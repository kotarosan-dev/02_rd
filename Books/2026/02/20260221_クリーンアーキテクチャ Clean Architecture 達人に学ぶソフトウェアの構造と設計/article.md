# クリーンアーキテクチャ Clean Architecture――達人に学ぶソフトウェアの構造と設計

## 1. 導入

ソフトウェアが「動く」ことと「良い構造を持つ」ことの間には、深い溝がある。多くのプロジェクトが初期には快調に進みながら、数年後にはフレームワークの変更やデータベースの移行が「事実上不可能」と宣告される状況に陥る。この現象は偶然ではなく、ソフトウェアの構造――すなわちアーキテクチャ――に対する投資の不足が生み出す必然的な帰結である。Robert C. Martinの『Clean Architecture』は、ソフトウェアアーキテクチャの目的を「変更のコストを最小化すること」と定義し、その実現のための原則と構造を体系的に論じた一冊である。SOLID原則、コンポーネントの原則、そして「依存性は内側に向かう」という同心円モデルを核心に据え、フレームワーク、データベース、UIといった「詳細（Details）」からビジネスルールという「方針（Policy）」を守り抜く設計思想を展開する。2017年の原著刊行以来、本書はソフトウェアアーキテクチャの必読文献として世界中の開発者に読み継がれている。

## 2. 著者紹介

Robert Cecil Martin（ロバート・セシル・マーティン、1952年12月5日生まれ）は、「Uncle Bob」の愛称で知られるアメリカのソフトウェアエンジニア・著述家・教育者である。1970年からソフトウェア開発に携わり、半世紀以上にわたるキャリアを持つ。1990年にObject Mentor社を設立し、ソフトウェア開発のコンサルティングと教育を提供してきた。2001年にはMartin Fowlerらとともにアジャイルマニフェストの起草・署名に参加した。

Martinの最大の貢献は、オブジェクト指向設計における5つの基本原則を「SOLID」というアクロニムに凝縮したことである。Single Responsibility Principle（単一責任原則）、Open-Closed Principle（開放閉鎖原則）、Liskov Substitution Principle（リスコフの置換原則）、Interface Segregation Principle（インタフェース分離原則）、Dependency Inversion Principle（依存性逆転原則）――これらの原則は、もはや個人の著作の一部ではなく、ソフトウェア工学の基礎教養として定着した。「Cleanシリーズ」として知られる著書群には、『Clean Code』（2008年）、『The Clean Coder』（2011年）、『Clean Architecture』（2017年）、『Clean Agile』（2019年）、『Clean Craftsmanship』（2021年）がある。現在はClean Coders LLCの共同創業者として、ビデオ教材を通じたソフトウェア職人技の普及に取り組んでいる。

---

## 書誌情報

- **書名**: Clean Architecture 達人に学ぶソフトウェアの構造と設計
- **原題**: Clean Architecture: A Craftsman's Guide to Software Structure and Design
- **著者**: Robert C. Martin（ロバート・C・マーティン）
- **訳者**: 角征典、高木正弘
- **出版社**: KADOKAWA（日本語版）、Prentice Hall（原著）
- **出版年**: 2018年（日本語版）、2017年（原著）
- **ISBN**: 978-4-04-893065-9（日本語版）、978-0-13-449416-6（原著）

---

## 3. 本書の概要

本書は全6部34章で構成される。第I部「イントロダクション」ではアーキテクチャの定義と目的を論じ、第II部「プログラミングパラダイム」では構造化プログラミング、オブジェクト指向プログラミング、関数型プログラミングの本質を「何を奪うか」という視点から再解釈する。第III部「設計の原則」ではSOLID原則を詳述し、第IV部「コンポーネントの原則」ではコンポーネントの凝集性と結合度に関する6つの原則を論じる。第V部「アーキテクチャ」が本書の核心であり、依存性の方向制御、境界線の引き方、そして同心円モデルとしてのクリーンアーキテクチャが提示される。第VI部は著者のキャリアから得た教訓を語る回顧録となっている。

本書の中心的主張は明快である。ソフトウェアアーキテクチャの目的は、システムの構築と保守に必要な人的リソースを最小化することである。そして、その実現手段は「方針（Policy）を詳細（Details）から分離し、依存性の方向を方針に向ける」ことである。フレームワーク、データベース、Webサーバ、UIフレームワーク――これらはすべて「詳細」であり、ビジネスルールという「方針」はこれらの詳細に依存すべきではない。依存の方向を逆転させることで、ビジネスルールはフレームワークの流行り廃りから保護される。

## 4. 重要な洞察①：SOLID原則の「アーキテクチャへの拡張」

本書が『Clean Code』と決定的に異なるのは、SOLID原則をクラスやモジュールの設計原則としてだけでなく、アーキテクチャレベルの設計原則として再定位した点にある。特に**依存性逆転原則（DIP）**がアーキテクチャの根幹を成す。

従来の理解では、DIPは「具象クラスではなくインタフェースに依存せよ」というクラス設計の指針であった。Martinはこれをアーキテクチャレベルに拡張し、「ソースコードの依存方向は、制御の流れとは逆に、抽象度の高い方針に向かうべきである」と再定義する。具体的には、UIコントローラがビジネスロジックのインタフェースに依存し、データベースアクセス層がビジネスロジックのインタフェースに依存する。ビジネスロジックは何にも依存しない。

この原則を徹底すると、「データベースの変更がビジネスロジックに影響しない」「UIフレームワークの変更がビジネスロジックに影響しない」という、直感に反するが強力なアーキテクチャが実現する。Martinは、これが「遅延決定（Deferred Decisions）」を可能にすると論じる。データベースをMySQL、PostgreSQL、MongoDB、あるいはフラットファイルのいずれにするかという決定を、プロジェクトの最終段階まで先送りできるアーキテクチャこそが、良いアーキテクチャなのである。

## 5. 重要な洞察②：同心円モデルと「叫ぶアーキテクチャ」

本書の象徴的な図が、「依存性の方向は内側に向かう」同心円モデルである。最内円には**エンティティ（Entities）**が位置し、企業全体のビジネスルールを表現する。次の円には**ユースケース（Use Cases）**が位置し、アプリケーション固有のビジネスルールを記述する。その外側に**インタフェースアダプタ（Interface Adapters）**が位置し、コントローラ、プレゼンター、ゲートウェイがデータ形式の変換を担う。最外円には**フレームワークとドライバ（Frameworks & Drivers）**が位置し、Web、データベース、UI等の技術的詳細が配置される。

この同心円モデルの核心は「依存性のルール（The Dependency Rule）」である。外側の円のコードは内側の円のコードを参照できるが、内側の円のコードは外側の円の存在を一切知らない。関数名、クラス名、変数名――外側の円で宣言されたいかなるものも、内側の円のコードの中で言及してはならない。

Martinはまた「叫ぶアーキテクチャ（Screaming Architecture）」という概念を提唱する。プロジェクトのディレクトリ構造を見たとき、それが「Spring Boot」や「Rails」ではなく「医療システム」や「会計システム」であることを叫ぶべきだ、という主張である。アーキテクチャはフレームワークではなくユースケースについて語るべきなのである。

## 6. 重要な洞察③：境界線（Boundaries）の引き方と「ハンブルオブジェクトパターン」

Martinは、アーキテクチャにおける最も重要な判断は「どこに境界線を引くか」であると論じる。境界線とは、変更の理由が異なるコンポーネント同士を分離する線であり、一方のコンポーネントの変更が他方に波及しないようにする防壁である。

この境界線の実現手法として、Martinは**ハンブルオブジェクトパターン（Humble Object Pattern）**を導入する。テストが困難なコード（UI描画、データベースアクセス、ネットワーク通信等）から、テスト可能なビジネスロジックを分離する手法である。たとえば、MVCにおけるPresenterは、Viewが描画すべきデータをすべてViewModelとして準備する。View自身はViewModelをそのまま描画するだけの「謙虚な」存在となり、すべてのロジックはテスト可能なPresenter側に移動する。

この分離により、ビジネスルールのテストにデータベースもWebサーバもUIフレームワークも不要になる。Martinは「テスト可能性はアーキテクチャの品質指標である」と断言する。テストが書きにくいコードは、アーキテクチャが良くないことの兆候なのである。

境界線の「厳格さ」にもグラデーションがある。同一プロセス内のソースレベルの分離（パッケージの依存方向の制御）から、デプロイメント単位の分離（JAR、DLL等）、さらにはサービスレベルの分離（マイクロサービス、SOA）まで、境界線の物理的な厚さはシステムの要求に応じて選択すべきである。重要なのは、初期段階で境界線を「引きすぎない」こと、そして後から境界線を追加できるようにソースレベルの依存方向を制御しておくことである。

## 7. 批判的考察

本書に対する批判として、まず**抽象度の高さに対する具体例の不足**が挙げられる。同心円モデルの原則は明快だが、「では実際にSpring Bootでどう実装するのか」「Reactとの組み合わせではディレクトリ構造をどう設計するのか」といった具体的なガイダンスは最小限にとどまる。原則は普遍的であるが、実装の現場で必要なのは原則と具体の橋渡しであり、この点で読者は別の参考資料を必要とする。

第二に、**「フレームワークは詳細」という主張の現実性**への疑問がある。理論的にはフレームワークからの独立が望ましいが、実務上、フレームワークを「ラップ」し「隠蔽」するためのアダプタ層のコストは無視できない。特に小規模なアプリケーションでは、このオーバーヘッドがもたらすコストが、フレームワーク独立のメリットを上回る場合がある。Martin自身も「すべてのアプリケーションにフルのクリーンアーキテクチャが必要なわけではない」と示唆しているが、この点のガイダンスは不十分である。

第三に、**回顧録パートの比重**について、一部の読者から「自伝的な逸話が多く、アーキテクチャの議論の密度が薄まる」という指摘がある。プログラミングの歴史的文脈を理解することには価値があるが、構造化プログラミングの誕生やオブジェクト指向の歴史に多くのページを割くことの投資対効果については議論の余地がある。

## 8. 実践への示唆

本書の原則は、以下の文脈で強力な実践的指針を提供する。

1. **プロジェクト初期のディレクトリ構造設計**: フレームワークの規約に従ったディレクトリ構造（controllers/、models/、views/）ではなく、ドメイン概念に基づくディレクトリ構造（orders/、customers/、invoices/）を採用する。「叫ぶアーキテクチャ」の原則に従い、ディレクトリ構造がビジネスドメインを語るようにする。

2. **依存性の方向チェック**: コードレビューにおいて、ソースコードの依存方向が「内側（ビジネスルール）に向かっているか」を確認する。ビジネスロジックのファイルがimport/requireしているモジュールの中に、フレームワーク固有のモジュール、データベースドライバ、HTTPライブラリが含まれていないかを検査する。

3. **テスト戦略の設計**: ビジネスルールのユニットテストが、データベース接続もHTTPサーバもなしに実行できるかを基準にアーキテクチャの品質を評価する。テストが遅い、セットアップが複雑、外部依存がモックだらけといった症状は、境界線の設計に問題があることを示す。

4. **段階的な境界導入**: 初期段階ではソースレベルの分離（パッケージの依存方向制御）にとどめ、必要に応じてデプロイメントレベルやサービスレベルの分離に進化させる。「最初からマイクロサービス」ではなく、「将来マイクロサービスに分割可能なモノリス」を目指す。

5. **「遅延決定」の実践**: データベースの種類、キャッシュ戦略、メッセージキューの選択といった技術的詳細の決定を可能な限り遅らせる。インタフェース（抽象）を先に定義し、具体的な技術選択を後から行えるアーキテクチャを構築する。

## 9. 結論

Robert C. Martinの『クリーンアーキテクチャ』は、ソフトウェアアーキテクチャの目的を「変更のコストの最小化」と明確に定義し、その実現手段としてSOLID原則のアーキテクチャレベルへの拡張、同心円モデルによる依存性の方向制御、境界線による関心事の分離を体系的に提示した書籍である。

本書の最大の強みは、原則の普遍性にある。特定のプログラミング言語やフレームワークに依存せず、「依存性は内側に向かう」「方針を詳細から分離する」「テスト可能性はアーキテクチャの品質指標である」といった原則は、あらゆる技術スタックに適用可能である。同時に、この普遍性は具体性の不足という裏面を持ち、実装の現場では読者自身による翻訳作業が必要となる。

本書を一冊の技術書としてだけでなく、ソフトウェア開発者の職業倫理を論じた書としても読むことができる。「動くコード」を書くことは最低条件であり、「将来の変更を安く行えるコード」を書くことこそがプロフェッショナルの責務である――この主張は、Martinの「Cleanシリーズ」全体を貫く一貫したメッセージであり、本書はその構造的側面を担う要の一冊として位置づけられる。ソフトウェアの構造設計に携わるすべての開発者にとって、少なくとも一度は通過すべき書籍である。

---

## 参考文献

- Martin, R. C. (2017). *Clean Architecture: A Craftsman's Guide to Software Structure and Design*. Prentice Hall.
- Martin, R. C. (2008). *Clean Code: A Handbook of Agile Software Craftsmanship*. Prentice Hall.
- Martin, R. C. (2002). *Agile Software Development: Principles, Patterns, and Practices*. Prentice Hall.
- Fowler, M. (2002). *Patterns of Enterprise Application Architecture*. Addison-Wesley.
- Cockburn, A. (2005). "Hexagonal Architecture." *alistair.cockburn.us*.

---

**⚠️ AIによる執筆支援について**
本記事はAI（LLM）による執筆支援を使用しています。参考文献・書誌情報については可能な限り検証を行っていますが、誤りが含まれる可能性があります。正確な情報は原著や一次資料をご確認ください。
