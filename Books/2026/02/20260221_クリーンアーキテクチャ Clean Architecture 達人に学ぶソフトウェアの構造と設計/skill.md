---
name: clean-architecture-design-principles
description: Robert C. Martinの『クリーンアーキテクチャ』に基づくソフトウェア構造設計の原則とフレームワーク。SOLID原則、コンポーネントの原則、同心円モデル、依存性ルールを通じて、テスト可能・保守可能・変更容易なアーキテクチャを設計する。
---

# クリーンアーキテクチャ：ソフトウェア構造設計の原則

## 概要

Robert C. Martinが提唱する「クリーンアーキテクチャ」は、ソフトウェアの構造設計において「方針（Policy）を詳細（Details）から分離し、依存性の方向を方針に向ける」ことで、テスト可能・保守可能・変更容易なシステムを実現するための設計原則体系。SOLID原則、コンポーネントの原則、同心円モデルの三段階で構成される。

## 使用場面（When to Use）

- 新規プロジェクトのアーキテクチャ設計を行うとき
- 既存システムの保守コストが増大し構造改善が必要なとき
- フレームワークやデータベースの変更可能性を確保したいとき
- テスト戦略を改善し、ビジネスロジックのテスト容易性を高めたいとき
- コードレビューで依存方向の妥当性を検証するとき
- 「モノリスから将来的にマイクロサービスへ」の移行パスを設計するとき

## 核心原則：アーキテクチャの目的

> **ソフトウェアアーキテクチャの目的は、システムの構築と保守に必要な人的リソースを最小化することである。**

**方針と詳細の分離:**

| 分類 | 定義 | 具体例 |
|------|------|--------|
| **方針（Policy）** | ビジネスルール、ドメインロジック | 注文の合計金額計算、与信審査ルール、在庫引当ロジック |
| **詳細（Details）** | 方針の実現手段、技術的選択 | データベース（MySQL/PostgreSQL/MongoDB）、Webフレームワーク（Spring/Rails）、UI（React/Vue） |

**原則**: 方針は詳細に依存してはならない。詳細が方針に依存すべきである。

## フレームワーク：三層構造

### Layer 1: SOLID原則（クラス・モジュール設計）

| 原則 | 正式名称 | 要旨 | アーキテクチャレベルの意味 |
|------|---------|------|------------------------|
| **S** | Single Responsibility Principle | 変更の理由は一つだけ | コンポーネントの変更理由を単一に保つ |
| **O** | Open-Closed Principle | 拡張に開き、修正に閉じる | 新機能追加が既存コードの修正を要求しない設計 |
| **L** | Liskov Substitution Principle | 派生型は基底型と置換可能 | インタフェースの契約を守るアダプタ設計 |
| **I** | Interface Segregation Principle | 使わないメソッドに依存させない | コンポーネント間のインタフェースを必要最小限に |
| **D** | Dependency Inversion Principle | 抽象に依存し、具象に依存しない | **アーキテクチャの根幹**: 依存方向を方針に向ける |

**DIPのアーキテクチャ適用:**
```
[UI Controller] → <<interface>> → [Use Case]
[DB Repository実装] → <<interface>> → [Use Case]

ビジネスロジック（Use Case）は何にも依存しない
UIとDBがビジネスロジックのインタフェースに依存する
```

### Layer 2: コンポーネントの原則

**凝集性の原則（何をまとめるか）:**

| 原則 | 意味 | 判断基準 |
|------|------|---------|
| **REP（再利用・リリース等価の原則）** | 再利用の単位はリリースの単位 | 一緒にリリースされるものはまとめる |
| **CCP（閉鎖性共通の原則）** | 同じ理由で変更されるクラスをまとめる | SRPのコンポーネント版 |
| **CRP（全再利用の原則）** | 一緒に使われないクラスはまとめない | 不要な依存を避ける |

**結合度の原則（コンポーネント間の関係）:**

| 原則 | 意味 | 実践 |
|------|------|------|
| **ADP（非循環依存関係の原則）** | 依存グラフに循環を作らない | 依存方向を一方向に保つ |
| **SDP（安定依存の原則）** | 安定しているコンポーネントの方向に依存する | 変更頻度の低い方に依存 |
| **SAP（安定度・抽象度等価の原則）** | 安定したコンポーネントは抽象的であるべき | 安定 = 抽象（インタフェース中心） |

### Layer 3: 同心円モデル（クリーンアーキテクチャ本体）

```
┌─────────────────────────────────────┐
│  Frameworks & Drivers（最外層）       │
│  Web, DB, UI, Devices, External I/F  │
│  ┌─────────────────────────────┐    │
│  │  Interface Adapters          │    │
│  │  Controllers, Presenters,   │    │
│  │  Gateways                    │    │
│  │  ┌─────────────────────┐    │    │
│  │  │  Use Cases           │    │    │
│  │  │  Application         │    │    │
│  │  │  Business Rules      │    │    │
│  │  │  ┌─────────────┐    │    │    │
│  │  │  │  Entities    │    │    │    │
│  │  │  │  Enterprise  │    │    │    │
│  │  │  │  Business    │    │    │    │
│  │  │  │  Rules       │    │    │    │
│  │  │  └─────────────┘    │    │    │
│  │  └─────────────────────┘    │    │
│  └─────────────────────────────┘    │
└─────────────────────────────────────┘

依存の方向 → 常に内側に向かう
```

**各層の役割:**

| 層 | 内容 | 含まれるもの | 変更頻度 |
|----|------|------------|---------|
| **Entities** | 企業全体のビジネスルール | ドメインオブジェクト、ビジネスルール | 最も低い |
| **Use Cases** | アプリケーション固有のビジネスルール | ユースケースインタラクタ、入出力境界 | 低い |
| **Interface Adapters** | データ形式の変換 | Controller、Presenter、Gateway、ViewModel | 中程度 |
| **Frameworks & Drivers** | 技術的詳細 | Web、DB、UI、外部API | 最も高い |

**依存性ルール（The Dependency Rule）:**
- 外側の円のコードは内側の円を参照できる
- 内側の円のコードは外側の円の存在を一切知らない
- 内側の円で宣言された名前だけが内側のコードで使用される
- 制御の流れが依存の方向と逆になる場合はDIPで解決する

## 具体的な実行手順

### Step 1: エンティティの定義
1. ビジネスドメインの核心概念を特定する
2. ドメインオブジェクトとビジネスルールを定義する
3. 外部依存（フレームワーク、DB、UI）を一切含めない
4. 純粋な言語機能のみでエンティティを実装する

### Step 2: ユースケースの定義
1. アプリケーションが提供する機能をユースケースとして列挙する
2. 各ユースケースの入力データ構造（Input Boundary）を定義する
3. 各ユースケースの出力データ構造（Output Boundary）を定義する
4. ユースケースインタラクタを実装する（エンティティのみに依存）

### Step 3: インタフェースアダプタの設計
1. Controller: 外部リクエスト → ユースケースの入力形式に変換
2. Presenter: ユースケースの出力 → UIの表示形式（ViewModel）に変換
3. Gateway: ユースケースが要求するデータアクセスインタフェースの実装
4. 依存方向が内側を向いていることを確認する

### Step 4: フレームワーク・ドライバの配線
1. Webフレームワーク（Spring Boot、Express等）の設定
2. データベースアクセスの具象実装（JPA、TypeORM等）
3. DIコンテナによる依存性の注入設定
4. エントリポイント（main関数）ですべてを組み立てる

### Step 5: 依存方向の検証
1. ビジネスロジック（Entities/Use Cases）のimport文を確認
2. フレームワーク固有のクラス/モジュールがimportされていないことを確認
3. ビジネスロジックのテストがDB・Web・UIなしで実行できることを確認
4. アーキテクチャテスト（ArchUnit等）で依存方向を自動検証する

## 実践パターン

### ハンブルオブジェクトパターン（Humble Object Pattern）
テストが困難な部分（UI描画、DB接続等）を「謙虚な」薄いラッパーにし、ロジックをテスト可能な側に移動する。

| テスト困難な側（Humble） | テスト容易な側 |
|------------------------|-------------|
| View（HTMLレンダリング） | Presenter（ViewModel生成） |
| Database（SQL実行） | Gateway Interface実装 |
| Web（HTTPハンドリング） | Controller（入力変換） |

### 叫ぶアーキテクチャ（Screaming Architecture）
ディレクトリ構造がフレームワークではなくビジネスドメインを語るべきである。

**悪い例（フレームワーク中心）:**
```
src/
├── controllers/
├── models/
├── views/
├── services/
└── repositories/
```

**良い例（ドメイン中心）:**
```
src/
├── orders/
│   ├── entities/
│   ├── use-cases/
│   ├── adapters/
│   └── infrastructure/
├── customers/
│   ├── entities/
│   ├── use-cases/
│   ├── adapters/
│   └── infrastructure/
└── invoices/
    ├── entities/
    ├── use-cases/
    ├── adapters/
    └── infrastructure/
```

### 境界線の厳格さのグラデーション

| レベル | 分離方法 | コスト | 適用場面 |
|-------|---------|-------|---------|
| **ソースレベル** | パッケージの依存方向制御 | 低 | 初期段階、小規模プロジェクト |
| **デプロイメントレベル** | JAR/DLL/npm packageとして分離 | 中 | 中規模、チーム分離 |
| **サービスレベル** | 独立プロセス、ネットワーク通信 | 高 | 大規模、マイクロサービス |

**推奨**: まずソースレベルの分離から始め、必要に応じて段階的に引き上げる。

## 遅延決定（Deferred Decisions）チェックリスト

良いアーキテクチャでは以下の決定を遅延できる:
- [ ] データベースの種類（RDB/NoSQL/ファイル）
- [ ] Webフレームワークの選択
- [ ] UIフレームワークの選択
- [ ] キャッシュ戦略
- [ ] メッセージキューの選択
- [ ] 認証ライブラリの選択
- [ ] ログ基盤の選択

## 関連アーキテクチャとの対応

| 名称 | 提唱者 | クリーンアーキテクチャとの関係 |
|------|--------|--------------------------|
| **ヘキサゴナルアーキテクチャ** | Alistair Cockburn | Ports & Adaptersの概念が同心円モデルと対応 |
| **オニオンアーキテクチャ** | Jeffrey Palermo | 層の同心円構造と依存方向が一致 |
| **DDD（ドメイン駆動設計）** | Eric Evans | Entityの概念、ドメイン中心の設計思想が共通 |
| **PoEAA** | Martin Fowler | Repository、Service Layer等のパターンが対応 |

## 注意点

- すべてのアプリケーションにフルのクリーンアーキテクチャが必要なわけではない
- 小規模アプリケーションではオーバーエンジニアリングになるリスクがある
- 原則は普遍的だが、具体的な実装は言語・フレームワークに応じて翻訳が必要
- 「フレームワーク独立」の追求は、フレームワークの利便性を犠牲にするトレードオフを伴う
- 最初から完璧な境界線を引こうとせず、段階的に進化させるアプローチが現実的
