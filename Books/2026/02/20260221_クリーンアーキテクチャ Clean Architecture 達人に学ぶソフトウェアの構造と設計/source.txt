Clean Architecture

クリーンアーキテクチャ Architecture

達人に学ぶソフトウェアの構造と設計

Robert C. Martin 角征典、 高木正弘 訳

アーキテクチャの

ルールはどれも

同じである!

ASCII

DWANGO

アジャイルソフトウェア達人の技

Clean Code

Robert C. Martin 著 花井志生訊 定価(本体3,800円+税)

アジャイルソフトウェア達人の

Clean

Code

クリーンコード

コードを書き、

読み、

洗練する

1

Clean Coder

プロフェッショナルプログラマへの道

Robert C. Martin 角征典訊: 定価(本体2,000円+税)

Clean

| クリーンコーダー

Coder

プロフェッショナルプログラマへの道

ソフトウェアの

プロになるには 本書が必要だ!

Clean Architecture

クリーンアーキテクチャ Clean Architecture 達人に学ぶソフトウェアの構造と設計

Robert C. Martin 角征典、 高木正弘 訳

ASCII

DWANGO

本文中に記載されている社名および商品名は、一般に開発メーカーの登録商標です。 なお、本文中ではTM・表示を明記しておりません。

商標

Clean Architecture

A CRAFTSMAN'S GUIDE TO SOFTWARE STRUCTURE AND DESIGN

Robert C. Martin

PRENTICE HALL

Boston Columbus Indianapolis New York San Francisco Amsterdam Cape Town Dubai London Madrid Milan Munich Paris Montreal Toronto Delhi Mexico City São Paulo Sydney Hong Kong Seoul Singapore Taipei Tokyo

Copyright

Authorized translation from the English language edition, entitled CLEAN ARCHITECTURE: A CRAFTS MAN'S GUIDE TO SOFTWARE STRUCTURE AND DESIGN, 1st Edition. by MARTIN, ROBERT C. published by Pearson Education, Inc. publishing as Prentice Hall, Copyright © 2017. All rights reserved. No part of this book may be reproduced or transmitted in any form or by any means, electronic or mechanical, including photocopying, recording or by any information storage retrieval system, without permission from Pearson Education, Inc.

JAPANESE language edition published by DWANGO CO. LTD. Copyright © 2018.

Japanese translation rights arranged with PEARSON EDUCATION, INC. through JAPAN UNI AGENCY. INC. TOKYO JAPAN.

本書は、米国 Pearson Education, Inc. との契約に基づき、 株式会社ドワンゴが翻訳、 出版したものです。

本書は、 私の愛すべき妻、4人のすばらしい子どもたちとその家族、 (私の人生のデザートである) 5人の孫たちに捧げる。



目次

目次

まえがき

19

序文

謝辞

23

著者について

27

29

第Ⅰ部 イントロダクション 31

第1章 設計とアーキテクチャ

33

目的は?

ケーススタディ

アーキテクチャの戦い

34

34

40

まとめ

第2章 2つの価値のお話

41

振る舞い

大きな価値

アイゼンハワーのマトリックス

41

アーキテクチャ

42

43

43

45

7

目次

第II部 構成要素から始めよ : プログラミング

パラダイム 47

49

第3章 パラダイムの概要

構造化プログラミング

オブジェクト指向プログラミング

関数型プログラミング

49

50

50

考えるべきこと

まとめ

第4章 構造化プログラミング

51

證明

51

53

有害宣言

機能分割

正式に証明できない

救済のための科学

テスト

58

まとめ

25 56 57

第5章 オブジェクト指向プログラミング

カプセル化とは?

59

54

55

56

2938 60 62

水とは?

まとめ

第6章 関数型プログラミング

71

整数の二乗

不変性とアーキテクチャ

可変性の分離

71

73

73

56

ポリモーフィズムとは?

65

70

8

イベントソーシング まとめ

76

77

第III部 設計の原則

第7章 SRP: 単一責任の原則

症例1 想定外の重複

81

症例2:マージ

解決策

まとめ

まとめ

82

84

84

86

第8章 OCP:オープン・クローズドの原則

87

思考実験。 方向の制御 情報隱蔽 まとめ 88 91 91 92

第9章 LSP:リスコフの置換原則

93

継承の使い方の指針 93 正方形 長方形問題 94 リスコフの置換原則 (LSP) とアーキテクチャ リスコフの置換原則 (LSP) 違反の例 95 96

第10章 ISP: インターフェイス分離の原則

97

99

インターフェイス分離の原則 (ISP) と言語との関係 100 インターフェイス分離の原則 (ISP) とアーキテクチャとの関係 101

まとめ

101

9

目次

75

103

第11章 DIP: 依存関係逆転の原則

安定した抽象

Factory

具象コンポーネント

まとめ

リンカ

104

105

106

106

第IV部 コンポーネントの原則・

107

第12章 コンポーネント

コンポーネントの簡単な歴史

リロケータビリティ (再配置可能性)

110

まとめ

109

第13章 コンポーネントの凝集性

112

113

再利用 リリース等価の原則 (REP)

閉鎖性共通の原則 (CCP)

117

全再利用の原則 (CRP)

118

119

120

コンポーネントの凝集性のテンション図 まとめ

第14章 コンポーネントの結合

非循環依存関係の原則 (ADP)

114

トップダウンの設計

安定依存の原則 (SDP)

安定度 抽象度等価の原則 (SAP)

まとめ

121

123

125

125

131

132

138

143

目次

10 10

目次

145

第V部 アーキテクチャ

第15章 アーキテクチャとは?

147

開発

運用

独立した開発が可能

独立デプロイ可能性 重複

148

デプロイ

保守

149

選択肢を残しておく

149

150

151

デバイス非依存

ダイレクトメール

物理アドレス

まとめ

第16章 独立性

152

154

155

156

ユースケース

運用

開発

デプロイ

選択肢を残しておく

レイヤーの切り離し

ユースケースの切り離し

切り離し方式

切り離し方式 (再び) まとめ

結合の悲しい物語

168 188

157

157

159

158

159

159

160

161

161

162

162

162

第17章 バウンダリー: 境界線を引く

163

165

167

11

FitNesse

170

172

あなたの境界線は何か? いつ境界線を引くのか?

入力と出力はどうする?

プラグインアーキテクチャ

プラグインの戦い

174

第18章 境界の解剖学

175

176

まとめ

177

179

179

境界を越える

恐怖のモノリス

デプロイコンポーネント

スレッド

ローカルプロセス

180

182

サービス

182

まとめ

182

183

第19章 方針とレベル

レベル

まとめ

第20章 ビジネスルール

エンティティ

184

ユースケース

リクエストとレスポンスのモデル まとめ

第21章 叫ぶアーキテクチャ

185

186 188

189

190

191

192

アーキテクチャのテーマ

193

アーキテクチャの目的

195

だが、ウェブはどうか?

196

196

196

目次

12

目次

197

197

フレームワークはツールであり、 生き方ではない テスト可能なアーキテクチャ まとめ

198

199

第22章 クリーンアーキテクチャ

依存性のルール

典型的なシナリオ まとめ

201

204

205

第23章 プレゼンターと Humble Object

Humble Object パターン

プレゼンターとビュー

テストとアーキテクチャ

207

データベースゲートウェイ

207

データマッパー

208

209

サービスリスナー まとめ

第24章 部分的な境界

210

211

最後のステップを省略する

209

片方だけの境界

209

210

212

Facade.

212

213

213

まとめ

第25章 レイヤーと境界

Hunt the Wumpus

クリーンアーキテクチャ?

215

流れを横切る

215

217

流れを分割する

まとめ

219

219

221

13

目次

223

第26章 メインコンポーネント

究極的な詳細

まとめ

第27章 サービス: あらゆる存在

サービスアーキテクチャ?

サービスのメリット?

223

227

229

229

子猫の問題

救世主のオブジェクト

231

コンポーネントベースのサービス

横断的関心事 まとめ

第28章 テスト境界

230

233

234

235

236

システムコンポーネントとしてのテスト

テスト容易性のための設計

テスト API

まとめ

第VI部 詳細

237

237

238

第29章 クリーン組込みアーキテクチャ

239

240

241

適性テスト

ターゲットハードウェアのボトルネック

まとめ

243

246

256

第30章 データベースは詳細

257

259

14

目次

リレーショナルデータベース

260

260

なぜデータベースシステムが普及しているのか?

もしもディスクがなかったら?

詳細

だけど、 パフォーマンスはどうなの?

小話

まとめ

261

262

262

263

264

第31章 ウェブは詳細

止まらない振り子

結論

265

まとめ

第32章 フレームワークは詳細

フレームワークの作者たち

267

266

268

269

一方的な結婚

リスク

解決策

今あなたたちを夫婦として宣言する まとめ

269

270

270

271

272

272

第33章 事例: 動画販売サイト

273

プロダクト

ユースケース分析

コンポーネントアーキテクチャ 依存性管理 まとめ

第34章 書き残したこと

273

274

275

277

277

レイヤーによるパッケージング

279

280

15

機能によるパッケージング

281

ポートとアダプター

コンポーネントによるパッケージング

283

289

悪魔は実装の詳細に宿る 組織化かカプセル化か

285

290

そのほかの分割方法

292

まとめ 言い残したこと

第VII部 付録

294

295

付録A アーキテクチャ考古学

組合の会計システム

レーザーカット

アルミダイキャストの監視

297

297

4-Tel

サービスエリアコンピュータ

304

C言語

BOSS

PCCU

317

DLU/DRU

VRS

316

電子受付

318

319

転送システムの作成

307

312

321

323

明確なコミュニケーション

308

ROSE

325

327

アーキテクト登録試験

まとめ

あとがき

329

331

333

335

訳者あとがき

339

目次

16

訳者について

目次

341

索引

343

17



まえがき

アーキテクチャについて話すとき、 我々は何を話すのだろうか?

あらゆるメタファーがそうであるように、 ソフトウェアをアーキテクチャの観点から説明す ると、明らかになることと同じだけ、明らかにできないことが生まれてしまう。 また、提供で きる以上のことを約束し、 約束した以上のことを提供することになるだろう。

アーキテクチャの魅力は構造だ。 構造はソフトウェア開発のパラダイムであり、 話題の中心 である (コンポーネント、 クラス、 関数、 モジュール、レイヤー、サービス、マイクロなんと か)。 だが、 多くのソフトウェアシステムの全体構造は、 信念や理解を不可能にしてしまう。 た とえば、いずれ消え去る運命にあるソビエト帝国の計画、 雲に届くほどあり得ない高さのジェ ンガタワー、「大きな泥だんご」に埋まっている考古学的な地層。 建物の構造と同じように、 ソ フトウェアの構造も我々の直感に従っている。 だが、 そのことはそれほど明らかにはなってい ない。

建物であれば、それが石だろうがコンクリートだろうが、 縦に高かろうが横に長かろうが、 巨大だろうが狭小だろうが、壮大だろうが平凡だろうが、明らかに物理的な構造を持っている。 建物の構造は、物理的な重力と材料に配慮すること以外、それほど選択肢は残されていない。 一方、ソフトウェアは (深刻な場合を除き) 重力に配慮することはない。 ソフトウェアは何で 作られているのだろうか? レンガ、コンクリート、木材、スチール、 ガラスからできた建物 とは異なり、ソフトウェアはソフトウェアで作られている。 大規模なソフトウェアは小規模な ソフトウェアから作られ、 小規模なソフトウェアはさらに小規模のソフトウェアコンポーネン トから作られている。 コーディングにおける「親亀の背中に子亀を乗せて、 子亀の背中に孫亀 乗せて、孫亀の背中にひ孫亀乗せて･･････」 である。

ソフトウェアアーキテクチャについて言及すると、ソフトウェアは本質的に再帰的でフラク タルなので、コードによってすべてが描き出されていく。 すべては詳細である。 建物のアーキ テクチャにも詳細のレベルの連鎖は存在する。 だが、 ソフトウェアにおいて物理的なことを話 しても意味がない。 ソフトウェアにも構造はある。 構造の数も種類も多い。 そうした多様性に よって、建物に見られる物理的構造が覆い隠されている。 したがって、 建物よりもソフトウェ アのほうが設計活動も集中も必要になるはずだと、 かなりもっともらしく主張できるだろう。 その意味では、ソフトウェアのアーキテクチャを建物のアーキテクチャよりも構造的であると 考えるのは、あながち間違っているとは言えない!

だが、 人間は物理的な尺度で理解して追求しようとする。 PowerPoint の四角形は、見た目に

19

は明らかではあるものの、ソフトウェアシステムのアーキテクチャではない。 アーキテクチャ の一部であることは確かだが、四角形を全体像 (アーキテクチャ) だと思ってしまうと、 本当 の全体像やアーキテクチャを見失ってしまう。 ソフトウェアアーキテクチャは見えない。 可視 化されたものは選択肢であり、最初から与えられるものではない。選択肢はさらに複数の選択 肢 ( 何を含めるのか、 何を外すのか、形や色で何を強調するのか、 一貫性や省略によって何を 強調しないのか) から成り立っている。 いずれのビューにも特性や本質はない。

ソフトウェアアーキテクチャを物理的あるいは物理的尺度で語ることに意味はないが、 特定 の物理的制約については配慮する必要がある。 プロセッサの速度とネットワークの帯域は、シ ステムのパフォーマンスに大きな影響を与える。 メモリとストレージは、コードベースの野望 を制限する可能性がある。 ソフトウェアは夢のようなものかもしれないが、 物理的な世界で動 作しているのだ。

恋のおそろしい化け物とは、 意欲は無限だが実行は有限、 欲する心ははてしないがおこなうには限度 がある。

-William Shakespeare 「トロイラスとクレシダ」 (白水社) より引用

. . 物理的な世界とは、 我々 企業 経済が生きている場所である。 ここから、ソフトウェアアー キテクチャを理解するためのもうひとつの計器が手に入る。 それは、物理的な力や量が少なく、 我々がそのことについて話したり、論拠にしたりすることができるものだ。

アーキテクチャは、システムを形作る重要な設計決定を表したものである。 ここでの重要性は、 変更 コストによって計測できる。

Grady Booch

時間とお金と労力によって、 我々は大規模なものと小規模なものを並び替えることができる。 それにより、 アーキテクチャとそれ以外を区別できる。 この指標は、アーキテクチャの善し悪 しの判断にも使える。 優れたアーキテクチャは、 特定の時点でユーザー 開発者・所有者のニー ズを満たすだけでなく、 これから先もニーズを満たし続けることのできるものである。

優れたアーキテクチャのコストが高いと思うなら、劣ったアーキテクチャにすればいい。

システム開発で典型的に直面する変更は、コストが高く、 変更が難しく、数日や数週間で終 わらないプロジェクト型の変更であってはいけない。

まえがき

Brian Foote and Joseph Yoder

20

まえがき

このことは、あまり小さくはない、 物理的な問題につながっていく。 「時間旅行」 だ。 典型 的な変更が重要な意思決定につながるかどうかについて、 どのように把握すればいいのだろう か? 水晶玉やタイムマシンを持たずに、 どうすれば将来の開発工数やコストを減らせるのだ ろうか?

アーキテクチャはプロジェクトの初期段階に決定したいと思うものだが、必ずしも他より適切なも のになるとは限らない。

-Ralph Johnson

過去を理解するのはそれほど難しいことではない。 現在を理解するのは確実なことではない。 将来を予測するのは簡単なことではない。

ここからさまざまな分岐点が生まれる。

最も暗い道のりでは、権威と硬直性から堅牢で安定したアーキテクチャが生まれるとされて いる。 変更のコストは高く、 変更することは許されない。 それにより、 勢いのない官僚的な排 水口へと進むことになる。 アーキテクトの任務は全般に渡り、 全体主義的なものである。 アー キテクチャは開発者のディストピアとなり、 あらゆる人の不満の原因になるだろう。 もうひとつの暗い道のりでは、 よくある危険な臭いがする。 ハードコーディングされた当て 推量、無数のパラメータ、 死んだコードの墓場、意図しない複雑さにより、 保守の予算が枯渇

しそうである。

我々が興味を持っているのは、最もクリーンな道のりである。 ソフトウェアがソフト (柔軟 ) であることを認め、 それをシステムで最優先すべき財産として保持することを目指している。 不完全な知識で運用する可能性があることも認めながら、 そうするのが人間であり、 人間はそ れが得意であることを理解している。 我々の弱みよりも強みを生かしてくれる。 我々は物を作 り、発見する。 我々は質問し、 実験する。 優れたアーキテクチャとは、それが目的地ではなく 旅路であること、凍結された成果物ではなく進行形の探索プロセスであることを理解するとこ ろから生まれる。

アーキテクチャは、 実装と計測によって証明すべき仮説である。

-Tom Gilb

この道を進むには、配慮と注目、 思考と観察、実践と原則が必要になる。 これだと遅くなる ように思えるかもしれないが、これがあなたの歩む道のりである。

221

まえがき

速く進む唯一の方法は、うまく進むことである。

-Robert C. Martin

それでは、よい旅を。

2017年5月 Kevlin Henney

22

序文

本書のタイトルは 「Clean Architecture』。 何とも厚かましい名前だ。 傲慢であるとさえ言え るだろう。 さて、 私はなぜこのタイトルを選び、そして書こうと考えたのか?

生まれてはじめてコードを書いたのは1964年。 12歳の頃だった。 今は2016年なので、かれ これ半世紀以上にわたってコードを書いていることになる。 その間、 ソフトウェアシステムを 構築する方法について、 いくつか学んだことがある。 きっとそれは、他の人たちにとっても有 用なものだろう。

半世紀以上にわたり、 大きなものから小さなものまで数多くのシステムを構築してきた。そ のなかには、小さな組込みシステムもあれば大規模なバッチ処理もあった。 リアルタイムシス テムもあればウェブシステムもあった。 コンソールアプリ、 GUIアプリ、 プロセス制御アプリ、 ゲーム、 会計システム、 電気通信システム、 設計ツール、ドローイングアプリ、その他にもい ろいろと作ったものだ。

シングルスレッドアプリもマルチスレッドアプリもあった。 少数の巨大なプロセスからなる アプリもあれば、 多数の軽量なプロセスからなるアプリもあった。 マルチプロセッサアプリ、 データベースアプリ、 数学のアプリ、 計算機科学のアプリなどにも関わった。

本当に多くのアプリを作ってきたし、 多くのシステムを構築してきた。 そして、 それらすべ ての経験からとても重要なことを学んだ。

アーキテクチャのルールはどれも同じである!

今までに作ってきたシステムがどれも根本的に異なるものであることを考えると、これは驚 くべきことだ。 まったく違うシステムなのに、なぜ同じアーキテクチャのルールに従っている のだろうか? 私が思うに、 ソフトウェアアーキテクチャのルールはその他すべての変数から 独立しているのだろう。

この半世紀でハードウェアがどれほど進化したかを考えると、この事実はさらに驚きを増す。 私がプログラムを書き始めた頃のマシンは、冷蔵庫と同じくらいの巨大なもので、クロック周 波数は0.5MHz, コアメモリは4K、 ディスクは32K、 秒間10文字のテレタイプインターフェイ スだった。 私は今この文章を、 南アフリカでの旅行中のバスのなかで書いている。 MacBook に 搭載されているのは4コアのi7。 それぞれ 2.8GHz だ。 RAM は16GB、 テラバイト単位のSSD、 2880 × 1800 の RetinaディスプレイにはHD動画を映し出せる。 計算能力の違いは驚異的だ。

23

計算してみればわかるが、このMacBook は半世紀前のコンピュータより少なくとも1022倍は 強力になっている。

22桁の違いは膨大だ。この数は、地球からアルファケンタウリまでのオングストローム単位 での距離に匹敵する。 また、 あなたの手元にあるコインに含まれる電子の数もそれくらいだ。 私の人生において経験した計算能力の増加は、少なくともこれくらいになる。

さて、この計算能力の変化は、私が書くソフトウェアにどのような影響を及ぼしているのだ ろう? 確かにソフトウェアのサイズは大きくなっている。 かつては2,000 行のプログラムを 見れば 「大きいなあ」 と思っていたものだ。 実際それは、箱一杯につまったカードで10ポンド (4.5kg)ほどの重さになった。 今となっては、少なくとも10万行くらいにならないと大規模だ とは言われない。

ソフトウェアのパフォーマンスも向上した。 1960年代には夢にも思わなかったことを実現で きるようになっている。 「地球爆破作戦」 「月は無慈悲な夜の女王」 「2001年宇宙の旅」 といっ た作品が想像していた未来の姿は、 いま見るとまったくの的外れだ。 これらの作品が描いたの は、巨大な機械が感情を持つようになる世界だった。 いま我々の目の前にあるのは、とても小 さな機械。 感情を持つわけでもなく、 機械のままだ。

現代のソフトウェアを過去のものと比べて気づくことがもうひとつある。 使われている素材 は今も昔も変わっていない。 if 文や代入文や while ループなどが同じように使われている。

いまどきの言語やパラダイムのほうがずっと優れているじゃないかと言う人もいるだろう。 我々には Java や C#や Ruby があるし、 オブジェクト指向設計だって使える。 確かにそうだが、 実際に書いているコードは「順次」 「選択」 「反復」 の組み合わせに過ぎず、 これは50年代や60 年代から何も変わっていない。

プログラミングのプラクティスをよくよく見れば、この50年でほとんど変わっていないこと がわかる。 プログラミング言語は多少マシになったし、 開発ツールはとても便利になった。 で も、コンピュータプログラミングの構成要素は変わってい

1966年のプログラマを現代に呼び、 IntelliJ を立ち上げた MacBook を渡してJava のコード を見せたとしよう。 彼女はショックから立ち直るのに24時間を要するかもしれない。でも、 いったん立ち直れば、普通にコードを書けるようになるだろう。 Java は Cみたいなものだし、 Fortran と比べてもそんなに違いはない。

逆にあなたが1966年にさかのぼったとしよう。 パンチカードと秒間10文字のテレタイプを 使って、 PDP-8 のコードを書く方法を教わったあなたは、 絶望から立ち直るのに24時間を要 するかもしれない。 でも、いったん立ち直れば、 普通にコードを書けるようになるだろう。 書 いているコードは今とそんなに違いはない。

おそらく女性だろう。というのも、当時のプログラマは大半が女性だったからだ。

序文

24

序文

ここがポイントだ。 書いているコードが変わらないのだから、 どんな種類のシステムでもソ フトウェアアーキテクチャのルールは同じ。 ソフトウェアアーキテクチャのルールとは、プロ グラムの構成要素をどのように組み立てるかのルールである。 構成要素は普遍的で変わらない のだから、それらを組み立てるルールもまた、 普遍的で変わらないのである。

若いプログラマは 「そんなわけがない」 と言うかもしれない。 昔は昔、 今は今。 過去のルール が今でも通用するわけがないと思うのだろう。もしそう考えているのなら、残念ながら間違っ ている。ルールは何も変わっていない。 言語やフレームワークやパラダイムがまったく新しい ものに変わったところで、ルール自体は Alan Turing が最初のマシンコードを書いた1946年 と同じままだ。

でも、ひとつだけ変わったことがある。 かつての我々は、そのルールがどんなものかを知らな かった。 そのせいで、 何度となくルールを破ってきた。 今は違う。 半世紀の経験を経て、 我々 はようやくルールをつかんだ。

時代を超越した不変のルールたち。 それこそが本書のすべてだ。

25



謝辭

本書の執筆に協力してくれた方々を紹介する (順不同)。

Chris Guzikowski

Chris Zahn

Matt Heuser

Jeff Overbey

Micah Martin

Justin Martin

Carl Hickman

James Grenning

Simon Brown

Kevlin Henney

Jason Gorman

Doug Bradbury

Colin Jones

Grady Booch

Kent Beck

Martin Fowler

Alistair Cockburn

James O. Coplien

Tim Conrad

Richard Lloyd

Ken Finder

Kris lyer (CK)

Mike Carew

Jerry Fitzpatrick

Jim Newkirk

Ed Thelen

Joe Mabel

Bill Degnan

ここには挙げきれないが、 他にも多くの協力があった。 執筆中に第21章 「叫ぶアーキテクチャ」 を読み返していると、 Jim Weirich の温かい笑顔と 笑い声が頭に浮かんだ。 安らかに眠るんだよ、 Jim!

27 22



著者について

Robert C. Martin (アンクル・ボブ)は1970年からプログラマである。 cleancoders.com の 共同創業者であり、ソフトウェア開発者向けの学習用動画をオンラインで提供している。また、 Uncle Bob Consulting LLC. を設立し、 世界中の大企業を対象としたソフトウェアコンサル ティング、トレーニング、スキル開発を行っている。 シカゴに本拠地を置くコンサルティング ファーム 8th Light, Inc. では、 Master Craftsman を務めていた。 さまざまな業界誌に寄稿し、 国際的なカンファレンスや展示会でも頻繁に講演している。 「C++ Report」 の編集長を3年間 務め、 Agile Alliance の初代委員長でもあった。

著書に 「The Clean Coder (邦訳: Clean Coder プロフェッショナルプログラマへの道)」 「Clean Code (邦訳: Clean Code - アジャイルソフトウェア達人の技)」 「UML for Java Programmers (邦訳: Java プログラマのためのUML)」 「Agile Software Development (邦 訳: アジャイルソフトウェア開発の奥義)」 「Extreme Programming in Practice (邦訳: XP エクストリームプログラミング実践記 開発現場からのレポート)」「More C++ Gems」 「Pattern Languages of Program Design 3」 「Designing Object Oriented C++ Applications Using the Booch Method」 がある。

29



イントロダクション

第

部

プログラムを動かすために膨大な知識とスキルが必要になることはない。 高校生だっていつ もプログラムを書いている。 若い大学生ならPHP や Ruby の短いコードを組み合わせ、 数十億 ドルのビジネスを始めていたりするくらいだ。 パーティションで区切られたオフィスにいる世 界中の若いプログラマたちは、巨大な課題管理システムにある膨大な要件文書を扱いながら、 システムを 「動かす」ために死に物狂いになっている。 彼らが作り出すコードは、きれいでは ないかもしれないが、それでも動く。 何かを「一度だけ」 動かすのは、それほど難しいことで はないからだ。

ソフトウェアを正しくするのは完全に別問題である。 正しくするのは難しい。 若いプログラ マがまだ持っていない知識やスキルが必要になるだろう。 プログラマが習得に時間をかけてい ない思考や洞察力が必要になるだろう。 プログラマが必要になるとは夢にも思わなかったレベ ルの規律や献身が必要になるだろう。 たいていの場合、職人としての情熱とプロになりたいと いう願望も必要になるはずだ。

ソフトウェアを正しくすると、 不思議なことが起こる。 ソフトウェアを動かすのに大量のプロ グラマが不要になる。 膨大な要件文書や巨大な課題管理システムが不要になる。 パーティショ ンで区切られた世界中のオフィスで、 24時間ずっとプログラミングしなければいけないような ことも不要になる。

ソフトウェアを正しくすれば、 開発や保守に必要な人材はわずかで済む。 変更は簡単で迅速 になる。 欠陥の数は少なく、ほとんど出てこなくなる。 労力は最小に抑えられ、 機能性と柔軟 性は最大になる。

こうした光景はユートピアのように思える。 だが、私はそこにいる。 そうした光景をこの目 で見ている。 システムの設計とアーキテクチャのおかげで、 開発や保守が楽になっているプロ ジェクトに取り組んでいる。 必要となる人材が少ないプロジェクトも経験している。 欠陥率が 極端に低いシステムの経験もある。 優れたソフトウェアアーキテクチャが、システム、プロジェ クト, チームに驚異的な影響を与えるのを見たことがある。 私は 「約束の地」 へ行ったことが あるのだ。

だが、私の言葉を真に受けてはいけない。 自分自身の経験をふりかえってみよう。 これまで に反対の経験をしたことはないだろうか? 相互接続が何重にも複雑に絡み合い、 あらゆる変 更は (どれだけ小さなものでも) 大きなリスクを伴い、 終わるまでに数週間もかかる。 そのよ

31

うなシステムに関わったことはないだろうか? ひどいコードや腐った設計に邪魔されたこと はないだろうか? システムの設計が、チームの士気、 顧客の信頼、 マネージャーの忍耐に大 きな悪影響を及ぼしたことはないだろうか? ソフトウェアの腐った構造によって、チーム、 部署、さらには企業がつぶれるのを目撃したことはないだろうか? あなたはプログラミング の地獄へ行ったことがあるだろうか?

私はある。 みなさんもそうだろう。すばらしい設計に取り組む喜びを味わうよりも、クソみ たいな設計と必死に戦うほうが一般的だ。

第1部 イントロダクション

22 32

設計とアーキテクチャ

第 1 章

設計とアーキテクチャについては、 何年も混乱が生じている。 設計とは何か? チャとは何か? 両者の違いは何か? アーキテク

本書の目的は、こうした混乱を切り捨て、 設計とアーキテクチャについて最終的な定義をす ることである。 まずは、 両者に違いがないことから主張したい。 何も違いはないのだ。 通常、 「アーキテクチャ」という言葉は、下位レベルの詳細とは切り離された文脈で使用され ている。 一方、「設計」 という言葉は、下位レベルの構造や意思決定を意味している。 だが、実 際のアーキテクトの行動を見ていると、この使い分けは無意味であることがわかる。

新しい家を設計する建築家 (アーキテクト) を考えてみよう。 家にはアーキテクチャはある だろうか? もちろんある。 そのアーキテクチャとは何だろうか? おそらく、 家の形、外観、 正面図 空間や部屋のレイアウトなどになるだろう。 だが、 建築家の作成した図を見ると、膨大 な量の詳細が書き込まれている。 たとえば、 排気口、 ライトのスイッチ、 ライトの配置なども わかるようになっている。 どのスイッチがどのライトを制御しているのかもわかる。 ボイラー の位置と給湯器や排水ポンプのサイズや配置もわかる。 壁、屋根、 基礎がどのように構築され るのかも詳しく書き込まれている

33

章 設計とアーキテクチャ

第1

要するに、 上位レベルの決定をサポートする下位レベルの詳細がすべてわかるようになって いるのだ。 また、下位レベルの詳細と上位レベルの決定が家全体の設計の一部であることも見 てわかる。

ソフトウェアの設計も同じだ。 下位レベルの詳細と上位レベルの構造は全体の設計の一部と なる。それらが連続した構造を作り、システムの形状を定義する。 どちらも欠くことはできな い。 両者を明確に区別することはできない。 最上位レベルから最下位レベルまで、 決定の連続 なのである。

目的は?

では、そうした決定の目的は何だろうか? 優れたソフトウェアの設計の目的とは何か? それは、私のユートピアの実現にほかならない。

ソフトウェアアーキテクチャの目的は、 求められるシステムを構築・保守するために必要な人材を最 小限に抑えることである。

設計の品質は、顧客のニーズを満たすために必要な労力で計測できる。 必要な労力が少なく、 システムのライフタイム全体で低く保たれているならば、その設計は優れている。 逆に、 リリー スごとに労力が増えるなら、その設計は優れていない。 ね、簡単でしょ。

ケーススタディ

例として、ケーススタディを考えてみよう。匿名を希望しているが、 現実の企業の実際のデー タを使用している。

まず、エンジニアリング部門の人材の増加を見てみよう (図1-1)。 リリースするたびに人数 が増えている。 みなさんも望ましい傾向だと同意してくれるのではないだろうか。 人材の増加 は、大きな成功を示しているはずだ!

では、この企業の同時期の生産性を見てみよう。 単純にコード行数で計測したものだ (図 1-2).

34

ケーススタディ

市場を牽引するソフトウェアプロダクトのライフサイクル 1400 1200 1000 800 600 400 ■エンジニアリング部門の人材 200 0 1 2 3 4 5 6 7 8 メジャーリリース

図 1-1

エンジニアリング部門の人材の増加 (Jason Gorman のプレゼンテーションスライドを許可を得て 掲載)

市場を牽引するソフトウェアプロダクトのライフサイクル 8000 プロダクトの (KLOC) 7000 6000 5000 4000 3000 2000 1000 0 1 2 34 5 6 7 8 メジャーリリース 図1-2 同時期の生産性

明らかに何かがうまくいっていない。 開発者の増加によってリリースはできているが、 コー ドの増加は漸近線に近づいている。

図1-3 を見てほしい。 本当に恐ろしいグラフだ。これは、コード1行あたりのコストの変化 を示している。

グラフの傾向から、 持続可能性が低いことがわかる。 同時期に企業がいくら利益を上げてい ようが関係ない。 この曲線は、ビジネスモデルから利益を奪い去り、完全に崩壊させることは ないにしても、企業を大きく失速させるだろう。

35

第1章

設計とアーキテクチャ

こうした生産性の変化の原因は何だろうか? リリース8にリリース1の40倍ものコストが かかっているのはなぜだろうか?

市場を牽引するソフトウェアプロダクトのライフサイクル 400 350 300 250 200 コード行あたりの コスト 150 100 50 0 1 2 3 4 5 6 7 8 メジャーリリース

図1-3 コード行あたりのコストの変化

崩壊のサイン

あなたが見ているのは崩壊のサインだ。 システムを慌てて構築しているとき、大量のプログ

ラマによってアウトプットを生み出しているとき、 コードがクリーンであることや設計の構造 について配慮が欠けているとき、この曲線に乗ったまま最悪な結末を迎えることになるだろう。 図1-4 は、開発者にとってこの曲線がどのように見えるかを示したものである。 最初はほぼ 100%だった生産性が、 リリースするたびに低下していることがわかる。 4回目のリリースから は、 生産性は底を打っている。

開発者の視点からすると、誰もが一生懸命に働いているので、非常にイライラすることにな るだろう。 決して、 誰かが手を抜いているわけではない。

だが、彼らの自己犠牲や残業や献身的な行動があったとしても、もはや何も効果はない。 機 能の開発ではなく、 崩壊の対応に追われているからだ。 ある場所の対応が終われば次の場所、 また次の場所、 またまた次の場所へと、崩壊の対応を続けていると、 機能の開発はほとんどで きなくなる。

36

ケーススタディ

生産性 リリースごとの生産性 100% 75% 50% 25% 0% 1 2 3 4 5 6 7 8 図 1-4 リリースごとの生産性

|経営者の視点

「これはひどい」 と思ったなら、 経営者の視点から見てみよう! 図 1-5 は、 同時期のの給与を示している。

開発者

$20,000,000 $15,000,000 $10,000,000 $5,000,000 so 1 2 3 4 5 6 7 8 リリース

図 1-5 リリースごとの開発者の給与

リリース1は毎月百万ドル程度の給与でデリバリーされた。 リリース2では、数百万ドルが プラスされた。 リリース8は毎月2,000万ドルの給与でデリバリーされ、さらに上昇を続けて いる。

このグラフだけでも恐ろしい。 明らかに衝撃的なことが起きていることがわかる。 収益はコ ストを上回っているので、 上記の費用は正当化できるだろう。だが、この曲線を見る限り、 不 安しか生まれない。

図1-5の曲線と図1-2のリリースごとのコード行を比較してみよう。 初期の数百万ドルの頃 は非常に多くの機能を手に入れていたが、最終的な 2,000万ドルの頃にはほとんど何も手に入 れられていない! CFOがこの2つのグラフを見れば、 惨事を食い止めるために早急な対応

37

設計とアーキテクチャ

章

が必要だと考えるだろう。

だが、どのような対応ができるだろうか? 何がうまくいっていないのだろうか? 生産性 の急激な低下の原因は何か? 憤慨しながら開発者に激怒するほかに、 経営者には何ができる のだろうか?

何が間違っていたのか?

約2,600年前、 イソップが「ウサギとカメ」という物語を作った。 この物語の教訓は、さまざ まな表現で何度も述べられている。

●「遅くとも着実であれば競走に勝つ」

● 「競走は短期戦ではない。 強い者が勝つわけではない」 ● 「急げば急ぐほど速度は落ちる」

この物語は自信過剰の愚かさを描いている。 ウサギは生まれながらの足の速さに自信を持っ ていたが、競走を真剣に受け止めなかったがために昼寝をした結果、 カメに先にゴールされて しまったのである。

現代の開発者も自信過剰な競走をしている。 おっと、 昼寝はしてないか。 君たちは猛烈に働 いている。 だが、脳みそは眠っている。 優れた、 クリーンな、うまく設計されたコードが重要 であることがわかっていない。

「あとでクリーンにすればいいよ。 先に市場に出さなければ!」

開発者たちはそうやっていつもごまかす。 だが、 あとでクリーンにすることはない。 市場か らのプレッシャーは止まらないからだ。 「先に市場に出さなければ」ということは、後ろに競合 他社が大勢いるということである。 競合他社に追い抜かれないためには、これからも走り続け るしかない。

その結果、開発者はモードを切り替えることができない。 次の機能、 また次の機能、 またま た次の機能を追加することになり、コードをクリーンにすることまで手が回らない。 そして、 崩壊が始まる。 生産性がゼロに近づいていく。

ウサギが足の速さに自信を持っていたように、 開発者は生産性に自信を持っている。 だが、 生産性を低下させるコードの崩壊は、絶えず忍び寄ってくる。 すきあらば、 生産性は数か月で ゼロになってしまうだろう。

先ほどの開発者のごまかしは、崩壊したコードを書けば長期的には遅くなるものの、短期的 には速度が上がるという考え方にもとづいている。 このことを信じている開発者は、崩壊した コードを書くモードから、いずれどこかでクリーンにするモードに切り替われる、 というウサ

第1

38

ケーススタディ

ギのような自信を持っている。 だが、それは事実誤認である。 事実は、 短期的にも長期的にも、 崩壊したコードを書くほうがクリーンなコードを書くよりも常に遅い。

Jason Gorman の実験結果を見てみよう (図1-6) Jason は6日間かけて実験を行った。 毎 日、 整数をローマ数字に変換する簡単なプログラムを作るという実験だ。 事前に定義した受け 入れテストをパスすれば作業完了となる。 作業は毎日30分以内とした。 1日目、3日目、5日 目は、テスト駆動開発 (TDD) というコードをクリーンにする有名な規律を適用した。2日目、 4日目、6日目は、 TDD を使わずにコードを書いた。

作業完了時間 (分) ローマ数字に変換するカタ(コードの演習) 30 29 28 27 26 25 24 23 22 2 TDDあり TDDなし イテレーション

図1-6 整数を変換する作業時間と TDD の有無

図1-6を見ると、 学習曲線が描かれていることがわかる。 日を追うごとに作業完了時間が短 縮されている。 また、 TDD を使ったほうが全体的に10%ほど速く、 TDD を使わなかった最速 時間よりも、 TDD を使った最遅時間のほうが速い。

これを驚くべき結果だと感じる人もいるだろう。一方、ウサギの自信過剰に惑わされていな い人にとっては、思っていたとおりだと感じるだろう。 ソフトウェア開発のシンプルな真実を 理解しているからだ。

速く進む唯一の方法は、うまく進むことである。

これは、経営者のジレンマに対する答えでもある。 生産性の低下とコストの増加を回復させ る唯一の方法は、 開発者にウサギの自信過剰な思考をやめさせ、自ら生み出した崩壊に対して 責任を持たせることである。

開発者はスクラッチからシステム全体を再設計することが答えだと考えているかもしれない が、それもまたウサギのやり方だ。 崩壊をもたらした自信過剰が、今度は競走をやり直せばもっ

39

章 設計とアーキテクチャ

とうまく構築できるという話に変わっている。 現実はそれほどうまくはいかない。

自信過剰による再設計は、 元のプロジェクトと同じように崩壊する。

まとめ

いずれの場合も、開発組織が自らの自信過剰を認識して回避し、 ソフトウェアアーキテクチャ の品質と真剣に向き合うことが、最善の選択肢となる。

ソフトウェアアーキテクチャと真剣に向き合うには、優れたソフトウェアアーキテクチャと は何かを知る必要がある。 労力の最小化と生産性の最大化を実現する設計とアーキテクチャを 構築するには、そこに到達するためのシステムアーキテクチャの属性を把握する必要がある。

それが本書の内容だ。 優れたクリーンなアーキテクチャと設計がどのようなものかを説明す る。 本書を読んだソフトウェア開発者は、長期的に利益をもたらすシステムを構築できるだ ろう。

第1

40

2つの価値のお話

2 食 第 章

$$$$

すべてのソフトウェアシステムは、ステークホルダーに2つの異なる価値を提供する。 それ は「振る舞い」 と 「構造」 だ。 ソフトウェア開発者には、この2つの価値を維持する責任があ る。 残念ながら、 片方だけにフォーカスすることが多く、もう片方が無視されてしまっている。 さらに残念なことに、2つのうち価値の低いほうにフォーカスすることが多く、最終的にソフ トウェアシステムの価値がゼロになってしまうこともある。

振る舞い

ソフトウェアの1つ目の価値は「振る舞い」 だ。 プログラマは、マシンがステークホルダーの ためにお金を生み出したり節約したりできるように、マシンに振る舞いを与えるために雇用さ れている。 そのためにプログラマは、ステークホルダーが機能仕様書や要件文書を作成するの を支援する。 その後、ステークホルダーのマシンが要件を満たせるように、プログラマはコー ドを書くことになる。

41

第2章 2つの価値のお話

もしマシンが要件を満たしていなければ、プログラマはデバッガを取り出して問題を解決 する。

多くのプログラマは、それが自分たちの仕事だと思っている。 マシンが要件を満たせるよう にして、バグがあれば修正する。 それが仕事だと信じている。 ひどい間違いだ。

アーキテクチャ

ソフトウェアの2つ目の価値は 「ソフトウェア」 という言葉に関係している。 この言葉は「ソ フト」 と 「ウェア」 の複合語だ。 「ウェア」は「プロダクト」を意味する。 「ソフト」は......そ う、ここに2つ目の価値がある。

ソフトウェアは「ソフト」になるように考案されたものだ。 マシンの振る舞いを簡単に変更 する手段になることを目的としたものである。 マシンの振る舞いを簡単に変更したくないとき は、それを「ハード」 ウェアと呼んだ。

上記の目的を達成するには、ソフトウェアはソフトでなければいけない。 つまり、簡単に変 更できなければいけない。 ステークホルダーが機能を変更したいと思えば、その変更は簡単に できるようになっておくべきだ。 変更の難易度は、変更の形状ではなく、 変更のスコープに比 例しなければいけない。

ソフトウェア開発のコストの増加の背景に、こうした「スコープ」 と 「形状」 の違いがある。 要件の変更のサイズに対して、 不釣り合いなほどコストがかかるのはそのためだ。 開発の初年度 のほうが2年目よりも変更のコストが安く、 2年目のほうが3年目よりも安いのはそのためだ。

ステークホルダーの視点からすると、ほとんど同じようなスコープの変更を伝えているだけ である。 だが、開発者の視点からすると、ステークホルダーはジグソーパズルのピースを渡し てくるようなものだ。 パズルは次第に複雑になっていき、 システムの形状が要件の形状に合わ なくなっていくため、 新しい要件は前回の要件よりも当てはめるのが難しくなるのである。

ここで 「形状」 という聞き慣れない言葉を使っているが、 私は比喩としては適切だと考えて いる。 ソフトウェア開発者は、 「四角い」 ペグを 「丸い」 穴に打ち込まなければいけないような 気持ちになることがよくある。

この問題はもちろん、システムのアーキテクチャの問題である。 アーキテクチャが特定の「形 状」を選択していると、 新しい機能がその構造に適さない可能性が高くなっていく。 したがっ て、形状にとらわれないアーキテクチャにしたほうが実用的である。

42

アイゼンハワーのマトリックス

大きな価値

機能? それともアーキテクチャ? ステムが動作することが重要だろうか? だろうか? 価値が大きいのはどちらだろうか? ソフトウェアシ それとも、簡単に変更できることのほうが重要なの

ビジネスマネージャーに質問すると、ソフトウェアシステムが動作することが重要であると 答える。 開発者もこの意見に賛同することが多い。 だが、 これは間違った態度だ。 簡単な論理 的思考で極端な状況を想定し、 これが間違っていることを証明しよう。

●完ぺきに動作するが、変更できないプログラムを与えられたとする。 要件が変更されると 機能しなくなる。 修正することもできない。 したがって、このプログラムはいずれ役に立 たなくなる。

・動作しないが、 変更が簡単なプログラムを与えられたとする。 要件が変更されても修正は 可能なので、動かし続けることができる。 したがって、 このプログラムはこれからも引き 続き役に立つ。

これでは納得できないかもしれない。 変更できないプログラムなど存在しないからだ。 だが、 変更のコストがメリットを上回っており、変更が事実上できなくなっているシステムは存在す るだろう。 多くのシステムでは、一部の機能や設定がその段階に到達している。

ビジネスマネージャーに変更を希望するかと聞くと、 当然ながら 「希望する」と答える。 た だし、将来の柔軟性よりも現在の機能性のほうが重要だと回答を補足するはずだ。 とはいえ、 ビジネスマネージャーが変更を求めたとき、 あなたが膨大なコストを見積もると、 変更が非現 実的になるまでシステムを放置したあなたに対して、 ビジネスマネージャーは激怒するだろう。

アイゼンハワーのマトリックス

ドワイト・D・アイゼンハワー大統領による 「重要度と緊急度のマトリックス」 を考えてみ よう (図2-1)。 このマトリックスに対して、アイゼンハワーは以下のように述べている。

43

第2

つの価値のお話 重要 緊急 重要 緊急ではない 重 要ではない 重要ではない 緊急 緊急ではない 図2-1 アイゼンハワーのマトリックス

私には緊急と重要の2種類の問題がある。 緊急と重要は違う。 重要なことが緊急になるわけではな い。

この古い格言には真実が数多く含まれている。 緊急なことが重要になることはほとんどない。 重要なことが緊急になることもほとんどない。

ソフトウェアの1つ目の価値 (振る舞い) は緊急だが、 常に重要とは限らない。 ソフトウェアの2つ目の価値 (アーキテクチャ) は重要だが、 常に緊急とは限らない。 もちろん緊急かつ重要なものもある。 緊急でも重要でもないものもある。 この4つの組み合 わせには、以下の優先順位を付けることができる。

章 2

1. 緊急かつ重要

2. 緊急ではないが重要 3.緊急だが重要ではない 4. 緊急でも重要でもない

コードのアーキテクチャ (重要) は1と2、コードの振る舞い (緊急)は1と3に位置する。 ビジネスマネージャーや開発者がよくやる間違いは、3の項目を1に昇格させることだ。 つま り、「緊急だが重要ではない」ものと 「緊急かつ重要」なものを区別できていないのである。 こ うした間違いは、システムの重要ではないことを優先して、システムの重要なアーキテクチャ を無視することにつながる。

ソフトウェア開発者のジレンマは、ビジネスマネージャーがアーキテクチャの重要性を評価で きないことである。そのためにソフトウェア開発者が雇われている。 したがって、 ソフトウェ ア開発チームには、機能の緊急性よりもアーキテクチャの重要性を強く主張する責任が求めら れる。

1954年のノースウェスタン大学での演説より。

44

アーキテクチャの戦い

アーキテクチャの戦い

この責任を果たすことは 「戦い」 に足を踏み入れることを意味する。 「闘争」 のほうが適切か もしれない。 率直に言えば、物事は常にこうして成し遂げられる。 開発チームは、企業にとっ て最善と思えるものを求めて闘争する。 それは、マネジメントチームも、マーケティングチー ムも、セールスチームも、オペレーションチームも同じだ。 常に闘争である。

優れたソフトウェア開発チームは、真正面から闘争に立ち向かう。 ステークホルダーたちと 対等に ひるむことなく口論する。 ソフトウェア開発者もステークホルダーであることは忘れ てはいけない。 保護すべきソフトウェアに対する責任がある。 それが、 あなたの役割であり、 義務である。 それが、 あなたが雇われている大きな理由だ。

あなたがソフトウェアアーキテクトであれば、このことは特に重要となる。 ソフトウェアアー キテクトは、その職務記述からすると、 システムの機能よりも構造にフォーカスするものだ。 アーキテクトは、 機能を簡単に開発・変更・拡張できるアーキテクチャを構築するのである。

アーキテクチャを後回しにすると、 システムの開発コストはますます高くなり、 一部または全部が変更不能になるだろう。 そのことを覚えておいてほしい。 そのような状態が 許されているようなら、 ソフトウェア開発チームが自らが必要とするもののために、懸命に闘 わなかったということだ。

システムの

15 45



構成要素から始めよ : プログラミングパラダイム 部

ソフトウェアアーキテクチャはコードから始まる。 それでは、コードをはじめて書いたとき からこれまでに学んできたことをふりかえりながら、 アーキテクチャの議論を進めていこう。 1938年、 Alan Turing がコンピュータプログラミングの基礎を築いた。彼が最初にプログラ ム可能なマシンを考案したわけではないが、プログラムが単なるデータであることを最初に理 解したのは彼だ。 1945年まで、彼は実際のコンピュータで、実際のプログラムを書いていた。 我々も (十分に目を凝らしてみれば) 彼の書いたものがコードだと認識できる。そのプログラ ムには、ループ、 分岐、代入、サブルーチン、 スタックなど、我々のよく知るものが使われて いる。 彼の使用していた言語はバイナリだ。

それからというもの、さまざまなプログラミングの革命が起きている。 よく知られた革命は、 言語の革命だ。 まず、 1940年代後半にアセンブラが登場した。 これらの 「言語」は、プログラ ムをバイナリに翻訳する負担をプログラマから解放した。 1951年にGrace Hopper が世界初の コンパイラ 「A-0 system」 を考案した。 彼女が 「コンパイラ」という言葉を生み出したのだ。 Fortran は1953年に考案された(私が生まれた翌年だ)。 その後、 COBOL PL/1 SNOBOL、 C. Pascal、C++、 Java など、絶え間なく新しいプログラミング言語が生み出されている。

さらに重要な革命がある。 それは、プログラミングパラダイムの革命だ。 バラダイムとは、 プログラミングの方法のことであり、 言語とは比較的関係のないものである。 パラダイムは、 どのプログラミング構造を使うべきか、それをいつ使うべきかを教えてくれる。 現在までに、 このようなパラダイムは大きく3つ存在している。 理由はあとで説明するが、どれもお互いに 似ているところがない。



パラダイムの概要

第3

KOHNKE

本章では、3つのパラダイムの概要を紹介する。 その3つのパラダイムとは、 「構造化ブログ ラミング」 「オブジェクト指向プログラミング」「関数型プログラミング」である。

構造化プログラミング

最初に導入された (最初に誕生したわけではない) パラダイムは、1968年にEdsger Wybe Dijkstra が発見した 「構造化プログラミング」 である。 Dijkstra は、 制限のないジャンプ (goto 文の使用) がプログラムの構造に対して有害であることを示した。 今後の章で示すことになる が、彼はこのようなジャンプを、なじみのある if / then / else や do/while/until といった構 文に置き換えた。

19 49

章 バラダイムの概要

第3

構造化プログラミングのパラダイムは、以下のように要約できる。

構造化プログラミングは、直接的な制御の移行に規律を課すものである。

オブジェクト指向プログラミング

次に導入されたパラダイムは、 構造化プログラミングの2年前の1966年に、 Ole Johan Dahl とKristen Nygaard が発見した 「オブジェクト指向プログラミング」である。 この2人のプロ グラマは、 ALGOL言語の関数呼び出しのスタックフレームをヒープに移動できること、 そのこ とにより、 関数から戻ってきたあとでも関数で宣言したローカル変数が存在し続けられること に気づいた。 この関数はクラスのコンストラクタになり、 ローカル変数はインスタンス変数に なった。 そして、 ネストした関数はメソッドになった。 その後、 規律のある関数ポインタの使 用によって、必然的にポリモーフィズムの発見につながった。

オブジェクト指向プログラミングのパラダイムは、以下のように要約できる。

オブジェクト指向プログラミングは、間接的な制御の移行に規律を課すものである。

関数型プログラミング

3つ目のパラダイムの「関数型プログラミング」 は、 最近になって導入するところも増えて きたが、発明された時期は3つのパラダイムのなかで最も早い。 実際、 コンピュータプログラ ミングよりも昔に発明されている。 関数型プログラミングは、 Alonzo Church の業績の直接的 な成果である。 彼は、 同時期に Alan Turing が挑んでいた数学的問題を追求しながら、 1936 年にラムダ計算を発明した。 彼のラムダ計算は、 Lisp 言語の基礎となっている。 Lisp は、 1958 年に John McCarthy によって開発された言語だ。 ラムダ計算の基本的な概念は不変性である。 つまり、シンボルの値は変化しないという概念だ。このことは、 関数型言語には代入文がない ことを意味する。 実際には、 変数の値を変更する手段が用意された関数型言語も多い。 ただし、 その手段は非常に厳しく制限されている。

関数型プログラミングのパラダイムは、以下のように要約できる。

関数型プログラミングは、代入に規律を課すものである。

50

まとめ

考えるべきこと

3つのプログラミングパラダイムを紹介する際に、私が意図的に設定したパターンに注目して ほしい。 これらのパラダイムは、プログラマから能力を削除しているのである。 新しい能力を 提供しているものはない。 それぞれがネガティブな意図を持ち、 何らかの規律を課しているの である。 これらのパラダイムは、 何をすべきかを伝えるというよりも、 何をすべきでないかを 伝えているのである。

この問題を別の角度から見ると、 それぞれのパラダイムは我々から「何かを奪っている」と 言える。 つまり、3つのパラダイムは、 我々から goto 文 関数ポインタ、代入を奪っているの だ。 では、ほかにも奪われたものはあるのだろうか?

奪われたものは、ほかにはない。 したがって、これらの3つのパラダイムが、 我々がこれか らお目にかかるすべてのパラダイムである。 少なくともネガティブなパラダイムはこの3つだ けになるだろう。 これら以外にパラダイムが存在しないという証拠もある。 それは、この3つ が1958年から1968年の10年間に発見されたことだ。 それから何十年もの間、 新しいパラダイ ムは追加されていない。

まとめ

パラダイムの歴史的な教訓は、 アーキテクチャとどのように関係しているのだろうか? 「す 「べて」において関係している。 我々は、 アーキテクチャの境界を越えるための仕組みとして、 ポリモーフィズムを使う。 我々は、データの配置やアクセスに規律を課すために、 関数型プロ グラミングを使う。 我々は、 モジュールのアルゴリズムの基盤として、 構造化プログラミング を使う。

これらの3つが、 アーキテクチャの3つの大きな関心事に対応していることに注目してほし い。 その3つとは 「コンポーネントの分離」 「データ管理」 「機能」である。

51



構造化プログラミング

4枚 第

Edsger Wybe Dijkstra は、 1930年にロッテルダムで生まれた。 第二次世界大戦中、ロッテ ルダムの爆撃とオランダのドイツ占領から逃れた彼は、 1948年に高校を卒業。 数学・物理学・ 化学 生物学の成績が優秀だった。 1952年3月、 彼が21歳のとき (私が生まれるわずか9か

月前)、オランダ初のプログラマとして、 アムステルダムの数学センターの職に就いた。

1955年、3年間プログラマを務めた Dijkstra は、 身分としてはまだ学生であり、理論物理学 よりもプログラミングの知的挑戦のほうが大きいとして、自身の長期的なキャリアにプログラ ミングを選択した。

1957年, Dijkstra は Maria Debets と結婚した。 当時、 オランダの結婚式では自分の職業を 宣言することになっていた。 だが、オランダ当局は、 Dijkstraの職業である「プログラマ」 を 受け入れようとしなかった。 そのような職業など聞いたことがなかったからだ。そのために彼 は 「理論物理学者」 という肩書を受け入れた。

プログラミングをキャリアに選ぶことについて、 Dijkstra は上司の Adriaan van Wijngaarden に相談した。 プログラミングという学問分野や科学を誰も明らかにしておらず、 そのために自分 はプログラミングに真剣に取り組むことができないと伝えたのだ。 上司からの答えは、 Dijkstra

53

第4章 構造化プログラミング

ならプログラミングの学問分野を発見し、ソフトウェアを科学に進化させることができるとい うものだった。

Dijkstra は、コンピュータが巨大で、壊れやすく、遅く、信頼性が低く、(今日の基準では) 非常に制限された、 真空管の時代にキャリアを開始した。 当時のプログラムは、バイナリ形式 やまだ洗練されていないアセンブリ言語で書かれていた。 入力となるのは、物理的な紙テープ やパンチカードだった。 編集・コンパイルテストのループは、数日とはいわないまでも、数 時間はかかるものだった。

こうした原始的な環境で、 Dijkstra はすばらしい発見をしたのである。

証明

Dijkstra が最初に認識していた問題は、プログラミングはハードなものであり、プログラマ はプログラミングがうまくできていないというものだった。 複雑なプログラムには、人間の脳 が何の支援もなく管理するにはあまりにも多くの詳細が含まれている。 些細な詳細を見落とす と、プログラムは動くかのように思えるが、驚くようなことで失敗してしまう。

Dijkstra の解決策は、 数学の証明を適用するというものだった。 彼のビジョンは、 公理・定 理系補助定理といったユークリッドの階層の構築だった。 数学者と同じように、 プログラ マもその階層を使えると彼は考えていたのだ。 つまり、 すでに実績のある構造をプログラマが 使用することで、それをコードに結び付け、自ら証明できるようにするのである。

これを実現するために、 Dijkstra はアルゴリズムの証明を記述する手法が必要であることを 認識した。 これはかなり大きな挑戦だった。

Dijkstra は研究を続けるなかで、 goto 文を使うことによって、モジュールを再帰的に小さな 単位に分割できなくなること、それにより合理的な証明に欠かせない 「分割統治」 が使えなく なることを発見した。

だが、 goto 文を適切に使えば、こうした問題は発生しなかった。 Dijkstra は、 goto を 「うま く」 使えば、 if / then / else などの選択や、 do / while といった反復の制御構造に対応すること に気づいたのである。これらの制御構造のみを使用したモジュールならば、証明可能な単位に 再帰的に分割できる可能性がでてきた。

これらの制御構造と順次処理を組み合わせると、 特別なものになることを Dijkstra は知って いた。その2年前に Böhm と Jacopini が、 あらゆるプログラムは 「順次」 「選択」 「反復」の3 つの構造で構築できることを特定していたからだ。

この発見が決定的なものとなった。 モジュールを証明可能にする制御構造は、 あらゆるプロ グラムを構築できる制御構造の最小セットと同じだったのだ。 こうして 「構造化プログラミン

54

グ」 が誕生した。

「順次」 が正しいことを証明するために、 Dijkstra は単純な列挙を行った。 入力と出力を数学 的に追跡したのである。こうしたアプローチは、通常の数学的証明と何ら変わりはなかった。 「選択」の証明についても、 Dijkstra は列挙を適用した。 選択のそれぞれの経路を列挙したの である。 両方の経路が最終的に適切な数学的な結果になれば、その証明は確かなものになった と言える。

「反復」は少し違っていた。 反復を証明するために、 Dijkstra は数学的帰納法を使用する必要 があった。 1のときは、 列挙によって証明した。 次に、 Nが正しいと仮定した場合、 N+1 も正 しいことを列挙によって証明した。 反復の開始条件と終了条件についても、 列挙によって証明 した。

こうした証明は、 苦労が多く複雑なものだったが、それが証明というものである。 こうした 発展により、 定理のユークリッドの階層を構築できるというアイデアが、 実現可能であるかの ように思えてきた。

有害宣言

1968年、 Dijkstra は3月に出版される CACM の編集委員にレター論文を送った。レター論文 のタイトルは「Go To Statement Considered Harmful (GOTO 文は有害だと考えられる)」。 3つの制御構造に対する彼の立場を表明したものだった。

そして、プログラミングの世界は炎上した。 当時の人たちはまだインターネットが使えなかっ たので、Dijkstra の悪評を投稿することはできず、オンラインで彼を非難することもできなかっ た。 だが、 多くのジャーナルに投書することはできたし、 実際にそれが行われた。

こうした投書は必ずしも礼儀正しいものばかりではなかった。 彼の立場を猛烈に否定するも のもあれば、 逆に強く支持するものもあった。 議論は論争となり、その後約10年間も続くこと になった。

最終的に論争は収まった。 理由は簡単だ。 Dijkstra が勝利したからである。 コンピュータ言 語が進化するにつれ、 goto 文の存在は影を潜め、ほとんど消え去ってしまった。 現代的なほと んどの言語には、 goto 文は備わっていない(もちろん、 Lisp にはあるわけがない)。

今日の我々は、好むと好まざるとにかかわらず、 構造化プログラマである。 我々の使用する 言葉には、規律のない直接的な制御の移行を使うという選択肢は用意されていないからだ。

Java の break や例外処理も goto の一種だと指摘する人もいる。 だが、こうした構造は、かつ て Fortran や COBOL が持っていた、 制限のない制御の移行とは違うものだ。 実際、 goto キー ワードをサポートしている言語でさえ、 ターゲットを現在の関数のスコープに制限している。

有害宣言

55

第4章 構造化プログラミング

機能分割

構造化プログラミングは、 モジュールを証明可能な単位に再帰的に分割することを可能にす る。それによって、 モジュールは機能的に分割できる。 つまり、大きな問題は上位レベルの機 能に分割できるというわけだ。 分割された機能は、さらに下位レベルの機能へと無限に分割し ていくことができる。 また、 このように分割された機能は、 構造化プログラミングの制限され た制御構造を使って表現することができる。

こうした基盤の上に、 1970年代後半から1980年代にかけて、 「構造化分析」 や 「構造化設計」が 知名度を高めていった。 Ed Yourdon, Larry Constantine、 Tom DeMarco, Meilir Page-Jones といった人物が、これらの手法を宣伝・普及させた。 プログラマたちは、こうしたやり方に従 い、大きな問題をモジュールやコンポーネントに分割し、さらに小さな証明可能な機能へと分 割していったのである。

正式に証明できない

だが、 最後まで証明されることはなかった。 定理のユークリッドの階層が構築されることは なかった。 プログラマたちは、 小さな機能が正しいことを証明するプロセスに対して、 利点を 見いださなかったのである。 結局、 Dijkstra の夢は途絶え、消え去った。 今日のプログラマは、 正式な証明が高品質のソフトウェアを生み出す適切な方法であるとは考えていない。

正しいことを証明する戦略は、正式な、 ユークリッド方式の、数学的な証明だけではない。 大 きく成功したもうひとつの戦略に科学的方法がある。

救済のための科学

科学の理論や法則は、正しいと証明することができない。 それが科学と数学の根本的に異 なるところである。 たとえば、ニュートンの運動の第二法則 (F=ma) や万有引力の法則 (F=Gmmg/r2) が正しいと証明することはできない。 もちろん、これらの法則を実証するこ とはできる。 小数何桁かの精度で計測することもできる。 だが、 数学的に証明することはでき ない。実験をどれだけ行っても、実証的な証拠をどれだけ多く集めても、実験によってこれら の法則が 「正しくない」ことが証明される可能性が常に残されているのである。

これが 科学の理論や法則の本質だ。 証明可能ではなく、 反証可能なのである。

56

テスト

証明可能ではないにもかかわらず、 我々は日常的にこれらの法則に命をかけている。 たとえ ば、車に乗るたびに、 F = ma に命を預けている。 これが世の中の仕組みを表す信頼できるも のだと考えているからだ。 あるいは、 一歩踏み出すたびに、 F = Gmm/r2 が正しいものであ るとして、自らの健康と安全をささげている。

科学は、真であることを証明することではなく、真ではないことを証明することで機能して いる。 そして、 多くの労力をかけても真ではないことが証明できないなら、 目的のために十分 に真であるとみなされる。

もちろん、 すべてのことが証明できるわけではない。 「これは嘘である」 という主張は、真で も偽でもない。 これは、証明できない最も簡単な例だろう。

つまり、数学は証明可能な主張を真であると証明する学問であり、 科学は証明可能な主張を 偽であると証明する学問であると言えるだろう。

テスト

Dijkstra は 「テストはバグが存在しないことではなく、 バグが存在することを示すものであ る」と述べた。 つまり、 テストによってプログラムが正しくないことは証明できるが、 プログ ラムが正しいことは証明できないのである。 テストに十分な労力をかけていれば、そのプログ ラムは目的のために十分に真であるとみなせる。

この事実は、驚くべきことを示している。 ソフトウェア開発は、数学的な構成要素を操作し ているかのように思えるかもしれないが、 実際には数学的な試みではない。 むしろソフトウェ ア開発は科学のようなものである。 どれだけ最善を尽くしても正しくないことを証明できない ことによって、その正しさを明らかにしているのである。

ただし、こうした 「正しくないことの証明」 は、 証明可能なプログラムにしか適用できない。 (たとえば goto を無制限に使用した) 証明不可能なプログラムは、いくらテストしても正しい とみなされることはない。

構造化プログラミングでは、プログラムを再帰的に分割して、証明可能な小さな機能にする 必要がある。 そして、証明可能な小さな機能が正しくないことを、テストを使って証明する。 テストが正しくないことを証明できなければ、その機能は目的のために十分に正しいとみなす ことができる。

57

第4章 構造化プログラミング

まとめ

構造化プログラミングの価値を高めるのは、 反証可能なプログラミングの単位を作成する能 力である。 したがって、現代の言語では無制限の goto 文がサポートされていない。このこと は、 アーキテクチャレベルにおいて、 機能分割がベストプラクティスだと考えられている理由 でもある。

最小の機能から最大のコンポーネントまで、あらゆるレベルにおいて、ソフトウェアは科学 のように、 反証可能性によって動かされている。 ソフトウェアアーキテクトは、簡単に反証で きる(テスト可能な) モジュール、 コンポーネント サービスを定義しようとする。 そのため に、さらに上位のレベルにおいて、 構造化プログラミングのような制限を課している。 こうした制限については、今後の章で詳しく調べていきたい。

58

5年 章

オブジェクト指向プログラミング 第

Thecks1

これから説明していくことになるが、優れたアーキテクチャの基本となるのは「オブジェク ト指向設計」 の原則の理解と適用である。 だが、 オブジェクト指向 (00: Object Oriented) と は何だろうか?

ひとつの答えに「データと関数の組み合わせ」 がある。 これはよく引き合いに出されるもの だが、満足できない答えである。 of () f (o) が別物であるかのように扱われているからだ。 バカバカしい。 Dahl と Nygaard が関数呼び出しのスタックフレームをヒープに移動すること で「オブジェクト指向」 というものを発明した1966年よりもずっと前から、プログラマたちは データ構造を関数に渡していた。

もうひとつのよくある答えに 「現実の世界をモデル化する方法」 がある。 言い訳がましい答 えだ。 「現実の世界をモデル化」 とは、 何を意味しているのだろうか? どうしてそんなことを したいと思うのだろうか? おそらくこれは、00 を使えばソフトウェアと現実世界が近くな るので、 ソフトウェアのことを理解しやすくなる、 といったことを意図しているのだろう。 あ まりにも言い訳がましい答えだが、そもそも定義が雑すぎる。 結局、 00 とは何なのかを明ら かにしていない。

59

章 オブジェクト指向プログラミング

第5

あるいは、カプセル化、継承、 ポリモーフィズムという3つの魔法の言葉でOOの性質を説 明しようとする人もいる。 おそらくこういう人たちは「00はこれら3つの適切な混合物であ る」 とか 「00 言語はこれら3つをサポートするべきだ」 などと言いたいのだろう。 では、それぞれの概念を順番に調べてみよう。

カプセル化とは?

「カプセル化」 が00 の定義の一部となっているのは、 00 言語がデータと関数のカプセル化 を簡単かつ効果的なものにしているからだ。それによって、 データと関数の周囲に線を引くこ とができる。 その線の外側にはデータは見えないようになっていて、 一部の関数だけが見える ようになっている。これらの概念は、「プライベートなデータメンバー」と「クラスのパブリッ クなメンバー関数」として表される。

この考え方は、00 だけのものではない。 実際、 C言語でも完ぺきなカプセル化は実現でき る。 以下の簡単なプログラムを考えてみよう。

リスト 5-1 point.h

struct Point; struct Point* makePoint (double x, double y); double distance (struct Point *p1, struct Point *p2);

リスト 5-2 point.c

#include "point.h" #include <stdlib.h> #include <math.h>

struct Point{ }; double x,y;

struct Point* makepoint (double x, double y) { struct Point* pmalloc(sizeof(struct Point)); p->xxi p-yyi return Pi

60

カプセル化とは?

}

double distance(struct Point* p1, struct Point* p2) {

p2->x;

double dx=p1->x

double dy return sqrt(dx*dx+dy*dy);

p1->y p2->y;

}

point.h のユーザーは、 struct Point のメンバーにアクセスできない。 makePoint ( と distance() は呼び出せるが、 Point のデータ構造や関数の実装については何も知らない。

これは (非00 言語による) 完ぺきなカプセル化である。 C言語のプログラマは、このよう なことをいつもやっていた。 データ構造と関数をヘッダーファイルに宣言し、 実装ファイルで それらを実装するのである。 ユーザーからは、 実装ファイルの要素にアクセスすることはでき ない。

だがその後、C++という言語が登場し、C言語の完ぺきなカプセル化が破られてしまった。 C++のコンパイラの技術的な理由から、クラスのメンバー変数をヘッダーファイルに宣言す る必要があった。 その結果、 Point を以下のように変更することになった。

リスト 5-3 point.h

class Point { public: Point (double x, double y); double distance (const Point& p) const;

private : double x; double y; };

リスト 5-4 point.cc

#include "point.h" #include <math.h>

Cコンパイラは、クラスのインスタンスのサイズを知る必要がある。

-

-

61

章 オブジェクト指向プログラミング

Point::Point (double x, double y) : x(x),y(y) 0

double Point::distance (const Point& p) const { } double dx=x-p.x; = double dy y-p.y; return sqrt(dx*dx + dy*dy);

point.h のクライアントから、メンバー変数xとyが見えている! 変数へのアクセスはコ ンパイラによって防御されることになるが、クライアントはそれらの存在を知っているのであ る。つまり、メンバー名が変更されると、 point.cc ファイルを再コンパイルする必要がある! カプセル化が壊れてしまっているのだ。

もちろんカプセル化を部分的に修復することはできる。 public、private protected のキー ワードを導入すればいい。 だがこれらは、コンパイラからヘッダーファイルの変数を見るため の、技術的に必要とされるハックである。

JavaやC#では、ヘッダーと実装の分離を廃止している。 これにより、 カプセル化はさらに 弱体化した。 これらの言語では、クラスの宣言と定義を分離することは不可能である。 こうした理由から、 00 がカプセル化に依存していることを受け入れるのは難しい。 実際、 多

00 言語は、 強制的なカプセル化をほとんどあるいはまったく持っていない。

確かに00 は、プログラマがカプセル化されたデータを盗み見ないように、礼儀正しく振る 舞うべきであるという考え方には依存している。 だとしても、○○を提供すると主張している 言語は、 C言語で完ぺきに実現できていたカプセル化を弱体化させてしまっているのである

継承とは?

00 言語が優れたカプセル化を与えてくれなかったとしても、継承ならば確実に与えてくれ るはずである。

まあ、普通ならそう思うはずだ。 そもそも継承とは、スコープ内の変数と関数のグループを 再度宣言したものである。 これは、00 言語が登場するはるか前から、 C言語のプログラマが 手動でやってきたことだ。

2 たとえば、Smalltalk, Python, JavaScript Lua Ruby などがある。 C言語のプログラマだけでなく、 その時代のほとんどの言語は、あるデータ構造を別のものとして装うことができた。

62

第5

継承とは?

これを元の point. h に対してやってみよう。

5-5 namedPoint.h

struct NamedPoint;

struct Named Point makeNamedPoint (double x, double y, char* name); void setName (struct NamedPoint np, char* name); char getName(struct NamedPoint* np);

5-6 namedPoint.c

#include "namedPoint.h" #include <stdlib.h>

struct NamedPoint { }; double x,y; char* name;

struct Named Point* make Named Point (double x, double y, char* name) { struct NamedPoint* p = malloc(sizeof(struct NamedPoint)); p->x = x; p->y = y; p->name name; return p; }

void setName (struct NamedPoint* np, char* name) { np->name name; }

char getName(struct NamedPoint* np) { return np->name; }

63

第5章 オブジェクト指向プログラミング

リスト 5-7 main.c

#include "point.h" #include "namedPoint.h" #include <stdio.h>

int main(int ac, char** av) {

struct NamedPoint* origin = makeNamedPoint (0.0, 0.0, "origin");

struct NamedPoint upperRight

(1.0, 1.0, "upperRight");

makeNamedPoint

printf("distance=%f\n",

distance(

(struct Point*) origin,

(struct Point*) upperRight));

main プログラムを注意深く見ると、 NamedPoint というデータ構造が Point の派生物のよう に動作していることがわかる。 これは、 NamedPoint の最初の2つのフィールドの順序がPoint と同じになっているからだ。 要するに、 NamedPoint は Point の純粋な上位集合であり、対応す るメンバーの順番を保持してるため、 Point になりすますことができているのだ。

このようなトリックは、00 の登場以前からプログラマが使用する一般的なプラクティスだっ た。 実際、このようなトリックを使って、 C++は単一継承を実現している。

したがって、 00 言語が発明されるよりもずっと前から、 我々はある種の「継承」 を持ってい たと言えるだろう。 ただし、この主張はすべてが真実というわけではない。 トリックが存在し たことは事実だが、本物の継承と比べると、さほど便利なものではなかったからだ。 また、 こ のトリックを使って多重継承を実現するのは、かなり困難である。

それから、 main.c では、 NamedPoint の引数を Point にキャストしなければいけないことに も注意してほしい。 実際の00 言語では、こうしたアップキャスティングは暗黙的に行われる。 00 言語はまったく新しいものを我々に与えてくれたわけではない。 だが、 データ構造のな りすましが格段に便利になったことは間違いない。

まとめると、カプセル化についてはポイントを獲得できず、 継承については半分のポイント しか獲得できていない。これまでのところ、00のスコアはあまり優れているとは言えない。 だが、考慮すべき特性がもうひとつ残されている。

実際にはまだ存在する。

}

4

64

ポリモーフィズムとは?

ポリモーフィズムとは?

00 言語の登場より前に、ポリモーフィズムのような振る舞いはあったのだろうか? 当然 あった。 以下にあるC言語の簡単な copy プログラムを見てほしい。

#include <stdio.h>

void copy() { } int c; while ((c-getchar()) != EOF) putchar(c);

か? getchar() は STDIN から読み取りを行っている。 だが、 どのデバイスが STDIN なのだろう putchar() は STDOUT に書き込みを行っている。 だが、 どのデバイスが STDOUT なのだろ うか? これらの関数は、ポリモーフィズムを実現している。その振る舞いが STDIN と STDOUT の種類によって決まるからだ。

STDIN と STDOUT は、各デバイスの実装を抱える Javaのインターフェイスのようなものであ る。もちろん、 先ほどのCのプログラムにはインターフェイスはない。 それでは、 getchar() の呼び出しが、 実際に文字を読み取るデバイスドライバにどのようにつながるのだろうか?

その質問の答えは簡単だ。 UNIX では、すべてのIO デバイスドライバに5つの標準機能を提 供することが求められている。 その5つとは、 open、close, read, write seek だ。 これら の関数のシグネチャは、すべてのIO ドライバで同じでなければいけない。

FILE データ構造体には、 関数へのポインタが5つ含まれている。 今回の例では、以下のよう になるだろう。

struct FILE { void (open) (char* name, int mode); void (close)(); int (*read)(); void (*write)(char); void (*seek) (long index, int mode); };

コンソール用のIO ドライバでは、これらの関数

を定義し、 そのアドレスでFILE データ構造

5 UNIX システムは多種多様なので、 これはあくまでも例である。

65

第5章 オブジェクト指向プログラミング

体をロードする。

#include "file.h"

void open (char* name, int node) {/*...*/ } void close() {/*...*/}; int read() { int c;/*...*/ return c; } void write(char c) {/*...*/} void seek (long index, int mode) { /*...*/}

struct FILE console = {open, close, read, write

STDIN が FILE *として定義されていて、それがコンソールのデータ構造体を指しているので あれば、getchar()は以下のように実装できる。

extern struct FILE * STDIN;

int getchar(){ return STDIN->read(); }

, seek};

言い換えれば、 getchar () は、 STDIN が指している FILE データ構造体の read ポインタが指 している関数を呼び出しているだけなのだ。

この簡単なトリックが、 00 のポリモーフィズムの基礎である。 たとえば、 C++では、クラ スの仮想関数は vtable というテーブルにポインタを持ち、すべての仮想関数への呼び出しは このテーブルを経由することになる。 派生クラスのコンストラクタでは、生成したオブジェク トの vtable にそれらの関数をロードするだけだ。

まとめると、ポリモーフィズムは関数へのポインタの応用である。 1940年代後半にノイマン 型アーキテクチャが実装されて以来、 プログラマはポリモーフィズムの振る舞いを実現するた めに、関数へのポインタを使用してきた。 つまり、00は新しいものを提供しているわけでは ないのである。

ただし、このことが全面的に正しいわけでもない。 00 言語がポリモーフィズムを提供して くれたわけではないが、 それを安全かつ便利にしてくれたのは00 言語だ。

関数へのポインタを明示的に使用して、ポリモーフィズムの振る舞いを生み出すときの問題 は、関数へのポインタが危険であることだ。ポインタを初期化するときは 「ポインタを経由し 「て関数を呼び出す」 という規約を覚えておく必要がある。 プログラマが規約を覚えておかない

66

ポリモーフィズムとは?

と、バグの追跡と排除が相当難しくなるだろう。

00 言語はこうした規約を排除することで、 関数へのポインタの危険性を回避している。 00 言語を使えば、 ポリモーフィズムも簡単に使えるようになる。 古参のC言語のプログラマだけ が夢見ることのできた「強力なパワー」 を授けてくれる。これらを踏まえると、 00 は間接的 な制御の移行に規律を課すものであると結論づけることができるだろう。

| ポリモーフィズムのパワー

ポリモーフィズムの優れた点は何だろうか? その魅力をきちんと評価するために、 copy プ ログラムの例を再度考えてみたい。 新しいIO デバイスが作成されたら、プログラムはどうなる だろうか? たとえば、 copy プログラムを使用して、 手書き認識装置から音声合成装置にデー タをコピーしたいとしよう。 こうした新しいデバイスを動かすためには、 copy プログラムをど のように変更する必要があるだろうか?

答えは、 何も変更する必要はない! copy プログラムを再コンパイルする必要もない。 なぜ だろうか? copy プログラムのソースコードは、 IO ドライバのソースコードに依存していな いからだ。 IO ドライバがFILE で定義されている5つの標準関数を実装していれば、 copy プロ グラムは喜んでそれらを使用するのである。

IO デバイスは copy プログラムのプラグインになったのだ。

それでは、なぜ UNIX は IO デバイスをプラグインにしたのだろうか? 1950年代後半に 我々がプログラムをデバイス非依存にすべきであることを学んだからだ。 それはなぜか? デ バイス依存のプログラムをいくつも作った結果、 プログラムに同じ仕事をしてもらいながら、 さまざまなデバイスを扱ってもらいたいことがわかったからだ。

たとえば、 カードデッキから入力データを読み込み、 新しいデッキにパンチを出力するプロ グラムをよく書いていた。 その後、 顧客からカードデッキの代わりに、磁気テープのリールを 渡されるようになった。 これが非常に不便だった。 プログラムの大部分を書き直す必要があっ たからだ。 同じプログラムでカードとテープが動作すればいいのにと思っていた。

プラグインアーキテクチャは、こうしたIO デバイスの非依存性をサポートするために考案さ れたものだ。 それ以来、ほぼすべてのオペレーティングシステムで実装されている。 だが、ほ とんどのプログラマは、自分たちのプログラムにその考え方を適用しなかった。 関数のポイン タを使うのは危険だったからだ。

00 ならば、 プラグインアーキテクチャをどこでも何にでも使うことができる。

6 パンチカード (IBM Hollerithの80パンチカード)を見たことがない人も多いと思うが、1950年代、1960年代、さら に1970年代でさえ、 当たり前のように使われていた。

67

第5章

オブジェクト指向プログラミング

| 依存関係逆転

ポリモーフィズムの安全で便利な仕組みが使えるようになる前に、 どのようなソフトウェア があったのかを想像してほしい。 典型的な呼び出しツリーでは、 main 関数が上位レベルの関数 を呼び出し、それが中間レベルの関数を呼び出し、それが下位レベルの関数を呼び出す。 ソー スコードの依存関係は、依然として制御の流れに従っている (図5-1)。

ソースコードの 依存關係 Main HL1 HL2 制御の 流れ HL3 ML ML2 ML3 MLA MLS ML6 LL1 LL2 ய ш LLS LL7 LL10 LL11 LL12

5-1 ソースコードの依存関係と制御の流れ

main が上位レベルの関数の1つを呼び出すためには、その関数を含むモジュールの名前に言 及する必要がある。 C言語では#include を使う。 Java では import 文を使う。 C#では using 文を使う。 呼び出し元は、呼び出し先を含んだモジュールの名前に言及しなければいけない。

こうした制約があるため、 ソフトウェアアーキテクトにはわずかな選択肢しか残されて い。 制御の流れはシステムの振る舞いによって決まり、ソースコードの依存関係は制御の流れ によって決まるのである。

だが、ポリモーフィズムを活用すると、まったく異なることが発生する (図5-2)。 図5-2では、 モジュール HL1がモジュール ML1 にあるF() 関数を呼び出している。 インター フェイス経由で関数を呼び出しているところが、 ソースコードの仕掛けだ。 実行時には、イン ターフェイスは存在しない。 HL1 は ML1 にある F() を呼び出すだけだ。

ML1とインターフェイスIのソースコードの依存関係 (継承関係) が、制御の流れと逆転し ていることに注目してほしい。 これは依存関係逆転と呼ばれ、 ソフトウェアアーキテクトに大 きな影響を与えるものである。

00 言語が安全で便利なポリモーフィズムを提供しているというのは、ソースコードの依存

7 間接的ではあるが。

68

ポリモーフィズムとは?

HL1 図5-2 依存関係逆転 +F() Δ ML1 +F()

関係は(たとえどこにあっても) 逆転できることを意味する。

再び図 5-1の呼び出しツリーとソースコードの依存関係を見てみよう。 ソースコードにある すべての依存関係は、 インターフェイスを挿入することで逆転可能である。

このアプローチを使うことで、 00 言語で書かれたシステムに取り組んでいるソフトウェア アーキテクトは、システムにあるすべてのソースコードの依存関係の方向を絶対的に制御でき る。依存関係を制御の流れに合わせる必要はない。どのモジュールが呼び出しを行い、どのモ ジュールが呼び出されようとも、ソフトウェアアーキテクトはソースコードの依存関係をどの 方向にも向けることができる。

これはパワーだ! これが00 の提供するパワーである。 これこそが本当の00だ。 少なく ともアーキテクトの観点からはそう言える。

このパワーで何ができるだろうか? たとえば、 システムのソースコードの依存関係を並べ 替えるだけで、他の方法を使わなくても、データベースとユーザーインターフェイス (UI) をビ ジネスルールに依存させることができる (図 5-3)。

UI Business Rules Database

図5-3 データベースとユーザーインターフェイスはビジネスルールに依存している

つまり、UI とデータベースをビジネスルールのプラグインにできるということだ。 したがっ て、ビジネスルールのソースコードからUIやデータベースに言及することはない。

結果として、ソースコードと同じ依存関係のまま、ビジネスルール、 UI、 データベースを3 つの異なるコンポーネントやデプロイメントユニット (jar ファイル、DLL、 Gem ファイルな と)にまとめることができる。 つまり、ビジネスルールを含むコンポーネントは、UIやデータ ベースを含むコンポーネントに依存しないということだ。

69

ジェクト指向プログラミング

また、ビジネスルールはやデータベースとは独立してデプロイできる。 UI やデータベー に対する変更が、 ビジネスルールに影響を与えることはない。 これらのコンポーネントはビ ネスルールとは関係なく、 独立してデプロイできるからだ。

コンポーネントのソースコードを変更しても、そのコンポーネントだけを再デプロイすれば いい これが、独立デプロイ可能性である。

システムにあるモジュールを個別にデプロイできるなら、別々のチームが個別に開発できる。 これが、 独立開発可能性である。

まとめ

「OO とは何か?」 この質問には、多くの意見と多くの答えがある。 だが、 ソフトウェアアー キテクトにとって、 その答えは明らかだ。 00 とは 「ポリモーフィズムを使用することで、シ ステムにあるすべてのソースコードの依存関係を絶対的に制御する能力」である。

これにより、アーキテクトは「プラグインアーキテクチャ」 を作成できる。 これは、上位レ ベルの方針を含んだモジュールを下位レベルの詳細を含んだモジュールから独立させることで ある。 下位レベルの詳細はプラグインモジュールとなり、 上位レベルの方針を含んだモジュー ルとは独立して、 デプロイおよび開発することが可能となる。

70 10

関数型プログラミング

第6袋

SICP

さまざまな意味で、 関数型プログラミングの概念はプログラミング以前から存在する。 この パラダイムは、1930年代に Alonzo Church が発明したラムダ計算にもとづいている。

整数の二乗

関数型プログラミングを説明するために、いくつかの例を見ていこう。 まずは簡単な計算だ。 最初の25の整数の二乗を印字するというものだ。 Java のような言語では、以下のように書くことになるだろう。

public class Squint ( public static void main(String args[]) { for (int i=0; i<25; i++) System.out.println(i*1); }

71

関数型プログラミング

第6章

Clojure (Lisp の派生言語) などの関数型の言語では、同じプログラムを以下のように実装す るだろう。

println(take 25 (map (fn [x] (xx)) (range))))

Lisp を知らないなら、 少し奇妙に見えるかもしれない。 少しだけフォーマットし直して、い くつかのコメントを追加してみよう。

(println (take 25.. Print (印字する) the first 25 (最初の25を) (map(fn[x] (xx));__ squares (二乗する) (range))));_ of Integers (整数の)

println take, map、 range がすべて関数であることはわかるだろう。 Lisp では、括弧で囲

んで関数を呼び出す。 たとえば、 (range) は range 関数を呼び出している。 (fn [x] ( xx)) という式は、引数を2回渡して乗算関数を呼び出す無名関数である。 つま り、入力の二乗を計算するものだ。

再び全体を見ると、 内側の関数呼び出しから説明するとよさそうだ。

range 関数は、0から始まる整数の無限リストを返す。

先ほどのリストは map 関数に渡される。 これは、 各要素に対して二乗の無名関数を呼び出 し、整数の二乗の無限リストを生成する。

先ほどの二乗のリストは take 関数に渡される。 これは、最初の25個の要素だけを含んだ 新しいリストを戻す。

●println 関数は入力を印字する。 入力となるのは、整数の二乗のリストの最初の25個のリ ストである。

「無限リスト」と聞いて不安になったかもしれないが、心配する必要はない。 実際に生成され るのは、最初の25個の要素だけを含んだリストである。 無限リストの要素は、 アクセスされる まで評価されないからだ。

すべての不安が解消できたら、これから Clojure と関数型プログラミングを学べるすばらし い時間を心待ちにしてほしい。 ただし、 ここではこれらについて教えることが目的ではない。 私の目的は、 Clojure と Java プログラムの大きな違いについて指摘することだ。 Java プログ ラムは、可変変数(プログラムの実行中に状態を変化させる変数) を使用する。 たとえば、 ルー

プの制御変数がそうだ。 だが、 そのような変数は Clojure プログラムには存在しない。 先ほ

72

可変性の分離

どの Clojure プログラムを見ると、 xなどの変数は初期化されているが、そこから変更されるこ とはない。

このことが驚くべき主張につながる。 それは 「関数型言語の変数は変化しない」 というものだ。

不変性とアーキテクチャ

アーキテクチャの観点からすると、なぜこれが重要なのだろうか? なぜアーキテクトは、 変数の可変性に配慮すべきなのだろうか? その答えは、簡単すぎるくらいである。 それは、 競合状態、 デッドロック状態、 並行更新の問題の原因が、すべて可変変数にあるからだ。 変数 が変化しないのであれば、競合状態や並行更新の問題は発生しない。 また、 変更可能なロック がなければ、 デッドロックになることもない。

言い換えれば、 並行処理の (複数のスレッドやプロセスを必要とする) アプリケーションに おいて直面するあらゆる問題は、 可変変数がなければ発生しないのである。

アーキテクトならば、 並行性の問題には関心があるはずだ。 設計しているシステムを複数の スレッドやプロセッサの環境でも、堅牢に動作させたいはずである。 ここで、 みなさんは自分 自身にこう問いかけていることだろう。 「不変性は実際に使えるのか?」 と。

ストレージとプロセッサ速度が無限にあれば、その答えは肯定的なものとなる。 これらのリ ソースが無限になければ、その答えは少し微妙になる。 つまり、 ある程度の妥協ができれば、 不変性は実際に使えるだろう。

こうした妥協をいくつか見ていこう。

可変性の分離

不変性に関する最も一般的な妥協となるのは、アプリケーションまたはアプリケーションの サービスを「可変コンポーネント」 と 「不変コンポーネント」 に分離することである。 不変コ ンポーネントは、 可変変数を使わずに、 純粋に関数的にタスクを行う。 不変コンポーネントは、 変数の状態の変更を許可している (純粋に関数的にタスクを行わない) 1つ以上のコンポーネ ントと通信する (図 6-1)。

状態の変更により、 これらのコンポーネントは並行性の問題に遭遇する可能性がある。 した がって、 変更可能な変数を並行更新や競合状態から保護するために、 トランザクショナルメモ リを使用するのが一般的である。

トランザクショナルメモリとは、 データベースがディスクのレコードを扱うのと同じように、

73

関数型プログラミング

不変コンポーネント 可変 コンポーネント トランザクショナル メモリ 図6-1 可変状態とトランザクショナルメモリ

メモリ内の変数を扱うものである。 変数をトランザクションやリトライベースのスキームから 保護してくれる。

このアプローチの簡単な例として、 Clojure の atom がある。

(def counter (atom 0)); initialize counter to 0 (カウンターを0で初期化) (swap! counter inc); safely increment counter. (安全にカウンターを加算)

このコードでは、変数 counter は atom として定義されている。 Clojure では、 atom は特別 な種類の変数であり、その値は厳しい条件下で、 swap! 関数によって強制的に変更する必要が ある。

先ほどのコードの swap! 関数は、変更する atom と、 新しい値を計算して atom に格納する関 数の2つの引数をとる。ここでは、引数を増加させる inc 関数によって、 counter という atom の値を変更している。

swap! が使用する戦略は、従来からある比較と置換のアルゴリズムだ。 counter の値を読み 込んでから、 inc に渡している。 inc から戻ったときに、 counter をロックして、 inc に渡した 値と比較する。 値が同じならば、 inc から戻された値を counter に格納して、 ロックを解除す る。 値が違っていたら、 ロックを解除して、 戦略を最初から再試行する。

atom は、 簡単なアプリケーションには適している。 だが、 従属変数が複数になると、並行更 新やデッドロックから安全に保護することはできない。 そのような場合は、さらに洗練された 機構を使用することになる。

I わかっている ・ディスクを知らない人もいるだろう。

第6章

74

イベントソーシング

適切に構造化されたアプリケーションは、変数を変更しないコンポーネントと変更するコン ポーネントに分離されている。 こうした分離は、変更された変数を保護する適切な規律を使う ことで実現されている。

アーキテクトならば、不変コンポーネントにできるだけ多くの処理を押し込み、 可変コンポー ネントからできるだけ多くのコードを追い払うべきだろう。

イベントソーシング

ストレージと処理能力の限界は、 我々の視界から急速に遠ざかっている。 今では、プロセッ サは毎秒数十億の命令を実行し、数十億バイトのRAMを持つことが一般的である。 記憶容量 が増え、マシンが高速になれば、変更可能な状態を持つ必要性は薄くなっていく。 簡単な例として、 顧客の口座残高を保持する銀行アプリケーションを想像してほしい。 入出 金の取引を実行すると、 口座の残高が変更される。

では、口座の残高を保存する代わりに、取引のみを保存すると考えてみよう。 残高を知りた い場合は、これまでのすべての取引を合計するのである。 この仕組みならば、 可変変数は必要 ない。

このアプローチは明らかにおかしい。 時間が経つにつれて、取引の数は際限なく増加し、合 計を計算するために必要な処理能力が維持できなくなるだろう。 この仕組みを永遠に機能させ るには、無限のストレージと無限の処理能力が必要になるだろう。

だがおそらく、この仕組みを永遠に機能させる必要はない。 アプリケーションの寿命期間だ けこの仕組みを機能させるなら、 すでに我々は十分な記憶容量と十分な処理能力を持っている。 これがイベントソーシングの背景にある考え方だ。 イベントソーシングとは、状態ではな 取引 (トランザクション) を保存するという戦略である。 状態が必要になれば、 すべての取 引を収集すればいい。

もちろんショートカットも用意されている。 たとえば、 毎晩0時に状態を計算して保存して おくことができる。 そして、状態が必要になれば、 0時からの取引だけを計算すればいいので ある。

この仕組みに必要なデータストレージを考えてみよう。 おそらく膨大な量が必要になるはず だ。 実際、 オフラインのデータストレージは急速に増加しており、現在では数兆バイトのデー タ量でも少ないと考えられている(したがって、ものすごい量が必要になる)。

さらに重要なのは、こうしたデータストアに対して、 削除や更新は行われないということだ。

この概念を教えてくれた Greg Young に感謝。

75

章 関数型プログラミング

その結果、アプリケーションはCRUD にはならず、 CR だけになる。 また、 並行更新の問題も 発生しない。

十分な記憶容量と十分な処理能力があれば、 アプリケーションを完全に不変にできる。した がって、完全に関数型になる。

まだおかしいと思っているようなら、この仕組みはソースコード管理システムとまったく同 じであることを思い出すといいだろう。

まとめ

これまでの流れをまとめよう。

●構造化プログラミングは、直接的な制御の移行に規律を課すものである。 ●オブジェクト指向プログラミングは、間接的な制御の移行に規律を課すものである。 ●関数型プログラミングは、 代入に規律を課すものである。

第6

これら3つのパラダイムは、我々から何かを奪っている。 それぞれがコードの書き方に何らか の制限をかけている。 いずれのパラダイムも我々にパワーや能力を与えてくれるものではない。 過去半世紀にかけて我々が学んだのは、何をすべきではないかである。

そのために我々は、歓迎できない事実に直面する必要がある。 それは、ソフトウェアは急速 に進歩する技術ではないということだ。 現在のソフトウェアのルールは、 Alan Turing が電子 計算機で実行するための最初のコードを書いた1946年のものと同じである。 ツールは変わり、 ハードウェアも変わったが、ソフトウェアの本質は変わっていない。

ソフトウェア (コンピュータプログラムの本質) は、 「順次」 「選択」 「反復」 と 「間接参照」 で構成されている。 それ以上でもそれ以下でもない。

76

設計の原則 第 部

SO OLID KOHNKE

よくできたソフトウェアシステムは、クリーンなコードを書くことから始まる。 レンガの出来

が悪ければ、その建築は優れたものにはならない。 一方、たとえよくできたレンガを使っても、 ぐちゃぐちゃなものを作ってしまうことがあり得る。 そこで登場するのが 「SOLID 原則」だ。 SOLID 原則は、 関数やデータ構造をどのようにクラスに組み込むのか、 そしてクラスの相互 接続をどのようにするのかといったことを教えてくれる。 「クラス」という用語を使ったから といって、これらの原則がオブジェクト指向ソフトウェアにしか通用しないわけではない。 こ こでいうクラスとは、単にいくつかの機能やデータをとりまとめたものを指しているにすぎな い。 「クラス」と呼ぶかどうかは別として、 どのようなソフトウェアシステムにもそのような仕 組みはあるはずだ。 SOLID 原則は、そうした仕組みに適用するものである。 SOLID 原則の目的は、以下のような性質を持つ中間レベルのソフトウェア構造を作ることだ。

●変更に強いこと

●理解しやすいこと

●コンポーネントの基盤として、 多くのソフトウェアシステムで利用できること

77

第I部 設計の原則

「中間レベルの」 という言葉は、 SOLID 原則がモジュールレベルの開発に使われるものである ことを意図している。 コードレベルよりも上に適用するものであり、 モジュールやコンポーネ ントで使うソフトウェア構造の定義に役立つ。

よくできたレンガを使っても、ぐちゃぐちゃな建築になってしまうことがあるのと同様に、 中間レベルのコンポーネントがいくらよくできていても、システム全体としてはひどいものに なってしまうことがある。 そのため、 SOLID 原則の説明が終わったら、 次はそれに対応するコ ンポーネントの原則を説明する。 そのあとに上位レベルのアーキテクチャの原則の話に移る。

SOLID 原則の歴史は古い。 私がいろいろな原則をまとめるようになったのは、80年代後半の ことだった。 あの頃の私は、USENET (Facebook のご先祖様みたいなものだと思ってほしい) ソフトウェア設計の原則についていろんな議論をしていた。 議論を重ねるにつれて、原則が 変化することもあった。 なかには消えてしまったものもあるし、 いくつかの原則をひとつにま とめたこともあった。 新しい原則を追加したこともあった。 最終的に安定したのは2000年代初 期のことだったが、当時は今とは違う順番で原則を紹介していた。

確か2004年だったと思うが、 Michael Feathers から 「これらの原則の並び順を変えれば、頭 文字を SOLID と読めるのでは?」というメールが届いた。 SOLID 原則誕生の瞬間だ。 この後の章で個々の原則を詳しく説明するので、ここではその概要を示す。

単一責任の原則 (SRP Single Responsibility Principle)

コンウェイの法則から導かれる当然の帰結。 個々のモジュールを変更する理由がたったひ とつだけになるように、ソフトウェアシステムの構造がそれを使う組織の社会的構造に大 きな影響を受けるようにする。

●オープン・クローズドの原則 (OCP Open-Closed Principle)

Bertrand Meyer が 80年代に広めた原則。 ソフトウェアを変更しやすくするために、 既存 のコードの変更よりも新しいコードの追加によって、 システムの振る舞いを変更できるよ うに設計すべきである。

●リスコフの置換原則 (LSP Liskov Substitution Principle)

Barbara Liskov が提唱した有名な派生型の定義。 1988年に誕生。 要するに、 交換可能な パーツを使ってソフトウェアシステムを構築するなら、 個々のパーツが交換可能となるよ うな契約に従わなければいけないということ。

●インターフェイス分離の原則 (ISP Interface Segregation Principle)

ソフトウェアを設計する際には、使っていないものへの依存を回避すべきだという原則。

第16章 「独立性」の「開発」を参照。

78

第II部 設計の原則

●依存関係逆転の原則 (DIP Dependency Inversion Principle)

上位レベルの方針の実装コードは、下位レベルの詳細の実装コードに依存すべきではなく、 逆に詳細側が方針に依存すべきであるという原則。

これらの原則の詳細については、これまでにもさまざまな書籍や記事が公開されている。 本 書では、それらの文献での議論を繰り返すのではなく、 これらの原則がアーキテクチャ的にど のような意味を持つのかを中心に説明する。 SOLID 原則についてなじみのない人にとっては、 本書の説明だけでは不十分かもしれない。 その場合は、 脚注で紹介した文献をあたってみると いいだろう。

2拙書 「アジャイルソフトウェア開発の奥義」 http://www.butunclebob.com/ ArticleS.UncleBob. PrinciplesOfDod. https://en.wikipedia.org/wiki/SOLID_(object-oriented_design) など。 あるいは 「SOLID」 で検索してみるとい いだろう。

79



SRP: 単一責任の原則 第

7.

章

SOLID 原則のなかで最も誤解されがちなのが「単一責任の原則 (SRP)」 だろう。 おそらく その原因は、名前があまりよくなかったことだ。 この原則の名前を聞いたプログラマは「どの モジュールもたったひとつのことだけを行うべき」と受け取ってしまう。

確かにそのような原則も存在する。 ひとつの関数はたったひとつのことだけを行うべきとい うものだ。 巨大な関数にリファクタリングを施して、 小さな関数に切り分けるときに使うのが この原則である。 ただ、 これを用いるのは最下位のレベルだ。 SOLID 原則の単一責任の原則 (SRP)とは別のものである。

かつて単一責任の原則 (SRP) は、以下のように語られてきた。

モジュールを変更する理由はたったひとつだけであるべきである。

ソフトウェアシステムに手を加えるのは、ユーザーやステークホルダーを満足させるためだ。 この「ユーザーやステークホルダー」こそが、単一責任の原則 (SRP) が指す 「変更する理由」 である。 つまり、この原則は以下のように言い換えられる。

81

第7章 SRP 単一責任の原則

モジュールはたったひとりのユーザーやステークホルダーに対して責務を負うべきである。

残念ながら 「たったひとりのユーザーやステークホルダー」という表現は適切ではない。 複 数のユーザーやステークホルダーがシステムを同じように変更したいと考えることもある。 こ こでは、変更を望む人たちをひとまとめにしたグループとして扱いたい。 このグループのこと をアクターと呼ぶことにしよう。

これを踏まえると、最終的な単一責任の原則 (SRP) は以下のようになる。

モジュールはたったひとつのアクターに対して責務を負うべきである。

さて、ここでいう「モジュール」とは何のことだろう? 端的に言えば、モジュールとはソー スファイルのことである。 たいていの場合は、この定義で問題ないだろう。 だが、 ソースファイ ル以外のところにコードを格納する言語や開発環境も存在する。 そのような場合の 「モジュー ル」 は、いくつかの関数やデータをまとめた凝集性のあるものだと考えよう。 「凝集性のある」 という言葉が単一責任の原則 (SRP) を匂わせる。 凝集性が、ひとつのアク

ターに対する責務を負うコードをまとめるフォースとなる。

単一責任の原則 (SRP) を理解するには、この原則に違反している例を見るのが一番だ。

症例1 想定外の重複

私がよく使うお気に入りの例が、 給与システムにおける Employee クラスだ。 このクラスに は、 calculatePay ( )、 reportHours()、save() の3つのメソッドがある (図7-1)。

Employee +calculatePay +reportHours + save сто 図7-1 Employee クラス

82

症例1 想定外の重複

このクラスは単一責任の原則 (SRP) に違反している。 3つのメソッドがそれぞれ別々のアク ターに対する責務を負っているからだ。

●calculatePay () メソッドは、 経理部門が規定する。 報告先は CFO だ。 reportHours() メソッドは、 人事部門が規定して使用する。 報告先は COO だ。 ●save() メソッドは、データベース管理者が規定する。 報告先は CTO だ。

これらのメソッドをひとつの Employee クラスに入れると、 開発者はすべてのアクターを結 合することになる。 この結合が原因となり、 CFO チームの何らかの操作が、 COO チームの使 うものに影響を及ぼしてしまうこともある。

たとえば、 calculatePay() メソッドと reportHours() メソッドの両方で所定労働時間を算 出しているとしよう。 計算アルゴリズムはどちらも同じである。 開発者はコードの重複を嫌い、 この計算部分を regular Hours () メソッドに切り出した(図7-2)。

calculate Pay reportHours regularHours 図7-2 アルゴリズムの共有

ここで、 CFO チームでの所定労働時間の算出方法に手を加える必要が出てきたとしよう。 COO チームにはその必要はない。 というのも、 人事部門では所定労働時間を別の目的で使って いたからだ。

そのタスクを担当する開発者は、 calculatePay () メソッドから regularHours () が呼ばれて いることを確認した。 だが、 regularHours () が reportHours() メソッドからも呼び出されて いることには気づかなかった。

その開発者は regularHours() に手を加えて要件を満たすようにした。 十分にテストもした。 CFOチームも期待どおりの動きをすることを確認した。 そして、 システムがデプロイされた。 もちろん、 COO チームはそのことを知らない。 人事の担当者は相変わらず reportHours()

から出てきた数字を使っている。 だが、 すでにその数字は間違っている。 やがて問題が発覚し、

COO は激怒した。 間違ったデータのせいで、 何百万ドルもの損害が出たからだ。 よく似たことは誰もが経験しているだろう。 問題が起こった原因は、別々のアクターのコー ドをひとつにまとめてしまったことにある。 単一責任の原則 (SRP) は、アクターの異なるコー

83

SRP 単一責任の原則

第7章

ドは分割するべきという原則だ。

症例2:マージ

さまざまなメソッドが含まれるソースファイルでは、マージが頻繁に発生することもめずら しくない。 個々のメソッドがそれぞれ別々のアクターに対応しているなら、なおさらそのよう な場面は多くなる。

たとえば、 CTO の配下にいる DBAチームが、 データベースの Employee テーブルのスキー マを少し変更することになったとしよう。 一方、COOの配下にいる人事の事務員も、 勤怠報告 の書式変更が必要になったとする。

おそらく別々の開発チームに属している開発者が、 それぞれ Employee クラスをチェックア ウトして変更を始めることになるだろう。 残念ながら、 双方の変更内容が衝突したようだ。 こ んなときにはマージが必要になる。

マージのリスクについてはわざわざ説明する必要もないだろう。 いまどきのツールならうま い具合にこなしてくれる。 だが、どんな場面にも対応できる万能のツールなど存在しない。 ど うしてもリスクは残ってしまう。

今回のマージの例では、 CTO と COO の双方にリスクが残る。さらには、 CFO まで巻き添え を食らう可能性も否定できない。

その他にもさまざまな症例が考えられるが、いずれも複数の人たちがそれぞれ別の理由で、 同じソースファイルを変更することに原因がある。

改めて言うが、こうした問題を回避するには、 アクターの異なるコードは分割するべきである。

解決策

これらの問題にはさまざまな解決策がある。 いずれも関数を別のクラスに移動するというも のだ。

一番わかりやすいのは、データを関数から切り離すというものだろう。 たとえば、3つのク ラスから EmployeeData クラスを使うようにする。 このクラスは、シンプルなデータ構造を持 つだけで、メソッドはひとつも含まれていない (図7-3)。 3つのクラスはそれぞれ、 特定の機 能に必要なソースコードだけを保持している。 また、他のクラスについて知ることは許可され ていない。 こうしておけば、想定外の重複は避けられる。

この解決策にも弱点がある。 開発者が3つのクラスをインスタンス化して、追跡しなければ

84

解決策

PayCalculator + calculatePay HourReporter + report Hours EmployeeSaver + saveEmployee Employee Data

図7-3 3 つのクラスはお互いに相手のことを知らない

いけないという点だ。 このジレンマを解決するために一般的に使われるのが、 Facade パター ンである (図7-4)。

Employee Facade + calculatePay + report Hours + save PayCalculator + calculate Pay HourReporter + reportHours EmployeeSaver + save Employee 図7-4 Facade パターン Employee Data

EmployeeFacade に含まれるコードはごくわずかである。 その責務は、 実行したいメソッド を持つクラスのインスタンスを生成して、 処理を委譲するだけだ。

重要なビジネスルールはデータの近くに置いておきたいと考える開発者もいるだろう。その 場合は、 元の Employee クラスに重要なメソッドだけを残し、 重要ではないメソッドを呼び出 す Facade として使えばいい (図7-5)。

Employee -employeeData + calculate Pay + reportHours + save HourReporter + report Hours EmployeeSaver + saveEmployee

図7-5 元の Employee クラスに重要なメソッドだけを残し、重要ではないメソッドのFacade として使う

メソッドがひとつしかないクラスばかり作られるという理由で、この方法を気に入らない人 もいるだろう。 だが、 そのようなことになるはずがない。 給与計算や帳票出力やデータの保存

85

第7章 SRP : 単一責任の原則

に必要なメソッドの数は多くなる。 また、 各クラスには、 private メソッドがいくつも含まれる ことになるだろう。

関連するメソッドを持つクラスは、それぞれがひとつのスコープを表す。 スコープの外から は、 どのような private メンバーが存在するかはわからない。

まとめ

単一責任の原則 (SRP) は関数やクラスに関する原則だが、 同じような原則が別のレベルで も登場する。 コンポーネントレベルでは、この原則は 「閉鎖性共通の原則 (CCP)」 と呼ばれる ようになる。 また、 アーキテクチャレベルでは、 「アーキテクチャの境界」を作るための「変更 の軸」と呼ばれている。 これらについては、すべてこの後の章で取り上げる。

86

OCP : オープン・

クローズド の原則 第8章

SLVO

SAVO payta

「オープン・クローズドの原則 (OCP)」 は、 1988 年に Bertrand Meyer が提唱した以下のよ うな原則だ。

ソフトウェアの構成要素は拡張に対しては開いていて、 修正に対して閉じていなければならない。 「アジャイルソフトウェア開発の奥義 第2版」 (SBクリエイティブ) より引用

言い換えれば、ソフトウェアの振る舞いは、既存の成果物を変更せず拡張できるようにすべ きである、ということだ。

これこそが、 我々がソフトウェアアーキテクチャを学ぶ根本的な理由だ。 ちょっとした拡張 のために大量の書き換えが必要になるようなら、そのソフトウェアシステムのアーキテクトは 大失敗への道を進んでいることになる。

ソフトウェア設計の研究者の多くは、オープンクローズドの原則 (OCP) はクラスやモジュー ルを設計する際の指針となる原則だと考えている。 だが、 コンポーネントのレベルを考慮した ときに、この原則はさらに重要なものとなる。

| Benrand Meyer. Object Oriented Software Construction, Prentice Hall, 1988, p. 23. (邦訳: 「オブジェクト指向入門」 アスキー)

87

章 OCP オープン・クローズドの原則

第8

本章で思考実験をすることで、それが明確になるだろう。

思考実験

財務情報をウェブページに表示するシステムを考えてみよう。 ページ上のデータはスクロー ルできて、負の数値は赤く表示される。

ステークホルダーから 「画面に出ている内容と同じものを、白黒のプリンターで印刷したい」 という要望が出たとしよう。印刷するとしたら、適切なページ処理が必要になるだろう。 各ペー ジのヘッダーやファター、 列の見出しも必要になる。 負の数値は括弧で囲むなどの処理も必要 だろう。

新しくコードを書かなければいけないのは明白だが、 既存コードの修正はどれくらい必要に なるだろう?

よくできたソフトウェアアーキテクチャなら、 既存コードの修正は必要最小限に抑えられる だろう。 修正なしで済ませられれば理想的だ。

だが、その方法は? まずは、変更する理由が異なるものは、単一責任の原則 (SRP) で適 切に分割する。そして、それらの依存関係を依存関係逆転の原則 (DIP) で適切にまとめる。 単一責任の原則 (SRP) を適用する際には、 図8-1 のようなデータフロー図を使うことにな るだろう。財務データを分析して会計報告データを生成し、これを2種類の出力処理で適切に フォーマットする。

財務分析

財務データ

Web

レポート出力

会計報告データ

(印刷レポート出力

図8-1 SRPを適用する

ここで重要なのは、レポートの作成は2つの異なる責務を伴うことだ。 出力するデータの計 と、 ウェブ (あるいは印刷)向けの表示形式の作成である。

この2つを分離するには、ソースコードの依存関係を適切に調整し、一方に影響を与えるこ となく変更できるようにする必要がある。 また、 変更を取り消すことなく振る舞いを拡張でき るようにする必要がある。

88

これを実現するには、処理をクラスに分割して、それぞれのクラスをコンポーネントにまとめ る。 図8-2の二重線がコンポーネントを表している。 図の左上のコンポーネントが Controller 右上が Interactor、 その下がDatabase である。 左下には、 Presenter と View を表す4つのコ ンポーネントがある。

:Controller: <<DS> Financial Report Financial Request Report Controller Financial Report Presenter Screen Presenter: Screen Presenter Print Presenter Print Presenter Financial Report Requester Financial Report Response cinteractor Financial Report Generator Financial entities <ADS Financial Data Gateway Databas <<DS> <DE> Financial Data Financial Database Screen Print Mapper View View Model Model Screen View Print View =Web View: PDF View Web PDF View View

図8-2 処理をクラスに分割し、クラスをコンポーネントにまとめる

<I>マークがついているクラスはインターフェイスで、 <DS>マークはデータ構造を表してい る。また、通常の矢印は使用の関係、白抜きの矢印は実装や継承の関係を表している。 まず気づくのが、 すべての依存関係はソースコードに関するものであるということだ。 たと えば、クラスAからクラスBに矢印が引かれている場合は、クラスAのソースコードからクラ スBの名前についての言及がある。 だが、 クラスBからクラスAへの言及はない。 たとえば、

図8-2において、 Financial DataMapper は実装の関係によって FinancialDataGateway のこと を知っているが、 Financial DataGateway は FinancialDataMapper のことを一切知らない。

また、二重線で囲まれた枠を越える線が、すべて一方通行になっていることにも気づく。 こ れはつまり、 コンポーネントの関係が単方向であることを意味している。 コンポーネントは図

思考実験

89

第8章 OCP オープン・クローズドの原則

8-3 のようになる。 矢印の向かっている先が、 自分自身を変更したときに影響を及ぼしたくな コンポーネントである。

4 Financial Report Controller Financial Report Interactor Screen Presenter Print Presenter Financial Database Web View PDF View

図8-3 コンポーネントの関係は単方向である

改めて言おう。 コンポーネントAがコンポーネントBの変更から保護されるべきならば、コ ンポーネントBからコンポーネントAへ依存すべきである。

ここでは、 Presenter を変更したときに、 Controller を変更する必要をなくしたい。 Views を変更したときに、 Presenter を変更する必要をなくしたい。 他のすべてを変更したときに、 Interactor を変更する必要をなくしたい。

オープン・クローズドの原則 (OCP) に最も適しているのは、Interactor である。 Database. Controller Presenter View を変更しても、 Interactor には何の影響も及ぼさない。

なぜ Interactor がそんなにも特権的な位置づけになるのだろう? それは、ビジネスルール を含んでいるからだ。 Interactor は、 アプリケーションの最上位レベルの方針を含んでいる。 そのほかのコンポーネントは、周辺にある関心事を処理している。 Interactor は、 その中心と なる関心事を処理している。

Controller は Interactor の周辺にある関心事だが、その一方で Presenter や View に対し ては中心的な位置づけになる。 同じく Presenter も、 Controller に対しては周辺的だが、 View に対しては中心的な位置づけになる。

90

情報隱廏

「レベル」の概念にもとづいた保護の階層ができていることに注目しよう。 Interactor は最上 位レベルの概念なので、これが最も保護される。 View は最下位レベルの概念なので、保護レベ ルは最も低くなる。 Presenter は、 View よりも上位にあるが、 Controller や Interactor よりも 下位レベルにある概念だ。

これが、アーキテクチャレベルにおけるオープン・クローズドの原則 (OCP) だ。 アーキテ クトは、いつどのような理由でどのように変更するかを考えて機能を分割する。 そして、 分割 した機能をコンポーネントの階層構造にまとめる。 上位レベルにあるコンポーネントは、下位 レベルのコンポーネントが変更されたとしても、 変更する必要はない。

方向の制御

先ほどのクラス図に怖じ気づいた人がいるなら、ここでもう一度見直してほしい。 図が複雑 になっているのは、コンポーネントの依存関係が正しい方向になるように制御するためだった。

たとえば、 Financial DataGateway インターフェイスが Financial Report Generator と Finan

cialDataMapperの間に入っているのは、 Interactor コンポーネントから Database コンポーネ ントへの依存関係を逆転させるためである。 Financial ReportPresenter インターフェイスや 2つのView インターフェイスの役割も同様だ。

情報隱蔽

Financial ReportRequester インターフェイスは、 依存関係の逆転とは別の役割を担ってい る。このインターフェイスの役割は、FinancialReportController が Interactor の内部を知り すぎないように保護することである。 このインターフェイスがなければ、 Controller は推移的 にFinancial Entities に依存してしまう。

推移的な依存関係は 「ソフトウェアのエンティティは自分が直接使っていないものに依存す べきではない」 という大原則に違反している。この大原則については、後ほどインターフェイ ス分離の原則 (ISP) や全再利用の原則 (CRP) について説明するときに再び取り上げる。

Controller への変更が Interactor に影響を及ぼさないようにすることが最優先ではあるが、 Controllerもまた Interactor の変更から保護しておきたい。 そのために、 Interactor の内部を 隠蔽しているのである。

第8章 OCP オープン・クローズドの原則

まとめ

オープンクローズドの原則 (OCP) は、システムのアーキテクチャの隠れた原動力である。 その目的は、変更の影響を受けずにシステムを拡張しやすくすることだ。 目的を達成するため に、システムをコンポーネントに分割して、コンポーネントの依存関係を階層構造にする。 そ して、上位レベルのコンポーネントが下位レベルのコンポーネントの変更の影響を受けないよ うにする。

92

LSP : リスコフの置換原則

第2章

TLISKOVP

A! CLISKOY

FOR PRESIDENT

FOR PRESIDEN

ELISKO

LISKOVE

FOR PRES

KOHNKE

1988年に Barbara Liskov が、 派生型について以下のように定義した。

ここで望まれるのは、 次に述べるような置換可能な性質である S型のオブジェクト 01 の各々に、 対応するT型のオブジェクト o2が1つ存在し、 Tを使って定義されたプログラムPに対して 02 の代わりに 01 を使ってもPの振る舞いが変わらない場合、 SはTの派生型であると言える。 「アジャイルソフトウェア開発の奥義 第2版』 (SBクリエイティブ) より引用

この考えは「リスコフの置換原則 (LSP)」 と呼ばれている。 いくつか例を見てみよう。

継承の使い方の指針

図9-1に示すような License クラスについて考えてみよう。 このクラスには calcFee() メ ソッドがあり、 Billing アプリケーションから呼ばれている。 また、 License の 「派生型」が

. Barbara Liskov, "Data Abstraction and Hierarchy.

SIGPLAN Notices 23.5 (May 1988).

93

第9章 LSP:リスコフの置換原則

2つある。 PersonalLicense と BusinessLicense だ。 これらは、それぞれ異なるアルゴリズム を用いてライセンス料を計算する。

Billing License +calcFee() Personal License Business License - users

図9-1 License とその派生型。 リスコフの置換原則 (LSP) を満たしている。

この設計はリスコフの置換原則 (LSP) を満たしている。 Billing アプリケーションは、使っ ている2つの派生型に依存していないからだ。 どちらの派生型も License 型に置き換えること ができる。

正方形 長方形問題

リスコフの置換原則 (LSP) 違反のお手本のような例が、かの有名な (悪名高いと言うべき か)正方形・長方形問題だ (図9-2)。

User Rectangle +setH, +setW Square + setSide

図9-2 悪名高き正方形 長方形問題

この例のSquare (正方形) は、 Rectangle (長方形) の適切な派生型とは言えない。なぜな Rectangleは幅と高さをそれぞれ独立して変えられるのに対して、 Square は両方を同時に 変える必要があるからだ。 User が相手を Rectangle であると信じていると、 おかしなことに

94

リスコフの置換原則 (LSP) とアーキテクチャ

なってしまう。 以下のコードを見てみよう。

Rectangler= r.setW(5); r.setH(2); assert (r.area() == 10);

最初の…のところで Squareのインスタンスを作っていると、 最後のアサーションは失敗す るだろう。

こうしたリスコフの置換原則 (LSP) 違反から身を守る唯一の手段は、 User のなかに (たと えば if 文を使うなどして) Rectangle の正体がSquare かどうかを検出する仕組みを用意する ことだ。 ただし、 User の振る舞いが使用する型に依存することになるので、これらの型は置換 可能ではなくなってしまう。

リスコフの置換原則 (LSP) とアーキテクチャ

オブジェクト指向の黎明期には、リスコフの置換原則 (LSP) は (先ほどのセクションで紹 介したような) 継承の使い方の指針になるものだと考えられていた。 だが、時間をかけてその 適用範囲は広がり、 今ではインターフェイスと実装に関するソフトウェア設計の原則になって いる。

対象となるインターフェイスにはさまざまな形式がある。 Java 風のインターフェイスは、そ れを実装したクラスをいくつも作れる。 Ruby であれば、 同じメソッドシグネチャを共有する クラスをいくつも作れる。 ウェブであれば、 同じREST インターフェイスに応答するサービス をいくつも作れる。

これらを含めたさまざまな場面にリスコフの置換原則 (LSP) を適用できる。 ユーザーはき ちんと定義されたインターフェイスに依存しており、そのインターフェイスの実装の置換可能 性にも依存しているからだ。

アーキテクチャの観点からリスコフの置換原則 (LSP) を理解するには、この原則に違反し たときにシステムのアーキテクチャに何が起こるのかを考えてみるのが一番だ。

95

章 LSP リスコフの置換原則

リスコフの置換原則 (LSP) 違反の例

さまざまなタクシー配車サービスを集約するシステムを作っているとしよう。 我々のウェブ サイトを使うユーザーは、複数のタクシー会社を横断して、 自分に最適なタクシーを探すこと ができる。 ユーザーがタクシーを決めたら、 我々のシステムがRESTful サービスを使ってタク シーを配車する。

このとき、 RESTful な配車サービスのURIは、 運転手データベースに含まれる情報の一部で あるものとする。 我々のシステムがユーザーのリクエストを満たす運転手を選んだら、 まずは 運転手データベースから URI を取得する。 そして、 そのURI を使い、 お目当ての運転手を呼び 出す。

たとえば、 運転手 Bob の呼び出し URIが以下のようなものだったとしよう。

purplecab.com/driver/Bob

我々のシステムは、このURI に配車情報を付加して、以下のような PUT リクエストを送る ことになる。

purplecab.com/driver/Bob /pickupAddress/24 Maple St. /pickupTime/153 /destination / ORD

もちろん、すべての配車サービスが同じREST インターフェイスに準拠していることが前提 だ。 すべての会社が、 pickupAddress、 pickup Time, destination といったフィールドを同じ ように扱う必要がある。

ここで、 Acme というタクシー会社が、仕様をきちんと読み取れないプログラマを雇ったと しよう。そのプログラマは、 destination というフィールド名を dest と省略してしまった。 Acme は地域最大のタクシー会社で、 CEO の離婚した元妻が我々の会社のCEO と結婚するら しい･･････。 さて、なんとなく状況はわかった。 このとき、 我々のシステムのアーキテクチャは どうなるだろうか?

我々のシステムに特別な処理を組み込む必要があるのは間違いない。 Acme の運転手の配車 リクエストを組み立てるときには、 その他の運転手へのリクエストとは別のルールを使う必要 がある。

第9

96

最もシンプルな方法は、配車コマンドを組み立てるモジュールに if文を追加するというも のだ。

if (driver.getDispatchUri().startsWith("acme.com"))…

もちろん、 有能なアーキテクトならそんな小細工は許さないだろう。 "acme" をハードコーディ ングしてしまうと、ありとあらゆる不具合の原因になってしまう。 また、セキュリティの問題 につながる可能性もあるだろう。

たとえば、成長を続ける Acme が別のタクシー会社 Purple を買収したとしよう。 合併した 新会社のなかで、 Acme と Purple はそれぞれ別々のブランドとして生き続けることになった。 ウェブサイトは別々に持つが、システムは旧 Acme のものに統一することになった。このとき、 我々のシステムは、 "purple" 用にもうひとつif文を追加することになるのだろうか?

アーキテクトはこの手のバグからシステムを守る必要がある。 URI をキーとする設定データ ベースを使い、 何らかの配車コマンド作成モジュールを用意することになるだろう。 その設定 データは、たとえば以下のようになる。

URI 配車フォーマット Acme.com /pickupAddress/%s/pickupTime/%s/dest%s /pickupAddress/%s/pickupTime/%s/destination/%s

RESTful サービスのインターフェイスが置換可能になっていないせいで、アーキテクトは複 雑な仕組みを追加することになってしまった。

まとめ

リスコフの置換原則 (LSP) はアーキテクチャのレベルにも適用できる。 むしろ適用すべき である。 置換可能性に少しでも違反してしまうと、システムのアーキテクチャが特別な仕組み だらけになってしまう。

まとめ

97



ISP: インターフェイス分離の

第 原則 10円

KOHNKE

「インターフェイス分離の原則 (ISP)」 の名前の由来を図 10-1 に示した。

User1 User2 User3 OPS +op1 +op2+op3

図 10-1 インターフェイス分離の原則 (ISP)

10-1では、複数のユーザーが同じOPSクラスを使っている。 ここでは、User1 が op1 を使 い。 User2op2 を使い、 User3 が op3を使っているものとする。 OPS が、 Java のような言語で書かれたクラスだとしよう。 Userl のソースコードは、 実際に

99

第10章 ISP: インターフェイス分離の原則

は使っていないop2 とop3にも意図せずに依存している。 ここでいう 「依存」とは、 op2 のコー ドを変更したときに、 Userl の再コンパイルと再デプロイが必要になるという意味だ。 本来な らば、 op2 のコードが変わっても気にする必要はないはずだ。

この問題を解決するには、 各操作をインターフェイスに分離すればいい (図 10-2)。

先ほどと同じく Java のような静的型付け言語で実装されているとすると、 User1のソース コードは U10ps と op1 には依存しているが、 OPS には依存していない。 つまり、 OPS に変更が あったとしても、もしそれが User1 に関係のない部分であれば、 User1の再コンパイルと再デ プロイは不要になる。

User1 User2 User3 U1Ops U2Ops U3Ops + op1 +op2 4 +op3 OPS [ +op1 +op2 +op3

図10-2 分離された操作

インターフェイス分離の原則 (ISP) と言語との関係

先ほど説明した内容は、プログラミング言語の種類に大きく依存する。 Java のような静的型 付け言語は、 import や use や include といった宣言をプログラマに強要する。 ソースコード に書かれたこれらの宣言がソースコードの依存性を作り出し、そのために再コンパイルと再デ プロイが必要になってしまう。

Ruby や Python のような動的型付け言語では、こうした宣言はソースコードには存在せず、 実行時に推論される。 つまり、再コンパイルや再デプロイを強制するソースコードの依存性は 存在しないのだ。 このあたりが、 静的型付け言語よりも動的型付け言語のほうが柔軟で疎結合 なシステムを作れる最大の理由である。

この事実だけを見ると、 インターフェイス分離の原則 (ISP) は言語の問題であり、 アーキテ

100

まとめ

クチャの問題ではないと考える人もいるかもしれない。

インターフェイス分離の原則 (ISP)とアーキテクチャとの関係

冷静になってインターフェイス分離の原則 (ISP) のそもそもの動機を考えてみると、そこに は深刻な問題が潜んでいることがわかる。 必要としないモジュールに依存することは一般的に 有害とされる。 ソースコードの依存関係においては、 再コンパイルや再デプロイを強制される ので明らかに有害であることがわかる。 だが、 さらに上位のアーキテクチャレベルにおいても 有害なのだ。

システムSを担当するアーキテクトが、 あるフレームワークFをシステムに導入したいと考 えたとしよう。 このフレームワークFの作者は、フレームワークを特定のデータベースDのた めだけに作っている。 つまり、SはFに依存しており、さらにFはDに依存していることにな る (図 10-3)。

システムS フレームワークF 図 10-3 問題のあるアーキテクチャ データベースD

FDのすべての機能を使っているわけではなく、 使っていない機能もあるだろう。 Sにとっ て、それらの機能はどうでもいいものだ。 だが、Dのそのような部分が変更されると、Fを再 デプロイすることになるだろう。 それはすなわち、Sも再デプロイしなければいけないという ことだ。 さらに悪いことに、Dの一部の機能に障害が発生すると、 それがFやSの障害の原因 になってしまう可能性がある。

まとめ

本章での教訓は、必要としないお荷物を抱えたものに依存していると、予期せぬトラブルの 元につながるということだ。

この件については、 第13章 「コンポーネントの凝集性」 で全再利用の原則 (CRP) を扱う際 に改めて掘り下げたいと思う。

101



DIP : 依存関係逆転の原則 11

ソースコードの依存関係が (具象ではなく) 抽象だけを参照しているもの。 それが、最も柔 軟なシステムである。 これが 「依存関係逆転の原則 (DIP)」 の伝えようとしていることである。 Java のような静的型付け言語ならば、 use や import や include で指定する参照先を、イン ターフェイスや抽象クラスなどの抽象宣言だけを含むソースモジュールに限定するということ だ。 具象に依存するべきではない。

Ruby や Python のような動的型付け言語でもルールは同じ。 ソースコードの依存性が具象 モジュールを参照してはいけない。 ただし、これらの言語では、具象モジュールが何かを明確 にするのは難しい。 ここでは、呼ばれている関数の実装が書かれているモジュールを 「具象モ ジュール」と呼ぶことにしよう。

このルールを絶対のものとして守り続けるのは明らかに現実的ではない。 ソフトウェアシス テムは数多くの具象に依存しているからだ。 たとえば、 Java の String クラスは具象であり、 これを抽象にするのは無理がある。 ソースコードが具象の java.lang.string に依存するのは 避けられないし、 避けるべきでもない。

String クラスは他のクラスに比べて非常に安定している。 変更されることはほとんどない し、あったとしてもきちんとコントロールされている。 プログラマやアーキテクトは、 String

103

依存関係運転の原則

②内コロコロ変わることなど心配しなくていい。

そのような理由から、依存関係運転の原則 (DIP) を考えるときにはOSやプラットフォーム まわりは気にしないことが多い。 変化しないとみなして構わないので、こうした具象への依存 は音することにしよう。

依存したくないのは、システム内の変化しやすい具象要素だ。 開発中のモジュールや、頻繁 に変更され続けているモジュールがその対象になる。

安定した抽象

抽象インターフェイスの変更は、それに対応する具象実装の変更につながる。 一方、具象実装 を変更してもインターフェイスの変更が必要になることはあまりない。 つまり、インターフェ イスは実装よりも変化しにくいということだ。

優れたソフトウェア設計者やアーキテクトは、 インターフェイスの変動性をできるだけ抑え ようとする。 新しい機能を実装するときにも、できる限りインターフェイスの変更なしで済ま せられるようにする。これは、ソフトウェア設計の基本中の基本だ。

安定したソフトウェアアーキテクチャは、変化しやすい具象への依存を避け、安定した抽象 インターフェイスに依存すべきである。これをコーディングレベルのプラクティスにまとめる と、以下のようになる。

●変化しやすい具象クラスを参照しない。 その代わりに抽象インターフェイスを参照するこ と静的型付け言語であっても動的型付け言語であっても、このルールを守ること。 これ はオブジェクトの生成時にも大きな制約となる。 一般的には、 Abstract Factory パターン を使うしかないだろう。

●変化しやすい具象クラスを継承しない。 これは先ほどのルールにも含まれるが、あえて言 及しておきたい。 静的型付け言語における継承は、ソースコードの関係のなかで最も強力 かつ厳格なものだ。 そのため、十分に注意しながら使う必要がある。 動的型付け言語であ ればそれほど問題にはならないが、継承が一種の依存関係であることは変わらない。 気を つけて使うのが賢明だ。

●具象関数をオーバーライドしない。 具象関数はソースコードの依存を要求することが多い。 関数をオーバーライドしても依存関係を排除することはできず、そのまま継承することに なるだろう。 依存をうまく管理するには、 元の関数を抽象関数にして、それに対する複数 の実装を用意しなければいけない。

104

Factory

●変化しやすい具象を名指しで参照しない。 これは単に依存関係逆転の原則 (DIP) を言い 換えたものにすぎない。

Factory

上記のルールに従おうとすると、具象オブジェクトを生成する際に特別な処理が必要になる。 事実上すべての言語において、 オブジェクトの生成にはオブジェクトの具象定義を含むソース コードへの依存が避けられないからだ。

Java を含む大半のオブジェクト指向言語では、 Abstract Factory パターンを使ってこの望ま ざる依存性を管理する。

その仕組みを図11-1 に示そう。 Application は、Service インターフェイス経由で ConcreteImpl を使う。 だが、Application は何らかの方法で ConcreteImpl を生成する必要がある。 Concrete Impl のソースコードに依存せずにこれを実現するために、 Application は ServiceFactoryのmakeSvc メソッドを呼ぶ。 このメソッドの実装は ServiceFactoryImplクラスで定義されており、この クラスは ServiceFactory の派生クラスである。 この実装が ConcreteImpl のインスタンスを 生成し、それを Service として戻すのである。

Application Service Factory + makeSvc <I> Service Concrete Impl Service Factory Impl +makeSvc <<creates>>

図11-1 Abstract Factory パターンによる依存性の管理

図1-1の上下を区切る曲線がアーキテクチャの境界だ。 これが抽象と具象の区切りになる。 この曲線を横切るソースコードの依存性は、すべて具象側から抽象側へと向かっている。

105

第11章 DIP: 依存関係逆転の原則

この曲線は、システムを2つのコンポーネントに分割する。 一方が抽象、 もう一方が具象だ。 抽象コンポーネントには、すべての上位レベルのビジネスルールが含まれる。 具象コンポーネ ントには、これらのビジネスルールが操作する実装の詳細が含まれる。

図中の曲線を横切る処理の流れは、ソースコードの依存性とは逆向きになることに注意し よう。 ソースコードの依存性と処理の流れは逆向きになる。 だからこそ 「依存関係逆転の原則 (DIP)」と名付けたのである。

具象コンポーネント

図11-1 の具象コンポーネントには依存性があるので、 依存関係逆転の原則 (DIP) を満たし ていない。 これはよくあることだ。 依存関係逆転の原則 (DIP) の違反を完全に取り除くこと はできないが、 依存関係逆転の原則 (DIP) を満たさない具象コンポーネントを少数に絞り込 み、それらをシステムの他の部分と分離することはできる。

ほとんどのシステムには、 依存関係逆転の原則 (DIP) を満たさない具象コンポーネントが少な くともひとつは存在する。 このコンポーネントはmain コンポーネントと呼ばれることが多い。 main 関数を含んでいるからだ。 図11-1 の場合なら、 おそらく main 関数が ServiceFactory Impl のインスタンスを生成して、 それを ServiceFactory 型のグローバル変数として扱うことにな るだろう。 Application からは、このグローバル変数を通じて Factory にアクセスする。

まとめ

本書では、ここからさらに上位レベルのアーキテクチャの原則を扱うことになるが、 依存関 係逆転の原則 (DIP) も何度となく登場する。 これは、アーキテクチャの図のなかで最も目立 つ原則だろう。 図11-1 の曲線は、後の章では「アーキテクチャの境界」を表すことになる。 曲 線を横切る依存性が抽象に向かっているが、これは後の章では 「依存性のルール」という新し いルールとして登場する。

1 アプリケーションの起動時に OS が最初に実行する関数のこと。

106

IV

部

コンポーネントの原則 第

SOLID 原則がレンガを組み合わせて壁や部屋を作る方法を伝える原則だとするならば、 コン ポーネントの原則は部屋を組み合わせて建物を作る方法を伝える原則である。 大規模建築と同 様に、 大きなソフトウェアシステムは小さなコンポーネントを組み合わせて作られている。 第IV部では、ソフトウェアコンポーネントとはいかなるものなのか、その構成要素は何なの か、どのように組み合わせてシステムを作り上げるのかといった内容を扱う。

107



コンポーネント 第12

コンポーネントとは、デプロイの単位のことである。 システムの一部としてデプロイできる、 最小限のまとまりを指す。 Javaなら jar ファイル Ruby なら gem ファイル、 NETならDLL などがそれにあたる。 コンパイル型言語ならバイナリファイル、インタプリタ型言語ならソー スファイルになる。 あらゆる言語において、 コンポーネントがデプロイの基準になる。

複数のコンポーネントをリンクして単体の実行可能ファイルにすることもできる。 あるい は、複数のコンポーネントを. war ファイルのようなアーカイブにまとめることもできる。.jar [やdll や exeなどの形式で、動的に読み込むプラグインとして、個別にデプロイすることも できる。 最終的にどのような形式でデプロイするかにかかわらず、 よくできたコンポーネント は常に個別にデプロイできる状態を保っているため、個別に開発を進められる。

109

第12章 コンポーネント

コンポーネントの簡単な歴史

その昔、プログラムをメモリ上のどの場所にどのように配置するかを決めるのは、 ブログラ マの役割だった。プログラムの先頭に 「origin」 を示すものを置いて、プログラムを読み込むメ モリのアドレスをそこで宣言してい

以下に示すのは、簡単なPDP-8のプログラムだ。 GETSTR というサブルーチンでは、キーボー ドから入力された文字列をバッファに保存している。 また、 GETSTR を実行するちょっとしたユ ニットテストもついている。

*200 TLS START, CLA TAD BUFR JMS GETSTR CLA TAD BUFR JMS PUTSTR JMP START BUFR, 3000

GETSTR,

DCA PTR

NXTCH,

0

KSF

JMP -1

KRB

DCA I PTR

TAD I PTR

AND K177

ISZ PTR

TAD MCR

SZA

JMP NXTCH

K177,

177

MCR,

-15

先頭の 200 コマンドに注目しよう。 これは、 生成したコードを200番地にロードするよう にコンパイラに指示するものだ。

いまどきのプログラマにはなじみのない概念だろう。 プログラムがコンピュータのメモリ上

110

コンポーネントの簡単な歴史

でどこにロードされるかなんて、 今ではほとんど気にすることがない。 その昔、 これはプログ ラマが最初に決めるべきことのひとつだった。 その当時、プログラムはリロケータブル (再配 置可能) ではなかったのだ。

当時のプログラマは、ライブラリ関数をどのように使っていたのだろうか? 実は、先ほど のソースコードにその手法が書かれている。 プログラマはライブラリ関数のソースコードをア プリケーションに組み込んで、ひとつのプログラムとしてコンパイルしていた。 ライブラリは バイナリではなく、ソースコードとして管理されていたのだ。

この手法の問題は、その当時のデバイスが低速であり、 メモリが高価だった(つまり、 使え るメモリが限られていた)ことだ。 コンパイラはソースコードを繰り返し走査する必要があっ たが、すべてのソースコードをメモリ上に置いておく余裕はなかった。 その結果、 コンパイラ は低速なデバイスから何度もソースコードを読む必要があった。

これには時間がかかる。 関数ライブラリが大きくなればなるほど、コンパイラの処理時間も 延びる。 巨大なプログラムのコンパイルには何時間もかかっていた。

コンパイルにかかる時間を短縮しようと考えたプログラマは、 関数ライブラリのソースコー ドをアプリケーションから分離するようになった。 関数ライブラリを個別にコンパイルして、 そのバイナリを既知の番地 (たとえば2000g など)にロードするようにした。 そして、 関数ラ イブラリ用のシンボルテーブルを作り、このシンボルテーブルをアプリケーションコードと一 一緒にコンパイルした。 アプリケーションを実行するときには、まず関数ライブラリのバイナリ をロードしてから2、アプリケーションをロードした。 メモリ上の配置は図12-1のようになる。

アプリケーションが0000円 番地から 17778 番地に収まっているうちは、これで問題ない。 し かし、アプリケーションはすぐに巨大化し、 この範囲に収まらなくなるだろう。そのときは、 関数ライブラリを挟んだ2つのアドレスセグメントにアプリケーションを分割しなければいけ ない (図 12-2)。

どう見ても持続可能な状況ではない。 関数ライブラリに関数を追加しようとすると、さらに 別の場所を確保する必要がある (7000 近辺を使うことになるだろう)。 このままでは、コン ピュータのメモリが増えてもプログラムとライブラリの断片化は解消されない。 何か手を打つべきであることは間違いない。

1 私の最初の勤務先では、サブルーチン集のソースコードが入った大量のカードが棚に置かれていた。 新しいプログラム を書くときには、そこから抜き出したカードを自分のデッキに放り込んだものだった。 2 当時のマシンの大半はコアメモリを使っており、コンピュータの電源を落としてもその内容は消去されなかった。 いっ たんロードした関数ライブラリは、そのまま何日も残しておいたものだ。

111

第12章 コンポーネント *000-x177 x200-x377 x400-x577 x600-777 0000-0777 アプリケーション 1000-1777 2000-2777 3000-3777 関数ライブラリ 4000-4777 5000-5777 6000-6777 7000-7777 図12-1 最初のメモリ配置 x000-x177 x200-x377 x400-x577 x600-*777 0000-0777 アプリケーション... 1000-1777 2000-2777 3000-3777 関数ライブラリ 4000-4777 5000-5777 アプリケーション 6000-6777 7000-7777

12-2 アプリケーションを2つのアドレスセグメントに分割する

リロケータビリティ (再配置可能性)

その解決策が、リロケータブルなバイナリだった。 アイデアは極めて単純だ。 コンパイラが 出力するバイナリコードに手を加えて、 スマートローダでメモリに再配置できるようにしたの だ。 ローダには、リロケータブルなコードをどこにロードするかが伝えられる。リロケータブ ルなコードにはフラグが組み込まれていて、 どの部分をどのアドレスにロードする必要があるか を示している。 通常は、バイナリのメモリ参照アドレスに開始アドレスを追加するだけだった。

これでプログラマは、関数ライブラリとアプリケーションをどこにロードするかを指示でき るようになった。 実際には、ローダが受け取ったバイナリ入力をそのままの順番でメモリに再

112

配置しているだけだ。 その結果、 プログラマは必要な関数だけをロードできるようになった。

その後、コンパイラにさらに手を加えて、 リロケータブルなバイナリのメタデータとして 数名を出せるようにした。 プログラムからライブラリ関数が呼ばれたら、コンパイラはその関 数名を外部参照として出力する。 プログラムがライブラリ関数を定義するときは、コンパイラ はその関数名を外部定義として出力する。 これにより、外部定義をどこにロードするかが決ま れば、ローダが外部参照をリンクできるようになった。

リンクローダの誕生である。

リンカ

リンクローダのおかげで、プログラムを個別にコンパイルやロードができるセグメントに分 割できるようになった。 プログラムもライブラリも、規模が比較的小さいうちは、 これでうま くいっていた。しかし、 60年代後半から70年代にかけて、プログラマはどんどん野心的にな り、プログラムも巨大化していった。

最終的にリンクローダの処理が重すぎて使えない状況に陥った。 関数ライブラリは磁気テー プのような低速デバイスに格納されていた。 ディスクに格納されていたとしても、当時のディ スクはかなり遅かった。 こうした低速デバイスを使っていると、リンクローダが外部参照を解 決するために、何十回もバイナリライブラリを読み込まなければいけなくなる。 プログラムが 大きくなればなるほど、ライブラリの関数も増えていく。 リンクローダがプログラムをロード するのに1時間以上かかることもあった。

結局、 ロードとリンクをそれぞれ別のフェーズに分けることになった。 遅い部分 (リンクの処 理) をリンカと呼ばれる別のアプリケーションに切り出した。 リンカの出力はリンク済みのリ ロケータブル形式であり、ローダによる再配置も非常に高速にできた。 実行形式を作るときは まず低速なリンカによる準備が必要になるが、 それさえ済ませておけば、いつでもすぐにロー ドできるようになった。

時は流れて80年代。 プログラマはC言語などの高級言語を使うようになっていた。 プログ ラマの野心はとどまるところを知らず、プログラムもさらに巨大化した。 何十万行ものコード で書かれたプログラムもめずらしくはなかった。

cファイルに書かれたソースモジュールをコンパイルして.。 ファイルを作り、それをリン カに渡してすぐにロードできる実行ファイルを作った。 モジュールを個別にコンパイルするの にそれほど時間はかからなかったが、 すべてのモジュールを一度にコンパイルするにはそれな りに時間がかかった。 リンカにはそれよりもさらに時間がかかった。 全体の所要時間も長くな り, かつてのように1時間以上かかることもめずらしくなかった。

リンカ

113

第12章 コンポーネント

プログラマは永遠に自分の尻尾を追い続ける運命にあるようだ。 60年代、70年代、80年代 にかけて、ワークフローを高速化するために施されたあらゆる変更は、プログラマの野心とそ れに伴うプログラムの巨大化によって打ちのめされてきた。 結果が出るまで1時間待ちという 状態からは逃れられないようだ。 ロードは高速だが、コンパイルとリンクにかかる時間がボト ルネックになった。

つまり、我々はプログラムのサイズに関する 「マーフィーの法則」を実体験していたわけだ。

プログラムは、コンパイルとリンクに使える時間を使い切るまで肥大化する。

だが、登場人物はマーフィーだけではなかった。 そこで登場したのがムーアだった。80年代 後半に両者が激突した。 勝利したのはムーアだった。 ディスクの小型化が始まり、 速度は劇的 に向上した。 メモリも非常に安価になり、 ディスク上のほとんどのデータをRAM上にキャッ シュできるようになった。 クロック数は、1MHzから100MHz にまで成長した。

90年代半ばには、プログラマの野心によるプログラムの肥大化よりも、リンク時間の短縮の ほうが早く進むようになった。 一部の例外を除いて、 リンク時間は秒単位にまで短縮された。 小さなジョブなら、リンクローダのアイデアも再び使える状況になった。

当時は Active-X や共有ライブラリが主役の時代で、ちょうど. jar ファイルが出始めた頃 だった。コンピュータやデバイスが十分に高速になり、ロード時にリンクできる時代が再び訪 れた。 複数の .jar ファイルや共有ライブラリを秒単位でリンクして、プログラムを実行できる ようになったのだ。 コンポーネントをプラグイン化するアーキテクチャが生まれたのもちょう どこの頃だった。

今では、.jar ファイルやDLLなどの共有ライブラリを既存のアプリケーションのプラグイン としてリリースすることも当たり前になった。 Minecraft の MOD が作りたければ、自作の.jar ファイルを特定のフォルダに配置するだけでいい。 ReSharper を Visual Studio に組み込みた ければ、DLL をインクルードするだけでいい。

まとめ

動的にリンクされたファイルを実行時にプラグインできる。 これが我々のアーキテクチャに おけるソフトウェアコンポーネントだ。 ここにたどり着くまでに大変な労力を要する50年だっ たが、 我々は気軽に使えるコンポーネントプラグインアーキテクチャをようやく手に入れるこ

3 ムーアの法則計算機の速度やメモリや集積度は18か月ごとに倍になる。 この法則は1950年代から2000年くらいまで は成り立っていた。 しかしそれ以降は、少なくとも動作クロックに関しては成長が鈍っている。

114

まとめ

とができた。

115



コンポーネントの凝集性

第 13分 章

KOHNKE

BUTTER งอ

どのクラスをどのコンポーネントに含めればいいのだろう? この判断は重要で、優れたソ フトウェアエンジニアリングの原則に従った判断が求められる。 だが、残念ながら、これまで はその場しのぎの思いつきの判断が続いてきた。

本章では、 コンポーネントの凝集性に関する以下の原則を取り上げる。

●再利用 リリース等価の原則 (REP)

●閉鎖性共通の原則 (CCP)

●全再利用の原則 (CRP)

117

第13章 コンポーネントの凝集性

再利用 リリース等価の原則 (REP) •

再利用の単位とリリースの単位は等価になる。

Maven や Leiningen や RVM など、 この十年の間にさまざまなモジュール管理ツールが生ま れた。これらのツールの重要性が増している理由は、 再利用可能なコンポーネントやコンポー ネントライブラリがどんどん作られているからである。 我々は今、 ソフトウェアを再利用する 時代を生きている。 オブジェクト指向モデルの当初からの理想がようやく達成されたのだ。

再利用 リリース等価の原則 (REP) は、ごく当たり前のことを言っているようにも思える。

ソフトウェアコンポーネントを再利用したくても、 リリースプロセスでそのコンポーネントを 追跡していなかったり、リリース番号がついていなかったりすると、 うまく再利用できない。 再利用できない理由は単純で、 リリース番号がついていなければ、 再利用するコンポーネン トの互換性を確認できないからだ。 開発者はコンポーネントの新しいリリースが出たことを知 る必要があるし、そのリリースで何が変わったのかも知る必要がある。

新しいリリースの通知を受け取った開発者が、 そのリリースでの変更内容を確認したうえで、 あえて古い版を使い続けるという判断をすることもめずらしくない。 したがって、リリースプロ セスにおいては適切な通知とリリースドキュメントを用意することが欠かせない。 これらを用 いて、 新しいリリースを適用するか否か、 適用するならいつ適用するかをユーザーが判断する。

この原則をソフトウェア設計やアーキテクチャの観点で考えると、コンポーネントを形成する クラスやモジュールは凝集性のあるグループでなければいけないという意味になる。 コンポー ネントはクラスやモジュールを適当に寄せ集めたものではない。 コンポーネントには一貫する テーマや目的があり、それを共有するモジュールを集めなければいけない。

これは明確なことだろう。 だが、この原則には別の観点もある。 おそらくこちらはそれほど 明確ではない。 それは、ひとつのコンポーネントを形成するクラスやモジュールは、まとめてリ リース可能でなければいけない、というものだ。同じバージョン番号を共有し、同じリリース プロセスを経て、同じリリースドキュメントを持っているという事実は、 作者にとってもユー ザーにとっても合理的なはずだ。

とはいえ、この言い方は心もとない。 「合理的」 という言葉は、権威づけをしようとしている ようにも聞こえるし、なんだかつかみどころのないアドバイスである。 だが、 そうなってしま うのも無理はない。クラスやモジュールをひとつのコンポーネントにまとめる方法について、 きちんと説明するのは難しいからだ。 あいまいなアドバイスしかできないかもしれないが、 そ れでもこの原則は重要だ。 この原則に違反している例はよく見かけるし、それは「合理的では 「ない」からだ。もしあなたが再利用・リリース等価の原則 (REP) に違反していれば、ユーザー

118

閉鎖性共通の原則 (CCP)

はそれに気づき、 あなたのアーキテクチャの設計スキルに疑問を抱くだろう。

再利用 リリース等価の原則 (REP) の弱点は、 他の2つの原則の強みでも補いきれない。 実 際、閉鎖性共通の原則 (CCP) と全再利用の原則 (CRP) では、この原則の内容を否定的な意 味で扱っている。

閉鎖性共通の原則 (CCP)

同じ理由、 同じタイミングで変更されるクラスをコンポーネントにまとめること。 変更の理由やタイ ミングが異なるクラスは、別のコンポーネントに分けること。

これは、単一責任の原則 (SRP) をコンポーネント向けに言い換えたものだ。 単一責任の原 則 (SRP) は 「クラスを変更する理由が複数あるべきではない」という原則だったが、 閉鎖性共 通の原則 (CCP) は 「コンポーネントを変更する理由が複数あるべきではない」と説いている。 多くのアプリケーションにおいて、 再利用性よりも保守性のほうが重要だ。 アプリケーショ ンのコードを変更しなければいけないときには、ひとつのコンポーネントに変更箇所がまとまっ ているほうが、あちこちのコンポーネントに散らばっているよりもありがたい。 変更箇所がひ とつのコンポーネントに閉じていれば、 変更後にデプロイする必要があるのはそのコンポーネ ントだけになる。 そのコンポーネントに依存していないコンポーネントは再デプロイする必要 がない。

閉鎖性共通の原則 (CCP) が我々に伝えようとしているのは、同じタイミングで変更される ことが多いクラスはひとつにまとめておけということだ。 2つのクラスが物理的あるいは概念 的に密結合していて、 変更のタイミングがいつも一緒になるのであれば、それは同じコンボー ネントに属するものだ。 まとめておけば、ソフトウェアのリリースやデプロイの際の作業量を 最小限に抑えられる。

この原則は、オープンクローズドの原則 (OCP) とも密接に関連している。 実際、 閉鎖性 共通の原則 (CCP) で扱う 「閉鎖性」 は、 オープンクローズドの原則 (OCP)の「クローズ 「ド」と同じ意味だ。 オープン・クローズドの原則 (OCP) では、クラスは修正に対しては閉じ ていて、拡張に対しては開いていなければいけないと定めている。 完全に閉じるのは不可能な ので、戦略的に進めていく必要がある。 クラスの設計時には、想定できるものや過去に経験し たことがあるものなど、よくある種類の変更に対して閉じるようにしておく。

閉鎖性共通の原則 (CCP) は、この教えをさらにかみ砕いて 「変更の種類が似ているクラス をひとつのコンポーネントにまとめる」とした。 こうしておけば、 要件変更があった場合の変

1 第27章 「サービス: あらゆる存在」 の 「子猫の問題」を参照。

119

章 コンポーネントの凝集性

第 13

更箇所を最小限のコンポーネントに絞れる。

単一責任の原則 (SRP) との類似点

前述のとおり、 閉鎖性共通の原則 (CCP) は単一責任の原則 (SRP) をコンポーネントに適用 したものである。 単一責任の原則 (SRP) は、 変更の理由が異なるメソッドは別のクラスに分 けるという原則だった。 閉鎖性共通の原則 (CCP) は、 変更の理由が異なるクラスは別のコン ポーネントに分けるという原則だ。 どちらの原則も、要するに以下のようなことを言っている。

同じタイミング、同じ理由で変更するものはひとまとめにすること。 変更のタイミングや理由が異な るものは別々に分けること。

全再利用の原則 (CRP)

コンポーネントのユーザーに対して、 実際には使わないものへの依存を強要してはいけない。

全再利用の原則 (CRP) も、ひとつのコンポーネントにまとめるべきクラスやモジュールを 判断するための原則である。 この原則は、 一緒に用いられることが多いクラスやモジュールは 同じコンポーネントにまとめよというものである。

ひとつのクラスだけを再利用することはめったにない。 他のクラスと組み合わせて、 再利用 可能な抽象として用いることが多い。 全再利用の原則 (CRP) は、そうしたクラスを同じコン ポーネントにまとめるように説いている。 コンポーネントに属するクラスには、多くの依存関 係があることだろう。

わかりやすい例として、コンテナクラスとそれに対応するイテレータを考えてみよう。これ らはまとめて再利用すべきものだ。 お互いに密結合しているからである。 したがって、これら は同じコンポーネントにまとめておくべきだ。

全再利用の原則 (CRP) はどのクラスを同じコンポーネントにまとめるべきかだけを言って いるのではない。どのクラスを同じコンポーネントにまとめるべきではないかも教えてくれる。 あるコンポーネントが別のコンポーネントを使うとき、 両者には依存関係が生まれる。 もしか すると使う側のコンポーネントが使いたいのは、 使われる側のコンポーネントにあるひとつの クラスだけなのかもしれない。 だからといって、 依存関係が弱くなることはない。 使う側のコ ンポーネントが使われる側のコンポーネントに依存していることには変わりない。

10 120

コンポーネントの凝集性のテンション図

したがって、 使われる側のコンポーネントが変更されるたびに、 使う側のコンポーネントに も変更が必要になるだろう。 仮に変更が不要であっても、再コンパイルと再デプロイが必要に なる可能性は高い。 変更された箇所が使う側のコンポーネントに関係のないところだったとし ても、その可能性は変わらない。

コンポーネントに依存するのであれば、コンポーネントに含まれるすべてのクラスに依存す るようにしておきたい。 言い換えれば、ひとつのコンポーネントにまとめるクラスはどれも切 り離せないものばかりにしておきたい。 つまり、 依存するクラスもあれば依存しないクラスも あるといった状況は避けておきたい。 そのような状態では、 本来不要であるはずの再デプロイ に手間がかかってしまう。

全再利用の原則 (CRP) は、 どのクラスをひとまとめにすべきかというよりも、どのクラス をひとまとめにすべきではないかを伝える原則だ。 密結合していないクラスを同じコンポーネ ントにまとめるべきではない。

インターフェイス分離の原則 (ISP)との関係

全再利用の原則 (CRP) はインターフェイス分離の原則 (ISP) を一般化したものである。 イ ンターフェイス分離の原則 (ISP) は、 使っていないメソッドを持つクラスに依存しないように 伝えている。 一方の全再利用の原則 (CRP) は、 使っていないクラスを持つコンポーネントに 依存しないように伝えている。

これらはどちらも、以下のようにまとめられる。

不要なものには依存しないこと。

コンポーネントの凝集性のテンション図

もうお気づきかもしれないが、 凝集性に関するこれらの原則には相反するところがある。 再 利用 リリース等価の原則 (REP) と閉鎖性共通の原則 (CCP) は、包含関係にある。 どちら も、ひとつのコンポーネントを大きくする方向に働くものだ。一方の全再利用の原則 (CRP) は、これらとは相反する原則で、 ひとつのコンポーネントを小さくする方向に働くものだ。 こ れら3つの原則のバランスをうまくとるのが、 アーキテクトの腕の見せどころだ。

図13-1 に示すテンション図2は、 凝集性に関する3つの原則がそれぞれどのように影響を及

2 このアイデアを出してくれた Tim Outinger に感謝する。

121

第13章 コンポーネントの凝集性

ほしあうかを示したものだ。 辺にある記述は、反対側の頂点にある原則を無視したときにかか るコストを表している。

REP CCP 不要なリリース作業の増加 再利用性のための 保守性のための グループ化 グループ化 変更すべきコンポーネントの増加 あなたのコンポーネントは どこに当てはまるだろう? CRP 不要なリリース作業を 減らすための分割 再利用性の低下

図13-1 凝集性に関する原則のテンション図

再利用 リリース等価の原則 (REP) と全再利用の原則 (CRP) を守ることにだけ力を入れ ているアーキテクトは、些細な変更が大量のコンポーネントに影響を及ぼすことに驚かされる だろう。 閉鎖性共通の原則 (CCP) と再利用 リリース等価の原則 (REP) に注目すると、リ リースの回数が無駄に増えてしまう。

優れたアーキテクトは、この三角形のなかで開発チームの現在の懸念事項に見合った落とし どころを見つける。 それだけではなく、 時がたてばチームの懸念事項が変わるということも心 得ている。たとえば、 開発の初期段階なら再利用 リリース等価の原則 (REP) よりも閉鎖性 共通の原則 (CCP) のほうがずっと重要になる。 再利用性よりも、 開発しやすさのほうが重要 だからだ。

一般に、プロジェクトの初期はこの三角形の右側に位置する傾向がある。 つまり、再利用性 を犠牲にしている状態だ。 プロジェクトが進み、 別のプロジェクトから利用される頃になると、 図の左側へ移っていく。 このことは、プロジェクトのコンポーネントの構造が経過時間や成熟 度によって変わることを意味している。 図の左側では、そのプロジェクトの開発よりも、他の

122

まとめ

プロジェクトの開発でどのように使われるのかを考えるようになる。

まとめ

かつての我々は、凝集性に関してそれほど深く考えることはなく、再利用 リリース等価の 原則 (REP) 閉鎖性共通の原則 (CCP)、 全再利用の原則 (CRP) よりもずっとシンプルに考え ていた。 凝集性は 「ひとつのモジュールはひとつだけの機能を持っている」という属性のこと だと考えていた。 しかし、 コンポーネントの凝集性に関するこれら3つの原則は、それがもっ と複雑なものであることを示している。 どのクラスをコンポーネントにまとめるかを決めると きには、開発時の利便性と再利用性のトレードオフを考慮する必要がある。 アプリケーション のニーズに従ってこれらのバランスをとるのは、簡単なことではない。 また、 最適な落としど ころは常に変わり続ける。 つまり、 今の時点で適切だった判断が、 翌年には不適切になってい るかもしれない。 プロジェクトが進み、 再利用性を重視するようになると、 コンポーネントの 構成も変わっていくのである。

123



コンポーネントの結合 14個

KOHNKE

次に取り上げる3つの原則は、コンポーネントの関連を扱うものだ。 先ほどの章と同様に、 ここでも 「開発の利便性」 と 「論理的な設計」 のトレードオフが発生する。 コンポーネント構 造のアーキテクチャに影響を及ぼすフォースには、技術的なもの、 政治的なもの、変動しやす いものが存在する。

非循環依存関係の原則 (ADP)

コンポーネントの依存グラフに循環依存があってはいけない。

一日の仕事を終え、作ったプログラムがきちんと動くことを確認して帰宅する。 翌朝出社し てみると、あら不思議。 昨日はきちんと動いていたのに今朝はうまく動かない。 そんな経験は ないだろうか? なぜそんなことになったのだろう? おそらく、 昨晩あなたよりも遅くまで 残っていた誰かが変更した箇所が、 何か悪さをしているのだろう。私はこれを「二日酔い症候 群」と呼んでいる。

125

第14章 コンポーネントの結合

「二日酔い症候群」は、大勢の開発者が同じソースコードを変更する開発現場で発症する。 小 規模なプロジェクトで数人が同じソースコードを扱うくらいなら、 そんなに大きな問題にはな らない。 しかし、プロジェクトや開発チームの規模が大きくなると、 悪夢のような二日酔いが 襲いかかってくる。 安定版をビルドできない状態が何週間も続くことだってめずらしくない。 ほかの誰かの最新の変更に追従するために、 誰もが自分のコードを変更し続けているのである。

ここ数十年の間に、この問題に対するソリューションが2つ登場した。 どちらも電気通信業界 から生まれたものだ。 ひとつは 「週次ビルド」、 もうひとつは 「非循環依存関係の原則 (ADP)」 である。

|週次ビルド

週次ビルドは中規模のプロジェクトで一般的に使われるようになった手法だ。 以下のように 進めていく。 まず、週の最初の4日間は、ほかの開発者が何をどう変更したかを一切無視する。 各自が手元にコピーしたコードで作業を進め、 ほかのメンバーの作業との統合は気にしない。 そして金曜日になったら、全員の変更を統合して、 システムをビルドする。

この手法のすばらしいところは、週5日のうちの4日間は誰にも邪魔されずに開発できると ころだ。 一方、デメリットは明らかで、 毎週金曜日の統合作業はとてもつらいものになる。

残念なことに、プロジェクトの規模が大きくなると、金曜日まる一日かけても統合が終わら なくなってしまう。 金曜日に終わらなかった統合は、 土曜日にずれ込んでしまう。 そんなこと が何度も続けば、これからは毎週木曜日に統合しようということになるだろう。最終的にはそ れでも間に合わず、 統合を水曜日から始めようということになるだろう。

統合に時間がかかり、 開発の時間が短くなれば、チームとしての生産性が落ちる。 やがてそ れに耐えられなくなった開発者やプロマネが、1週間おきにビルドすればいいと言い出すだろ う。 しばらくはそれでしのげるかもしれないが、プロジェクトが成長すれば統合に要する時間 もさらに延びていく。

このシナリオの行き着く先は、 危機的な状況だ。 効率を求めるなら、ビルド周期を定期的に 延ばす必要がある。 しかし、ビルドの周期を延ばせば延ばすほど、失敗するリスクも高くなっ ていく。統合とテストはどんどん難しくなり、高速なフィードバックのメリットが得られなく なってしまう。

循環依存の除去

この問題を解決するには、開発環境をリリース可能なコンポーネントに分割すればいい。こ うすれば、コンポーネントが作業の単位になり、 コンポーネントごとに担当の開発者 (あるい

126

非循環依存関係の原則 (ADP)

は開発チーム)を割り当てられる。 自分の担当するコンポーネントが動くようになったら、そ れをリリースして他の開発者たちからも使えるようにする。 リリース番号を割り当てて、他の チームが利用できるディレクトリに移動する。 その後の手直しについては、自分たちのローカ ル環境で進めていく。 他の開発者たちが使うのは、先ほどリリースしたバージョンだけだ。

コンポーネントの新しいリリースが使えるようになったら、ほかのチームはそのリリースを すぐに導入するかどうかを自分たちで判断できる。 すぐには導入しないことに決めたなら、 今 までのリリースを使い続ければいい。 導入する準備が整った時点で、 新しいリリースを使い始 めることができる。

こうすれば、ほかの開発者に翻弄されることはない。 ひとつのコンポーネントに加えた変更 が、すぐにほかのチームに影響を及ぼすようなことはない。 コンポーネントの新しいリリース をいつ導入するかは、それぞれのチームで判断できるようになる。 さらに、統合の単位も小さ くなる。それぞれの変更を統合するために、 開発者全員を集めたりする必要もない。

これは非常にシンプルかつ合理的なプロセスであり、 実際に広く使われている。 しかし、こ のプロセスをきちんと機能させるには、コンポーネントの依存構造をきちんと管理しておく必 要がある。 循環依存があってはいけない。 もし循環依存があれば 「二日酔い症候群」は避けら れない。

図14-1に示したコンポーネント図を考えてみよう。 複数のコンポーネントを組み合わせた よくあるアプリケーションだ。このアプリケーションがどのような機能を持つかは気にする必 要はない。 それよりも重要なのは、コンポーネントの依存構造だ。 有向グラフ構造になってい ることに注目しよう。 コンポーネントがノードであり、 依存が有向エッジである。

Database View Main Presenters Interactors Controllers Entities Authorizer

図 14-1 典型的なコンポーネント図

127

章 コンポーネントの結合

第14

もうひとつ注目すべきことがある。 どのコンポーネントからスタートしても、矢印をたどっ て元のコンポーネントに戻ることができない。 つまり、 この図には循環構造が存在しない。 こ のようなグラフは、 有向非循環グラフ (DAG Directed Acyclic Graph) と呼ばれる。

ここで、 Presenters の開発チームが新しいリリースを公開したとしよう。 このリリースの 影響を受けるコンポーネントを調べるのは簡単だ。 図の矢印を逆向きにたどるだけでいい。 つ まり、影響を受けるのは View と Main である。 これらのコンポーネントを担当する開発者は、 どこかのタイミングで自分たちの開発環境に Presenters の新しいリリースを統合することに なる。

同様に考えると、 Main がリリースされたときには、 ほかのコンポーネントに何も影響を及ぼ さないことがわかる。 ほかのコンポーネントは Main のことを知らず、 いつ変更されたかなどは 気にしていない。 ありがたいことだ。 このおかげで、 Main をリリースする際の影響は、比較的 小さく済む。

Presenters の開発チームが開発中のコンポーネントをテストしたければ、 開発版の Presenters を現在使用中の Interactors および Entities と組み合わせてビルドすればいい。 そのほかの コンポーネントについては気にする必要はない。 これもまたありがたいことだ。 Presenters を 担当する開発者は、比較的手間をかけずにテストを実行できるし、考慮すべき変動要素も少な くなる。

システム全体をリリースするときは、この手順をボトムアップで進めていこう。 まずは、 Entities をコンパイルして、 テストして、リリースする。 次に、 Database と Interactors を 同じように進める。 その後、 Presenters と View と Controllers をリリースする。 続けて、 Authorizer をリリースする。 最後にリリースするのは Main だ。 このプロセスは非常に明確で 扱いやすい。 コンポーネントの依存関係を把握できているからこそ、システムをビルドする方 法が明確なのだ。

コンポーネントの依存グラフにおける循環依存の影響

新たな要件が追加されて、 Entities に含まれるクラスが Authorizer にあるクラスを使わざ るを得なくなったとしよう。 たとえば、 Entities にある User クラスが、 Authorizer にある Permissions クラスを使うような場合だ。 この変更によって、 循環依存が発生してしまう (図 14-2).

この循環依存がいくつかの問題を引き起こす。 たとえば、 Database の開発者は、今までコン ポーネントをリリースするときには、 Entities との互換性を維持することを考えておけばよ かった。しかし、新たに登場した循環依存によって、 さらに Authorizer との互換性も考慮しな ければいけなくなる。 Authorizer はさらに、 Interactors にも依存している。 今までと比べて

128

非循環依存関係の原則 (ADP)

Database をリリースするのが格段に難しくなった。 Entities と Authorizer と Interactors は、事実上ひとつの巨大なコンポーネントになったようなものだ。 これらのコンポーネントを 担当する開発者は、 恐ろしい 「二日酔い症候群」に悩まされることになる。 それぞれが同じバー ジョンのコンポーネントを使う必要が出てくるので、 各コンポーネントの開発者はお互い歩み 寄ることになるだろう。

Database View Main Presenters Interactors Entities 図 14-2 循環依存 Controllers Authorizer

問題はこれだけではない。 Entities をテストするときにどうなるかを考えてみよう。 残念 なことに、 Authorizer と Interactors の両方を統合してビルドする必要がある。 耐えられな いほどではないかもしれないが、コンポーネントがこのように密結合してしまうとテストも面 倒だ。

自分のクラスのユニットテストをひとつ実行したいだけなのに、なぜこんなにも多くのライ ブラリやほかの開発者のコードが必要になるのか。 少しでも調べれば、 その原因が循環依存に あることに気づくだろう。 循環依存があると、 コンポーネントを切り離すのが難しくなる。 ユ ニットテストやリリースも難しくなり、 失敗に陥りやすくなる。 さらに、モジュールの数が増 えるにつれて、ビルド時の課題も幾何級数的に増加する。

環依存があると、システムのリリース時にコンポーネントのビルドの順番を決めるのも難 しくなる。おそらく、正しい順序など存在しないのだろう。 Java のようにコンパイル済みのバ イナリで他のコンポーネントを参照するような言語では、このことは非常にやっかいな問題に つながる可能性がある。

129

第 14章 コンポーネントの結合

循環依存の解消

どのような状況でも、コンポーネントの循環依存を排除して、 有向非循環グラフに戻すこと が可能だ。 その方法としては、以下の2つがよく使われる。

1. 依存関係逆転の原則 (DIP) を適用する。 図 14-3 の場合は、 User が必要とするメソッ ドを持つインターフェイスを作ればいい。 このインターフェイスを Entities に入れて、 Authorizer からはそれを利用する。 これで Entities と Authorizer の依存関係が逆転す るので、 循環依存は解消される。

User Entities Authorizer User Permissions Entities Permissions Authorizer Permissions

図 14-3 Entities と Authorizer の依存関係の逆転

2. Entities と Authorizer の両方が依存する新しいコンポーネントを作る。 そして、 両方の コンポーネントが依存するクラスをこの新しいコンポーネントに移動する (図 14-4)。

| 「変化」するもの

2番目に示した方法からもわかるとおり、コンポーネントの構造は要件の変更に伴って変化す る。アプリケーションが成長するにつれて、コンポーネントの依存構造も細かく変わっていく。 したがって、 循環依存が入り込まないように、依存構造を常に注視しておく必要がある。 循環 が発生したときには、 何らかの方法で解消しなければいけない。 その過程で新しいコンポーネ ントが生まれて、 依存構造が変わることもあるだろう。

130

トップダウンの設計

Database View Main Presenters Interactors Entities Controllers Authorizer 号 Permissions

図 14-4 Entities と Authorizer の両方が依存する新しいコンポーネント

トップダウンの設計

これまでの議論から必然的に導けるのは、 コンポーネントの構造をトップダウンで設計する のは不可能だということだ。 コンポーネントの構造は、 システム設計の際に検討するだけのも のではなく、その後もどんどん変わっていく。

まだピンとこない人もいるかもしれない。 我々は、コンポーネントのような粒度の粗い分解 は、高水準の機能分解のようになると考えている。

コンポーネントの依存構造のような粒度の粗いグループを見ると、それぞれのコンポーネン トがシステムの何らかの機能を表していると考えてしまう。 だが、 コンポーネント図にはその 様子は見られない。

実際、コンポーネント図にアプリケーションの機能について書くことはほとんどない。 この 図はアプリケーションのビルド可能性や保守性を見るための地図のようなものだ。 したがって、 プロジェクトの開始時にコンポーネント図を作ることはない。 プロジェクトの開始時にはビル ドや保守が必要なソフトウェアは存在しないため、 地図は不要だからだ。 しかし、設計や実装 の初期段階からモジュールが増えていくと、それらの依存関係をきちんと把握する必要が出て くる。プロジェクトが 「二日酔い症候群」 に陥らないようにするためだ。 また、 あちこちを同 時に変更するようなことは避けたいので、単一責任の原則 (SRP) や閉鎖性共通の原則 (CCP) に注目して、変更のタイミングが同じクラスをひとまとめにしようとするだろう。

依存構造のなかで最優先に対処すべき問題が、 変動性の分離である。 さまざまな理由で頻繁 に変更されるコンポーネントが、 安定すべきコンポーネントに影響を及ぼすことは避けたい。

131

第 14章 コンポーネントの結合

たとえば、 GUIの見た目をちょっと変えるだけで、 ビジネスルールに影響を及ぼすようなこと はあってはいけない。 新しい帳票を追加しただけで、 最上位レベルの方針に影響を及ぼすのも 好ましくない。 アーキテクトはこれらを踏まえ、コンポーネントの依存グラフを組み立てる。 価値の高い安定したコンポーネントを、 頻繁に変更されるコンポーネントから保護するのだ。

アプリケーションが成長するにつれて、 構成要素の再利用性を考えるようになる。 この段階 になると、 全再利用の原則 (CRP) がコンポーネントの構成に影響し始める。 もし循環依存が 発生すれば、 非循環依存関係の原則 (ADP) を適用する。 そして、 依存グラフは変化しながら 成長していく。

コンポーネントの依存構造をクラス設計の前に決めようとすると、 散々な目にあうだろう。 共通の閉鎖性は見つかっていないし、再利用可能な要素にも気づいていない。 そして、 間違い なく循環依存を作ってしまう。 コンポーネントの依存構造は、システムの論理設計に合わせて 育てていくものだ。

安定依存の原則(SDP)

安定度の高い方向に依存すること。

設計を完全に確定させるのは不可能だ。 使い続けていくうちに、 設計に多少の変化が発生す るのは避けられない。 閉鎖性共通の原則 (CCP) を満たすようにすれば、 特定の変更以外には 影響を受けないコンポーネントを作ることができる。 このようなコンポーネントは、 変動を見 越した設計をしている。 変わりうるものであることを想定しているのだ。

変動を想定したコンポーネントは、変更しづらいコンポーネントから依存されてはいけない。 変更が難しくなってしまうからだ。

変更しやすい設計で作ったモジュールであっても、ほかのコンポーネントから依存されると、 あっという間に変更しづらくなる。 自分たちのモジュールには一切手を加えていないのに、 そ れ以降は手を加えづらくなってしまうのだ。 安定依存の原則 (SDP) を満たしていれば、手軽 に変更できるように作ったモジュールが変更しづらいモジュールから依存されていないことを 保証できる。

安定度

「安定度」 とは何だろう? 1枚のコインを立てた状態で置いたとする。 これは安定している だろうか? おそらくあなたは 「安定していない」と答えるだろう。 余計な手出しをせずそっ

132

安定依存の原則 (SDP)

としておけば、 コインはそのままの状態を保ち続けるだろう。 それでも、 これは 「安定してい ない」。 つまり、安定度は、変化の頻度とは関係ないということだ。 コインがずっとそのままの 状態を保っていたとしても、これを 「安定している」 とみなすのは難しい。

ウェブスター辞典によると、 安定している (stable) とは 「簡単には動かせないこと (not easily moved)」 だそうだ。 安定度は、 何かを変更する際に要する労力と関連している。 立てたコイン は不安定である。 なぜなら、 ちょっと手を出すだけで簡単に倒れるからだ。 一方、テーブルは 非常に安定している。 テーブルをひっくり返すにはかなりの労力を要するからだ。

さて、これをソフトウェアに当てはめてみよう。 ソフトウェアコンポーネントを変更しづら くする要素には、サイズや複雑さや明快さなど、さまざまなものがある。 だが、ここではこれ らを一切無視して、別の要素に着目しよう。 ソフトウェアを変更しづらくするには、多数のソ フトウェアコンポーネントから依存されるようにすればいい。 多数のコンポーネントから依存 されたコンポーネントは非常に安定している。 なぜなら、 少し変更するだけでもほかのさまざ まなコンポーネントとの調整が必要になるからだ。

図14-5 では、 X が安定したコンポーネントになる。 3つのコンポーネントがxに依存してい るということは、このコンポーネントを変更しない理由が少なくとも3つはあるということだ。 このようなとき、 Xは3つのコンポーネントに対する責務を負っていると言う。 逆に、Xはほか のコンポーネントに依存していない。 つまり、 外部要因で変更が必要になることはない。この ようなコンポーネントを独立コンポーネントと呼ぶ。

図 14-5 安定したコンポーネントx

図14-6に示した Y は、 非常に不安定なコンポーネントだ。 Yに依存するコンポーネントはひ とつもないので、このコンポーネントは何も責務を負わない。 Y自身は3つのコンポーネント に依存しているので、3つの外部要因による変更の可能性がある。 このようなコンポーネント を従属コンポーネントと呼ぶ。

133

章 コンポーネントの結合

第14

図 14-6 非常に不安定なコンポーネント Y

|安定度の指標

コンポーネントの安定度をどのように計測すればいいだろうか? そのコンポーネントに依 存しているコンポーネントの数や、そのコンポーネントが依存しているコンポーネントの数を 調べるのもひとつの方法だ。こうした数を調べれば、 コンポーネントの位置的な安定度が算出 できる。

●ファンイン: 依存入力数。 この指標は、コンポーネント内のクラスに依存している外部 のコンポーネントの数を表す。

●ファン・アウト: 依存出力数。 この指標は、コンポーネント内にある、 外部のコンポーネ ントに依存しているクラスの数を表す。

•I (Instability): 不安定さ。 I = ファンアウト (ファンイン ファンアウト)。 こ の指標は、ゼロ以上1以下の値になる。 I=0が最も安定しているコンポーネントを表し、 I=1が最も不安定なコンポーネントを表す。

ファン・インとファン・アウトを算出する際には、対象コンポーネントに含まれるクラスと 依存関係にある外部コンポーネントのクラスの数を調べる。 図14-7の例を考えてみよう。 コンポーネント Ccの安定度を算出してみよう。 Cc の外部にある3つのクラスがCcの内部の

クラスに依存しているので、ファン・イン=3だ。一方、Ccの内部のクラスが依存するccの 外部のクラスは1つなので、 ファン・アウト=1となる。 つまり、 I = 1/4 だ。

C++では、これらの依存は一般的に#include 文で表される。 ひとつのソースファイルにひと つのクラスしか含めないようにしておけば、Iの値は簡単に算出できるようになる。 Java の場 合は、 import 文と修飾名を数えれば、 の値がわかる。

の値が1になるのは、そのコンポーネントに依存するコンポーネントがひとつもなく(ファ

1以前に出版した書籍では「ファン・アウト」と「ファン・イン」ではなく、 「遠心性」 と 「求心性」 という用語を使って いた。 正直すまなかったと思っている。 当時の私は、中枢神経系のメタファーを好んでいたのだ。

134

安定依存の原則 (SDP)

Ca Cb 図 14-7 例 Cd

ン・イン=0)、 そのコンポーネントが他のコンポーネントに依存している (ファン・アウト > 0) 場合だ。 これは、最も不安定な状態である。 他のコンポーネントに対して何も責務を負 わず、ただ依存しているだけである。 他のコンポーネントから依存されていないので、そのコ ンポーネントを変更することを思いとどまる理由がない。 他のコンポーネントに依存している ので、依存するコンポーネントの事情でそのコンポーネントを変更する可能性がある。

一方、1の値がゼロになるのは、そのコンポーネントに依存しているコンポーネントが存在し ている (ファン・イン > 0) が、 そのコンポーネントは他のコンポーネントに依存していない (ファンアウト = 0) 場合だ。 このコンポーネントはほかのコンポーネントに対する責務を 負い、ほかのコンポーネントからは独立している。 これは、最も安定した状態である。 ほかの コンポーネントからの依存があるために、 気軽に手を加えることはできない。 ほかのコンポー ネントに依存していないので、ほかのコンポーネントの都合によって変更する必要がない。

安定依存の原則 (SDP) は、コンポーネントの1を依存するコンポーネントのよりも大きく すべきというものである。 つまり、コンポーネントの依存性の方向を順番にたどると、1の値 は減少していくべきだということになる。

すべてのコンポーネントに高い安定度を求める必要はない

すべてのコンポーネントが最大限に安定した状態になっているとしたら、 そのシステムには 手を加えることができないだろう。 それは我々の望む状況ではない。 コンポーネント構造を設 討するときには、安定度の高いコンポーネントもあれば、 安定度の低いコンポーネントもあるよ うにしておきたい。 3つのコンポーネントからなるシステムの理想的な構成を図14-8 に示す。

変更しやすいコンポーネントを図の上に、 それらが依存する安定したコンポーネントを図の 下に配置している。 このように、安定度の低いコンポーネントを図の上のほうに書くと定めて おくと便利だ。 そうすれば、上向きの矢印は安定依存の原則 (SDP) に違反している (さらに、 後述する非循環依存関係の原則 (ADP) にも違反している)ことがすぐに見つけられるように

135

第14章

なる。

コンポーネントの結合 instable stable instable I=1 I=0

図14-8 3つのコンポーネントからなるシステムの理想的な構成

以下に示す図 14-9 は、 安定依存の原則 (SDP) に違反している例だ。

instable Stable I=1 instable Flexible

図14-9 安定依存の原則 (SDP) 違反

Flexible は、 意図的に変更しやすいように作られているコンポーネントだ。 このコンポーネ ントは安定度を低くしておきたい。 しかし、 安定度の高いコンポーネント Stable を担当する 開発者が、このコンポーネントに Stable を依存させてしまっている。 これは安定依存の原則 (SDP)に反した状態だ。 なぜなら、 Stable コンポーネントの1の値は、 Flexible コンポーネ ントに比べてずっと小さいからだ。 結果的に、 Flexible コンポーネントは変更しづらいものに なってしまう。このコンポーネントを変更すると、必然的に Stable コンポーネントやそれに 依存するほかのコンポーネントにも手を加えなければいけなくなる。

この問題を解決するには、 Stable から Flexible への依存を何らかの手段で取り除く必要があ

136

安定依存の原則 (SDP)

る。そもそも、なぜこの依存が存在するのだろうか。 ここでは、 Stable のクラスUがFlexible のクラスCを使う必要があるとしよう (図 14-10)。

Stable u Flexible

図 14-10 Stable のひが Flexible のCを利用している

この問題を修正するためには、依存関係逆転の原則 (DIP) を使えばいい。 インターフェイ スのUs を作り、これをコンポーネント UServer に格納する。このインターフェイスでは、 Uが 使うすべてのメソッドを宣言しておく。 そして、 cにこのインターフェイスを実装させる (図 14-11)。 これで Stable が Flexible に依存することはなくなり、両方のコンポーネントがそ れぞれ UServer に依存するようになる。 UServer は非常に安定しており (10) Flexible の 安定度は低いまま (11) にできる。 これで、すべての依存がを小さくする方向に流れるよ うになった。

Stable UServer <I> us 4 Flexible

図 14-11 インターフェイス Us を c が実装する

抽象コンポーネント

インターフェイスしかないコンポーネント (今回の例におけるUServer のようなもの)を見 て、不思議に思う人もいるかもしれない。 実行可能なコードが一切含まれていないからだ! しかし、 Java やC#のような静的型付け言語では、 これはごくありふれた戦略で、欠かせない ものである。 こうした抽象コンポーネントは安定度が非常に高いので、安定度の低いコンポー ネントが依存する対象としては理想的だ。

Ruby や Python のような動的型付け言語には、このような抽象コンポーネントは存在しな い。 抽象コンポーネントへの依存も存在しない。 これらの言語における依存構造は、静的型付 言語に比べるとずっとシンプルになる。 依存関係を逆転させるときに、 何らかの宣言をした

137

第 14章 コンポーネントの結合

りインターフェイスを継承したりする必要がないからだ。

安定度 抽象度等価の原則 (SAP)

コンポーネントの抽象度は、 その安定度と同程度でなければいけない。

上位レベルの方針をどこに適用するか

システムのなかには、頻繁に変更すべきでないソフトウェアも含まれる。 上位レベルのアー キテクチャや方針を示すソフトウェアがそれにあたる。 ビジネスやアーキテクチャに関する決 定は、頻繁に変わってほしくはないものだ。 したがって、 そのシステムにおける上位レベルの 方針をカプセル化したソフトウェアは、安定度の高い (10) コンポーネントに配置しなけれ ばいけない。安定度の低い (11) コンポーネントには、すばやく簡単に変更できるようにし ておきたいソフトウェアのみを含めるべきだ。

しかし、 上位レベルの方針を安定度の高いコンポーネントに配置すると、 方針を表現してい るソースコードを変更しづらくなる。 結果的に、 そのアーキテクチャは柔軟性に欠けるものに なってしまうだろう。 安定度が最大の (10) コンポーネントを変更せずに済ませることは可 能だろうか? その答えはオープンクローズドの原則 (OCP) にある。 オープンクローズ ドの原則 (OCP)は、クラスを作るときには既存コードを変更せずに拡張できるようにしてお くというものだった。 この原則を満たすクラスとは何だろうか? そう、 抽象クラスだ。

|安定度抽象度等価の原則 (SAP) の導入

安定度 抽象度等価の原則 (SAP) は、 安定度と抽象度の関係についての原則だ。 安定度の 高いコンポーネントは抽象度も高くあるべきで、 安定度の高さが拡張の妨げになってはいけな いと主張している。 一方、安定度の低いコンポーネントは具体的なものであるべきだとして る。 安定度が低いことによって、 その内部の具体的なコードが変更しやすくなるからである。

したがって、 コンポーネントの安定度を高くしようと思えば、拡張できるようにインターフェ イスと抽象クラスで構成すべきである。 安定度が高くて拡張可能なコンポーネントは柔軟にな り、アーキテクチャへの制約も少なくなる。

安定度抽象度等価の原則 (SAP) と安定依存の原則 (SDP) の組み合わせが、 コンポーネ

138

安定度 抽象度等価の原則 (SAP)

ント版の依存関係逆転の原則 (DIP) に相当する。 安定依存の原則 (SDP) では、安定度が高く なる方向に依存すべきであると言い、安定度抽象度等価の原則 (SAP) では、安定度が抽象 度と連動するものだと言っているからだ。 つまり、 抽象度が高くなる方向に依存すべきという ことになる。

とはいえ、依存関係逆転の原則 (DIP) はクラスの関係を表す原則であり、クラスにはグレー ゾーンは存在しない。 抽象クラスとそれ以外のクラスにきちんと区別できる。 一方、 安定依存 原則 (SDP)と安定度抽象度等価の原則 (SAP) の組み合わせはコンポーネントの関係を 表す原則だが、コンポーネントの安定度や抽象度はきちんと区別できるものではない。

| 抽象度の計測

コンポーネントの抽象度を表す指標 A を以下のように定める。 この値は、 コンポーネントに 含まれるクラスの総数に占める、 インターフェイスや抽象クラスの割合を算出したものだ。

●Nc: コンポーネント内のクラスの総数。

●Na: コンポーネント内の抽象クラスとインターフェイスの総数。

●A: 抽象度。 A = Na

Nc

Aは0から1までの値をとる。 この値が0であれば、そのコンポーネントに抽象クラスやイ ンターフェイスが一切含まれないことを表す。 この値が1であれば、 そのコンポーネントには 抽象クラスやインターフェイスしか含まれないことを表す。

主系列

さて、安定度 (I) と抽象度 (A) の関連を定義する段階にきた。 縦軸をA、 横軸を1とする グラフを作ってみよう (図14-12)。 「よいもの」とされている2種類のコンポーネントが、こ のグラフのどこに置かれるかを考えてみよう。 安定度と抽象度がともに最大のコンポーネント は、グラフの左上にあたる (0.1) にプロットされるだろう。 同様に、 安定度と抽象度がとも に最低のコンポーネントは、グラフの右下にあたる (1.0)にプロットされる。

すべてのコンポーネントがこのどちらかに収まるわけではない。 抽象度にも安定度にも、程 度というものがあるからだ。 たとえば、何かの抽象クラスを継承して別の抽象クラスを作るの はよくあることだ。この派生クラスは、 依存性を含む抽象クラスになる。 つまり、 抽象度は最 大ではあるが、 安定度は最大ではないことになる。 依存性を含むことで、 安定度が低下してい るのである。

139

第 14章 コンポーネントの結合 A (0,1) (1,0) 図 14-12 I/A グラフ

すべてのコンポーネントを (0.1) か (1.0) のいずれかになるように強制することは不可能 だが、コンポーネントがVAグラフのどのあたりにあれば妥当かを定めることはできる。 これ を定めるには、 コンポーネントがプロットされるべきではない (除外すべき) 範囲を見つけれ ばいい (図 14-13) 。

(0.1)k A 苦痛ゾーン 主系列 無駄ゾーン (1.1) (0,0) 1 (1,0) 図 14-13 除外すべき範囲

苦痛ゾーン

(0.0) の近辺にあるコンポーネントについて考えてみよう。 ここにあるのは、安定度が最高 の具象コンポーネントである。 そのようなコンポーネントは柔軟性に欠けているので好ましく ない。 抽象度が低いために拡張することができず、 安定度が高いために変更も難しい。 きちん と設計したコンポーネントが (0.0)の近辺にくることは、普通はないだろう。 この近辺は除

140

度 抽象度等価の原則 (SAP

安定)

外すべき領域であり、 苦痛ゾーンと呼ばれている。

ソフトウェアの構成要素のなかには、このゾーンに入るものもある。 その一例が、 データベー ススキーマだ。 データベーススキーマは変更されやすく、極めて抽象度が低く、他のコンポー ネントから依存されまくっている。 だからこそ、 オブジェクト指向アプリケーションとデータ ベースとのインターフェイスをきちんと管理するのは難しく、スキーマの変更は苦痛を伴う作 業になりがちなのだ。

(0.0) 近辺にあるソフトウェアの例としてもうひとつ考えられるのが、 具象ユーティリティ ライブラリだ。 こうしたライブラリの1の値は1になるが、 実際にはほとんど変更されること はないだろう。たとえば、 String コンポーネントを考えてみよう。 ここに含まれるクラスはす べて具象クラスだが、 あまりにもいろいろなところから使われているために、ちょっとした変 更でも大騒ぎになってしまう。 つまり、 String は変動性が低い。

変動性の低いコンポーネントは (0.0) 近辺にあっても害はない。 変更されることはまずない からだ。 つまり、 苦痛ゾーンにあると問題になるのは、 変動性の高いソフトウェアコンポーネ ントだけということになる。 変動性が高ければ高いほど、このゾーンにあるときの「苦痛」も大 きくなる。このグラフの第三の軸として、 変動性を考えてもいいだろう。 その場合、 図14-13 は苦痛が最大 (つまり、変動性が最大) な平面だけを表していることになる。

無駄ゾーン

次に、 (1.1)の近辺にあるコンポーネントを考えてみよう。 最大限に抽象化されているにも かかわらず、 それに依存するコンポーネントが存在しない。 そんなコンポーネントは無意味だ。 この領域を無駄ゾーンと呼ぶ。

このゾーンにいるソフトウェアは、ゴミのようなものだ。 実装がひとつもないまま放置され た抽象クラスなどがそうだ。 コードベースに含まれてはいるものの、実際には使われていない コードが存在することもある。

このゾーンに深く入り込んだコンポーネントには、そうした要素がかなりの割合で含まれて いるに違いない。 もちろん無駄な要素がある状態は好ましくない。

|除外すべきソーンを回避する

変動性の高いコンポーネントをこれらのゾーンからできるだけ遠ざけておくべきなのは明ら かだ。 両方のゾーンから最も離れた点を結ぶ軌跡は (10) (0.1) をつなぐ直線になる。こ の直線を主系列と呼ぶことにする。

2 天文学の重要な概念を表す用語を借用するという傲慢を許してほしい。

141

章 コンポーネントの結合

第14

主系列上にあるコンポーネントは、その安定度に対して抽象的すぎず、 その抽象度に対して不 安定すぎないものとなる。 無駄でもないし、 大きな苦痛を伴うこともない。 抽象度が高いため

にほかから依存されていることもあれば、 抽象度が低いためにほかに依存していることもある。 コンポーネントにとって理想的な場所は、主系列の両端のどちらかである。 優れたアーキテ クトは、大半のコンポーネントをそのどちらかに収めようと努力している。 だが、これまでの 経験上、 大規模システムにはどうしてもそこに収まらないコンポーネントが存在する。 そうし たコンポーネントについては、できるだけ主系列上に乗せるか、 そこに近づけるようにすると いいだろう。

|主系列からの距離

ここで登場するのが最後の指標だ。 コンポーネントが主系列にできるだけ近い位置にあるこ とが望ましいのであれば、 その理想からどの程度離れているのかを表す指標を用意すればいい。

●D (Distance): 距離。 D = [A+1-11 これは0以上1以下の値となる。 値が0の場合、 そ のコンポーネントはまさに主系列にあることを意味する。 値が1の場合、 主系列から最も かけ離れた状態を表す。

この指標を使えば、主系列への適合度について設計の分析ができるようになる。 すべてのコ ンポーネントのDの値を算出してから、Dが0付近にないコンポーネントについて再検討すれ ばいい。

設計を統計的に分析することもできる。 すべてのコンポーネントのDの値について、 その平 均と分散を計算してみよう。 うまく設計できていれば、 平均も分散も0に近づくだろう。 分散 を使えば、そのほかのコンポーネントと比較した 「例外的な」 コンポーネントを識別するため の 「制御限界」を定めることができる。

図14-14の散布図からは、 大半のコンポーネントが主系列上にあるが、 平均からの距離が標 準偏差 (Z1)を超えているコンポーネントも存在することが読み取れる。これらの異常な コンポーネントは、改めて精査する価値があるだろう。 何らかの理由で、その抽象度の割に依 存が少なすぎたり、具象コンポーネントが大量の依存を持っていたりすることが考えられる。

この指標のもうひとつの利用法として考えられるのは、 個々のコンポーネントについてD値 の推移を記録することだ。 その結果は、 図14-15のようなグラフになる。このグラフからは、 直近の何回かのリリースで Payroll コンポーネントに奇妙な依存性が入り込んでいることが読 み取れる。 このグラフでは、制御の閾値をD=0.1 にしている。 R2.1 の点はこの制御限界を超

以前の著書では、この指標のことをD'と呼んでいたが、別にそれを踏襲する理由もないと判断した。

142

まとめ

A Main Sequence Z=2 Z=1 I 図 14-14 コンポーネントの散布図

えているので、なぜ主系列からこんなに離れてしまったのかを調べる価値があるだろう。

0.2 1 D 0.1 R1.0 R1.1 Payrollパッケージ R1.2 R2.0 R2.1 リリース

図 14-15 あるコンポーネントのD値の推移

まとめ

本章で取り上げた依存性管理の指標は、設計における依存性と抽象度の関係が、私が 「よい 「もの」と考えているパターンに当てはまるかどうかを計測するものである。 経験上、世の中に はよい依存もあれば、 悪い依存もある。 これらの指標は、私のこれまでの経験を踏まえたもの

143

第14章 コンポーネントの結合

になっている。 とはいえ、これらの指標がすべてではない。 これは何らかの基準に従って計測 しただけにすぎない。 だが、 万能ではないかもしれないが、それなりに役立つのではないだろ うか。

144

アーキテクチャ

V. 部

第

145



アーキテクチャとは? 15

「アーキテクチャ」 という言葉は、 力と神秘のビジョンを呼び起こす。 重苦しい決断と深い技 術力のことが頭に思い浮かぶ。 ソフトウェアアーキテクチャは技術の成果の頂点にある。 ソフ トウェアアーキテクトといえば、絶大な力を持ち、尊敬を集める人物が思い浮かぶ。 「いつの日 かソフトウェアアーキテクトになりたい」。 意識の高い若きソフトウェア開発者のなかで、 そう 思わない者がいるだろうか?

だが、 ソフトウェアアーキテクチャとは何だろうか? ソフトウェアアーキテクトは何をす るのだろうか? いつそれをやるのだろうか?

そもそもソフトウェアアーキテクトはプログラマである。 プログラマを続けておかなければ いけない。 ソフトウェアアーキテクトはコードを書かず、 より高いレベルの問題にフォーカス するものだ、というウソを信じてはダメだ。 そんなのはデタラメだ! ソフトウェアアーキテ クトは最高のプログラマであり、継続してプログラミングの仕事を引き受けながら、 生産性を 最大化する設計にチームを導いていく。 ほかのプログラマほどコードを書かないかもしれない が、引き続きプログラミングの作業に関わっている。 自分で課題を経験していなければ、ほか のプログラマのために適切な仕事をすることなどできないからだ。

147

第15章 アーキテクチャとは?

ソフトウェアシステムのアーキテクチャは、 それを構築した人がシステムに与えた「形状」 である。 その形状を生み出すためには、システムをコンポーネントに分割し、 コンポーネント をうまく配置して、 コンポーネントが相互に通信できるようにする必要がある。

アーキテクチャの形状の目的は、そこに含まれるソフトウェアシステムの開発・デプロイ・ 運用 保守を容易にすることである。

それらを容易にするための戦略は、できるだけ長い期間、 できるだけ多く選択肢を残すことである。

この言葉はみなさんを驚かせたかもしれない。 みなさんは、 アーキテクチャの目的を 「シス テムを適切に動作させること」だと考えていたのではないだろうか。 確かにシステムは適切に 動作させたい。そして、システムのアーキテクチャは、それを最重要の優先事項としてサポー トするものでなければいけない。

しかし、システムのアーキテクチャは、システムの動作に影響を与えるものではない。 世の 中には数多くのシステムがあり、ひどいアーキテクチャにもかかわらず、正しく動作している ものはいくつも存在する。 運用でトラブルが発生しているのではなく、 デプロイ 保守開発 でトラブルが発生しているのである。 .

アーキテクチャがシステムを適切に動作させるサポートの役割を果たすべきではない、とい うことではない。 実際にその役割は果たしており、 それは非常に重要なものである。 だが、それ は能動的で必要不可欠なものではなく、 受動的で装飾的なものなのだ。 システムの振る舞いの 選択肢として、アーキテクチャが残せるものはほとんどないと言っていいだろう。

アーキテクチャの主な目的は、システムのライフサイクルをサポートすることである。優れ たアーキテクチャがあれば、システムを容易に理解・開発・保守 ・ デプロイできる。 最終的な 目的は、システムのライフタイムコストを最小限に抑え、プログラマの生産性を最大にするこ とである。

開発

開発が難しいソフトウェアシステムは、ライフタイムが長くて健全である可能性が低い。 だ からこそ、システムのアーキテクチャによって、 開発チームが開発しやすくなるようなシステ ムにするべきなのである。

チームの構成が異なれば、 アーキテクチャの決定も異なる。 たとえば、 開発者が5人程度の 小規模なチームであれば、コンポーネントやインターフェイスが明確に定義できていないモノ リシックなシステムでも、みんなで協力してうまく開発できるはずだ。 実際、そのようなチー

148

ムは、開発初期はアーキテクチャの構造が何らかの障害物になると考えている。 多くのシステ ムに優れたアーキテクチャが存在しないのはそのためだ。 チームの規模が小さく、 障害物とな るような強固な構造を望んでいないので、 最初からアーキテクチャが存在しないのである。

一方、 開発者が7人ずつ、5つのチームで開発しているシステムは、 信頼性の高い安定した インターフェイスで明確にコンポーネントを分割しない限り、 作業をうまく進めることはでき ない。このシステムのアーキテクチャは(ほかの要素を考慮しないならば)、1チームずつ合計 5つのコンポーネントになっていくだろう。

このようなチーム単位のアーキテクチャは、システムのデプロイ 運用・保守に最適なアーキ テクチャではない。 だが、 開発スケジュールが差し迫っていると、どうしてもこのようなアー キテクチャになってしまう。

デプロイ

ソフトウェアシステムが効果を生み出すためには、デプロイ可能な状態でなければいけない。 デプロイのコストが高ければ、その分だけシステムの有用性は低下する。 ソフトウェアアーキテ クチャの目的は、システムを単一のアクションで簡単にデプロイできるようにすることである。

残念なことに、 開発初期にデプロイ戦略を考慮することはほとんどない。 そのため、 システ ムの開発は容易になるかもしれないが、デプロイは非常に難しいものとなってしまう。

たとえば、システムの開発初期に、 開発者が 「マイクロサービスアーキテクチャ」の導入を 決めたとする。 コンポーネントの境界が明確で、 インターフェイスが比較的安定しているため、 システムの開発が楽になると思ったのかもしれない。 だが、 システムをデプロイする時期にな ると、マイクロサービスの数が問題になることが判明する。 それぞれのサービスの設定や接続、 起動のタイミングが、重大なエラーの原因となるのだ。

早い段階からアーキテクトがデプロイの問題について考えていれば、サービスの数を減らし たり、サービスとプロセス内のコンポーネントのハイブリッドにしたり、 相互接続を管理する 統合的な手段を選択したり、何らかの対策ができていただろう。

運用

• システムの運用に対するアーキテクチャの影響は、 開発 デプロイ・保守に対する影響と比 べるとさほど大きくはない。 運用の問題の多くは、ソフトウェアアーキテクチャを変更しなく ても、ハードウェアを追加すれば解決できる。

運用

149

第15章 アーキテクチャとは?

実際、このような光景を何度も目にしたことがあるはずだ。 非効率的なアーキテクチャを持 ソフトウェアシステムでも、ストレージやサーバーを追加するだけで正常に動作することは よくある。 ハードウェアは安価であり、 人は高価であるという事実を踏まえれば、 デプロイ 開発・保守を妨げるアーキテクチャよりも、 運用を妨げるアーキテクチャのほうがコストは安 い、ということになる。

システムの運用に最適化されたアーキテクチャが望ましくない、というわけではない。むし ろそれは望ましい! ただ、コストの計算式が、 開発デプロイ 保守に偏りすぎているので ある。 .

とはいえ、システムの運用におけるアーキテクチャの役割はほかにもある。 それは、 システ ムの運用ニーズを伝えるというものだ。

アーキテクチャが優れていれば、システムの運用方法は開発者が見ればすぐにわかる、 と説 明すればわかりやすいだろう。 つまり、 アーキテクチャが運用方法を明らかにするのである。 システムのアーキテクチャは、システムに求められるユースケース、 機能、 振る舞いを、 ファー ストクラスのエンティティになるまで高める必要がある。 そして、 それが開発者にとっての目 印となるべきだ。 これにより、 システムの理解が容易になり、 そのことによって、 開発や保守 に大いに役立つのである。

保守

ソフトウェアシステムのすべてにおいて、保守は最もコストがかかるものである。 永遠に続く

新しい機能の登場と、 避けられない欠陥や修正の繰り返しは、 人的リソースを膨大に消費する。 保守の主なコストは、洞窟探検とリスクだ。洞窟探検とは、 既存のソフトウェアを掘り起こ し、新しい機能の追加や欠陥の修正において、 最適な場所や戦略を見つけるコストである。 こ のような変更を行っているうちに、意図しない欠陥を生み出す可能性が生まれ、 リスクのコス トを高めることになってしまう。

アーキテクチャを慎重に考え抜けば、これらのコストは大幅に低下する。 システムをコンポー ネントに分離して、安定したインターフェイスを持つ独立したコンポーネントにしておけば、 将来の機能の道筋が照らされ、意図せずに壊してしまうリスクを大幅に軽減できるだろう。

150

選択肢を残しておく

選択肢を残しておく

これまでの章で説明したように、ソフトウェアには2種類の価値がある。 「振る舞いの価値」 と 「構造の価値」だ。 そして、後者のほうが価値が大きい。 なぜなら、 それがソフトウェアをソ フトにする価値だからだ。

ソフトウェアが発明されたのは、マシンの振る舞いをすばやく簡単に変更する必要があった からだ。 だが、その柔軟性は、システムの形状、 コンポーネントの配置、 コンポーネントの相 互接続に大きく依存する。

ソフトウェアをソフトに保つには、できるだけ長い期間、 できるだけ多く選択肢を残すこと である。 では、 「残すべき選択肢」 とは何だろうか? それは、重要ではない詳細である。

あらゆるソフトウェアシステムは、大きく2つの要素に分割できる。 「方針」 と 「詳細」だ。 方針の要素は、ビジネスのすべてのルールや手順を含んでいる。 方針には、システムの本当の 価値がある。

詳細は、 人間・そのほかのシステムプログラマが、 方針についてやり取りするために必要な ものだが、 方針の振る舞いに影響を与えるものではない。 詳細には、 IO デバイス、 データベー

ス、ウェブシステム、サーバー、 フレームワーク、 通信プロトコルなどが含まれる。

アーキテクトの目的は、 方針とは無関係に詳細を決めながら、 方針をシステムの最も重要な要 素と認識するシステムの形状を作ることである。 こうすることで、 詳細の決定を延期や留保す ることができる。

いくつか例を挙げよう。

開発の初期段階でデータベースシステムを選択する必要はない。 なぜなら上位の方針では、 使用するデータベースの種類を気にかけるべきではないからだ。 実際、アーキテクトが気 をつけていれば、 リレーショナルデータベースなのか、 分散型データベースなのか、階層 型データベースなのか、プレインなファイルなのかを上位の方針で気にすることはない。

●開発の初期段階でウェブサーバーを選択する必要はない。 なぜなら上位の方針では、ウェ ブで配信するかどうかを気にかけるべきではないからだ。 上位の方針が、 HTML、 AJAX JSP JSF などのウェブ開発における 「アルファベットの羅列」 を認識しなければ、 プロ ジェクトの決定を遅らせることができる。 実際、システムをウェブ経由で配信するかどう かすら決める必要はない。

●開発の初期段階で REST を採用する必要はない。 なぜなら上位の方針では、 外の世界に対 するインターフェイスを認識すべきではないからだ。 マイクロサービスやSOA のフレー ムワークを採用する必要もない。 繰り返すが、 上位の方針が気にする必要はない。

開発の初期段階でDIフレームワークを導入する必要はない。 なぜなら上位の方針では、依

151

章 アーキテクチャとは?

第15

存性の解消方法を気にかけるべきではないからだ。

理解できたのではないだろうか。 周囲の詳細を気にせずに上位の方針を構築できれば、詳細 の決定をしばらく延期 留保できる。 また、決定を遅延できれば、その分だけ適切に作るため の情報が数多く手に入る。

これにより、複数の実験をするという選択肢も与えられる。 あなたが上位レベルの方針に関 与していて、それがデータベースについて認識していないとわかっている場合は、事前に複数の 異なるデータベースに接続して、妥当性やパフォーマンスをチェックすることができる。 ウェブ システム、フレームワーク、ウェブの利用そのものについても、同じ方法を適用できるだろう。 選択肢を残せる期間が長ければ、 実験できる数が増え、挑戦できることが増え、決定しなけ ればいけない時点までに入手できる情報も増える。

では、ほかの誰かがすでに決定していた場合はどうだろうか? 会社がすでに特定のデータ ベース、ウェブサーバー、フレームワークを使うと決めていた場合はどうだろうか? 優秀な アーキテクトならば、まだ決まっていないと主張するだろう。 そして、 決定をできるだけ長く遅 できるように、あるいはいつまでも変更できるように、システムの形状を決めていくだろ

バイス非依存

考え方の一例として、1960年代に戻ってみよう。 当時は、コンピュータはまだティーン ャーで、ほとんどのプログラマは数学者かほかの分野のエンジニアだった (それから、 3 上が女性だった)。

我々は、数多くの間違いを犯した。 そのときはそれが間違いだとも気づかなかった。 なかった。

ドを10デバイスに直接バインドするという間違いを犯したことがある。 プリ 字する必要があったので、プリンターを制御する IO命令を使ったコードを そのコードはデバイス依存だった。

レプリンターに印刷する PDP-8プログラムを書くとき、私は以下のようなマシ いた。

SMP I PRTCHR

TL2

デバイス非依存

PRTCHR は、 テレプリンターに1文字を印字するサブルーチンである。 最初の0はリターンア ドレスの記憶領域として使用する (質問は受け付けない)。 TSF は、テレプリンターが文字を印 字する準備ができていれば、次の命令をスキップするものである。 テレプリンターがビジーで あれば、 TSF から JMP に移り、 また TSF にジャンプする。 準備ができていれば、 TSF から TLS に飛び Aレジスタにある文字をテレプリンターに送信する。 そして、 JMP I PRTCH で呼び出 し元に戻る。

最初のうちは、この戦略でうまくいった。 カードリーダーからカードを読み取るときは、 カー ドリーダーと直接やり取りをするコードを使用した。 カードをパンチするときは、 カードバン チを直接操作するコードを記述した。 プログラムは完ぺきに動いた。 これが間違いだったとは、 当時の我々は知る由もなかったのである・・・・・。

パンチカードの束は管理が難しい。 なくなったり、破けたり、穴があいたり、 バラバラになっ たり、 どこかに落ちたりすることもあった。 正しいカードがどこか消えて、余計なカードが混 ざっていることもあった。 データの整合性は大きな問題になっていた。

解決策は磁気テープだった。 カードのイメージをテープに移すことができた。 磁気テープを 落としても、レコードがバラバラになることはなかった。 誤ってレコードを失うこともなかっ たし、テープを渡すだけで空のレコードが挿入されることもなかった。 テープは安全だった。 また、読み書きが高速で、 バックアップコピーを作成するのも簡単だった。

だが、残念なことに、 我々のソフトウェアはカードリーダーとカードバンチを操作するため に書かれたものだった。 磁気テープを使うためには、すべてを書き直さなければいけなかった。 それは大変な仕事だった。

1960年代後半までに我々は、デバイス非依存にたどり着いた。 当時のオペレーティングシス テムは、 カードのようなユニットレコードを処理するソフトウェア機能として、 10デバイスを 抽象化していた。 プログラムからは、 抽象的なユニットレコードデバイスを操作するオペレー ティングシステムのサービスを呼び出せばいい。 オペレーターは、こうした抽象サービスを接 続するカードリーダー、 磁気テープ、ユニットレコードデバイスをオペレーティングシステム に伝えた。

これにより、 何も変更することなく、 同じプログラムでカードの読み書きとテープの読み書 きの両方ができるようになった。 ここからオープン・クローズドの原則 (OCP) が誕生した (そ の名前はまだなかったが)。

153

第15章 アーキテクチャとは?

ダイレクトメール

1960年代後半、 私はクライアントのためにダイレクトメールを印刷する会社に勤めていた。 クライアントがユニットレコードの入った磁気テープを送ってくる。そこには、氏名や住所な どの顧客の情報が記録されている。 我々は、パーソナライズされたステキな広告を印字するプ ログラムを書いた。

こんにちは、マーティンさん

おめでとうございます!

ウィッチウッドレーンの住人から、なんと「あなた」が選ばれました。 すばらしい限定サービスにご参加いただけます。 つきましては…

クライアントは巨大なロール紙を送ってきた。 そこには手紙の文面が記載されており、 氏名 と住所などの印字したい要素が空になっていた。 我々は、磁気テープから氏名や住所などの要 素を抽出し、 指定された部分に印字するプログラムを作成した。

ロール紙の重さは225キロ以上もあり、数千通分に相当した。 クライアントはそのロール紙 を数百個送ってきた。 我々が個別に印刷するのだ。

最初は、IBM 360の1台のラインプリンターで印刷していた。 それは、シフトごとに数千文 字を印字することができた。 だが、非常に高価なマシンを長時間稼働し続けることになった。 その当時、 IBM 360 をレンタルするのに月額数万ドルもかかっていたからだ。

そこで、ラインプリンターの代わりに、 磁気テープを使用するようにオペレーティングシス テムに指示を出した。 オペレーティングシステムで抽象化したIO を使っていたので、プログラ ムは何も問題なく動作した。

IBM 360は、テープの内容を約10分でダンプアウトした。 複数のロール紙に印刷するのに 十分な量だった。 磁気テープをコンピュータ室の外に持ち出して、オフラインプリンターに接 続されたテープドライブにマウントした。 オフラインプリンターは5台あり 24時間ずっと稼 働させることができた。 それらを使い、 毎週数十万通のダイレクトメールを印刷した。

デバイス非依存の効果は絶大だった! 使用するデバイスのことを知らなくても、何も気に かけることなく、プログラムを書くことができた。 コンピュータに接続されたローカルライン プリンターを使用して、プログラムをテストすることができた。 磁気テープに「印刷」 する命 令をオペレーティングシステムに出してから、 数十万通の印刷を実行したのである。

我々のプログラムには 「形状」 があった。 その形状は、 方針と詳細を切り離すものだった。 こ

154

物理アドレス

こでの方針は、氏名と住所のレコードの書式を設定することだった。 ここでの詳細は、それを 印刷するデバイスだった。 我々は、 使用するデバイスの決定を遅らせたのである。

物理アドレス

1970年代初頭、私は全米トラック運転手組合の大規模な会計システムの仕事をしていた。 25MB のディスクドライブがあり、そこに Agent, Employer Member のレコードを格納した。 レコードごとにサイズがさまざまだったので、 各セクタが Agent レコードのサイズになるよう に、ディスクの最初のいくつかのシリンダをフォーマットするようにした。次のいくつかのシ リンダは、 Employer レコードに合うセクタを持てるようにフォーマットした。 最後のいくつか のシリンダは、Member レコードに合うようにフォーマットした。

我々は、ディスクの詳細な構造を知るためのソフトウェアを書いた。 その結果、ディスクに は200のシリンダと10のヘッドがあり、 各シリンダにはヘッドあたり数十のセクタがあるこ とがわかった。 また、 どのシリンダに Agent, Employer, Member が保持されているかもわかっ これらはすべてコードに組み込まれていた。

我々は、Agent Employer Member を検索するためのインデックスをディスクに保存した。 このインデックスは、ディスクにある特別にフォーマットされたシリンダだった。 Agent のイ ンデックスは、そのレコードのID、 シリンダ番号、 ヘッド番号、 セクタ番号で構成されていた。 Employer と Member も同様のインデックスを持っていた。 Member はディスクにある二重連結リ ストでも保持されていた。 Member レコードは、次の Member レコードと前の Member レコード のシリンダ番号、 ヘッド番号、 セクタ番号を保持していた。

新しいディスクドライブにアップグレードする場合、 何が起きるだろうか? それがヘッド の多いものだったら? シリンダが多いものだったら? シリンダのセクタが多いものだった ら? 我々は、 古いディスクからデータを読み取り、 新しいディスクに書き出して、 すべての シリンダヘッダー、セクタの番号を変換するという特別なプログラムを書く必要があった。 コードにある配線をすべて接続し直す必要があったのだ。 それがコードのあらゆるところに存 在した! すべてのビジネスルールが、 シリンダヘッダー、 セクタの構造を詳細に把握して いたのである。

ある日、経験豊富なプログラマが仲間に加わった。 我々がこれまでやってきたことを見た彼 は、顔面から血の気が引いていた。 我々がまるでエイリアンであるかのように衝撃を受けてい た。 そして、アドレス方式を相対アドレスに変えるべきだと穏やかにアドバイスしてくれた。 その賢明な同僚は、ディスクをセクタの巨大な配列と見なし、シーケンシャルな整数でアドレ ス可能にすべきだと提案した。 そのようにしたことで、我々は簡単な変換ルーティンを書くこ

155

第15章 アーキテクチャとは?

とができた。 ディスクの物理的な構造を把握し、相対アドレスをその場でシリンダヘッダー、 セクタの番号に変換するというものだ。

我々にとって幸いだったのは、彼のアドバイスを受け入れることができたということだ。 ディ スクの物理的な構造を把握できないように、 システムの上位の方針を変更したのである。 これ により、ディスクドライブの構造に関する決定をアプリケーションから切り離すことができた。

まとめ

本章で紹介した2つの物語は、 アーキテクトが大規模に採用している原則の小規模な活用例 である。 優れたアーキテクトは、 方針と詳細を慎重に区別して、 方針が詳細を把握することな く、決して依存することがないように、両者を切り離す。 優れたアーキテクトは、詳細の決定 をできるだけ延期 留保できるように、 方針をデザインする。

156

独立性 16日 章

申 UBOUND KONKE

これまでに述べたように、優れたアーキテクチャは以下のことをサポートしなければいけ ない。

●システムのユースケース ●システムの運用 ●システムの開発 ●システムのデプロイ

ユースケース

条書きの最初の「ユースケース」とは、アーキテクチャがシステムの意図をサポートしな ければいけないことを意味している。 ショッピングカートのアプリケーションであれば、アー

157

第16章 独立性

キテクチャはショッピングカートのユースケースをサポートしなければいけない。 まさにアー キテクトの最大の関心事であり、 アーキテクチャの最優先事項になるだろう。 アーキテクチャ はユースケースをサポートしなければいけない。

だが、前述したように、アーキテクチャがシステムの振る舞いに大きな影響を与えることは ない。 アーキテクチャが選択肢として考えられることはほとんどない。 とはいえ、影響を与え

ることがすべてではない。 アーキテクチャが振る舞いをサポートするために最も重要なことは、 アーキテクチャレベルでシステムの意図がわかるように、 振る舞いを明らかにすることである。 優れたアーキテクチャを備えたショッピングカートのアプリケーションは、ショッピング カートのアプリケーションのように見える。 システムのユースケースは、 システムの構造のな かにハッキリと見えるようになるのだ。 開発者は振る舞いを探すことがなくなる。 振る舞いは ファーストクラスの要素として、システムのトップレベルにあるからだ。 このような要素には、 クラス、関数、モジュールなどがあり、 アーキテクチャでは目立った位置にいる。 また、 それ ぞれの機能を明確に示す名前が付けられている。

第21章 「叫ぶアーキテクチャ」では、このポイントをさらに明確にするつもりだ。

運用

アーキテクチャは、システムの運用において、 表面的というよりも本質的な役割を果たす。 システムが毎秒 100,000 人の顧客を処理する必要があるなら、 アーキテクチャはその求められ るユースケースに対して、スループットと応答時間をサポートしなければいけない。 システム から巨大なデータキューブにミリ秒単位で問い合わせる必要があれば、 アーキテクチャはそう した運用を可能にする構造になっていなければいけない。

これを実現するために、小さなサービスをいくつも配置して、それぞれのサービスを並列で 実行するシステムもあるだろう。 ひとつのプロセッサでひとつのプロセスを動かし、アドレス 空間を共有する大量の軽量スレッドで実現するシステムもあるだろう。 アドレス空間を共有し ない複数のプロセスを使うシステムもあるだろう。 ひとつのプロセスで単純なモノリシックな プログラムを動かすシステムもあるだろう。

奇妙に思えるかもしれないが、優れたアーキテクトであれば、こうした決定は選択肢として 残しておく。 たとえば、モノリシックに書かれたシステムがその構造に依存している場合、必 要に応じて、複数プロセス、 複数スレッド、マイクロサービスなどへと簡単にアップグレード することはできない。 一方、 コンポーネントを適切に分割し、 コンポーネントの通信方法とし て特定の技術を想定していないアーキテクチャならば、システムの運用ニーズの変化に合わせ て、スレッド、プロセス、サービスなどへと比較的簡単に移行することができる。

158

選択肢を残しておく

開発

アーキテクチャは、 開発環境のサポートにおいて、 非常に重要な役割を果たす。 ここで、 コ ンウェイの法則が作用する。

[コンウェイの法則] システムを設計する組織は、組織のコミュニケーション構造をコピーした構造 の設計を生み出す。

チームや利害関係の多い組織では、開発中にチームがお互いに干渉しないように、それぞれ のチームの行動を独立させるアーキテクチャをシステムに持たせる必要がある。 そのためには、 単独で開発可能なコンポーネントにシステムを適切に分割しなければいけない。 そして、チーム が独立して動けるように、 分割したコンポーネントをそれぞれのチームに割り当てるのである。

デプロイ

アーキテクチャは、デプロイの手軽さの決定にも大きな役割を果たす。 目指すべきは「即時 デプロイ」である。 優れたアーキテクチャならば、大量にある構成スクリプトやプロパティファ イルの変更に依存することはない。 ディレクトリやファイルを手作業で作成して用意する必要 もない。 優れたアーキテクチャがあれば、 構築後すぐにシステムをデプロイできる。

これもシステムをコンポーネントに適切に分離・分割することで実現可能となる。 このなか には、システム全体をまとめ、各コンポーネントが適切に開始 統合管理されるようにする 主要なコンポーネントも含まれる。

選択肢を残しておく

優れたアーキテクチャであれば、これらのすべての懸念点とそれらをお互いに満足させるコ ンポーネントの構造のバランスをうまく取ることができる。 ね、簡単でしょ? まあ、言うの は簡単だ。

実際にこのバランスを取ることは難しい。 問題となるのは、すべてのユースケースを把握で きないこと、運用上の制約、 チーム構造、 デプロイ要件がわからないことである。 たとえわかっ ていたとしても、システムのライフサイクルに応じて、 それらは必然的に変化していく。 つま り、目指すべき目標は不明瞭で一貫性がないのだ。 ようこそ、現実世界へ。

159

第16章 独立性

だが、すべてがわからないわけではない。 達成すべきターゲットが明確でなくても、比較的 安価に実装することができ、 上記のバランスをうまく取ることができるアーキテクチャの原則 もある。 こうした原則によって、 システムを独立したコンポーネントに分割できる。 それによ できるだけ長い期間、 できるだけ多く選択肢を残すことが可能になる。

システムをどのように変更せざるを得なかったとしても、優れたアーキテクチャがあれば、 選択肢を残すことでそれが容易になるのである。

レイヤーの切り離し

ユースケースを考えてみよう。 アーキテクトは、必要なユースケースをすべてサポートする システムの構造を求めているが、 すべてのユースケースを把握することはできない。 だが、シ ステムの基本的な意図はわかっている。 これはショッピングカートのシステム、 それは BOM (部品表) のシステム、 あれは注文処理システム、 という具合だ。 アーキテクトは、 単一責任の 原則 (SRP) 閉鎖性共通の原則 (CCP) を使用して、 システムの意図を考慮しながら、 異な る理由で変更されるものを分離し、 同じ理由で変更されるものをまとめることができる。

異なる理由で変更されるものとは何か? 明らかなものがいくつかある。 たとえば、 ユーザー インターフェイスを変更する理由は、ビジネスルールを変更する理由とは関係がない。 だが、 ユースケースにはその両方の要素がある。 優れたアーキテクトならば、 ユースケースのUI部分 とビジネスルールの部分を分離したいと思うはずだ。 そうすれば、ユースケースは明確にした ままで、それぞれの部分を独立して変更できるようになる。

ビジネスルール自体は、アプリケーションに密接に結び付いているものもあれば、一般的な ものもある。 たとえば、 入力フィールドの検証は、アプリケーションと密接に結び付いている。 一方、 口座の利率計算や在庫の計算といったビジネスルールは、 そのドメインに密接に結び付 いている。 この2種類のルールは異なる頻度や理由で変更されるため、独立して変更できるよ うに分離すべきである。

データベース、クエリ言語、 スキーマなども、ビジネスルールやUIとは関係のない技術的詳 細である。 システムのほかの部分とは関係なく、 異なる頻度や理由で変更されるものだ。 した がって、独立して変更できるように、システムのほかの部分から分離すべきである。

このように、システムは切り離された水平レイヤー (たとえば、 UI、アプリケーション特有 のビジネスルール、アプリケーションに依存しないビジネスルール、データベースなど)で分 割されていることがわかる。

160

切り離し方式

ユースケースの切り離し

ほかに異なる理由で変更されるものはあるだろうか? ユースケースそのものがそうだ! 注 文入力システムに注文を追加するユースケースは、注文を削除するユースケースと比べると、明 らかに異なる頻度と理由で変更される。 ユースケースはシステムを分割する自然な方法である。 また、ユースケースは、システムの水平レイヤーを薄く垂直にスライスしたものである。 そ れぞれのユースケースは、UIの一部、アプリケーション特有のビジネスルールの一部、アプ リケーションに依存しないビジネスルールの一部、 データベース機能の一部を使用する。 した がって、システムを水平レイヤーに分割するときには、 それらを薄く垂直にユースケースとし ても分割するのである。

この切り離しを実現するためには、注文追加のユースケースのUIと注文削除のユースケース のUIを分離する。 ビジネスルールについても、データベースについても同様である。 ユース ケースの分割をシステムの高さにそろえておく。

ここにパターンが見られる。 変更する理由の違いでシステムの要素を切り離しておくと、古 ユースケースに影響を与えずに新しいユースケースを追加できる。 また、 ユースケースから 使用する UIやデータベースをグループ化しておけば、 新しいユースケースを追加しても古い ユースケースに影響を及ぼすことがない。

切り離し方式

箇条書きの2番目の 「運用」について、切り離しの意味を考えてみよう。 さまざまな観点で ユースケースを分離しておけば、 高いスループットで実行しなければいけないものと低いスルー ブットで実行しなければいけないものは分離されているはずである。 UI とデータベースがビジ ネスルールから分離されていれば、 異なるサーバーで実行することができる。 高い帯域幅を必 要とするものは、 複数台のサーバーにレプリケートできる。

つまり、ユースケースの切り離しは、運用にも適用可能である。 ただし、運用で活用するに は、適切な方式が必要となる。 たとえば、別々のサーバーで実行したいなら、 分離したコンポー ネントを同じプロセッサのアドレス空間に配置させることはできない。 それぞれを異なるサー バーに配置して、 何らかの通信手段でやり取りをすることになる。

多くのアーキテクトは、このようなコンポーネントを (その基準はあいまいだが) 「サービス」 または 「マイクロサービス」と呼んでいる。 実際、サービスをベースにしたアーキテクチャは 「サービス指向アーキテクチャ」 と呼ばれることが多い。

161

第16章 独立性

名前が気に入らないと思っても、 気にすることはない。 私は「サービス指向アーキテクチャ」 が最善のアーキテクチャだとか、 「マイクロサービス」のビッグウェーブに乗るしかないと言う つもりはない。ここで言いたいのは、 コンポーネントをサービスレベルまで分離するときもあ る、 ということだ。

忘れないでほしいのだが、優れたアーキテクチャは選択肢を残しておくものである。 切り離 し方式も、そうした選択肢のひとつだ。

このトピックを掘り下げる前に、ほかの箇条書きを見ていこう。

独立した開発が可能

箇条書きの3番目は 「開発」である。 コンポーネントが明確に切り離されていれば、チーム 同士の干渉は緩和される。 ビジネスルールがUI を認識していなければ、 UIにフォーカスした チームがビジネスルールにフォーカスしたチームに影響を与えることはない。 ユースケースが お互いに切り離されていれば、 addOrder (注文追加) のユースケースにフォーカスしたチームが delete Order (注文削除) のユースケースにフォーカスしたチームの邪魔をする可能性は低い。

レイヤーやユースケースが切り離されている限り、 システムのアーキテクチャは、チームを ( フィーチャーチーム、コンポーネントチーム、レイヤーチームなどの編成を問わず) サポート するだろう。

独立デプロイ可能性

レイヤーやユースケースが切り離されていれば、デプロイの柔軟性も高まる。 実際、 うまく 切り離されていれば、稼働するシステムでレイヤーやユースケースをホットスワップすること も可能である。 新しいユースケースを追加するときには、 そのほかの部分はそのままにして、 新しい jar ファイルやサービスをシステムに追加するだけになるだろう。

重複

アーキテクトは罠にハマることがよくある。 その罠は、 重複に対する恐怖から生まれる。 ソフトウェアの世界では、 重複は悪いものだとされている。 重複したコードは好きではない。 コードが重複していたら、 専門家としての威信をかけて、 重複を削減 排除するだろう。

162

切り離し方式 (再び)

だが、 重複の種類はそれだけではない。 たとえば、あるインスタンスに変更があれば、その インスタンスのすべての複製にも同じ変更を反映しなければいけない。 これは本物の重複であ る。明らかに重複していたコードが (変更頻度や理由が違うために) 異なる進化を遂げ、数年 後には両者がまるで違ったものになっていることもある。 これは本物の重複ではない。 偽物の 重複、 あるいは偶然の重複である。

今度は画面構成が同じ2つのユースケースを見ていこう。 おそらくアーキテクトはコードを 共有したい衝動にかられるはずだ。 だが、 本当にそうすべきだろうか? これは本物の重複な のか? 偶然の重複なのか?

おそらく偶然だろう。 時間が経てば、画面は少しずつ違ったものになり、最終的には別物に なっている可能性が高い。 したがって、 統一的に扱わないように注意する必要がある。 あとか ら分離するのは大変だ。

ユースケースを垂直に分離していると、 こうした問題に遭遇する。 そして、 ユースケースを 統合したくなる。 なぜなら、 画面構成が似ていたり、アルゴリズムが似ていたり、 データベー スのクエリやスキーマが似ていたりするからだ。 気をつけてほしい。 反射的に重複を排除する 罪を犯してはいけない。 その重複が本物かどうかを見極めるべきだ。

同様に、レイヤーを水平に分離していると、 あるデータベースのレコードのデータ構造が、 ある画面のデータ構造とよく似ていることに気づくことがある。 ビューモデルを作成して要素 をコピーするのではなく、データベースのレコードをそのままUIに渡したくなるが、注意して ほしい。 これは (ほぼ) 確実に偶然の重複である。 ビューモデルを作成するのは大した労力で はないし、レイヤーを適切に切り離すのに役立つだろう。

切り離し方式 (再び)

再び、切り離し方式だ。 レイヤーやユースケースを切り離す方法はいくつもある。 ソースコー ド (ソース) レベル、バイナリコード (デプロイ) レベル、 実行単位 (サービス)レベルで切り 離すことができる。

●ソースレベルあるモジュールに対する変更が、他のモジュールの変更や再コンパイルに つながらないように、ソースコードモジュール間の依存性を管理する (Ruby Gems など)。 この切り離し方式では、コンポーネントはすべて同じアドレス空間で実行される。 コンポー ネント間の通信には、単純な関数呼び出しを使用する。 コンピュータのメモリに読み込ま れた単一の実行ファイルが存在する。 これを「モノリシック構造」 と呼ぶ。

●デプロイレベル: あるモジュールのソースコードに対する変更が、 ほかのモジュールの再

163

第16章 独立性

ビルドや再デプロイにつながらないように、デプロイ可能な単位の依存性を管理する (jar ファイル、DLL、 共有ライブラリなど)。

多くのコンポーネントは同じアドレス空間に存在し、 通信には関数呼び出しを使用する。 なかには、同じプロセッサの別のプロセスに存在し、 通信にはプロセス間通信、ソケット、 共有メモリなどを使用しているコンポーネントもある。 ここで重要なのは、コンポーネン トが単独でデプロイ可能な単位 (jar ファイル、 Gem ファイル、DLLなど) に分割されて いることである。

●サービスレベル: 依存性をデータ構造のレベルまで下げ、 ネットワークパケットだけで通 信する。そうすれば、すべての実行単位は完全に独立しており、ソースやバイナリを変更 してもお互いに影響を与えることはない (サービスやマイクロサービスなど)。

使用するのに最適な方式はどれだろうか?

その答えは「プロジェクトの初期段階では判断が難しい」 である。 プロジェクトが進んでい くと、最適な方式も変わっていく可能性がある。

たとえば、単一のサーバーだけで快適に稼働していたシステムが、 別のサーバーでいくつか のコンポーネントを実行させる必要があるまで成長する、 といったことは容易に想像できる。 システムが単一のサーバーで動いているうちは、ソースレベルの切り離しで十分だが、 いずれ デプロイ可能な単位やサービスとして切り離すことになるだろう。

ひとつの (現時点で最も人気が高いと思われる) ソリューションとして、最初からサービス レベルで切り離すというものがある。 このアプローチの問題は、 粒度の粗い切り離しにつなが るということだ。マイクロサービスがどれだけ 「マイクロ」になったとしても、切り離しの粒 度が十分に細かくなることはない。

もうひとつの問題は、開発時間とシステムリソースが高価であるということだ。 必要とされ ないサービス境界を扱うために、 労力 メモリ処理サイクルが浪費されていく。 まあ、 後ろ の2つは安価かもしれないが、少なくとも最初のものは安価ではないだろう。

私の好みは、いざというときのために、サービスを作れそうなところまで切り離すというも のである。 ただし、コンポーネントはできるだけ長い期間、 同じアドレス空間に存在させてお く。これは、サービスの選択肢を残しているのだ。

このアプローチでは、 コンポーネントは最初にソースコードレベルで分離されている。 プロ ジェクトの最後までそれで十分なこともある。 デプロイや開発に問題が発生しても、デプロイ レベルに移行すれば (少なくともしばらくは) 十分である。

開発・デプロイ 運用の問題が多くなれば、 デプロイ可能な単位をサービスに変えて、少し . ずつシステムをその方向に移動させていく。

そのうち運用ニーズが低下していくだろう。 そうすれば、サービスレベルの切り離しは、デ

164

まとめ

プロイレベルやソースレベルでも十分になる。

優れたアーキテクチャがあれば、 システムはモノリシックとして生まれ、 単一ファイルでデ プロイされ独立してデプロイ可能な単位になるまで成長し、最後はサービスやマイクロサー ビスまでたどり着くことが可能になるだろう。 その後、 物事が変わったときには、これまでの 流れを逆転させ、モノリシックまで戻せるようになっておくべきである。

優れたアーキテクチャは、ソースコードを変更から保護してくれる。 切り離し方式を選択肢と して残すことで、大規模なデプロイと小規模なデプロイで使用する方式を変えることができる。

まとめ

そう、これは一筋縄ではいかないのだ。 切り離し方式の変更は設定オプションにすべきだと 言いたいわけではない (そのほうが適切なこともあるが)。 私が言っているのは、システムの切 り離し方式は時間とともに変化する可能性があるということだ。 そして、 優秀なアーキテクト であれば、そうした変化を予見して、適切に進めていくのである。

165



バウンダリー:境界線を引く時17歳

ソフトウェアアーキテクチャとは、境界線を引く技芸である。 これを私は 「バウンダリー」と 呼んでいる。 ソフトウェアの要素を分離し、 お互いのことがわからないように制限するという ものである。 プロジェクトの初期に境界線を引くこともある。 まだコードを書いていない段階 だ。 逆に、 なかなか境界線を引かないこともある。 初期に境界線を引くのは、 決定をできるだ け遅らせるためである。 決定によってビジネスロジックが汚染されないようにしているのだ。 アーキテクトの目的は、 求められるシステムを構築・維持するために必要な人材を最小限に 抑えることである。 こうした人々のパワーを奪うものは何か? それは、結合である。 それも 早すぎる決定との結合である。

早すぎる決定とはどのようなものなのか? それは、システムのビジネス要件 (ユースケー ス)と関係のない決定である。 たとえば、 フレームワーク、 データベース、ウェブサーバー、 ユーティリティライブラリ、 DIなどに関する決定が含まれる。 優れたシステムアーキテクチャ は、このような決定を従属的かつ遅延可能なものにする。 優れたシステムアーキテクチャは、 このような決定に依存しない。 優れたシステムアーキテクチャは、重大な影響を与えることな く、このような決定を最終時点まで引き延ばせる。

167

第17

章 バウンダリー 境界線を引く

結合の悲しい物語

P社の悲しい物語を聞いてほしい。 早すぎる決定に対する警告となるだろう。 1980 年代にP 社の創業者たちは、シンプルなモノリシックのデスクトップアプリケーションを開発した。 彼 らは大きな成功を収め、 そのプロダクトは1990年代に人気の高いアプリケーションへと成長 した。

だが、 1990 年代後半にウェブが台頭してきた。 あらゆる企業がウェブソリューションを持た なければならず、それはP社も例外ではなかった。 P社の顧客はプロダクトのウェブバージョ ンを求めた。 この要求に応えるために、P社はイケてる20人の Java プログラマを雇い、プロ ダクトをウェブ化するプロジェクトに着手した。

Java の連中は、頭のなかでサーバーが踊ることを夢見ていたので、リッチな3層構造 「アー キテクチャ」を採用した。 それぞれのサーバーは、GUI のサーバー、ミドルウェアのサーバー、 データベースのサーバーとなった。 当たり前だ。

非常に早い段階で、すべてのドメインオブジェクトを3つのインスタンスに分けることを決 定したのだ。 その3つとは、 GUI層、 ミドルウェア層、 データベース層である。 インスタンス は異なるマシンに存在していたので、プロセッサ間通信と層間通信のあるリッチなシステムが 構築された。 層間のメソッド呼び出しは、 オブジェクトに変換して、シリアライズして、マー シャルして送信した。

ここで、 既存のレコードに新しいフィールドを追加する簡単な機能を実装することになった としよう。 まずは、3つの層にあるクラスと層間メッセージにフィールドを追加することにな る。データは双方向に送信するので、合計4つのプロトコルを設計する必要がある。 プロトコ ルには送信側と受信側があるため、8つのプロトコルハンドラが必要だ。 まとめると、3つの実 行ファイルをビルドする必要があり、それぞれに3つのビジネスオブジェクトの更新、4つの メッセージの新規作成、8つのハンドラの新規作成が必要になる。

この簡単な機能を実装するために、 実行ファイルが何をしなければいけないかと考えてみよ う。 オブジェクトのインスタンス化、シリアライズ、 マーシャルとアンマーシャル、メッセー ジの構築とバース、ソケット通信、タイムアウトの管理、 再試行のシナリオなどなど、 簡単な 機能ひとつだけでも、さまざまなことに配慮しなければいけない。

このプログラマたちは、開発中は複数台のサーバーを持っていなかった。 1台のマシンに3つ の実行ファイルを入れて、 異なるプロセスで実行していた。 こうして数年かけて開発していっ た。彼らは自分たちのアーキテクチャが正しいと確信していた。 そして、 たとえ1台のマシン

3層構造はアーキテクチャではないため、「アーキテクチャ」と括弧書きにした。 これはトポロジーである。 優れたアー キテクチャを留保するための決定だ。

168

結合の悲しい物語

で実行していたとしても、オブジェクトのインスタンス化、シリアライズ、 マーシャルとアン マーシャル、メッセージの構築とパース、ソケット通信などなど、あらゆることを実行する必 要があった。

皮肉なことに、 P社は複数台のサーバーを必要とするシステムを販売していなかった。 これ までにデプロイしたシステムは、いずれも1台のサーバーだけだった。 本来なら複数台のサー バーで行うはずだったオブジェクトのインスタンス化、シリアライズ、 マーシャルとアンマー シャル メッセージの構築とバース、ソケット通信などを、3つの実行ファイルで、1台のサー バーで続けることになった。

この悲劇は、アーキテクトが早すぎる決定を下したことで、 開発の労力を劇的に増やしてし まったところに原因がある。

P社の物語は特殊なものではない。 私は同じ光景をさまざまな場所で何度も目撃してきた。 実際、 P社の物語は複数の事例を重ねたものだ。

だが、 P社よりも悪い運命が待ち構えている。

会社の車を管理する地元企業 W 社について考えてみよう。 W社は最近 「アーキテクト」を

雇い つぎはぎだらけのソフトウェア開発をコントロールしようとしていた。 「コントロール」 はこの男を表す二つ名だった。 彼はすぐに、 この小さな業務で必要なものに気づいた。 それは、 本格的なエンタープライズ規模のサービス指向 「アーキテクチャ」 だった。 彼は、業務の「オブ 「ジェクト」をすべて表した巨大なドメインモデルを作り、これらのドメインオブジェクトを管理 するサービスを設計し、 開発者全員を地獄へ導いた。 参考までに、担当者の情報 (氏名、住所、 電話番号)を販売レコードに登録する簡単な例を見ていこう。 まずは、 ServiceRegistry から ContactService (担当者サービス)のサービスIDを取得する。 次に、 CreateContact (担当 者作成)メッセージを ContactService に送信しなければいけない。 もちろんこのメッセージ には、有効なデータとなるいくつものフィールドが含まれている。 プログラマは「氏名、住所、 「電話番号」 のデータしか持っていないので、アクセスできないデータも含まれていることにな る。 したがって、プログラマは偽のデータを作り、 新しく作成した担当者のIDを販売レコード に埋め込み、 UpdateContact (担当者更新) メッセージを SaleRecordService に送信する必要 がある。

何かテストを実施しようとすると、 必要なサービスを1つずつ起動して、 メッセージバスを 起動して、BPEL サーバーを起動して...... と、 すべての起動が終わってから、サービス間で何 度もメッセージのやり取りをすることになるので、 伝播の遅延が発生し、いくつものキューを 待つことになった。

また、新しい機能を追加したい場合は、 おそらく想像できるだろうが、 すべてのサービスを 結合し、大量の WSDL を書き換え、 その変更によってすべてを再デプロイする必要があった。 地獄のほうがマシな場所のように思えてくる。

169

第17

章 バウンダリー 境界線を引く

サービスを中心に構成されたソフトウェアシステムは、本質的に間違っているわけではない。 W社の過ちは、 SOA を視野に入れたツールを早く導入しすぎたところにある。 つまり、大量の ドメインオブジェクトのサービスの導入を急ぎすぎたのだ。 この過ちによって、 多くの人間の 時間が SOA の渦に飲み込まれてしまった。

そのほかにもアーキテクチャの失敗話を語ることはできる。 だが、それよりもアーキテクチャ の成功話をしていこう。

FitNesse

私と息子のMicah は、 2001年から FitNesse に取り組んでいる。 Ward Cunningham が作っ た FIT ツールをシンプルな wikiでラップして、受け入れテストを書けるようにするというア イデアだ。

Maven が jar ファイルの問題を 「解決」 する前の話だ。 当時、 我々が開発するものについて は、複数の jar ファイルをダウンロードさせるものであってはならないと強く主張していた。 こ のルールを「ダウンロード・アンド・ゴー」 と呼んでいた。 このルールによって、 多くの決定 がなされていた。

最初の決定は、 FitNesse のニーズに固有のものとして、独自のウェブサーバーを作ること だった。 独自のものを作るなんて、 ばかばかしいと思うかもしれない。 2001年当時ですら、 我々 が使用できるオープンソースのウェブサーバーは大量に存在していた。 だが、自分たちで作っ てみると、それが本当によい決定だったことに気づいた。 素のウェブサーバーはシンプルに書 けたし、ウェブフレームワークの決定をずっと先まで遅らせることができたからだ。

もうひとつの初期の決定は、データベースについて考えるのを避けたことである。 MySQL を 使おうとは考えていたが、その決定を遅らせる設計を採用することにした。 その設計とは、す べてのデータアクセスとデータリポジトリの間にインターフェイスを置くというものだった。

データアクセスのメソッドはWikiPage という名前のインターフェイスに配置した。 ページ の検索・取得・保存など、 必要な機能をすべて提供するようにした。 もちろん最初からこれら のメソッドを実装したわけではない。 最初のうちはデータの取得や保存を伴わない機能を実装 しながら、 データアクセスについてはしばらく考えないようにしていた。

実際、 3か月間はwikiのテキストをHTML に変換するだけだった。 データストレージは必 要なかったので、 MockWikiPage というクラスを作った。単にデータアクセスメソッドをスタプ 化したものだ。

最終的にこれらのスタブは、 我々が作りたい機能を実現するのに不十分な

2 長い年月を経てからでも、 Velocity フレームワークを FitNesseに導入することができた。

ものとなった。 スタプ

170

FitNesse

ではなく、本物のデータアクセスが必要になった。 そこで、 WikiPage から派生した InMemoryPage という新しいクラスを作った。 このクラスには、wikiページのハッシュテーブルを管理する データアクセスメソッドを実装した。 データは RAM に保存した。

これにより、 1年間は次々と機能を実装することができた。 実際、 Fit Nesse の最初のバー ジョンはこのように動いていた。 ページの作成、ほかのページへのリンク、 ステキな wiki 記 法、 FIT によるテストの実行までできていた。 できなかったのは、それまでの作業を保存する ことだった。

永続化の実装を考える時期になったとき、 再び MySQL のことが頭に思い浮かんだ。だが、 すぐには必要ないと判断した。 ハッシュテーブルをファイルに書き出すのは非常に簡単だから だ。したがって、ファイルに書き出すための FileSystemWikiPage を実装し、引き続き機能を 開発していった。

3か月後、ファイルを使うソリューションで十分だという結論に達した。 MySQL を使うアイ デアは完全に放棄することにした。 我々は存在価値がなくなるまで決定を遅らせ、決して振り 返ることはなかった。

これで物語は終わりのはずだった。 だが、 自分のために wiki を MySQL に入れると決めた顧 客がいた。 我々は、 決定を遅らせることを可能にした WikiPages のアーキテクチャを彼に見せ た。すると翌日、彼は MySQL で動くシステムを持って戻ってきた。 MySqlWikiPage を書くだ けで、動かすことができたのである。

当初はオプションとして FitNesse にもバンドルしていたが、誰も使わなかったので、 最終 的には外すことにした。 それを書いた顧客も、 結局は外していたくらいだ。

FitNesse の開発初期に、 我々はビジネスルールとデータベースの間に境界線を引いた。 その 境界線があることで、ビジネスルールはデータベースについて (シンプルなデータアクセスメ ソッド以外) 何も知ることはなかった。 その決定によって、 データベースの選択を1年以上も 遅らせることができた。 ファイルシステムの選択肢を試すことができ、 よりよいソリューショ ンが見つかったときに方向性を変えることができた。 それでいて、 当初の方向性 (MySQL)を 必要とする人がいたときは、 それを妨げたり、 邪魔をしたりすることもなかった。

データベースを使わずに18か月間も開発していたということは、 スキーマの問題、 クエリの 問題、データベースサーバーの問題、 パスワードの問題、 接続時間の問題など、 データベース を起動したときに醜い頭部を持ち上げてくるあらゆる厄介な問題に、18か月間も遭遇しなかっ たということだ。 また、 テストを遅くするデータベースがないので、 すべてのテストを高速に 実行することができた。

要するに、境界線を引けば、 決定を延期・留保できる。 最終的には、膨大な時間と頭痛を軽 減することにもつながる。 そして、 それが優れたアーキテクトのやるべきことである。

171

章 バウンダリー 境界線を引く

第17

あなたの境界線は何か?

いつ境界線を引くのか?

境界線は「重要なもの」 と 「重要ではないもの」の間に引く。 GUIはビジネスルールにとって 重要ではないので、その間に境界線を引く。 データベースはGUIにとって重要ではないので、 その間に境界線を引く。 データベースはビジネスルールにとって重要ではないので、その間に 境界線を引く。

このことに異議を唱える人もいるだろう。 特に「データベースはビジネスルールにとって重 「要ではない」の部分だ。 多くの人たちが「データベースはビジネスルールと密接に結び付いて 「いる」と教え込まれてきた。 なかには「データベースはビジネスルールを具体化したものであ る」と信じている人もいるくらいだ。

ほかの章でも触れているが、この考えは間違っている。 データベースはビジネスルールが間 接的に使用できるツールである。 ビジネスルールは、 スキーマ、 クエリ言語、 データベースに 関するそのほかの詳細について、 何も知る必要はない。 ビジネスルールが知る必要があるのは、 データを取得・保存する機能が存在するということだけだ。 したがって、 データベースはイン ターフェイスの裏側に置くことができる。

図17-1 を見れば、そのことがよくわかる。 BusinessRules は、 Database Interface を使用 してデータを取得・保存する。 DatabaseAccess は、このインターフェイスを実装し、 実際の Database を操作する。

Business Rules Database Interface Database Access Database

図17-1 インターフェイスの裏側にあるデータベース

172

あなたの境界線は何か? いつ境界線を引くのか?

この図で示したクラスとインターフェイスは象徴的なものである。 実際のアプリケーション には、ビジネスルールのクラス、データベースのインターフェイス、データベースアクセスの

実装が数多く存在する。 だが、 そのすべてが、ほぼ同じパターンに従っている。 境界線はどこにあるだろうか? 継承関係のところだ。 Database Interface の下にある(図 17-2)

Business Rules Database Interface Database Access 図 17-2 境界線 Database

DatabaseAccessクラスから出ている2つの矢印に注目してほしい。 DatabaseAccessクラス から出ているということは、 DatabaseAccess クラスの存在は誰にも知られていないというこ とだ。

一歩引いて考えてみよう。 多くのビジネスルールを含んだコンポーネントと、データベース とアクセスクラスを含んだコンポーネントがあるとする (図17-3)。

矢印の方向に注目してほしい。 Database は BusinessRules のことを知っている。 Business Rules は Database のことを知らない。 つまり、 Database Interface は BusinessRules コンポー ネントに存在し、 DatabaseAccess は Database コンポーネントに存在することを意味する。

の方向が重要である。 これは、 Database は BusinessRules にとって重要ではないが、 Database は BusinessRules なしでは存在できないことを示している。

不可解に思えたなら、以下のことを思い出してほしい。 Database コンポーネントには、 BusinessRules からの呼び出しをデータベースのクエリ言語に変換するコードが含まれている。 BusinessRules のことを知っているのは、 その変換コードである。

この2つのコンポーネントの間に境界線を引き、 矢印を BusinessRules に向けたことで、

173

章 バウンダリー 境界線を引く

第 17

Business Rules Database

図 17-3 ビジネスルールのコンポーネントとデータベースのコンポーネント

BusinessRules からあらゆる種類のデータベースを使えることがわかる。 Database コンポー ネントは、さまざまな実装に置き換えることが可能である。 そして、 BusinessRules がそのこ とを気にすることはない。

データベースは、Oracle、 MySQL、 CouchDB、 Datomic、 ファイルでも実装できる。 ビジネ スルールが気にすることはない。 つまり、 データベースの決定を遅らせることができるのだ。 データベースを決める前に、ビジネスルールの作成とテストに集中できる。

入力と出力はどうする?

開発者と顧客は、システムについて見誤ることが多い。 GUI を見て、 GUI がシステムだと思っ ている。 GUIの観点からシステムを定義しているので、 GUI はすぐに動作しなければいけない

ものだと思っている。 重要な原則を認識していないのだ。 その原則とは 「IOは無関係」である。 最初は理解しにくいかもしれない。 我々はシステムの振る舞いを IOの振る舞いから考えて しまう。 たとえば、ビデオゲームを考えてみよう。 あなたの体験は、 インターフェイス (画面、 マウス、ボタン、サウンドなど) に支配されている。 そして、 インターフェイスの背後には、そ れを動かすモデル(洗練されたデータ構造と機能) があることを忘れてしまう。さらに重要な のは、そうしたモデルにはインターフェイスは必要ないということだ。 画面にゲームを表示し なくても、ゲームのイベントをモデリングして、その責務を実行できる。 インターフェイスは モデルにとって重要ではない。 そして、 モデルはビジネスルールである。

前回と同じように、 GUIコンポーネントと BusinessRules コンポーネントを境界線で分けて みよう (図17-4)。 同様に、 関連性の低いコンポーネントが、 関連性の高いコンポーネントに 依存していることがわかる。 矢印はどちらのコンポーネントがもう一方を知っているかを示し

174

プラグインアーキテクチャ

ている。 つまり、 どちらのコンポーネントがもう一方を気にかけているかを示している。ここ では、 GUI が BusinessRules を気にかけていることになる。

Business Rules GUI

図 17-4 GUI コンポーネントと BusinessRules コンポーネントの境界

境界と矢印を描くと、 GUIは他の種類のインターフェイスに置き換え可能であることがわか る。 BusinessRules が気にすることはない。

プラグインアーキテクチャ

データベースとGUI の2つの決定をまとめると、他のコンポーネントを追加するパターンが 生まれる。 そのパターンとは、サードパーティのプラグインを許可するシステムで使用されて いるパターンである。

実際、ソフトウェア開発技術の歴史は、いかに都合よくプラグインを作成するかの物語だ。 プラグインによって、 スケーラブルで保守可能なシステムアーキテクチャを確立するのである。 コアとなるビジネスルールは、選択式またはそのほかの形式で実装されたコンポーネントから 分離・独立している (図 17-5)。

この設計にすれば、ユーザーインターフェイスはプラグインとなるため、 さまざまな種類の ユーザーインターフェイスをプラグインできる。 ウェブ、 クライアント/サーバー、 SOA、 コン ソールなど、 そのほかの種類のユーザーインターフェイス技術も使うことができるようになる。 データベースも同様だ。 プラグインとして扱えば、 SQL データベース、 NoSQL データベー ス, ファイルシステムベースのデータベースなど、さまざまな種類のデータベース技術に置き えることが可能だ。

こうした置き換えは普通ではないかもしれない。 ウェブベースとして開発したシステムに対

175

第17章

バウンダリー 境界線を引く DB Business Rules GUI 図17-5 ビジネスルールにプラグイン

して、クライアント/サーバー型のUIのプラグインを書くのは難しいだろう。 ビジネスルール と新しいUIのやり取りにも修正が必要になる可能性が高い。 それでも、プラグイン構造を前提 にして着手しておけば、そのような変更でもなんとか実現できるのである。

プラグインの戦い

ReSharper と Visual Studio の関係を考えてみよう。 これら2つのコンポーネントは、完全 に異なる企業の完全に異なる開発チームによって開発されている。 ReSharper を開発している JetBrains 社はロシアを拠点にしている。 Microsoft社は (もちろん) ワシントン州のレドモン ドだ。これよりも離れた開発チームを想定するのは難しいくらいである。

どちらのチームが相手を傷つけることができるだろうか? どちらのチームが相手に影響 されないだろうか? 依存関係の構造を見ればそれがわかる (図17-6) ReSharper のソース コードは、Visual Studio のソースコードに依存している。 したがって、 ReSharper チームが Visual Studio チームを妨害することはできない。 一方、 Visual Studio チームが望むならば、 ReSharper チームを完全に無力化できる。

とても非対称的な関係だが、我々がシステムに求めるものでもある。 ほかのモジュールから 影響されないモジュールが必要だ。 たとえば、誰かがウェブページのフォーマットやデータベー スのスキーマを変更したときに、 ビジネスルールが壊れるようなことはあってほしくない。 シ ステムのある部分を変更したことで、ほかの関係ない部分が壊れるようなことはあってほしく ない。 システムにそのような脆弱性を露呈してほしくはない。

176

まとめ

VS ReSharper

図 17-6 ReSharper は Visual Studio に依存している

システムをプラグインアーキテクチャにしておくと、 変更の影響を伝播させないファイア ウォールを構築できる。 GUI をビジネスルールにプラグインしている場合、 GUI の変更はビジ ネスルールに影響を与えない。

境界線は変更の軸があるところに引く。 境界線を挟んだコンポーネントは、それぞれ変更の 頻度や理由が違っているのである。

GUI はビジネスルールと異なる時間や頻度で変更される。 したがって、 その間に境界線を引 く。ビジネスルールはDIフレームワークと異なる時間や理由で変更される。 したがって、その 間に境界線を引く。

これも単一責任の原則 (SRP) である。 単一責任の原則 (SRP) はどこに境界線を引けばい いかを教えてくれる。

まとめ

ソフトウェアアーキテクチャに境界線を引くためには、まずはシステムをコンポーネントに 分割する。そのなかのいくつかのコンポーネントがコアのビジネスルールになる。 必要な機能 が含まれているそのほかのコンポーネントは、コアのビジネスには直接関係しないので、プラ グインにしておく。 次に、 コンポーネントにコードを配置して、そこから一方向にコアのビジ ネスに向かって矢印を描く。

これは、依存関係逆転の原則 (DIP) と安定度 抽象度等価の原則 (SAP) を適用したもの であると認識すべきだ。 依存性の矢印が詳細レベルから抽象レベルを指すようになっている。

177



境界の解剖学 第18回

DONALD WAS HERE YOURGE

VERA?

KOANKE

システムのアーキテクチャは、ソフトウェアコンポーネントとそれらを分離する境界によっ て定義される。 こうした境界にはいくつもの形がある。 本章では、一般的なものをいくつか見 ていこう。

境界を越える

実行時に境界を越えるものがあるとすれば、境界の向こう側にある関数の呼び出しとデータ 受け渡しになるだろう。 適切に境界を越えるには、ソースコードの依存関係を管理する必要 がある。

なぜソースコードなのか? それは、あるソースコードのモジュールを変更すると、ほかの ソースコードのモジュールも変更や再コンパイルをするなどして、デプロイし直す必要がある かもしれないからだ。 こうした変更に対してファイアウォールを管理・構築することが、 境界 の意味するところである。

179

第18章 境界の解剖学

恐怖のモノリス

最も単純で最も一般的なアーキテクチャの境界は、物理的に表現されているわけではない。 単一のプロセッサとアドレス空間のなかで、 機能とデータをうまく区分しているだけだ。 第16 章では、これを「ソースレベルの切り離し方式」 と呼んだ。

デプロイの観点からすると、これは単一の実行ファイルにすぎない。 いわゆる「モノリス」で ある。たとえば、静的にリンクされた C/C++のプロジェクト、 実行可能なjar ファイルにまと められた Java クラスファイル、 .EXE ファイルにまとめられた.NET バイナリなどがそうだ。

モノリスをデプロイするときに境界が見えないからといって、 境界が存在していないとか、 意味がないというわけではない。 静的にリンクしてひとつの実行ファイルにする場合でも、コ ンポーネントを個別に開発してから組み立てることには、 非常に大きな価値がある。

ほとんどの場合、このようなアーキテクチャは内部の依存性を管理するために、 何らかの動 的ポリモーフィズムに依存している。 このことは、 過去数十年でオブジェクト指向開発が重要 なパラダイムになった理由のひとつでもある。 オブジェクト指向やポリモーフィズムに相当す るものがなければ、アーキテクトは切り離しを実現するために、 関数へのポインタを使用する といった危険なプラクティスに頼ることになる。 だが、アーキテクトは関数へのポインタはリ スクが高すぎると思っているため、 コンポーネントの分割を放棄せざるを得ない。

可能な限りシンプルに境界を越えるには、下位レベルのクライアントから上位レベルのサー ビスに対して、 関数呼び出しをすることである。 実行時の依存性とコンパイル時の依存性の両 方で、 同じ方向 (上位レベルのコンポーネントの方向)に向かうのである。

図18-1では、制御の流れが境界を左から右に横切っている。 ここでは、 Client が Service の 関数f() を呼び出している。 そして、このときに Data のインスタンスを渡している。 DS はデー タ構造 (Data Structure) のことだ。 Data は関数の引数として渡すこともあれば、もっと巧妙 な方法で渡すこともある。 なお、 Data の定義は境界の呼び出される側にあることに注意してほ しい。

上位レベルのクライアントが下位レベルのサービスを呼び出す必要がある場合、動的ポリモー フィズムを使用して、制御の流れの依存性を逆転させる。 実行時の依存性をコンパイル時の依 存性の反対にするのである。

C++などの言語で記述されたモノリシックシステムの依存性管理には、静的ポリモーフィズム (ジェネリックやテンプ レートなど)も使える。だが、動的ポリモーフィズムのように、再コンパイルや再デプロイが不要になることはない。

180

恐怖のモノリス

Client Service +f Data <DS>

図18-1 制御の流れは下位レベルから上位レベルに向かって境界を越える

図18-2 でも、制御の流れが境界を左から右に横切っている。 ここでは、 上位レベルの Client が、下位レベルの ServiceImpl の関数 f() を Service インターフェイス経由で呼び出してい る。だが、 依存性が境界の右から左へ、 上位レベルのコンポーネントに向かっている。 データ 構造の定義が境界の呼び出し側にあることにも注意してほしい。

Client <DS> Data Service Service Impl +f +f

図 18-2 制御の流れに反して境界を越えている

モノリシックで静的にリンクされた実行ファイルであっても、 このようにうまく分割してお けば、プロジェクトの開発テストデプロイの作業で役に立つ。チームはお互いに足を引っ 張ることなく、個別に自分たちのコンポーネントに取り組むことができる。 上位レベルのコン ポーネントは、引き続き下位レベルの詳細から独立しているのである。

モノリスに含まれるコンポーネント間の通信は、非常に高速で安価である。 通常は単なる関 数呼び出しだからだ。 その結果、ソースレベルの境界を越える通信はにぎやかなものとなる。 モノリスのデプロイにはコンパイルと静的リンクが必要になるため、システムのコンポーネ ントは、通常はソースコードとしてデリバリーされる。

181

第18章 境界の解剖学

デプロイコンポーネント

アーキテクチャの境界の最も単純な物理的表現は、 動的リンクライブラリである。 たとえ ば、 NET の DLL、Java の jar ファイル、 Ruby の Gem、 UNIX の共有ライブラリなどがそう だ。 デプロイにコンパイルは不要なので、これらのコンポーネントはバイナリやデプロイ可能 な形式でデリバリーされる。 これは 「デプロイレベルの切り離し方式」 である。 デプロイでは、 こうしたデプロイ可能な単位を WAR ファイルのような便利な形式や、 単なるディレクトリに まとめることになる。

上記の点を除けば、デプロイレベルのコンポーネントはモノリスと同じである。 ほとんどの 場合、すべての機能は同一のプロセッサとアドレス空間に存在している。 コンポーネントの分 割と依存性の管理の戦略も同じである。

モノリスと同様に、デプロイコンポーネント間の通信も単なる関数呼び出しなので、 非常に 安価である。 最初に動的リンクや実行時読み込みが必要になるが、 それでも境界を越える通信 はにぎやかだ。

スレッド

モノリスとデプロイコンポーネントの両方でスレッドを使用できる。 スレッドはアーキテク チャの境界やデプロイ単位というよりも、実行のスケジュールや順序を整理する方法である。 スレッドはひとつのコンポーネントに含めることもできるし、複数のコンポーネントに分散さ せることもできる。

ローカルプロセス

もっと強力な物理的なアーキテクチャの境界として、 ローカルプロセスがある。 ローカルプ ロセスは、通常はコマンドラインや同等のシステムコールで作成される。 そして、 同じプロセッ サまたはマルチコアの同じプロセッサセットで実行される。 なお、 アドレス空間は別々である。 共有メモリ分割も使用されているが、 メモリ保護によってプロセスがメモリを共有しないよう になっている。

ローカルプロセス間の通信は、ソケットか、 メールボックスやメッセージキューなどのOS

2 この場合、静的ポリモーフィズムは選択肢に入らない。

182

サービス

が提供している通信機能を使って行われる。

ローカルプロセスは、 静的にリンクされたモノリスであっても、動的にリンクされたデプロ コンポーネントであっても構わない。 前者の場合、 複数のモノリシックプロセスがコンパイ ルや静的にリンクされた同じコンポーネントを持っていることがある。 後者の場合、 動的にリ ンクされた同じデプロイコンポーネントを共有していることがある。

ローカルプロセスは 「上位コンポーネント」の一種だと考えるといいだろう。 こうしたプロ セスは、動的ポリモーフィズムで依存性を管理する下位レベルのコンポーネントで構成されて いる。

ローカルプロセスの分離戦略は、モノリスやバイナリコンポーネントと同じである。ソース コードの依存性は、 境界を越えて同じ方向を目指し、 常に上位のコンポーネントへ向かう。 ローカルプロセスの場合、 上位レベルのプロセスのソースコードのなかに、下位レベルのプ

ロセスの名前・物理アドレスレジストリ参照キーなどが含まれていないことを意味する。 忘 れないでほしいのだが、 アーキテクチャの目標は、下位レベルのプロセスを上位レベルのプロ セスのプラグインにすることである。

ローカルプロセスの境界を越える通信には、 OS のシステムコール、データのマーシャルとア ンマーシャル、プロセス間のコンテキストスイッチがあるが、いずれもそれなりに高価なもの である。 あまりにぎやかにならないように注意したほうがいいだろう。

サービス

最も強い境界はサービスである。 サービスとは、一般的にコマンドラインや同等のシステム コールで開始されるプロセスのことである。 サービスは、物理的な場所に依存していない。 通 信している2つのサービスは、同じプロセッサやマルチコアに存在することもあれば、 存在し ないこともある。 あらゆる通信はネットワーク経由で行われることが前提だ。

サービスの境界を超える通信は、 関数呼び出しと比べると非常に遅い。 ターンアラウンドタ イムは、数十ミリ秒から数秒になる。 通信がにぎやかにならないように注意する必要がある。 このような通信においては、レイテンシーに対処することになるだろう。

上記の点を除けば、サービスにはローカルプロセスと同じルールが適用できる。 下位レベル のサービスは上位レベルのサービスに「プラグイン」されるべきである。 上位レベルのサービ スのソースコードには、下位レベルのサービスの物理的な情報 (たとえば、 URI など) を含め てはいけない。

183

第 18 章 境界の解剖学

まとめ

モノリス以外のほとんどのシステムでは、複数の境界戦略を使用する。 サービスの境界を利 用するシステムが、ローカルプロセスの境界を同時に利用することもある。 実際、サービスは 相互作用する複数のローカルプロセスのファサードにすぎない。 また、サービスやローカルプ ロセスはほぼ確実に、ソースコードのコンポーネントで構成されたモノリスか、 動的にリンク されたデプロイコンポーネントのいずれかである。

つまり、システムの境界は、 ローカルでにぎやかな境界とレイテンシーに影響される境界が 混在しているのである。

184

方針とレベル 齢 19歳 章

KANKE

ソフトウェアシステムは方針を示したものである。 システムの中心にあるコンピュータプロ グラムがまさにそれだ。 コンピュータプログラムは、入力を出力に変換する方針を詳細に記述 したものである。

ほとんどのシステムでは、 方針はさらに小さな方針に分割される。 方針のなかには、 ビジネ スルールの算出方法について記述しているものもあれば、 レボートのフォーマット方法につい て記述しているものもあれば、 入力データの検証方法について記述しているものもある。

ソフトウェアアーキテクチャの開発の技芸は、こうした方針を慎重に分離し、 変更方法にも

とづいて再編成するところにも見られる。 同じ理由や時期に変更する方針は、同じレベルの同 コンポーネントにまとめておき、 異なる理由や時期に変更する方針は、異なるレベルの異な るコンポーネントに分けておくのである。

アーキテクチャの技芸では、 まとめたコンポーネントを有向非循環グラフにすることがよく ある。 グラフのノードは、 同じレベルの方針を持つコンポーネントである。 有向エッジは、コ ンポーネントの依存性を示している。 そうすることで、異なるレベルのコンポーネントを接続 しているのである。

185

第19章 方針とレベル

こうした依存性は、ソースコードのコンパイル時の依存性である。 Java では、 import にな る。C#では、using になる。 Ruby では、 require になる。 いずれもコンパイラに必要な依存 性だ。

優れたアーキテクチャでは、こうした依存性の方向は接続するコンポーネントのレベルで決 まる。 どのような場合でも、 下位レベルのコンポーネントが上位レベルのコンポーネントに依 存するように設計する。

レベル

「レベル」 の厳密な定義は 「入力と出力からの距離」 である。 方針がシステムの入力と出力か ら離れていれば、それだけレベルは高くなる。 入力と出力を管理する方針は、システムのなか で最下位レベルの方針になる。

図19-1のデータフロー図は、単純な暗号化プログラムを表している。 入力デバイスから文 字を読み取り、テーブルを使って変換したあと、 出力デバイスに文字を書き出すというものだ。 データフローは、実線で描かれた曲線の矢印で示している。 適切に設計されたソースコードの 依存性は、 破線で描かれた直線の矢印で示している。

文字の読み取り 変換 文字 ソースコード 依存性 文字の書き出し 図19-1 単純な暗号化プログラム テーブル

入力と出力から最も離れたコンポーネントは Translate (変換) なので、これがシステムの 最上位のコンポーネントということになる。

データフローとソースコードの依存性は、 必ずしも同じ方向を指しているとは限らない。 こ

1 Meilir Page-Jones は、 このコンポーネントを著書 「構造化システム設計への実践的ガイド」 (近代科学社) で 「中央変換」 と呼んでいた。

186

レベル

れもまたソフトウェアアーキテクチャの技芸のひとつである。 ソースコードの依存性はデータ フローから切り離し、 レベルと結び付けるべきである。

以下のように暗号化プログラムを書けば、 間違ったアーキテクチャを簡単に作成できるだ ろう。

function encrypt() { while (true) writeChar (translate (readChar()));

この間違ったアーキテクチャでは、 上位レベルの encrypt (暗号化)が下位レベルの readChar (文字の読み取り) と writeChar (文字の書き出し) に依存している。

優れたアーキテクチャであれば、 図19-2のクラス図のようになる。 点線で囲んだ Encrypt クラスと CharWriter と CharReader のインターフェイスに注目してほしい。 この線を横切る 依存性は、すべて内側へ向かっている。 つまり、 これがシステムの上位レベルの要素である。

Encrypt Char Reader Char Writer Console Reader Console Writer

図19-2 システムの優れたアーキテクチャを示すクラス図

ConsoleReader と ConsoleWriter はクラスになっている。 入力と出力に近いので、いずれも 下位レベルである。

この構造が、どのように上位レベルの暗号化の方針と下位レベルの入出力の方針を切り離し ているかに注目してほしい。 これにより、広範囲のコンテキストで暗号化方針を使用できるよ うになる。 入出力の方針が変更されたとしても、暗号化の方針に影響を与える可能性は低い。 方針は変更方法にもとづいてコンポーネントにグループ化されている。そのことを思い出し

187

第19章 方針とレベル

てほしい。 同じ理由や時間で変更される方針は、単一責任の原則 (SRP) と閉鎖性共通の原則 (CCP)でグループ化される。 上位レベルの方針 (入出力から遠い方針) は、下位レベルの方針 よりも変更の頻度が低く、 変更の理由が重要である。 下位レベルの方針 (入出力に近い方針) は、変更の頻度が高く、 緊急性は高いものの、変更の理由はさほど重要ではない。

たとえば、上記の暗号化プログラムの簡単な例であっても、暗号化アルゴリズムの変更より もIO デバイスの変更のほうが、可能性としては高いはずだ。 また、暗号化アルゴリズムを変更 する理由は、IO デバイスを変更する理由よりも重要になるだろう。

これらの方針を別々にして、ソースコードの依存性を上位レベルの方針に向けておけば、変 更が及ぼす影響は軽減できる。システムの下位レベルに重要ではないが緊急の変更があったと しても、重要な上位レベルにほとんど、あるいはまったく影響を与えることがない。

この問題のもうひとつの見方として、下位レベルのコンポーネントを上位レベルのコンボー ネントのプラグインにするというものがある。 図19-3のコンポーネント図は、 このような 配置を示している。ここでは、 Encryption は IODevices について何も知らず、IODevices は Encryption に依存している。

Encryption IO Devices

図19-3 下位レベルのコンポーネントを上位レベルのコンポーネントにプラグインする

まとめ

方針の議論には、単一責任の原則 (SRP)、オープン・クローズドの原則 (OCP) 閉鎖性共 通の原則 (CCP) 依存関係逆転の原則 (DIP)、 安定依存の原則 (SDP)、 安定度 抽象度等価 の原則 (SAP)が混在している。 本章を読み返し、それぞれの原則がどこで使われているのか、 どうして使われているのかを確認してもらいたい。

188

ビジネスルール 20

アプリケーションをビジネスルールとプラグインに分割する場合、 実際のビジネスルールが どのようなものかを把握しておいたほうがいいだろう。 ビジネスルールにはいくつかの種類が あることがわかる。

ビジネスルールとは、ビジネスマネーを生み出したり節約したりするルールや手続きのこと だ。 厳密に言えば、コンピュータで実装されているかどうかにかかわらず、ビジネスマネーを 生み出したり節約したりするルールのことだ。 手動で実行されたとしても、 お金を生み出した り節約したりすることはできる。

たとえば、銀行がローンに N%の利子を付けているとすると、 それは銀行のお金を生むための ビジネスルールになる。 利子をコンピュータで計算しようと、 そろばんで計算しようと、まっ たく関係はない。

こうしたルールのことを最重要ビジネスルールと呼ぶ。 ビジネスにとって欠かせないもので あり、システムが自動化されていなくても存在するからだ。

最重要ビジネスルールには、いくつかのデータが必要になる。 たとえば、ローンであれば、 貸 金残高、金利、支払いスケジュールなどが必要になる。

189

第20章 ビジネスルール

こうしたデータのことを最重要ビジネスデータと呼ぶ。 システムが自動化されていなくても 存在するデータだからだ。

最重要ビジネスルールと最重要ビジネスデータは密接に結び付いているため、オブジェクト の有力な候補になる。 こうしたオブジェクトのことをエンティティと呼びたい!。

エンティティ

エンティティとは、コンピュータシステムの内部にあるオブジェクトであり、最重要ビジネス データを操作する最重要ビジネスルールをいくつか含んだものである。 エンティティオブジェ クトには、最重要ビジネスデータかそれらのデータへの簡単なアクセス手段が含まれる。 エン ティティのインターフェイスは、そうしたデータを操作する最重要ビジネスルールを実装した 関数で構成されている。

たとえば、 図20-1はローンのエンティティをUMLのクラス図で表したものだ。 最重要ビジ ネスデータが3つと、それに関連するインターフェイスである最重要ビジネスルールが3つ見 える。

|- principle |-rate Loan |-period | + makePayment() applyinterest() + chargeLateFee()

図20-1 ローンエンティティをUMLのクラス図で表したもの

こうしたクラスを作成するときは、ビジネスにとって不可欠な概念を実装するソフトウェア をまとめ、 これから構築するシステムから切り離すようにする。 つまり、ビジネスを表すもの として、エンティティのクラスを独立させるのである。 エンティティは、データベース、ユー ザーインターフェイス、サードパーティ製のフレームワークについて、 何も気にする必要はな い。 システムがどのようなものであっても、データがどのように保存されていても、コンピュー

' これは Ivar Jacobson が名付けた概念である。 参考:「オブジェクト指向ソフトウェア工学 OOSE」 (アジソン ウェスレイ・ トッパン情報科学シリーズ)。

190

ユースケース

タがどのように配置されていても、 エンティティはあらゆるシステムのビジネスに役立つ。エ ンティティはビジネスであり、 それ以外の何者でもない。

私が 「クラス」と呼んだことを心配している人がいるかもしれないが、心配は無用だ。 エン ティティを作成するのにオブジェクト指向言語は不要である。 最重要ビジネスデータと最重要 ビジネスルールを同じソフトウェアモジュールにまとめるだけでいい。

ユースケース

ビジネスルールはエンティティほど純粋なものばかりではない。 自動化されたシステムを定 義制限することによって、 ビジネスのお金を生み出したり節約したりするビジネスルールも ある。こうしたルールは手動の環境では使用されない。 自動化されたシステムの一部としての み意味があるからだ。

たとえば、銀行員が新規ローンを作成するために使用するアプリケーションを想像してほし い。 銀行は、ローン担当者が連絡先を収集 検証してから、候補者の与信スコアが500 以上あ ることを確認するまで、ローンの支払い見積りを提示しないと決めているとしよう。 その場合、 連絡先情報画面がすべて入力され、値がきちんと検証され、 与信スコアが基準値を超えている ことが確認できるまでは、 支払い見積りの画面に進まないようにシステムを設定するだろう。

これは、ユースケースと呼ばれるものだ。 ユースケースとは、 自動化されたシステムを使用 する方法を記述したものである。 ユーザーから提供された入力、ユーザーに戻す出力、 出力を 生成する処理ステップなどを規定している。 エンティティに含まれる最重要ビジネスルールと は違い、ユースケースはアプリケーション固有のビジネスルールを記述している。

図20-2にユースケースの例を示した。 最後の行で 「顧客」に言及していることに注目して ほしい。 これは 「顧客」 エンティティへの参照である。 そこには、 銀行と顧客の関係を支配す る最重要ビジネスルールが含まれている。

ユースケースには、エンティティの最重要ビジネスルールをいつどのように呼び出すかを規 定したルールが含まれている。 ユースケースはエンティティのダンスを制御しているのである。 ユースケースは、ユーザーインターフェイスについては記述していない。 インターフェイスか らやってくるデータとそこから出ていくデータを略式で規定しているだけである。 ユースケー スを見ただけでは、そのアプリケーションがウェブなのか、シッククライアントなのか、コン ソールなのか、純粋なサービスなのかを判断することは不可能である。

このことは非常に重要である。 ユースケースはシステムのユーザーに対する見た目を記述す

これも Ivar Jacobson が名付けた概念である。

191

第20章

ビジネスルール

新規ローンのために連絡先情報を収集する 入力: 氏名、住所、生年月日、 運転免許証番号など 出力: 入力と同じもの+ 与信スコア 通常コース: 1.氏名を受け取り、検証する。 2. 住所、生年月日、運転免許証番号などを検証する。 3. 与信スコアを取得する。 4. 与信スコアが500未満ならば、 「否認」にする。 5. それ以外ならば、 「顧客」 を作成して「ローンの支払い 見積り」を起動する。

図20-2 ユースケースの例

るものではない。ユーザーとエンティティのインタラクションを支配するアプリケーション固 有のルールを記述したものである。 データがどのようにシステムに入出力されるかは、ユース ケースとは無関係だ。

ユースケースはオブジェクトである。 アプリケーション固有のビジネスルールを実装した関 数を1つ以上持っている。 また、 入力データ、 出力データ、 それらがやり取りする適切なエン ティティへの参照といった、データ要素を持っている。

エンティティは自身を制御するユースケースのことを知らない。 これは、依存関係逆転の原 則 (DIP) に従ったもうひとつの例だ。 上位レベルのコンセプト (エンティティなど)は、下位 レベルのコンセプト (ユースケースなど) のことを知らない。 その代わり、 下位レベルのユー スケースは、 上位レベルのエンティティのことを知っている。

では、なぜエンティティが上位レベルで、 ユースケースが下位レベルなのだろうか? ユース ケースはアプリケーション固有なので、システムの入力と出力に近い。 エンティティは複数の アプリケーションで使用できるように一般化されているので、 システムの入力と出力から遠く 離れている。 したがって、 ユースケースはエンティティに依存し、 エンティティはユースケー スに依存していないのである。

リクエストとレスポンスのモデル

ユースケースは、入力データを期待し、 出力データを生成する。 ユースケースオブジェクト をうまく作りたければ、ユーザーや他のコンポーネントとのデータの通信方法について触れる べきではない。 ユースケースクラスのコードが HTML や SQLのことを知る必要はない!

192

ユースケースクラスは、入力としてシンプルなリクエストデータ構造を受け取り、 出力と してシンプルなレスポンスデータ構造を戻す。 これらのデータ構造は何にも依存していない。 HttpRequest や HttpResponse といった、 標準的なフレームワークのインターフェイスから派 生したものでもない。 ウェブのことは何も知らないし、他のユーザーインターフェイスに関す ることも把握していない。

依存性がないことは非常に重要である。 リクエストとレスポンスのモデルが独立していなけ れば、それらに依存するユースケースもリクエストとレスポンスのモデルの依存性に間接的に 結び付けられてしまう。

これらのデータ構造にエンティティオブジェクトへの参照を含めたいと思うかもしれない。 エンティティとリクエストとレスポンスのモデルは多くのデータを共有しているので、合理的 な判断だと考えられるのだろう。 だが、この誘惑に負けてはいけない! この2つのオブジェ クトの目的はまったく違う。 まったく違う理由で変化していくのだから、それらをまとめるこ とは、閉鎖性共通の原則 (CCP) と単一責任の原則 (SRP) に違反している。 その結果、 コー ドに多くのトランプデータ3や条件分岐が発生してしまうだろう。

まとめ

ビジネスルールは、ソフトウェアシステムが存在する理由である。 中心的な機能である。 お 金を生み出したり節約したりするコードを保持したものである。いわば、 家宝である。

ビジネスルールはそのままでいなければいけない。 使用するユーザーインターフェイスやデー タベースなど、下位の懸念事項に関わるべきではない。 ビジネスルールを表すコードがシステ ムの心臓部となり、そこにプラグインされるものについては、何も配慮しないことが理想であ る。ビジネスルールはシステムのなかで、最も独立していて、 最も再利用可能なコードでなけ ればいけないのだ。

訳注:ほかの関数に渡すだけのデータのこと。 トランプは「放浪する」という意味

まとめ

193



叫ぶアーキテクチャ 21

建物の設計図を想像してほしい。 建築家が作成したものであり、建築の計画となるものだ。 この計画から何がわかるだろうか?

家族用の一戸建ての計画ならば、 まずは玄関があり、 玄関ホールがあり、 そこからリビング ルームやダイニングルームに続いているだろう。 ダイニングルームの近くには、 少し離れてキッ チンがあるだろう。 キッチンの隣にはダイネットエリア (食事スペース) があり、その隣には ファミリールームもあるだろう。 計画を見れば、 家族用の一戸建てであることがわかるはずだ。 アーキテクチャが 「戸建て」 と叫んでいるのである。

図書館の設計図を見てみよう。 そこには、 正面玄関、受付、読書エリア、 小さな会議室、 図書 館の本をすべて収納できる本棚を置くスペースがあるだろう。 アーキテクチャが「図書館」と 叫んでいるのである。

では、 あなたのアプリケーションのアーキテクチャは何と叫んでいるだろうか? 最上位 レベルのディレクトリ構造と最上位レベルのパッケージのソースファイルは、 「ヘルスケア 「システム」 「会計システム」 「在庫管理システム」と叫んでいるだろうか? それとも 「Rails」 「Spring/Hibernate」「ASP」 と叫んでいるだろうか?

195

第21章 叫ぶアーキテクチャ

アーキテクチャのテーマ

Ivar Jacobson のソフトウェアアーキテクチャに関する独創的な著書 「オブジェクト指向ソ フトウェア工学 OOSE」 に立ち戻ってみよう。 サブタイトルの 「use-case によるアプローチ」 に注目してほしい。 Jacobson は、 ソフトウェアアーキテクチャはシステムのユースケースを支 える構造であると指摘している。 戸建てや図書館の計画が建物のユースケースを叫んでいるよ うに、ソフトウェアアプリケーションのアーキテクチャもアプリケーションのユースケースに ついて叫ぶべきである。

アーキテクチャはフレームワークに関するものではない (そうあるべきではない)。 アーキテ クチャはフレームワークから提供されるものではない。 フレームワークは使用するツールであ り アーキテクチャが従うものではない。 あなたのアーキテクチャがフレームワークにもとづ いているのなら、そのアーキテクチャはユースケースにもとづくことはできない。

アーキテクチャの目的

優れたアーキテクチャはユースケースを中心にしているため、 フレームワーク、ツール、 環 境に依存することなく、ユースケースをサポートする構造を問題なく説明できる。 改めて戸建 ての計画を考えてみよう。 建築家の最大の関心事は、 家がレンガで作られていることではなく、 家が使用可能であることだ。 実際、 建築家は計画がユースケースを満たしていることを確認し たあとで、 施主が外装材 (レンガ、石材、木材) を選択できるように苦心している。

優れたソフトウェアアーキテクチャがあれば、 フレームワーク、データベース、ウェブサー バー、その他の環境の問題やツールの意思決定を延期・ 留保できる。 フレームワークの選択肢 は残されたままだ。 Rails Spring Hibernate Tomcat、 MySQL などについては、プロジェ クトの後半まで決定する必要がない。 また、優れたアーキテクチャであれば、そうした決定の 変更も容易になる。 優れたアーキテクチャは、ユースケースを強調し、 周辺の関心事からユー スケースを切り離すのだ。

だが、ウェブはどうか?

ウェブはアーキテクチャだろうか? システムがウェブ経由で提供されているとしたら、 そ れはシステムのアーキテクチャを決定づけているのだろうか? もちろんそんなことはない!

196

テスト可能なアーキテクチャ

ウェブは提供の仕組み (IO デバイス) であり、 アプリケーションアーキテクチャもウェブの ことをそのように扱うべきである。 アプリケーションがウェブで提供されている事実は詳細で あり、 システム構造を支配するものではない。 実際、アプリケーションをウェブで提供すると いう決定は、 遅延させるべきものである。 システムアーキテクチャは、提供方法を知るべきで はない。必要以上に複雑にしたり、 基本的なアーキテクチャを変更したりすることなく、コン ソールアプリケーション、ウェブアプリケーション、シッククライアントアプリケーション、 さらにはウェブサービスアプリケーションとして、問題なく提供できるようにすべきである。

フレームワークはツールであり、生き方ではない

フレームワークは非常に強力で、 非常に便利なものである。 フレームワークの作者は、フレー ムワークのことを深く信じている。 彼らの書いたフレームワークの使い方は、熱狂的な信者の 観点から物事を伝えている。 フレームワークに関する書籍の著者たちも、熱狂的な信者である ことが多い。 彼らは、フレームワークの使い方を教えてくれるが、 フレームワークがすべてを 包括し、すべてに行き渡り、 すべてのことをフレームワークに任せるという立場を前提として いるようだ。

そんな立場になりたいわけではないだろう。

冷静にフレームワークを見てほしい。 疑いの眼差しで見てみよう。 確かに便利そうだ。 だが、 コストは? どのように使うべきか、 どのように自分自身を守るべきかを自問してほしい。 ユー スケースを重視したアーキテクチャをどのように維持するかを考えてほしい。 フレームワーク アーキテクチャを乗っ取られないように、 戦略をうまく策定しよう。

テスト可能なアーキテクチャ

システムアーキテクチャがユースケースをサポートするものであり、 フレームワークから少し 距離を置いたものになっていれば、 フレームワークを使うことなく、すべてのユースケースのユ ニットテストを実行できるはずだ。 テストを実行するためにウェブサーバーを起動する必要は ない。テストを実行するためにデータベースに接続する必要はない。 エンティティオブジェク トは、フレームワーク、データベース、その他の複雑さに依存しない、 プレインオールドオブ ジェクトでなければいけない。 ユースケースオブジェクトからエンティティオブジェクトを調

197

第21章 叫ぶアーキテクチャ

整しなければいけない。 最後に、 それらをまとめたものは、フレームワークの複雑さがなくて も、そのままの状態でテスト可能でなければいけない。

まとめ

アーキテクチャは、システムで使用しているフレームワークではなく、 システムそのものに ついての情報を伝える必要がある。 たとえば、ヘルスケアシステムを構築しているならば、新 しく参加したプログラマがソースリポジトリを見たときに、 「ああ、これはヘルスケアシステム だ」と思えるようにしておくべきである。 システムの提供方法はまだわからなくても、システ ムのユースケースをすべて把握できるようにしておくべきだ。 そして、 あなたのところへやっ て来て、 こう言うだろう。

「モデルのようなものは見えますが、ビューとコントローラーはどこにありますか?」 あなたはこう答えるだろう。

「それは詳細だから、まだ気にする必要はないよ。 あとから決めよう」

198

クリーンアーキテクチャ 22 KOHNKE

過去数十年にわたり、 我々はシステムのアーキテクチャに関するさまざまなアイデアを見て きた。

●ヘクサゴナルアーキテクチャ : Alistair Cockburn が開発し、 Steve Freeman と Nat Pryce がすばらしい著書 「実践テスト駆動開発」 で採用したもの。 「ポートとアダプター」とも呼 ばれる。

●DCI アーキテクチャ : Jim Coplien と Trygve Reenskaug が開発したもの。 ●BCE: Ivar Jacobson が著書 「オブジェクト指向ソフトウェア工学 OOSE」 で紹介したもの。

これらのアーキテクチャは、 細部に多少の違いはあるものの、 非常によく似ている。 いずれ も「関心事の分離」 という同じ目的を持っている。 そして、 ソフトウェアをレイヤーに分割す ることで、この分離を実現している。 また、 それぞれ少なくとも、ビジネスルールのレイヤー と、ユーザーやシステムとのインターフェイスとなるレイヤーを持っている。 これらのアーキテクチャは、以下の特性を持つシステムを生み出す。

199

第22章 クリーンアーキテクチャ

●フレームワーク非依存: アーキテクチャは、機能満載のソフトウェアのライブラリに依存 していない。 これにより、システムをフレームワークの制約で縛るのではなく、フレーム ワークをツールとして使用できる。

●テスト可能 : ビジネスルールは、 UI、 データベース、ウェブサーバー、 その他の外部要素 がなくてもテストできる。

● UI 非依存 UI は、システムのほかの部分を変更することなく、簡単に変更できる。 たとえ ば、ビジネスルールを変更することなく、 ウェブUI をコンソール UIに置き換えることが できる。

●データベース非依存 Oracle や SQL Server を Mongo、 BigTable、 CouchDB などに置き 換えることができる。 ビジネスルールはデータベースに束縛されていない。 ●外部エージェント非依存: ビジネスルールは、外界のインターフェイスについて何も知ら ない。

図22-1 は、 これらのすべてのアーキテクチャを単一の実行可能なアイデアに統合したもの である。

DB デバイス ゲートウェイ クリーンアーキテクチャ ウェブ コントローラー ユースケース 外真 エンティティ インターフェイス プレゼンター |企業のビジネスルール | アプリケーションのビジネスルール インターフェイスアダプター □ フレームワークとドライバ プレゼンター UI ユースケース 「出力ポート ユースケース インタラクター 制御の流れ コントローラート ユースケース 「入力ポート

図22-1 クリーンアーキテクチャ

200

依存性のルール

依存性のルール

図22-1の同心円は、 ソフトウェアのさまざまな領域を表している。 一般的には、円の中央に 近づくほどソフトウェアのレベルが上がっていく。 円の外側は仕組み。 内側は方針である。 このアーキテクチャを動作させる最も重要なルールは、依存性のルールである。

ソースコードの依存性は、 内側 (上位レベルの方針) だけに向かっていなければいけない。

円の内側は外側について何も知らない。 特に、 外側で宣言された名前は、 内側にあるコード で触れてはいけない。 これには、 関数、 クラス、 変数、 そのほかの名前付きソフトウェアエン ティティが含まれる。

同様に、 外側で宣言されたデータフォーマットは、 内側から使ってはいけない。 外側のフレー ムワークで生成されたフォーマットは特にそうだ。 円の外側にあるものから内側にあるものに 影響を及ぼしたくはない。

|エンティティ

エンティティは、 企業全体の最重要ビジネスルールをカプセル化したものだ。 エンティティ は、メソッドを持ったオブジェクトでも、データ構造と関数でも構わない。 企業にあるさまざ まなアプリケーションから使用できるなら、 エンティティは何であっても問題はない。

企業が存在せず、単一のアプリケーションを作成しているだけなら、 エンティティはアプリ

ケーションのビジネスオブジェクトになるだろう。 それは、最も一般的で、 最上位レベルのルー ルをカプセル化したものである。 外部で何か変化が起きても、それが変化する可能性は低い。 たとえば、ページのナビゲーションやセキュリティを変更したとしても、これらのオブジェク トが影響を受けることはないだろう。 特定のアプリケーションの操作に変更が発生しても、エ ンティティのレイヤーに影響を与えることはない。

ユースケース

ユースケースのレイヤーのソフトウェアには、アプリケーション固有のビジネスルールが含 まれている。 ここには、システムのすべてのユースケースがカプセル化・実装されている。 ユー スケースは、エンティティに入出力するデータの流れを調整し、ユースケースの目標を達成で きるように、エンティティに最重要ビジネスルールを使用するように指示を出す。

このレイヤーの変更がエンティティに影響を与えることはない。 また、このレイヤーが、 デー

201

第22章 クリーンアーキテクチャ

タベース、 UI、 共通のフレームワークなどの外部の変更の影響を受けることもない。 ユースケー スのレイヤーは、そのような関心事からは分離されている。

ただし、アプリケーションの操作の変更がユースケースに影響を与え、それがユースケース のレイヤーのソフトウェアにまで影響することもある。 ユースケースの詳細が変更された場合、 このレイヤーのコードの一部も確実に影響を受ける。

|インターフェイスアダプター

インターフェイスアダプターのレイヤーのソフトウェアは、ユースケースやエンティティに 便利なフォーマットから、 データベースやウェブなどの外部エージェントに便利なフォーマッ トにデータを変換するアダプターである。 たとえば、 GUI の MVC アーキテクチャを保持する のはこのレイヤーになる。プレゼンター、ビュー、コントローラーは、すべてこのインターフェ イスアダプターのレイヤーに属している。 モデルは、コントローラーからユースケースに渡さ れ、ユースケースからプレゼンターとビューに戻されるデータ構造にすぎない。

同様に、このレイヤーでは、エンティティやユースケースに便利な形式から、永続フレーム ワーク(つまりデータベース)に便利な形式にデータを変換する。 円の内側のコードは、 デー タベースについて何も知らない。 データベースがSQL データベースであれば、 すべての SQL はこのレイヤー (特にデータベースに関係する部分) に限定する必要がある。

また、このレイヤーには、外部サービスなどの外部の形式から、ユースケースやエンティティ が使用する内部の形式にデータを変換するアダプターも含まれる。

|フレームワークとドライバ

図22-1の最も外側の円は、フレームワークやツールで構成されている。 たとえば、 データ ベースやウェブフレームワークなどである。 通常、 このレイヤーにはコードをあまり書かない。 書くとしても、円の次の内側とやり取りするグルーコードくらいである。

フレームワークとドライバのレイヤーには、詳細が詰まっている。 ウェブも詳細。 データベー スも詳細。 被害が抑えられるように、これらは外側に置いておく。

4つの円だけ?

図22-1の円は、概要を示したものである。 したがって、この4つ以外にも必要なものはあ るだろう。この4つ以外は認めないというルールはない。 ただし、 依存性のルールは常に適用 される。 ソースコードの依存性は常に内側に向けるべきだ。 内側に近づけば、 抽象度と方針の

202

依存性のルール

レベルは高まる。 円の最も外側は、最下位レベルの具体的な詳細で構成される。 内側に近づく と、ソフトウェアは抽象化され、 上位レベルの方針をカプセル化するようになる。 円の最も内 側は、最も一般的で、 最上位レベルのものになる。

境界線を越える

図22-1 の右下に、円の境界線をどのように越えるべきかの例を用意した。 コントローラー とプレゼンターは、 次のレイヤーのユースケースと通信している。 制御の流れに注目してほし い。コントローラーから始まり、ユースケースを経由して、 最後にプレゼンターで実行されて いる。ソースコードの依存関係にも注目してほしい。 それぞれが内側のユースケースに向かっ ていることがわかる。

こうした明らかな対立は、通常は依存関係逆転の原則 (DIP) を使って解消する。 Java のよ うな言語では、インターフェイスや継承を整理して、 境界線を越えたところでソースコードの 依存関係が制御の流れと逆転するようにする。

たとえば、ユースケースからプレゼンターを呼び出す必要があるとしよう。 依存性のルール に違反するため、 直接呼び出すことはできない。 円の外側にある名前は、 円の内側から触れる ことはできないからだ。 したがって、ユースケースから円の内側にあるインターフェイス(図 22-1の「ユースケース出力ポート」) を呼び出すようにして、円の外側にあるプレゼンターが インターフェイスを実装することになる。

同じテクニックを使用して、 アーキテクチャに含まれるすべての境界線を越えることができ る。 制御の流れがどのような方向であっても、 依存性のルールに違反しないように動的なポリ モーフィズムを活用して、 制御の流れとは反対のソースコードの依存関係を生み出す。

境界線を越えるデータ

境界線を越えるデータは、単純なデータ構造で構成されている。 好みに応じて、 構造体やデー タ転送オブジェクトを使うこともできる。 単なる関数呼び出しの引数にすることもできる。 ハッ シュマップに詰め込んだり、オブジェクトにしたりすることもできる。 境界線を越えて渡すの は、独立した単純なデータ構造であることが重要だ。 エンティティオブジェクトやデータベー スの行をそのまま渡すようなズルはしたくない。 また、 依存性のルールに違反するような依存 性をデータ構造に持たせたくはない。

たとえば、多くのデータベースフレームワークは、クエリに対して便利なデータ形式を戻す。 これを 「行構造」 と呼ぶこともある。 行構造を円の内側の境界線を越えて渡したくはない。 渡 してしまうと、円の内側が外側について知ることになるため、 依存性のルールに違反すること

203

第22章 クリーンアーキテクチャ

になる。

したがって、境界線を越えてデータを渡すときは、常に内側の円にとって便利な形式にする。

典型的なシナリオ

図22-2は、データベースを使ったウェブベースの Java システムの典型的なシナリオを示し ている。 ウェブサーバーは、ユーザーからの入力データを受け取り、 左上の Controller に渡す。 Controller は、 プレインオールドなJava オブジェクトにデータを詰め込み、 InputBoundary を経 由して、 UseCase Interactor に渡す。 UseCase Interactor は、そのデータを解釈し、 Entities の ダンスを制御する。 また、 DataAccessInterface を使用して、 Entities が使うデータをDatabase からメモリに持ってくる。 それが終わると、 UseCase Interactor は Entities からデータを収 集し、OutputData をプレインオールドなJava オブジェクトとして生成する。 OutputData は、 Output Boundary インターフェイスを経由して、 Presenter に渡される。

Input Data <DS> Controller Input Boundary Presenter <DS> View Model View Use Case Interactor Entities <I> Output Boundary <DS> Output Data <I> Data Access Interface Data Access Database

図22-2 データベースを使ったウェブベースの Java システムの典型的なシナリオ

204

まとめ

Presenter の仕事は、 OutputData を ViewModel (プレインオールドなJava オブジェクト) に 詰め込み直し、 表示可能な形式にすることである。 ViewModel に含まれるのは、 Viewがデータ の表示に使用する文字列とフラグである。 OutputData に Date オブジェクトが含まれることも あるが、 Presenter はユーザーのために適切にフォーマットされた文字列を含んだ ViewModel を読み込む。 Currency オブジェクトなどのビジネスに関連するデータも同様である。 Button MenuItem の名前も ViewModel に含めておく。 これらは、 Button や MenuItem をグレー表示 にするかどうかを View に伝えるフラグである。

View がやるべきことは、 ViewModel から HTMLページにデータを移動すること以外に残され ていない。

依存性の向きに注目してほしい。 すべてが依存性のルールに従い、 内側に向かって境界線を 越えている。

まとめ

こうした単純なルールに従うのは、それほど難しいことではない。 ルールを守っていれば、 いずれ多くの苦痛から解放してくれるだろう。 ソフトウェアをレイヤーに分割して、 依存性の ルールを守れば、本質的にテスト可能なシステムを作り、 それがもたらすメリットを受け取る ことができる。 システムの外部のパーツ(データベースやウェブフレームワーク) が廃れたと しても、そうした要素を最小限の労力で置き換えることができる。

205



プレゼンターと Humble Object 23, 章

第22章では、 プレゼンターという概念を導入した。 プレゼンターは、 Humble Object パター ンの一種であり、アーキテクチャの境界の特定と保護に役立つものである。 実際、 第22章「ク リーンアーキテクチャ」 は、 Humble Object の実装が満載である。

Humble Objectパターン

Humble Object パターンは、ユニットテストを実行する人が、テストしにくい振る舞いとテ ストしやすい振る舞いを分離するために生み出されたデザインパターンである。 アイデアは非 常にシンプルだ。 振る舞いを2つのモジュールまたはクラスに分割するだけである。 ひとつの モジュールは 「Humble (控えめ)」 で、 ここにはテストが難しい振る舞いのみが含まれる。 も うひとつのモジュールには、 Humble Object から取り除かれたテストしやすい振る舞いが含ま れる。

1 dinit Test Patterns, Meszaros, Addison-Wesley, 2007, p. 695.

207

第23章 プレゼンターと Humble Object

たとえば、 GUI のユニットテストは難しい。 なぜなら、 画面に適切な要素が表示されている かを確認するテストを書くのが非常に難しいからだ。 しかし、 GUI の振る舞いの大部分は、簡 単にテストできる。 Humble Objectパターンを使えば、2種類の振る舞いを Presenter と View の2つのクラスに分けられる。

プレゼンターとビュー

View は、 Humble Object である。 こちらはテストが難しい。 したがって、このオブジェクト のコードはできるだけシンプルに保っておく。 GUIにデータを移動するが、 そのデータを処理 することはない。

Presenter は、テスト可能なオブジェクトである。 アプリケーションからデータを受け取り、 プレゼンテーション用にフォーマットして、 View が画面に移動できるようにする。 たとえば、 アプリケーションがフィールドに日付を表示したいと思ったら、 Presenter に Date オブジェク トを渡す。 Presenter はそのデータを適切な文字列にフォーマットして、 View から発見できる ViewModel というシンプルなデータ構造に配置する。

アプリケーションが画面にお金を表示したいと思ったら、 Presenter に Currency オブジェ クトを渡す。 Presenter はそのオブジェクトに適切な桁数と通貨記号を付けてフォーマット して、文字列として ViewModel に配置する。 値がマイナスのときに赤色にする必要があれば、 ViewModel に適切な真偽値のフラグを付けておく。

画面にあるボタンにはすべて名前が付いている。 名前は Presenter が配置した ViewModel に 含まれる文字列である。 ボタンをグレーアウトする必要があれば、 Presenter が ViewModel に 適切な真偽値のフラグを設定する。 メニュー項目の名前は、 Presenter が読み込んだ ViewModel に含まれる文字列である。 ラジオボタン、チェックボックス、テキストフィールドの名前は、 Presenter が読み込み、 適切な文字列と真偽値として ViewModel に配置する。 画面に表示する 数値のテーブルは、 Presenter が読み込み、 適切にフォーマットした文字列として ViewModel に配置する。

画面に表示するもの、アプリケーションが制御するものはすべて、 ViewModel に含まれる文 字列 真偽値 列挙型として表現する。 View がやるべきことは、 ViewModel からデータを読み 込み、 画面に移動すること以外に残されていない。 だからこそ、 View は Humble なのである。

208

データマッパー

テストとアーキテクチャ

テスト容易性が優れたアーキテクチャの特性であることは、これまでずっと知られてきたこ とだ。 Humble Object パターンはその好例である。 振る舞いをテストしやすい部分とテストし にくい部分に分割することが、 アーキテクチャの境界の定義につながるからだ。 Presenter と View もそうした境界のひとつだ。 だが、 他にも境界は存在する。

データベースゲートウェイ

ユースケースインタラクターとデータベースの間にあるのが 「データベースゲートウェイ」で ある。このゲートウェイは、アプリケーションがデータベースに対して実行する作成・ 読み取 り更新 削除のメソッドを含んだポリモーフィックインターフェイスである。 たとえば、アプ リケーションが昨日ログインしたすべてのユーザーの名字を知りたいと思えば、 UserGateway インターフェイスに getLastNamesOfUserswhoLoggedInAfter という名前のメソッドを含めて おく。 これは、引数に Date を受け取り、名字のリストを戻すメソッドである。

ユースケースのレイヤーでSQL の使用を許可しなかったことを思い出してほしい。 その代 わり、ゲートウェイにメソッドを用意して使うようにした。 ゲートウェイはデータベースのレ イヤーにあるクラスで実装する。 この実装は、 Humble Object である。 メソッドから要求さ れたデータにアクセスするために SQL (やそのほかのデータベースインターフェイス) を使う だけだからだ。 一方、 インタラクターは Humble ではない。 アプリケーション固有のビジネス ルールをカプセル化しているからだ。 Humble ではないが、 インタラクターはテスト可能であ る。 ゲートウェイを適切なスタブやテストダブルに置き換えることができるからだ。

データマッパー

データベースの話題に戻ろう。 Hibernate のような ORM は、 どのレイヤーに属しているの だろうか?

まずは、前提を明らかにしよう。 ORM (オブジェクトリレーショナルマッパー)というも のは存在しない。 理由は簡単だ。 オブジェクトはデータ構造ではないからだ。 少なくともユー

1 Patterns of Enterprise Application Architecture, Martin Fowler, et al., Addison-Wesley, 2003, p.466 (邦訳「エンタープライズ アプリケーションアーキテクチャパターン」 翔泳社)

209

第23章 プレゼンターと Humble Object

ザーの観点からはデータ構造ではない。 オブジェクトのユーザーは内部のデータを見ることが できない。 すべてがプライベートになっているからだ。 ユーザーはオブジェクトのパブリック なメソッドしか見えない。 したがって、ユーザーの観点からすると、 オブジェクトは操作の集 合である。

一方、データ構造は、 振る舞いを持たないデータの変数の集合である。 したがって、 ORM は 「データマッパー」 と呼ぶほうが適切だ。 リレーショナルデータベーステーブルから読み取った データをデータ構造に詰め込むからだ。

では、ORM システムはどこに属するのだろうか? もちろんデータベースのレイヤーだ。 実 際 ORM はゲートウェイインターフェイスとデータベースの間に Humble Object の境界を作 るものである。

サービスリスナー

では、サービスはどうだろう? アプリケーションがほかのサービスと通信する必要がある 場合、あるいはアプリケーションがサービスを提供する場合、 Humble Object パターンがサー ビスの境界を作成するのだろうか?

もちろんだ! アプリケーションはシンプルなデータ構造にデータを読み込み、 データを適 切にフォーマットし、境界を越えてモジュールに渡し、そのモジュールが外部のサービスに送 信する。 データの受け取り側では、サービスリスナーがサービスインターフェイスからデータ を受け取り、アプリケーションから使えるシンプルなデータ構造にフォーマットする。 そして、 サービス境界を越えて、そのデータ構造がアプリケーションに戻される。

まとめ

アーキテクチャの境界の近くには、 Humble Object バターンが潜んでいる。 境界を越える通 信には、シンプルなデータ構造が含まれている。 また、 境界はテストしにくい部分とテストし やすい部分に分割する。 アーキテクチャの境界でこのパターンを使用すると、システム全体の テスト容易性が大幅に向上する。

210

部分的な境界 24

KONKE

本格的なアーキテクチャの境界はコストが高い。 相互にポリモーフィックなBoundary イン ターフェイス、 Input と Output のデータ構造、 両サイドのコンパイルやデプロイを独立させ るための依存性管理が必要になる。 それには多くの作業が必要だ。 また、 保守の作業も必要に なる。

優れたアーキテクトならば、このような境界はコストが高すぎると判断するだろう。 だが、 それと同時に、あとで必要になるかもしれないことを考えて、できるだけ境界を残したいとも 思うだろう。

予測型の設計は、 アジャイルコミュニティから YAGNI (You Aren't Going to Need It: あ とで必要になることはない)に違反していると指摘される。 だが、 問題に直面しているアーキ テクトは「確かに違反している。 だが、 あとで必要になることもある」 と考える。 そして、 部 分的な境界を実装することになるだろう。

211

第24章 部分的な境界

最後のステップを省略する

部分的な境界を構築するひとつの方法は、独立してコンパイルやデプロイが可能なコンポー ネントを準備したあとで、 それらを同じコンポーネントにまとめるというものである。 相互イ ンターフェイスも、 入出力のデータ構造も、すべて設定しておくが、コンパイルやデプロイは ひとつのコンポーネントで済むようにしておくのである。

部分的な境界とはいえ、 完全な境界と同じだけのコードや予備的な設計が必要になる。 だが、 複数のコンポーネントを管理する必要はない。 バージョン番号の追跡やリリース管理の負担も ない こうした違いを軽く考えてはいけない。

FitNesse の初期の戦略もこのようにしていた。 FitNesseのウェブサーバーのコンポーネン トを FitNesse のwikiやテストの部分から分離できるように設計したのである。 ウェブコン ポーネントを利用した別のウェブアプリケーションを作るかもしれない、というアイデアがあっ たからだ。それと同時に、2つのコンポーネントをユーザーにダウンロードさせたくはなかっ た。我々の設計のゴールは「ダウンロード・アンド・ゴー」だった。 ユーザーがほかの jar ファ イルを探したり、 バージョンの互換性を気にかけたりすることなく、1つのjarファイルをダウ ンロードするだけで実行できるようにすることが狙いだったのだ。

FitNesse の話は、このアプローチの危険性も示している。 時間が経つと、ウェブコンポーネ ントが必要なくなってきたからだ。 ウェブコンポーネントとwikiのコンポーネントの分離が弱 くなり始めたのである。 依存性が境界線を間違った方向に越えるようになってきた。 今では、 両者を再度分離するのが面倒になっている

片方だけの境界

アーキテクチャの完全な境界は、双方向の分離を維持するために、両側にインターフェイス を使用している。 だが、双方向の分離を維持するというのは、 初期のセットアップも継続的な 保守もコストが高い。

あとから完全な境界にする余地を残した、片方だけの構造を図 24-1 に示す。 昔ながらの Strategy パターンの実例だ。 クライアントからは ServiceBoundary インターフェイスを使用 し、 それは ServiceImpl クラスによって実装されている。

これが将来のアーキテクチャの境界の準備であることは明らかだ。 Client を ServiceImpl から分離するために、 依存関係の逆転が行われている。 だが、厄介な点線の矢印で示している ように、この分離が急速に劣化していくことも明らかである。 相互のインターフェイスがなけ

212

まとめ

Service Client Boundary Service Impl 図24-1 Strategy パターン

れば、こうした裏ルートを防ぐことはできない。 開発者やアーキテクトが規律に従って勤勉に なるしかないだろう。

Facade

さらにシンプルな境界は Facade パターンである (図24-2)。 この場合、 依存関係の逆転さ えも断念する。 境界は Facade クラスで定義しておく。 すべてのサービスはこのクラスのメソッ ドになり、クライアントからアクセスできないクラスにサービス呼び出しを行う。

Client Facade Service

図 24-2 Facade パターン

ただし、 Client はすべてのサービスクラスに推移的に依存していることに注意してほしい。 静的言語では、 Service クラスのいずれかのソースコードを変更すると、 Client も再コンパイ ルが必要になる。 また、 この構造でも簡単に裏ルートを作れることが想像できる。

まとめ

アーキテクチャの境界を部分的に実装する3つのシンプルな方法を見てきた。 もちろんほか にも方法はあるだろう。 この3つの戦略はあくまでも例として提供したものだ。

213

第24章 部分的な境界

これらのアプローチには、それぞれ独自のコストとメリットがある。 最終的に完全な境界に 至るまでの代理として、 特定の状況においては適切なものである。 境界がうまく設定できなけ れば、劣化していく可能性もある。

アーキテクチャの境界をいつどこに作るのか、 それは完全な境界なのか部分的な境界なのか を決めるのは、アーキテクトの役割である。

214

レイヤーと境界 25 第 章

KONNE

システムは 「UI」 「ビジネスルール」 「データベース」という3つのコンポーネントで構成さ れていると考えるとわかりやすいだろう。 単純なシステムであれば、 これで十分である。 だが、 ほとんどのシステムは、 これよりもコンポーネントの数が多い。

ここでは、簡単なコンピュータゲームを取り上げよう。 3つのコンポーネントを想像しやすい ゲームである。 UIは、プレーヤーからゲームルールに対するすべてのメッセージを処理する。 ゲームルールは、何らかの永続的なデータ構造にゲームの状態を保存する。 だが、 これですべ てだろうか?

Hunt the Wumpus

それでは、骨格に肉付けしてみよう。 往年の名作である1972年のアドベンチャーゲーム 「Hunt the Wumpus」 を想定してほしい。 このテキストベースのゲームでは、 GO EAST (東へ行く) や SHOOT WEST (西を撃つ) のような単純なコマンドを使用する。 プレーヤーがコマンドを入力す ると、プレーヤーの見る・匂う聞く経験することを、コンピュータが応答する。プレーヤー

215

第25章 レイヤーと境界

は、罠、落とし穴、その他の危険を回避しながら、 洞窟で Wumpus (ウンパス)の狩りをする。 このゲームに興味があるなら、 ウェブで検索すれば詳しいルールが見つかるはずだ。

まずは、テキストベースのUIを維持しながら、 ゲームルールを切り離してみよう。 異なる言 語のバージョンを出して、 他国でも売れるようにするためだ。 UIコンポーネントとゲームルー ルは言語に依存しない APIで通信し、 UI が API の結果を適切な人間の言語に翻訳するものと しよう。

図25-1に示すように、ソースコードの依存関係が適切に管理されていれば、 任意の数の UI コンポーネントで共通のゲームルールを再利用できる。 ゲームルールは、 使用されている人間 の言語を把握することはなく、 気にする必要もない。

English UI Game Rules Spanish UI

図25-1 任意の数のUIコンポーネントが共通のゲームルールを再利用できる

次に、ゲームの状態が何らかの永続的な場所に保存されているとしよう。 たとえば、フラッ シュメモリだ。 クラウドに保存されることもあるだろう。単にRAM に保存されていることも あるかもしれない。 いずれの場合も、 ゲームルールが詳細を知ることは望ましくない。 したがっ て、ここでも APIを作成しよう。 ゲームルールがデータストレージのコンポーネントと通信す るための API だ。

ゲームルールにデータストレージのことを知らせたくないので、 依存性のルールに従い、適 切に向きを設定した (図25-2)。

English Ul Flash Data Game Rules Spanish UI Cloud Data 図25-2 依存性のルールに従った

216

クリーンアーキテクチャ?

クリーンアーキテクチャ?

ここに「ユースケース」 「境界」「エンティティ」 「データ構造」 といった、 クリーンアーキテ クチャを適用できることは明らかだ。 だが、重要なアーキテクチャの境界を本当にすべて発見 できたのだろうか?

言語だけが UI の変更の軸ではない。 たとえば、テキストの通信方法を変えたくなるかもしれ ない。シェルウィンドウ、テキストメッセージ、チャットアプリケーションなどを使いたくな ることもあるだろう。 さまざまな可能性が存在する。

つまり、変更の軸によって定義される、潜在的なアーキテクチャの境界が存在するというこ とだ。 したがって、そうした境界を越えて、 言語と通信方法を分離できる API を作る必要があ るだろう。 図 25-3 にそのアイデアを示した。

SMS Console Game Rules Language Data Storage Text Delivery English Spanish Cloud Data Flash Data 図25-3 修正した図

図25-3 の図は少し複雑だが、 驚くことは含まれていない。 破線の枠は抽象コンポーネント を示しており、 上下に置かれたコンポーネントが実装する API を定義したものである。 たとえ ば、 Language の API は、 English や Spanish が実装している。

GameRules は、 GameRules が定義して Language が実装した API を使って、 Language と通信す る。 Language は、 Language が定義して TextDelivery が実装した API を使って、 TextDelivery と通信する。 API は、 実装者ではなく、ユーザー側が定義 所有しているのである。

GameRules の内部を見ると、 GameRules に含まれるコードが使用して、 Language のコードが 実装しているポリモーフィックなBoundary インターフェイスが見つかる。 同様に、 Language に 含まれるコードが使用して、 GameRules のコードが実装しているポリモーフィックな Boundary インターフェイスも見つかる。

実際には、このゲームのような小規模なものにクリーンアーキテクチャを適用することはないだろう。 これくらいなら 200行以下のコードで書けるはずだ。 アーキテクチャの境界を必要とする大規模なシステムの代わりに、例として小さ なプログラムを使っているだけである。

217

第25章 レイヤーと境界

Language の内部も同じだ。 そこには、 TextDelivery が実装しているポリモーフィックな Boundary インターフェイスが見つかる。 TextDelivery に含まれるコードが使用して、 Language

のコードが実装しているポリモーフィックなBoundary インターフェイスも見つかる。 いずれの場合も、Boundary インターフェイスで定義された API は、 アップストリームのコ ンポーネントが所有しているのである。

English、SMS、CloudData などのバリエーションでは、抽象コンポーネントで定義されたポリ モーフィックなインターフェイスを具象コンポーネントが実装している。 たとえば、 Language で定義されたポリモーフィックなインターフェイスは、English や Spanish が実装する。

こうしたバリエーションを排除し、 APIコンポーネントだけに注目すると、 先ほどの図を図 25-4 のように単純化できる。

Game Rules Language Data Storage Text Delivery

図25-4 単純化した図

すべての矢印が上を向いていることに注目してほしい (図25-4)。 ここでは、 一番上に GameRules を配置している。GameRules は最上位レベルの方針を含んでいるコンポーネントなので、この 方向は合理的である。

情報の流れを考えてみよう。 ユーザーからのすべての入力は、左下にある Text Delivery コ ンポーネントからやってくる。 その情報は Language コンポーネントで翻訳され、 GameRules に コマンドとして伝えられる。 Game Rules はユーザーの入力を処理して、 適切なデータを右下の DataStorage に送信する。

218

流れを分割する

その後、 GameRules が出力結果を Language に送り返す。 Language は API を適切な言語に翻 訳する。そこから TextDelivery を経由して、翻訳された言語がユーザーに配信される。

この構成は、情報の流れを2つに分割している。 左側の流れはユーザーとの通信、右側の流 れはデータの永続化である。 そして、 両方の流れが上部の GameRules で出会う。 ここで両方 の情報が処理されるのだ。

流れを横切る

先ほどの例のように、 常に2つの情報の流れが存在するのだろうか? そういうわけではな い。 たとえば、 「Hunt the Wumpus」 を複数人のプレーヤーがオンラインでプレイするとしよ う。この場合、 図25-5 に示したようなネットワークコンポーネントが必要になる。 この構成 は、情報の流れを3つに分割している。 そして、それらすべてを GameRules が制御している。

Game Rules Language Data Storage Network 図25-5 ネットワークコンポーネントを追加

したがって、 システムが複雑になるにつれて、 コンポーネントは多くの情報の流れに分割さ れることになるだろう。

流れを分割する

このように説明すると、 すべての流れが最終的に最上部のコンポーネントで出会うと思うか もしれない。 そうであれば簡単でいいのだが、現実はもっと複雑だ。 「Hunt the Wumpus」 の GameRules コンポーネントを考えてみよう。 ゲームルールの一部は

2 矢印の方向がよくわからなくなったら、これはデータの流れではなく、ソースコードの依存性の方向であることを思い 出してほしい。

3 昔はこの上位のコンポーネントのことを「中央変換」 と呼んでいた。 Meilir Page-Jones の著書 「構造化システム設計への 実践的ガイド」 (近代科学社) を参照してほしい。

219

第25章 レイヤーと境界

マップの構造を扱っている。 たとえば、 洞窟がどのように接続されているか、 どのオブジェクト がどの洞窟にあるかを把握している。 また、プレーヤーが洞窟を移動する方法や、 プレーヤー が対処すべきイベントを決定する方法についても把握している

だが、さらに上位レベルに別の方針が存在する。 プレーヤーの状態や、 イベントのコストと メリットを把握する方針だ。 こうした方針により、プレーヤーは健康を害したり、食べ物を発 見して健康を回復したりする。 下位レベルの方針では、 FoundFood や Fell InPit のようなイベ ントとして、上位レベルの方針を宣言することになるだろう。 上位レベルの方針はプレーヤー の状態を管理している (図25-6)。 最終的には、方針がプレーヤーの勝敗を決定する。

Player Management Move Management Language Data Storage Network

図25-6 上位レベルの方針がプレーヤーを管理する

これはアーキテクチャの境界だろうか? MoveManagement と PlayerManagement を分離す る API が必要だろうか? 少しだけ物事がおもしろくなるように、 マイクロサービスを追加し てみよう。

「Hunt the Wumpus」の大規模マルチプレーヤーバージョンがあるとしよう。 MoveManagement はプレーヤーのコンピュータで処理されるが、 PlayerManagement はサーバーで処理される。 PlayerManagement は、 接続されたすべての MoveManagement コンポーネントに対して、マイク ロサービスの API を提供する。

図25-7 は、 このシナリオを簡略化して示したものである。 Network は実際にはこれよりも少し 複雑だが、考え方は伝わるだろう。この場合、アーキテクチャの完全な境界は、 MoveManagement と Player Management の間にある。

220

Player Management Move Management Player Mgt. Player Mgt. Imp. Proxy. Language Data Storage Network Network 図25-7 マイクロサービス APIを追加した まとめ

まとめ

ここまでにやってきたことは何を意味するのだろうか? 200 行の Kornshell で実装できる シンプルなプログラムに、どうしてわざわざアーキテクチャの境界を作ったのだろうか?

この例は、 アーキテクチャの境界があらゆるところに存在することを示している。 我々アー

キテクトは、それがいつ必要になるかに気を配らなければいけない。 また、 境界を完全に構築 しようとすると、コストが高くつくことを認識する必要がある。 それと同時に、境界を無視す ると、たとえ完全なテストスイートやリファクタリングの規律があったとしても、レイヤーを 追加するコストが非常に高くなることも認識する必要がある。

では、我々アーキテクトは何をすべきだろうか? その答えは満足できるものではない。 非 常に頭のいい人たちが、 抽象化が必要になることを予測してはいけないと提唱してきた。 これ が YAGNIの哲学である。 このメッセージには、オーバーエンジニアリングのほうがアンダー エンジニアリングよりも悪質であるという知見が含まれている。 だが、アーキテクチャの境界 が必要なところになかったとしたら、 境界を追加するコストやリスクは非常に高いものとなる だろう。

おわかりいただけただろうか。 ソフトウェアアーキテクトは未来に目を向けなければいけな い。 頭を使って推測するべきだ。 コストを評価し、 アーキテクチャの境界がどこにあるのか、 完全に実装する必要があるのか、部分的に実装すべきなのか、無視したほうがいいのかを判断 する必要がある。

しかもこれは、1回限りの決定ではない。 プロジェクトの開始時に、実装する境界と無視す る境界を決めればいいわけではない。 常に見張る必要がある。 システムの進化に注意を払うべ きだ。境界が必要になりそうなところに注目して、境界がないために発生している摩擦の兆候

221

第25章 レイヤーと境界

を感じ取ってほしい。

そこから、境界を実装するコストと無視するコストを比較検討し、 その決定を何度も評価す る。無視するコストよりも実装するコストが低くなる変曲点で、境界を実装することがゴール

である。

そのためには、注意深く見守らなければいけない。

222

メインコンポーネント 26

すべてのシステムには、そのほかのコンポーネントを作成・調整・監督するコンポーネント が少なくとも1つ存在する。 私はこのコンポーネントを Main と呼んでいる。

究極的な詳細

Main コンポーネントは、究極的な詳細 (最下位レベルの方針) である。 システムの最初のエ エントリーポイントとなる。 オペレーティングシステム以外に、このコンポーネントに依存して いるものはない。 Factory や Strategy などのグローバルな要素を作成し、 システムの上位の抽 象部分に制御を渡すことが、 このコンポーネントの仕事になる。

依存関係については、 この Main コンポーネントにDIフレームワークを使って注入する必要 がある。 Main に注入できたら、あとはフレームワークを使用せずに、 Main が通常のやり方で 依存関係をちりばめる。

Main は、 汚れ仕事が最も似合うコンポーネントだ。

223

第26章 メインコンポーネント

「Hunt the Wumpus」 の最新バージョンのMain コンポーネントを考えてみよう。 コードの 本体で把握したくない文字列を読み込むところに注目してほしい。

public class Main implements HtwMessageReceiver { private static Hunt The Wumpus game; private static int hitPoints = 10; private static final List<String> caverns new ArrayList<>(); private static final String ) environments = new String[] { "bright", "humid", "dry", "creepy", "ugly", "foggy", "hot", "cold", "drafty", }; "dreadful"

private static final String[] shapes new String[] { "round", "square", "oval", "irregular", "long", "craggy", "rough", }; "tall", "narrow"

private static final String[] cavernTypes new String[] { "cavern", "room", "chamber", "catacomb", "crevasse", "cell", "tunnel", "passageway",

224

究極的な詳細

}; "hall", "expanse"

private static final String[] adornments new String[] { }; "smelling of sulfur", "with engravings on the walls", "with a bumpy floor", "littered with garbage", "spattered with guano", "with piles of Wumpus droppings", "with bones scattered around", "with a corpse on the floor", "that seems to vibrate", "that feels stuffy", "that fills you with dread"

ここから先が main 関数だ。 まずは、 HtwFactory を使ってゲームを作成している。ここで htw.game.Hunt TheWumpus Facade というクラス名を渡している。 このクラスは Main よりも汚 い仕事をしている。こうすることで、このクラスに変更があっても、 Main を再コンパイルや再 デプロイすることを回避できる。

public static void main(String[] args) throws IOException { game HtwFactory.makeGame ("htw.game. Hunt The Wumpus Facade",

createMap();

new Main());

BufferedReader br =

new BufferedReader (new InputStreamReader (System.in)); game.makeRest Command ().execute();

while (true) {

System.out.println(game.getPlayerCavern ()); System.out.println("Health: "+hitPoints +

game.getQuiver());

Hunt The Wumpus.Command c game. make RestCommand(); System.out.println(">");

String command br.readLine();

+

if (command.equalsIgnoreCase("e"))

arrows:

cgame.makeMoveCommand (EAST);

else if (command.equalsIgnoreCase("w"))

"

225

第26章 メインコンポーネント

c game.makeMoveCommand (WEST);

else if (command.equalsIgnoreCase("n"c game.makeMoveCommand (NORTH);

))

else if (command.equalsIgnoreCase("s")) c game.makeMove Command (SOUTH);

else if (command.equalsIgnoreCase("r")) c game.makeRestCommand();

else if (command.equalsIgnoreCase("sw")) cgame.makeShoot Command (WEST);

else if (command.equalsIgnoreCase("se")) game.makeShoot Command (EAST); c

else if (command.equalsIgnoreCase("sn")) cgame.makeShoot Command (NORTH);

else if (command.equalsIgnoreCase("ss")) cgame.makeShoot Command (SOUTH);

else if (command.equalsIgnoreCase("q")) return;

c.execute();

}

また、main では、入力ストリームを作成し、 ゲームのメインループを回し、 単純な入力コマ ンドを解釈しているが、 すべての処理を上位レベルのコンポーネントに委ねているところにも 注目してほしい。

最後に、 main がマップを作成していることを見ていこう。

private static void createMap() { int nCaverns = (int) (Math.random() * 30.0 + 10.0); while (nCaverns-- > 0) caverns.add(makeName());

for (String cavern } caverns) { maybeConnect Cavern (cavern, NORTH); maybeConnectCavern (cavern, SOUTH); maybeConnectCavern (cavern, EAST); maybe Connect Cavern (cavern, WEST);

String player Cavern = anyCavern(); game.setPlayerCavern (playerCavern);

226

まとめ

} game.setWumpusCavern (any Other (playerCavern)); game.addBatCavern (any Other (playerCavern)); game.addBatCavern (any Other (playerCavern)); game.addBatCavern (any Other (player Cavern)); game.addPitCavern (any Other (playerCavern)); game.addPitCavern (anyOther (playerCavern)); game.addPitCavern (anyOther (player Cavern)); game.setQuiver (5);

} // 以降のコードは省略

ここでのポイントは、 Main はクリーンアーキテクチャの円の最も外側にある下位レベルのモ ジュールであることだ。 それは、 上位レベルのシステムのためにすべてを読み込み、 制御を渡 すものである。

まとめ

Main をアプリケーションのプラグインと考えよう。 初期状態や構成を設定して、 外部リソー スを集め、アプリケーションの上位レベルの方針に制御を渡すプラグインである。 プラグイン

なので、 アプリケーションの設定ごとに複数の Main コンポーネントを持つこともできる。

たとえば、開発用、 テスト用、 本番用の Main を用意することもできる。 あるいは、 デプロイ する国別、 権限別、 顧客別に用意することもできるだろう。

Main をアーキテクチャの境界の背後にあるプラグインとして考えると、 設定の問題はもっと 解決しやすくなるはずだ。

227



サービス:あらゆる存在 27日

KONKE

サービス指向 「アーキテクチャ」 とマイクロサービス 「アーキテクチャ」 は、 最近になって 普及してきたものだ。 現在の人気の理由は、以下のようなものである。

●サービスが互いに分離されているように見えるから。 あとで説明するが、これは部分的に しか正しくない。

●サービスが開発とデプロイを独立させているように見えるから。これもあとで説明するが、 部分的にしか正しくない。

サービスアーキテクチャ ?

まず、サービスを使用することは、その性質上、 アーキテクチャであるという意見について考 えてみたい。 これは明らかに正しくない。 システムのアーキテクチャは、 上位レベルの方針と 下位レベルの詳細を分離し、依存性のルールに従う境界によって定義される。 アプリケーショ ンの振る舞いを分離するだけのサービスは、単なる高価な関数呼び出しにすぎず、 アーキテク

229

チャにおいて必ずしも重要なものではない。

アーキテクチャにおいて、 サービスは重要にならなければいけないと言っているのではない。 プロセスやプラットフォームで機能を分割するサービスを作成することは、 依存性のルールに 従っているかにかかわらず、 大きな利点がある。 サービスはサービスであり、 アーキテクチャ を定義するものではないということだ。

関数の構成を考えてみるとわかりやすいだろう。 モノリシックやコンポーネントベースのシ ステムのアーキテクチャは、特定の関数呼び出しによって定義されている。 これは、 アーキテ クチャの境界を越えて、 依存性のルールに従うものである。 だが、 システムに存在するそのほ かの多くの関数は、振る舞いを分離しているだけであり、 アーキテクチャにおいて重要なもの ではない。

サービスでも同じだ。 サービスもプロセスやプラットフォームの境界を越える関数呼び出し にすぎない。 アーキテクチャにおいて重要なサービスもあれば、重要ではないサービスもある。 本章での我々の関心は、前者のサービスである。

サービスのメリット?

このセクションでは、現在人気のあるサービスアーキテクチャに疑問を投げかけていこう。 1 つずつメリットを取り上げていきたい。

誤った分離

システムをサービスに分ける大きなメリットは、サービス同士が強く分離されていることだ と言われる。 それぞれのサービスは、異なるプロセス (場合によっては異なるプロセッサ)で 実行されているため、サービスはお互いの変数にアクセスすることができない。 また、 それに よってサービスのインターフェイスが明確に定義されることになる。

確かに正しいところもある。だが、それほど多くはない。 変数のレベルでは分離されている かもしれないが、プロセッサ内やネットワーク上にある共有リソースについては分離されてい ない。それに、サービスは共有しているデータと強く結び付いてしまっている。

たとえば、サービス間で渡されるデータレコードに新しいフィールドが追加されると、 その 新しいフィールドを扱うすべてのサービスを変更することになるだろう。 また、 データの解釈 についても強く合意しておかなければいけない。 したがって、 サービスはデータレコードと強 く結び付いているということであり、結果として、 間接的ではあるが相互に結び付いているの である。

第27章 サービス あらゆる存在

230

明確に定義されたインターフェイスに関しては、確かに正しいところもあるが、関数のとき ほど正しいものではない。 サービスのインターフェイスは、関数と比べると、正式なものでは なく、 厳密なものではなく、明確に定義されているものでもない。 こうしたメリットは、明ら かに幻想である。

誤った開発とデプロイの独立

サービスのもうひとつのメリットは、専属のチームがサービスを所有・運用することだと言 . われる。 専属のチームは、 DevOps の戦略の一環として、サービスの記述 保守運用に責任 を持つ。 こうした開発とデプロイの独立性は、スケーラブルであるとみなされる。 独立して開 発およびデプロイが可能なサービスが、 数十、百、数千あれば、 大規模なエンタープライズ システムが構築できると信じられている。 システムの開発・保守・運用についても、同程度の 数の独立したチームに分割することができると信じられている。

ここには正しいことも含まれている。 だが、 ごく一部である。 歴史的に見ると、大規模なエ ンタープライズシステムは、 モノリシックなシステムやコンポーネントベースのシステムでも 構築できる。 サービスだけがスケーラブルなシステムを構築する唯一の選択肢ではない。

それから、誤った分離により、サービスは必ずしも独立して開発 デプロイ 運用できると は限らないことがわかる。 データや振る舞いが結び付いている限り、 開発 デプロイ運用に は調整が必要なのである。 . . .

子猫の問題

この2つの誤りの例として、タクシー配車システムをもう一度見てみよう。 このシステムは、 ある都市のタクシー会社をいくつも把握しており、顧客が配車を注文できるというものだった。 顧客は、乗車時間、料金、 豪華さ、 運転手の経験など、いくつかの条件でタクシーを選択でき るものとしよう。

システムをスケーラブルにしたかったので、 小さなマイクロサービスをたくさん用意して構 することにした。 そして、 開発スタッフを多くの小規模チームに分割し、対応するサービス を開発・保守・運用を担当してもらうようにした。

図27-1 は、 架空のアーキテクトがこのアプリケーションを実装するために、サービスをどの ように構成したかを示している。 TaxiUI サービスは、モバイルデバイスを使用してタクシーを

子猫の問題

したがって, マイクロサービスの数とプログラマの人数はほぼ同じである。

231 231

第27章 サービス: あらゆる存在

発注する顧客を扱う。 TaxiFinder サービスは、 さまざまな Taxi Supplier (タクシー業者)を 調べ、ユーザーの条件に合ったタクシーを決定する。 そして、ユーザーにひも付けられた短期 間のデータレコードに保管する。 TaxiSelector サービスは、ユーザーの指定した料金、 時間、 豪華さなどの条件を受け取り、候補のなかから適切なタクシーを選択する。 選択したそのタク シーを TaxiDispatcher サービスに渡し、 そこでタクシーを発注する。

Taxi Ul Taxi Finder Candidate Taxis Taxi Supplier! Taxi Supplier2ト [ Taxi Supplier 3 ) Taxi Dispatcher Taxi Selector

図27-1 タクシー配車システムを実装するサービスの構成

このシステムがすでに1年以上稼働しているとしよう。 開発スタッフたちは、すべてのサー ビスを保守・運用しながら、 新しい機能を喜んで開発している。

ある晴れた日のこと、マーケティング部門は開発チームとミーティングを開いた。 このミー ティングでは、子猫宅配サービスを開始する計画があることが発表された。 ユーザーは自宅や 事業所に子猫の宅配を注文することができるのだ。

市内にいくつかの子猫収集地点を設置して、宅配の注文が入ったら、 近くにいるタクシーが 収集地点から子猫を選び、注文された住所に子猫を届けるのである。

ひとつのタクシー業者がこのプログラムに賛同してくれた。残りもいずれ賛同してくれるだ ろう。だが、賛同しない業者もいるだろう。

運転手のなかには猫アレルギーの人もいるはずだ。 その運転手はこのサービスを担当すべき ではない。 また、タクシーの乗客のなかにも猫アレルギーの人はいるだろうから、 子猫の宅配 に使ったタクシーは、その後3日間は猫アレルギーの顧客を乗せないようにしたい。

ここでサービスの図を見てほしい。 この機能を実装するために、どれだけのサービスを変更 しなければいけないだろうか? すべてだ。 子猫機能の開発とデプロイは、明らかに慎重に調 整する必要がある。

. 言い換えると、サービスはすべて結合されており、独立して開発 デプロイ保守すること はできないのである。

232

救世主のオブジェクト

これは 「横断的関心事」 の問題である。 あらゆるソフトウェアシステムは、サービス指向で あろうとなかろうと、この問題に直面することになる。 図27-1のサービス図のような機能分割 は、すべての動作に影響を与える新機能の追加に対して非常に弱い。

救世主のオブジェクト

コンポーネントベースのアーキテクチャでは、 この問題をどのように解決できたのだろうか? SOLID の設計原則を慎重に検討していれば、 新機能をポリモーフィックに扱う一連のクラス を作成することができたはずだ。

図27-2 は、 この戦略を示している。 この図にあるクラスは、 図27-1のサービスにも対応し ている。ただし、境界に注意してほしい。 また、依存性のルールに従った依存関係にも注意し てほしい。

Taxi Taxi Finder Suppliers Taxi UI Rides Taxi Selector Taxi Dispatcher Component Factories Kittens

図27-2 横断的関心事に対応するオブジェクト指向のアプローチ

233

第27章 サービス: あらゆる存在

元のサービスのロジックの大部分は、オブジェクトモデルのベースクラスに保持されている。 だが、乗車に固有のロジックは、 Rides コンポーネントに抽出されている。 子猫の新機能は、 Kittens コンポーネントに置かれている。これらの2つのコンポーネントは、 Template Method や Strategy などのパターンを使用して、 元のコンポーネントの抽象ベースクラスをオーバーラ イドしている。

新しいコンポーネントであるRides と Kittens の2つは、依存性のルールに従っていること に注目してほしい。 これらの機能を実装するクラスは、 UI の制御下にある Factory によって作 成されることにも注目してもらいたい。

このスキームでは、 子猫機能を実装するときに TaxiUI を変更する必要がある。 だが、 ほかに 変更するものはない。 新しい jar ファイル、 Gem、 DLL などをシステムに追加することになる が、それらは実行時に動的に読み込まれる。

したがって、子猫の機能は分離され、独立して開発 デプロイが可能である。

コンポーネントベースのサービス

「これをサービスで実現できるのか?」 と疑問に思うだろう。 答えは「もちろん!」 だ。 サー ビスはモノリシックである必要はない。 SOLID の原則を使用してサービスを設計し、 コンポー ネントの構造を与えておけば、サービスに含まれる既存のコンポーネントを変更することなく、 新しいコンポーネントを追加できる。

Java で作られたサービスは、1つ以上の jar ファイルに含まれた抽象クラスの集まりである と考えられる。 新機能や機能拡張が必要なときは、 jar ファイルを追加すればいい。 そこには、 最初の jar ファイルの抽象クラスを拡張するクラスが含まれる。 新機能のデプロイは、サービ スを再デプロイするのではなく、 新しい jarファイルをロードパスに追加するだけになる。 言 い換えれば、 新機能の追加は、 オープン・クローズドの原則 (OCP) に準拠している。

図27-3 のサービス図は、こうした構造を示している。 以前と同じようにサービスが存在し ているが、それぞれに内部コンポーネントの設計があり、 新機能を新しい派生クラスとして追 加することができる。 これらの派生クラスは、それぞれのコンポーネントの内部に存在する。

234

横断的関心事

Taxi Finder Ride Supplier Kitty Supplier Taxi Supplier! | Taxi Supplier2} Taxi Supplier3 Ride Taxi UI Finder Kitty Pinder Candidate Taxis Ride Taxi Selector Selector Kitty Selector Taxi Dispatcher Ride Dispatcher Kitty Dispatcher

図27-3 各サービスには内部コンポーネントの設計があり、新機能を新しい派生クラスとして追加することが できる

横断的心事

我々が学んだのは、 アーキテクチャの境界はサービスとサービスの中間に位置するわけでは ないということだ。 アーキテクチャの境界は、サービスを横断することで、 コンポーネントに 分割しているのである。

横断的関心事に対応するために、サービスは依存性のルールに従った内部コンポーネントの アーキテクチャと一緒に設計する必要がある (図27-4)。 サービスがシステムのアーキテクチャ の境界を定義しているのではなく、サービス内部のコンポーネントがそれを定義しているので ある。

235

第27章

サービス: あらゆる存在 Rides Ride Selector Taxi Selector Kittens Kitten Selector

27-4 サービスは依存性のルールに従った内部コンポーネントのアーキテクチャと一緒に設計する必要が ある

まとめ

サービスは、システムのスケーラビリティや開発の利便性に対しては有用だが、 アーキテク チャにおいては重要な要素ではない。 システムのアーキテクチャは、システム内の境界と、 境 界を越える依存性によって定義される。 アーキテクチャは、 要素の通信や実行の物理的な仕組 みで定義されるわけではない。

サービスは、アーキテクチャの境界に囲まれたひとつのコンポーネントの場合もある。 ある いは、アーキテクチャの境界で分割された、複数のコンポーネントで構成されている可能性も ある。 めったにないが、 アーキテクチャに重要性を持たせないために、クライアントとサービ スを結合させることもあるだろう。

2 めったにないと思いたいが、場合によってはよく経験することかもしれない。

236

テスト境界 128円

そうだ、テストはシステムの一部だ。 システムのほかの部分と同様に、テストもアーキテク チャに関与している。 いくつかの点において、 その関与はごく当たり前のものだが、いくつか この点において、その関与は非常に独特なものである。

システムコンポーネントとしてのテスト

テストにはかなり混乱が見られる。 システムの一部なのか? システムから切り離されてい るのか? テストにはどのような種類があるのか? ユニットテストとインテグレーションは 違うのか? 受け入れテストは? 機能テストは? Cucumber のテストは? TDD のテス トは? BDD のテストは? コンポーネントテストは?

そうした議論に巻き込まれるのが本書の役割ではない。 幸いなことに、そうした議論は不要 だ。 アーキテクチャの観点からすると、 すべてのテストは同じだ。 TDD で作る小さなテストで FitNesse の大きなテストでも、 Cucumber や Spec Flow や JBehaveのテストでも、アーキ

237

第28章 テスト境界

テクチャにおいてはすべて同じである。

テストは、その性質上、 依存性のルールに従う。 テストは、 非常に詳細で具体的であり、テ ストするコードに対して常に依存している。 実際、 テストはアーキテクチャの円の最も外側に あると考えることができる。 システムに含まれるものはテストに依存しておらず、 常にテスト のほうがシステムのコンポーネントに依存している。

テストも独立してデプロイ可能である。 ほとんどの場合、 プロダクションシステムではなく、 テストシステムにデプロイされる。 したがって、 独立したデプロイが不要なシステムであって も、テストは依然として独立してデプロイできる。

テストは、最も独立したシステムコンポーネントである。 システムの運用には不要だ。 ユー ザーが使うものでもない。 テストの役割は運用ではなく、 開発をサポートすることだ。 それで も、ほかと同じシステムコンポーネントである。 実際、 多くの点において、 そのほかのすべて のシステムコンポーネントが従うべきモデルを表している。

テスト容易性のための設計

テストを極端に分離しすぎてしまうと、普段からあまりデプロイしないことが重なって、 開 発者はテストをシステムの設計の外側にあるものと考えてしまう。 これは破滅的な見方だ。 テ ストをシステムの設計にうまく統合しないと、 不安定なものになる。 システムは硬直化し、 変 更は困難になるだろう。

もちろん問題は結合である。 システムと強く結合したテストは、システムに合わせて変化す る必要がある。 システムコンポーネントに対する小さな変更であっても、 結合した多くのシス テムが壊れたり、変更が必要になったりする。

こうした状況は深刻化する可能性がある。 共通のシステムコンポーネントを変更すると、何 百や何千というテストが壊れる可能性がある。 これは、脆弱なテストの問題 (Fragile Tests Problem) と呼ばれている。

これがどのように起きるかを経験するのは難しいことではない。 たとえば、 GUI を使用して ビジネスルールを検証するテストスイートを想像してみてほしい。 このようなテストは、 ログ イン画面から始まり、特定のビジネスルールをチェックできるまでページを移動していくこと になるだろう。 途中でログインページやナビゲーションの構造を変更すると、膨大な数のテス トが壊れる可能性がある。

脆弱なテストは、システムを硬直化させるという悪影響を及ぼす。 システムを少し変更した だけで大量のテストが失敗するとなると、 開発者は変更するのをためらうだろう。 たとえば、 マーケティングチームが簡単なナビゲーション構造の変更を依頼してきたとしよう。 その変更

238

によって、 1,000個のテストが破壊されるとする。 このときのマーケティングチームと開発チー ムとの会話を想像してみよう。

解決策は、テスト容易性の設計にある。 ソフトウェア設計の第一のルールは、 その理由がテ スト容易性だろうと何だろうと、 常に同じである。 それは、変化しやすいものに依存しないだ。 GUI は変化しやすい。 GUI を使用してシステムを操作するテストスイートは脆弱である。 した がって、 GUI を使用しなくてもビジネスルールのテストができるように、システムとテストを 設計しなければいけない。

テストAPI

この目的を達成するには、テストから使用できるAPIを作成して、 すべてのビジネスルール を検証できるようにすればいい。 このAPIには、テストからセキュリティ制約を取り除き、 コ ストの高いリソース(データベースなど) をバイパスし、システムをテスト可能な状態にする 「スーパーパワー」 が必要である。 このAPIは、ユーザーインターフェイスが使用するインタ ラクターおよびインターフェイスアダプターのスーパーセットになる。

テスト APIの目的は、テストをアプリケーションから分離することである。 この分離は、UI からテストを切り離すことだけではない。 アプリケーションの構造からテストの構造を切り離 すことが目的である。

構造的結合

構造的結合は、最も強く、最も油断できない、 テストの結合の形態である。 すべてのクラス のテストクラスと、 すべてのメソッドのテストメソッドを含んだテストスイートを想像してほ しい。 このようなテストスイートは、アプリケーションの構造と深く結び付いている。

プロダクションのクラスやメソッドが変更されると、大量のテストを変更することになる。 その結果として、テストは脆弱になり、 プロダクションコードは硬直化していく。

テスト API の役割は、アプリケーションの構造をテストから隠すことである。 これにより、 テストに影響を与えることなく、 プロダクションコードをリファクタリングして進化させるこ とができる。また、プロダクションコードに影響を与えることなく、テストをリファクタリン グして進化させることができる。

このような進化の分離が必要なのは、時間が経つにつれて、テストは具体的かつ個別化する 傾向があるからだ。 それとは対照的に、プロダクションコードは抽象的かつ一般化する傾向が ある。構造的結合が強いと、こうした進化の分離が妨げられる。 そして、 本来ならば一般化さ

テスト API

239

第28章 テスト境界

れ、柔軟であったプロダクションコードが、そうではなくなってしまう。

|セキュリティ

テスト API のスーパーパワーは、プロダクションシステムにデプロイされると危険である。 したがって、 テスト API とその危険な実装部分は、 独立してデプロイ可能な個別のコンポーネ ントに入れておく必要がある。

まとめ

テストはシステムの外側ではない。安定度やリグレッションのメリットを提供するのであれ ば、テストもうまく設計すべきシステムの一部である。 システムの一部として設計されていな いテストは、脆弱で保守が難しくなる傾向がある。 保守が難しいので、 メンテナンスルームに 廃棄されることもよくある。

240

クリーン組込みアーキテクチャ 29

KOHNKE

執筆: James Grenning

しばらく前に、 Doug Schmidt のブログで 「The Growing Importance of Sustaining Software for the DoD (国防総省のソフトウェアを維持する重要性の高まり)」という記事を読んだ。 そ の記事のなかで、 Doug は以下のような主張をしている。

ソフトウェアは消耗しないが、ファームウェアやハードウェアは時代遅れになる。その結果、ソフト ウェアの変更が必要になる。

目の前が開けた瞬間だった。 Doug は明確な2つの用語を使っていたのだが、 それまでの 私にとっては、明確ではなかったのだ)。 ソフトウェアは長寿の代物だが、 ハードウェアの進 化に伴い、 ファームウェアは時代遅れになる。 これまでに組込みシステムの開発の経験があれ ば、ハードウェアが絶え間なく進化・改善していくことはご存じだろう。 それと同時に、新し

http://insights.sel.cmu.edu/sei_blog/2011/08/the-groving-importance-of-sustaining-softvare-for-the-

dod.ktal

241

第29章 クリーン組込みアーキテクチャ

い 「ソフトウェア」に機能が追加され、絶え間なく複雑性が増加していくのである。 Doug の言葉に以下の文を追加したい。

ソフトウェアは消耗しないが、管理できていないファームウェアやハードウェアの依存関係により、 ソフトウェアが内部から破壊される可能性がある。

ハードウェアの依存関係に影響されてしまうため、組込みソフトウェアが長寿にならないこ ともめずらしくはない。

私は、Doug のファームウェアの定義が好きだ。 だが、ほかの定義も見てみよう。 以下のよう なものが見つかった。

●ファームウェアは、 ROM、 EPROM、 フラッシュメモリなどの不揮発性メモリデバイスに 保存されたものである。 (https://en.wikipedia.org/wiki/Firmware)

●ファームウェアは、ハードウェアデバイスにプログラムされたソフトウェアプログラムま

たは命令セットである。 (https://techterms.com/definition/firmware) ●ファームウェアは、ハードウェアに組み込まれたソフトウェアである。 (https://www.life vire.com/what-is-firmware-2625881)

●(ファームウェアは) 読み取り専用メモリ (ROM) に書き込まれたソフトウェア (あるい はプログラムやデータ) である。 (http://www.webopedia.com/TERM/F/firmware.html)

Doug の文章を読むと、上記のような広く受け入れられているファームウェアの定義が間違っ ている(少なくとも時代遅れになっている)ことがわかる。 ファームウェアとは、ROM に存在 するコードを意味するものではない。 ファームウェアは、格納されている場所ではなく、 それ が何に依存しているのか、ハードウェアの進化に合わせてどれだけ変化しにくいかで決まる。 ハードウェアは進化しているのだ (手元の携帯電話を見ればわかるだろう)。 したがって、 その ことを考慮しながら、 組込みコードを構造化する必要がある。

私は、ファームウェアやファームウェアのエンジニアに対して敵対心を持っているわけでは ない (自分でファームウェアを書いていたこともあるくらいだ)。 だが、 本当に必要とされるの は、ファームウェアを少なくして、 ソフトウェアを多くすることだ。 事実、 私はファームウェ アのエンジニアが書くべきファームウェアが多すぎることに絶望している!

組込みエンジニアではないエンジニアもファームウェアを書いているのだ! コードに SQL を埋め込んだり、プラットフォームの依存性を広げたりするたびに、実質的にファームウェア を書いているのである。 Androidアプリの開発者は、 Android API とビジネスロジックを分離 できていなければ、ファームウェアを書いていることになる。

242

プロダクトコード (ソフトウェア)とハードウェアとやり取りするコード (ファームウェア) の境界線は、存在しないのではないかと思えるほどあいまいである。 私はこのことに多くの労 力を費やしてきた。 たとえば、1990年代後半には、 TDM (Time-Division Multiplexing)から VolP (Voice over IP) に移行する通信サブシステムの再設計を手伝っていた。 VoIP は現在で も活躍しているが、 TDM は 1950年代から1960年代の先端技術であり、 1980年代から1990年 代に広く導入されたものだ。

ある状況における呼び出しの応答についてシステムエンジニアに質問すると、しばらく姿を 消してから、詳細な答えを持って帰ってきた。 「どこで答えを手に入れたのか?」と聞くと「現 行のプロダクトのコードから」という答えが返ってきた。 絡み合ったレガシーコードが、新し いプロダクトの仕様だったのだ! 既存の実装では、 TDM と呼び出しのビジネスロジックが分 離されていなかった。 プロダクト全体がハードウェアや技術に完全に依存しており、 絡み合っ たものを解きほぐすことができなかった。 そして、そのプロダクト全体が、実質的にファーム ウェアとなった。

別の例を考えてみよう。 コマンドメッセージはシリアルポート経由でこのシステムに届く。 当然のことながら、 そこにはメッセージのプロセッサとディスパッチャがある。 プロセッサは、 メッセージのフォーマットを認識し、それを読み取り、 要求を処理できるコードにディスパッチ する。 驚くところは特にないが、プロセッサとディスパッチャは、 UART2とやり取りするコー ドに同居している。 つまり、 プロセッサはUART の詳細に汚染されているのだ。 プロセッサは 寿命の長いソフトウェアになれた可能性もあるが、ここではファームウェアとなっている。 ソ フトウェアになる機会を拒否されたのだ。 こんなの絶対おかしいよ!

私はソフトウェアとハードウェアを分離する必要性を長年認識してきたが、 Doug の言葉に よって、ソフトウェアとファームウェアという用語を両者の関係性のなかで使うことがわかった。 エンジニアやプログラマに対して伝えるべきことは明らかである。 ファームウェアをあまり 書かないようにして、 寿命を長くする機会をコードに与えよう。 もちろん望むだけではうまく いかない。 それでは、組込みソフトウェアのアーキテクチャをクリーンにして、ソフトウェア に寿命の長い人生を送る機会を授ける方法を見ていこう。

適性テスト

なぜ組込みソフトウェアはファームウェアになるのだろうか? ほとんどの場合、組込みコー ドを動作させることが重視され、 長寿のための構造はあまり重視されていない。 Kent Beck が、

2 シリアルポートを制御するハードウェアデバイス。

適性テスト

243

章 クリーン組込みアーキテクチャ

第29

ソフトウェアを構築する3つの活動について、以下のように説明している (強調は著者による)。

1. まずは、 動作させる。 動作しなければ、 仕事にならない。

2. それから、 正しくする。 あなたやほかングして、ニーズの変化や理解の向上のためにコードを進化させていく。 3. それから、高速化する。 「必要とされる」 パフォーマンスのためにコードをリファクタリ ングする。

の人たちが理解できるようにコードをリファクタリ

私が見かける組込みシステムソフトウェアの多くは 「動作させる」ことを念頭に置いて書か れている。 おそらく「高速化する」 という目標のことも考えられているだろう。 高速化は、あら ゆる機会で細かな部分最適化を続けることによって実現するものだからだ。 Fred Brooks は、 著書 「人月の神話」 のなかで 「1つは捨石にするつもりで」 と述べている。 Kent と Fred は、 ほ とんど同じアドバイスをしている。 動作するものを学んでから、よりよいソリューションを生 み出すべきである。

こうした問題は、組込みソフトウェアだけのことではない。 ほとんどのアプリケーションは、 ただ動作するためだけに作られており、 長寿となるように正しくコードを作ることはほとんど 考慮されていない。

アプリを動作させることを、私はプログラマの適性テスト (App-titude test) と呼んでいる。 だが、アプリを動作させることだけに関心を持つプログラマ (組込みプログラマかどうかを問 わない)は、プロダクトや雇用主に不利益を与えている。プログラミングとは、アプリをただ 動作させる以上のものなのだ。

適性テストを通過したコードの例として、小さな組込みシステムの1つのファイルに含まれ る関数を見ていこう。

ISR (TIMER1_vect) { ... } ISR (INT2_vect) { ... } void btn_Handler(void) { ... } float calc_RPM (void) { ... } static char Read_RawData (void) { ... } void Do_Average (void) { ... } void Get_Next_Measurement (void) { } void Zero_Sensor_1 (void) { ... } void Zero_Sensor_2 (void) { ... } void Dev_Control (char Activation) { ... } char Load_FLASH_Setup (void) { ... } void Save_FLASH_Setup (void) { }

244

適性テスト

void Store DataSet (void) { ... } float bytes2float (char bytes [4]) { ... } void Recall DataSet (void) { ... } void Sensor_init(void) { ... } void uC_Sleep(void) { }

この関数のリストは、ソースファイルで見つかった順番になっている。 これを関心事でグルー プ化してみよう。

●ドメインロジックを含んだ関数

float calc RPM (void) { ... } void Do Average (void) { } void Get Next Measurement (void) { ... } void Zero Sensor_1 (void) { ... } void Zero Sensor_2(void) { }

●ハードウェアプラットフォームを設定する関数

ISR(TIMER1_vect) { ... } ISR(INT2_vect) { ... } void uC_Sleep(void) { ... }

●ボタンのオン/オフに反応する関数

void btn_Handler(void) { ... } void Dev Control (char Activation) { }

●ハードウェアから読み取ったA/D入力を取得する関数

static char Read_RawData (void) { ... }

●永続化ストレージに値を保存する関数

} char Load FLASH_Setup(void) { ... } void Save FLASH_Setup(void) { void Store DataSet (void) { ... }

245

章 クリーン組込みアーキテクチャ

第29

float bytes2float (char bytes [4]) { ... }

void Recall_DataSet(void) { ... }

●名前を示していることをやっていない関数

void Sensor_init(void) { ... } ...

このアプリケーションのほかのファイルを見ると、 コードの理解を妨げるものがいくつも見 つかった。また、このコードのいずれかをテストする唯一の方法が、 組込みターゲットにある ことを示すファイル構造も見つかった。 つまり、このコードのほぼすべてのビットが、 特別な マイクロプロセッサのアーキテクチャのことを把握しており、 特定のツールチェーンやマイク ロプロセッサと結び付いた 「拡張された」 C の構造体を使っていたのである。 このプロダクト を別のハードウェア環境に移植する可能性がある限り、コードが長寿になる方法は残されてい ない。

このアプリケーションは確かに動作している。 エンジニアは適性テストを通過している。 だ が、このアプリケーションは「クリーン組込みアーキテクチャ」になっているとは言えない。

ターゲットハードウェアのボトルネック

組込み開発者は、その他の開発者が扱わない多くの懸念事項に対応する必要がある。 たとえ ば、制限されたメモリ空間、 リアルタイムの制約と期限、制限されたIO、 一般的ではないユー ザーインターフェイス、センサーや現実世界との接続などだ。 ほとんどの場合、 ハードウェア はソフトウェアやファームウェアと同時に開発されている。 こうしたシステムを開発するエン ジニアは、コードを実行できないことがある。 ハードウェアが手に入り、 コードを実行できた としても、ハードウェアに欠陥があることが多い。 ソフトウェア開発の進捗は通常よりも遅く なるだろう。

そう、組込みは特別なのだ。 組込みエンジニアも特別だ。 だが、 組込み開発はそれほど特別 ではない。 本書の原則は組込みシステムにも適用できる。

組込みの特別な問題にターゲットハードウェアのボトルネックがある。 クリーンアーキテク チャの原則やプラクティスを適用せずに組込みコードを構成すると、 そのターゲットでしかコー

3 シリコンプロバイダーは、C言語からレジスタや10ポートに簡単にアクセスできるように、C言語にキーワードを追加 している。残念ながら、そうしたコードはもはやC言語ではない。

246

ターゲットハードウェアのボトルネック

ドをテストできない状況になる。 その結果、 開発速度が低下してしまうだろう。

クリーン組込みアーキテクチャはテスト可能な組込みアーキテクチャ

ターゲットハードウェアのボトルネックを解消するために、 組込みソフトウェアやファーム ウェアにアーキテクチャの原則を適用する方法を見ていこう。

レイヤー

レイヤーにはさまざまな種類がある。 まずは、 図29-1にある3つのレイヤーから見ていこ う。一番下にはハードウェアがある。 Doug が警告しているとおり、 技術の進歩とムーアの法 則によって、ハードウェアは変化する。 パーツは古くなっていく。 新しいパーツのほうが、 消 費電力は少なく、パフォーマンスは高く、 安価である。 理由は何であれ、ハードウェアの必然 的な変化が起きたときに、 私は組込みエンジニアとして、必要以上に仕事が増えることを望ん でいない。

ソフトウェア ファームウェア ハードウェア 図29-1 3 つのレイヤー

ハードウェアとそれ以外との分離は、少なくともハードウェアが定義されているならば、明 らかになっていることだ (図 29-2)。 だが、 適性テストを通過するときに、このあたりで問題 がよく発生する。 すべてのコードからハードウェアの知識の汚染を取り除くものが存在しない からだ。 どこに何を置くのか、ほかのモジュールについてどこまで知るべきかを注意深く決め なければ、コードの変更は非常に難しいものとなる。 それは、ハードウェアが変化したときだ けではない。 ユーザーからの変更や修正すべきバグがあったときなども含まれる。

ソフトウェアとファームウェアを混ぜるのはアンチパターンである。 このアンチパターンの あるコードは変更しにくい。 また、 変更は危険であり、 意図しない結果につながることが多い。 ちょっとした変更についても、システム全体の完全な回帰テストが必要になる。 手動テストが

247

第29章 クリーン組込みアーキテクチャ

ファームウェア ハードウェア

図29-2 ハードウェアとシステムのそれ以外の部分は分離すべき

飽きることを予想して、 インストルメント化されたテストを外部から作れるようにしておかな ければ、新しいバグレポートが作成されるだろう。

ハードウェアは詳細

ソフトウェアとファームウェアの境界線は、コードとハードウェアの境界線と違い、うまく 定義できるものではない (図29-3)。

ソフトウェア ファームウェア ハードウェア

図29-3 ソフトウェアとファームウェアの境界線は、 コードとハードウェアの境界線と違い、 あいまいである

組込みソフトウェアの開発者の仕事には、この境界線を明確にすることも含まれる。 ソフト ウェアとファームウェアの境界は、ハードウェア抽象化レイヤー (HAL: Hardware Abstraction Layer) と呼ぶ (図 29-4)。 これは新しい考え方ではない。 Windows 以前の時代からPCの世 界に存在するものだ

HAL はその上に置かれたソフトウェアのために存在する。 HALのAPIはソフトウェアの必 要性に合わせて調整すべきである。 たとえば、ファームウェアはバイトやバイトの配列をフラッ シュメモリに格納することができる。 一方、アプリケーションは名前と値のペアを何らかの永

248

ターゲットハードウェアのボトルネック

HAL ソフトウェア ファームウェア ハードウェア

図29-4 ハードウェア抽象化レイヤー (HAL)

続化メカニズムに格納して読み取る必要がある。 この場合、ソフトウェアは、その名前と値の ペアがどこに保存されるのか (フラッシュメモリなのか、 回転ディスクなのか、 クラウドなの か、コアメモリなのか) を知る必要はない。 HAL はサービスを提供するものであり、それがど のように機能するかをソフトウェアに明らかにすることはない。 フラッシュメモリの実装は、 ソフトウェアから隠すべき詳細なのである。

別の例として、 GPIO ビットに接続されている LED を考えてみよう。 ファームウェアは、GPIO ビットへのアクセスを提供している。 HAL は、 たとえば Led_TurnOn (5) を提供することにな るだろう。これはかなり低レベルなハードウェア抽象化レイヤーである。 それでは、 抽象レベ ルをハードウェアの観点から、ソフトウェアやプロダクトの観点まで引き上げてみよう。 LED は何を示しているのだろうか? たとえば、バッテリーの低下を示しているとしよう。 ファー ムウェア (またはボードサポートパッケージ) でも Led_TurnOn (5) は提供できるだろう。 その 場合、HAL は Indicate_LowBattery() を提供することになるだろう。 HALはアプリケーショ ンが必要とするサービスであると考えられる。 また、レイヤーにレイヤーが含まれていること がわかるだろう。 事前に定義されたレイヤーというよりも、 フラクタルなパターンが繰り返さ れているのである。 GPIO の割り当ては、ソフトウェアから隠しておくべき詳細だ。

ハードウェアの詳細はHALのユーザーに明らかにしない

クリーン組込みアーキテクチャのソフトウェアは、ターゲットハードウェアをオフにしたテ ストが可能である。 HAL をうまく作れば、 オフターゲットのテストを簡単にする継ぎ目や置換 点ができる。

プロセッサは詳細

組込みアプリケーションが特殊なツールチェーンを使用している場合、 「<i> 便利な </i>」

249

第29

章 クリーン組込みアーキテクチャ

ヘッダーファイルが提供されていることがある。 こうしたコンパイラは、 C言語を勝手に変更 して、プロセッサの機能にアクセスするキーワードを追加している。 C言語のように見えるか もしれないが、そのコードはもはやC言語ではない。

ベンダー提供のCコンパイラは、 プロセッサのレジスタ、 IOポート、クロックタイマ、 IO ビット、割り込みコントローラー、 そのほかのプロセッサ機能に直接アクセスするために、 グ ローバル変数のようなものを提供することがある。 これらの機能に簡単にアクセスできるのは 便利だが、 便利な機能を使っているコードは「もはやC言語ではない」。 別のプロセッサ用に コンパイルできないだろうし、 同じプロセッサであっても別のコンパイラでは動かない可能性 がある。

シリコンとツールのプロバイダーが、 あなたのプロダクトをコンパイラから切り離せないよう にしている、などと私は考えたくない。 疑わしきは罰せず。 彼らは本当に役に立ちたいと思っ ていると考えよう。 それを将来的に困らないようにいかに使うかは、あなた次第である。 拡張 されたC言語のことを知るファイルを制限したほうがいいだろう。

では、ACME 社製の DSP のヘッダーファイルを見てみよう (ワイリーコヨーテが使って いたアレだ)。

#ifndef _ACME_STD_TYPES

#define _ACME_STD_TYPES

#if defined(_ACME_X42 ) typedef unsigned int Vint_32; typedef unsigned short Vint_16; typedef unsigned char Uint_8; typedef int Int_32; typedef short Int_16; typedef char Int_8;

#elif defined( _ACME_A42)

typedef unsigned long Vint_32;

typedef unsigned int Vint_16;

typedef unsigned char Vint_8;

typedef long Int_32;

typedef int Int_16;

typedef char Int_8;

#else

#error <acmetypes.h> is not supported for this environment

#endif

意図的にHTMLを使用している。

4

250

#endif

ターゲットハードウェアのボトルネック

acmetypes.h ヘッダーファイルを直接使用するべきではない。 直接使用すると、 あなたのコー ドが ACME DSP に結び付けられてしまう。 ACME DSP を使っているのだから、 別に問題な いのではないか? と思うかもしれない。 だが、このヘッダーを含めない限り、 コードをコン パイルできなくなることが問題だ。 ヘッダーを使用して _ACME_X42 や _ACME_A42 を定義した場 合、 オフターゲットでコードをテストしようとすると、 整数が間違ったサイズになってしまう。 それくらいなら問題ないと思っていると、ある日、アプリケーションを別のプロセッサに移植 することになるだろう。 ポータビリティを選ばなかったために、 ACME について知るファイル を制限しなかったために、 その移植作業は困難を極めるのである。

acmetypes.h を使用する代わりに、 stdint.h を使用して、もっと一般的な道筋を歩むべきで ある。 だが、ターゲットコンパイラが stdint.h を提供していない場合はどうだろうか? この ヘッダーファイルを自分で書けばいい。 ターゲットビルド用に書いた stdint.h は、ターゲッ トコンパイルのための acmetypes.h を使用する。

#ifndef _STDINT_H_ #define _STDINT_H_

#include <acmetypes.h>

typedef Vint_32 uint32_t; typedef Vint_16 uint16_t; typedef Vint_8 uint8_t;

typedef Int_32 int32_t;

typedef Int_16 int16_t;

typedef Int_8 int8_t;

#endif

組込みソフトウェアやファームウェアから stdint.h を使用すると、 コードがクリーンにな り、ポータビリティを確保できる。 すべてのソフトウェアはプロセッサに依存しないようにす べきだが、 すべてのファームウェアにはそれができない。 以下のスニペットは、マイクロコン トローラーの周辺機器にアクセスできるC言語の拡張を利用している。 内蔵周辺機器を使用で きるように、プロダクトからマイクロコントローラーを使用しているのだろう。 この関数は、 “1”という行をシリアル出力ポートに出力するものだ (実際に存在するコードを参考にした)。

251

第29章 クリーン組込みアーキテクチャ void say_hi ( ) { IE = 0b11000000; SBUFO = (0x68); while (TI_0 == 0); TI_0 = 0; SBUFO = (0x69); while (TI_0 == 0); TI_0 = 0; SBUFO = (0x0a); while (TI_0 == 0); } TI_0 = 0; SBUFO (OxOd); while (TI_0 == 0); TI_0 = 0; IE = 0b11010000;

この小さな関数には多くの問題がある。 すぐに目にとまるのは Ob11000000 の存在だろう。 このバイナリの表記はカッコよさげだが、 C言語で書けるのだろうか? 残念ながら、C言語 では書けない。 そのほかのいくつかの問題も、C言語の拡張を利用したコードに関連している。

●IE: 割り込み可能なビット。

●SBUFO シリアル出力バッファ。

●TI_0:シリアル送信バッファエンプティ割り込み。 1を読み出すと、 バッファが空である ことを示す。

大文字の変数は、マイクロコントローラーの内蔵周辺機器に実際にアクセスする。 割り込み の制御や文字を出力したい場合は、 これらの周辺機器を使用する必要がある。 確かに便利だが、 これはC言語ではない。

クリーン組込みアーキテクチャでは、これらのデバイスアクセスレジスタを限られた場所から 使用して、完全にファームウェアに閉じ込めておく。 レジスタを知っているのはファームウェ アになる。その結果、 シリコンに結び付けられる。 コードがプロセッサに結び付くと、安定し たハードウェアを手に入れる前にコードを動かすときに困る。 また、 組込みアプリケーション を新しいプロセッサに移植するときにも困ったことになる。

マイクロコントローラーを使用するときは、こうした低レベル機能をプロセッサ抽象化レイ ヤー (PAL: Processor Abstraction Layer) でファームウェアから分離しておく。 PALの上に

252

ターゲットハードウェアのボトルネック

ファームウェアは、 少しだけ安定性に欠けるが、オフターゲットでテストできる。

は詳細

HALは必要だが、 それで十分だろうか? 純粋な組込みシステムでは、 HAL だけでコード を動作環境から切り離すことができる。 だが、 リアルタイムOS (RTOS) や組込み版のLinux や Windows を使うシステムはどうだろうか?

組込みコードの寿命を延ばすには、OSを詳細として扱い、OS の依存関係から身を守る必要 がある。

ソフトウェアは、 OS を経由して動作環境のサービスにアクセスする。 OSはソフトウェアを ファームウェアから分離するレイヤーである (図29-5)。 OS を直接使用すると、 問題が発生 する可能性がある。 たとえば、 RTOS の会社が買収され、ロイヤルティが上がったり、品質が 下がったりするかもしれない。 必要な機能がRTOS にない場合はどうするだろうか? 新しい OS の API の変更に合わせて、単に構文を書き換えるだけではなく、 さまざまな機能やプリミ ティブに合わせて意味的に適応させながら、 多くのコードを修正することになるだろう。

ソフトウェア OS ファームウェア ハードウェア 図29-5 OS を追加する

クリーン組込みアーキテクチャでは、 OS 抽象化レイヤー (OSAL: Operating System Ab straction Layer) でソフトウェアを OSから分離する (図29-6)。 このレイヤーの実装は、関 数の名前を変更するだけの簡単な場合もあれば、 いくつかの関数をまとめてラップすることも ある。

ほかのRTOS にソフトウェアを移植したことがあれば、それがどれだけ大変なことかをわ かっているだろう。 ソフトウェアがOS ではなく OSAL に依存していれば、互換性のある新し OSAL を作成するだけでいい。 既存の複雑なコードを修正するほうがいいだろうか? そ

253

第29章 クリーン組込み

アーキテクチャ OSAL ソフトウェア HAL OS ファームウェア ハードウェア

図29-6 OS 抽象化レイヤー (OSAL)

れとも、決められたインターフェイスや動作に合わせて新規にコードを書くほうがいいだろう か? これは引っ掛けの質問ではない。 私なら後者を選ぶ。

コードが膨れ上がることを心配しているかもしれない。 だが実際には、このレイヤーはOSを 使用する重複部分だ。 これが大きな負担になることはない。 OSAL を定義すると、 アプリケー ションに共通の構造を持たせることもできる。 すべてのスレッドで並列モデルを用意するので はなく、メッセージバッシングの仕組みを提供することも可能になる。

ソフトウェアレイヤーの価値のあるアプリケーションコードをオフターゲットおよび OSな しでテストできるように、OSAL でテストポイントを用意することもできる。 クリーン組込み アーキテクチャのソフトウェアでは、ターゲットのOSなしにテスト可能である。 OSAL をう まく作れば、 オフターゲットのテストを簡単にする継ぎ目や置換点ができる。

インターフェイスに対するプログラミングと代替可能性

主なレイヤー (ソフトウェア、OS、 ファームウェア、ハードウェア) に HAL や OSAL を追 加するだけでなく、本書で説明している原則も適用できる (適用すべきである)。 これらの原則 は、関心事の分離、 インターフェイスに対するプログラミング、 代用可能性を促進する。

レイヤードアーキテクチャの考えは、インターフェイスに対するプログラミングの考え方に もとづいている。 あるモジュールがインターフェイス経由で別のモジュールとやり取りしてい るなら、サービスプロバイダーを別のものに置き換えることができる。 たとえば、 開発用に独 自の小さな printf を作った経験のある読者も多いだろう。 独自の printf が標準の printf と 同じインターフェイスを持っていれば、サービスをオーバーライドして置き換えることができ

254

ターゲットハードウェアのボトルネック

るのだ。

基本的なルールとして、インターフェイスの定義にはヘッダーファイルを使うというものが ある。 ただし、その場合には何をヘッダーファイルに入れるかに注意すべきだ。 ヘッダーファ イルの内容は、 関数宣言と関数が必要とする定数や構造体の名前だけに制限すべきだ。

インターフェイスヘッダーファイルに実装に必要なデータ構造、定数、 typedef を含めてご ちゃごちゃさせてはいけない。 ごちゃごちゃすることだけが問題ではない。 それによって、不 要な依存関係ができてしまうのだ。 実装の詳細の可視性を制限しよう。 実装の詳細は変更され ると考えよう。 コードが細部を知る場所を少なくしておけば、それだけコードを追跡修正す る場所も少なくなる。

クリーン組込みアーキテクチャでは、 モジュールはテスト可能である。 インターフェイス経 由でやり取りしているからだ。 インターフェイスは、オフターゲットのテストを簡単にする継 ぎ目や置換点を提供する。

[DRYな条件付きコンパイル命令

見過ごされがちな代用可能性として、 組込みの C/C++のプログラムが複数のターゲットや OS を扱う方法がある。 コードのセグメントをオン/オフするために、 条件付きコンパイルを使 用するというものだ。 テレコムアプリケーションで何千回も#ifdef BOARD_V2を書いていたこ とを思い出してしまった。

こうしたコードの繰り返しは、 DRY 原則に違反している。 #ifdef BOARD_V2 を一度だけ見 かけたとしても、それは問題ではない。 6,000回も見かけたら、深刻な問題である。 ターゲッ トハードウェアの種別を識別する条件付きコンパイルは、 組込みシステムでは何度も繰り返さ れる。 他に対策はあるだろうか?

HAL を使うのはどうだろうか? そうすれば、 ハードウェアの種別は HALに隠された詳細 になる。 条件付きコンパイルではなく、 HALのインターフェイスを使えば、 リンカや何らかの ランタイムバインディングを使用して、 ソフトウェアをハードウェアに接続することができる だろう。

5 Andrew Hunt, David Thomas 「達人プログラマー」 (オーム社)を参照。

255

第29章 クリーン組込みアーキテクチャ

まとめ

組込みソフトウェアを開発している人は、 組込みソフトウェア以外の経験から多くを学ぶこ とができる。 本書を手にしたあなたが組込み開発者であれば、 ソフトウェア開発に関する豊富 な知見を発見できるだろう。

すべてのコードをファームウェアにすると、 プロダクトの長期的な健康のためにならない。 ターゲットハードウェアでしかテストできないと、 プロダクトの長期的な健康のためにならな い。 クリーン組込みアーキテクチャは、プロダクトの長期的な健康のためである。

256

詳細 第 VI 齢 部

(訳注: 「詳細」 を意味する 「detail」 には、 「些細」 という意味もある。 本書では 「詳細」 で統 一しているが、両方の意味が含まれることに注意してほしい。

257



データベースは詳細 第30

Business

RULES

KANKE

Oracle

アーキテクチャの観点では、 データベースはエンティティではない。 データベースは詳細で

あり、 アーキテクチャの構成要素として現れることはない。 ソフトウェアシステムのアーキテ クチャにおけるデータベースの立ち位置は、 あなたが住む家におけるドアノブのようなものだ。 ケンカを売っているように聞こえるかもしれない。 実際、論争になったこともある。 念のた めに言っておくが、 今話題にしているのはデータモデルのことではない。 アプリケーションの データをどのような構造で扱うかは、システムのアーキテクチャにおいて重要な問題だ。 しか し、データベースはデータモデルではない。 データベースはひとつのソフトウェアであり、デー タへのアクセス機能を提供する道具にすぎない。 アーキテクチャの観点では、道具のことなど気 にしない。 それはもっと下位レベルの仕組みの話だ。 優れたアーキテクトは、システムのアー キテクチャが下位レベルの仕組みに汚染されることを許さない。

259

第30章 データベースは詳細

リレーショナルデータベース

1970年、 Edgar Codd がリレーショナルデータベースの原則を定めた。 それから80年代半 ばまでに、リレーショナルモデルは急成長し、 データストレージの世界を支配するようになっ た。普及したのには理由がある。 リレーショナルモデルはエレガントで規律があり、 堅牢なも のだからだ。 データストレージとそこへのアクセスの仕組みとして、 リレーショナルモデルは すばらしいものだった。

しかし、どんなにすばらしくて、 有用で、 数学的に妥当だったとしても、リレーショナルデー タベースは単なるテクノロジーのひとつにすぎない。 それはつまり、リレーショナルデータベー スがあくまでも詳細であることを意味する。

リレーショナルテーブルはデータアクセスの手法として便利なものだが、 データをテーブル の行として扱うことは、 アーキテクチャ的にはどうでもいいことだ。 アプリケーションのユー スケースはそんなことを気にしないし、気にすべきでもない。 データが表形式であるという知 識は、下位レベルのユーティリティ関数の世界に閉じ込めておくべきで、それはアーキテクチャ の円の外側にある。

データアクセスフレームワークの多くは、 データベースの行やテーブルをオブジェクトとして 受け渡しできるようになっている。 これは、アーキテクチャ的には間違っている。 ユースケー ス、ビジネスルール、 そして場合によってはUIまでも、リレーショナルデータ構造に縛られて しまうからだ。

なぜデータベースシステムが普及しているのか?

なぜソフトウェアシステムやソフトウェア開発会社が、 データベースシステムに支配されて いるのだろうか? Oracle や MySQL や SQL Server の何がそんなにすばらしいのだろう? ひとことで言うなら、 その答えは 「ディスク」だ。

半世紀にわたり、 回転する磁気ディスクがデータストレージの主役だった。 それ以外のデー タストレージを知らない世代のプログラマも多いだろう。 最初期のディスクは、直径 48インチ の巨大プラッタを大量に積み上げたもので、 重さは数千ボンドで、 容量は20MB だった。 それ が今では、直径3インチで、 重さ数グラムの薄い円盤に、 TB級のデータを保持できる。 それ はもう劇的な変化だ。 そしてプログラマは、 半世紀にわたり、ディスクの技術のある致命的な 問題に悩まされてきた。 何しろディスクは遅い。

ディスクでは、データは円形のトラックに格納される。 ひとつのトラックは複数のセクタに

260

もしもディスクがなかったら?

分割できて、 それぞれが所定のサイズ (4KB であることが多い) のデータを保持する。 ひとつ のブラッタには数百トラックを保持できて、 十数枚のブラッタを持つことができる。 ディスク 上の特定のバイトの内容を読みたい場合は、まずヘッドを適切なトラックに移動して、読みた いデータが書かれたセクタが回ってくるまで待ち、 そのセクタ全体をRAM に読み込んでから、 必要なバイトを取得する必要がある。 ここまでの所要時間は数ミリ秒だ。

ミリ秒と聞くと大したことないと感じるかもしれない。 だが、一般的なプロセッサのサイク ルタイムと比べると百万倍の長さになってしまう。 データがディスク以外のところにあれば、 ミリ秒どころかナノ秒単位でアクセスできるのだ。

ディスクが原因の遅延を軽減するために、インデックス、 キャッシュ、クエリの最適化が必 要になる。 また、これらがデータを把握するために、データを表現する何らかの手段も必要だ。 つまり、データアクセスとデータ管理システムが必要ということになる。 その後、このシステ ムは2種類の方式に分かれていった。 ファイルシステムと、リレーショナルデータベース管理 システム (RDBMS) だ。

ファイルシステムはドキュメントベースのシステムだ。 非常に自然かつ便利な方法で、 ドキュ メントを保存できる。 ただし、 ドキュメントの名前を指定して、 ドキュメントを保存したり取得 したりするだけならうまく機能するが、 ドキュメントの中身を検索しようとするとあまり役に 立たない。 たとえば、 login.c というファイルを探すのはたやすいことだが、 すべての.cファ イルのなかから変数 x が含まれているものを見つけるというのは難しいし、時間もかかってし まう。

データベースシステムはコンテンツベースである。 非常に自然かつ便利な方法で、 コンテン ツの内容にもとづいてレコードを探せる。 コンテンツの一部に同じ内容を含むレコードをすべ て探したりすることが得意だ。 残念ながら、 形式が定まっていないドキュメントを扱う仕組み は貧弱である。

どちらのシステムもデータをディスクで扱っている。 求められるアクセス方法に合わせて、 効率的にデータの格納や取得ができるようになっている。 どちらも独自のインデックス方式や データ配置方式を使っている。 さらに、 どちらも最終的にはデータをRAM に載せて扱う。 そ のほうが高速に操作できるからだ。

もしもディスクがなかったら?

かつては広く普及していたディスクだが、 今では絶滅寸前だ。 近いうちに、テープドライブ、 フロッピー CDと同じ道を歩むだろう。 ディスクは、RAM に取って代わられつつある。 さて、ここで考えてみよう。 ディスクが絶滅し、 すべてのデータがRAM に格納されるよう

261

第30章 データベースは詳細

になったとき、どのようにデータを扱うだろうか? 表形式にして SQL でアクセスする? そ れともファイルとして保存してディレクトリで管理する?

もちろんそんなことはしないだろう。 リンクリスト、ツリー、 ハッシュテーブル、 スタック、 キューなどでデータ構造を表現し、 ポインタや参照でデータにアクセスするだろう。 だって、 それがプログラマのやり方なのだから。

よくよく考えてみれば、すでにこの方法を使っていることに気づくだろう。 ファイルシステ ムのファイルだろうが、 データベースのデータだろうが、 まずはRAM に読み込んでから、 リ スト、セット、 スタック、 キュー、 ツリーなどの使いやすいデータ構造に変換しているはずだ。 ファイルやテーブルの形式のままでデータを使うことなどあり得ない。

詳細

この事実こそが、 データベースは詳細であると私が言っている理由だ。 データベースは、ディ スクとRAM との間でデータを移動する仕組みにすぎない。 大きなバケツに大量のビットを長 期保存しているのとそんなに変わらない。 しかし、 データベースのデータをそのままの形式で 使うことはめったにない。

アーキテクチャ的な観点からすると、 回転する磁気ディスクに存在するデータがどのような 形式であるかを気にすることはない。 もっと言えば、 ディスクが存在するかどうかも知るべき ではない。

だけど、 パフォーマンスはどうなの?

アーキテクチャ的にパフォーマンスは気になるところではないかって? もちろん気になる。 だが、データストレージのパフォーマンスについては、ビジネスルールと切り離して考えられ る。 データストアからのデータの出し入れを高速に実行する必要があるだろうが、 それは下位 レベルの関心事である。 そのことに対応するには、下位レベルのデータアクセスの仕組みを使 うことになる。そしてそれは、システムの全体的なアーキテクチャとは関係のないものだ。

262

小話

80年代後半のこと。 私はとあるスタートアップ企業でソフトウェアエンジニアのチームを率 いて、 T1 通信回線の完全性を計測するネットワーク管理システムの開発と販売に取り組んでい た。 そのシステムは、回線の終端装置のデータを取得してから、予測アルゴリズムを使って間 題を検出 報告するものだった。 .

UNIX プラットフォームを使い、データはシンプルなランダムアクセスファイルとして保存し た。 扱うデータにはコンテンツの関連がほとんどなかったので、 わざわざリレーショナルデー タベースを使うまでもなかったからだ。 ツリーやリンクリストのままでランダムアクセスファ イルに格納するほうが使いやすかった。 つまり、 RAM に読み込んだときに最も扱いやすい形 式でデータを保持していたことになる。

新たにマーケティングマネージャーを雇うことになった。 頭の切れるいい奴だった。 だが、 彼はすぐに「このシステムではリレーショナルデータベースを使うべきだ」と言いだした。 も ともとそんな考えはなかったし、 技術的な問題もなかった。 彼によると、それは「マーケティ 「ングの課題」なのだそうだ。

何を言っているのか意味がわからなかった。 せっかくリンクリストやツリーがあるのに、な ぜわざわざ表形式に変換して SQL で処理しなければいけないのだろう? シンプルなランダム アクセスファイルで十分なのに、わざわざお金をかけて巨大な RDBMSを導入しなければいけ ないのだろう? 私は彼と徹底的に戦った。

社内にいたハードウェアエンジニアが、 この RDBMS 騒ぎを引き受けた。 彼は、技術的な意 味でも RDBMS が必要だと思うと主張した。 私の席の後ろで役員たちと話しながら、電柱の上 でバランスをとっている家の絵を描いて 「電柱の上に家を建てたいと思いますか?」と言った。 ファイルの内容をRDBMSの表に格納したほうが、 そのまま使うよりもいくらか信頼性が高く なると言いたかったのだろう。

小話

私は彼とも戦った。 マーケティングの連中とも戦った。 無知な奴らに向かってエンジニアリ ングの原則を語り続けた。 とことん戦いまくった。

最終的に、そのハードウェアエンジニアが私を追い越して、 ソフトウェアマネージャーに昇 した。 かわいそうに、そのシステムには RDBMS が組み込まれてしまった。 彼らが勝った。 私は負けた。

念のために言っておくが、 技術的な意味で負けたのではない。 技術的には私のほうが正しかっ た。 RDBMS をアーキテクチャの中核に組み込むことに反対したのは間違っていなかった。 私 が負けたのは、顧客がリレーショナルデータベースを望んでいたからだ。 顧客はリレーショナ ルデータベースが何かなんて知るはずもない。 システムにおける使い方もわかっていない。 だ

263

第30章 データベースは詳細

が、そんなことはどうでもよかった。 顧客はRDBMS を使うことだけを期待していたのだ。 顧 客がソフトウェアを選定するときに使う機能比較チェックリストに 「RDBMS」 という項目が 追加されるようになった。 技術的な根拠などない。 考える意味もない。 不合理かつ根拠のない ニーズだが、それが現実だった。

そのようなニーズが生まれたそもそもの原因は、 当時のデータベースベンダーが仕掛けた大々 的なマーケティングキャンペーンにあった。 企業の 「データ資産」 を保護するためには、自社 のデータベースシステムこそが理想的な手段であることを企業の経営者に訴えたのだ。

よく似たことは今でも行われている。 「エンタープライズ」 だとか 「サービス指向アーキテク

チャ」だとかいった言葉が、地に足のつかないマーケティング用語として幅を利かせている。 私はこのときどうすべきだったのだろう? おそらく、 システムに無理やり RDBMS をネジ 止めして、 RDBMS にアクセスする安全な仕組みを用意してから、システムの中心にあるラン ダムアクセスファイルをそのまま使い続けるべきだったのだろう。 で、 当時の私が実際にどう したかというと･･････。 その会社から逃げ出して、コンサルに転身しましたとさ。

まとめ

データの構造であるデータモデルは、アーキテクチャ的には重要である。 だが、 回転する磁 気面上でデータを移動させる技術やシステムは、 アーキテクチャ的には重要ではない。 リレー ショナルデータベースシステムは、データを表形式で管理して、 SQLからアクセスするための 仕組みであり、 これは前者(データモデル) よりも後者 (技術やシステム) に近い。 データこ そが重要なのであり、 データベースは詳細なのである。

264

ウェブは詳細 31 日 章

90年代に開発者だった人たちに聞いてみたい。 ウェブが何もかもを変えていった経緯を覚え ているかい? キラキラしたウェブ技術を目の当たりにして、旧来のクライアントサーバーアー キテクチャがどんなふうに見えたかを覚えているかい?

実際のところ、 ウェブは何ひとつ変えなかった。 というか、変えるべきではなかった。 ウェ ブはこの業界で60年代からずっと続く 「振り子」 の延長線上にあるものだ。 この振り子は、す べての計算パワーを中央サーバーにまとめるか、逆にすべての計算パワーを端末に分散させる かの間を行ったり来たりしている。

ウェブの世界になってからの十数年間も、この振り子は何度か行ったり来たりしている。 は じめのうちは、すべてのパワーをサーバー側にまとめていて、ブラウザ側では特に何もしてい なかった。 そのうち、ブラウザ上でアプレットを動かすようになった。 我々はそれに満足でき ず、動的コンテンツは再びサーバー側へと戻された。 我々はそれに満足できず、 今度は Web 20なるものを発明した。 Ajax と JavaScript によって、 さまざまな処理がブラウザ側に戻って きた。 ブラウザで実行する巨大なアプリケーションを書くまでになった。 そして現在 Node.js を使って JavaScript をサーバー側に戻すのが流行っている。 ( やれやれ )

265

第31章 ウェブは詳細

止まらない振り子

ウェブが登場してから振り子の運動が始まったと考えるのは間違いだ。 ウェブの前には、ク ライアントサーバーアーキテクチャがあった。 その前は、中央にミニコンがあって、 そこに大量 のダム端末がつながっていた。 その前は、緑色の画面を持つ端末がメインフレームにつながっ ていた(この端末は、ちょうど今でいうところのブラウザみたいなものだ)。 さらにその前は、 計算機室とパンチカードの時代だった。 さらにその前は......。

歴史は繰り返す。 計算能力がどこに必要になるかを見つけ出せず、 集中と分散の間を行った り来たりしている。 この振り子は今後も動き続けるのだろう。

IT業界の歴史を俯瞰すると、 ウェブは何ひとつ変えていない。 ウェブは、 我々の多くが生 まれる前から始まり、 我々の多くが引退した後も続くであろう、 振り子の運動のひとつにすぎ ない。

アーキテクトとしては、長期的な観点で考える必要がある。 振り子の運動は短期的な問題で あり、ビジネスルールの中心からは切り離しておきたい。

ここで、Q社の事例を聞いてほしい。 Q社は有名な個人向けファイナンスシステムを作った 会社だ。 とても使いやすい GUIを持つデスクトップアプリで、私も愛用していた。

そこにウェブの時代がやってきた。 Q社はGUIを変更し、見た目も振る舞いもブラウザのよ うにした。 そりゃもう、びっくりした! 個人向けファイナンスアプリをブラウザ風の見た目 にするなんて、どこのどいつが考えたのだろう?

私はその新しいインターフェイスのことが気に入らなかった。 きっと誰もがそう感じたのだ ろう。その後、Q社はブラウザ風の見た目を廃止して、元のデスクトップアプリのGUIに戻し たのだ。

あなたがQ社のソフトウェアアーキテクトだったとしよう。 マーケティングの誰かさんが経 営陣に「もっとウェブっぽい UIに変更すべきですよ」 と言ったとする。 さあ、あなたならどう する? というか、マーケティングの人にそんなことを言い出される前に、 アーキテクトとし て何かできることはなかっただろうか?

アーキテクトとしては、ビジネスルールとUI を切り離しておくべきだった。 Q社のアーキ テクトが実際にそうしていたかどうかは知らない。 できることなら、 実際のところはどうだっ たのかを聞いてみたいものだ。 もし私がその当時のQ社にいたら、何としてでもビジネスルー ルを GUIから切り離しておこうとしただろう。 マーケティングの奴らが次に何を言い出すかな んて、知りようがないからだ。

次に、A社のことを考えてみよう。 A社は、人気のスマホを作っている企業だ。 A社は最近、 スマホ用 「オペレーティングシステム」 の新しいバージョンをリリースした (電話のオペレー

266

結論

ティングシステムというのはちょっと不思議な感じだ)。 この新しいリリースで、 既存のアプリ ケーションの見た目は大きく変わってしまった。 なぜそんなことに? マーケティングの奴ら が言い出したのだろう。

私はスマホのソフトウェアの世界にあまり詳しくないので、A社のデバイス向けのアプリを 開発している人たちが、 今回のアップグレードでどれだけつらい目にあうのかはわからない。 A社のアーキテクトとアプリ開発会社のアーキテクトたちには、ぜひビジネスルールとUIを 切り離しておいてもらいたいものだ。 マーケティングの奴らはいつも、ビジネスルールとUI を 一体化したがるのだから。

結論

結論はシンプルだ。 GUIは詳細である。 ウェブはGUIである。 したがって、 ウェブは詳細 である。 アーキテクトとしては、こうした詳細をビジネスロジックの中心から切り離しておき たい。

こんなふうに考えてみよう。 ウェブは入出力デバイスの一種である。 我々は、デバイスに依 存しないアプリケーションを書くことを60年代に学んだ。 その考えは今も生きている。 ウェブ だって例外ではない。

「ウェブも含めて GUIは独特でリッチなものだから、デバイスに依存しないアーキテクチャを 追求するのは無理があるんじゃないの?」

そんな声が聞こえてくる。 JavaScript によるバリデーション、 Ajax によるドラッグアンドド ロップ、ウェブページに配置するウィジェットやガジェットなどの複雑さを考えると、「デバイ ス非依存は実用的ではない」 と言ってしまうことができるなら、これほど簡単な話はない。

ある意味、それも間違いではない。 アプリケーションと GUI のやり取りは、 GUI の種類に特 化した方法で行われている。 ブラウザとウェブアプリの間で踊るダンスは、デスクトップアプ リと GUI の間で踊るダンスとは違ったものになる。 ダンスを UNIX のデバイスファイルのよう に抽象化しようとしても、 おそらく無理だ。

しかし、 UI とアプリケーションの間には別の境界もあり、そちらは抽象化できる。 ビジネス ロジックはユースケースの集まりである。 それぞれのユースケースは、ユーザーに代わって何 らかの機能を実行する。 個々のユースケースは、入力データ、 実行する処理、出力データにも とづいて記述できる。

UIとアプリケーションの間のダンスのどこかに、入力データが完成してユースケースが実行 可能になるところがある。 実行が終わると、 できあがったデータがUIとアプリケーションの間 のダンスに戻ってくる。

267

第31章 ウェブは詳細

完成した入力データや結果となる出力データを何らかのデータ構造に格納すれば、 ユースケー スを実行するプロセスの入力値および出力値として利用できる。 このやり方であれば、 個々の ユースケースがデバイスに依存せずに10デバイスを操作していると考えられる。

まとめ

このような抽象化は簡単ではないし、 適切な抽象化のためには試行錯誤が必要になるだろう。 だが、不可能ではない。 この世界には怪しげなマーケティングの奴らが満ちあふれている。 抽 象化が必要になる場面はいくらでも見つかるだろう。

268

フレームワークは詳細 32

CITY HALL

CITY HALL

Opening

Soon!

フレームワークが広く使われるようになってきた。 悪いことではない。 自由に使えて強力で 便利なフレームワークはたくさん存在する。

しかし、フレームワークはアーキテクチャではない。 なかにはそうであろうとしているもの もあるが、それでもやはりアーキテクチャではない。

フレームワークの作者たち

フレームワークの作者の多くは、 自作のフレームワークをフリーで公開している。 コミュニ ティの役に立ちたい、そして恩返しをしたいと思っているからだ。 称賛すべきことだ。 しかし、 いくら作者の意識が高くても、 彼らはあなた自身の思いを受け止めてはくれない。 彼らはあな たのことを知らないし、 あなたが何に困っているのかも知らないからだ。

フレームワークの作者が知っているのは、作者自身 同僚・友人が抱える問題だ。 そして、彼 らの問題を解決するためにフレームワークを作っている。 決してあなたのためではない。

269

第32章 フレームワークは詳細

もちろん、あなたが抱える問題と作者たちの抱える問題に重なるところはあるだろう。 そう でもなければ、フレームワークがここまで流行することはなかった。 重なる部分がそれなりに あるのであれば、フレームワークは便利なものだ。

一方的な結婚

あなたとフレームワークの作者との関係は、極めて不釣り合いである。 あなたは作者に対し

てかなりのコミットメントを求められるが、 作者はあなたに対して何の義務も負う必要がない。 この点についてもう少し考えてみよう。 何かのフレームワークを使おうとしたときに、あな たは作者が書いたドキュメントを読むだろう。 そのドキュメントに書かれているのは、 あなた のソフトウェアをそのフレームワークに統合するための、作者やほかのユーザーからのアドバ イスだ。 通常は、 あなたのアーキテクチャをそのフレームワークでラッピングする方法が紹介 されている。 おそらく作者たちは、フレームワークのクラスの派生クラスを作り、 その機能を ビジネスオブジェクトに組み込むことを推奨するだろう。 アプリケーションとフレームワーク を可能な限り結合させようとするのである。

作者にとって、フレームワークとの結合には何のリスクもない。 むしろフレームワークとの 結合を望んでいる。 作者自身はそのフレームワークを好きなようにコントロールできるからだ。 さらに作者は、あなたに対してもフレームワークとの結合を望んでいる。 一度でも結合して しまえば、切り離すのはとても難しくなるからだ。 フレームワークの作者にとって、 自分の作っ た基底クラスを大勢のユーザーが継承することほど、自尊心が満たされることはない。

作者は我々に対して、フレームワークとの結婚を申し込んでいる。 長期的なコミットメント を求めているのだ。 しかし、いかなる状況においても、作者から我々に何らかの約束をするこ とはない。 一方的な結婚だ。 すべてのリスクと負担を背負うのは我々であり、 フレームワーク の作者は何ひとつ背負うことはない。

リスク

フレームワークにはどんなリスクがあるのだろうか。 ここでいくつか挙げてみよう。

●フレームワークのアーキテクチャに難があることが少なくない。 一般に、フレームワーク は依存性のルールに違反する傾向がある。 フレームワークのコードを継承してビジネスオ ブジェクト (つまりエンティティ) に組み込めだなんて、とんでもない! フレームワー

270

クの作者は、円の最も内側にフレームワークを結合させたがっている。 一度入り込んでし まえば、それを取り外すことはできなくなる。 一度はめた結婚指輪は、ずっとあなたの指 に残り続けるのだ。

●アプリケーションを作り始めた頃は、フレームワークが助けになってくれるだろう。 しか し、プロダクトが成長するにつれて、 フレームワークの提供する機能では手に負えなくなっ てくる。 結婚指輪をはめたままでいると、 フレームワークに邪魔されてばかりいる自分に 気づくだろう。

●フレームワークが進化する方向が、 あなたの望む道からずれてしまうかもしれない。 自分に とって何の利益にもならない新バージョンへのアップグレードには躊躇するだろう。 便利 に使っていた機能が突然廃止されてしまったり、仕様変更されてしまったりすることだっ てあり得る。

●優れたフレームワークを見つけたときに、 乗り換えたくなる可能性がある。

解決策

これらのリスクへの対処法は?

フレームワークなんかと結婚するな !

おっと、 フレームワークを使うことは問題ない。 ただし、 結合しないことが大切だ。 フレー ムワークとは一定の距離を保つこと。 フレームワークは、アーキテクチャの円の外側にあるも のとして扱おう。 円の内側に組み込んではいけない。

フレームワークの基底クラスからビジネスオブジェクトを派生させることを求められても、 断ること。 その代わり、プロキシを用意して、 そのプロキシを含めたコンポーネントをビジネ スルールにプラグインすればいい。

フレームワークをコアのコードに混ぜないこと。 フレームワークはコンポーネントにまとめ て、コアのコードにプラグインしよう。 そうすることで、依存性のルールを守れるはずだ。 みなさんが大好きなSpring を例に考えてみよう。 Spring はDIフレームワークとしてよくで

きている。 おそらくあなたも、 Spring を使って依存性を自動ワイヤリングしているだろう。 そ れは別に構わない。 だが、 ビジネスオブジェクト全体にautovired アノテーションをちりばめ

てはいけない。 ビジネスオブジェクトがSpring について知るべきではないのだ。 そうではなく、 Spring を使って Main コンポーネントに依存性を注入しよう。 Main コンポー

解決策

271

フレームワークは詳細

ネントがSpringについて知っていることは何の問題もない。 Main はアーキテクチャのなかで 最下位レベルのコンポーネントだからだ。

今あなたたちを夫婦として宣言する

どう考えても断するしかないようなフレームワークもある。 C++を使っているなら STL は 使わざるを得ないだろう。 STL を避けて通るのは難しい。 Java を使う場合なら、ほぼ間違いな <標準ライブラリを使うことになるだろう。

ごく当たり前のことだ。 しかし、そういう決断をしたということに変わりはない。 自分のア プリケーションで何らかのフレームワークを使うことに決めた時点で、そのアプリケーション はフレームワークに縛られることになるのだと認識しておく必要がある。 幸いのときも、災い のときも、豊かなときも、貧しいときも、健やかなるときも、 病めるときも、ほかのすべてを 犠牲にしてでも、そのフレームワークを使うことになる。 気軽に受け入れられるようなもので はない。

まとめ

フレームワークに出会ったら、すぐに結婚しようとしてはいけない。 その前に何らかの方法 で時間稼ぎができないかを考えよう。 フレームワークは、 アーキテクチャの境界から可能な限 遠ざけるようにしよう。 牛一頭を購入する以外にもミルクを得る手段はあるはずだ。

272

事例: 動画販売サイト 33歳

KONKE

VCR TAPES

これまでに学んだアーキテクチャに関するルールや思想を実際の事例に当てはめてみよう。 この事例はシンプルで短いものだが、優れたアーキテクトが使う手順や判断について知ること ができるだろう。

プロダクト

この事例のために、私にとってなじみのあるプロダクトを選んだ。 動画を販売するウェブサイト のソフトウェアだ。 お察しのとおり、私がチュートリアル動画を販売している cleancoders.com を思い起こさせるものだ。

基本的なアイデアは単純なものだ。 我々は、 販売したいと思っている動画を持っている。 こ を、ウェブ上で個人や法人に販売する。 個人向けには、ストリーミング視聴用の価格と、 ダ ウンロード用の少し高めの価格を用意している。 ダウンロードした動画は、 その後無期限で視 聴できる。 法人向けのライセンスはストリーミング視聴限定で、 ある程度のライセンスを一括

273

第33章 事例:動画販売サイト

購入する場合は割引価格が適用される。

個人向けの販売のほとんどは、購入者と視聴者が同一人物だ。 一方、法人向けの販売では、動 画を購入する人と視聴する人が別であることが多い。

動画の作者は、動画ファイルとその説明文に加えて、 試験や練習問題、ソースコードなどの 資料を付属ファイルとして提供する必要がある。

管理者は、新しい動画シリーズを追加したり、 動画シリーズに動画を追加したり、各種ライ センス価格を設定したりする必要がある。

システムの最初のアーキテクチャを決めるための第一歩は、アクターとユースケースを見つ けることだ。

ユースケース分析

典型的なユースケース分析を図33-1に示す。

アクターの4つについては自明だろう。 単一責任の原則 (SRP) の観点からは、これら4つ のアクターがそれぞれ、 システムにおける変更の主な要因になる。 新しい機能を追加したり既 存の機能に手を加えたりするときには、いずれかのアクターにあてはまる。 システムを分割す るときには、あるアクターへの変更がほかのアクターたちに影響を及ぼさないようにしておき たい。

図33-1に示すユースケースがすべてではない。 たとえば、ログインやログアウトのユース ケースが見当たらない。 そのあたりを省略した理由は、単に本書で扱いきれる範囲に問題を絞 りたかったからだ。すべてのユースケースを含めてしまえば、本章だけで一冊の書籍になって しまうだろう。

図33-1 の中央にある点線のユースケースに注目しよう。 これらは抽象「ユースケースだ。 抽 象ユースケースは全般的な方針を定めたもので、別のユースケースがそれに肉付けする。「視聴 者としてカタログを閲覧する」 と 「購入者としてカタログを閲覧する」はどちらも、 抽象ユー スケースの 「カタログを閲覧する」 を継承している。

個人的には、この手の抽象化が必須であるとは思わない。 抽象ユースケースをこの図から追 い出しても、プロダクト全体の機能に何らかの妥協が必要になることはないだろう。 ただ、こ れら2つのユースケースはとても似ているので、早い段階で共通点を認識して共通化の道を探 るのが得策だと考えた。

1 これは 「抽象」 ユースケースを表す私独自の記法だ。 <<abstract >> のように UML のステレオタイプを使うのが一般的 だが、この標準に従うメリットはそんなにないと考えている。

274

コンポーネントアーキテクチャ

MP4を 登録する ダウンロード ライセンスを 購入する 試験を ストリーミング 登録する ライセンスを 購入する ライセンスを 購入する 作者 動画の説明文 を登録する 新しいシリーズ を追加する シリーズに動画 を公開する 管理者 カタログを 閲覧する 法人ライセンスを 購入する 購入者として カタログを 閲覧する 視聴者として カタログを 閲覧する 動画を ストリーミング 視聴する シリーズから動画 を削除する 動画を ダウンロード する ライセンス価格 を設定する 購入者 視聴者

図33-1

典型的なユースケース分析

コンポーネントアーキテクチャ

アクターとユースケースがわかったので、とりあえずのコンポーネントアーキテクチャを検 討できるようになった (図33-2)。

中の二重線は、 アーキテクチャの境界を表している。 ビュー プレゼンター、インタラク ター、コントローラーといった、 よく見る切り分けになっていることがわかる。 さらに、 対応 するアクターごとに分割している様子もわかる。

図33-2の個々のコンポーネントは、 おそらく.jar ファイルや.d11 ファイルになるだろう。 このなかには、それぞれのコンポーネントに割り当てたビュー、プレゼンター、インタラクター、 コントローラーが含まれる。

ここで、 Catalog View と Catalog Presenter という特別なコンポーネントがあることに注

275

第 33 章 事例 動画販売サイト

目してほしい。 抽象ユースケースの「カタログを閲覧する」 をこれらのコンポーネントで表し た。 ビューやプレゼンターをこれらのコンポーネントの抽象クラスとしてコーディングして、 継承先のコンポーネントからその抽象クラスを継承して使うことを想定している。

Admin Admin Admin Views Presenters Interactors uthor Views Author Presenters Author Interactors Purchaser Views Catalog View Viewer Views Purchaser Presenters Viewer Presenters Catalog Presenter Admin Controllers Author Controllers Purchaser Interactors Purchaser Controllers Viewer Interactors Viewer Controllers Revenue Gateways Data Gateways Database (Datomic)

図33-2

最初の段階のコンポーネントアーキテクチャ

さて、 本当にシステムをこのように分割して、 コンポーネントを.jar や.dll としてデリバ リーするのだろうか? 答えはイエスでもありノーでもある。 コンパイルやビルドの環境はそ のように構築するだろう。 だから、 各コンポーネントを個別にデリバリー可能な成果物にしよ うと思えばできる。 ただ、必要に応じてコンポーネントをとりまとめて、もう少し大きな単位 でデリバリーする選択肢も残しておきたい。 図 33-2のような分割をしたときに、ビュー プレ ゼンター、インタラクター、コントローラー、ユーティリティの5つの.jarファイルにまとめ るのも簡単だ。 これで、変更の理由が異なるコンポーネントを他から切り離してデプロイでき るようになる。

ビューとプレゼンターをひとつの.jar ファイルにまとめて、 そのほかのインタラクター、コ ントローラー、ユーティリティはそれぞれ個別の.jar にする方法も考えられる。さらに、昔 ながらのやり方として、ビューとプレゼンターをまとめた. jar と、 そのほかすべてをまとめ た.jar の2つだけにしてしまうこともできる。

これらの選択肢を選べる状況を維持しておけば、今後システムに変更があったときにも、デ

276

まとめ

ロイ方法を柔軟に変更して対応できるようになる。

存性管理

図 33-2の制御の流れは、 右から左へ進む。 コントローラーから受け取った入力をインタラク が処理する。 その結果を受け取ったプレゼンターが結果をフォーマットして、 ビューがそ を表示する。

矢印の向きが必ずしも右から左へ向かっているわけではないことに注目しよう。 左から右へ 向かっている矢印のほうが多いくらいだ。 そうなっている理由は、依存性のルールに従ってい るからだ。 二重線を越える矢印はすべて同じ向きになっていて、 常に上位レベルの方針を含む コンポーネントに向かっている。

また、 使用の関係 (通常の矢印) は制御の流れと同じ向きなのに対して、継承の関係 (白抜 きの矢印) は制御の流れと逆向きであることもわかる。 これは、オープン・クローズドの原則 (OCP) に従った結果だ。 依存性の向きを正しい方向にすることで、下位レベルの詳細が変わっ ても上位レベルの方針には影響しないようにしているのだ。

図33-2のアーキテクチャ図には、2つの観点での分割が含まれている。 単一責任の原則 (SRP) にもとづくアクターによる分割と、 依存性のルールによる分割である。 どちらの分割も、変更 の理由や頻度が異なるものを分離することが目的だ。 変更の理由に対応するのはアクターによ る分割で、変更の頻度に対応するのは方針のレベルの違いである。

コードの構成をこのようにしておけば、システムをデプロイするときにも思いどおりに進め られるようになる。 デプロイ可能な単位でコンポーネントをまとめることができるし、仮に状 況が変わったとしても、 コンポーネントのまとめ方を変更しやすい。

まとめ

277 27



書き残したこと 第34号

?

執筆: Simon Brown

ここまでのアドバイスを参考にすれば、優れたソフトウェアを設計できるようになってい はずだ。 クラスやコンポーネントは明確に切り分けられていて、それぞれの責務も明確で、依 存性もきちんと管理できるようになっていることだろう。 しかし、悪魔は実装の詳細に宿る。 気をつけておかないと、 最後の最後でつまずいてしまう。

たとえば、 オンライン書店を構築しているとしよう。 今から実装するユースケースは、顧客 から注文のステータスを見られるようにするというものだ。 サンプルはJava を想定している が、考え方はほかの言語でも同じように適用できる。 クリーンアーキテクチャはしばらく横に 置いておいて、 設計やコーディングに関するそのほかのアプローチを見ていこう。

279

第34章 書き残したこと

レイヤーによるパッケージング

真っ先に思いつく、おそらく最もシンプルなアプローチは、 昔ながらの水平方向のレイヤー ドアーキテクチャだ。 これは、技術的な役割にもとづいてコードを分割するものだ。 「レイヤー によるパッケージング」 と呼ばれることもある。 図34-1は、これを UML のクラス図のような 感じで表したものだ。

典型的なレイヤードアーキテクチャは、ウェブのコード用のレイヤーと、 「ビジネスロジッ ク」用のレイヤーと、永続化レイヤーを用意するものだ。 コードを水平方向のレイヤーに切り 分けて、同じようなものたちをそれぞれのレイヤーにまとめる。 「厳格なレイヤードアーキテ クチャ」では、それぞれのレイヤーは隣接する下位レイヤーだけに依存すべきだとされている。 Java では、レイヤーをパッケージとして実装することが多い。 図 34-1に示すとおり、 レイヤー (パッケージ) 間の依存性はすべて下向きになる。 この例では以下のJava クラスを用意した。

• OrdersController: Spring MVC コントローラーのようなウェブコントローラー。 ウェブ からのリクエストを処理する。

●OrdersService : 注文に関する 「ビジネスロジック」を定義するインターフェイス。 ●OrdersServiceImpl: サービスインターフェイスの実装。

●OrdersRepository : 永続化された注文情報へのアクセス方法を定義するインターフェイス。 JdbcOrdersRepository リポジトリインターフェイスの実装。

Martin Fowler は 「Presentation Domain Data Layering」 2 で、最初はレイヤードアーキテ クチャに従うのが得策だと言っている。 彼だけではない。 多くの書籍やチュートリアルや研修 やサンプルコードが、 同じようにレイヤードアーキテクチャを推奨している。 とりあえず動く ものを複雑になりすぎないように手早く作るには、これは優れた方法だ。 ただし、問題もある。 Martin Fowler も指摘するように、ソフトウェアの規模が大きくなり複雑化すると、コードを3 つの巨大なバケツに分けるだけでは手に負えなくなってくる。 そして、もう少し細かいモジュー ル化を考えなければいけなくなる。

別の問題もある。 すでにアンクル・ボブも指摘しているとおり、 レイヤードアーキテクチャ はビジネスドメインに関して何も叫ばない。 まったく異なる2つのビジネスドメインのコード をそれぞれレイヤードアーキテクチャにして並べてみると、 気味が悪いほどそっくりになる。 ウェブ、サービス、そしてリポジトリだ。 さらに、別の重大な問題もあるが、これについては

ふざけた命名規則だとは思うが、あとで見るとおり、これはそんなに重要な問題では2 https://martinfowler.com/bliki/PresentationDomainDataLayering.html

ない。

280

機能によるパッケージング

OrdersController com.mycompathy.myapp.web <<50> conterface OrdersService △△ Orders Servicelmpl com.mycompany.myapp. service <A> <<interface>> Orders Repository JdbcOrders Repository com.mycompany.myapp.data

図34-1 レイヤーによるパッケージング

後ほど説明する。

機能によるパッケージング

コードのとりまとめ方に関する別の手法として「機能によるパッケージング」 がある。 これ は垂直方向での切り分けだ。 関連する機能、 ドメインの概念、 (ドメイン駆動設計の用語で言う なら) 集約ルートにもとづいて分割する。 これまでの経験からすると、 すべての型をひとつの Java パッケージにまとめて、その概念を表すパッケージ名を付けることが多かった。

このアプローチの場合も、登場するクラスやインターフェイスは先ほどと同じだ (図 34-2)。 しかし、 それらを3つのJava パッケージに分けるのではなく、 すべてを1つのパッケージにま

281

第34章 書き残したこと

とめている。 先ほどの「レイヤーによるパッケージング」 を少しだけリファクタリングしたも のだが、トップレベルのコードの構成がビジネスドメインについて叫ぶようになった。 ウェブ、 サービス、 リポジトリといったものではなく、注文に関する何かをするものであることがわか るようになった。 別のメリットもある。 仮に 「注文を閲覧する」 ユースケースに何らかの変更 があったとしても、こちらの構成のほうが修正すべきコードを把握しやすい。 あちこちのバッ ケージに散らばっているのではなく、1つのパッケージにまとまっているからだ。

Orders Controller <<use <dinterface>> OrdersService Orders ServiceImpl <dinterface>> Orders Repository JdbcOrders Repository

com.mycompany.myapp.orders

図34-2 機能によるパッケージング

3 いまどきの IDEの機能を考えるとありがたみは薄れるかもしれないが、年寄りから見ると、軽量なテキストエディター への回帰があるように思える。

282

ポートとアダプター

水平方向のレイヤーリング (レイヤーによるパッケージング)でうまくいかなくなったソフ トウェア開発チームが、 垂直方向のレイヤーリング (機能によるパッケージング) に切り替える 事例をよく見かける。 だが、個人的にはどっちもどっちだと思っている。 本書をここまで読ん できたみなさんなら、もっといいやり方があるのではないかと思うことだろう。 そのとおりだ。

ポートとアダプター

アンクル・ボブは「ポートとアダプター」 「ヘキサゴナルアーキテクチャ」 「BCE」 などの手法 を挙げている (第22章)。 これらの狙いは、 ビジネス (ドメイン) に関するコードを技術的な 実装 (フレームワークやデータベース) から切り離して独立させることだ。 「内側 (ドメイン)」 と 「外側 (インフラストラクチャ)」 の構成にした、 図34-3のようなコードベースがよく見ら れる。

インフラストラクチャ ドメイン

図34-3 内側と外側に分けたコードベース

「内側」に含まれるのはドメインの概念、 「外側」 には外部の世界とのインタラクション(UI、 データベース、サードパーティとの統合など) を含める。 大原則は「外側が内側に依存するよ うにせよ。 その逆は許さない」である。 「注文を閲覧する」 ユースケースをこの方式で実装した 図34-4 に示す。

com.mycompany.myapp.domain パッケージが 「内側」 で、 それ以外のすべてのパッケージが

283

第34章 書き残したこと

「外側」にあたる。 依存性が 「内側」 に向かっていることに注目しよう。鋭い人なら、 先ほどの 図では OrdersRepository だったものが、ここでは Orders というシンプルな名前に変わってい ることにも気づくだろう。 ドメイン駆動設計の世界では、 「内側」に属するものはすべて「ユビ 「キタス言語」 で名付けることが推奨されているからだ。 このドメインの会話は、「注文」 につい て語るのであって、「注文リポジトリ」 について語るわけではない。

Orders Controller com.mycompaphy.myapp.web <<uses>> ' <dnterface>> Orders Service OrdersServiceImpl <<uses>> <dinterface>> Orders com.mycompany.myapp.domain JdbcOrders Repository com.mycompany.myapp.database

図34-4 「注文を閲覧する」 ユースケース

284

コンポーネントによるパッケージング

最後にこれだけ指摘しておきたいのだが、これはUMLのクラス図のようなものを簡略化し た図だ。というのも、依存性の境界を越えてデータをやり取りするためのインタラクターやオ ブジェクトが欠けているからだ。

コンポーネントによるパッケージング

本書の SOLID 原則、再利用 リリース等価の原則 (REP)、 閉鎖性共通の原則 (CCP)、 全再 利用の原則 (CRP) などのアドバイスには同意するが、 私は最終的に少し違う結論に達した。 「コンポーネントによるパッケージング」と名付けたこの手法について、 ここで紹介しよう。 ち なみに私は、これまでのキャリアの大半を Java による業務ソフトウェア開発に費やしてきた。 特定のビジネスドメインだけではなく、 さまざまなビジネスドメインに関わってきた。 これま でに作ってきたソフトウェアは、バラエティーに富んでいる。 ウェブベースのものが多いが、 ク ライアントサーバー型のものもあれば、 分散型のものもあり、メッセージベースのものもあれ ば、それ以外のものもあるといった具合だ。 使われている技術は違えど、 共通する部分もあっ た。 これまでに関わってきたソフトウェアの大半は、 昔ながらのレイヤードアーキテクチャを 採用していたのだ。

レイヤードアーキテクチャの問題点を先ほどいくつか説明したが、あれだけがすべてではない。 レイヤードアーキテクチャの目的は、 同じ種類の機能を持つコードを切り離すことだ。 ウェブの コードはビジネスロジックから切り離し、ビジネスロジックをデータアクセスのコードから切り 離す。 先ほどの UML のクラス図を見ればわかるが、 実装の観点では、レイヤーはJavaのパッ ケージに相当する。 コードのアクセス制御の観点では、 OrdersController が OrdersService インターフェイスに依存するためには、OrdersService インターフェイスを public にする必 要がある。別々のパッケージに属しているからだ。 同じく、 OrdersRepository インターフェイ スも public にしなければいけない。 リポジトリパッケージの外部にある OrdersServiceImpl クラスからもアクセスする必要があるからだ。

厳格なレイヤードアーキテクチャでは、依存性の矢印は常に下位に向かう。 また、 各レイヤー は次の下位レベルのレイヤーにしか依存することができない。 これを守ることで、クリーンで よくできた非循環依存グラフが完成する。 そのためには、コードベースの要素がほかの要素に 依存する際のいくつかのルールを守る必要がある。 ここに大きな問題がある。 ズルをして好ま

1996年に大学を卒業したあと最初にした仕事は、 PowerBuilder を使ったクライアントサーバー型デスクトップアプリ ケーションの開発だった。 PowerBuilderは高い生産性を誇る第四世代言語で、データベースを使うアプリケーションの 構築を得意としていた。その数年後、別のクライアントサーバー型アプリケーションを Java で作ることになった。この ときはデータベース接続処理を自作して (まだJDBCなどない頃の話だ)、自前のGUIツールキットを AWT上に作るは めになった。 これが 「進歩」 ってことだ!

285

第34章 書き残したこと

しくない依存性を組み込んでしまっても、きれいな非循環依存グラフが残されたままになるこ とだ。

チームに新しく加わったメンバーに、注文がらみの別のユースケースの実装を依頼したとす る。 自分の実力を見せてやろうと意気込んだ彼は、少しでも早く実装を済ませようとするだろう。 コーヒー片手に自席についた数分後、彼は OrdersController クラスを発見する なるほど。 注文関連のウェブページはこのクラスに書けばいいのだなと判断した。 だが、 注文関連のデー タをデータベースから持ってくる必要がある。 彼はひらめいた。 「すでに OrdersRepository イ ンターフェイスができあがってるじゃない。 要するに、DIで実装をコントローラーに注入すれ ばいいだけでしょ。 カンペキ!」 数分後、 ウェブページは動き出した。 ただ、この時点でUML は図34-5のようになってしまった。

依存性の矢印はすべて下向きではあるが、ユースケースによっては OrdersController が OrdersService を飛び越えるようになってしまった。 このような構成は緩いレイヤードアーキ テクチャと呼ぶことが多い。 次のレイヤー以外への依存も許しているからだ。 意図的にこのよ うにする場合もある。 たとえば、 CQRSパターンを使おうとしたら、 このようになるだろう。 しかし、それ以外の場合には、次のレイヤーを飛び越えた依存は望ましくない。 たとえば、 ビ ジネスロジックがレコードへのアクセス許可の責務を負っている場合に、ビジネスロジックを 飛び越えてしまうようなことは望ましくない。

新しいユースケースはとりあえず動いているようだが、 おそらく我々が期待していた実装と は異なる。 私がコンサルとして参加していたチームでも、こういうことがよくあった。 チーム がコードベースの現状を可視化し始めてから、ようやくそれに気づくことが多かった。

ここで必要なのは何らかのガイドライン、つまり「ウェブコントローラーはリポジトリに直 接アクセスしてはいけない」 のようなアーキテクチャの原則だ。 ただ、これをどうやって守ら せるのかが問題になる。 今まで関わってきたチームはたいてい「うちの開発者はきちっとして いるし、 コードレビューもやっているので大丈夫ですよ」などと言う。 信じるのは勝手だが、 予算や納期が迫ってきたときに何が起こるかは、 みなさんもよくご存じだろう。

少ないながらも、ビルド時に静的解析ツール (NDepend や Structure 101 や Checkstyle など) を使ってルール違反をチェックしているというチームもあった。 あなたも見たことがあるかも しれない。 その手のツールは、 正規表現やワイルドカード文字列を使って 「types in package ** / web should not access types in **/data」 のような設定をする。 そして、コンパイル後に これを実行する。

多少原始的ではあるが、チームとして定めたアーキテクチャの原則に違反しているときれを報告し、必要ならばビルドを失敗させるようにもできる。 メンバーを信じる場合にも

にそ ツー

5 CQRS (コマンドクエリ責務分離)は、データの更新とデータの読み込みを切り離すパターンである。

286

コンポーネントによるパッケージング

OrdersController

com.mycompany.myapp.web

<<Use$>>

<<interface>> Orders Service

OrdersServiceImpl

<<uses>>

com.mycompany.myapp.service

<<uses>>

<<interface>>

Orders Repository

JdbcOrders Repository

com.mycompany.myapp.data

図 34-5 緩いレイヤードアーキテクチャ

ルを活用する場合にも、共通した問題がある。 それは、誤りを犯しやすいことと、フィードバッ クループが長くなってしまうことだ。 チェックしないまま見過ごしてしまうと、コードベース が「大きな泥だんご」になってしまう。 個人的には、可能であればコンパイラを使ってルール を守らせるようにしておきたい。

ここで登場するのが「コンポーネントによるパッケージング」 という選択肢だ。 これは、今

6 http://www.laputan.org/mud/

287

第34章 書き残したこと

までのすべての手法のいいとこ取りをしたもので、 粒度の粗いコンポーネントに関連するすべ ての責務をひとつの Java パッケージにまとめることを目指すというものだ。 ソフトウェアシス テムをサービス中心で捕らえた考え方で、マイクロサービスアーキテクチャにも同様のものが 見られる。 「ポートとアダプター」 が、ウェブを単なるデリバリーメカニズムとして扱っている のと同じで、 「コンポーネントによるパッケージング」もユーザーインターフェイスを粒度の粗 コンポーネントから切り離している。 図34-6に 「注文を閲覧する」 ユースケースの様子を 示す。

要するに、「ビジネスロジック」 と永続化コードをひとつにまとめて 「コンポーネント」にす る手法だ。 アンクル・ボブによる「コンポーネント」の定義は、第12章で以下のように示され ている。

コンポーネントとは、デプロイの単位のことである。 システムの一部としてデプロイできる、最小限 のまとまりを指す。 Javaなら jar ファイルがそれにあたる。

私の定義はこれとは微妙に違っていて、 コンポーネントは 「関連する機能をよくできたクリー ンなインターフェイスの向こう側に閉じ込めて、 アプリケーションなどの実行環境の内側に置 「いたもの」だと考えている。 この定義は私が定めた 「C4 ソフトウェアアーキテクチャモデル」7 に由来するものだ。 このモデルは、 コンテナやコンポーネントやクラス (コード) の観点から、 ソフトウェアシステムの静的構造を考えるシンプルで階層的な方法である。 ソフトウェアシス テムはいくつかのコンテナ(ウェブアプリケーション、モバイルアプリ、スタンドアロンアプリ ケーション、データベース、 ファイルシステムなど) で構成されている。 各コンテナはいくつか のコンポーネントから成り立っている。 各コンポーネントはいくつかのクラス(コード) から 成り立っている。 このコンポーネントの分割単位と jar ファイルの分割単位は連動していない。 「コンポーネントによるパッケージング」の大きな利点は、 もし注文に関するコードを書きたい のなら、 OrdersComponent だけを見ればいいという点だ。 コンポーネントでは関心事の分離が 保たれているので、ビジネスロジックとデータ永続化は切り離されている。 しかし、 それはあ くまでもコンポーネントの実装の詳細にすぎず、利用者が知る必要もないことだ。 これは、マ イクロサービスやサービス指向アーキテクチャを採用した場合とも似ている。 OrdersService が注文の処理に関するすべてをカプセル化しているようなものだ。 マイクロサービスやサービ ス指向アーキテクチャとの主な違いは、依存性を切り離す方法だ。 モノリシックなアプリケー ションのうまく作られたコンポーネントは、マイクロサービス化に向かう際の第一歩と見なす ことができるだろう。

詳細は https://www.structurizr.com/help/c4 を参照すること。

288

悪魔は実装の詳細に宿る

OrdersController com.mycompapy.myapp.web <<Use$>> <<interface>> OrdersComponent △ OrdersComponentimpl <<uses>> <<interface>> Orders Repository JdbcOrders Repository 4141 com.mycompany.myapp.orders

図34-6 「注文を閲覧する」 ユースケース

悪魔は実装の詳細に宿る

これまでの4つの手法は、 異なる方法でコードを整理しているように見える。 そのため、 そ れぞれ異なるアーキテクチャスタイルだと考えられる。 しかし、詳細の実装を間違えてしまう と、あっという間にその見立てが崩れてしまう。

よく見かけるのは、 Java のような言語で public アクセス修飾子を気軽に使いすぎることだ。

289

第34章 書き残したこと

開発者は何も考えず、本能的に public を使っているように見える。 おそらく体で覚えてしまっ ているのだろう。 ウソだと思うなら、 書籍のサンプルコード、チュートリアル、 GitHub で公開 されているオープンソースのコードを見てみればいい。 水平方向のレイヤーだろうが垂直方向 のレイヤーだろうが、ポートとアダプターだろうがそれ以外の何かだろうが、 アーキテクチャ スタイルがどんなものだろうが、その傾向が見られるはずだ。 すべてを public にするという ことは、せっかくプログラミング言語が提供してくれているカプセル化の仕組みを活用できて いないということだ。 具象実装クラスを直接インスタンス化するような、 アーキテクチャスタ イルに違反したコードを防ぐ手段が一切なくなってしまう。

組織化かカプセル化か

この問題を別の面から考えてみよう。 もし Javaアプリケーションですべての型を public に したら、パッケージは単なる組織化 (フォルダのようなグループ化) の手段でしかなくなり、も はやカプセル化はできなくなる。 public な型はコードベースのどこからでもアクセスできるの で、パッケージは事実上ないに等しい。 パッケージを使っても何のメリットもないからだ。 こ れらを踏まえると、(カプセル化にも情報隠蔽にも役立たない) パッケージを無視した時点で、 どのアーキテクチャスタイルを選ぶかなどはどうでもいい話になる。 これまでの UML の図を 見たときに、すべての型が public であれば、 Java のパッケージはどうでもいい話になってし まう。 つまり、 本章の前半で示した4つの手法は、すべてがまったく同じものになってしまう のだ (図34-7)。

図34-7の矢印についてもう少し詳しく見ていこう。4種類のうちどの手法を目指そうとも、 矢印の種類や向きはまったく同じになっている。 概念的にはまったく違うアプローチだが、 文 法的にはまったく同じ結果になった。 さらに、すべての型を public にすれば、昔ながらの水 平方向のレイヤードアーキテクチャを表現した4通りの異なる方法にすぎないとも言える。 巧 妙なトリックだ。もちろん、Java ですべての型を public にしようとする人などいないだろう。 だが、やろうと思えばできるし、 私は実際に見たことがある。

Java のアクセス修飾子は完ぺきではないが、だからといってそれを無視するのは自らトラ ブルを呼び込んでいるようなものだ。 Java の型をどのパッケージに入れるかを変えると、 アク セス制御を適切に行ったときに、 何が何にアクセスできる (あるいはできない)ようになるか が大きく違ってくる。 パッケージを元の状態に戻して、 アクセス制御をもう少し厳しくできる 部分に印をつける (色を薄くしてみる) と、 興味深い結果になる (図34-8)。

8 たとえばJavaの場合、パッケージを階層構造であると考えがちだが、パッケージの親子関係にもとづくアクセス制御を することができない。階層構造を作れるのは、パッケージ名とディレクトリ構造だけである。

290

組織化かカプセル化か

4141 conterface OrdersComponent edinterface OrdersRepository JdbeOrders Repository enterfac Orders OrdersComponentimpl 11-114 Orders Controller OrdersController OrdersController OrdersController interface Orders Service edinterface OrdersService A conterface OrdersService OrdersServiceimpl Orders Servicempl Orders ServiceImpl dinterface Orders Repository <<nterface>>> Orders Repository JdbcOrders Repository JdbcOrders Repository JdbcOrders Repository

図34-7 4 つのアーキテクチャの手法は結局同じになる

OrdersController OrdersController OrdersControlier OrdersController com.mycompany myapp web com.mycompany.myapp.web dnterface OrdersService Orders Serviceimpl com.mycompany myapp service interface Orders Repository JdbcOrders Repository com.mycompany myapp.data conterfac Orders Service Orders Service Orders Servicelmpi OrdersServicem OrdersComponent A Orders Orders Component interface Orders Repository com mycompany.myapp.domai JdbcOrders Repostory JdbcOrders Repository com.mycompany.myapp.orders com.mycompany.myapp. OrgerRepository +4-14-4-11

図34-8 グレーになっている部分は、 アクセス制御をもう少し厳しくできる

291

第34章 書き残したこと

左から順に見ていこう。 まず「レイヤーによるパッケージング」 では、 OrdersService イン ターフェイスと OrdersRepository インターフェイスを public にする必要がある。 インター フェイスを定義するパッケージの外部からインターフェイスへの依存があるからだ。 逆に、 実 装クラス(OrdersServiceImpl と JdbcOrdersRepository) はアクセス範囲をもう少し(パッ ケージレベルまで)絞り込める。 これらは実装の詳細であり、外部から知る必要のないものだ からだ。

「機能によるパッケージング」 の場合は、 OrdersController がこのパッケージへの唯一のエン トリーポイントになる。 そのため、 その他すべてのアクセス範囲はパッケージに絞り込める。 この方式で注意すべきなのは、パッケージの外部から注文関連の情報を知りたければ、 コント ローラーを経由するしかなくなるという点だ。 それが望ましい場合もあれば、望ましくない場 合もあるだろう。

「ポートとアダプター」 の場合は、 Orders Service インターフェイスと Orders インターフェ イスには外部からの依存があるので、 public にしておく必要がある。 実装クラスは、最初の方 式と同じようにパッケージレベルのアクセスで構わない。 依存性は実行時に注入される。

最後に「コンポーネントによるパッケージング」 を考えると、 OrdersComponent インターフェ イスにはコントローラーからの依存がある。 しかし、それ以外はすべてパッケージレベルのア クセスで構わない。 public の型を減らせば減らすほど、 依存性が生まれる可能性を減らせる。 これで、このパッケージの外側から OrdersRepository インターフェイスを使ったり、実装ク ラスのインスタンスを作ったりする手段はなくなった。 この状態なら、 アーキテクチャの原則 を守っているかどうかのチェックをコンパイラに任せられる。 .NET なら internal で同じこと ができるが、コンポーネント単位で別のアセンブリを作る必要がある。

はっきりさせておきたい。 今ここで説明しているのは、すべてのコードがひとつのソースツ リーに属するようなモノリシックなアプリケーションに関する話だ。 あなたが作っているアプ リケーションがこのタイプのものであるなら (そんな人は少なくないだろう)、 アーキテクチャ の原則を守らせるのはコンパイラ任せにすることをお勧めする。 メンバーの自制心に頼ったり、 コンパイル後にツールでチェックしたりするより、 そのほうがずっといい。

そのほかの分割方法

プログラミング言語の機能を使う以外にも、ソースコードの依存性を分離する方法はある。 た とえば Java なら、OSGi のようなモジュールフレームワークが使えるし、 Java 9 で導入された

9 Java のリフレクションを使ってごにょごにょすればできなくもないが、頼むからそんなことはしないでほしい!

292

そのほかの分割方法

モジュールシステムも使える。 モジュールシステムをうまく活用すれば、 public と published をきちんと区別できるようになる。 たとえば、 Orders モジュールの型をすべて public にする が、外部から使えるのはその一部だけにするといった設定ができる。 待ちに待っていた機能だ。 だが、 私が最も喜んでいるのは、 Java 9 のモジュールシステムを活用して、 よりよいソフト ウェアを作るためのツールが生まれること、そして開発者の設計に対する興味を再び呼び起こ すきっかけになることだ。

別の選択肢もある。 依存性をソースコードレベルで切り離す方法で、具体的にはコードをそ れぞれ別のソースコードツリーに分割する。 「ポートとアダプター」の例の場合なら、以下の3 つのソースコードツリーを用意すればいい。

●ビジネスやドメイン (フレームワークや技術に関するもの以外) 用のソースコード OrdersService, OrdersServiceImpl. Orders

●ウェブ用のソースコード: OrdersController

データ永続化用のソースコード:JdbcOrdersRepository

後者の2つのソースコードツリーは、コンパイル時にビジネスやドメインのコードに依存す る。 一方、ビジネスやドメインのソースコードツリーは、ウェブやデータ永続化のコードについ て一切関知しない。 実装面では、これを実現するにはビルドツール (Maven、 Gradle, MSBuild など)のモジュールやプロジェクトを適切に分割すればいい。 理想を言えば、アプリケーショ ンのコンポーネントごとに、 別々のソースコードツリーを持つようにしておきたい。 しかし、 あくまでも理想的な解決策であって、 あまり現実的ではない。 この方式でソースコードを分割 すればするほど、パフォーマンスが問題になるし、 複雑度も増すし、 保守も面倒になるからだ。 「ポートとアダプター」方式を使っている人のための、もう少しシンプルなアプローチもある。 以下の2つのソースコードツリーを用意するというものだ。

ドメインのコード (「内部」) インフラストラクチャのコード (「外部」)

これは「ポートとアダプター」 アーキテクチャの説明でよく使われる図 (図34-9)にもうま く対応していて、 コンパイル時にインフラストラクチャからドメインに依存することになる。 このアプローチによるソースコードの分割はうまく機能するだろうが、トレードオフについ ても認識しておく必要がある。 私はそれを 「ポートとアダプターにおける「ペリフェリック」 ア ンチパターン」と呼んでいる。 パリには、ブルヴァールペリフェリックと呼ばれる環状の高 速道路がある。 そのおかげで、 市内の複雑な道路に立ち入らなくてもパリ周辺を回れるように

293

第34章書き残したこと

インフラストラクチャ ドメイン

図34-9 ドメインとインフラストラクチャのコード

なっている。 インフラストラクチャに関するすべてのコードをひとつのソースコードツリーに まとめるということは、ウェブコントローラーのインフラストラクチャのコードから、ほかの 領域(データベースリポジトリなど)のコードをドメインを経由せずに、 直接呼び出せてしま う可能性があるということだ。 適切なアクセス修飾子を付け忘れたときにそうなりがちである。

まとめ: 言い残したこと

いくらうまい設計をしても、その実装方法の複雑さを考慮しなければ、あっという間に設計 が崩れてしまう。 これが本章のポイントだ。 あなたが望む設計をコードの構造にマッピングす る方法、そのコードをとりまとめる方法、 実行時とコンパイル時に依存性を分割する方法につ いて考えてみよう。 使える選択肢は可能な限り残しておきたいが、 理想に走りすぎてもいけな い。チームの規模やメンバーのスキルやソリューションの複雑さ、そして時間と予算の制約な どを考慮しよう。選んだアーキテクチャスタイルを守らせるためにコンパイラが使えるかどう かを検討して、 データモデルなどのほかの領域と結合してしまわないように注意しよう。 悪魔 は実装の詳細に宿るものだ。

294

第 付録 VII 部

295



アーキテクチャ考古学 A

優れたアーキテクチャの原則を掘り起こすべく、 45年間の旅に出ることにしよう。 1970年以 降に私が関わったプロジェクトのいくつかを紹介する。 そのなかには、 アーキテクチャ的な観 点で興味深いものもあれば、得られた教訓が興味深いものもあった。 また、 その後のプロジェ クトに与えた影響が大きいという点で興味深いものもあった。

この付録は、ある意味では自叙伝のようなものだ。 アーキテクチャに関する話題を中心に進 めようとは思っているが、 自叙伝的なものである以上、 ときには横道にそれることもある。 ;-)

組合の会計システム

1960年代後半、 ASC Tabulating 社は全米トラック運転手組合の第705支部に会計システムを 納める契約を結んだ。 ASC がこのシステムを構築するために選んだコンピュータはGE Datanet 3)だった (図A-1)。

297

付録A アーキテクチャ考古学

A-1 GE Datanet 30 (出典: Ed Thelen, ed-thelen.org)

ご覧のとおりの巨大なマシンだった。 ひと部屋まるごと使うほどの大きさだったし、部屋に は厳重な空調制御が必要だった。

集積回路が登場する前の時代のコンピュータだ。大量のトランジスタで作られている。一部 には、真空管が残っているところさえあった (テープドライブのセンスアンプに使われていた だけではあるが)。

現代の基準で言うなら、バカでかくて遅くてちゃちで原始的なものだった。 コアは16K × 18ビットで、 サイクルタイムは約7ミリ秒2。 空調が整った大きな部屋を埋め尽くす大きさだっ た。 7トラックの磁気テープドライブと、 容量 20MB程度のディスクドライブがついていた。

このディスクがまた化け物みたいなものだった。 その様子は図 A-2 で確認できるが、写真だ

けではこの化け物の大きさが伝わらないだろう。 このキャビネットの高さは私の身長を上回っ ていた。 ブラッタは直径36インチで、厚さは1枚3/8インチ。 1枚のブラッタを抜き出した写 真が図 A-3である。

| ASC で使っていたマシンに関して、こんな話を聞いたことがある。 それは大きなトレーラーに積み込んで運ばれてきた のだが、その途中に高速で走るトラックが橋に衝突した。 コンピュータは無事だったが、その衝突の勢いでコンピュー タが前へ移動したせいで、一緒に積まれていた家具が粉々になってしまったそうだ。

2 今風に言うなら、クロック周波数が12kHzだった。

298

組合の会計システム

MASS RANDOM ACCESS DATA STORAGE UNIT

図A-2 データストレージユニットとブラッタ (出典: Ed Thelen, ed-thelen.org)

MA-3 ディスクの1枚のブラッタ。 厚さ 3/8インチ、 直径38インチ。 (出典: Ed Thelen, ed-thelen.org)

299

付録A アーキテクチャ考古学

さて、最初の写真に戻ってプラッタが何枚あるか数えてみよう。 少なくとも2桁はある。 そ れぞれのプラッタには専用のシークアームがあって、 空気圧式アクチュエーターでアームを動 かしていた。 シークヘッドがプラッタ間を移動する様子は目視できた。 シークタイムは0.5秒 から1秒程度だったからだ。

この化け物の電源を入れると、まるでジェットエンジンのような音を立てた。 動き始めてか ら安定するまでの間は、轟音と振動が部屋中を襲った。

Datanet 30の売りは、 多数の非同期端末を比較的高速に駆動する能力で、 それはまさに ASC が必要としているものだった。

ASCの拠点はイリノイ州レークブラフ。 シカゴから北に30マイルほどのところにあった。 第 705支部のオフィスがあるのはシカゴのど真ん中。 組合は、 十数人のデータ入力作業員を使っ て、 CRT 端末 (図A-4) からデータを入力させようとしていた。 帳票は ASR35 テレタイプ端 末 (図A-5) に打ち出した。

C

図 A-4 Datapoint CRT 端末 (出典 Bill Degnan, vintagecomputer.net)

3 ディスクの重さがどれほどのものかを想像してみよう。 その運動エネルギーといったら! 部屋に入ったときに、キャ ビネットのボタンから金属の削りくずが落ちてきたことがあった。 保守担当者に一報すると、 まずシャットダウンする ように言われた。 現場にきた保守担当者は、ベアリングのひとつが摩耗していることに気づいた。 彼曰く、このまま放 置しておけばディスクがどんどん緩んできて、 飛び出したディスクはコンクリートの壁を突き破って駐車場のクルマに 突っ込んでしまうだろうということだった。

4 陰極管(いわゆるブラウン管)。 緑一色な画面に ASCII 文字を表示できた。

300

組合の会計システム

図 A-5 ASR35 テレタイプ (Joe Mabel に転載の許可をいただいた)

CRT 端末の実行速度は秒速30 文字で、 これは1960年代後半としては上々の速さだった。 当 時のモデムはそんなに高性能ではなかったからだ。

ASC は十数本の専用線とその両端につなぐ300 ボーのモデムを電話会社からリースして、 Datanet 30 と端末を接続した。

その頃のコンピュータには OSなど存在せず、ファイルシステムすらなかった。 手元にある のはアセンブラだけ。

データをディスクに保存する必要があるときには、データを直接ディスクに書き込んだ。 ファ イルやディレクトリにではない。 データの書き込み先のトラック、 プラッタ、 セクタを見つけ たら、ディスクを操作してそこにデータを保存する。 つまり、ディスクのドライバを自作した ということだ。

このシステムにはエージェント、 雇用主、 組合員の3種類のレコードがあった。 基本的には これらのレコードに対する CRUD 操作を行うシステムだったが、それ以外にも組合費の請求や 勘定元帳の計算などの機能も持っていた。

元のシステムはコンサルタントがアセンブラで書いたもので、何とか 16K に収まるように詰 め込んでいた。

お察しのとおり、 この大きな Datanet 30 は維持費が高くつくものだった。そして、ソフト ウェアを動かし続けるために雇うソフトウェアコンサルタントも高給取りだった。 さらに、 世

301

付録A アーキテクチャ考古学

の中ではずっと安価なミニコンピュータが勢力を伸ばしつつあった。

ASCは1971年に、当時18歳だった私とオタク仲間2人を採用した。 この組合向け会計シス テムを、ミニコンピュータ Varian 620/f (図A-6) 向けにリプレイスする仕事だった。このコ ンピュータは安価だったし、我々への支払いも安上がりだ。 ASC にとっては悪くない話だった だろう。

varian data machines -= | DDE 3 TE 620/L-100

A-6 ミニコンピュータ Varian 620/f (出典: The Minicomputer Orphanage)

Varian のマシンは16ビットバスと32K × 16のコアメモリを持っていた。 サイクルタイム は約1マイクロ秒。 Datanet 30 に比べてもずっと高性能だ。 ディスク装置は当時流行していた IBM 2314 だ。 直径たった14インチのプラッタに30MB も保存できたし、コンクリートの壁を 突き破る心配もなかった!

もちろん、まだOS は存在しない。 ファイルシステムもなければ高級言語もない。 手元にあ るのはアセンブラだけ。 だが、 我々はやりとげた。

システム全体をなんとか32K に詰め込むのではなく、 我々はオーバーレイシステムを作った。 ディスクから読み出したアプリケーションは、オーバーレイ専用のメモリプロックにロードし ておく。 アプリケーションはこのメモリ上で実行される。ほかのプログラムを実行するときは、 ローカル RAM と一緒にプリエンプティブにディスクにスワップされる。

プログラムは、オーバーレイ領域にスワップインして、 出力バッファが一杯になるまで実行 して、別のプログラムがスワップインできるようにスワップアウトする。

もちろん、 UIが秒速30 文字だと、 プログラムの待ち時間が長くなる。 プログラムをディス クからスワップインする時間は十分にあったので、 すべての端末を可能な限りの速度で実行で

302

組合の会計システム

きた。 応答速度に不満を持つ人は誰もいなかった。

我々は、 割り込みと入出力を管理するプリエンプティブなスーパーバイザを書いた。 アプリ ケーションを書いてディスクドライバを書いて端末ドライバを書いてテープドライバを書いて、 それ以外もすべて書いた。 そのシステムのなかに、 我々以外が書いたものは1ビットたりとも なかった。 週80時間労働が続くような過酷な戦いだったが、 我々は8~9か月ほどかけてこの 化け物を稼働させた。

システムのアーキテクチャは単純なものだった (図A-7)。 アプリケーションが立ち上がる と、端末バッファがいっぱいになるまで出力を生成する。 その後、スーパーバイザがアプリケー ションをスワップアウトさせて、 新しいアプリケーションをスワップインする。 スーパーバイ ザは、端末バッファの内容を秒速30文字で出力する。 バッファが空に近づいたら、スワップア ウトしたアプリケーションを呼び戻して再びバッファを埋める。

端末 スーパーバイザ システムメモリ 端末バッファ スワップイン/アウト ディスク |オーバーレイ

図A-7 システムのアーキテクチャ

このシステムには2つの境界がある。 ひとつは、文字出力の境界だ。 アプリケーション側は、 自分が出力した内容が秒速30 文字の端末に送られることを知らない。 文字出力は、アプリケー ションの観点では完全に抽象化されていた。 アプリケーションの役割は、単に文字列をスーパー バイザに渡すところまで。 バッファからロードした文字を端末に送ってからアプリケーション をスワップするのは、スーパーバイザの役割だった。

この境界の依存性は、 通常の流れ、 つまり制御の流れと同じ方向を指していた。 アプリケー

303

付録A アーキテクチャ考古学

ションはコンパイル時にスーパーバイザに依存しており、制御の流れもアプリケーションから スーパーバイザへ向かうものだった。 この境界があるため、 アプリケーション側からは出力が どのようなデバイスに送られるのかを気にすることがなかった。

もうひとつの境界は、この依存性を逆転させたものだ。 スーパーバイザはアプリケーション を起動できるが、 コンパイル時にはアプリケーションに依存していない。 このとき、 制御の流 れはスーパーバイザからアプリケーションへ向かっている。 依存性を逆転させるインターフェ イスを実現するために、 すべてのアプリケーションをオーバーレイ領域内の特定のメモリアド レスにジャンプさせて起動するようにしていた。 この境界があるため、 スーパーバイザ側から はアプリケーションについて起動ポイント以外の情報を気にすることがなかった。

レーザーカット

1973年、私はシカゴにある Teradyne Applied Systems (TAS) に入社した。 そこは、 ボス トンに本社を置く Teradyne Inc. の関連会社だった。 そこでは、比較的高出力のレーザーで電 子部品を高精度にカットするシステムを作っていた。

その当時のメーカーは、セラミックの基板上にシルクスクリーンで電子部品を配置していた。 基板のサイズは1インチ四方で、 電子部品の多くは電流の流れを抑える抵抗器だった。 抵抗器の抵抗値は、その組成物や形状を含めたいくつかの要素によって決まる。 抵抗器を広 げれば広げるほど、抵抗値は小さくなる。

我々のシステムは、セラミックの基板をハーネスに載せて、付属するプローブで抵抗器に接 触する。プローブで抵抗値を計測し、レーザーを使って抵抗器のパーツを焼き、 求める抵抗値 の 0.1%程度の誤差に収まるまで削っていく。

我々はこのシステムをメーカーに販売した。 また、 自社内でもこのシステムを使い、 中小メー カー向けの小規模のバッチを扱ってい

使っていたコンピュータはM365。 多くの企業が自社でコンピュータを開発する時代だった。 Teradyne は自社でM365 を開発し、 関連会社に提供していた。 M365 は、 当時流行していたミ ニコンピュータである PDP-8の機能拡張版だった。

このM365 がポジショニングテーブルを制御して、 セラミック基板をプローブの下に移動さ せる。また、計測システムとレーザーもM365 で制御するようにした。 レーザーの位置決めに はX-Y ミラーを用いていて、これもプログラムで回転させることができた。 レーザーの出力設 定もこのシステムの担当だった。

M365 の開発環境は原始的なものだった。 ディスクは存在しない。 大容量記憶装置はテープ カートリッジで、まるで旧型の8トラックオーディオのカセットのようだった。 テープとドラ

304

レーザーカット

ブは TriData 製だった。

当時の8トラックオーディオカセットと同様、M365のテープもループ状になっていた。 テー ドライブの動きは一方通行で、巻き戻し機能が存在しない! テープの先頭に移動したけれ 「ロードポイント」まで先に進める必要があった。

テープの速度は秒速1フィート程度。 つまり、 ループの長さが25フィートなら、ロードボ ントに達するまで最大で25秒かかることになる。 そこで Tridata は、 10 フィートから100 まで、さまざまな長さのカートリッジを用意した。

M365 の前面には、ブートストラッププログラムをメモリにロードして実行するためのボタ があった。 このブートストラップは、データの最初のブロックをテープから読み込んで実行 る。 最初のブロックにはローダーが入っていることが多く、このローダーがテープの残りの 分に入っている OS をロードした。

OSは実行するプログラム名の入力をユーザーに促す。 プログラムは、同じテープの OS の ろに格納されている。 実行したいプログラム名をたとえば 「ED-402 Editor」 と入力すると、 がそれをテープから探して、ロードして実行する。

コンソールは蛍光グリーンの ASCII CRT で 「72文字× 24行」を表示できた。 文字はすべ 大文字だった。

プログラムを編集するときには、まずED-402 エディターをロードしてから、ソースコード を保存したテープを入れる。 ソースコードが格納されているブロックをメモリに読み込むと、 がスクリーンに表示される。 テープの1ブロックには50行のコードを保存できる。 画面上 カーソルをvi とよく似た感じで移動させて、ソースコードを編集する。 そのブロックの編集 を終えたら、 そのブロックを別のテープに書き出して、ソースのテープから次のブロックを読 み込む。 この流れを、 作業が終わるまで続ける。

ひとつ前のブロックに戻ることはできない。プログラムは、先頭から順に進めていく必要が ある。 後戻りしたければ、 まず今のコードを最後まで出力テープにコピーしてから、そのテー プを使って新たな編集セッションを始めるしかなかった。 そんな状況なので特に驚くことでも ないのだが、 我々はまずプログラムを紙に打ち出して、 赤ペンで変更内容を手書きしてから、 にもとづいてブロック単位でプログラムを編集していった。

プログラムの編集を終わったら、 OS に戻ってアセンブラを起動する。 アセンブラはソース コードのテープを読んで、 バイナリテープに書き出す。 データをラインプリンターに打ち出す もあった。

テープの信頼性はそれほど高くなかったので、 常に2本のテープに同じ内容を書き出してい た。 そうしておけば、少なくとも1本は問題なく書き込めている可能性が高まるからだ。

文字という数字は Hollerithのパンチカードに由来する。 彼のパンチカードのサイズは80文字で、デッキを落として カードがバラバラになったときに備えたシーケンス番号用に最後の8文字が 「予約」 されていた。

305

付録A アーキテクチャ考古学

このプログラムのコードは約 20,000行で、コンパイルには30分近くを要した。テープの読 み込みエラーが発生する確率は、 だいたい10回に1回くらいだった。 読み込みエラーを検知し たアセンブラは、コンソールのベルを鳴らして、エラーの内容をプリンターに打ち出す。 この いまいましいベルの音は、ラボ全体に響き渡った。 さらに30分待たされることになった哀れな プログラマの愚痴も聞こえた。

このプログラムのアーキテクチャは、その当時は一般的なものだった。 まず、ひとつの「マ スターオペレーティングプログラム (MOP)」 がある。 その役割は、 基本的な入出力機能と、 コ ンソールの「シェル」 を管理することだ。 Teradyne のほとんどの支部では MOP のソースコー ドを共有していたが、それぞれが自分たちの用途に合わせてフォークしていた。 MOP のソース コードをアップデートしたときは、紙に打ち出したリストに変更点を書き込んだものを各支部 に送って、各支部ではそれを (細心の注意を払いつつ) 手作業で統合してい

ハードウェアの計測やテーブルの位置決めやレーザーの操作などは、 その目的に特化したユー ティリティーレイヤーが管理した。 MOP とこのレイヤーとの境界は、控えめに言ってもひどい ものだった。 ユーティリティレイヤーがMOP を読んでいる間にも MOP はそのレイヤーに手 出しをしていたり、 逆に MOP からコールバックしたりすることもよくあった。 実際のところ 我々は、ふたつのレイヤーが別のものであるという認識はなかった。 我々にとって、 ユーティ リティーレイヤーは単に MOP に追加したコードだという認識だった。

次に、隔離レイヤーについて紹介しよう。 このレイヤーは、アプリケーションプログラムに 対する仮想マシンインターフェイスを提供する。 データ駆動の、まったく異なるドメイン特化 言語 (DSL)で書かれていた。 この言語を使って、レーザーやテーブルの移動・カット・計測 などをした。顧客は、自分たちが使うレーザーカットアプリケーションのプログラムをこの言 語で書くことができて、その書いたプログラムを実行するのが隔離レイヤーだった。

この手法は、 マシン非依存のレーザーカット言語を作ることが狙いではなかった。 この DSL には特別なところがあり、ほかのレイヤーとも密結合していた。 隔離レイヤーの狙いは、レー ザーカットのプログラムを作るアプリケーションプログラマに対して、 M365 のアセンブラよ りシンプルな言語を提供することだった。

テープから読み込まれたレーザーカットのジョブは、システムが実行する。 我々のシステム がレーザーカットアプリケーション用のOSとして機能していたことになる。

このシステムは M365のアセンブラで書かれており、 全体がひとまとまりのコンパイル単位 になっていて、ひとつのバイナリコードを生成していた。

アプリケーション内の境界は、 とりあえず定められている程度のものだった。 システムコー ドと DSLによるアプリケーションとの境界さえ、きちんとした縛りのあるものではなかった。 境界を越えた結合があちこちにあった。

まあ、1970年代初めのソフトウェアにはよくあることだった。

306

アルミダイキャストの監視

ダイキャストの監視

1970年代半ば、 OPEC 諸国が石油禁輸を決定したことでガソリン不足が発生して、怒ったドラ バーがガソリンスタンドに殺到していた。 当時、私は Outboard Marine Corporation (OMC) 働き始めた。 Johnson Motors や Lawnboy の親会社だ。

OMCはイリノイ州ウォキーガンに大規模な工場を構えて、同社のモーターや製品で使うア ダイキャストパーツを製造していた。巨大な炉で溶かされたアルミニウムが、 何十台もの ダイキャストマシンに運ばれていく。それぞれのマシンには専任のオペレーターがいて、 型の設定やマシンの運用や鋳造されたパーツの取り出しなどを担当していた。 オペレーター の給料は、 作ったパーツの数に応じて決まる仕組みだった。

私はそこで、店舗フロアのオートメーションプロジェクトに関わった。 OMC が導入したマ シンは IBM System/7で、 これはミニコンピュータに対する IBM からの答えだった。 彼らは このコンピュータをフロア内のすべてのダイキャストマシンと接続して、各マシンのサイクル 数や時間を計測できるようにした。 我々の役割は、 それらの情報をとりまとめて3270グリーン スクリーンディスプレイに表示することだった。

使った言語はアセンブラ。 相変わらず、コンピュータ上で動くコードは1ビット残らず、す 自分たちで書いた。 OS もなければサブルーチン集もなければフレームワークもなかった。 生のコードだけがそこにあった。

そのプログラムは、 割り込み駆動のリアルタイムコードでもあった。 ダイキャストマシンの 鋳造サイクルが始まるたびに一連の統計情報を更新し、 偉大なる IBM 370様にメッセージを送 信し、 CICS-COBOL のプログラムを実行して統計情報をグリーンスクリーンに表示する必要 があった。

私はこの仕事が大嫌いだった。 本当に大嫌いだった。 ああ、やってる作業自体は楽しかった でも、そこの文化が問題で··････。 ネクタイの着用を強制されるだなんて耐えられなかった。 努力しようとはしたし、実際にネクタイを締めた。 だが、ぜんぜん幸せじゃなかった。 周り の同僚たちもそれに気づいていた。 大事な日程を忘れてしまったり、 寝坊したせいで重要な会 に参加できなかったり、 そんなざまだった。 人生で唯一、 クビになったのがこの仕事だった。 まあそうなるのも仕方がない。

アーキテクチャ的なところに関しては、学ぶべきことはほとんどなかった。 ひとつだけ注目す べきことがあるとすれば、 System/7のプログラム割り込み設定 (SPI: Set Program Interrupt) 機能だ。プロセッサへの割り込みを発生させる仕組みで、 これを使えばキューにたまっている優 先順位の低い割り込みを処理できた。 今で言うなら、Java の Thread. yield() みたいなものだ。

307

付録A アーキテクチャ考古学

4-Tel

1976年10月、 OMC をクビになった私は Teradyne の別部署に復帰した。 その後12年にわ たってこの部署に在籍することになる。 このとき私が関わったのは、4-Telというプロダクト だった。これは、サービスエリア内のすべての電話線を毎晩テストして、 修理が必要な回線の 一覧を出すためのシステムだった。 さらに、 電話線の検査員が特定の回線を細かくテストでき る仕組みも用意されていた。

システムを構築した当初は、先ほどのレーザーカットシステムと同じようなアーキテクチャ だった。 つまり、アセンブリ言語で書かれたモノリシックなアプリケーションで、明確な境界 がない状態だった。 しかし、 私が復帰した頃には、 何かが変わり始めていた。

このシステムを使うのは、サービスセンター (SC) にいる検査員たちだった。 ひとつのサー ビスセンターが多数の中央交換局 (CO) をカバーしており、 それぞれの CO が 10,000本程度 の電話線を扱っていた。 ダイヤルや計測用の機器は CO 内に置く必要があった。そこで、各地 の CO に M365 を配置することになった。 このコンピュータのことを、 我々は COLT (Central Office Line Tester 中央交換局回線テスター)と呼んだ。 それとは別に、 SC にも M365を配 置した。 これは SAC (Service Area Computer: サービスエリアコンピュータ) と名付けられ た。 SAC には数台のモデムがつながれていて、 各地の COLT と300 ボー (毎秒30文字) で通 信することができた。

最初の頃は、 COLT がすべての作業を受け持っていた。 コンソール通信もメニューもレポー ト出力も すべて COLT の役割だった。 SAC は単なるマルチプレクサーに過ぎず、 COLT か ら受け取った出力を画面に表示しているだけだった。

この方式で何が問題だったかといえば、 毎秒30文字という速度の制約だった。 画面上にぽつ ぽつと表示される文字を待ち続けるのは検査員にとって気持ちのいいものではない。 重要なの はそのなかのごく一部のデータだけなのだから、 検査員にとってはなおさら辛かっただろう。 さらに、あの頃はM365 のコアメモリは高価で、 プログラムも巨大だった。

それらの問題への対策として、 ダイヤルアップと回線測定用のプログラムを、 結果の分析と レポート出力のプログラムから切り離すことにした。 そして、 前者は COLT に残したまま、後 者のプログラムはSACに移した。 これによって、 COLT は小規模なマシンで動かせるように なったし必要なメモリも激減した。 さらに、端末のレスポンスもかなり高速化した。 レポート SAC側で生成するようになったからである。

大成功だった。 (適切な COLT に接続したあとの) 画面の描画速度は劇的に改善されたし、 COLT の使用メモリも少なくなった。

境界は明確で、きちんと切り離されていた。 SAC と COLT の間でやりとりされるパケット

308

4-Tel

は、ごく少ないものだった。 このパケットの中身はシンプルな DSLで、 DIAL XXXX (XXXX に ダイヤルせよ) や MEASURE (測定せよ)などのプリミティブなコマンドを表すものだった。

M365はテープから読み込まれていた。 だが、 当時のテープドライブは高価で、電話局の環 境においては信頼性に欠けるものだった。 また、 COLT 内のそのほかの機器に比べて M365 は 比較的高価なマシンだった。 そこで我々は、 M365から8085 ベースのマイクロコンピュータへ リプレイスするプロジェクトを立ち上げた。

新しいコンピュータは、8085 を載せたプロセッサーボードと32KのRAMボード、 さらに 12KのROM ボードが3枚という構成だった。 これらのボードはすべて計測機器と同じシャーシ に収まるものだったので、M365のときのように巨大なシャーシを用意する必要はなくなった。 ROM ボードには Intel の 2708 EPROM (Erasable Programmable Read-Only Memory) チップが12個搭載されていた。 図 A-8 がそのチップの一例だ。我々の開発環境で動いてい た PROM バーナーという特殊なデバイスを使って、 ソフトウェアをこのチップに書き込んだ。 チップのデータを消去するには、 強力な紫外線を照射すればよかった。

IC 10 L C2708 238A5 図A-8 EPROM チップ 4C12

もちろん、これが矛盾した表現だということはわかっている。

1 プラスチックの小窓があって、内部のシリコンチップが見えるようになっていた。そして、そこにUVを照射すればデー タを消去できた。

309

付録A アーキテクチャ考古学

私は同僚と2人で、M365 のアセンブリ言語で書かれたプログラムを8085のアセンブリ言語 に移植した。 手作業で進めた移植は、ほぼ半年がかりだった。 最終的にできあがった8085の コードは、30K ほどのサイズになった。

開発環境には RAM 64K 搭載されていて ROM がついていない状態だったので、 コンバイ ルしたバイナリはRAMにダウンロードしてすぐにテストできた。

プログラムがきちんと動くことを確認してから、 EPROM を使うように切り替えた。 30個の チップを焼いて、3枚のROM ボードのスロットに順番どおりに差し込んだ。 順番を間違えな いように、 すべてのチップにはラベルを付けていた。

プログラムは、サイズが30Kのバイナリがひとつという構成だった。 チップを焼くときには、 そのバイナリイメージを1Kのセグメントに分割して、30個のセグメントをそれぞれ別のチッ ブに焼き込んだ。

これがうまく動いたので、ハードウェアの大量生産に踏み切ってシステムを各地の現場にデ プロイしはじめた。

しかし、ソフトウェアは 「ソフト」なものだ。 新しい機能を追加することもあれば、バグ修 正が必要になることもある。 システムが広く使われるようになるにつれて、 インストール先ご とに30のチップを焼き直して、 現地の作業員が30枚のチップをすべて入れ替えるというアッ プデート作業が重荷になり始めた。

ありとあらゆる問題が出てきた。 チップにラベルを貼り間違えることもあれば、ラベルがは がれてしまうこともあった。 現場のエンジニアがチップを差し込む場所を間違えることもあっ たし、不注意で新しいチップのピンを壊してしまうこともあった。 そんなときは、もう一度30 枚のチップを受け取らなければいけない。

なぜ、 毎回 30枚のチップを総入れ替えしていたのだろうか? 30K の実行ファイルのコー ドに手を加えるたびに、 実行ファイル内のインストラクションが読み込まれるアドレスが変わ るからだ。 また、 我々が呼び出すサブルーチンや関数のアドレスも変わってしまう。 つまり、 変更の多寡にかかわらず、 すべてのチップに影響が及ぶのだ。

ある日ボスがやってきて、 この問題を何とかできないかと聞いてきた。 ファームウェアの更 新を、 30枚のチップを総入れ替えしなくてもできるようにする必要があるというのだ。 いろい ろ検討したうえで、 我々は 「ベクトル化」 プロジェクトを立ち上げた。 3か月がかりのプロジェ クトだった。

基本的な考え方は極めてシンプルだ。 30Kのプログラムを32のソースファイルに分割して 個別にコンパイルできるようにして、 それぞれのサイズを1K 未満に抑えた。そして、それぞ れのソースファイルの先頭で、プログラムをロードするアドレスをコンパイラに指示するよう

8 ソフトウェアをROMに焼いた時点で「ファームウェア」と呼ばれるようになることは知っている。 でも、ファームウェ アになったところでそれが「ソフト」であることは変わらない。

310

4-Tel

にした(たとえば、ボードのC4に差し込むチップ用のソースファイルなら 「ORG C400」 など とした)。

また、同じくソースファイルの冒頭に、 シンプルな固定サイズのデータ構造を用意した。 こ こには、そのチップに含まれるすべてのサブルーチンのアドレスを含めるようにした。 サイズ は40バイトなので、最大で20件のアドレスしか保持できない。 つまり、ひとつのチップには サブルーチンを20件までしか含められないということだ。

次に、 RAM の中に特別な「ベクトル」領域を用意した。 40バイトのテーブルが32個。 ここ に、各チップの先頭にあるポインタを格納した。

そして、 すべてのチップ内に含まれるすべてのサブルーチンの呼び出しを、 このRAM 上の ベクトル領域を経由する方式に切り替えた。

プロセッサが立ち上がると、 まずすべてのチップをスキャンして、 先頭にあるベクトルテー ブルを RAMに読み込む。 それから、メインプログラムを立ち上げる。

この仕組みは大成功を収めた。 バグ修正や機能追加をした場合でも、 再コンパイルするチッ プは1枚か2枚で済むようになり、現場のエンジニアには再コンパイルしたチップを送るだけ で済むようになった。

我々は、チップを独立してデプロイ可能にした。 ポリモーフィックディスパッチの仕組みを 編み出したのだ。 オブジェクトを発明したのである。

これは、まさに「プラグインアーキテクチャ」と呼べるものだった。 実際にチップをプラグ インしていたのだから。 我々が作り上げたのは、何かの機能をインストールするときには、 そ の機能を含むチップを空きソケットに差し込めばいいという仕組みだった。 メニューには新し

い機能が自動的に表示されて、メインアプリケーションとのバインドも自動的に行われた。

もちろん、当時の我々はオブジェクト指向の原則など知らなかったし、 ユーザーインターフェ イスとビジネスルールを切り離すなどという概念もなかった。 だが、 その兆しは見え始めてい たし、それはとても強力なものだった。

この手法によって、想定外のメリットがもたらされた。 ダイヤルアップ接続してファームウェ アのパッチを適用できるようになったのだ。 デバイスのファームウェアにバグが見つかったら、 そのデバイスにダイヤルアップして、オンボードのモニタープログラムを使って RAMのベク トル領域を書き換える。 問題のあるサブルーチンへのポインタをRAM 上の未使用領域を指す ように変更して、その未使用領域に修正済みのサブルーチンを書き込めばいい。 マシンコード は16進形式でタイプしておく。

これは、現場の運用にとっても顧客にとっても、願ってもないことだった。 問題が発生した としても、新しいチップを運んだり、エンジニアを緊急に呼び出したりする必要がなくなるの だ。 システムにはとりあえずパッチをあてておけばいいので、 新しいチップの導入は次の定期 保守訪問のときまで待つことも可能だ。

311

付録A アーキテクチャ考古学

サービスエリアコンピュータ

4-Tel のサービスエリアコンピュータ (SAC) は、 M365 ミニコンピュータをベースにしたも のだった。 各地の COLT との通信には、 専用線あるいはダイヤルアップモデムを使っていた。 COLT に対して電話線の計測指示を出してその結果を受け取り、 複雑な分析をしたうえで、 問 題があればその場所を特定する。

派遣指示

このシステムの経済的な成否は、修理作業員をいかに正確に配置できるかにかかっていた。 修理作業は、組合の決まりで 「中央交換局」 「ケーブル」 「ドロップ」の3つのカテゴリーに分 かれていた。 中央交換局担当の作業員は、 中央交換局内の問題に対応する。 ケーブル担当の作 業員は、 中央交換局と顧客をつなぐケーブル設備の問題に対応する。 そしてドロップ担当の作 業員は、顧客側の敷地内での問題と外部のケーブルの敷地内への引き込み線 (ドロップ) の問 題に対応する。

顧客から障害報告を受けたシステムは、問題を調査してどのカテゴリーの修理作業員を派遣 するかを判断する。 これによって、電話会社は経費をかなり削減できた。というのも、派遣す る修理作業員を間違えてしまうと対応完了までの時間が延びてしまうし、修理作業員の交通費 もムダになってしまうからだ。

この派遣指示のコードを設計して組み上げた人は、 すばらしく頭の切れる人だったのだろう。 だが、コミュニケーション能力はないに等しかったのではないだろうか。 当時、 このコードが 書かれた様子について 「3週間ほど天井を見つめてから、体のありとあらゆる穴からあふれて くるコードを2日間かけて吐き出したあと、 その人は辞めてしまった」と言われていた。

ほかの誰にも理解できないコードだった。 新機能を追加したり不具合対応をしたりするたび に、どこかが壊れてしまった。 このコードは我々のシステムのなかで最も経済効果を生み出し ているものだったので、 問題が発生するたびに会社は大きな損害を被っていた。

ある日、上司から「今後このコードには一切手を出すな」と命令が下った。 このコードは正

式に硬直化した。

クリーンなコードの価値を思い知らされた瞬間であった。

312

サービスエリアコンピュータ

アーキテクチャ

このシステムは1976年にM365のアセンブラで書かれたものだった。 モノリシックなプログ ラムで、 60,000 行程度の大きさだった。 自前のOS は、 ポーリングにもとづいたノンプリエン プティブなタスク切り替えをする。 我々はこれを、マルチプロセッシングシステム (MPS)と 呼んでいた。 M365 には組込みのスタックがなかったので、タスク単位の変数はメモリの特別 な領域に保持され、コンテキストスイッチにあわせてスワップしていた。 共有変数は、 ロック とセマフォで管理した。 再入可能性やレースコンディションが常に問題になっていた。

デバイスの制御やUI関連のロジックは、ビジネスルールとは切り離されていなかった。 たと えば、モデム制御コードがビジネスルールやUIのコード内にちりばめられていた。ひとまとめ にしてモジュール化したり、 インターフェイスを抽象化したりすることはなかった。 モデムを ビット単位で制御するコードが、 システム内のありとあらゆるところに書かれていたのだ。 端末のUIについても同じで、 メッセージと書式制御コードが切り離されていなかった。 60,000

行のコードベースのあちこちに行き渡っていたのだ。

当時使っていたモデムモジュールは、PCボードにマウントするように作られていた。 モデム ユニットをサードパーティから購入して、 我々のバックパネルに収まるようにボードにあるほ かの回路と統合した。 このユニットは高価だったので、数年後にはモデムを自前で作るように なった。 ソフトウェア部門の我々は、ハードウェアデザイナーに対して、いま使っているモデ ムと同じビットフォーマットで制御できるようなモデムを作るように依頼した。 モデムの制御 コードがソフトウェアのあちこちに散らばっていることや、 将来的に現行のモデムと新しいモ デルを同時に扱う必要があることなどを説明した。 「ソフトウェア制御の観点で、新しいモデム が現行のモデムと同じように見えるようにしてくれないか」とお願いした。

そして、新しいモデムができあがった。 制御構造はまったく異なるものだった。 ちょっと違 うどころの話じゃない。 全体的に、 まったくの別物になっていたのだ。 ハードウェアエンジニアさん、 やってくれたものだね。

そのとき我々は何をしただろうか? すべての現行モデムを新しいものにリプレイスしたわ けではない。 新旧両方のモデムをシステム内で共存させたのだ。 つまり、ソフトウェア側では 両方のモデムを扱える必要があった。 モデムを操作するすべてのコードにフラグを追加して処 理を切り分ければいいだって? 何百か所もあるのにとても無理じゃないか!

結局、 我々はそれよりさらに悪い方法を選んでしまった。

シリアルバス通信でデータを書き込むサブルーチンがあって、 モデムを含むすべてのデバイ スの制御にそれが使われていた。 我々はそのサブルーチンを修正して、 旧モデムに特有のビッ トパターンを検知できるようにした。 そのパターンを見つけたら、新しいモデム向けに変換す

313

付録A アーキテクチャ考古学

るようにしたのだ。

一筋縄ではいかなかった。 モデムの制御コマンドは、シリアルバス上のさまざまなIO アドレ スへの書き込みシーケンスで構成されている。 この一連のコマンドに割り込みをかけて、 別の IOアドレスやタイミングやビットポジションを使う別のシーケンスに変換していった。

動くには動いたが、想像を絶する最悪のハックだった。 この大失態から、 ハードウェアとビ ジネスルールを切り離したりインターフェイスを抽象化したりすることの大切さを学んだ。

稼働中のシステムの全面見直し

1980年代に入り、独自アーキテクチャのミニコンピュータを内製するのは時代遅れになって きた。市場にはマイコンが幅広く出回っていて、それらを使うほうがずっと安あがりだった。 また、1960年代のプロプライエタリなアーキテクチャよりも、それらのアーキテクチャのほう が標準化されていた。 そういった状況に加えて SACのソフトウェアアーキテクチャがひどい ものだったこともあり、 技術部門の上層部はSACのアーキテクチャを根本的に見直すことに した。

新システムは、ディスク上に載る UNIX OS を使って、 C言語で書かれることになった。 そ れを、 Intel 8086 で動くマイコン上で走らせる。 ハードウェアチームは新しいコンピュータ上 での作業を始め、ソフトウェア開発の精鋭部隊 「タイガーチーム」がソフトウェアの書き直し に取りかかった。

最初の大失敗については、詳細はあえて語らない。 2~3人年の工数をかけたソフトウェアプ ロジェクトは炎上し、 タイガーチームは何ひとつデリバリーできなかった。

何年か後、確か1982年ごろに、 このプロジェクトが再開した。 そのゴールは、 SAC の設計 を全面的に見直して、 自前で新たに設計した超強力な 80286 マシンで UNIX 上のC言語のプロ グラムとして動かすことだった。 このコンピュータは 「Deep Thought (深い考え)」と名付け られた。

これまた時間がかかった。 とても時間がかかった。 まだまだ時間がかかった。 UNIX ベース のSAC が最終的にいつリリースされたのかは知らない。 確実なのは、私が退職した1988年に はまだリリースされていなかったということだ。 というか、 あれが実際にリリースされたのか どうかもはっきり知らない。

なぜそんなにも遅れたのだろう? 言ってしまえば、大規模なプログラマ部隊が今なおアク ティブに保守を続けている旧システムを、 再設計チームが追いかけきれなかったのだろう。 こ これは、彼らに立ちはだかった困難の一例にすぎない。

314

サービスエリアコンピュータ

|ヨーロッパへ

SAC をC言語で書き直そうとしていたちょうどその頃、 会社としてヨーロッパ方面への販路 の拡大も始まっていた。 システムの再設計が終わるのを待っているヒマはなかったので、ヨー ロッパに売り込んだのはもちろん現行の M365のシステムだった。

問題は、ヨーロッパの電話システムがアメリカとは大きく異なることだった。 作業員の組織 や指揮系統もアメリカとは違っていた。 そこで、 腕利きのプログラマの1人をイギリスに送り、 現地の開発チームを率いて SACのソフトウェアをヨーロッパ向けに改修することにした。

もちろん、イギリスでの変更をアメリカ側のプログラムに統合することなどまともに考えて はいなかった。 海を越えて大規模なコードベースを送れるようなネットワークができあがるの は、まだずっと先の話だ。 イギリスの開発者たちは、単純にアメリカのコードをフォークして、 必要なところに手を加えていった。

もちろんこれは問題を引き起こした。 大西洋を挟んだ両側の大陸で、相手側のシステムにも 修正が必要になるバグが見つかった。 しかし、 お互い独自に手を加えすぎていたため、アメリ カ版に適用した修正がイギリス版でもうまく動くかどうかの判断は難しかった。

胸焼けのするような数年を経て、ようやくアメリカとイギリスのオフィスの間に高速回線が 引かれた。 そこで、 お互いの変更内容を再び統合して、アメリカ版とイギリス版を設定で切り 替えられるようにしようということになった。 しかしこの試みは、3回挑戦してすべて失敗に 終わった。2つのコードベースはまだまだとても似てはいたが、それでも再統合するには食い 違いすぎていた。 急速に変わりゆく当時の市場に対応するには、そうならざるを得なかった。

その頃、 UNIX のC言語での書き直しに挑んでいたタイガーチームは、このヨーロッパとア メリカの問題にも対応しなければいけないことを思い知らされた。 もちろん、それは彼らの進 捗にとってよいニュースであるわけがなかった。

|SACのまとめ

ほかにもいろいろネタは尽きないが、 そろそろ続けるのが辛くなってきた。 これまでのソフ トウェア開発者人生で得た教訓の多くは、SACのひどいアセンブラコードと格闘していたこの 時代に学んだといっても過言ではない。

315

付録A アーキテクチャ考古学

C言語

4Tel Micro のプロジェクトで利用した8085 は、 さまざまな組込み機器向けプロジェクト で使える比較的低コストなプラットフォームだった。 32KのRAMと同じく32KのROMがあ ればロードできたし、 周辺機器を制御する方法も極めて柔軟で強力だった。 我々が持ち合わせ ていなかったのは、プログラムを書くための柔軟で便利な言語だった。 8085 のアセンブラでの コーディングは、決して楽しいものではなかった。

さらに、当時使っていたアセンブラは、自社のプログラマが開発したものだった。 このアセ ンプラはM365 で動いていて、 「レーザーカット」で説明したカートリッジテープの OS を使う ものだった。

まるで運命の巡り合わせのように、ハードウェアのリードエンジニアが、 CEOに対して本物 のコンピュータが必要だと訴えた。 彼は自分の言っていることをそれほど理解していなかった ようだが、政治力は非常に大きかった。 彼のおかげで、 我々はPDP-11/60 を導入することに なった。

当時、一介のプログラマにすぎなかった私は大喜びだった。 このコンピュータがあったらど んなことがしたいかをはっきりと認識していた。 きっとこのマシンは私のものになるだろうと 思った。

実機が届く数か月前に到着したマニュアルを自宅に持ち帰り、むさぼるように読んだ。 その 甲斐あって、 実機が到着した頃にはハードウェアもソフトウェアも使い方を知り尽くしてい 発注するときには助言もした。 たとえば、 新しいコンピュータにどの程度の容量のディスク ストレージを載せるべきかなどを指定した。 また、 25MB のリムーバルディスクバックを搭載

できるディスクドライブを2台買うべきだとも進言した。

なんと50MB ! 無限にも等しいじゃないか! 深夜にオフィスの廊下を歩きながら、西の 悪い魔女のように高笑いしたのを思い出す。 「50MB だって! ハッハッハッハッハッ!」

施設管理者に小さな部屋を用意してもらい、 6台の VT100 端末をそこに置いた。 私はその部 屋を宇宙の写真で飾った。 ソフトウェア開発者たちは、この部屋を使ってコードを書いたりコ ンパイルしたりすることになるだろう。

マシンが到着すると、数日がかりでセットアップして、すべての端末と接続した。喜びに満 ちあふれた作業だった。

8085 用の標準アセンブラを Boston Systems Office から購入した我々は、 4-Tel のマイクロ コードを8085用に移植した。 クロスコンパイル環境を構築して、 PDP-11 でコンパイルしたバ イナリを8085の開発環境や ROM バーナーにダウンロードできるようにした。 みんなのアンク ル・ボブは、すべてをやり遂げたのだ。

9 RK07

316

BOSS

IC

ただ、8085 のアセンブラを使っているという問題がまだ残っていた。 私にとってはまだ満足 できる状況ではなかった。 ベル研では 「新しい」 言語を使いまくっているという噂が聞こえてき その名を 「C」 というらしい。 私は Kernighan と Ritchie が書いた 「The C Programsving Language」を書店で入手した。数か月前にPDP-11のマニュアルを読み込んだときと同じよう に、この本も読みまくった。

シンプルでエレガントなその言語に衝撃を受けた。 アセンブリ言語のパワーを一切れるこ となく、はるかに便利な構文でそのパワーを活用できるようになっている。これはよいものだ。 早速、WhitesmithsのCコンパイラを購入して、PDP-11 で走らせた。 このコンパイラの出 力は、 Boston Systems Office の 8085 コンパイラと互換性のあるアセンブラ構文だった。 C言

語のコードを8085のハードウェアに載せる道がようやくできた!これで一歩前進だ。

残る問題は、組込み向けのアセンブリ言語のプログラマたちにC言語を使わせるように仕向 けることだけだった。そこには悪夢のような出来事が待ち受けていたが、それはまた別のお話

この呼び出しは、現在のタスクを中断させ、 event CheckFunction をポーリングリストに配 置して、 新規でブロックされたタスクと関連付けるものである。そして、ボーリングループの なかで待機して、 ポーリングリストにある関数のいずれかが true を戻すまで呼び出し続ける。

BOSS

我々の8085 プラットフォームには、オペレーティングシステムがなかった」 MC35MPS システムでの経験と IBM System/7の基本的な割り込みメカニズムを踏まえ、8085 には なタスクスイッチャーが必要だと考えた。 そこで私は、 BOSS (Basic Operating System and Scheduler) を考案した。

BOSS の大部分はC言語で書いた。 それにより並列タスクを作ることができた。だが、 エンプティブではなかったので、割り込みでタスクを切り替えることはできなかった。 M365 MPS システムと同様に、単純なボーリングでタスクの切り替えをするようにした。 ボーリング は、 イベントでタスクがブロックされたときに発生する。

BOSS は、 タスクのブロックを以下のように呼び出す。

block (eventCheckFunction);

10 後に 「Bob's Only Successful Software (ボブの唯一成功したソフトウェア)」に改名された。

317

付録A アーキテクチャ考古学

その後、その関数に関連付けられたタスクの実行が許可される。

前述のように、これは単純でノンプリエンプティブなタスク切り替えである。

このソフトウェアは、それから数年間にわたり膨大な数のプロジェクトの基礎となった。 そ の最初のひとつはpCCU だった。

pCCU

1970年代後半から1980年代初頭は、 電話会社にとって激動の時代だった。 その原因はデジ タル革命にあった。

前世紀では、 中央交換局と顧客の電話の接続は一組の銅線だった。 銅線はケーブルにまとめ られ、電柱や地下を使い、 田舎の巨大なネットワークエリアに張りめぐらされていた。

鋼は貴金属であり、 電話会社は国中を網羅するだけの量の銅を (数トン単位で) 保有してい た。 設備投資は莫大なものだった。 その大部分は、電話通話をデジタル接続にすることで埋め

合わせることができた。 一組の銅線で数百の電話通話をデジタルで運ぶことができた。 そのために電話会社は、 中央交換局の古いアナログスイッチを新しいデジタルスイッチに移 行するプロセスに着手した。

4Tel のテストは銅線で実施しており、 デジタル接続ではテストしていなかった。 デジタル 環境でも多くの銅線が残されていたが、以前よりもはるかに短く、 顧客の電話の近くに限定さ れていた。 この信号は中央交換局から地方の基地局にデジタルで伝送され、 そこでアナログ信 号に変換され、通常の銅線で顧客まで届けられる。 つまり、 測定装置は銅線が開始する場所に 置く必要があったが、 ダイヤル装置は中央交換局に残す必要があったのだ。 問題は、すべての COLT が同じ装置の発信と測定の両方を実施していることだった。 (数年前に明確なアーキテ クチャの境界を認識していれば、 莫大な資金を失うことはなかった!)

そこで、CCU (COLT 制御ユニット) と CMU (COLT 測定ユニット) という新しい製品アー キテクチャを考案した。 CCUは中央交換局に設置され、 テストする電話回線の発信操作を制御 する。 CMU は地方の基地局に設置され、 顧客の電話機に接続された銅線を測定する。

問題は、 CCU ごとにいくつものCMU があったことだ。 それぞれの電話番号にどのCMU を 使うべきかの情報は、デジタルスイッチに保持されていた。 したがって、 どの CMU と通信し て制御するかを決めるために、 CCU はデジタルスイッチに問い合わせる必要があったのだ。

間に合わせることを電話会社に約束した。 少なくとも 数か月は残されていたので、あまり急ぐことはなかった。 また、 CCU/CMU のハードウェアと ソフトウェアの開発に数人年かかることもわかっていた。

我々は新しいアーキテクチャを移行に

318

DLU/DRU

| スケジュールの罠

時間が経つにつれて、 常に緊急の問題が発生することがわかった。 そしてそれは、CCU/CMU アーキテクチャの開発を遅らせるものだった。 我々は遅れても特に問題ないと考えていた。 電 話会社がデジタルスイッチの開発をいつも遅らせていたからだ。 先方のスケジュールを確認す ると、 時間はまだ十分にあることを確信できたので、 我々の開発も同様にいつも遅らせていた。

ある日、 上司に呼ばれてオフィスに行ったところ、こう言われてしまった。 「来月、 デジタルスイッチを設置する顧客がいるから、それまでに CCU/CMU が動くようにし といてくれ」

なんてこった! 数年人の開発をたった1か月で? だが、 上司には計画があった。

実際には、 完全な CCU/CMUアーキテクチャは必要なかった。 デジタルスイッチを導入して いた電話会社はわずかだった。 導入していたところも中央交換局は1つで、地方の基地局は2 つしかなかった。 さらに重要なのは 「地方」 の基地局は、 「ローカル」 ではなかったということ だ。 そこには数百世帯を処理する古い通常のアナログスイッチがあった。 そして、 これらのス イッチは通常の COLT でも発信できる種類のものだった。 顧客の電話番号には、どの基地局を 使うかを決めるのに必要なすべての情報が含まれていた。 電話番号に5、6、7が含まれていれ ば、 基地局1へ。 それ以外は基地局2に振り分けることになっていた。

上司が私に説明したように、 CCU/CMU は必要なかったのだ。 我々が必要としていたのは、 中央交換局にあるシンプルなコンピュータだった。 それを基地局にある2つの COLT とモデ ム回線で接続する。 SAC は中央交換局のコンピュータと通信し、コンピュータで電話番号をデ コードし、 発信と測定のコマンドを対応する基地局の COLT に中継する。 こうして pCCU が生まれた。

これは、 BOSS を使って、 C言語で書かれ、顧客に導入されたはじめてのプロダクトだった。 開発には1週間かかった。 この物語にはアーキテクチャ的に深い意味はないが、次のプロジェ クトへつながるきっかけとなった。

DLU/DRU

1980年代初頭、顧客にテキサス州の電話会社があった。彼らの網羅すべきエリアは広大だっ た。実際、エリアが広大すぎて、ひとつのサービスエリアに作業員を派遣するための複数のオ フィスを用意する必要があった。 オフィスにはSACの端末を必要とする検査員がいた。

解決が簡単な問題だと思うかもしれないが、この話は1980年初期の話である。 当時はリモー ト端末はそれほど一般的ではなかった。 さらに悪いことに、 SACのハードウェアはすべての端

319

付録A アーキテクチャ考古学

末がローカルだと認識していた。 我々の端末も専用の高速シリアルバスに接続されていた。 我々はリモート端末の機能を持っていたが、それはモデムをベースにしたものだった。 また、

1980年代初頭のモデムは300bpsに制限されていた。 顧客はその速度では満足しなかった。

高速モデムも使えたが、 非常に高価であり、 「条件付き」 常時接続で稼働させる必要があった。 ダイヤルアップの品質は確実に十分ではなかった。

顧客は解決策を求めてきた。 我々の答えは DLU/DRU だった。

DLU/DRU は、 それぞれ 「Display Local Unit」 と 「Display Remote Unit」 の略である。 DLU は SACの筐体に接続するコンピュータボードで、 端末マネージャーボードのふりをするという ものだった。 ローカル端末用のシリアルバスを制御するのではなく、 キャラクタストリームを 使い、 それを 9600bpsの条件付きモデムリンクで多重化していた。

DRU は、顧客のリモート地点に置かれた箱だった。 9600bps のリンクの終端に接続され、 専 用のシリアルバスに接続された端末を制御するハードウェアを持っていた。 9600bps のリンク から受信したキャラクタを逆多重化し、適切なローカル端末に送信するというものだ。

奇妙に思うだろう? 今では当たり前すぎて考えたこともないような解決策を設計する必要 があったのだ。 だが、当時は………。

標準の通信プロトコルはオープンソースで共有されていなかったので、 独自の通信プロトコ ルを発明する必要があった。 インターネット接続が存在するよりもずっと前の話だ。

アーキテクチャ

このシステムのアーキテクチャは非常にシンプルだったが、 強調しておきたい興味深い特徴 がいくつかある。まず、両方のユニットが、8085テクノロジーを使用しており、C言語で書か れ、 BOSS を使用していたということだ。 だが、似ているのはそこまでだ。

このプロジェクトには2人が関わっていた。 私はプロジェクトリーダーであり、 Mike Carew が私の相棒だった。 私は DLU の設計とコーディングを担当し、 Mike は DRU の設計とコーディ ングを担当した。

DLUのアーキテクチャは、データフローモデルにもとづいていた。 各タスクは小規模で何か に特化したジョブを実行したあと、 その出力をキューを使用して次のタスクに渡す。 UNIX の パイプとフィルターのモデルを考えてみてほしい。 アーキテクチャは複雑だった。 1つのタス クから、複数のサービスが処理するキューが供給されることもあれば、1つのサービスだけが 処理するキューが供給されることもある。

組立ラインを考えてみよう。 各ポジションは何かに特化した単純な仕事を行う。 それから、 製品はラインの次のポジションまで移動する。 組立ラインは、複数のラインに分割されること もある。 場合によっては、分割されたラインを再び統合することもある。 これが DLU のやり 方だ。

320

VRS

Mike の DRU は大きく異なる仕組みを採用していた。彼は端末ごとにタスクを作成し、その タスクのなかで端末のすべてのジョブを行った。 キューはなかった。 データフローもなかった。 巨大なタスクが複数あり、それぞれが端末を管理していたのである。

これは組立ラインとは正反対で、熟練の職人が複数いるような感じになるだろう。 それぞれ が製品全体を構築するというものだ。

当時、 私は自分のアーキテクチャが優れていると思っていた。 Mike はもちろん、 自分のほう が優れていると思っていた。 このことについて、 彼とは興味深い議論を何度も行った。 結局、 どちらもうまくいった。 ソフトウェアアーキテクチャが大きく異なっていても、同じような効 果がもたらされることを認識した。

VRS

1980年代が進み、 さらに新しい技術が登場した。 たとえば、 音声によるコンピュータ制御だ。 4-Tel システムの特徴として、修理作業員がケーブルの障害を突き止める機能が挙げられる。 その手順は以下のとおりだ。

●中央交換局にいる検査員は、 我々のシステムを使用して、 障害までのおおよその距離を フィート単位で決定する。 これは20%程度の精度になる。 それから、その場所の近くにケー ブル修理作業員を派遣する。

●ケーブル修理作業員が到着したら検査員に電話をかけ、 障害地点プロセスを開始するよう に求める。 検査員は、 4-Tel システムの障害地点機能を起動する。 システムは、障害のある 回線の電子的特性の測定を開始し、ケーブルの開放や短絡などの操作を要求するメッセー ジを画面に表示する。

●検査員は、システムに必要な操作を修理作業員に伝える。 修理作業員は、 その操作が完了 したら検査員に伝える。 検査員は、操作が完了したことをシステムに通知する。 システム は、テストを続行する。

●2~3回このようなやり取りをしたあと、システムは障害までの新しい距離を計算する。 ケー ブル修理作業員は、その場所まで移動し、 プロセスを再開する。

柱の上や台に立っているケーブル修理作業員が、 自分でシステムを操作できたとしたら、 ど れだけよくなるだろうか。 それが、 まさに新しい音声技術が可能にしたことだ。 ケーブル修理 作業員がシステムに直接電話し、タッチトーンでシステムに指示を出し、 その結果を心地よい 声で聞くことができる。

321

付録A アーキテクチャ考古学

| 名前

会社で新しいシステムの名前を選択するためのコンテストを開催した。 提案された名前のなか で最も創造的だったのは 「SAM CARP」 だ。 これは 「Still Another Manifestation of Capitalist Avarice Repressing the Proletariat (労働者階級を抑圧している資本主義者のもうひとつの宣 言)」の略である。 言うまでもなく、 これは採用されなかった。

ほかに「Teradyne Interactive Test System」 というのもあった。 だが、これも採用されな かった。

「Service Area Test Access Network」 もあったが、これもダメ。

最終的に「VRS (Voice Response System)」に決まった。

|アーキテクチャ

私はこのシステムに関わっていなかったが、 何が起きたのかを耳にすることができた。 これか ら話す物語は私が経験したものではないが、間違っているところはそう多くないと信じている。

当時は、マイクロコンピュータ、 UNIX オペレーティングシステム、C言語、 SQL データベー スへ移行する激動の時代だった。 我々はそれらをすべて使用することにした。

多くのデータベースベンダーのなかから、最終的に UNIFY を選択した。 UNIFY は、 UNIX で動作するデータベースシステムだ。 それが我々にとって最適だった。

UNIFY は、 埋め込み SQL という新しい技術をサポートしていた。 この技術により、SQLコ マンドを文字列としてC言語のコードに埋め込むことができた。 そして、 我々は至るところで それを使った。

つまり、コードの好きなところに SQL を置くことができたのだ。 好きなところとはどこだろ うか? あらゆる場所だ! その結果、 コードの至るところに SQL が置かれることになった。 当時はもちろん、 SQLにしっかりとした標準はなかった。 ベンダー特有のクセがたくさん

あった。 特殊な SQL や UNIFY API の呼び出しもコードの至るところに含まれていた。 これがうまくいった! システムは成功した。 修理作業員たちも使ってくれた。 電話会社も 気に入ってくれた。みんなが幸せだった。

そして、我々が使用していたUNIFY の製品は、 開発が中止された。

やばい。やばい。

そこで、SyBase に切り替えることにした。 いや、 Ingress だったか? ちょっと覚えていな いのだが、いずれにしても、すべてのC言語のコードを探索し、すべての埋め込み SQL と API の呼び出しを見つけ、 新しいベンダーの仕様に置き換える必要があった。

322

3か月ほど取り組んでいたが、結局はあきらめた。 動かすことができなかったのだ。 あまり にも UNIFY と結び付いていたため、現実的な費用でコードを再構成できる望みがなかった。

そこで、 保守契約にもとづき、 UNIFY を保守する業者を雇った。 もちろん、 保守費用は年々 高くなっていく。

[VRSのまとめ

ここから私は、データベースは詳細であり、 システムのビジネス目的から切り離すべきであ ることを学んだ。 また、 サードパーティのソフトウェアシステムと強く結び付くことが好きで はないのも、このことが理由のひとつである。

電子受付

1983年、 我々の会社は、コンピュータシステム、 電気通信システム、音声システムを統合させ ていた。 CEOはここから新しい製品を開発できると考えていた。 その目的を達成するために、 3人のチーム (私も含む) に会社の新しい製品の構想設計・実装が依頼された。

電子受付 (ER: The Electronic Receptionist) を思いつくまでに、それほど時間はかからな かった。

アイデアはシンプルだった。 会社に電話をすると、 ER が応答して誰と話したいかを尋ねる。 その人の名前をプッシュすると、 ER が取り次いでくれる。 ERのユーザーは、電話をかけてコ マンドをプッシュすれば、世界中のどこにいても、話したい人につながることができた。 実際、 そのシステムはいくつかの代替番号を列挙することができた。

たとえば、ER を呼び出して 「RMART」 (私のコード) をブッシュすると、 ER が私の最初の 番号を呼び出す。 私が出なかったら、 次の番号を呼び出す。 それでも出なかったら、 ERは発信 者のメッセージを録音する。

その後、 ER は定期的に私にメッセージを届けようとする。

これが世界初のボイスメールシステムだった。 そして、 我々は特許を出願した。 このシステムのすべてのハードウェア (コンピュータボード、メモリボード、音声/テレコム ボードなどすべて) を構築した。 メインのコンピュータボードは、 前述した Intel 80286 プロ セッサの 「Deep Thought」 だった。

音声ボードは1本の電話回線をサポートしており、電話インターフェイス、音声エンコーダ/

11 会社で特許を保有していた。 雇用契約には、会社で発明したものはすべて会社に帰属すると明確に示されていた。 上司 は私に「それをドルで会社に売ろうとしても、会社はその金額を払わなかっただろう」と言った。

電子受付

323

付録A アーキテクチャ考古学

デコーダ、メモリ、 Intel 80186 マイクロコンピュータで構成されていた。

メインコンピュータボードのソフトウェアはC言語で書かれていた。 オペレーティングシ ステムはMP/M-86 だった。 これは、初期のコマンドライン駆動でマルチプロセッシング型の ディスクオペレーティングシステムだ。 UNIX の廉価版のようなものだ。

音声ボードのソフトウェアはアセンブラで書かれており、オペレーティングシステムはなかっ た。 Deep Thought と音声ボードの通信は、 共有メモリを介して行われていた。

このシステムのアーキテクチャは、現在ではサービス指向と呼ばれている。 各電話回線は、 MP/M で実行されるリスナープロセスで監視されていた。 呼び出しがあると、 最初のハンドラ プロセスが起動して、 その呼び出しが渡される。 呼び出しの状態が遷移するたびに、 適切なハ ンドラブロセスが起動して制御する。

メッセージはこれらのサービス間で、 ディスクファイルを介して渡された。 現在実行中のサー ビスは、次のサービスを決定して、 必要な状態情報をディスクファイルに書き込み、 そのサー ビスを開始するコマンドラインを発行してから、終了する。

このようなシステムを構築したのは、はじめてだった。 実際、 製品全体の主要アーキテクト だったのもはじめてだった。 ソフトウェアに関係するものはすべて私の担当だった。 そして、 それがうまく機能した。

このシステムのアーキテクチャが本書で説明したような「クリーン」だったとは言わない。 「プラグイン」 アーキテクチャでもなかった。 だが、本物の境界の可能性を示していたことは間 違いない。 サービスは独立してデプロイ可能であり、 それぞれの責任範囲内に生きていた。 上 位レベルのプロセスと下位レベルのプロセスがあり、 多くの依存関係が正しい方向へ向かって いた。

|ERの解体

残念ながら、この製品のマーケティングはうまくいかなかった。 Teradyne はテスト機器を 販売する会社だったので、 オフィス機器市場に参入する術を知らなかった。

2年以上かけて何度も挑戦したが、 CEOは (残念なことに) あきらめて特許出願を破棄して しまった。 この特許は、 我々が出願した3か月後に出願した会社のものとなった。 我々はボイ スメールと自動転送の市場全体を断念することになった。

なんてこった!

その代わり、我々の存在を脅かす厄介な機械を作ったと、みんなから責められることもなく なった。

324

転送システムの作成

転送システムの作成

ERは製品としてはうまくいかなかったが、ハードウェアとソフトウェアは既存の製品ライン の強化に使用できた。 さらに、 VRS のマーケティングの成功によって、 テストシステムに依存 していない音声応答システムを修理作業員のために提供すべきであることを確信した。

こうして生まれたのが CDS (Craft Dispatch System) である。 CDSは本質的にはER と同 じだが、 現場の電話修理作業員に特化したものとなっている。

電話回線に問題があると、 サービスセンターでトラブルチケットが作成される。 トラブルチ ケットは自動システムに保管される。 現場の修理作業員の仕事が終わると、 サービスセンター に電話をかけて次の作業について聞く。 サービスセンターのオペレーターは、次のトラブルチ ケットを修理作業員に読み上げる。

我々はそのプロセスを自動化しようとした。 修理作業員がCDS に電話すると、次の作業が割 り当てられるようにするのである。 CDSはトラブルチケットシステムを参照し、その結果を読 み上げる。 また、 誰がどのトラブルチケットを担当しているかを管理し、 トラブルチケットシ ステムに修理状況を報告する。

このシステムには、トラブルチケットシステム、 設備管理システム、 自動テストシステムと やり取りするおもしろい機能がいくつもあった。

ERのサービス指向アーキテクチャの経験から、同じアイデアをさらに積極的に試してみたい と思うようになった。 トラブルチケットのステートマシンは、ER の通話処理のステートマシン よりもはるかに複雑だった。 そこで、今でいうところのマイクロサービスアーキテクチャに着 手しようとした。

あらゆる呼び出しの状態遷移は、あまり重要ではないものだとしても、システムで新しいサー ビスを開始するようにした。 ステートマシンはテキストファイルに外部化して、 システムが読 み取るようにした。 電話回線からシステムにイベントが入ってくるたびに、 有限ステートマシ ンを遷移する。 イベントを処理するステートマシンは既存のプロセスに指示を与え、 新しいプ ロセスを開始する。 既存のプロセスは終了またはキューで待機する。

外部化されたステートマシンにより、コードを変更することなく、 アプリケーションの流れ を変更することができた。 これは、オープン・クローズドの原則 (OCP) だ。 ステートマシン を含むテキストファイルを変更することで、 ほかのサービスとは関係なく、 新しいサービスを 簡単に作成して、アプリケーションの流れに組み込むことができる。 システムが稼働していて もこれを行うことができた。 言い換えれば、 ホットスワップと効果的なBPEL (ビジネスプロ セス実行言語) を持っていたということだ。

古いERのアプローチは、ディスクファイルを使ってサービスのやり取りをするというもの

325

付録A アーキテクチャ考古学

だったが、サービスを高速に切り替えるためには遅すぎた。 そこで我々は 「3DBB」 という共有 メモリ機構を開発した12。 3DBB では、名前でデータにアクセスできた。 それはステートマシ ンのインスタンスに割り当てた名前だ。

3DBBは文字列や定数の保存には最適だったが、 複雑なデータ構造には使えなかった。 理由 は技術的なものだが、そう難しいことではない。 MP/Mにあるプロセスは、それぞれのメモリ パーティションに存在していた。 あるメモリパーティションにあるデータへのポインタは、別 のメモリパーティションでは意味を持たなかった。 その結果、 3DBBのデータにはポインタを 含めることができなかった。 文字列は問題なかったが、 ツリー、 リンクリスト、 ポインタ付き のデータ構造は機能しなかった。

トラブルチケットシステムにあるトラブルチケットは、さまざまなところからやってくる。 自動化されたものもあれば、手動で入力されたものもあった。 手動で入力されたものは、トラ ブルについて顧客に対応したオペレーターが作成したものだ。 顧客が問題について説明するの で、オペレーターがそうした苦情や意見を構造化したテキストストリームで入力する。 たとえ ば、以下のような感じになった。

/pno 8475551212 / noise / dropped-calls

想像できるだろうか。 / は新しいトピックの開始を意味している。 その次はコードで、その 次はパラメータだ。 コードは数千種類あり、ひとつのトラブルチケットに数十のコードが含ま れることもある。さらに悪いことに、手動で入力されるためスペルが間違っていたり、フォー マットが正しくなかったりすることもよくあった。 これは人間が解釈することを意図したもの であり、 機械で処理するものではなかった。

我々の課題は、この半構造化文字列をデコードして、解釈して、誤りを訂正して、 音声に変 換して、柱の上にいる修理作業員に届けるようにすることである。 そのためには、柔軟な解析 とデータの表現技術が必要だった。 データ表現は3DBBに渡す必要があるが、 3DBB は文字列 しか処理できない。

それから、顧客のところへ訪問する飛行機のなかで、 FLD (Fleid Labeled Data) というス キームを開発した。 今で言う XML や JSON のようなものだ。 フォーマットは違うが、 アイデ アは同じだ。 FLD は、 再帰的階層で名前をデータに関連付けるバイナリツリーである。 FLDは 簡単な APIで問い合わせることができ、 3DBBにとって理想的な文字列と相互に変換すること ができた。

つまり、XMLのようなものを使用して、 ソケットの代わりに共有メモリを経由するマイクロ

12 3DBB は 「3次元ブラックボード」を意味する。 あなたが1950年代生まれなら 「Drizzle, Drazzle, Druzzle, Drone」 を思い 出すだろう (訳注:「Tooter Turtle」 というアニメに登場する魔法の言葉のようだ)。

326

明確なコミュニケーション

サービス通信を、1985年の段階で実現していたということだ。 大した違いはないのである。

明確なコミュニケーション

1988年、 Teradyne の従業員のグループが、 Clear Communications というスタートアップを 立ち上げるために退社した。 私も数か月後に彼らに加わった。 我々のミッションは、T1 回線の 通信品質を監視するシステムのソフトウェアを構築することだった。 T1 回線とは、全国の長距 離通信を伝送するデジタル回線である。 T1 回線が網羅する米国全土を巨大なモニターに映し出 し、通信品質が低下したときには赤く点滅させようとしていた。

1988年当時、 GUIは目新しいものだった。 Apple Macintosh はわずか5歳。 Windows は冗 談のような代物だった。 だが、 Sun Microsystems は、 信頼できる X-Windows GUI を備え SPARCstation を構築していた。 そこで、 我々はSun を使うことにした。 つまり、C言語と UNIX を使うということだ。

これはスタートアップだった。 週に 70~80時間も働いた。 我々にはビジョンがあった。 モチ ベーションがあった。 意志があった。 エネルギーがあった。 専門知識があった。 株を持ってい た。 億万長者になることを夢見ていた。 戯言ばかり言っていた。

体のありとあらゆる穴からC言語のコードがあふれてきた。 それをこちらで投げつけ、あち らに放り込んだ。 巨大な城を空中に建てた。 プロセス、 メッセージキュー、壮大で最高のアー

キテクチャがあった。 OSI 参照モデルをすべて (データリンク層のところまで)書いた。 GUI のコードを書いた。 ごちゃごちゃしたコードだ! うへえ! ごちゃごちゃごちゃご ちゃしたコードだ。

私はgi() という名前の3,000行のC言語の関数を書いた。 この名前は 「Graphic Interpreter」 の略だ。 ごちゃごちゃの傑作である。 ほかにもごちゃごちゃに書いたものはあったが、それが 最も悪名高きものだった。

アーキテクチャ ? ご冗談を。 これはスタートアップだぜ。 アーキテクチャに時間をかける 余裕はなかった。 とにかくコードを書くんだ! コードがすべてだ!

だからコードを書いた。 とにかく書いた。 ひたすら書いた。 3年後、 我々は販売をやってい なかった。 まったく売れなかったわけではない。 だが、 市場は我々の壮大なビジョンに関心を 払ってくれなかった。 ベンチャーキャピタルもうんざりしていた。

この時点で私は人生を恨んだ。 これまでの努力と夢がすべて崩壊した。 職場で衝突した。 家 族とも仕事が原因で争いになった。 自分自身にも葛藤があった。

そして、すべてを変える電話があった。

327

付録A アーキテクチャ考古学

|設定

電話の2年前、 重要なことが2つ起きていた。

ひとつは、近くの会社に UUCP 接続の設定をしていたことだ。 そこからまた別の施設に UUCP 接続していて、その先がインターネットに接続されていた。 もちろんダイヤルアップ接続だ。 我々のメインの SPARCstation (私の机の上にあった)から、 1200bps のモデムを使って、 1日 に2回ほどUUCP ホストを呼び出した。 これにより、 電子メールとネットニュース(みんなで 興味深いことを議論する初期のソーシャルネットワーク) の利用が可能になった。

もうひとつは、 Sun が C++コンパイラをリリースしたことだ。 1983年以来、 私はC++と 00 に興味を持ってきた。 だが、コンパイラはなかなかやってこなかった。 だからその機会が得ら れたときは、すぐに言語を変えた。 3,000 行のC言語の関数を後にして、C++のコードを書き 始めた。そして学んだ······。

いろんな本を読んだ。 Bjarne Stroustrup の 「プログラミング言語 C++」 と 「注解 C++リ ファレンスマニュアル」 (通称 ARM) はもちろん読んだ。 Rebecca Wirfs-Brock の責任駆動 開発設計に関するすばらしい著書 「Designing Object Oriented Software」 も読んだ。 Peter Coad の 「オブジェクト指向分析 (OOA)」 「オブジェクト指向設計 「OOD」」 「Object-Oriented Programming」も読んだ。 Adele Goldberg の 「SMALLTALK-80 言語詳解」も読んだ。 James O. Coplien の 「C++プログラミングの筋と定石」も読んだ。 だが、おそらく最も重要な のは Grady Booch の 「Booch法 オブジェクト指向分析と設計」 だろう。 -

なんて名前だ! Grady Booch。 誰がそんな名前を忘れられるだろうか。 さらに、彼は Rational という会社のチーフサイエンティストだった! 私もチーフサイエンティストと名乗 りたかった! 私は彼の本を読んだ。 そして、 学んだ。 学んだ。 学んだ......。

学びながら、 ネットニュースで議論するようになった(今だと Facebook で議論する感じだ ろうか)。 私の議題はC++と 00 に関するものだった。 2年間、 Usenet にいる何百人もの人た ちと最高の言語機能や最高の設計原則について議論することで、 私は仕事の不満を和らげるこ とができた。 しばらくすると、 ある程度理解できるようになってきた。

SOLID 原則が生まれる基礎となったのは、こうした議論のひとつだった。

そうした議論のなかで、 おそらく何らかの直感もあったと思うのだが、 私は気づくことに なった・・・・・・。

328

アンクル ボブ

Clear 社のエンジニアに Billy Vogel という若い奴がいた。 Billy は全員にニックネームを付け た。 彼が私を 「アンクル・ボブ (ボブおじさん)」 と呼んだ。 私の名前からというよりも「J. R. "Bob" Dobbs」 の外見を意識したのだろう (https://en.wikipedia.org/wiki/File:Bobdobbs.png 参照)。

最初のうちは我慢していたが、数か月もすると、 スタートアップに対するプレッシャーと失 望のなかで、彼の 「アンクル・ボブ」 の呼びかけは薄れていった。 そして、ある日、電話が鳴った。

電話

電話の相手はリクルーターだった。 C++とオブジェクト指向設計に詳しい人物として、 私の 名前を手に入れたそうだ。 どうやって手に入れたのかはわからない。 だが、 ネットニュースで の議論と関係があるのではないかと思っている。

彼は、シリコンバレーにある Rational という会社があり、 そこで CASE ツール13の開発の手 伝いを募集していると言った。

顔から血の気が引いた。 私はその会社の名前を知っていたからだ。 どこで知ったかは定かで はなかったが、とにかく知っていた。 そうだ、 Grady Booch のいる会社だ。 Grady Booch と 仕事ができる!

ROSE

私は1990年に Rational の契約プログラマになった。 私は ROSE の開発に取り組んでいた。 これは、プログラマがBooch の図 (「Booch法 オブジェクト指向分析と設計」 で説明されて いる図。 図 A-9 を参照) を描くためのツールである。

Booch 記法は非常に強力だった。 UML などの表記法の前身となるものだ。

ROSE にはアーキテクチャがあった。 本物のアーキテクチャだ。 それは真のレイヤーで構成 され、レイヤーの依存関係は適切に制御されていた。 アーキテクチャが、 リリース可能、 開発 可能、 独立してデプロイ可能にしていたのである。

だが、それは完ぺきではなかった。 我々はアーキテクチャの原則について理解できていなかっ たことが多かった。 たとえば、真のプラグイン構造を作成していなかった。

13 Computer Aided Software Engineering (コンピュータ支援ソフトウェアエンジニアリング)

ROSE

329

付録A アーキテクチャ考古学 Process String. Receiver Associative! Array Packet Decoder Receiver 忍 Alarm Manager IPC Alarm Manager Process Alarm Manager Receiver Real Alarm Manager A-9 Booch の図

また、最も不幸な当時の流行に陥ってしまった。 いわゆるオブジェクト指向データベースを 使ってしまったのだ。

それでも、そこでの経験はすばらしいものだった。 ROSE に関わる Rational のチームとすば らしい1年半を一緒に過ごすことができた。 私の職業人生のなかで、最も刺激的な体験だった。

|議論は続く

もちろんネットニュースでの議論は続けていた。 私はネットでの存在感を高めていた。 「C++ Report」 で記事を書き始めた。 そして、 Grady の助けを借りながら、 はじめての著書 「Designing Object-Oriented C++ Applications Using the Booch Method」 の執筆に取り掛かった。

悩ましいことがひとつあった。 あまり認めたくはないが、真実である。 誰も私のことを「ア 「ンクル・ボブ」と呼ばないのだ。 なんとかして誰かに呼んでもらいたいと思った。 そこで、 メー ルとネットニュースの署名に 「アンクル・ボブ」 と書いた。 思えばこれが間違いだったのだが、 その名前が定着してしまった。 最終的に、この名前が私のブランドになった。

| そのほかの名前

ROSE は巨大な C++ アプリケーションだった。 厳密な依存性のルールを持つレイヤーで構成 されていた。ただし、これは本書で説明したルールではなかった。 我々は上位レベルの方針に依

330

アーキテクト登録試験

存性を向けることはしなかった。 むしろ従来の制御の流れの方向に依存性を向けていた。 GUI が表現を指し、 表現が操作ルールを指し、 操作ルールがデータベースを指していた。 結局、 依

存性を方針に向けることができなかったせいで、 この製品は最終的に消滅することになった。 ROSE のアーキテクチャは、優れたコンパイラのアーキテクチャに似ていた。 図形表記を 「パース」して内部表現に変換していた。 その表現はルールによって操作され、オブジェクト指 向データベースに格納された。

オブジェクト指向データベースは比較的新しいアイデアであり、 オブジェクト指向の世界は その話題で持ち切りだった。 すべてのオブジェクト指向プログラマは、自分のシステムにオブ ジェクト指向データベースを導入したいと考えていた。 そのアイデアは比較的シンプルで、 非 常に理想的なものだった。 データベースにはテーブルではなくオブジェクトを格納する。 RAM のような感じだ。 オブジェクトにアクセスすると、そのオブジェクトがメモリに出現する。 そ のオブジェクトが別のオブジェクトを指していれば、そのオブジェクトもアクセスした直後に メモリに登場する。 まるで魔法のようだった。

そのデータベースがおそらく我々の最大のミスだった。 魔法を求めていたが、 実際に手に入 れたのは大きくて、 遅くて、 押し付けがましくて、高価な、 サードパーティのフレームワーク だった。 それがあらゆるレベルで進捗を妨げ、 我々を地獄に陥れた。

そのデータベースだけが我々のミスではなかった。 大きなミスとして、オーバーアーキテク チャがあった。 本書で説明したよりも多くのレイヤーが存在しており、レイヤー間の通信に負 荷がかかっていた。 それがチームの生産性を大幅に下げていた。

実際、膨大な人年の作業、 壮絶な苦労、 やる気のない2回のリリースのあと、 そのツールは 廃棄され、 ウィスコンシンの小さなチームの作った小さくてかわいいアプリケーション (訳注: Object System Designer) に置き換えられてしまった。

優れたアーキテクチャがあっても、 大きな失敗につながることをそこで学んだ。 アーキテク チャは問題の規模に適応できるほど柔軟でなければいけない。 小さくてかわいいツールに巨大 なアーキテクチャを用意するのは、 失敗のレシピである。

アーキテクト登録試験

1990年代初頭、 私は真のコンサルタントになった。 世界中にこの新しいオブジェクト指向を 教えた。 私のコンサルティングは、オブジェクト指向システムの設計とアーキテクチャに重点 を置いたものだった。

私の最初のクライアントに教育試験サービス (ETS) があった。 そこは、 全米建築登録委員 協議会 (NCARB) と建築家候補のための登録試験を実施する契約を結んでいた。

331

付録A アーキテクチャ考古学

米国またはカナダで建築家になりたい人は、 登録試験に合格する必要がある。 この試験には、 建築設計を含むいくつかの建築問題が含まれていた。 候補者には、 図書館、レストラン、 教会 などを建築するためのいくつかの要件が与えられ、 適切な設計図を描くことが求められた。 経験のある建築家が審査員として集まり、 採点できるようになるまで、 その結果は保存され

る。その会合は巨大かつコストの高いイベントであり、曖昧さと遅れの原因となっていた。

NCARB は、候補者にコンピュータを使って試験を受けてもらい、コンピュータで評価と採 点ができるようにすることで、このプロセスを自動化したいと考えていた。 そこで、ETSにソ フトウェアの開発を依頼した。 ETS はそのプロダクトを作るための開発者チームをまとめるた めに、私を雇った。

ETSはこの問題を18 の 「Vignette (小作品)」 に分割した。 それぞれに CAD のような GUI アプリケーションがあり、 候補者はそれを使って解答する。 そして、 それぞれの採点アプリが 解答を取り込み、 点数をつける。

パートナーである Jim Newkirk と一緒に、私はこれらの36のアプリケーションに多くの類 似点が存在することを認識した。 18のGUIアプリケーションはすべて、 同様のジェスチャーと メカニズムを使用していた。 18の採点アプリケーションはすべて、 同じ数学的手法を使用して いた。これらの共通要素を踏まえ、 Jim と私は36のアプリケーションで再利用可能なフレーム ワークを開発することを決めた。 ETS には、最初のアプリには時間がかかるかもしれないが、 残りは数週間ずつで開発が終わるとして、このアイデアを提案した。

この時点で、 あなたは顔を手のひらで隠したり、 本書に頭を打ち付けていたりするだろう。 ある程度の年齢の人たちはオブジェクト指向の 「再利用」 の約束を覚えているだろう。 当時は、 クリーンなオブジェクト指向のC++コードを書いただけで、 自然に多くのコードを再利用でき るようになると信じられていた。

我々は最初のアプリに着手した。 それは最も複雑なものだった。 我々はそれを 「Vignette Grande」 と呼んだ。

我々2人は、再利用可能なフレームワークのことを考えながら、 Vignette Grande の開発に フルタイムで取り組んだ。 それには1年かかった。 1年後、 45,000 行のフレームワークコード 6,000 のアプリケーションコードができた。 まずはこの製品を ETS に納品した。 そして、 残り17のアプリケーションを大急ぎで書くことになった。

我々は3名の開発者を雇い、 次の Vignette の作業を開始した。

だが、うまくいかなかった。 我々の開発した再利用可能なフレームワークは、 再利用可能で はなかった。 新規で書くアプリケーションにうまく合わなかった。 微妙なズレがあり、 うまく 動作しなかった。

非常に残念だったが、 何をやるべきかはわかっていた。 ETSのところへ行き、45,000 行のフ レームワークを書き直すか、少なくとも再調整する必要があるため、 作業が遅れることを伝え

332

まとめ

た。 完了までにしばらく時間がかかることも伝えた。

言うまでもなく、 ETSはこの知らせに満足していなかった。

我々は作業を再開した。 古いフレームワークを脇に置き、4つの Vignette の開発を同時に開 始した。 古いフレームワークからアイデアとコードを借用したが、 新しく開発した4つを修正 しなくても済むように手直しした。 この作業に1年かかった。 その結果、 新規の 45,000 行のフ レームワークと、 3,000 ~ 6,000 行の4つの Vignette が生まれた。

言うまでもなく、GUI アプリケーションとフレームワークの関係は依存性のルールに従って いた。 Vignette はフレームワークのプラグインになっていた。 上位レベルのGUI の方針はフ レームワークに含まれていた。 Vignette のコードはグルーのようなものだった。

採点アプリとフレームワークの関係はもう少し複雑だった。 上位レベルの採点の方針は Vignette に含まれていた。 採点フレームワークを Vignette にプラグインしていたのだ。

もちろん、これらのアプリケーションは両方とも、静的にリンクされた C++ アプリケーショ ンだったので、プラグインという概念を考えていたわけではない。 だが、依存関係は一貫して 依存性のルールに従っていた。

4つのアプリケーションを提供してから、次の4つの作業を開始した。 今度は、当初の予定 どおり、数週間おきに届けることができた。 この遅れにより約1年分のスケジュールのコスト がかかっていたので、プロセスを高速化するためにもうひとりプログラマを雇った。

その結果、 期日と約束を守ることができた。 顧客は満足していた。 我々も満足だった。 人生 は上々だ。

我々は教訓を学んだ。 利用可能なフレームワークができるまでは、 再利用可能なフレームワー クは作れないのである。 再利用可能なフレームワークは、再利用する複数のアプリケーション と連携しながら構築する必要がある。

まとめ

最初に述べたように、この付録は自叙伝のようなものである。 アーキテクチャ的にインパク トのあったプロジェクトを主に取り上げた。 本書の技術的内容とはあまり関係はないが、重要 な話題もいくつか取り上げた。

もちろんこれは歴史の一部である。 数十年にわたり私が取り組んできたプロジェクトはほか にも数多くある。 だが、 意図的に1990年代初期までの歴史について触れた。 1990年代後期に ついては、すでに別の書籍で触れているからだ (訳注:「アジャイルソフトウェア開発の奥義」 だと思われる)。

333

付録A アーキテクチャ考古学

私の昔話を少しでも楽しんでくれたら幸いだ。 みなさんがそこから少しでも何かを学んでく れたらと願っている。

334

あとがき

ソフトウェア開発者としての私のキャリアは1990年代に始まった。 ビッグアーキテクチャの 恐竜が世界を支配していた時代だ。 その世界で生き残るには、 オブジェクト、コンポーネント、 デザインパターン、UML (とその前身) について学ぶ必要があった。

プロジェクトは長い設計フェーズから始まった (「プロジェクト」と呼んだことを後悔すべ きかもしれない)。 システムの詳細な設計図を 「シニア」 プログラマが作った。 多くの 「ジュニ 「ア」 プログラマがその後に続くためだ。 だが、 当然かもしれないが、後に続くことはなかった。 絶対に

その後、高位の「ソフトウェアアーキテクト」に昇進した (昔は 「リードアーキテクト」「チー ファーキテクト」 「枢密院ロードアーキテクト」などの大層な職位を自分たちにつけていたもの だ)。 だが、 PowerPoint のなかで四角形と矢印を接続したり、コーディングしたりするだけの 毎日だった。 実際のコードに触れる機会はほとんどなかった。

しばらくして、なんてくだらないんだと思うようになった。 コードの1行1行に何らかの設 計決定が含まれている。 つまり、コードを書いている人のほうが、 PowerPoint をいじるだけの 私よりも、ソフトウェアの品質にはるかに大きな影響を与えているのだ。

その後、 ありがたいことに、 アジャイルソフトウェア開発の革命が到来し、 私のようなアー キテクトを苦しみから救ってくれた。 私はプログラマだ。 私はプログラミングが好きだ。 コー ドに大きな影響を与えるには、コードを書くしかないことに気づいた。

ビッグアーキテクチャの (太古のビッグプロセスの原野をさまよっていた) 恐竜は 「エクスト

リームプログラミング」という名の隕石によって滅亡させられた。 そして、それは救いだった。 開発チームは、重要な事項に集中し、 価値を付加するところに注力できるようになった。 数 週間から数か月もかけて、ビッグアーキテクチャのドキュメントを待つようなことはなくなっ た。 ドキュメントを忠実に無視して、 自分たちが書かなければいけないコードを書いた。 チー ムは顧客にテストしてもらうことに同意した。 方向性を確認するための迅速な設計ミーティン グを開いた。 書かなければいけないコードをとにかく書いた。

ビッグアーキテクチャの恐竜は消滅した。 小さくて俊敏な 「ジュウプンナセッケイトタクサ ンノリファクタリング」という哺乳動物に置き換わった。 ソフトウェアアーキテクチャは機敏 になったのである。

理論的には。

プログラマにアーキテクチャを任せるときの問題は、プログラマがアーキテクトのように考

335

えなければいけないということだ。 ビッグアーキテクチャ時代に学んだすべてのことに価値が なかったわけではない。 ソフトウェアの構造は (たとえそれが短期的であっても) ソフトウェ 適応進化させる我々の能力に大きな影響を与える可能性がある。

すべての設計決定には、 将来変更する余地を残しておく必要がある。 たとえばビリヤードで は、すべてのショットがボールを落とすためにあるわけではない。 次のショットにつなげるた めのショットも必要である。 それと同じで、 将来のコードを阻害しないコードを書くことも必 それは簡単なことではない。 習得するには何年もかかるだろう。

ビッグアーキテクチャの時代は、 フラジャイル (壊れやすい) アーキテクチャの時代に道を 譲ることになった。 フラジャイルアーキテクチャとは、価値を提供するためにすばやく拡張す ることはできるが、イノベーションのペースを維持することが非常に難しい設計のことである。 「変化を受け入れる」ことについて議論するのは結構なことだが、 コードを1行変更するため 500ドルもかかるとしたら、 変化など起こるはずもない。

Bob Martin の書いた00の設計原則に関する記事は、 若いソフトウェア開発者だった私に 大きな影響を与えた。 新鮮な視点で自分のコードを見ると、 それまで問題だと思っていなかっ た問題が見えてきた。

今日の価値を提供しながら、 明日の価値を阻害しないコードを書くことが、 どうすれば可能 になるかをみなさんはすでに知っているはずだ。 これらの原則をコードに適用するために、練 する責任はあなた自身にある。

自転車に乗るのと同じように、ソフトウェアの設計を本を読むだけで習得することはできな い。 本書などから得たことを実際に生かすには、練習するしかない。 コードを分析して、 Bob が強調してくれた問題を探し、その問題を修正するためにコードをリファクタリングしていこ う。まだリファクタリングに慣れていないなら、 2つの意味で貴重な経験になるだろう。

設計とクリーンアーキテクチャを開発プロセスに組み込む方法を学ぼう。そうすれば、 新しいコードが痛みを引き起こす可能性は下がるだろう。 たとえば、 TDD を実施しているな テストをパスしたあとで少しだけ設計レビューをしてから、 クリーンアップすることを忘 ないでほしい(悪いデザインをあとで修正するよりも安上がりだ)。 コードをコミットする前 ビューしてもらおう。 クリーンではないアーキテクチャを防ぐ最後の砦 で、ナチタンはコードの 「品質ゲート」を追加するのもいいだろう(ビルドバ まきない会う 機会に作ってみてはどうだろう?)。 について語ることだ。 チームと話をしよう。 開発

演はみんなの問題だ。アーキテクチャの善し悪しについて、

者はアーキテクチャのことを意識し トラクチャのことを教えてくれた。あなたがク

あさかき

あとがき

リーンアーキテクチャを理解できたら、ほかの誰かの理解を手伝ってあげてほしい。 恩送りだ。 技術的な展望は絶えず進化していくが、 本書で紹介されているような基本原則はほとんど変 わらない。 「リーン JSON クラウド NoSQL入門」 なんて本があれば古本屋に売ってしまうかも しれないが、 「Clean Architecture」 はあなたの本棚に何年も置かれることだろう。 本書があな たにとって設計の奥義となることを願っている。 Bob の記事が私にとってそうであったように。

本当の旅はここから始まる 2017年1月26日 Jason Gorman

337



訳者あとがき

本書は、 "Robert C. Martin. Clean Architecture: A Craftsman's Guide to Software Structure and Design. Prentice Hall, 2017. 978-0134494166" の全訳である。 著者は、 アジャイル開発とオブ ジェクト指向の世界で有名な 「アンクル・ボブ」 こと Robert C. Martin。 彼の最新刊である本 書は、これまでに発刊された 「Clean Code」 「Clean Coder」 に続く 「Clean」シリーズの3作 目となっている。

本書で扱うテーマは「アーキテクチャ」。 目次を見てすでにお気づきかもしれないが、みなさ んが「アーキテクチャ」 という言葉から想像するイメージとは、 少し違った内容になっているだ ろう。著者の考えるアーキテクチャとは 「設計」 であり、 一般的なイメージよりも具体的なも のとなっている。その一方で、 ビジネスドメインに関係のないことは 「詳細」 と割り切り、 デ リバリーの仕組みやフレームワークなどをすべて後回しにしようとする。 おそらく異論のある 方もいらっしゃるだろう。 私もすっきりしていない。 たとえば、 ウェブアプリケーションを開 発するときに、フレームワークを選定しないことがあるだろうか?

だが、 著者はこれまでの経験を引き合いに出しながら、圧倒的な説得力で力強く迫ってくる。 お前のアーキテクチャは、見ただけでわかるようになっているのか? ドメインについて正し く叫んでいるのか? そのように問いかけてくる。 第21章から引用しよう。

最上位レベルのディレクトリ構造と最上位レベルのパッケージのソースファイルは、 「ヘルスケ アシステム」 「会計システム」 「在庫管理システム」 と叫んでいるだろうか? それとも 「Rails」 「Spring / Hibernate」 「ASP」 と叫んでいるだろうか?

フレームワークから着手しないことが本当に正しいことなのかは、私にはまだよくわからな い。 本書で紹介されている例は、いずれも現代的なアプリの話ではない。 正直、 大昔の話を何 度もされても困るのだが (翻訳も大変だし)、 それでも「時代を超越した不変のルール」が存在 するとして、著者はいつまでも原理・原則に忠実であろうとする。 この真摯な態度については、 心から見習いたい。 彼が 「ソフトウェアクラフトマンシップ(職人気質)」と呼んでいるものだ。

本書で提唱されている 「Clean Architecture」 については、すでに著者本人がブログや講演 などで情報発信していることもあり、見よう見まねでアーキテクチャの 「同心円」を実装して いる例が数多く見られる。 だが、著者のように原理原則に忠実であるためにも、 まずは本書 に目を通してもらいたい。 そして、著者と対話しながら、自らのアーキテクチャをクリーンに

339

訳者あとがき

してもらえれば幸いだ。

最後になるが、三輪吾 (@miwarin) さん、 大橋勇希 (@secret_hamuhamu) さん、 鈴木則夫 (@suzuki)さん、内山滋さん、 綿引琢磨 (@bikisuke) さん、 石川宏保さんに翻訳をレビュー していただいた。 ありがとうございました。

340

訳者について

角征典 (かど まさのり)

ワイクル株式会社代表取締役、 東京工業大学環境・社会理工学院特任講師。 アジャイル開発や リーンスタートアップに関する書籍の翻訳を数多く担当し、 それらの手法を企業に導入するコ ンサルティングに従事。 主な訳書に「リーダブルコード」 「Running Lean」 「Team Geek」 (オ ライリージャパン)、 「エクストリームプログラミング」「アジャイルレトロスペクティブズ」 (オーム社)、 「図解リーンスタートアップ成長戦略」 (日経BP社)、 「Clean Coder」 (アスキー ドワンゴ)、共著書に 「エンジニアのためのデザイン思考入門」(翔泳社) がある。

髙木正弘 (たかぎ まさひろ)

1972年大阪府生まれ。 都内で会社員として働く傍ら、 主にソフトウェア開発関連の技術文書の 翻訳に携わる。 日本酒とカメラと飛行機を好む。 主な訳書 共訳書に 「実践ドメイン駆動設計」 (翔泳社)、「継続的デリバリー」 (アスキードワンゴ)、「プログラミング PHP」 (オライリー・ ジャパン) がある。

341



索引

索引

DIP

79, 103, 130

128

139

A-0 system

Abstract Factory パターン

ནཱལ༹

47

104,105

Directed Acyclic Graph...

Distance

125

Alan Turing-

Doug Schmidt..

DRY-

47

50

142 ཝཱ

241 ཟླ

E

ADP.

ALGOL

Alistair Cockburn

199

50,71

Alonzo Church.

Andrew Hunt

DS

255

App-titude test

239

244

Edgar Codd..

atom-

Edsger Wybe Dijkstra-

API

-74

Barbara Liskov

78,93

199

Ed Yourdon.

F

BCE..

Bertrand Meyer

-260

.78

Fred Brooks

-61, 134

62

CAソフトウェアアーキテクチャモデル

Fragile Tests Problem -

288

Facade パターン -85,213

Factory..

FitNesse..

Fortran-

G

goto 文

128

Grace Hopper-

-55

86,117,119 GUI 詳細

Greg Young-

C

C++

David Thomas

C#

CCP

Data Structure

A

255

180 ཚེ

56

49.53

B

CACM

105

244

170

47

49.54

72

286

Clojure

CQRS

CRP

H

91, 117, 120

60,250 Hardware Abstraction Layer

C言語

142

-75

267

HAL

47

D

DAG

248,249

Dependency Inversion Principle

Humble Object パターン

Hunt the Wumpus...

180

255 Instability

DCI アーキテクチャ

199 Interface Segregation Principle-

248

79

134

257

IO は無関係・・

D

detail

134

78

174

78,99, 121

A

238

207

215

ISP

343

索引

Ivar Jacobson

252

190.191.196, 199

J

PAL

James Grenning

Java

JavaScript

P

62.71, 100, 134, 290

private

241

Processor Abstraction Layer

protected..

Jim Coplien

public

62

published-

John McCarthy-

199

K

252

62,289

...293

62

-50 Python

Kent Beck-

Kristen Nygaard

R

62,100

243

62

RAM

-50 RDBMS

L

Larry Constantine.

261

261,263

REP.

-56

Liskov Substitution Principle-

50,72

Lisp

LSP

78

ReSharper

Robert C. Martin

Ruby

78.93

117,118

M

Main

Martin Fowler

Meilir Page-Jones

Michael Feathers-

N

0

Object Oriented.

OCP...

Open-Closed Principle

00

Operating System Abstraction Layer

origin.

ORM

S

114.176

62,100

Lua

62

29

223 Single Responsibility Principle

280 Smalltalk

56,186,219 SOLID 原則。

78

SAP

Minecraft

SDP

Simon Brown

139

138

SRP..

114

Ole Johan Dahl 50

STDIN

Na..

Nat Pryce

199

Ne

3333 78

STDOUT

132

Strategy ->

139

swap!..

59

59 Tom DeMarco

U

253

OSAL

110

209

OS 抽象化レイヤー

OS は詳細・ 253

253

243

200

253

279

78

62

77,233

78,81,120

Steve Freeman-

65

199

65

212.234

T

TDD-

78,87

74

TDM

Template Method パターン

888 .39 243 234 243 56 199

Time-Division Multiplexing-

Trygve Reenskaug

UART.

UI非依存

344

Visual Studio

索引

186

114,176

Voice over IP

依存性

VolP.

vtable.

ルール・ -243 依存性管理。 -201 143,277 指標・ 143 依存入力数 134 イベントソーシング 75 インターフェイス - 68, 89, 104, 254 170 インターフェイスアダプター インターフェイス分離の原則 インタラクター -202, 239 78,99, 121 -239

-243

66

Ward Cunningham・・

211.221

211

YAGNI

You Aren't Going to Need It-

ウ

ウェブ

ウェブは詳細・

ウサギとカメ

196

アーキテクチャ DCI 33, 42, 44, 73, 145, 147,209 199 86 クリーン 199,217 考古学.. サービス 叫ぶ。 -297 229 エンティティ 195 戦い。 テーマ テスト可能 45 -196 197 ヘクサゴナル 199 目的・・・ 148, 196 オブジェクト レイヤード 280 レベル -86,91 アイゼンハワーのマトリックス 43 アクター 82,274 誤った開発 231 誤った分離 -230 あらゆる存在 229 アンクル・ボブ 29 安定依存の原則 132 安定度・ -132 指標 134 -138

I

265

-149.158

運用

遠心性・

190, 201

オ

横断的開心事。

オーバーライド・

-233,235

オープンクローズドの原則

-104

78.87

救世主..

233

オブジェクト指向設計

-233

オブジェクト指向プログラミング..

オブジェクトリレーショナルマッパー

50.59.76

59

209

カ

開発・・ 148, 159

独立･･

安定度 抽象度等価の原則。

外部エージェント非依存・

外部参照。

162

外部定義:

科学・

仮想関数

200

カプセル化

113

依存関係逆転

可変コンポーネント

113

イ

79, 103, 130

可変性・

56

60,290

W

依存関係逆転の原則

68

66

128

依存グラフ

可变变数

V

73

関数型プログラミング・

依存出力数

134

73

72,73

50.71,76

38

ア

134

Y

345

索引

間接参照。

機能によるパッケージング。

機能分割...

キ

究極的な詳細

求心性・

境界

テスト

境界線・

競合狀態。

行構造

凝集性

167,171, 172.203

テンション図

距離

切り離し

ク

具象オブジェクト -105 具象関数・・ 104 具象クラス。 104 具象コンポーネント 106 具象実装。 104 具象モジュール 103 具象ユーティリティライブラリ 141 苦痛ゾーン。 140 組込み・ -241,247 クラス..... -77,119 クリーンアーキテクチャ 199,217 クリーン組込みアーキテクチャ 241.247 クリーンなコード・ .39

構成要素。 47 構造・ 41 価値- 151 構造化設計 56 構造化プログラミング 49.53,76 構造化分析 56 構造的結合。 239 179,211,215 コードレベル 78 ..237 小話・ 263 コマンドクエリ責務分離 286 コンウェイの法則 78, 159 203 コンパイラ 47 82.117.121 コンポーネント 89, 109, 119 依存グラフ 128 凝集性・ .117, 121 結合・ 125 原則・ 107 パッケージング -285 メイ ン......... . 223 コンポーネントアーキテクチャ 275 コンポーネント図 131 コンポーネントの原則 107 コンポーネントベース 234 コンポーネントレベル 86 サ コンポーネントベース 234 メリット・ 230

ケ

経営者の視点・ 37 形状・ 42 继承 .62, 104 計劃 結合・ 結婚・ 139 125, 167, 168 270 原則 77 コ コアメモリ 111 考古学・ 297

サービス ****** 161, 183, 229

サービスアーキテクチャ

サービス指向アーキテクチャ

229

サービスリスナー

サービスレベル

161

-210

最下位レベルの方針・

最重要ビジネスデータ

最重要ビジネスルール

164

223

再配置可能。

再配置可能性

190

再利用 リリース等価の原則。

作者・

叫ぶアーキテクチャ

111

160, 161, 163

189

112

117,118

269

シ

システムコンポーネント・

195

142

223

134

-56,58

-73

-281

121

-76

237

346

索引

即時デプロイ

組織化・

290

42.241

シナリオ 指標 週次ビルド 従属コンポーネント 重複 204 143 126 ソフトウェア 133 162 重要ではない詳細・ 151 重要度と緊急度のマトリックス 43 主系列 139,141 距離 142 出力 循環依存 解消・ 174 126,128 130 順次・ 54,76 条件付きコンパイル命令 255 151,223,257,262 状態 75 情報隐蔽 -91 証明・ 54.56 事例・ 273 ス 数学的纳法 ༞55

ソフトウェアアーキテクト

-147

タ

ターゲットハードウェア・

ダイレクトメール。

-246

ダウンロード・アンド・ゴー 単一責任の原則・・

154

212

-78.81.120

チ

中央变换。

中間レベル

-219

抽象インターフェイス

抽象化..

抽象閱數:

104

267

スケーラブル

スコープ

抽象クラス

抽象コンポーネント

-104

231 ཧུ

抽象度。

106,137

スレッド

計測・・

138

抽象ユースケース -274

ཐཱæ 42 182 ディスク

テ

260,261

データ

データ構造

142 データベース 制御の流れ 68 脆弱なテストの問題 238 静的解析ツール 286 静的型付け言語・ 100 静的ポリモーフィズム 180 責務 133 セキュリティ 240 設計 33 原則 77 全再利用の原則 91,117,120 テスト 選択 54,76 選択肢 159 ソ

セ

制御限界

89.180

データベースゲートウェイ

172

データベースシステム

データベーススキーマ

260

データマッパー。

可能・

境界

API

容易性･･ 238

想定外の重複

システムコンポーネント

237

237

ソースレベル

-139

203

159

209

データベースは詳細・

データベース非依存・

141

259

データモデル・

200

テーマ..

適性テスト

209

259

243,244

196

78

57,209

197,200,247

239

82

163

テスト駆動開発・

139

39

347

索引

デッドロック

デバイス非依存

-67,152 パフォーマンス

285

-262

73

デプロイ

独立･･

231

デプロイコンポーネント

70.149.159 早すぎる決定・

182

デプロイレベル

切り離し方式・

コンポーネント・

-163, 182

パラダイム

反証可能

パンチカード

反復・

182

テンション図

ト

47.49

54,76

121

45

闘争

ヒ

動画販売サイト

洞窟探検･

273 ビジネスデータ

-150

動的型付け言語・

動的ポリモーフィズム・

100

比較と置換

独立開発可能性。

180

独立コンポーネント

167

67

独立性。

独立デプロイ可能性

最重要。

トップダウン

ビジネスルール。

ドメイン駆動設計･･

ドライバ...

74

.69.90, 189

トランザクション

190

取引・

ナ

ノ

56

非循環依存関係の原則

ビュー・

133

70

157

-189

ビルド可能性

フ

70,162

125

トランザクショナルメモリ

トランプデータ

ドワイト・D・アイゼンハワー 43

ファームウェア

何かを奪っている 51

115

=

208

127

ノード

残すべき選択肢・・ 151

八

ハードウェア抽象化レイヤー

ハードウェアは詳細・・

バウンダリー

パッケージング 280

131

131

-284

202

-73

ファンアウト

ファン イン

不安定さ..

75

二日酔い症候群・・

241

物理アドレス

193

不変コンポーネント

不変性・

75

ブラグイン

67,175

振り子・・

振る舞い。

価値..

174 フレームワーク

プレゼンター

248 プログラマ

248

134

-249

134

125

155

プラグインアーキテクチャ

73

73

176

265,266

41.44

ブレインオールドオブジェクト

151

196,197,202

結婚・・

197

作者・・

非依存

270

269

リスク

-200

フレームワークは詳細・

270

269

207,208

プログラミングパラダイム

167 プロセッサ抽象化レイヤー。

機能 -281 プロダクト

134

53

プロセッサは詳細・

-47

252

273

348

分割統治。

索引

-54 モノリス

< 並行更新。 並行处理。 73 73 閉鎖性共通の原則 86, 117.119 ヘクサゴナルアーキテクチャ 199 ヘッダーファイル 255 ペリフェリックアンチパターン 293 変更する理由 81 変更の軸 86,177 E 变動性 141 木 ポインタ 66 崩壊したコード 39 崩壊のサイン 36 方針・ 151,185 ポートとアダプター 199.283 保守。 150 保守性・ -131 ボトルネック 246 ポリモーフィズム・ --65,67

ユ

有害宣言・・

55

127

127

.128

切り離し

ユニットテスト

ユビキタス言語・

リリース可能

マイクロサービス。

-84

マージ

マ

マイクロサービスアーキテクチャ

有向エッジ

有向非循環グラフ..

いレイヤードアーキテクチャ

ラ

149

リクエスト

ムーアの法則

リスク ・・・・・・

リスコフの置換原則

リレーショナルデータベース

リレーショナルデータベース管理システム

161 リロケータブル

260

141

リンカ

114

111

ム

113

112

無限リスト

無駄ゾーン

無名関数

有向グラフ

ユースケース 157, 191, 201, 274

分析。 -274

197

284

286

ライフサイクル 148

ラムダ計算。 50.71

リ

リロケータビリティ

リンク

リンクローダ 113

レ

-72

メインコンポーネント

レイヤー 160,215,247

223

118.

261

メ

72

モジュールレベル

161

78,93

113

切り離し

モジュール

パッケージング 280

160

レイヤードアーキテクチャ -280

祓い .286

レスポンス

レベル 91, 185, 186

82

78

192

163

270

モ

モノリシック構造

192

ローカルプロセス

182

349

180



●本書に対するお問い合わせは、 電子メール (info@asciidvango.jp)にてお願いいたします。但し、 本書の記述内容を越えるご質問にはお答えできませんので、ご了承ください。

クリーンアーキテクチャ Clean Architecture 達人に学ぶソフトウェアの構造と設計 2018年7月27日 初版発行

著者

ロバート

Robert C. Martin かど まさのり たかひろ 角征典、高木正弘

記者

発行者 川上量生 発行 株式会社ドワンゴ 104-0061 東京都中央区銀座4-12-15 歌舞伎座タワー 編集 03-3549-6153 電子メール info@asciidwango.jp http://asciidwango.jp/ 発売 株式会社 KADOKAWA 102-8177 東京都千代田区富士見2-13-3 営業 0570-002-301 (カスタマーサポートナビダイヤル) 受付時間 11:00~17:00 (土日 祝日 年末年始を除く) https://www.kadokawa.co.jp/

印刷·製本 株式会社リーブルテック Printed in Japan

本書 (ソフトウェア/プログラム含む)の無断複製(コピー、スキャン、デジタル化等)並びに無断複製物 の譲渡および配信は、著作権法上での例外を除き禁じられています。 また、本書を代行などの 三者に依頼して複製する行為は、たとえ個人や家庭内での利用であっても一切認められておりません。 落丁・乱丁本はお取り替えいたします。 下記KADOKAWA 読者までご連絡ください。 送料小社負担にてお取り替えいたします。 但し、古書店で本書を購入されている場合はお取り替えできません。 電話 049-259-1100 (10:00-17:00/土日、祝日、年末年始を除く) 〒354-0041 埼玉県入間郡三芳町藤久保 550-1 定価はカバーに表示してあります。

ISBN978-4-04-893065-9 C3004

アスキードワンゴ編集部 福集 鈴木嘉平