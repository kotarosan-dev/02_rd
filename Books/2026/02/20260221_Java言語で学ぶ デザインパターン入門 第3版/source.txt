Java言語で学ぶ

デザインパターン入門

第3版

結城浩著

=SB Creative

ホームページのお知らせ

本書に関する最新情報は、以下のURLから入手することができます。

https://www.hyuki.com/dp/

このURLは、著者が個人的に運営しているホームページの一部です。

本書中のシステム名、製品名などは、一般に各社の商標または登録商標です。 本文中では、TM. マークを明記しておりません。

©2021 本書のプログラムを含むすべての内容は著作権法上の保護を受けております。 著者・発行者の許諾を得ずに、無断で複製・複写することは禁じられております。

はじめに

こんにちは、 結城浩です。 「Java言語で学ぶデザインパターン入門」 へようこそ。 プログラミングを行っていると、 以前と同じことを繰り返しているなあ、と気づくとき があります。 経験が増すにつれ、 そのような「パターン」が自分の心の

中に数多く蓄積さ

れ、やがてその「パターン」を次の開発に当てはめていくことができるようになります。 Erich Gamma, Richard Helm, Ralph Johnson, John Vlissidesの4人が、 そのような開発者 の 「経験」 や 「内的な蓄積」としてのパターンを

「デザインパターン」

ギャング・オブ・フィア ゴラ という形に整理しました。 この4人は、 the Gang of Four、 あるいはGoFと呼ばれています。 GoFは、 よく使われる23個のデザインパターンに「名前」を与え、 「カタログ」として 整理し、 1冊の本にまとめました。 この本が「オブジェクト指向における再利用のための デザインパターン」 (付録D [GoF] 参照) です。

たくさんのモジュールが関連して動作するとき、そのインタフェースが重要なのはあな たもご存知でしょう。 これは、コンピュータだけに当てはまることではありません。 たく さんの開発者が共同して作業するときには、 人間のインタフェースが重要になるのです。 そして、そのインタフェースの基となるのは 「言葉」 です。 特に、 コードの詳細を離れて、 プログラムの大きな構造について議論するときには、 言葉や図式が重要になってきます。 あの開発者が主張している改善案は、 私の改善案と同じなのか違うのか? 大枠としては 同じだが、 細部で異なるのか? 無限の時間と忍耐力があれば、議論を繰り返して、 それ らの疑問に答えることができるでしょう。 しかし、 デザインパターンの用語を借りれば、 もっと容易に互いのアイディアを比較し、論じ合うことができます。

デザインパターンは、開発者たちに、有益で豊かな語彙を与え、互いの意思疎通を容易 にしてくれるのです。

本書はデザインパターンの入門書です。 本書はGoFがまとめた23個のデザインパター ンを1つずつ取り上げて、 オブジェクト指向の初心者にもできるだけわかりやすいように まとめました。単なる理屈や理論を示すのではなく、そのパターンを使った具体的なプロ グラムを Java言語で書き、 実際に動作させています。 デザインパターンは遠い将来のため に学ぶものではありません。 デザインパターンは、私たちが日々書いているプログラムを 新しい観点から見直し、 再利用しやすく、機能拡張しやすいソフトウェアを作るための有 益な技法なのです。

本書の特徴

本書は次のような特徴を持ちます。

Java言語による実際に動くプログラム

GoFの23個のデザインパターンすべてについて、 Java言語による具体的なサンプルプロ グラムを示します。 すぐに読みとおせるように、ほとんどのサンプルプログラムは100行 程度の非常に小さなものになっています。 しかも、そのサンプルプログラムには「以下省 略」 という部分がなく、 実際に自分でコンパイルして実行することができます。 詳しくは 「本書のサンプルプログラム」 (p.vii) を参照してください。

◆パターン名の解説

デザインパターンの「名前」はもともと日本語ではなく主に英語です。 日本の開発者が みんな英語に堪能なわけではありませんので、各パターンの名前から正確なイメージを想 起できるとは限りません。 本書では、パターンの名前がどのような意味を持つのか、日本 語で表現するとどうなるのかについても説明します。 これによって英語が苦手な人であっ ても、パターンの恩恵を受けることができます。

◆パターン間の関連と練習問題

デザインパターンはカタログを丸暗記するためにあるのではありません。 そのパターン を身につけ、プログラムを読んでパターンを見抜き、プログラムを書くときにパターンを 当てはめる練習を行う必要があります。 そのためには、パターン相互の関連について学び、 また具体的な問題にパターンを適用する練習を行う必要があります。 本書では、パターン を学ぶための練習問題と解答を用意します。

iv

Java言語の関連情報

本書では、デザインパターンの解説だけではなく、 Java言語を深く知るための情報も示 します。 Java マークのあるところはJava言語に関連した情報です。

パターンのイラスト

言葉だけでパターンを把握するのは難しいものです。本書では、各章の扉にパターンを 直感的に表現したイラストを置きました。 これによってパターンを理解しやすくしていま す。

本書の読者

本書は、以下の読者を対象としています。

・オブジェクト指向に興味を持つ人 ・デザインパターンに興味を持つ人 (特に、 GoFの本に目を通して難しいなあと感じた人) Javaプログラマ全般 (特に、抽象クラスやインタフェースの理解に不安がある人)

本書を読むためには、 Java言語に関する基本的な知識が必要です。 具体的には、クラス やインスタンス、フィールドとメソッドについてある程度理解しており、与えられたJava 言語のソースを自分でコンパイルして実行できる程度の知識が必要です。 本書はデザインパターンの本ですが、必要に応じてJava言語の機能についての補足的な 解説も行っていますので、 読み進むうちにJavaの理解も深まるでしょう。 特に、抽象クラ スやインタフェースの目的がはっきり理解できていない読者には、おおいに参考になると 思います。

また、Java言語の知識がなくとも、 C++言語を知っていれば比較的容易に理解できるで しょう。

本書の構成

本書は次のような構成になっています。 本書の各章はGoFのデザインパターンに対応 ています。 ただし、 GoFの分類とは異なる観点からパターンを分類し、それをパートごと に分けています。 GoFの分類については付録Bを参照してください。

●第1部 「デザインパターンに慣れる」 では、理解しやすいパターンを使ってデザインパ ターンに慣れてみましょう。

第1章 「Iterator 処理を繰り返す」 では、複数の要素が集まっている中から要素を1 つ1つ取り出していく Iteratorパターンについて学びます。

第2章 「Adapter一皮かぶせて再利用」 では、異なるインタフェース (API) を持 つクラスの間をつなげる Adapterパターンについて学びます。

●第2部 「サブクラスにまかせる」 では、クラスの継承に関連したデザインパターンにつ いて学びます。

第3章 「Template Method 具体的な処理をサブクラスにまかせる」では、スーパー テンプレート メソッド クラスで処理の骨組みを定め、 具体的な処理をサブクラスで行うTemplate Method パタ ーンについて学びます。

第4章「Factory Method インスタンス作成をサブクラスにまかせる」では、スーパ クラスでインスタンスの作り方の骨組みを定め、 具体的な作成そのものはサブクラス ブック で行う Factory Methodパターンについて学びます。

●第3部 インスタンスを作る」 では、インスタンスの作成に関するデザインパターンに ついて学びます。

第5章 「Singleton - たった1つのインスタンス」 では、インスタンスが1つしか存在 <ケルトン しないSingletonパターンについて学びます。

第6章 「Prototype -コピーしてインスタンスを作る」 では、 ひな型となるインスタ プロトタイプ ンスをコピーしてインスタンスを作る Prototype パターンについて学びます。

- 第7章 「Builder 複雑なインスタンスを組み立てる」 では、複雑なものを段階を踏 ビルダー んで組み立てていくBuilderパターンについて学びます。

- 第8章 「Abstract Factory 関連する部品を組み合わせて製品を作る」 では、工場の アブストラクト・ファクトリー ように部品を組み合わせてインスタンス生成を行う Abstract Factoryパターンについて 学びます。

●第4部 「分けて考える」 では、ごちゃごちゃになりがちなプログラムを分けて考えるデ ザインパターンについて学びます。

ブリッジ 第9章 「Bridge機能の階層と実装の階層を分ける」 では、2種類の拡張が混在する プログラムを機能の階層と実装の階層に分け、 その間に橋渡しを行う Bridgeパターンに ついて学びます。

- 第10章 「Strategy アルゴリズムをごっそり切り替える」では、アルゴリズムをご っそり切り替えて改良をしやすいようにする Strategyパターンについて学びます。 ストラテジー

●第5部 「同一視」では、一見異なるものを統一的に操作できるようにしたり、取り扱い 方法を変えずに機能を追加するパターンを学びます。 また 「委譲」についても学びます。 第11章 「Composite 容器と中身の同一視」 では、容器と中身を同一視して、 再帰 コンポジット 的な構造を構築する Compositeパターンについて学びます。

第12章 「Decorator飾り枠と中身の同一視」 では、 飾り枠と中身を同一視して、 デコレータ 飾り枠を何重にも重ねるDecoratorパターンについて学びます。

●第6部 「構造を渡り歩く」 では、構造を渡り歩くパターンについて学びます。 第13章 「Visitor - 構造を渡り歩きながら仕事をする」 では、構造を渡り歩きながら 同じ操作を繰り返し適用する Visitor パターンについて学びます。 ビジター

第14章 「Chain of Responsibility責任のたらい回し」では、複数のものが連なって ーン・オブ・レスポンシビリティ いる中の、 どこかで仕事を行うという Chain of Responsibility パターンについて学びます。

●第7部 「シンプルにする」 では、クラスたちが複雑に関係しているときに、それをシン プルにするパターンについて学びます。

第15章 「Facade - シンプルな窓口」 では、複雑にからんだクラスを個別に制御す るのではなく、 窓口役のクラスを1つ配置することでシステム全体の操作性をよくする ファサード Facadeパターンについて学びます。

- 第16章 「Mediator 相手は相談役1人だけ」では、複数のクラスが互いに相談しあ うのではなく、 相談役のクラスを1つ用意し、 その相談役とだけやりとりすることでプ メディエイター ログラムをシンプルにするMediatorパターンについて学びます。

●第8部 「状態を管理する」 では、 状態に関連したパターンを学びます。

- 第17章 「Observer 状態の変化を通知する」 では、状態が変化するクラスと、その 変化を通知してもらうクラスを分けて考える Observerパターンについて学びます。 オブザーバ 第18章 「Memento 状態を保存する」 では、現在の状態を保存し、必要に応じて復 - メメント

帰させ、アンドゥを行えるようにする Mementoパターンについて学びます。

第19章 「State-状態をクラスとして表現する」では、状態をクラスで表現し、 状 態に応じた分岐処理を減らすStateパターンについて学びます。 ステート

●第9部 「無駄をなくす」 では、無駄をなくして効率的な処理を行うパターンについて学 びます。

フライウエイト 第20章 「Flyweight - 同じものを共有して無駄をなくす」 では、複数箇所で同じもの が登場するときに、それらを共有して無駄をなくす Flyweightパターンについて学びま す。

第21章 「Proxy必要になってから作る」 では、本当に目的のものが必要になるま では代理人を使って処理を進めるProxyパターンについて学びます。 プロキシー

■第10部 「クラスで表現する」 では、 意外なものをクラスで表現するパターンを学びま す。

第22章 「Command 命令をクラスにする」 では、要求や命令を形にしてクラスで コマンド - 表現する Commandパターンについて学びます。

vii

vili

第23章 「Interpreter- 文法規則をクラスで表現する」 では、文法規則をクラスで表 現するInterpreter パターンについて学びます。

本書のサンプルプログラム

| サンプルプログラムの入手方法

本書のサンプルプログラムは以下からダウンロードすることができます。

https://www.hyuki.com/dp/

| サンプルプログラムはMainクラスから起動

Javaでは、

public static void main(String[])

というメソッドを持っているクラスなら、任意のクラスを動作の起点とすることができま す。 しかし、本書では読者の理解を助けるため、サンプルプログラムを動作させる起点は、 必ずMain というクラスにしてあります。

本書で使う用語上の注意

インタフェースとAPI

インタフェースという用語は複数の意味を持ちます。

一般に、「あるクラスのインタフェース」 といったとき、通常はそのクラスが持ってい るメソッドの集まりを意味します。 そのクラスに対して何らかの操作や処理を行うときに は、そのメソッドを通じて行うのです。

ところでJavaでは、「キーワード interfaceを使って宣言されるもの」もインタフェー スと呼んでいます。

この2つのインタフェースという用語はその意味するところは似ていますが、文章の中 で用いるとき、混乱を招く場合があります。 そこで本書では、

インタフェース (API)

一般的な意味 (API は application programming interface の略)

と区別することにします。

インタフェース interface を使って宣言されるもの

| パターンとクラスと「役」

パターンという用語はデザインパターンの意味で用います。 例えば、 「GoFの本に登場 するパターンは23個ある」 は 「GoFの本に登場するデザインパターンは23個ある」とい う意味です。 また、 「Memento という名前のデザインパターン」のことを単に 「Memento 「パターン」と呼びます。

クラスはJavaでいうクラスであり、 キーワード classを使ってプログラムで定義される もののことをいいます。 例えば、 「このプログラムで定義しているのはGamerクラスであ る」などと表現します。 「Memento クラス」といったら、それはプログラム上でclass Memento { ... }として定義してあるもののことを指します。 やく

「役」 というのは本書だけで用いている表現です。 これは、パターン(デザインパター ン) の中に登場するクラスやインタフェースあるいはインスタンスで、パターンの中で特 定の役回りを果たすものを指します。 例えば、 「GamerクラスはOriginator役である」など と表現します。 必ずしも役の名前がクラスやインタフェースの名前と一致するとは限りま せん。

細かいことをいうようですが、 本文を読んでいくと、ここでいっている意味はよくわか ると思います。

謝辞

まず何より、 デザインパターンをまとめたErich Gamma, Richard Helm, Ralph Johnson, John Vlissides の4人に感謝します。

筆者の書籍雑誌連載 メールマガジンの読者の方々に感謝します。 筆者のWebペー ジに集う友人たちや、いつも筆者のために祈ってくれているクリスチャンの友人たちに感 謝します。

本書の原稿、プログラム、 それに図は、執筆と並行してインターネット上でレビューが 行われました。 レビューを行う方々は、年齢・国籍・性別・住所・職業の区別なくインタ ーネットで公募され、すべてのやりとりは電子メールとWebを使って行われました。 本

ix

書のレビューに参加してくださった方々に感謝します。 貴重な意見、 改善案、 バグ報告、 励ましの言葉を送ってくださった、以下の各氏に感謝します (五十音順)。

新真千恵さん、池田史子さん、 石井勝さん、 石田浩二さん、 井芹義博さん、 宇田川勝 俊さん、川崎昌博さん、 榊原知香子さん、砂生貴光さん、佐藤貴行さん、鈴木健司さ ん、鈴木しのぶさん、 竹井章さん、 藤森知郎さん、 前田恭男さん、 前原正英さん、三 喜義さん、 谷内上智春さん、 山城俊介さん。

また、この他にも多くの方からレビュー報告をいただきました。 感謝します。 筆者の活動を常に支援してくださるソフトバンクパブリッシング株式会社の野沢喜美 男書籍総編集長、第1書籍編集部の松本香織氏に感謝します。 本書の企画をお話したとき

に「それはいい本になります」 といってくださったのは、大きな励ましでした。 最愛の妻と2人の息子たちに感謝します。 そして、いつも筆者を元気いっぱい応援して くれる義母に本書を捧げます。

2001年3月 武蔵野にて

結城

『増補改訂版』の刊行にあたって

2001年の初版刊行以来、 「Java言語で学ぶデザインパターン入門」は多数の読者からご 愛読いただきました。 ここにあらためて感謝します。

このたび、記述を全面的に見直し、 「増補改訂版」 としました。 改訂にあたっては、読 者から送っていただいた無数のフィードバックを参考にいたしました。 ありがとうござい ます。 本書もまた、読者のみなさんのお役に立ちますように。

結城

2004年6月

浩

浩

『第3版』の刊行にあたって

2001年の初版から20年、 2004年の増補改訂版から17年もの月日が流れました。 あり がたいことに 「Java言語で学ぶデザインパターン入門」 は継続的に多くの読者さんにご愛 読いただいてきました。 深く感謝します。

第3版の刊行にあたっては、サンプルプログラムの内容を Java言語の進化に合わせてア ップデートすると共に、 本文の記述を全面的に見直しました。 本書もまた、 多くの読者さんのお役に立ちますように。

2021年9月 横浜にて

結城浩



CONTENTS

はじめに 本書の特徴 本書の読者 本書の構成 本書のサンプルプログラム・ 本書で使う用語上の注意 謝辞 「増補改訂版」の刊行にあたって 「第3版」 の刊行にあたって UMLについて・ UML・ クラス図・ クラスの関連・ シーケンス図・ |デザインパターンを学ぶ前に iii iv viii viii ix xi xxix xxix xxix xxxiv xxxiv xxxvii

第1部

デザインパターンに慣れる

第1章 Iterator

処理を繰り返す

Iterator パターン 2 サンプルプログラム・ Iterable <E> インタフェース Iterator <E> インタフェース Book クラス BookShelf クラス･ BookShelflteratorクラス Main クラス Iterator パターンの登場人物 5 6 6 8 9 11

あなたの考えを広げるためのヒント

12

xiii

xiv CONTENTS

実装がどうであれ、 Iterator を使える・

抽象クラスやインタフェースはどうも苦手で...

Aggregate役と Iterator 役の対応・

「次」は間違いやすい 14

「最後」も間違いやすい・

複数の Iterator

deletelterator は不要・

関連しているパターン この章で学んだこと 練習問題

第2章 Adapter

Adapter パターン・

一皮かぶせて再利用

15

サンプルプログラム (1) (継承を使ったもの)

Banner クラス

Print インタフェース

PrintBannerクラス

Mainクラス

サンプルプログラム (2) (委譲を使ったもの)・

Print クラス・

PrintBanner クラス

Adapter パターンの登場人物

あなたの考えを広げるためのヒント・

どんなときに使うのだろう

たとえソースがなくても・

バージョンアップと互換性

かけ離れたクラス・

継承と委のどちらを使うべきか

関連しているパターン

この章で学んだこと

練習問題

28 222222222

26

26

26

27

28

14

15

29

30

29

20

14

19

21

16

15

17

13

18

13

25

12

21

24

23

22

24

CONTENTS XV

第2部 サブクラスにまかせる

|第3章

Template Method 具体的な処理をサブクラスにまかせる

.33

34

Template Method パターン・

テンプレートとは何か

34

Template Method パターンとは何か 34 サンプルプログラム AbstractDisplayクラス 35 36 CharDisplay クラス String Displayクラス 37 38 Main クラス 40

Template Methodパターンの登場人物・

41

あなたの考えを広げるためのヒント ロジックが共通化できる

スーパークラスとサブクラスの連携プレー

サブクラスをスーパークラスと同一視する

関連しているパターン

補講クラス階層と抽象クラス・

抽象クラスの意義

42

スーパークラスからサブクラスへの要請

スーパークラスとサブクラスの協調

42

45

43

この章で学んだこと

練習問題

43

Factory Method

43

44

45

44

第4章

46

44

インスタンス作成をサブクラスにまかせる 47

Factory Method パターン 48 サンプルプログラム 48 Productクラス・ 49 Factoryクラス 50 IDCardクラス 51 IDCardFactory クラス･ 51 Main クラス・ 52

Factory Method パターンの登場人物・ 53 あなたの考えを広げるためのヒント 55

xvi CONTENTS

フレームワークと肉付け

インスタンス生成メソッドの実装方法・

パターン利用と開発者間の意思疎通 static Factory Method

関連しているパターン

この章で学んだこと 練習問題

第3部 インスタンスを作る

第5章

59 58 58

Singleton たった1つのインスタンス -61

Singleton パターン

サンプルプログラム

Singletonクラス

Mainクラス

Singletonパターンの登場人物・

あなたの考えを広げるためのヒント

なぜ制限を設ける必要があるのか・

唯一のインスタンスはいつ生成されているか

enum

Singleton-

関連しているパターン・・

この章で学んだこと

練習問題

第6章 Prototype

コピーしてインスタンスを作る71

Prototype パターン・

サンプルプログラム

68

Productインタフェース・

Managerクラス・・

MessageBoxクラス

UnderlinePenクラス

Mainクラス・

あなたの考えを広げるためのヒント

クラスからインスタンスを作ってはいけないのか

-72

Prototypeパターンの登場人物・

73

74

75

76

77

78

80

81

67

62

57 5555555

63

67

56

64

62

65

81

66

65

65

66

CONTENTS xvii

82

クラス名は束縛なのか

関連しているパターン・

補講 clone メソッドと java.lang.Cloneable インタフェース

Java

clone.

cloneメソッドはどこで定義されているか

83

83

Cloneable が要求するメソッドは?

84

cloneメソッドは浅いコピーを行う

cloneは使いにくい

この章で学んだこと

練習問題

-84

84

85

第7章

82

-85

86

Builder

複雑なインスタンスを組み立てる --87

Builder パターン

88

サンプルプログラム .88 Builder クラス・ .89 Directorクラス .90 TextBuilderクラス HTMLBuilderクラス・ 91 .92 Mainクラス 93

Builder パターンの登場人物・

関連しているパターン・

あなたの考えを広げるためのヒント 誰が何を知っているか..

依存性の注入 (Dependency Injection)

97

.99

99

設計時に決められること、 決められないこと ソースの読み方、修正の仕方・・

この章で学んだこと･

第8章

.99

100

練習問題・・

Abstract Factory

101

101

102

102

関連する部品を組み合わせて製品を作る

103

Abstract Factory パターン 104 サンプルプログラム 105 抽象的な部品 抽象的な部品 抽象的な部品 Itemクラス Linkクラス Trayクラス・ 109 109 110

象製品 Pagsクラス 抽象的な工場 Factoryクラス 工場を Manクラス 組み合わせ、製品を作る: 具体的な工場 ListFactoryクラス 115 具体的な ListLink クラス (115) 具体的な品 ListTrayクラス 具体的な製品 ListPageクラス 117 サンプルプログラムに別の具体的な工場を追加 119 具体的な工場 DivFactoryクラス 120 具体的な部品 DivLink クラス 121 具体的な部品 DivTrayクラス 具体的な製品 DivPage クラス あなたの考えを広げるためのヒント Abstract Factory パターンの登場人物 122 124 122 126 具体的な工場を新たに追加するのは簡単 126 部品を新たに追加するのは困難 126 関連しているパターン 126 補講 インスタンスの作り方いろいろ 127 この章で学んだこと 128 練習問題。 129

第4部

分けて考える

第9章

Bridge

Bridge パターン・・

・機能の階層と実装の階層を分ける -131

クラス階層の2つの役割

サンプルプログラム

機能のクラス階層 機能のクラス階層 実装のクラス階層

Displayクラス・ CountDisplayクラス

DisplayImpl クラス

実装のクラス階層 String Displaylmplクラス

Main クラス・・

Bridge パターンの登場人物・

あなたの考えを広げるためのヒント

分けておけば、拡張するのが楽になる

継承は固い結びつき、委はゆるやかな結びつき

137

138

137

139

135

140

134

141

132

141

132

142

evill

CONTENTS xix

143

関連しているパターン・ この章で学んだこと 練習問題

第10章 Strategy

143

144

アルゴリズムをごっそり切り替える .....145

Strategy パターン・ サンプルプログラム 146 146 Hand 型 147 Strategy インタフェース 149 WinningStrategy クラス 150 ProbStrategy クラス 151 Playerクラス・ 153

Main クラス

155

157

Strategy パターンの登場人物

あなたの考えを広げるためのヒント

わざわざStrategy 役を作る必要ってあるの?

158

実行中に切り替えることも可能

さまざまな乱数発生器・ 関連しているパターン この章で学んだこと 練習問題

第5部 同一視

158

第11章 Composite

158

容器と中身の同一視･

173

173

173

175

158

159

160

160

163

Composite パターン サンプルプログラム 164 164 Entry クラス File クラス 165 167 Directoryクラス 168 Main クラス・ 170

Composite パターンの登場人物・

あなたの考えを広げるためのヒント

複数と単数の同一視··

addはどこに置くべきか

XX CONTENTS

再帰的構造はあらゆる場面で登場する 関連しているパターン

この章で学んだこと

練習問題・・

第12章 Decorator

Decorator パターン・

飾り枠と中身の同一視

サンプルプログラム・

Display クラス・

String Displayクラス

Borderクラス

SideBorderクラス

FullBorderクラス・

Mainクラス・

Decorator パターンの登場人物

あなたの考えを広げるためのヒント

透過的なインタフェース (API)・

中身を変えずに、機能追加ができる 動的な機能追加ができる。

単純な品揃えでも、多様な機能追加ができる

java.ioパッケージとDecorator パターン

java.nio.file.Files-

関連しているパターン

補講 継承と委譲における同一視・

継承 サブクラスとスーパークラスとを同一視 自分と委譲先とを同一視・

この章で学んだこと

練習問題。

第6部

構造を渡り歩く

|第13章

Visitor

構造を渡り歩きながら仕事をする 199

Visitor パターン・・

サンプルプログラム

177

Visitorクラス・

176

Element インタフェース

192

192

193

196

195

200

176

178

200

191

192

181

182

175

178.

180

200

-202

187

180

185

184

188

175

190

188

189

190

189

CONTENTS xxi

202

Entry クラス

File クラス

ListVisitorクラス

203

204

206

Visitor 側とElement 側の相互呼び出し

Visitor パターンの登場人物···

あなたの考えを広げるためのヒント・

207

Directoryクラス・

.209

Main クラス・・

ダブルディスパッチ・・

211

なぜこんなに複雑なことをするのか

212

The Open-Closed Principle拡張については開き、 修正については閉じる

Concrete Visitor 役の追加は簡単・

212

ConcreteElement役の追加は困難

212

Visitor が処理するためには何が必要か ・

関連しているパターン...

この章で学んだこと

213

214

練習問題。

214

214

215

|第14章 - 責任のたらい回し221

| Chain of Responsibility

Chain of Responsibilityパターン・・

サンプルプログラム・

215

216

.222

222

Trouble クラス・ Supportクラス NoSupport クラス LimitSupport クラス OddSupport クラス 223 224 225 226 227 SpecialSupport クラス・ 227

Main クラス･･

228

Chain of Responsibility パターンの登場人物・

230

231

あなたの考えを広げるためのヒント・・

要求を出す人と要求を処理する人をゆるやかに結びつける

動的に連鎖の形態を変える・

自分の仕事に集中できる

たらい回しで処理は遅くならないのか

231

232

練習問題.

232

この章で学んだこと

232

関連しているパターン・

233

233

234

xxii CONTENTS

|第15章 Facade

シンプルな窓口

-235

236

第7部 シンプルにする

Facade パターン・・

236

サンプルプログラム

238

239

Database クラス・

HtmlWriterクラス

PageMakerクラス・

Mainクラス・・

240

242

Facadeパターンの登場人物

あなたの考えを広げるためのヒント Facade役がやっていることは何だろう 再帰的なFacadeパターンの適用・

プログラマがFacade を作らない理由 関連しているパターン・

この章で学んだこと

心理的要因

練習問題・

第16章 Mediator 相手は相談役1人だけ

Mediator パターン

|サンプルプログラム

Mediator インタフェース

Colleague インタフェース

ColleagueButtonクラス

Colleague TextFieldクラス・

ColleagueCheckboxクラス

LoginFrame クラス

256

255

Mainクラス

Mediator パターンの登場人物··

257

あなたの考えを広げるためのヒント

分散が災いになるとき・

通信経路の増加･･

再利用できるのは何か?

GUIプログラミングの注意点・

この章で学んだこと

258

259

練習問題。 267

263

265

265

265

265

関連しているパターン・

266

250

266

263

267

255

246

245

245

244

246

244

-249

244

250

241

CONTENTS xxiii

第8部 状態を管理する

第17章

Observer 状態の変化を通知する

269

Observer パターン サンプルプログラム 270 270 Observerインタフェース 270 Number Generatorクラス・ DigitObserverクラス・ 271 RandomNumber Generator クラス 273 273 GraphObserverクラス･ Main クラス・・ 274 275

Observerパターンの登場人物

あなたの考えを広げるためのヒント

ここにも交換可能性が登場する

Observerの順序・・ ......

276

277

Observerの行為がSubjectに影響を与えるとき 更新のためのヒント情報の扱い ・

「観察」 よりも 「通知」 になっている

Model/View/Controller (MVC)

関連しているパターン..

この章で学んだこと

練習問題・・

277

278

|第18章 Memento

Memento パターン

280

281

状態を保存する

サンプルプログラム

278

279

280

Mementoクラス

280

-283

284

Gamerクラス・

285

285

Main クラス・

287

Memento パターンの登場人物

290

あなたの考えを広げるためのヒント

293

2つのインタフェース (API) とアクセス制御 294 Memento をいくつ持つ?・ Mementoの賞味期限は? 296 296

Caretaker役と Originator 役を分けることの意味

294

関連しているパターン・

296

297

280

Xxiv CONTENTS

この章で学んだこと

練習問題

第19章 State

状態をクラスとして表現する

-301

State パターン・

サンプルプログラム・

金庫警備システム

Stateパターンを使わない擬似コーディング・

Stateパターンを使った擬似コーディング・

Stateインタフェース・

DayState クラス・・

NightStateクラス

302

302

-302

304

-308

Contextインタフェース

SafeFrameクラス

Main クラス

.306

- 309

Stateパターンの登場人物

あなたの考えを広げるためのヒント・

分割して統治せよ

状態に依存した処理・

状態遷移は誰が管理すべきか

自己矛盾が起こらない・

新しい状態を追加するのは簡単

複数の顔を持つインスタンス・

関連しているパターン・

この章で学んだこと 練習問題

第9部 無駄をなくす

第20章 Flyweight

Flyweight パターン・

サンプルプログラム

同じものを共有して無駄をなくす 325

Big Char クラス

Big CharFactoryクラス

322

BigString クラス・

326

326

329

331

298

333

-320

320

-320

321

322

304

.310

-311

-315

297

-316

..317

.317

-319

318

CONTENTS XXV

334

Main クラス・

Flyweight パターンの登場人物・

あなたの考えを広げるためのヒント･

335

335

335

複数箇所に影響が及ぶ･･

intrinsic extrinsic-

メモリ以外のリソース・・ static Factory Method 関連しているパターン.. この章で学んだこと 練習問題。

337

-337

管理されているインスタンスは、ガベージコレクションされない・

.338

339

.339

340

第21章 Proxy

必要になってから作る

Proxyパターン

340

サンプルプログラム

Printerクラス

-341

342

Printableインタフェース

PrinterProxy クラス

342

Mainクラス・

Proxyパターンの登場人物・

あなたの考えを広げるためのヒント

代理と委譲・・

透過的ということ

HTTPプロキシー・ さまざまなProxy

343

代理人を使ってスピードアップ・・

345

346

348

代理人と本人を分ける必要はあるのか

349

350

- 350

351

-351

351

352

関連しているパターン..

練習問題・

352

353

この章で学んだこと

353

354

第10部 クラスで表現する

| 第22章 Command

命令をクラスにする

Commandパターン

-

サンプルプログラム

Commandインタフェース

MacroCommand クラス･･

DrawCommandクラス・

Drawableインタフェース・

DrawCanvasクラス

Mainクラス

356

358

362

Commandパターンの登場人物

あなたの考えを広げるためのヒント

命令が持つべき情報は? -

356

-355

357

履歴の保存

アダプター・

関連しているパターン・

367

この章で学んだこと 練習問題

章 Interpreter

第23

Interpreter パターン

363

ミニ言語

360

文法規則をクラスで表現する375

ミニ言語の命令

ミニ・プログラムの例

ミニ言語の文法･･

ターミナル・エクスプレッションとノンターミナルエクスプレッション・

サンプルプログラム

Nodeクラス

ProgramNodeクラス

CommandListNode クラス・

CommandNode クラス

RepeatCommandNode クラス

PrimitiveCommandNode クラス・

-388

Contextクラス・

390

381

378

382

ParseException クラス

377

383

.386

385

389

376

384

377

393

369

369

369

372

369

391

361

372

373

xXxvi CONTENTS

CONTENTS xxvii

Main クラス・

.393

Interpreter パターンの登場人物

あなたの考えを広げるためのヒント

他にどんなミニ言語があるだろうか・

読み飛ばすか読み取るか・

.395

396

396

397

397

関連しているパターン・

この章で学んだこと、そして最後の言葉・ 練習問題・・

398

付録

A 練習問題の解答

.399

B GoFによるデザインパターンの分類・

D 参考文献・

402

C デザインパターン Q&A・

506

507

511

索引･･･

512



UMLについて XX

UMLについて

UML

UMLは、システムを視覚化したり、 仕様や設計を文書化したりするための表現方法で ユニファイド・モデリング・ランゲージ す。 UMLはUnified Modeling Languageの略です。

本書では、デザインパターンに登場するクラスやインスタンスの関係を表現するために UMLを用いますので、 ここで、本書を読み進めるために必要なUMLの知識をお話しまし ょう。 ただし、説明に用いる用語についてはJava言語の用語を使用します (例えば、 UMLの 「アトリビュート (属性)」 という用語の代わりに、Javaの 「フィールド」 を使い、 UMLの 「オペレーション (操作)」という用語の代わりに、 Java の 「メソッド」 を使いま す)。

UMLの仕様は非常に大きなもので、 本書で使うのはそのうちのほんの一部です。 UML について詳しく知りたい方は、 公式サイト https://www.uml.org/を参照してください。

クラス図

クラスダイアグラム UMLのクラス図 (Class Diagram) は、 クラスやインスタンス、インタフェースなどの 静的な関係を表現したものです。 クラス図という名前で呼ばれていますが、登場するのは クラスだけではありません。

|クラスと階層関係

Fig.0-1に、Javaのプログラムと、対応するクラス図の例を示します。

Fig.10-1 クラスの階層関係を表したクラス図

abstract class Parent Class { int fieldl; static char field2; abstract void methodA(); double method(){ 11... } class ChildClass extends Parent Class ( void methodA() { 11... static void method() { ParentClass field1 field2 methodA methodB ChildClass methodA methodC

この図は、 ParentClass と ChildClassという2つのクラスの関係を表しています。 白 抜きのがついた実線の矢印はクラスの階層関係を表しています。 矢印はサブクラスか らスーパークラスへ向かっています (いうなれば、これはextendsの矢印です)。

ParentClass は ChildClassのスーパークラスであり、 逆にいえば、ChildClassは ParentClassのサブクラスになっています。 スーパークラスを基底クラスや親クラスと呼ぶ 人もいます。またサブクラスを派生クラスや子クラス、 あるいは拡張クラスと呼ぶ人もいます。 おのおののクラスは長方形で表現します。 長方形の中は水平線で分割され、

クラスの名前

・フィールドの名前 メソッドの名前

を順番に書きます。 名前だけではなく付加的な情報 (アクセス制御やメソッドの引数や型 など)を書く場合もありますし、反対にその図で注目する必要のない項目については省略 する場合もあります (ですから、 クラス図からソースプログラムが復元できるとは限りま せん。

XXXXX

UMLについて xxxi

abstractクラス (抽象クラス) の名前は斜字体で書きます。 例えば、 Fig.0-1では ParentClassは抽象クラスなので斜字体になっています。

static フィールド (クラスフィールド) の名前には下線をつけます。 例えば、 field2はク ラスフィールドなので下線がついています。

abstractメソッド (抽象メソッド) は斜字体で書きます。 例えば、 ParentClassの methodAは抽象メソッドなので斜字体になっています。

staticメソッド (クラスメソッド) の名前には下線をつけます。 例えば、 ChildClassの methodcはクラスメソッドなので下線がついています。

ちょっと一言 Java と C++の用語

Java と C++では用語が多少異なります。 Javaのフィールドは、C++のメンバ変数に 対応し、Javaのメソッドは、C++のメンバ関数に対応します。

ちょっと一言 矢印の向き

UMLではサブクラスからスーパークラスに向けて矢印が伸びます。 スーパークラ スを元にしてサブクラスを作りますから、 逆の方が理解しやすいと感じる人もいるか もしれません。

次のように考えると覚えやすいです。 サブクラスを定義するとき、 extends でスー パークラスを指定します。 ですから、サブクラスは必ずスーパークラスを知っていま す。 でもスーパークラスはサブクラスを知っているとは限りません。 相手を指さすこ とができるのは相手を知っているときだけです。 だからサブクラスからスーパークラ スへ矢印が伸びているのです。

インタフェースと実装

Fig.0-2もクラス図の例です。

この図は、 Printable というインタフェースがあり、 PrintClass というクラスがその インタフェースを実装していることを表しています。 本書では、 抽象クラスとの類似性を 強調するためインタフェースの名前を斜字体にしていますが、一般には斜字体にしないこ ともよくあります。

白抜きの △がついた破線の矢印はインタフェースと実装クラスの関係を表しています。 矢印は実装クラスからインタフェースへ向かっています (いうなれば、 これは implements の矢印です)。

UMLでJavaのインタフェースを表現する場合には<<interface>> と書きます。

XOU

FD2 インタフェースと実装クラスを表したクラス図

interface Printable ( abstract void print(); abstract void sewage(); <<interface>> Printable print newPage class PrintClass implements Printable ( veid print() { 1 vaid newPage() { PrintClass print newPage

Fig.0-3 集約を表したクラス図

class Color (

class Fruit ( Color color;

class Basket ( Fruit fruits; }

Color color Fruit fruits Basket

UMLについて xxxiii

Fig.0-3もクラス図の例です。

この図は、 Color (色)、 Fruit (フルーツ)、 Basket(バスケット) という3つのクラスの 関係を表しています。 Basket クラスのfruits フィールドは、 Fruitクラスの配列になっ ており、 BasketクラスのインスタンスはFruit クラスのインスタンスを複数個持ちます。 また、 Fruitクラスのcolor フィールドはColor クラス型になっていて、 Fruitクラスの インスタンスはColorクラスのインスタンスを1個持ちます。 平たくいえば、 バスケット にはフルーツが何個か入っていて、各フルーツにはそれぞれの色がついているという関係 です。

アグリゲーション このような「持っている」 関係を 「集約」 (aggregation) と呼びます。 インスタンスを持っ ていれば、個数にかかわらずその関係は集約です。 配列を使っていても、 java.util.ArrayList クラスを使っていても、どのような実装であっても、インスタンスを持っていればその関 係は集約です。

白抜きのひし形がついた線は、 集約を表します。 ひし形のお皿の上に物が載っていると 思ってください。

アクセス制御

集約

Fig.0-4もクラス図の例です。

Fig.0-4 アクセス制御を明示したクラス図

class Something ( private int privateField; protected int protectedField; public int publicField; int packageField; private void privateMethod() { } protected void protectedMethod() ( } public void publicMethod() { ) void packageMethod() { Something -privateField #protectedField +publicField "packageField -privateMethod #protected Method +publicMethod "packageMethod

この図では、メソッドやフィールドのアクセス制御を表現しています。 UMLでは、ア

クセス制御を表現したい場合、 メソッドやフィールドの名前の前に記号をつけます。

+ がついている場合、 publicなメソッドやフィールドを表します。 どこからでもそれに アクセスすることができます。

がついている場合、 private なメソッドやフィールドを表します。 クラスの外からそ れにアクセスすることはできません。

#がついている場合、 protectedなメソッドやフィールドを表します。 それにアクセス

できるのは同じクラスか、サブクラス、 および同じパッケージ内のクラスだけです。 がついている場合、 同じパッケージ内からのみアクセスできるメソッドやフィールド を表します。

クラスの関連

クラスの関連を表すために、関連の名前に黒三角() をつけて表記することができま す。 例をFig.0-5に示します。

Fig.0-5 クラスの関連

Client Uses▸ Target Client が Target を使用する Creates▸ Factory Product FactoryがProductを生成する Notifies▸ Observer SubjectがObserverに通知する Subject

シーケンス図

シーケンス・ダイアグラム UMLのシーケンス図 (Sequence Diagram) は、 プログラムが動くときに、どのメソッ ドがどういう順番で実行されるか、どのような事象がどういう順番で起きるかを表現した ものです。

クラス図は、「時間によって変化しないもの (静的な関係)」を表します。 それに対して

xoxiv

UMLについて XXXV

シーケンス図は、 「時間に従って変化するもの (動的な振る舞い)」を表します。

処理の流れとオブジェクト間の協調動作

Fig.0-6に示すのはシーケンス図の一例です。

Fig.0-6 シーケンス図の例 メソッドの呼び出し)

class Client { Server server; void work(){ server.open(); server.print("Hello"); server.close(); } class Server { Device device; void open() ( } void print (String s) { } device.write(s); void close() { // ... class Device ( void write (String s) ( :Client work open :Server :Device print write close

Fig.0-6の右側がシーケンス図です。 左側には対応するJavaプログラムの断片を示しま す。

この図には3つのインスタンスが登場しています。 インスタンスはそれぞれ図の上にあ る3つの長方形に対応しています。 長方形の中には、Client, Server, Device のよ うに、コロン(:) の後にクラス名が書かれ、下線がつけられています。 これは、それぞれ Clientクラスのインスタンス、 Server クラスのインスタンス、 Deviceクラスのインスタ

ンスを表しています。

個々のインスタンスに名前が必要な場合には、 server: Serverのように、 コロンの前に 名前を書きます。

それぞれのインスタンスからは下方向に破線が伸びています。 これをライフライン (生 存線) と呼びます。 ここでは、時間は下方向に流れると考えてください。 上は過去、下は 未来です。 ライフラインは、インスタンスが存在する間だけ存在します。

ライフラインの途中に細長い長方形があります。 これは、そのオブジェクトが活動中で あることを表します。

横方向に矢印が並んでいます。 openというラベルがついた矢印を見てください。 実線 で、先が黒くなっている矢印() はメソッドの呼び出しを表します。 ここでは、 client が server の openメソッドを呼び出したことを表しています。 openメソッドを呼 び出したので、 server インスタンスが活動中になり、 細長い長方形が始まりました。

オープン

apanの矢印から始まったserverの細長い長方形の下端から、 clientの方へ破線の矢印

(--) が伸びています。 これはopenメソッドからのリターン (戻り) を表しています。 この図では、すべてのメソッドのリターンを描いていますが、省略されることもあります。 制御がclient に戻ったので、 server インスタンスの活動中の長方形はいったん終わり ます。

また同様にして、 print メソッドが呼び出されます。 今度は、 printメソッドの中から さらに device インスタンスのwrite メソッドを呼び出していますね。

このようにして、関連する複数のインスタンス間の振る舞いが図式化できたことになり ます。 シーケンス図は、ライフラインをたどりながら上から順番に読んでいきます。 そし て矢印があったら、 それを追って、 インスタンス間の協調動作を確認していきましょう。

xxxv

デザインパターンを学ぶ前に xxxvii

デザインパターンを学ぶ前に

個々のデザインパターンを理解するためのヒントをいくつかご紹介します。

| デザインパターンはクラスライブラリそのものではない

私たちがJavaでプログラムを書くときには、 便利なクラスが集まったクラスライブラリ を用います。 しかし、デザインパターンは、クラスライブラリそのものではありません。 デザインパターンは、クラスライブラリよりも一般的な概念です。 クラスライブラリは 部品となったプログラムそのものですが、 デザインパターンは部品がどのように組み立て られているか、 個々の部品がどのように関連して大きな機能を果たすのかを表現したもの です。

白雪姫の話を例にとって考えてみましょう。 ある特定の劇で白雪姫役を誰が演じたか、 王子役を誰が演じたかという話は、一般的な白雪姫の話の筋書きを説明するときには必須 ではありません。 具体的な役者を説明するよりも、白雪姫役と王子役の間の 「関係」 を説 明する方が大切でしょう。 特定の役者が演じた特定の劇だけが 「白雪姫」 なのではありま せん。誰が演じたとしても、白雪姫の筋書きにそっていれば、それは白雪姫の話になりま す。 肝心なのは、どういう種類の登場人物が出てきて、それらが互いにどういう役割を演 じるか なのです。

デザインパターンも同じです。 Abstract Factory パターンってどんなものですか? とい う問いに答えるとき、 具体的なプログラム例を読むことも理解の助けにはなりますが、 そ の特定のプログラムだけがAbstract Factoryパターンなのではありません。 肝心なのは、 どういう種類のクラスやインタフェースが出てきて、それらが互いにどういう関係にある かなのです。

しかし、クラスライブラリの中でデザインパターンは使われている

デザインパターンは、クラスライブラリそのものではありません。 しかし、 Javaの標準 的なクラスライブラリの中には、デザインパターンがたくさん生かされています。 デザイ ンパターンを理解していれば、 それらのクラスライブラリの役割を理解する助けとなるで しょう。

プログラムを完成品として見ないこと

Xxxxxviii

コロン

デザインパターンの目標の1つは、プログラムを再利用可能にすることです。つまり、 どうやってプログラムを 「部品」として再利用するかを考えているのです。 ですから、プ ログラム例を「完成品」として見るのではなく、 今後 「機能を拡張していくもの」「変更 を加えていくもの」として見るようにしましょう。

・どのような機能が拡張される可能性があるか?

・その機能拡張を行うときに修正が必要になるのはどのクラスか? ・修正が不要なのはどのクラスか?

このような観点でデザインパターンを見ると、 理解が深まるでしょう。

図は見るのではなく、 読むこと

デザインパターンを解説するときには、 図が登場します。 本書では主にクラス図とシー ケンス図を用います (p.xxixの 「UMLについて」を参照)。 これらの図を単なる「絵」 だ と思わないでください。 ひと目で全貌がわかるものではありません。

クラス図なら、まずは1個1個の長方形 (クラス) を見、 その中に書かれているメソッ ド名を見、それらが普通のメソッドなのか抽象メソッドなのかを確認します。 そして、 ク ラスの間の矢印を確認し、どのクラスがどのインタフェースを実装しているのかを確認し ます。 このように、 図の中の構成要素が何を意味しているのかをていねいに1つ1つ追っ ていきます。そうして読み進むうちに、 図が全体として主張していることがわかってくる のです。

シーケンス図は、クラス図よりも楽に読めます。 時間は上から下に流れていきますので、 順序良く、どのオブジェクトからどのオブジェクトが呼び出されるのかを一歩一歩確認し ましょう。 そうしていくと、パターンの中での各オブジェクトの役割が少しずつわかって いきます。

図をパッと見るだけで、 魔法のように意味がわかるわけではありません。 ていねいに 「読んでいく」 必要があるのです。

自分で例を考えること

単にプログラム例を読むだけではなく、自分なりの例を考えてみましょう。 また自分が設計やプログラミングを行うときに、学んだデザインパターンが当てはま らないだろうか、と考えてみるのもよいでしょう。

デザインパターンを学ぶ前に xxxix

白雪姫の役は誰か?

役割を理解すること

デザインパターンはドラマのようなものです。 たくさんのクラスやインタフェースとい う登場人物が現れて、互いにかかわりをもちながらドラマを作っていきます。 一人一人に は役割が割り振られています。 各人は、その役割にそって行動しなければなりません。 主 人公は主人公らしくふるまい、敵方はそれに対抗します。 ヒロインも登場し、 劇はクライ マックスへ向かいます。

デザインパターンも同じです。 デザインパターンごとに、 クラスやインタフェースには それぞれの役割が割り振られます。 各クラスやインタフェースの役割を理解しなければ、 ドラマ全体のパターンを見抜くこともできませんし、うまく型にはめてやることもできま せん。うっかり、主人公を敵方に従わせてしまったり、ヒロインを悪役にしてしまったり することにもなりかねません。 また、コメディなのに悲劇にしてしまったり、 ドキュメン タリーなのに作り話のようにしてしまったりします。

以下の各章では、デザインパターンを1つずつ紹介していきます。 そのときに、パター ンに登場する役割もあわせて紹介します。 サンプルコードを読むときには、単純にプログ ラムとして読むだけではなく、 各クラスやインタフェースが、このパターンの上ではどの ような役割を果たしているかに注目しつつ読んでいくようにしましょう。

同じパターンなら、クラスの名前は違っていても、 役割の対応がつきます。 そして役割 の対応がつけば理解もしやすくなります。 具体的な役者が誰であっても、誤りなく劇全体 を見通せるようになるでしょう。

いま観ているのが 「白雪姫」の劇なら、 具体的な役者が誰であれ、王子は白雪姫に恋を するでしょう。そしてドラマの最後には、 白雪姫は王子のキスを受け、 目覚めることにな

るのです。

それでは、いよいよ、 個々のパターンを学んでいきましょう。



第1章 Iterator

処理を繰り返す

Iterator パターン

Java言語で配列arrの要素をすべて表示するには、 for 文を使って次のように書きます。

for (int i = 0; i < arr.length; i++) { System.out.println(arr[i]);) 1

ここで使われているループ変数に注目しましょう。 変数 iは、最初0で初期化され、 1, 2, 3, と増えていきます。 そしてそのつど、 arr[i] の内容が表示されます。 配列は要素がたくさん集まったもので、添え字を指定することで、たくさんの要素の中 から1個を選ぶことができます。

arr [D] 最初の要素 (0番目の要素) arr [1] その次の要素 (1番目の要素) arr[i] i番目の要素 B

arr[arr.length -1] 最後の要素

for文の i++でiを1ずつ増加させていくと、 現在注目している要素を「次」 「その次」 「そのまた次」に進めていることになります。 このようにしてiを増やしていくと、配列 arr の要素全体を最初から順番にスキャン (走査) していることになります。 ここで使われている変数」の働きを抽象化し、 一般化したものを、 デザインパターンで

は、

Iterator パターン

と呼んでいます。

Iteratorパターンとは、何かがたくさん集まっているときに、それを順番に指し示して イテレート いき、 全体をスキャンして処理を繰り返すものです。 iterate という英単語は何かを 「繰り 「返す」という意味です。 iteratorは日本語では反復子と呼ばれることがあります。

この章ではIteratorパターンを学びましょう。

なお、Javaでは通常このようなfor文は拡張for文を使って書きます (p.10参照)。

2

サンブルプログラム 3

サンプルプログラム

さっそくIteratorパターンを使ったサンプルプログラムを読んでみましょう。 ここで作 るプログラムは、 本棚 (BookShelf) の中に本 (Book) を入れ、 その本の名前を順番に表 示するというものです (Fig.1-1)。

| Fig.1-1 サンプルプログラムのイメージ図

BookShelf BookShelf Iterator Book

| Iterable<E> インタフェース

テラブル Iterable<E> インタフェース (List 1-1) は、 処理を繰り返す対象を表すもので、 java.lang パッケージで宣言されています。 このインタフェースを実装しているクラスは、 配列のように 「何かがたくさん集まっているもの」 いわば「集合体」 になります。 iterable という英単語は「繰り返すことができる」 や 「反復可能である」という意味です。

Iterable<E>のうちEは型パラメータと呼ばれるもので、ここでは 「集まっているもの」 を表す型を指定します。 サンプルプログラムではBookを集めたインタフェースを使いま すから、 Iterable<Book> という形で使うことになります。 これは後ほどList 1-4で登場 します。

41erator

Fig.1-2 サンプルプログラムのクラス図

<<interface>> Iterable<Book> iterator Creates▸ ACCE <<interface>> Iterator<Book> hasNext next books last BookShelf getBookAt appendBook getLength iterator name getName Book Δ BookShelfIterator bookShelf index hasNext next

Table 1-1 クラスとインタフェース一覧

名前 Iterable<E> 解說 集合体を表すインタフェース (java.langパッケージ) Iterator <E> サンプルプログラムではIterable<Book> として使用 処理を繰り返す反復子を表すインタフェース (java.utilパッケージ) サンプルプログラムではIterator <Book> として使用 本を表すクラス Book BookShelf 本棚を表すクラス BookShelfIterator 本棚をスキャンするクラス Main 動作テスト用のクラス

サンプルプログラム 5

List 1-1

Iterable<E> インタフェース (java.lang.Iterable からの抜粋)

1: public interface Iterable<E> { 2: public abstract Iterator <E> iterator(); 3: )

Iterable<E> インタフェースではiteratorメソッドが宣言されています。このメソッ ドは集合体に対応する Iterator<E>を1個作成するためのものです。

集合体に含まれている1つ1つの要素を処理していきたいときには、このiterator メソ ッドを使って Iterator <E> インタフェースを実装したクラスのインスタンスを1個作りま す。

| Iterator<E > インタフェース

次に、Iterator<E>インタフェース (List 1-2) を見てみましょう。 Iterator <E > イン タフェースは1つ1つの要素の処理を繰り返すためのもの、ループ変数のような役割を果 たすものです。

List 1-2 Iterator << E> インタフェース (java.util. Iterator からの抜粋)

1: public interface Iterator<E> ( 2: 3: public abstract boolean hasNext(); public abstract E next(); 4: )

ここに宣言されているメソッドは2つです。 「次の要素」が存在するかどうかを調べる ためのhasNext メソッドと、 「次の要素」を得るための nextメソッドです。 hasNext メソッドの戻り値が boolean 型である理由はわかりますね。 次の要素が存在し たら、このメソッドはtrueを返します。 次の要素が存在しなかったら、つまり最後の要 素まですでにたどり着いていたら、このメソッドの戻り値は false になります。 hasNext メソッドはループの終了条件で使うためのものです。

nextメソッドには少し説明が必要です。 戻り値の型が型パラメータのEになっているこ とからわかるように、このnextメソッドは集合体の要素を1個返してくれます。しかし、 next メソッドの仕事はそれだけではありません。 この次、 nextメソッドを呼び出したと きに、ちゃんと次の要素を返すように、 内部状態を次に進めておくという仕事が裏に隠れ

第1章 Iterator処理を繰り返す

ているのです。 「裏に隠れているのです」 といわれても、 Iterator <E > インタフェースで はメソッド名しかわかりませんね。 具体的な動きは、このIterator <E> インタフェース を実装しているクラス (BookShelfIterator) の方で見ていきましょう。 そうすれば、 もう少しnextメソッドの働きがはっきりします。

Bookクラス

Book クラス (List 1-3) は本を表すクラスです。 とはいっても、 できることはあまりあ りません。 できるのは本の名前をgetNameメソッドで得ることだけです。 本の名前は、コ ンストラクタでインスタンスを初期化するときに引数で指定します。

List 1-3 Bookクラス (Book.java)

1: public class Book ( 2: private String name; 3: 4: public Book (String name) ( 5: this.name = name: 6: } 7: 8: 9: public String getName() return name; 10: } 11: )

BookShelf クラス

Bookshelf クラス (List 1-4) は本棚を表現しているクラスです。 このクラスは集合体 として扱うために Iterable<Book>インタフェースを実装しています。 ソース中の 「implements Iterable<Book>」 という部分が、 Iterable<Book> インタフェースを実装 していることを表現しています。 また Iterable<Book> インタフェースで宣言されていた iterator メソッドの実体が書かれていることも確認してください。

オーバーライド iterator メソッドの前に、 @Override と書かれています。 これは、 iterator メソッド が Iterableインタフェースで宣言されているメソッドをオーバーライドして実装したも のであることを表しています。 @Overrideは付加的な情報 (アノテーション)の一種です。 @Override アノテーションがついているメソッドは他のクラスやインタフェースとの関連 で重要な役割を担いますから、ソースコードを読む際にはよく意識してください。

サンプルプログラム 7

List 1-4 BookShelf (BookShelf.java)

1: import java.util. Iterator;

2:

3: public class BookShelf implements Iterable<Book> {

5:

4:

private Book [] books;

private int last = 0;

6:

7:

public Bookshelf (int maxsize){

8:

this.books = new Book [maxsize];

)

public Book getBookAt(int index) { return books [index];

9:

10:

11:

12:

13:

14:

15:

16:

public void appendBook (Book book) (

this.books (last] = book; last++;

17:

この本棚は、 books というフィールドを持っています。 このフィールドはBookの配列 です。 この配列の大きさは、最初にBookShelfのインスタンスを作るときに引数 (maxsize) で指定します。 books フィールドを private にしているのは、このクラス外から直接アク セスされるのを防ぐためです。

}

18:

19:

public int getLength() (

21:

return last;

22:

23:

@Override

public Iterator <Book> iterator () (

24:

25:

return new Bookshelf Iterator (this);

28: )

26:

20:

27:

さて、 iterator メソッドです。 このメソッドは、 BookShelf クラスに対応する Iterator として、 BookShelfIterator というクラスのインスタンスを生成してそれを返します。 この本棚の本を繰り返して処理したいときに、このiterator メソッドが呼び出されます。

}

}

10 Iterator 811

BookShelfiterator 57

それでは、BookShelfクラスのスキャンを行う BookShelfIteratorクラス (List 1-5) を見てみましょう。

List 1-5 BookShelfiterator 2 (BookShelfiterator.java)

1: import java.util.Iterator;

2: import java.util.NoSuchElementException;

3:

4: public class BookShelfIterator implements Iterator<Book> {

5:

6:

private Bookshelf bookshelf;

private int index;

7:

8:

public BookShelf Iterator (BookShelf bookShelf) {

9:

this.bookshelf

this.index = 0;

bookshelf;

10:

11:

12:

13:

}

@Override

14:

public boolean hasNext() {

if (index <bookShelf.getLength()) (

return true;

15:

16:

} else {

17:

18:

19:

return false;

22: 23: 24: 25: 26: ' 27: 28: 29: 30: 31: ) @Override public Book next() { ) if (!hasNext()) ( throw new NoSuchElementException(); Book book bookshelf.getBookAt(index); index++; return book;

}

20:

21:

BookShelfIterator は、 Iterator < Book> インタフェースを実装していますので、 Iterator < Book型として扱うことができます。

bookshelf フィールドは、このBookShelfIterator がスキャンする本棚です。 そして

サンプルプログラム

indexフィールドが現在注目している本を指す添え字になります。

コンストラクタでは、 渡されたBookshelfのインスタンスをbookshelf フィールドに保 存し、 index を0にします。

hasNextメソッドは、 Iterator < Book> インタフェースで宣言されているメソッドを実 装したものですね。 「次の本」 があるかどうかを調べ、 あるならtrue、 ないなら false を 返します。 次の本があるかどうかは、 index が本棚の本の冊数 (式 bookshelf.getLength() の 値) よりも小さいかどうかで判定します。

next メソッドは、現在注目している本 (Bookのインスタンス)を返し、さらに 「次」 へ進めるためのメソッドです。 これも、 Iterator <Book> インタフェースで宣言されてい るメソッドでした。 ここはちょっぴり複雑ですね。 まず、 戻り値として返すべき本を bookという変数にとっておき、 index を次に進めてからbook を return します。

この 「index を次に進めておく」 という処理は、冒頭の for文 (p.2) でいえば、 i++に 相当する処理です。 ループ変数を 「次」 に進めたのです。

| Main クラス

ここまでで、 本棚をスキャンする準備ができました。 では、 Mainクラス (List 1-6) 使って、 小さな本棚を作り、 本を表示してみましょう。

List 1-6 Mainクラス (Main.java)

1: import java.util.Iterator;

2:

3: public class Main ( 4: 5: 6: 7: 8: 9: 10: 11: 12: 13: 14: 15: 16: 17: public static void main(String[] args) { BookShelf bookshelf = new BookShelf(4); bookshelf.appendBook (new Book ("Around the World in 80 Days")); bookshelf.appendBook (new Book ("Bible")); bookshelf.appendBook (new Book ("Cinderella")); bookshelf.appendBook (new Book ("Daddy-Long-Legs*)); // 明示的に Iteratorを使う方法 Iterator <Book it = bookshelf.iterator(); while (it.hasNext()) { Book book it.next(); System.out.println(book.getName()); System.out.println();

18:

10 第1章 Iterator処理を繰り返す

19: // 拡張for文を使う方法 20: 21: 22: } 23: for (Book book: bookShelf) ( System.out.println(book.getName()); System.out.println(); 24: } 25: 1

まず、本が4冊入る本棚を作ります。 そして順番に、

Around the World in 80 Days (80日間世界一周 )

Bible (聖書)

Cinderella (シンデレラ)

Daddy-Long-Legs (あしながおじさん)

という4冊の本を作って入れました。 本の名前は、順番がわかりやすいように頭文字がA, B,C,Dとアルファベット順にしました。

その後、 bookshelf という本棚に入った4冊の本を2つの方法で順番に表示しています。 1つ目は 「明示的に Iterator を使う方法」 です。 bookshelf.iterator () によって得ら れるitが、 本棚をスキャンするための Iterator < Book> のインスタンスです。 while文の 条件にはもちろんit.hasNext() と書き、 スキャンしていない本がある限り while文のル ープが回ることになります。 そしてループの中でit.next() によって本を得て、それを表 示しています。

2つ目は 「拡張for文を使う方法」 です。 拡張for文は直前のwhile文とまったく同じ動 作をします。 すなわち、拡張for文を使うとIterator を使った繰り返し処理を簡潔に書 くことができるのです。

一般に、 Javaの拡張for文は、 Iterableインタフェースを実装しているクラスのイン スタンスに対して、 内部的に Iterator を使って実現されています。 つまり、Javaの拡張 for文の背後ではIteratorパターンが使われているといえます。

なお、 Javaの配列は Iterableインタフェースを実装しているわけではありませんが、 拡張for文を使って要素に対する繰り返し処理を書くことができます。 例えば、 intの配 列arrの要素に対する繰り返し処理は、次のように書き直せます。

// ループ変数を使った例 for (int i = 0; i < arr.length; i++) { ) System.out.println(arr[i]); -> // 拡張for文を使った例 for (int e: arr) { } System.out.println(e);

Iterator パターンの登場人物 11

Fig.1-3 実行結果

Around the World in 80 Days Bible Cinderella Daddy-Long-Legs Around the World in 80 Days Bible Cinderella Daddy-Long-Legs

Iterator パターンの登場人物

サンプルプログラムを読み終えたところで、 Iteratorパターンの登場人物をまとめてみ ましょう。

イテレータ Iterator (反復子) の役

要素を順番にスキャンしていくインタフェース (API) を定める役です。 サンプルプロ グラムでは、 Iterator <E> インタフェースがこの役をつとめ、次の要素が存在するかどう かを得るためのhasNextメソッドと、 次の要素を得るための nextメソッドを定めていまし た。

コンクリート イテレータ Concretelterator (具体的な反復子)の役

Iterator 役が定めたインタフェース (API) を実際に実装する役です。 サンプルプログラ ムでは、 BookShelfIteratorクラスがこの役をつとめました。 この役はスキャンするため に必要な情報を持っている必要があります。 サンプルプログラムでは、BookShelf クラスの インスタンスをbookShelf フィールドで覚えており、注目している本をindexフィールド で覚えていました。

アグリゲート Aggregate (集合体)の役

Iterator 役を作り出すインタフェース (API) を定める役です。 そのインタフェース (API) は、 「私が持っている要素を順番にスキャンしてくれる人」 を作り出すメソッドと いうことになります。 サンプルプログラムでは、 Iterable<E> インタフェースがこの役を つとめ、 iteratorメソッドを定めていました。

第1章 Hernor ator

処理を繰り返す

コンクリート・ア ConcreteAggregate (具体的な集合体)の役

Aggregate 役が定めたインタフェース (API) を実際に実装する役です。 具体的な Iterator 役 すなわち Concretelterator 役のインスタンスを作り出します。 サンプルプログ ラムでは、BookShelfクラスがこの役をつとめ、 iteratorメソッドを実装していました。

以上のIteratorパターンをクラス図で表記すると、 Fig.1-4のようになります。

| Fig.1-4 Iterator パターンのクラス図

<< interface>> iterator Aggregate ConcreteAggregate iterator Creates▸ <<interface>> Iterator hasNext next ConcreteIterator aggregate hasNext next

あなたの考えを広げるためのヒント

| 実装がどうであれ、 Iteratorを使える

どうして Iteratorパターンなんて面倒なものを考える必要があるのでしょう。 配列だっ たら for文でくるくる回せばいいじゃないですか。 なぜ集合体の外に Iterator役などと いうものを作る必要があるのでしょう。 大きな理由は、Iteratorを使うことで、 実装と切り離して繰り返しを行えるからです。 次のコードを見てください。

while (it.hasNext()) { Book book = it.next(); System.out.println(book.getName());

12

あなたの考えを広げるためのヒント 13

ここで使われているのは、 hasNext と nextというIteratorのメソッドだけです。 BookShelf の実装で使われているメソッドは呼び出されていません。 つまり上のwhileル ープは、 BookShelf の実装には依存しないことになります。

Bookshelf を実装した人が、 配列を使って本を管理することをやめて、 java.util.ArrayList を使うようにプログラムを修正したとしましょう。 Bookshelf をどのように修正しようと も Bookshelf が iterator メソッドを持っており、 正しいIterator < Book> を返してく れれば(つまり、 hasNext と nextメソッドが正しく実装されているクラスのインスタン スを返してくれれば)、 上記のwhileループはまったく変更しなくても動作するのです。

これは、 BookShelfの利用者にとってはうれしいことです。 デザインパターンはクラス の再利用化を促進するものです。 再利用化を促進するとは、クラスを部品として使えるよ うにするということであり、 1つの部品を修正しても、他の部品の修正が少なくてすむ、 ということなのです。

こう考えてくると、サンプルプログラムで、 メソッドiteratorの戻り値を BookShelf Iterator 型の変数に代入せず、 Iterator < Book型の変数に代入している理由もわかりま すね (List 1-6の12行目)。 BookShelfIteratorのメソッドを使ってプログラミングを行う のではなく、あくまでIterator<Book>のメソッドを使ってプログラミングを行おうとい う姿勢を示しているのです。

抽象クラスやインタフェースはどうも苦手で・・・

抽象クラスやインタフェースの使い方がよくわからない人は、 Iterable<E> や Iterator <E> のようなインタフェースを使ってプログラミングするのではなく、具体的なクラスだけを 使ってプログラミングしてしまいがちです。

しかし、具体的なクラスだけを使うと、 クラス間の結合が強くなってしまい、 部品とし て再利用することが難しくなります。 結合を弱め、クラスを部品として再利用しやすくす るために、 抽象クラスやインタフェースが導入されます。

これは、本書全体を通じて頻繁に登場する考え方ですので、いまはピンとこなくても、 読み進むうちにだんだんわかってくるはずです。 「具体的なクラスだけでプログラミング するのではなく、 抽象クラスやインタフェースを使ってプログラミングする」 という考え 方を頭の隅に置いておいてください。

| Aggregate役と Iterator役の対応

ところで、 Bookshelf クラスに対応する ConcreteIterator 役としてBookShelfIterator クラスを定義したことを思い出してください。 Bookshelf Iterator は、 Bookshelf がど

第1章 Iterator処理を繰り返す

14

のように実装されているかを知っています。 実装を知っているからこそ、「次の本」 を得 るためのメソッド getBookAt を呼び出すことができたわけです。

ということは、もしもBookShelf の実装をがらりと変えてしまい、 getBookAtメソッド というインタフェース (API) も変更してしまった場合には、 BookShelfIterator は修正 が必要になります。

Iterable<E> とIterator<E> という2つのインタフェースが対になっているように、 Book Shelf と BookShelfIterator という2つのクラスも対になっているのです。

「次」は間違いやすい

next という名前のメソッドは間違いやすいものです。 このメソッドの戻り値は、現在 見ている要素なのでしょうか、それとも次の要素なのでしょうか。 nextメソッドは、 よ り詳しくいえば、

returnCurrent ElementAndAdvanceToNextPosition

とでも呼ぶべきものです。 すなわち、「現在の要素を返しつつ、 次の位置に進める」とい うことですね。

「最後」も間違いやすい

「次」 も間違いやすいですが、「最後」 も間違いやすいです。 hasNext メソッドは、 最 後の要素を得る前はtrueを返しますが、 最後の要素を得た後は false を返します。 注意 深く作らないと、 最後の1個を返し損ねる危険があります。

hasNextメソッドは、 「次にnextメソッドを呼んでも大丈夫かどうかを調べるもの」と 覚えておけばよいでしょう。

複数のIterator

「現在どこまでたどったかを覚えている仕組みがAggregate役の外に置かれている」と いうのは、 Iteratorパターンの特徴の1つです。 この特徴によって、 1つのConcrete Aggregate役に対して複数のConcretelterator役を作ることができます。

この章で学んだこと

Java

deletelterator l*TE

Javaでは、 使われなくなったインスタンスは自動的に削除されます (ガベージコレクシ ョン)。 ですから、 iterator に対応したdeleteIteratorメソッドは不要です。

関連しているパターン

Visitor パターン (第13章)

Iteratorパターンは、集合体の要素を1つずつ処理していくものです。 しかし、 Iterator <E> インタフェースの中にはその処理までは記述されていません。

Visitorパターンは、たくさんの要素が集まっている中を渡り歩きながら、 同じ処理を繰 り返し繰り返し適用していくというものです。

・Composite パターン (第11章) Composite パターンは再帰的な構造を持ったパターンです。 これに Iterator パターンを 適用するのは難しいです。

・Factory Method パターン (第4章)

iteratorメソッドが Iteratorのインスタンスを作成するときに、 Factory Methodパタ ーンが使われる場合があります。

この章で学んだこと

この章では、集合体の要素を、 統一した方法で1つ1つ処理していく Iteratorパターンに ついて学びました。 それでは練習問題をやってみましょう。

15

1章 erratorを繰り

16 第

練習問題

解答は付録A (p.402)

●問題 1-1

サンプルプログラムのBookShelfクラス (List 1-4) では、最初に指定した本棚の大き さを超えて本を入れることはできません。 無理に入れようとすると、 java.lang.Array IndexOutOfBoundsException という例外が発生します。 そこで、配列ではなく java.util ArrayListを使い、本棚の大きさを超えても本を追加できるようにしてください。

第2章 Adapter

一皮かぶせて再利用

09:0

第2章 Adapter度かぶせて再利用

Adapter パターン

例えば、直流12ボルトで動くノートパソコンを交流100ボルトのAC電源につなぐとし ましょう。 そのとき私たちは、ACアダプターという装置を使います。 ACアダプターは 家庭用の電源として提供されている 「交流100ボルト」 を、 いま必要な 「直流12ボルト」 に変換してくれます。 提供されているものと、必要なものとの間に入って、その間を埋め るのがアダプターの仕事です。 アダプターは英語でadapterと書き、 「adapt (適合)させ 「るもの」という意味です。ACアダプターは、直流12ボルトのパソコンを交流100ボルト の環境に adapt させているのです。

Fig.2-1 アダプターの役割

ACアダプター

交流100ボルト

直流12ボルト

プログラムの世界でも、すでに提供されているものがそのまま使えないときに、必要な 形に変換してから利用することがよくあります。 「すでに提供されているもの」と「必要 「なもの」の間の「ずれ」 を埋めるようなデザインパターン、これが

アダプター Adapter パターン

です。

ラッパー Adapter パターンはWrapper パターンと呼ばれることもあります。 wrapperとは 「包むも の」という意味です。 普通の商品をきれいな包み紙で包んで、 ギフト用品にするように、 何かをくるりと包んで別の用途に使えるように変換してくれるもの それがラッパーであ り、アダプターということになります。

Adapter パターンには以下の2種類があります。

18

サンプルプログラム (1) (水を使ったもの)

けいしょう

・クラスによるAdapter パターン (継承を使ったもの)

インスタンスによる Adapter パターン (委譲を使ったもの)

いじょう

本章では、この2種類のAdapterパターンについて順にお話します。

サンプルプログラム (1) (継承を使ったもの)

クラスによるAdapter パターンを使ったサンプルプログラムを読んでみましょう。 ここ で作るサンプルプログラムは、 Hello という与えられた文字列を

(Hello)

のように表示したり、

*Hello*

のように表示したりする簡単なものです。

いま、Banner クラス (bannerは 「広告の垂れ幕」という意味) には、 文字列をカッコ でくくって表示する showwithParenというメソッドと、 文字列の前後に印をつけて表示 するshowwithAster というメソッドが用意されています。 このBannerクラスを、交流 100ボルトのように 「すでに提供されているもの」 だと仮定します。

一方、Print インタフェースでは、文字列を弱く (カッコ付きで) 表示するためのメソ ッドprintWeak (weakは弱いという意味) と、 文字列を強く (*ではさんで強調して) 表 ウィーク ストロング 示するためのメソッド printStrong (strongは強いという意味) が宣言されているとしま す。このインタフェースが、 直流12ボルトのように「必要なもの」 だと仮定しましょう。 いまやりたいことは、Banner クラスを使って、 Printインタフェースを満たすような クラスを作ることです。 すなわち、 交流100ボルトを直流12ボルトに変換してくれるよう なアダプターを作ることです。

アダプターの役割を担うのが Print Bannerクラスです。 このクラスは、提供されてい るBannerクラスを継承し、必要とされている Printインタフェースを実装します。 Print Bannerクラスは、 showwithParenメソッドを使ってprintWeak を実装し、showWithAster メソッドを使ってprintStrong を実装するのです。 これでPrint Bannerクラスはアダプ ターとしての機能を果たすことになります。 電源の比喩とこのサンプルプログラムの対応 関係を Table 2-1に示します。

19

第2章 Adapterかぶせて再利用

Table 2-1 電源の比喩とサンプルプログラムの対応関係

電 源の比喩 提供されているもの 交流100ボルト サンプルプログラム 変換装置 アダプター Bannerクラス (showwithParen, showwithAster) Print Banner クラス 必要なもの 直流12ボルト Print 1971-7 (printWeak, printStrong)

Fig-2-2 「クラスによるAdapterパターン」 を使ったサンプルプログラムのクラス図 (継承を使う)

Main Uses <<interface>> Print printWeak printStrong PrintBanner printWeak printStrong Banner showWithParen showWithAster

Bannerクラス Bannerクラス (List 2-1) はあらかじめ提供されているクラスとします。

List 2-1 Banner 57 (Banner.java) 1: public class Banner ( 2: private String string; 3: 4: public Banner (String string) ( 5: this.string string: 6: 7: 8: public void showwith Paren () { 9: System.out.println("( string )*); 10: ) 11: 12: 13: public void showWithAster () [ System.out.println(*** string ***); 14: 15: )

20

サンプルプログラム (1) 水を使ったもの)

Printインタフェース

Printインタフェース (List2-2) が必要とされているインタフェースとします。

List 2-2 Print インタフェース (Print.java)

1: public interface Print ( 2: 3: 4: ) public abstract void printWeak(); public abstract void printStrong ();

PrintBanner クラス

PrintBanner クラス (List 2-3) がアダプターの役目を果たします。 用意されている Bannerクラスを拡張 (extends) して、 showwithParenメソッドとshowwithAster メソ ッドを継承します。 また、要求されているPrintインタフェースを実装 (implements) してprintWeak メソッドとprintStrong メソッドを実装しています。

オーバーライド @Override は、 printWeak と printStrong というメソッドに対する付加的な情報 (アノ テーション)の一種です。 この@Override アノテーションは、 printWeak と printStrong という2つのメソッドがPrintBannerクラスで勝手に作ったものではなく、 Printインタ フェースで宣言されているメソッドをオーバーライドして実装したものであることを表し ています。

List 2-3 PrintBanner 5 (PrintBanner.java)

1: public class PrintBanner extends Banner implements Print ( public PrintBanner (String string) ( super (string); @Override public void printWeak ( ) ( showwithParen(); 2: 3: 4: } 5: 6: 7: 8: 9: 10: 11: 12: 13: 14: 15: ) BOverride public void printStrong()( showwithAster();

21

第2章 Adapterかぶせて再利用

Main クラス

Main クラス (List 2-4) は、ここで作ったアダプター役のPrintBannerクラスを使って Hello という文字列を弱く (カッコ付きで)、 また強く (*ではさんで)表示します。

List 2-4 Main クラス (Main.java)

1: public class Main ( 2: 3: 4: 5: 6: } 7: ) public static void main(String[] args) { Print p = new PrintBanner ("Hello"); p.printWeak(); p.printStrong();

Fig-2-3 実行結果

(Hello)

*Hello*

ここで、Mainクラスの中ではPrintBannerのインスタンスをPrintインタフェース型 の変数に代入していることに注意してください。 このMainクラスはあくまでPrintとい うインタフェースを使って(つまりprintWeak メソッドとprintStrongメソッドを使っ て)、プログラミングをしているのです。 Bannerクラスや showwithParenメソッドや showwithAster メソッドは、 Mainクラスのソースコード上からはすっかり隠されていま す。 これはちょうど、ノートパソコンは直流12ボルトさえ提供してもらえば正しく動作 し、それを支えているのが (アダプターの向こう側にいるのが) 交流100ボルトだなんて ことは知らないのと似ています。

Print Bannerクラスがどういう風に実現されているかをMainクラスは知りません。 知 らないということは、 Mainクラスをまったく変更せずに Print Bannerクラスの実装を変 えられるということでもありますね。

22

サンプルプログラム (2) 香を使ったもの)

サンプルプログラム (2) (委譲を使ったもの)

先ほどのサンプルプログラムは 「クラスによる」 Adapterパターンでした。 今度は 「イ ンスタンスによる」 Adapterパターンを見てみましょう。 先ほどのサンプルプログラムで は 「継承」 を使って適合を行いましたが、 今度は 「委譲」を使います。

ちょっと一言 委譲について

いじょう 委譲というのは堅苦しい表現ですが、要するに 「誰かにおまかせする」 というこ とです。重要な会議に出席できないとき、 委任状というものを書きます。 「私は出席 できませんが、 私の代わりとして佐藤さんにお願いします」 というものです。 委譲と いうのは委任と同じです。 Javaでの委譲は、あるメソッドの実際の処理を他のインス タンスのメソッドにまかせてしまうことをいいます。

Mainクラス、Bannerクラスは先ほどのサンプルプログラム (1) と同じで、 実行結果も同 じです。 しかし、 Printはインタフェースではなくクラスだと仮定します (List 2-5)。

たんいつ つまり、Bannerクラスを利用して、 Print クラスと同じメソッドを持つクラスを実現 しようというのです。 Javaでは、2つのクラスを同時に継承することはできません (単一 継承)。 Java では、 PrintBannerクラスを、 Print と Bannerの両方のサブクラスとして定 義することはできないのです。 けいしょう

Print Banner クラス (List 2-6) は、 banner フィールドでBannerクラスのインスタン スを保持します。 このインスタンスはPrint Bannerクラスのコンストラクタで生成しま す。 そして、 printWeak および printStrongメソッドでは、 そのbanner フィールドを介 してshowWithParen, showwithAsterメソッドを呼び出すのです。

PrintBanner クラス (List2-6) の printWeak と printStrong という2つのメソッドは、 Print クラス (List 2-5) で宣言されているメソッドをオーバーライドして実装したもの ですから、 List2-3と同様にメソッドの前に@Override アノテーションが書かれています。

List 2-3では、 自分のスーパークラスから継承したshowwithParen, showwithAster メソ ッドを呼んでいましたが、 List 2-6ではbanner フィールド経由で呼び出しています。

ほら、委譲が出てきましたね。 PrintBannerクラスのprintWeak メソッドが呼ばれたと き、自分で処理をするのではなく、別のインスタンス (Bannerのインスタンス)のshow WithParenメソッドにおまかせしているのです。

23

Adapter--

Fig.2-4 インスタンスによるサンプルプログラムのクラス図 (委譲を使う)

Main Uses Print printWeak printStrong PrintBanner banner printWeak printStrong Banner showWithParen showWithAster

| Print クラス

List 2-5 Print 757 (Print.java)

1: public abstract class Print ( 2: 3: 4: ) public abstract void printWeak (); public abstract void printStrong ();

PrintBanner 57

List 2-6 PrintBanner 552 (PrintBanner.java)

1: public class PrintBanner extends Print ( private Banner banner; 2: 3: 4: public Print Banner (String string) ( 5: this. banner new Banner (string); 6: 7:

24

Adapter パターンの登場人物 25

@Override public void printWeak() { banner.showwithParen(); 8: 9: 10: 11: } 12: 13: 14: 15: 16: } 17: ) @Override public void printStrong () ( banner.showwithAster();

Adapterパターンの登場人物

Adapter パターンの登場人物は、次のとおりです。

ターゲット Target (対象) の役

いま必要となっているメソッドを定めている役です。 ノートパソコンを動かすための直 流12ボルトですね。 サンプルプログラムでは、 Print インタフェース (継承の場合) Print クラス (委譲の場合) がこの役をつとめました。

クライアント Client (依頼者)の役

Target役のメソッドを使って仕事をする役です。 直流12ボルトで動くノートパソコン ですね。 サンプルプログラムでは、 Main クラスがこれに相当します。

アダブティー Adaptee (適合される側) の役

Adapt-er (適合する側) じゃなくて Adapt-ee (適合される側) です。 Adaptee は、すで に用意されているメソッドを持っている役です。 交流100ボルトのAC電源ですね。 サン プルプログラムでは、Banner クラスがこの役をつとめました。

このAdaptee役のメソッドがTarget役のメソッドに一致していたら (つまり家庭に提供 されているのが最初から直流12ボルトだったら)、 次のAdapter 役はいらなかったのです がね...。

Adapterの役

アダプター

Adapter パターンの主人公です。 Adaptee役のメソッドを使って何とかTarget役を満た そうというのがAdapter パターンの目的であり、 Adapter 役のお仕事です。 交流100ボルト

26 第2章 Adapter度かぶせて再利用

直流12ボルトに変換するアダプターです。 サンプルプログラムでは、 Print Banner クラ スがこの役をつとめました。

クラスによるAdapterパターンの場合には、Adapter 役は 「継承」 を使って Adaptee役を 利用します。

一方、インスタンスによるAdapter パターンの場合には、「委譲」 を使って Adaptee役を 利用します。

この2つのAdapterパターンをクラス図で表記すると、 Fig.2-5とFig.2-6のようになりま す。

あなたの考えを広げるためのヒント

どんなときに使うのだろう

「必要なメソッドがあるなら、それをプログラミングすればいいじゃないか。 どうして Adapter パターンなどというものを考える必要があるのか」 と疑問に思う読者もいると思 います。 Adapter パターンはどんなときに使うのでしょうか。

私たちは、いつもゼロからプログラミングするとは限りません。 すでに存在しているク ラスを利用することもよくあります。 特にそのクラスが十分にテストされ、バグが少なく、 また実際にこれまで使われてきた実績があるのならば、なおさらです。 何とかそのクラス を部品として再利用したいものです。

Adapter パターンは、既存のクラスに一皮かぶせて必要とするクラスを作ります。 この パターンによって、必要とするメソッド群をすばやく作ることができます。 もしバグが出 たとしても、既存のクラス (Adaptee役) にはバグがないことがわかっているのでAdapter 役のクラスを重点的に調べればよいことになり、 プログラムのチェックがとても楽になり ます。

たとえソースがなくても

すでに作られたクラスがあって、 新しいインタフェース (API) に適合させる、と考え ると、 Adapterパターンというのは当たり前のことのように感じられます。 しかし、 私た ちは、新しいインタフェース (API) に適合させようとするとき、つい既存のクラスのソ ースをいじって 「修正」 しようと考えてしまいます。 「ここをちょいと変えればきっと仕 事はおしまいだな」と考えてしまうのです。 でもそれでは、動作テストがすんでいる既存 のクラスを、修正後にもう一度テストしなければならなくなってしまいます。

あなたの考えを広げるためのヒント

Fig.2-5 クラスによるAdapter パターンのクラス図 ( 継承を使う)

Client Uses <<interface>> Target implements Adapter extends ▸ Adaptee targetMethodi targetMethodi targetMethodz methodA methodB targetMethod2 methodc

Fig.2-6 インスタンスによる Adapter パターンのクラス図 (委譲を使う)

Client Uses Adaptee Target extends Adapter has▸ targetMethodi targetMethod2 adaptee targetMethodi targetMethod2 methodA methodB methodC

Adapter パターンは、既存のクラスにはまったく手を加えずに、 目的のインタフェース (API)にあわせようとするものです。 また、 Adapterパターンでは、既存のクラスのソー スプログラムは必ずしも必要ではありません。 既存のクラスの仕様だけがわかれば、 新し いクラスを作ることができるのです。

バージョンアップと互換性

ソフトウェアにはバージョンアップがつきものです。ソフトウェアをバージョンアップ

27

第2章 Adapterかぶせて再利用

するときに問題になるのが 「古い版との互換性」 です。 しばしばレガシーシステム (legacy system)とも呼ばれる古い版を捨ててしまえればソフトウェアのメンテナンスは 楽なのですが、いつもそれができるとは限りません。 古い版と新しい版とを共存させて、 しかもメンテナンスを楽に行うために Adapter パターンが役に立つことがあります。

例えば、今後は新しい版だけをメンテナンスしたいとします。 その場合は新しい版を Adaptee役とし、 古い版をTarget役とします。 そして、新しい版のクラスを使って古い版 のメソッドを実装する Adapter役のクラスを作るのです。

この関係を表現した概念図をFig. 2-7に示します (これはUMLによる図ではありませ ん)。

かけ離れたクラス

もちろん、Adapte役と Target 役の機能があまりにもかけ離れている場合には、Adapter パターンは使えません。 交流100ボルトの電源を元にして水道の水を出すわけにはいきま せんからね。

継承と委譲のどちらを使うべきか

継承と委譲の2種類のサンプルプログラムを紹介しましたが、 実際にはどちらを使うべ きでしょうか。 一般的には、継承を使うよりも委譲を使う方がトラブルが少なくなります。 それは、スーパークラスの内部的な振る舞いを詳しく知らないと、継承を効果的に使うの が難しい場合が多いからです。

Fig. 2-7 過去のバージョンとの互換性を取るためのAdapter パターン

Version 1.0対応の プログラム Version 2.0対応の プログラム Version 1.0対応の プログラム MyClass Version 1.0 1.0-2.0 変換アダプター MyClass Version 2.0

28

この章で学んだこと

関連しているパターン

◆ Bridge パターン (第9章) Adapter パターンは、インタフェース (API) が異なっているクラス同士を結びつけるパ ターンです。 Bridge パターンは、 機能の階層と実装の階層を結びつけるパターンです。

Decorator パターン (第12章)

Adapter パターンは、インタフェース (API) のずれを埋めるためのパターンです。 Decoratorパターンは、インタフェース (API) を変えずに機能を追加するパターンです。

この章で学んだこと

この章では、インタフェース (API) が異なっている2つの間に入って、 そのずれを埋 めるためのAdapter パターンについて学びました。 継承を使ったものと、委譲を使ったも のを紹介し、 それぞれの特徴についてお話しました。

どうですか だいぶデザインパターンに慣れてきましたか。 練習問題にもぜひ取り組ん でみてください。

29

第2章 Adapterかぶせて再利用

練習問題

解答は付録A (p.404)

問題2-1

[Java

サンプルプログラムでは、 Print Bannerクラスのインスタンスを作るときに、次のよう にPrint型の変数に代入しています (List2-4)。

Print p = new PrintBanner ("Hello');

なぜ、次のようにPrintBanner型の変数に代入しないのでしょう。

PrintBanner p = new PrintBanner ("Hello");

問題2-2 java.util.Properties クラスは、

depth=32

|width=1024

height=512

のような、キーとその値の組 (プロパティ) を管理するためのものです。 java.util.Properties クラスには、プロパティを java.io.Reader経由で読んだり java.io.Writer経由で書い たりするために、次のメソッドが用意されています。

public void load (Reader reader) throws IOException プロパティの集合を Reader経由で読み込む。

public void store (Writer writer, String comments) throws IOException プロパティの集合をWriter経由で書き込む。 comments はコメント文字列。

Adapterパターンを使って、プロパティの集合をファイルに保存する FileProperties クラスを作ってください。

ここで、プロパティの集合をファイルに保存するメソッドはList2-7のFileIOインタ フェース (Target役) で宣言するものとし、 FilePropertiesクラスはこのFileIOインタ フェースを実装するとします。

実行前のfile.txtおよび実行後の newfile.txt は List 2-9 と List 2-10のようになります (# で 始まる行は、 java.util. Propertiesクラスによって自動的に付加されるコメントです)。 FileProperties クラスがあれば、 java.util. Propertiesクラスのメソッドについて 知らなくても、 FileIOインタフェースのメソッドさえ知っていればプロパティを扱える ことになります。

30

電源の比喩でいえば、 java.util. Properties クラスが提供されている交流100ボルト に、FileIOインタフェースが必要とされている直流12ボルトに、 そしてFileProperties クラスがアダプターになります。

List 2-7 Filelo 1371-7 (Filelo.java)

1: import java.io.IOException; 2: 3: public interface FileIO ( public void readFromFile (String filename) throws IOException; 4: 5: public void writeToFile(String filename) throws IOException; 6: 7: public void setValue(String key, String value); public String getValue(String key); 8: }

List 2-9

入力ファイル (file.txt)

width=640

31

List 2-8 Main 7 (Main.java)

1: import java.io.IOException; 2: 3: public class Main ( 4: public static void main(String[] args) { 5: FileIo f = new FileProperties(); try { 6: 7: 8: 9: 10: 11: 12: 13: 14: 15: } 16: ) 17: ) f.readFromFile("file.txt"); f.setValue("width", "1024"); f.setValue("height", "512"); f.setValue("depth", "32"); f.writeToFile("newfile.txt"); System.out.println("newfile.txt is created."); } catch (IOException e) ( e.printStackTrace();

第2章 Mater度かぶせて再利用

List 2-10 771 (newfile.txt)

written by FileProperties #Thu Jul 01 18:57:34 JST 2021 depth=32 width=1024 height=512

32

第3章

Template Method 具体的な処理を

サブクラスにまかせる

第3章 Template Method 具体的サブクラスにまかせる

|Template Method パターン

テンプレートとは何か

テンプレートというのは、文字の形に穴が空いている薄いプラスチックの板のことで す。 その穴をペンでなぞると、 手書きでも整った文字を書くことができます。 テンプレー トの穴を見ればどのような形の文字が書けるかはわかりますが、 実際にどういう文字にな るかは、具体的な筆記用具が決まらなければわかりません。 サインペンを使えばサインペ ンで書いた文字になりますし、鉛筆を使えば鉛筆で書いた文字になります。 また色鉛筆を 使えば色つきの文字になるでしょう。しかし、 どの筆記具を使ったとしても、書かれる文 字はテンプレートの穴の形どおりの文字になるはずです。

Fig.3-1 テンプレートをサインペンでなぞる 0123456789 012345

Template Method パターンとは何か

この章で学ぶTemplate Method パターンは、テンプレートの機能を持つパターンです。 スーパークラスの方にテンプレートとなるメソッドが定義されています。 そのメソッドの 定義の中では抽象メソッドが使われています。 このため、スーパークラスのプログラムを 読んでいるだけでは、最終的にどんな処理をすることになるかはわかりません。 わかるの は、抽象メソッドをどのように呼び出しているか、ということだけです。

抽象メソッドを実際に実装するのはサブクラスです。 サブクラスの側でメソッドを実装 すれば、具体的な処理が決定します。 異なるサブクラスが異なる実装を行えば、 異なる処 理が行われるでしょう。 しかし、 どのサブクラスでどのような実装をしたとしても、 処理

34

サンプルプログラム 35

の大きな流れはスーパークラスで組み立てたとおりになります。

このように、スーパークラスで処理の枠組みを定め、 サブクラスでその具体的内容を定 めるようなデザインパターンを、

Template Method パターン

テンプレート・メソッド

と呼びます。この章ではTemplate Methodパターンについて学びます。

サンプルプログラム

Template Methodパターンを使ったサンプルプログラムを読んでみましょう。 ここで作 るサンプルプログラムは、 「文字や文字列を5回繰り返して表示する」 という簡単なもので す。

ここでは、AbstractDisplay, CharDisplay, StringDisplay, Mainの4つのクラス が登場します。

AbstractDisplayクラスではdisplayメソッドが定義されています。 そして、 display メソッドの中では open, print, close という3つのメソッドが使われています。 この open, print, close という3つのメソッドも、 AbstractDisplayクラスの中で宣言され ていますが、 実体がない抽象メソッドになっています。 ここでは、 抽象メソッドを使って いる display メソッドがテンプレートメソッドになります。

open, print, closeメソッドを実際に実装しているのは、 AbstractDisplayクラスの サブクラスである CharDisplayクラスやString Displayクラスです。 Main クラスは動作テストのためのクラスです。

Table 3-1 クラス一覧

名前 解說 AbstractDisplay メソッド displayのみ実装されている抽象クラス CharDisplay StringDisplay Main メソッド open, print, close を実装しているクラス メソッド open, print, close を実装しているクラス 動作テスト用のクラス

第3章 Template Method 具体的な処理をサブクラスにまかせる

Fig.3-2 サンプルプログラムのクラス図 CharDisplay AbstractDisplay cpen print close display StringDisplay open print close printLine ロゼ

open print close

AbstractDisplayクラス

AbstractDisplayクラス (List 3-1) は、 open, print, close, display というメソ ッドを持っているクラスです。 このうち open, print, closeは抽象メソッドで、 display メソッドのみが実装されています。 AbstractDisplayクラスに書かれている display メ ソッドの定義を読むと、次の処理を行っていることがわかります。

openメソッドを呼び出す *printメソッドを5回呼び出す closeメソッドを呼び出す

それでは, open, print, closeの各メソッドは何をしているのでしょうか。 Abstract Displayクラスを見てみると、この3つは抽象メソッドになっているのがわかります。 つ まり、 AbstractDisplayクラスのdisplay が 「実際に」 何をするかは、 AbstractDisplay クラスを見ただけではわからないことになります。 実際に何をするのかは、 open, print, close を実装するサブクラスにまかされているのです。

36

サンプ サンプルプログラム 37

List 3-1

AbstractDisplay 757 (AbstractDisplay.java)

2: 3: 1: public abstract class AbstractDisplay ( // open, print, closeはサブクラスに実装をまかせる抽象メソッド public abstract void open(): 4: public abstract void print(); 5: public abstract void close(); 6: 7: // display は AbstractDisplay で実装しているメソッド 8: 9: 10: 11: 12: ) 13: public final void display() ( open(); for (int i = 0; i < 5; i++) ( print(); close(): 14: 15: )

| CharDisplayクラス

ここまで理解できたら、今度はサブクラスの1つである Char Displayクラス (List 3-2) を見てみましょう。 スーパークラスのAbstractDisplayクラスで抽象メソッドになって いた open, print, close がすべて実装されていますので、 CharDisplayクラスは抽象ク ラスではありません。 また open, print, closeはスーパークラスのメソッドをオーバー ライドしているメソッドですから、 @Overrideアノテーションが書かれています。 CharDisplayクラスの open, print, close は Table 3-2のような処理を行っています。

Table 3-2 CharDisplayクラスのopen, print, close メソッドの処理

メソッド名 処理 open 文字列 <<* を表示する print close コンストラクタで与えられていた1文字を表示する 文字列 >>" を表示する

displayメソッドが呼ばれたら何が表示されるでしょうか。 例えば、 コンストラクタに 'H' という文字が渡されていたとすると、

<<HHHHH >>

という文字列が表示されることになります。 Hが5回表示されているのは、スーパークラ スのdisplayメソッドがprintメソッドを5回呼び出していることに対応しています。

章 Template Method具体的な処理をサブクラスにまかせる

List 3-2 CharDisplayクラス (CharDisplay.java)

1: public class CharDisplay extends AbstractDisplay ( private char ch; // 表示すべき文字 2:

3:

4:

// コンストラクタ

5:

public CharDisplay (char ch) (

6:

7:

this.ch = ch:

8:

9:

@Override

10:

public void open () (

11:

// 開始文字列として<<"を表示する

System.out.print("<<");

12:

13:

14:

@Override

15:

16:

17:

public void print() {

// フィールドに保存しておいた文字を1回表示する

System.out.print(ch);

18:

19:

20:

}

BOverride

21:

public void close(){

22:

23:

// 終了文字列として""を表示する

24:

25:

System.out.println(">");

26: )

}

| String Displayクラス

}

それでは、もう1つのサブクラスである String Displayクラス (List3-3) を見てみま しょう。もちろん、こちらでも open, print, close が実装されています。 今度はどんな 処理を行っているでしょうか?

StringDisplayのopen, print, close は Table 3-3のような処理を行っています。 この状態で、 displayメソッドが呼ばれたらどうなるでしょうか。 コンストラクタに "Hello, world. という文字列が渡されていたとすると、

38

サンプルプログラム 39

|Hello, world.| |Hello, world.| |Hello, world. | |Hello, world.| |Hello, world.|

のように、枠で囲まれた文字列が表示されます。 |Hello, world. | が5回表示されている のは、スーパークラスのdisplayメソッドがprintメソッドを5回呼び出していることに 対応しています。

|Table 3-3 StringDisplayクラスのopen, print, closeメソッドの処理

メソッド名 处理 open. 文字列+----+ を表示する print close コンストラクタで与えられていた文字列を|*と･･ではさんで表示する’ 文字列 +-----+" を表示する

List 3-3 StringDisplay 2 (String Display.java)

1: public class String Display extends AbstractDisplay ( private String string; // 表示すべき文字列 2: 3: private int width; // 文字列の表示幅 4: 5: 6: 7: 8: // コンストラクタ public StringDisplay (String string) { this.string = string; this.width = string.length(); 9: ) 10: 11: 12: 13: @Override public void open() ( printLine(); 14: 15: 16: 17: 18: @Override public void print() ( System.out.println(" + string + 19: 20:

*ここでは簡単のため、1文字が画面上で1カラムを占めるという前提でコーディングしています。

3 Template Method -

40

@Override public void close() { printLine(); // cpenとclose から呼び出されて+---+" という文字列を表示するメソッド private void printLine() { 21: 22: 23: 24: } 25: 26: 27: 28: 29: 30: 31: 32: 33: 34: 1 System.out.print ("+"); for (int i=0; i < width; i++) { System.out.print ("-"); System.out.println("+"); -x

| Mainクラス

Main クラスは動作テストを行うものです。 これまで作ったChar Displayクラスと StringDisplayクラスのインスタンスを作り、 displayメソッドを呼び出しています。

List 3-4 Main 52 (Main.java)

1: public class Main ( 2: 3: 4: public static void main(String[] args) { // 'H' を持ったCharDisplayのインスタンスを1個作る Abstract Display dl = new CharDisplay( 'H'); // "Hello, world." を持ったStringDisplayのインスタンスを1個作る AbstractDisplay d2 = new StringDisplay ("Hello, world."); 5: 6: 7: 8: 9: 10: // d1,d2 とも、すべて同じAbstractDisplayのサブクラスのインスタンスだから // 継承したdisplayメソッドを呼び出すことができる 11: 12: 13: // 実際の動作は個々のクラス CharDisplay や String Displayで定まる dl.display(); d2.display(); 14: 15: )

Template Method パターンの登場人物 41

Fig.3-3 実行結果

<<HHHHH >> |Hello, world.| |Hello, world. | ←d1 による表示 (CharDisplay) ←d2 による表示 (StringDisplay) |Hello, world. | |Hello, world.| |Hello, world.|

Template Method パターンの登場人物

Template Methodパターンの登場人物は、次のとおりです。

ブストラクト・クラス AbstractClass (抽象クラス)の役

AbstractClass役は、テンプレートメソッドを実装します。 また、そのテンプレートメソ ッドで使っている抽象メソッドを宣言します。 この抽象メソッドは、サブクラスである Concrete Class 役によって実装されます。 サンプルプログラムでは、 AbstractDisplay ク ラスがこの役をつとめました。

コンクリートクラス ConcreteClass (具象クラス)の役

AbstractClass役で定義されている抽象メソッドを具体的に実装します。 ここで実装した メソッドは、 AbstractClass 役のテンプレートメソッドから呼び出されます。 サンプルプロ グラムでは、 Char Displayクラスや String Displayクラスがこの役をつとめました。 このTemplate Methodパターンをクラス図で表記すると、 Fig.3-4のようになります。

第3章 Template Method具体的な処理をサブクラスにまかせる

Fig.3-4 Template Method パターンのクラス図

AbstractClass methodl method2 method3 templateMethod method1 method2 method3 ConcreteClass

あなたの考えを広げるためのヒント

ロジックが共通化できる

Template Methodパターンを使うと、どんないいことがあるのでしょうか。 スーパーク ラスのテンプレートメソッドでアルゴリズムが記述されていますので、 サブクラス側では アルゴリズムをいちいち記述する必要がなくなります。

例えば、 Template Methodパターンを使わず、エディタのコピー&ペースト機能を使って 複数のConcreteClass役を作ってしまったとしましょう。 ConcreteClass1, Concrete Class2, ConcreteClass, ・・・たちは、すべて似て非なるクラスになりました。 書いた直 後はいいのですが、 あとでConcrete Class1にバグが発見されると、いったいどうなります か。 1つのバグの修正を すべてのConcrete Class役に反映させなくてはなりません。

その点、 Template Methodパターンでプログラミングしていれば、テンプレートメソッ ドに誤りが発見された場合でも、テンプレートメソッドさえ修正すればよい、ということ になります。

42

関連しているパターン 43

| スーパークラスとサブクラスの連携プレー

Template Methodパターンでは、スーパークラスとサブクラスが綿密に連携をとって動 いています。 ですから、 スーパークラスで宣言されている抽象メソッドを実際にサブクラ スで実装するときには、そのメソッドがどういうタイミングで呼び出されるかを理解して おく必要があるでしょう。 スーパークラスのソースプログラムがないと、 サブクラスの実 装は難しいかもしれません。

| サブクラスをスーパークラスと同一視する

サンプルプログラムの中では、 CharDisplayのインスタンスも、 String Displayのイ ンスタンスも、Abstract Display 型の変数に代入しています。 そして display メソッド を呼び出していますね。

スーパークラス型の変数があり、その変数にサブクラスのインスタンスが代入されてい るとします。 そのとき、 instanceofなどでサブクラスの種類を特定せずにプログラムが 動くようにプログラミングするのはよいことです。

リスコフ サブスティテ ジョン・プリンシプル スーパークラス型の変数に、サブクラスのインスタンスのどれを代入しても正しく動作 するようにする、という原則はThe Liskov Substitution Principle (LSP) と呼ばれていま す。

関連しているパターン

◆Factory Methodパターン (第4章)

Template Methodパターンをインスタンス生成に応用した典型的な例がFactory Method パターンです。

Strategy パターン (第10章)

Template Methodパターンでは、 「継承」 を利用してプログラムの動作を変更すること ができます。 スーパークラスでプログラムの振る舞いの大枠を定め、サブクラスで具体的 な振る舞いを定めているからです。

*ただし、実装を継承する場合には、 LSPを厳密に守るのは不可能なことが知られています (inheritance is not subtyping)。 参考: https://xtech.nikkei.com/it/article/COLUMN/20061107/252787/ 参考: https://dll.acm.org/doi/10.1145/96709.96721

44 第3章 Template Method サブクラスにまかせる

これに対してStrategyパターンでは、「委譲」を利用してプログラムの動作を変更する ことができます。 Strategyパターンでは、プログラムの一部分を変更するというよりも、 アルゴリズム全体をごっそり切り替えています。

補講 : クラス階層と抽象クラス

スーパークラスからサブクラスへの要請

私たちがクラス階層について学ぶとき、たいていはサブクラスの視点で考えます。 つま り、次のような点に目を向けがちです。

・スーパークラスで定義されているメソッドがサブクラスで利用できる ・サブクラスに少しメソッドを書くだけで新しい機能が追加できる ・サブクラスでメソッドをオーバーライドすれば振る舞いを変更できる

ここでちょっと視点を変えて、 スーパークラスの気持ちになって考えてみましょう。 ス ーパークラスで抽象メソッドが宣言されているとします。このとき、そのメソッドの実装 は「サブクラスにまかされている」 わけです。言い換えれば、 抽象メソッドを宣言すると いうのは、プログラムを使って次のような主張を行っていることになります。

・サブクラスがそのメソッドを実装することを期待する

・サブクラスに対して、そのメソッドの実装を要請する

サブクラスには、スーパークラスで宣言されている抽象メソッドを実装するという責任 サブクラス・レスポンシビリティ が生じているといってもいいでしょう。 これを subclass responsibility (サブクラスの責任) といいます。

Javaのプログラムを読んでいて @Override アノテーションが書かれているメソッドがあ ったなら、それはスーパークラスやインタフェースで宣言されているメソッドをオーバー ライドしていることを表します。 そのときには、どんな責任を担っているメソッドなのか を意識してドキュメントを読みましょう。

抽象クラスの意義

抽象クラスはインスタンスを作ることができません。 抽象クラスをはじめて学ぶとき、 「インスタンスを作れないクラスなど何の役に立つのだろう」 という疑問を持つ人もいま す。 しかし、この章で学んだ Template Methodパターンを理解すれば、その疑問は少し解

Java

この章で学んだこと 45

消するでしょう。 抽象メソッドにはメソッドの本体が書かれていないので、 具体的な処理 内容はわかりません。 しかし、 メソッドの名前を決め、そのメソッドを使ったテンプレー トメソッドによって処理を記述することはできるのです。 実際の処理内容はサブクラスま で行かなければ決まりませんが、 抽象クラスの段階で処理の流れを形作るのは大切なこと です。

スーパークラスとサブクラスの協調

スーパークラスとサブクラスは、お互いに協調しあいながらプログラムを構築していま す。 スーパークラスでの記述を多くすれば、サブクラスでの記述は楽になりますが、 サブ クラスの自由度は減ってしまいます。 逆にスーパークラスの記述が少なければ、サブクラ スの記述は大変になり、 また個々のサブクラスで処理の記述が重複してくるかもしれませ

ん。

Template Methodパターンでは、処理の骨組みをスーパークラスで記述し、具体的な肉 付けをサブクラスで行っています。 どのレベルで処理を分けるか、 どの処理をスーパーク ラスにおき、どの処理をサブクラスにおくかについては、定まったマニュアルがあるわけ ではありません。 それは、プログラムの設計を行う人にまかされているのです。

この章で学んだこと

この章では、 スーパークラスで処理の骨組みを規定し、サブクラスで処理の内容を具体 化する Template Methodパターンについて学びました。 また、 抽象クラスの意義やサブク ラスの責任についても考えました。

次の章では、 インスタンスの生成にTemplate Methodパターンを適用したパターンであ る Factory Methodパターンを学びましょう。

第3章 Template Method 具体的な処理をサブクラスにまかせる

練習問題

問題3-1

Java java.io.InputStreamクラスではTemplate Methodパターンが使われています。 仕様 書 (JDKのAPIリファレンス) を読んで、 java.io.InputStreamのサブクラスで実装す ることが要請されているメソッドは何かを調べてください。

●問題3-2

解答は付録A (p.405)

Java

サンプルプログラムのAbstractDisplayクラス (List 3-1) の displayメソッドは、 public final void display(){

として実装されています。 ここにはfinal と書かれていますが、 これはどのようなことを 表していますか。

■問題3-3

サンプルプログラムで、 open, print, closeメソッドを継承関係および同一パッケー ジにあるクラスからのみ呼び出せるようにし、無関係な他のクラスからは呼び出せないよ うにしたいとします。 どうしたらいいですか。

Java

●問題 3-4

}

Java

Javaのインタフェースは抽象クラスとよく似ています。 Java 8以降では、インタフェー スのメソッドに対し、 defaultキーワードを使ってデフォルト実装を定義することができ ます。 サンプルプログラムのAbstractDisplayクラス (List 3-1) をインタフェースに変 更してください。

46

第4章

Factory Method

インスタンス作成を

サブクラスにまかせる

月333

Fatory Method インスタンス作成をサブクラスにまかせる

Factory Method パターン

Template Method パターン (第3章) では、スーパークラス側で処理の骨組みを作り、 サブクラス側で具体的な処理の肉付けを行いました。 このパターンをインスタンス生成の 場面に適用したものが、この章で学ぶ

ファクトリーメソッド Factory Method パターン

です。

factory という英単語の意味は、 「工場」 です。 インスタンスを生成する工場をTemplate Method パターンで構成したものが、 Factory Method パターンになります。

Factory Methodパターンでは、インスタンスの作り方をスーパークラスの側で定めます が、具体的なクラス名までは定めません。 具体的な肉付けは、すべてサブクラスの側で行 います。 これによって、 インスタンス生成のための枠組み (フレームワーク) と、 実際の インスタンス生成のクラスとを分けて考えることができるようになります。

サンプルプログラム

Factory Methodパターンを使ったサンプルプログラムを読んでみましょう。 このサンプ ルプログラムは、身分証明書カード (IDカード) を作る工場を題材としたものです。 こ こには5つのクラスが登場します。

ProductクラスとFactoryクラスは、frameworkというパッケージに属しています。 この 2つのクラスがインスタンス生成のための枠組み (フレームワーク) の役割を果たします。 IDCardクラスとIDCardFactoryクラスは、実際の肉付けを行います。 これらはidcard というパッケージに属しています。

Main クラスは、動作テストのためのクラスです。

この章で紹介するサンプルプログラムを読むときには、いまframework パッケージの側 を読んでいるのか、 idcardパッケージ側を読んでいるのかを意識してください。

・インスタンス生成のフレームワークの側 (frameworkパッケージ)

・肉付けを行っている側 (idcardパッケージ)

Java

注意 公開するパッケージを開発する場合には、 ドメイン名を逆にした文字列を使って、世界に 1つしかないパッケージ名にすることが推奨されています。 例えば、 example.comというドメイ ン名を元にして、 com.exampleで始まるパッケージ名を作ります。 しかし、ここでは説明を単純 にするために、そのルールには従っていません。

48

サンプルプログラム 49

| Table 4-1 クラス一覧

パッケージ 名前 framework framework Factory Product 解說 抽象メソッドuseのみ定義されている抽象クラス メソッド create を実装している抽象クラス メソッド use を実装しているクラス idcard IDCard idcard IDCardFactory 無名 Main メソッド createProduct, registerProduct を実装しているクラス 動作テスト用のクラス

Fig.4-1 サンプルプログラムのクラス図

framework Creates▸ Factory create createProduct registerProduct idcard Creates ▸ IDCardFactory createProduct registerProduct use owner use getOwner Product IDCard

| Product クラス

framework パッケージのProductクラス (List 4-1) は 「製品」を表現したクラスです。 このクラスでは、 抽象メソッドuseのみが宣言されています。 具体的なuse の実装は、 す べて Productのサブクラスにまかせています。

このフレームワークでは、製品とは 「何はともあれ、 use できる (使える)もの」と規 定していることになります。

第4章 Factory Method インスタンス作成をサブクラスにまかせる

List 4-1 Product (Product.java)

1: package framework;

3: public abstract class Product {

2:

4: 5: )

public abstract void use();

Factoryクラス

framework パッケージのFactoryクラス (List 4-2) では、 Template Method パターンが 使われています。 抽象メソッド createProduct で 「製品を作り」、作った製品を抽象メソ ッド registerProduct で 「登録」します。 「製品を作る」 と 「登録」 の実装はサブクラス で行います。

このフレームワークでは、工場とは 「createメソッドでProductのインスタンスを生 成するもの」と規定しています。 そして、 create メソッドは 「createProduct で製品を 作って、registerProductで登録する」という手順として実装されています。

具体的な実装内容は、 Factory Methodパターンを適用したプログラムによって異なりま す。 しかし、Factory Methodパターンであれば、 インスタンス生成に Template Method ターンが使われることになります。

List 4-2 Factory クラス (Factory.java)

1: package framework:

2:

3: public abstract class Factory {

public final Product create (String owner) {

Product p = createProduct (owner);

4:

5:

registerProduct (p):

6:

7:

8:

return p;

9:

10:

protected abstract Product createProduct (String owner); protected abstract void registerProduct (Product product);

11:

12: )

50

サンプルプログラム 51

IDCardクラス

ここまではフレームワーク側 (framework パッケージ)を見てきました。 今度は肉付け をする側 (idcardパッケージ) に話を移します。 例として、認識番号カードを表す IDCard というクラスを作ってみましょう。 フレームワークから分離することを明示するため、 idcardパッケージという別のパッケージにします。 IDCardクラス (List 4-3)は、製品 Productクラスのサブクラスとして定義します。

List 4-3 IDCard 57 (IDCard.java)

1: package idcard;

6: 7: 8: 9: 10: 2: 3: import framework. Product; 4: 5: public class IDCard extends Product { private String owner; IDCard (String owner) { System.out.println (owner -F. *); this.owner owner; 11: } 12: 13: 14: 15: @Override public void use () { System.out.println(this *.*); 16: } 17: 18: 19: @Override public String toString() ( 20: return "[IDCard:" + owner +"]"; 21: ) 22: 23: 24: public String getOwner() { return owner; 25: 26: )

IDCardFactory "57

IDCardFactory メソッドを実装しています。 2 (List 4-4), createProduct & register Product 20

第4章 Factory Methodインスタンス作成をサブクラスにまかせる

createProduct では、IDCardのインスタンスを生成することで、 「製品を作る」ことを 実際に実現しています。

registerProduct では、「登録」 という機能を実現します。 本来ならば、 例えばデータ ベースやWebサービスにアクセスして製品を登録するのですが、ここでは簡単のために 「〜を登録しました」というメッセージを表示するだけの処理を行っています。

List 4-4 IDCardFactory クラス (IDCardFactory.java)

52

1: package idcard; 2: 3: import framework.Factory: 4: import framework.Product; 5: 6: public class IDCardFactory extends Factory ( BOverride protected Product createProduct (String owner) { return new IDCard (owner); 7: 8: 9: 10: } 11: 12: @Override 13: 14: 15: protected void registerProduct (Product product) { System.out.println(product を登録しました。 *); + 16: )

| Main クラス

Main クラス (List 4-5) では、 framework パッケージとidcardパッケージを利用して、 実際のIDCardを作り、使ってみましょう。

List 4-5 Main クラス (Main.java)

1: import framework.Factory: 2: import framework. Product; 3: import idcard. IDCardFactory; 4: 5: public class Main { 6: 7: 8: 9: public static void main(String[] args) ( Factory factory = new IDCardFactory(); Product card = factory.create("Hiroshi Yuki*); Product card2 = factory.create("Tomura");

10: Product card = factory.create("Hanako Sato"); card1.use(); 11: : : card2.use(); card3.use(); 14: } 15: ) Factory Method パターンの登場人物 53

Fig.4-2 実行結果

Hiroshi Yuki のカードを作ります。 [IDCard: Hiroshi Yuki] を登録しました。 Tomuraのカードを作ります。 [IDCard: Tomura] を登録しました。 Hanako Satoのカードを作ります。 [IDCard: Hanako Sato] を登録しました。 [IDCard: Hiroshi Yuki] を使います。 [IDCard: Tomura] を使います。 IDCard: Hanako Sato] を使います。

Factory Methodパターンの登場人物

Factory Methodパターンの登場人物は、次のとおりです。 クラス図 (Fig.4-3) を見る と、スーパークラス (抽象的な骨組み、フレームワーク) の側にあるCreator 役と Product 役の関係が、サブクラス (具体的な肉付け) の側にある Concrete Creator 役と Concrete Product役の関係と並行していることがわかります。

1213

54 第4章 Factory Method インスタンス作成をサブクラスにまかせる

Fig.4-3 Factory Method パターンのクラス図

フレームワーク create Creates▸ Creator factoryMethod 具体的な肉付け Creates▸ ConcreteCreator factoryMethod Product methodl method2 methoda Concrete Product methodl method2 method3

プロダクト Product (製品) の役

これはフレームワーク側です。 このパターンで生成されるインスタンスが持つべきイン タフェース (API) を定める抽象クラスです。 具体的な内容は、 サブクラスのConcrete Product役が定めます。 サンプルプログラムでは、 Productクラスがこの役をつとめまし た。

クリエイタ Creator (作成者)の役

これはフレームワーク側です。 Product役を生成する抽象クラスです。 具体的な内容は サブクラスのConcrete Creator役が定めます。 サンプルプログラムでは、 Factory クラス がこの役をつとめました。

Creator 役は、実際に生成する Concrete Product役については何も知りません。 Creator役 が知っているのは、 Product役とインスタンス生成のメソッド (Fig.4-3ではfactoryMethod) を呼び出せば、 Product が生成されるということだけです。 サンプルプログラムでは、 createProduct メソッドがインスタンス生成のためのメソッドになっています。 newに よる実際のインスタンス生成を、 インスタンス生成のためのメソッド呼び出しに代えるこ とで、具体的なクラス名による束縛からスーパークラスを解放していることになります。

あなたの考えを広げるためのヒント 55

ConcreteProduct (具体的製品) の役 これは具体的な肉付けをする側です。 具体的な製品を定めます。 サンプルプログラムで は、IDCard クラスがこの役をつとめました。

コンクリートプロダクト

コンクリートクリエイタ

Concrete Creator (具体的作成者)の役

これは具体的な肉付けをする側です。 具体的な製品を作るクラスを定めます。 サンプル プログラムでは、IDCardFactoryクラスがこの役をつとめました。

あなたの考えを広げるためのヒント

| フレームワークと肉付け

これまで、 「フレームワーク」 と 「肉付け」の2つの側についてお話しました。 これら は、 それぞれ framework パッケージとidcardパッケージに分かれています。

ここで、同じフレームワークを使ってまったく別の「製品」 と 「工場」 を作るとしまし ょう。 例えば、 テレビのクラス Television とテレビ工場 TelevisionFactoryとしましょ うか。 この場合、 framework パッケージをimport した別の television パッケージを作る ことになるでしょうね。

ここで、framework パッケージの中身を修正せずに、まったく別の「製品」 と 「工場」 が作れる、ということに注目しましょう。 framework パッケージの中身を修正する必要は ありません。

思い出してください。 frameworkパッケージの中では、 idcardパッケージをimport し ていません。 ProductクラスやFactoryクラスの中には、IDCard や IDCardFactory とい う具体的なクラス名は書かれていません。 ですから、 新しいクラスを同じフレームワーク で生成する場合でも、 例えば televisionパッケージを importするような framework パッ ケージの修正はまったく不要なのです。 このことを 「frameworkパッケージは idcardパ ッケージに依存していない」と表現します。

インスタンス生成 ・メソッドの実装方法

サンプルプログラムでは、 FactoryクラスのcreateProductメソッドは抽象メソッドにな っています。 つまり、このメソッドはサブクラスで実装することが期待されているのです。 createProduct メソッドの記述方法は、以下の2通りが考えられます。

56 第4章 Factory Method インスタンス作成をサブクラスにまかせる

抽象メソッドにする

抽象メソッドにする方法。 抽象メソッドにすると、サブクラスは必ずこのメソッドを実 装しなければならなくなります。 実装していない場合には、コンパイル時に検出されます。 サンプルプログラムではこの方法をとっています。

abstract class Factory ( public abstract Product createProduct (String name);

デフォルトの実装を用意しておく

デフォルトの実装を用意する方法。 デフォルトの実装を用意しておくと、サブクラスで 実装しなかった場合には、 その実装が使われます。

class Factory ( public Product createProduct (String name)return new Product (name); )

{

ただし、この場合にはProductクラスに対して直接newしていますので、 Productクラ スを抽象クラスにしておくことはできません。

パターン利用と開発者間の意思疎通

第3章で学んだ Template Method パターンも、この章のFactory Methodパターンも、実 際に行っている操作のわりには複雑なプログラミングに感じられます。 これは、1つのク ラスを読んだだけでは動作がよく理解できないからです。 スーパークラスで動作の骨組み を理解し、そこで使われている抽象メソッドが何かを見極め、 さらに、その抽象メソッド を実際に実装しているクラスのソースコードを読むことが必要になります。

一般に、デザインパターンを使って、 あるクラス群を設計する場合、そのクラス群の保 守を行う人に、設計者の意図したデザインパターンが何であるかうまく伝わるようにする 必要があります。 さもないと、 設計者の最初の意図から離れた修正が加えられてしまう可 能性があるからです。

プログラムのコメントや開発文書の中に、実際に使われているデザインパターンの名称 と意図を記述しておくのはよいことです。

あなたの考えを広げるためのヒント

static Factory Method

インスタンス生成のためのクラスメソッド (staticメソッド) 全般を Factory Method と呼ぶ場合があります。 これは GoF の Factory Methodパターンとは違いますが、 Javaのイ ンスタンス生成で非常によく使われる手法です。 JavaのAPIリファレンスでも、 インスタ ンス生成のためのクラスメソッドを static Factory Method と表現することがあります。

JavaのAPIリファレンスを読む際には、参照しているクラスに static Factory Method が 提供されていないかに注目しましょう。 static Factory Method はインスタンス生成で重要 な役割を果たすことが多いからです。

static Factory Methodとしては、 create, newInstance, getInstance などの名前がよく使わ れますが、それ以外の名前が使われる場合もあります。

•java.security.SecureRandomの getInstance メソッドは、 乱数生成アルゴリズムの名 前を指定して SecureRandomのインスタンスを生成する static Factory Methodです。

SecureRandom random = SecureRandom.getInstance("NativePRNG");

●java.util.Listのof メソッドは、 具体的な要素を与えるとListのインスタンスを生 成する static Factory Methodです。

// "Alice", "Bob", "Chris"からなるListを得る List<String> list = List.of ("Alice", "Bob", "Chris");

●java.util.ArraysのasListメソッドは、与えられた配列や列挙した要素からListの インスタンスを生成する static Factory Methodです。

String[] arr = { "Alice", "Bob", "Chris" }; List<String> list1 = Arrays.asList (arr); List<String> list2 = Arrays.asListAlice", "Bob", "Chris");

• java.lang.String の value Of メソッドは、 さまざまな型の文字列表現を得る static Factory Method です。

// char型の'A' から String型のAを得る String string = String.valueOf('A');

•java.time Instantのnowメソッドは、現在時刻を表すInstantのインスタンスを生 成する static Factory Methodです。 ここでは生成するインスタンスが何であるかわかり やすいnow (いま) という名前になっています。

Instant instant = Instant.now();

57

第4章 Factory Method インスタンス作成をサブクラスにまかせる

関連しているパターン

Template Methodパターン (第3章)

Factory Method パターンは、 Template Methodパターンの典型的な応用です。 サンプル プログラムのcreateメソッドがテンプレートメソッドになっています。

Singletonパターン (第5章)

Creator役 (あるいは Concrete Creator役) をつとめるクラスは、多くの場合、 Singleton パターンとして作ることができます。 プログラムの中でインスタンスが複数存在する必要 はあまりないからです。 ただし、このサンプルプログラムでは、 Singleton パターンには なっていません。

・Composite パターン (第11章)

Product役 (あるいはConcreteProduct 役) に Compositeパターンを当てはめることがで きる場合があります。

◆ Iterator パターン (第1章)

IteratorパターンでiteratorメソッドがIteratorのインスタンスを作成するときに、 Factory Methodパターンが使われる場合があります。

この章で学んだこと

この章では、インスタンス生成にTemplate Methodパターンを応用したFactory Method パターンを学びました。

デザインパターンの考え方には慣れてきましたか。 1つのパターンの中では、複数のク ラスやインタフェースが個々の役割を持ち、 互いに関連しながら動作しています。 1つの クラスだけを取り上げて、 これはどのパターンか、というのではなく、必ずクラスやイン タフェースの相互関係に目を向けるようにしましょう。 白雪姫が1人で立っているだけで は、白雪姫の劇にはならないのです。

もっとも、世の中には1人でもドラマが成り立つ 「1人芝居」 というものもありますね。 次の章では、 「1人芝居」 に近いパターンを紹介しましょう。

58

練習問題

解答は付録A (p.408)

問題4-1

Java

サンプルプログラムでは、IDCardクラス (List 4-3)のコンストラクタはpublicにな っていません。 これは何を表しているでしょうか。

public class IDCard extends IDCard (String owner) ( }

Product (

問題4-2

サンプルプログラムのIDCardクラス (List 4-3) にカードの通し番号をつけ、IDCard Factoryクラスが通し番号と所持者の対応表を持つように修正してください。

問題4-3

Productクラス (List 4-1) のサブクラスでは、 コンストラクタで必ず「製品の名前」 を引数として与えることを強制しようと思って、以下のようにProductクラスを定義しま した。しかし、コンパイル時にエラーになりました。 なぜですか。

Java

public abstract class Product { public abstract Product (String name); public abstract void use ();

59



第5章

Singleton たった1つのインスタンス

第5章 Singletonたった1つのインスタンス

Singleton パターン

私たちがプログラムを動かすとき、 普通はたくさんのインスタンスが生成されます。 例 えば、 文字列を表すjava.lang.Stringクラスのインスタンスは、 文字列1個に対して 個生成されますので、 文字列が1,000個登場するプログラムなら、 1,000個のインスタンス が作られます。

しかし、「このクラスのインスタンスはたった1つしか作らないし、 作りたくない」と いうときもあります。 それは、システムの中に1個しか存在しないものをプログラムで表 現したいときです。 例えば、 コンピュータシステム全体を表現したクラスや現在のシステ ム設定を表現したクラス、あるいは各種定数などです。

もちろん、 注意深くプログラミングして、 new MyClass() を1回しか実行しないように すれば、MyClassのインスタンスは1個しか生成されません。 しかし、 「プログラマが注意 しているからインスタンスが1個しか生成されない」のではなく、

・指定したクラスのインスタンスが絶対に1個しか存在しないことを保証したい インスタンスが1個しか存在しないことをプログラム上で表現したい

場合には、どうしたらよいでしょうか。 インスタンスが1個しか存在しないことを保証するパターンを、

シングルトン Singleton パターン

と呼びます。 singleton とは、 要素を1個しか持たない集合のことです。 インスタンスが1 個しかないので、このような名前がついています。 この章では、 Singletonパターンについて学びましょう。

サンプルプログラム

Singletonパターンを使ったサンプルプログラムを読んでみましょう。

Table 5-1 クラス一覧

名前 解說 Singleton インスタンスが1つしか存在しないクラス Main 動作テスト用のクラス

62

サンプルプログラム 63

Fig.5-1にサンプルプログラムのクラス図を示します。 コンストラクタ Singletonのは じめに-がついているのは、 Singleton が private であることを明示するためです。 また、 メソッド getInstanceに下線がついているのは、このメソッドがstaticメソッド (クラ スメソッド)だからです(これらはUMLの約束です。 p.xxxi、p.xxxiv参照)。

Fig.5-1 サンプルプログラムのクラス図

Singleton -singleton -Singleton +getInstance

| Singleton クラス

Singletonクラス (List 5-1) では、 インスタンスは1つしか作られません。 Singleton クラ スでは、static フィールド (クラス変数) としてsingleton が定義され、 それを Singleton クラスのインスタンスで初期化しています。この初期化はSingleton クラスのロード時に 一度だけ行われます。

Singleton クラスのコンストラクタはprivate になっています。 これは、 Singleton ク ラス外からコンストラクタを呼び出すことを禁止するためです。もし、

new Singleton ()

という式がこのクラスの外にあったとしても、コンパイル時のエラーになります。 そもそ もプログラマが注意して new しないようにしてくれれば、 コンストラクタをprivateにす る必要はありません。 しかし、 Singletonパターンは、プログラマがどう間違ってもイン スタンスが1個しか生成されないことを保証する、というパターンでしたね。 この保証の ために、コンストラクタをprivateにしておくのです。

ここでは、動作の様子を確認するため、コンストラクタの中でインスタンスを生成し ました。」 というメッセージを表示しています。

Singleton クラスの唯一のインスタンスを得るメソッドとして、 getInstance が用意さ れています。 この getInstanceはp.57で触れた static Factory Method の一種です。 この例 では、メソッドの名前を getInstanceとしましたが、必ずしもこの名前でなければなら ないわけではありません。 しかし、唯一のインスタンスを得る方法は、何かしら必要にな

第5章 Singleton たった1つのインスタンス

ります。

List 5-1 Singleton 252 (Singleton.java)

1: public class Singleton ( 2: 3: 4: 5: 6: 7: 8: 9: 10: private static Singleton singleton new Singleton(); private Singleton () { System.out.println(LL."); public static Singleton getInstance() { return singleton; 11: )

| Mainクラス

Mainクラス (List 5-2) は、 Singleton クラスを利用しているクラスです。 ここでは、 SingletonクラスのgetInstanceメソッドを使ってSingletonのインスタンスを得てい ます。 getInstanceメソッドは2回呼び出されています。 戻り値は、 それぞれ obj1と obj2に代入しています。 確かに同じインスタンスが得られているかどうかを、 obj1 == obj2 という式でチェックしています。

List 5-2 Singleton 25352 (Main.java)

1: public class Main ( public static void main(String[] args) { System.out.println("Start."); Singleton objl Singleton obj2 2: 3: 4: 5: 6: 7: 8: 9: 10: ) 11: 12: 13: ) Singleton.getInstance(); Singleton.getInstance(); if (obj1 == obj2) { System.out.println("obj1 obj2 1 1 2 2 *); } else { System.out.println("objl obj2 1 1 2 3 & 1) #h. "); System.out.println("End.");

64

あなたの考えを広げるためのヒント

Fig.5-2にサンプルプログラムの実行結果を示します。

Fig.5-2 実行結果

Start. インスタンスを生成しました。 obj1 と obj2 は同じインスタンスです。 End.

Singleton パターンの登場人物

Singleton パターンの登場人物は、次のとおりです。

シングルトン Singletonの役

Singletonパターンには、 Singletonの役しか登場しません。 Singletonの役は、唯一のイ ンスタンスを得るためのstaticメソッドを持っています。 このメソッドはいつも同じイ ンスタンスを返します。

Fig.5-3 Singletonパターンのクラス図

Singleton -singleton -Singleton. +getInstance

あなたの考えを広げるためのヒント

| なぜ制限を設ける必要があるのか

Singletonパターンでは、インスタンスの数に制限を設けています。 なぜ、わざわざ制 眼を課すようなプログラミングを行う必要があるのでしょうか。 制限を課す、ということ は、前提になる条件を増やす、ということです。

65

第5章 Singleton たった1つのインスタンス

66

インスタンスが複数存在すると、 インスタンスたちが相互に影響し合って、思いがけな いバグを生み出してしまう可能性があります。

しかし、インスタンスが1つしかないという保証があれば、その前提条件の下でプログ ラミングできることになります。

唯一のインスタンスはいつ生成されているか

Java

サンプルプログラムの実行結果 (Fig.5-2) を注意深く読むと、 「start.」 と表示してか ら「インスタンスを生成しました。」と表示していることがわかります。

プログラムの実行開始後、最初にgetInstanceメソッドを呼び出したときにSingleton クラスは初期化されます。 そして、そのときにstatic フィールドの初期化が行われ、唯 一のインスタンスが作られるのです。

enum Singleton

enumの要素は定数としてインスタンスの唯一性が保証されています。 例えばjava.time Month APRILは暦における四月を表すインスタンスですが、これはシステムで唯一のイ コンスタンスになります。

ですから、 要素を1個だけ持つenumによって次のようにSingletonパターンを実装する ことができます。

enum Singleton { INSTANCE; public void hello() { System.out.println("hello is called.");

ここで唯一のインスタンスへはSingleton. INSTANCE という式でアクセスすることがで きます。 hello メソッドを呼び出す文は、

Singleton. INSTANCE.hello();

になります。

関連しているパターン

以下のパターンでは、Singletonパターンが使われることがあります

・Abstract Factory パターン (第8章)

Builder パターン (第7章)

・Facade パターン (第15章)

Flyweight パターン (第20章)

・Prototype パターン (第6章)

State パターン (第19章)

この章で学んだこと

この章では、インスタンスが1個しか生成されないことを保証する ついて学びました。 インスタンスを得るためのstatic. メソッドを スの外から new されないように、コンストラクタをprivateしました。 に し、キックラクラ

次の章では、クラスからインスタンスを作るのではなく、インスタンスョンス タンスを作るパターンを学びます。

5章 Singleton たった1つのインスタンス

68 第

解答は付録A (p.411)

練習問題

問題 5-1

次の TicketMakerクラス (List 5-3) は、 getNext TicketNumber メソッドを呼ぶたび に、1000, 1001, 1002, ... という数を順に返すためのものです。 チケットの番号やシ リアルナンバーを生成するのに使います。 このTicketMaker クラスは、 現在のままでは インスタンスをいくつでも作れてしまいます。 これにSingletonパターンを当てはめて インスタンスが1個しか作れないようにしてください。

List 5-3 まだ Singletonパターンになっていない TicketMaker クラス (TicketMaker.java)

1: public class TicketMaker ( 2: 3: 4: 5: private int ticket = 1000; public int getNext TicketNumber() { return ticket++; 6: 7: } }

●問題 5-2

インスタンスの個数が3個に限定されているクラス Triple を作ってください。 インスタ ンスには ALPHA", "BETA", "GAMMA という名前がついており、 getInstance (String name) でname という名前を持つインスタンスが得られるものとします。

問題 5-3

ある人がSingleton クラスをList 5-4のように作りました。 しかしこれでは、 getInstance メソッドが複数のスレッドから呼び出されるとSingletonパターンになりません。 どうし てですか

List 5-4 複数のスレッドから呼び出されるとSingleton パターンにならない (Singleton.java)

1: public class Singleton ( 2: private static Singleton singleton = null; 3: 4: private Singleton () { 5: System.out.println("インスタンスを生成しました。"); 6: )

7:

8: 9: 10: 11: 12: 13: 14: ) public static Singleton getInstance() { if (singleton == null) ( ) singleton new Singleton(); return singleton; )

69



第6章

Prototype コピーして インスタンスを作る

第6章 Pretotypeコピーしてインスタンスを作る

Prototypeパターン

私たちはSomethingクラスのインスタンスを作成するとき、

new Something ()

という式を用います。 new というJava言語のキーワードを使い、 クラス名を指定すること でインスタンスを生成します。 このように、 new でインスタンスを作る場合には、クラス 名を必ず指定しなければなりません。 しかし、 クラス名を指定せずにインスタンスを生成 したくなる場合もあります。 クラスからインスタンスを作るのではなく、インスタンスを コピー(複製)して新しいインスタンスを作るのです。 それは以下のような場合です。

72

(1)種類が多すぎてクラスにまとめられない場合

1番目は、扱うオブジェクトの種類があまりにも多すぎて、 1つ1つを別のクラスにして いたら、 ソースファイルを多数作成する必要が生じてしまう場合です。

(2) クラスからのインスタンス生成が難しい場合

2番目は、生成させたいインスタンスが複雑な過程を経て作られるものであり、クラス から作り上げることがとても難しい場合です。 例えば、 グラフィックエディタなどでユー ザがマウスの操作によって作り上げた図形を表すインスタンスがあるとします。 そのよう な、ユーザの操作で作成されるインスタンスを、プログラミングによって作るのは困難で す。 ユーザの操作で作られたインスタンスと同じものを再び作りたい場合には、 いま作っ たインスタンスをいったん保存しておき、 作りたいときにそれをコピーします。

(3) フレームワークと生成するインスタンスを分けたい場合

3番目は、インスタンスを生成するときのフレームワークを、 特定のクラスに依存しな いように作りたい場合です。 このような場合には、クラス名を指定してインスタンスを作 るのではなく、前もって 「ひな型」 となるインスタンスを登録しておき、 その登録したイ ンスタンスをコピーすることでインスタンスを生成します。

インスタンスから別のインスタンスを作り出すというのは、コピー機を使って書類をコ ピーすることに似ています。 元の書類をどうやって作ったかを知らなくても、コピー機に かければ同じ書類を何枚でも作れるのです。

サンプルプログラム

この章では、クラスからインスタンスを生成するのではなく、 インスタンスから別のイ ンスタンスを作り出す、

Prototype パターン

プロトタイプ

について学ぶことにしましょう。 prototype という英単語は「原型」 や 「模範」という意 味です。 原型となるインスタンス、 模範となるインスタンスを元に新しいインスタンスを 作るのです。

クローン Java言語では、複製を作る操作を 「clone」 と呼んでいます。 この章では、Java言語の cloneメソッドとCloneableインタフェースの使い方についても学びます。

サンプルプログラム

Prototypeパターンを使ったサンプルプログラムを読んでみましょう。 以下に示すサン プルプログラムは、文字列を枠線で囲って表示したり、下線を引いて表示したりするもの です。

登場するクラスとインタフェース一覧を Table 6-1に示します。 Productインタフェー スとManager クラスは frameworkパッケージに属し、 インスタンスを複製する仕事を行い ます。 ManagerクラスはcreateCopy を呼び出しますが、 具体的にどのクラスのインスタ ンスを複製するかは関知しません。 Product インタフェースを実装しているクラスであり さえすれば、そのインスタンスを複製することができるのです。

MessageBox クラスとUnderline Penクラスは、どちらもProductインタフェースを実 装しているクラスです。このインスタンスを作って Manager クラスに登録しておけば、好 きなときに複製することができます。

Table 6-1 クラスとインタフェース一覧

パッケージ 名前 framework Product framework Manager 無名 MessageBox 無名 無名 Main Underline Pen 解說 抽象メソッド use と createCopy が宣言されているインタフェース createCopyを使ってインスタンスを複製するクラス 文字列を枠線で囲って表示するクラス。 use と createCopyを実装して いる 文字列に下線を引いて表示するクラス。 use と createCopyを実装して いる 動作テスト用のクラス

73

第6章 Prototypeコピーしてインスタンスを作る

Fig.6-1 サンプルプログラムのクラス図

showcase register create Manager Uses ▸ <<interface>> Product use createCopy ulchar use UnderlinePen createCopy MessageBox decochar use createCopy

Product インタフェース

Productインタフェース (List 6-1) は、 複製を可能にするためのものです。 このイン タフェースは、 java.lang.Cloneableインタフェースを継承しています。 Cloneableイ ンタフェースについてはp.83の補講で詳しくお話しますが、このインタフェースを実装し ているクラスのインスタンスは、 clone メソッドを使って自動的に複製を行うことができ るようになります。

useメソッドは、「使う」 ためのものです。 「使う」 が何を意味するかは、サブクラスの 実装にまかされています。

createCopyメソッドは、インスタンスの複製を行うためのものです。

List 61 Product インタフェース (Product.java)

1: package framework;

3: public interface Product extends Cloneable { 4: 5: 6: ) public abstract void use (Strings); public abstract Product createCopy();

2:

74

サンプルプログラム

| Managerクラス

Manager クラス (List 6-2) は、 Productインタフェースを利用してインスタンスの複 製を行うクラスです。

showcase フィールドは、 String で表した 「名前」 と、 Product インタフェースを実装 したクラスのインスタンス」との対応関係を、 java.util.Map<String, Productとし て表現したものです。 showcase フィールドに名前とインスタンスの組を登録 (put) して おけば、指定した名前に対応するインスタンスを取得 (get) できます。

register メソッドで、 製品の名前とProductインタフェースが与えられると、その1組 を showcase に登録します。 ここで引数に渡されてくる Product 型のprototypeは何でし ょうか。 その実際のクラスはわかりませんが、とにかくProductインタフェースを実装し たクラスのインスタンス (すなわち、 useメソッドやcreateCopyメソッドを呼ぶことが できるインスタンス)です。

ProductインタフェースやManager クラスのソースに、 MessageBoxクラスやUnderline Pen クラスのクラス名がまったく出てこないことに注意してください。 クラス名が出てこない ということは、 Product Manager はそれらのクラスとは独立に修正ができるということ を意味しています。 ここはとても大切なポイントです。 ソース中にクラスの名前を書くと、 そのクラスと密接な関係ができてしまいます。 Managerクラスでは、具体的な個々のクラ スの名前を書かず、 ただProductというインタフェース名だけを使っています。 このイン タフェースだけが、 Manager クラスと他のクラスの掛け橋となっているのです。

List 6-2 1: package framework; 2: 3: import java.util. HashMap; 4: import java.util.Map; 5: 6: public class Manager ( private Map<String, Product showcase = new HashMap<>(); public void register (String name, Product prototype) { showcase.put (name, prototype); 7: 8: 9: 10: 11: ) 12: 13: 14: 15: 16: 17: ) public Product create (String prototypeName) ( Product = showcase.get(prototypeName); return p.createCopy();

Manager 2 (Manager.java)

75

76 第6章 Produktypeコピーしてインスタンスを作る

| MessageBox クラス

今度は具体的なサブクラスの方を見てみましょう。 MessageBoxクラス (List 6-3) は、 Productインタフェースを実装 (implements) しています。

decochar フィールドは、 文字列を飾り枠のように囲む文字です。 useメソッドは、与 えられた文字列を decochar で囲みます。 例えば、 decochar がのとき、 「Hello」とい う文字列がuse メソッドに与えられたら、

* Hello ⭑

のように表示します。

createCopyメソッドは、自分自身の複製を行うメソッドです。 ここで呼び出している clone メソッドは、Java言語仕様で規定されており、 自分自身の複製を作成するメソッドです。 複製を作成するとき、 インスタンスが持っているフィールドの値もそのまま新しいインスタンス にコピーされます。 clone メソッドでコピーを行うことができるのは、 java.lang.Cloneable インタフェースを実装しているクラスだけです。 もし、このインタフェースが実装されて いない場合には、例外 CloneNot SupportedException が投げられますので、 try ... catch で捕まえておく必要があります。 MessageBoxクラスではProductインタフェースしか実装 していませんが、先ほど見たように、 Productインタフェースはjava.lang.Cloneableイ ンタフェースを拡張したものですから、 Clone Not SupportedException が投げられるこ とはありません。なお、 java.lang.Cloneableインタフェースは、単なる印付けとして 用いられているだけであり、このインタフェースが宣言しているメソッドはありません。 Java言語のclone メソッドは、自分のクラス (およびサブクラス) からしか呼び出すこ

とができないので、他のクラスからの要請で複製を行う場合には、 createCopyのような 別メソッドでcloneをくるんでやる必要があります。

*ここでは簡単のため、1文字が画面上で1カラムを占めるという前提でコーディングしています。

サンプルプログラム

List 6-3 MessageBox 257 (MessageBox.java)

1: import framework. Product;

2:

3: public class MessageBox implements Product {

4:

private char decochar;

6:

5:

public MessageBox (char decochar) (

this.decochar = decochar;

7:

8:

9:

)

10:

@Override

11:

public void use (String s) (

13:

int decolen 1 + s.length() + 1;

for (int i = 0; i < decolen; i++) { System.out.print (decochar);

14:

15:

16:

17:

18:

19:

20:

21:

23: 24: 25: 26: 27: 28: 29: 30: 31: 32: 33: } 34: ) @Override public Product createCopy() { Product p null; try { p (Product) clone(); } catch (CloneNotSupportedException e) ( ) e.printStackTrace(); return p;

22:

UnderlinePenクラス

UnderlinePenクラス (List 6-4) は、 MessageBox とほぼ同じ動作をしますが、ulchar というフィールドが 「下線」 として用いられます。 例えば、 ulchar が一のときに、 「Hello」 という文字列がuseメソッドに与えられたら、

12:

}

System.out.println();

System.out.println (decochar+s+decochar);

for (int i = 0; i < decolen; i++) {

System.out.print (decochar);

System.out.println();

77

78 第6章 Prototype コピーしてインスタンスを作る

Hello

のように-で下線をつけてHelloを表示します。

List 6-4 UnderlinePen 52 (UnderlinePen.java)

1: import framework. Product;

3: public class Underline Pen implements Product (

2:

private char ulchar;

4:

6:

5:

public Underline Pen (char ulchar) {

this.ulchar ulchar;

7:

8:

9:

@Override

10:

11:

public void use (String s) {

12:

13:

int ulen s.length(); System.out.println(s);

14:

for (int i=0; i < ulen; i++) {

System.out.print (ulchar);

15:

16:

System.out.println();

17:

18:

19:

20:

@Override

21:

22:

public Product createCopy() {

Product p = null;

try (

23:

24:

p (Product) clone();

25:

) catch (CloneNot SupportedException e) (

e.printStackTrace();

26:

27:

return p;

28:

29:

30: )

| Mainクラス

Main クラス (List 6-5) では、まずManagerのインスタンスを作ります。 そして、 Manager のインスタンスに対して、 UnderlinePenのインスタンスとMessageBoxのインスタンス を(名前つきで) 登録します (Table 6-2)。

)

}

ブルプログラム 79

Table 6-2 Manager 3

名前 "strong message" "warning box" クラスとインスタンスの内容 Underline Pen Tulchar - MessageBox decochar *. "slash box" MessageBox decochar /

List 6-5 Main (Main.java)

1: import framework. Manager;

2: import framework. Product;

3:

4: public class Main (

5:

public static void main(String[] args) { // 準備

6:

Manager manager = new Manager();

8:

Underline Pen upen = new Underline Pen ('-');

9:

10:

MessageBox mbox = new MessageBox (***); MessageBox sbox = new MessageBox ('/');

11:

// 登錄

12:

13:

14:

manager.register("strong message", upen); manager.register ("warning box", mbox); manager.register ("slash box", sbox);

// 生成と使用

15:

16:

17:

19:

20:

Product p1 manager.create("strong message"); pl.use("Hello, world.");

18:

21:

22:

23:

Product p2 = manager.create("warning box"); p2.use("Hello, world.");

Product p3 manager.create("slash box"); p3.use("Hello, world.");

24:

25:

26:

27: )

Fig.6-2 M

Hello, world.

*pluse の出力

*p2. use の出力

"Hello, world. *

p3.use

/Hello, world./

7:

Prototype-コピーしてインスタンスを作る

Prototypeパターンの登場人物

Prototype パターンの登場人物は、次のとおりです。

プロトタイプ Prototype (原型) の役

Prototype役は、インスタンスをコピー (複製) して新しいインスタンスを作るための メソッドを定めます。 サンプルプログラムでは、 Productインタフェースがこの役をつと めました。

コンクリート・プロトタイプ ConcretePrototype (具体的な原型) の役

Concrete Prototype役は、インスタンスをコピーして新しいインスタンスを作るメソッ ドを実際に実装します。 サンプルプログラムでは、 MessageBoxクラスや Underline Pen クラスがこの役をつとめました。

クライアント Client (利用者)の役

Client役は、インスタンスをコピーするメソッドを利用して、新しいインスタンスを作 ります。サンプルプログラムでは、 Managerクラスがこの役をつとめました。

Fig.6-3 Prototype パターンのクラス図

Uses ▸

Client

Prototype

createCopy

Concrete Prototype

createCopy

80

あなたの考えを広げるためのヒント 81

あなたの考えを広げるためのヒント

|クラスからインスタンスを作ってはいけないのか

私がPrototypeパターンを学んで最初に感じたのは、 インスタンスを作りたいなら素直 に、

new Something ()

とすればいいではないか。 なぜPrototypeパターンが必要なのか、というものでした。 そ の答えについては、 本章のはじめに3つの場合を挙げて簡単にお話しました。 ここで、 も う一度サンプルプログラムを振り返りつつ説明しましょう。

(1) 種類が多すぎてクラスにまとめられない場合

サンプルプログラムでは、3つのひな型が登場しました。

・・・を使って文字列に下線を引くもの ・・・を使って文字列に枠をつけるもの ・リ/ を使って文字列に枠をつけるもの

この例はシンプルなものですから、 ひな型は3つだけですが、その気になればいくらで も多くの種類を作ることができます。 しかし、 それらをすべて別々のクラスにしてしまっ ては、クラスの数が多くなりすぎて、 ソースプログラムを管理しにくくなります。

(2) クラスからのインスタンス生成が難しい場合

これは、今回のサンプルではあまり実感できません。 マウスを使って操作を行う、 図形 エディタのようなアプリケーションを想像すると理解しやすいと思います。 ユーザが操作 を行って作った図形を表すインスタンスと同じものを作りたいとします。 そのときは、ク ラスを使うのではなく、 インスタンスをコピーして作る方が簡単でしょう。

(3) フレームワークと生成するインスタンスを分けたい場合

サンプルプログラムでは、インスタンスのコピー (clone) を行う部分を framework パ ッケージの中に閉じ込めています。

Managerクラスのcreateメソッドには、クラス名の代わりに "strong message や "slash box という文字列をインスタンス生成のための名前として与えています。 これは、 Javaという言語が備えているインスタンス生成の機構であるnew Something () という形式

コピーしてインスタンスを作る

をより一般化し、クラス名の束縛からフレームワークを分離しているといえます。

クラス名は束縛なのか

ところで、ソースプログラムの中にクラス名が書かれていると、 何が問題なのでしょう か。 ソースコード中に利用するクラス名を書くのは当然のことではないでしょうか。 ここで私たちは、オブジェクト指向プログラミングの目標の1つが 「部品としての再利

用」 であることをもう一度思い出す必要があります。

ソースの中に利用するクラスの名前を書いておくことが、 常に悪いわけではありません。 しかし、ソースの中に利用するクラスの名前が書かれていると、そのクラスと切り離して 再利用することはできなくなってしまうのです。

ええ、もちろんソースを書き換えて、 クラス名を変更することはできます。 でも、ここ で述べている「部品としての再利用」 ではソースを書き換えることは考えません。 Javaで いえば、手元にあるのがクラスファイル (.class) だけでも、そのクラスを再利用できる かが大切なのです。 ソースファイル (.java) がなくても再利用できるかがポイントな のですね。

密に結合しなければならないクラスの名前がソース中に書かれるのは当然であり、問題 はありません。 部品として独立させなければならないクラスの名前がソース中に書かれて いることが問題なのです。

関連しているパターン

82

Flyweight パターン 第20章)

Prototypeパターンでは、現在のインスタンスと同じ状態の別のインスタンスを作って 利用します。

Flyweight パターンでは、1つのインスタンスを複数の場所で共有して利用します。

Memento パターン (第18章)

Prototypeパターンでは、現在のインスタンスと同じ状態の別のインスタンスを作りま す。

Mementoパターンでは、スナップショットとアンドゥを行うために現在のインスタン スの状態を保存します。

[補講 clone メソッドと java.lang.Cloneable インタフェース

Composite パターン (第11章) および Decorator パターン (第12章)

Composite パターンやDecoratorパターンを多用しているとき、複雑な構造のインスタ ンスが動的に作られる場合があります。 このようなときPrototypeパターンを使うと便利 なことがあります。

Command パターン (第22章)

Commandパターンに登場する命令を複製したい場合に、 Prototypeパターンが使われる 場合があります。

補講 : clone メソッドとjava.lang.Cloneableインタフェース

Java clone

クローン Java言語では、 インスタンスのコピーを行う機構としてcloneメソッドが用意されていま す。 cloneメソッドを実行する場合、 コピー対象となるクラスは java.lang.Cloneable イン タフェースを実装する必要があることに注意してください。 コピー対象となるクラスが直 接java.lang.Cloneableインタフェースを実装してもかまいませんし、 スーパークラス のどこかでCloneableインタフェースを実装してもかまいません。 また、 Cloneableイン タフェースのサブインタフェースを実装してもかまいません。 サンプルプログラムでは、 MessageBoxクラスや Underline PenクラスはProductインタフェースを実装し、その ProductインタフェースはCloneableインタフェースのサブインタフェースになっていま す。

Cloneable インタフェースを実装したクラスのインスタンスは、 cloneメソッドを呼び 出すとコピーされます。 そして、 cloneメソッドの戻り値はコピーによって作られたイン スタンスになります (内部でやっていることは元のインスタンスと同じ大きさのメモリ を確保し、 元のインスタンスのフィールドの内容をコピーしているのです)。 クローン・ノット・サポーティド・エクセプション もしも、 Cloneableインタフェースを実装していないクラスのインスタンスがclone メ ソッドを呼び出すと、 例外 Clone Not supportedException (cloneがサポートされていな い例外) が発生します。

整理すると、以下のようになります。

・Cloneable インタフェースを実装しているクラスのインスタンス →コピーされる

・Cloneable インタフェースを実装していないクラスのインスタンス →CloneNot SupportedException が発生する

83

84 第6章 Prototype コピーしてインスタンスを作る

なお、 java.langパッケージは暗黙のうちにimport されていますので、ソース中では java.lang.Cloneable とは書かず、 単にCloneableと書くことができます。

clone メソッドはどこで定義されているか

cloneメソッドは、 java.lang.Objectクラスで定義されています。 Objectクラスは Javaのクラス階層のおおもとのクラスですから、 どのクラスでもcloneメソッドを継承し ていることになります。

| Cloneableが要求するメソッドは?

「Cloneableインタフェース」 というと、 その中にcloneメソッドが宣言されているよ うに考えがちです。 でも、違います。 Cloneableインタフェースにはメソッドは1つも宜 言されていません。 このインタフェースは、単に 「cloneによってコピーすることができ る」という印として使われています。 このような印をつけるインタフェースのことをマー カーインタフェース (marker interface) と呼びます。

Javaの標準ライブラリでCloneableがマーカーインタフェースであることはいまさら変 えられませんが、本来あるべき姿としてはCloneable中でcloneを宣言するように規定す べきだったでしょう。 そうすればCloneNot supportedException という例外も不要にな ります。

| cloneメソッドは浅いコピーを行う

cloneメソッドによって行われるのは、フィールドの内容をそのままコピーするという 動作です。 言い換えれば、フィールドの先にあるインスタンスの中身までは考慮しない、 ということです。例えば、フィールドの先に配列があったとします。 cloneメソッドを使 ってコピーした場合、 その配列への参照がコピーされるだけであって、配列の要素1つ1 つがコピーされるわけではありません。

このようなフィールド対フィールドのコピー (field-for-field copy) のことを 「浅いコ ピー (shallow copy)」 と呼びます。 cloneメソッドが行うのは 「浅いコピー」 です。 シャロウ・コピー

cloneが行う 「浅いコピー」だけでは困る場合には、クラス設計者がclone メソッドを オーバーライドして、自分が必要な「コピー」 を定義することも可能です (cloneメソッ ドをオーバーライドする場合には、 super.clone() を使ってスーパークラスのclone メソ ッドを呼ぶのを忘れないようにしましょう)

cloneはコピーを行うだけであって、 コンストラクタを呼ぶわけではないことにも注意

この章で学んだこと

する必要があります。 また、 インスタンス生成時に何か特殊な初期化を必要とするクラス では、 clone メソッド内に処理を記述する必要があります。

詳しくは、JavaのAPIリファレンスで、 java.lang.Objectクラスのcloneメソッド、 およびjava.lang.Cloneableインタフェースの項を参照してください。

cloneは使いにくい

本章では、Java言語で提供されているcloneの仕組みを使って Prototypeパターンを実 装しました。 しかし、 多種類のフィールドを持ったクラスのインスタンスを複製するため にcloneの仕組みを使うのは大変です。 それは、 java.lang.Objectクラスのclone メソ ッドがprotectedになっているため、 継承関係にないクラスのcloneメソッドを呼び出す ことが難しいからです (cloneの難しさについて詳しくは付録D [Bloch] の [項目13 cloneを注意してオーバーライドする」 を参照)。

実際のJava プログラミングでインスタンスのコピーを行うクラスを設計する場合、 cloneの仕組みに頼らず、 コピーコンストラクタやコピーファクトリを使う方がいいでし ょう。 練習問題 6-2では、 サンプルプログラムをコピーコンストラクタを使って書き換え ます。

この章で学んだこと

この章では、 クラスからインスタンスを作るのではなく、 インスタンスから新しいインス タンスを作る Prototype パターンについて学びました。 また、 cloneメソッドとCloneable インタフェースの使い方も学びました。

85

章 Potypeコピーしてインスタンスを作る

練習問題

●問題 6-1

解答は付録A (p.418)

サンプルプログラムでは、 MessageBoxクラス (List 6-3) Underline Pen クラス (List 6-4) に、 同じ動作をする createCopyメソッドが定義されています。 同じ動作をす るメソッドが1つのプログラムに複数個定義されているのは管理上好ましくありませんの で、このメソッドを共有したいとします。 どうしたらいいですか。

問題 6-2

Java

サンプルプログラムでは、Javaのclone を使ってインスタンスのコピーを実装しました が、コピーコンストラクタを使ってインスタンスをコピーする方法もあります。 コピーコ ンストラクタとは「同じクラスのインスタンスを引数に持ち、インスタンス生成時にフィ ールドのコピーを行うコンストラクタ」のことです。 例えば、 サンプルプログラムの MessageBoxクラス (List 6-3) にコピーコンストラクタを定義すると、次のようになりま す。

// コピーコンストラクタ public MessageBox (MessageBox prototype) { this.decochar = prototype.decochar:

コピーコンストラクタを使ってインスタンスのコピーを行うようにサンプルプログラム を書き換えてください。

86

第7章 Builder

複雑なインスタンスを 組み立てる

第7章 Builder複雑なインスタンスを組み立てる

Builder パターン

都会にはビルディングがたくさんあります。 ビルディング (building) は、 構造を持つ 大きな建築物ですね。 一般に、 構造を持っている大きなものを建築したり構築したりする ビルド ことを、英語でbuildといいます。

ビルディングを建てるとき、 まず地盤を固め、 骨組みを作り、下から上に少しずつ作って いきます。 一般に、複雑な構造を持ったものを作り上げるとき、一気に完成させるのは困難 です。 まず全体を構成している各部分を作り、段階を踏んで組み上げていくことになります。 この章では、構造を持ったインスタンスを組み上げていく、

ビルダー

Builder パターン

について学びます。

サンプルプログラム

サンプルとして、 Builderパターンを使って「文書」を作成するプログラムを作ってみ ましょう。 ここで作る文書は以下のような構造を持っています。

・タイトルを1つ含む ・文字列をいくつか含む . 箇条書きの項目をいくつか含む

Builder クラスでは、 文書を構成するためのメソッドを定めます。 そして、 Director クラスがそのメソッドを使って、 具体的な1つの文書を作ります。

Builderクラスは抽象クラスで、 実際の処理は書かれていません。 抽象メソッドが宣言 されているだけです。 文書作成のための具体的な処理を決定するのは、 Builderクラスの サブクラスです。

このサンプルプログラムでは、 Builderクラスのサブクラスとして以下のクラスを定義 しました。

TextBuilder クラス テキスト (普通の文字列) を使って文書を作る ・HTMLBuilder クラス ・HTMLを使って文書を作る

Director が TextBuilder を使うとテキストの文書ができ、 HTMLBuilder を使うと HTMLの文書ができます。

章末の練習問題 (問題7-3) でも、 Builderクラスのサブクラスを作ります。

88

サンプルプログラム

| Table 7-1 クラス一覧

名前 Builder Director 解說 文書を構成するためのメソッドを定めた抽象クラス 1つの文書を作るクラス TextBuilder テキスト (普通の文字列) を使って文書を作るクラス HTMLBuilder HTMLファイルを使って文書を作るクラス Main 動作テスト用のクラス

Fig.7-1 サンプルプログラムのクラス図

Uses▸ Main Director builder construct Builder makeTitle makeString makeItems sb TextBuilder makeTitle makeString makeItems close getTextResult close Uses HTMLBuilder filename sb makeTitle makeString makeItems close getHTMLResult Uses

Builder クラス

Builder クラス (List 7-1) は、 「文書」 を作るメソッドたちを宣言している抽象クラス です。makeTitle, makestring, makeItems は、それぞれタイトル、文字列、箇条書き を文書中に構築するメソッドです。 closeメソッドは文書を完成させるメソッドです。

89

2章なインスタンスを組み立てる

第

List 7-1 Builder クラス (Builder.java)

1: public abstract class Builder ( 2: public abstract void makeTitle (String title); 3: public abstract void makeString (String str); 4: 5: public abstract void makeItems (String[] items); public abstract void close(); 6:1

| Director クラス

Directorクラス (List 7-2) では、 Builderクラスで宣言されているメソッドを使って 文書を作ります。

Director クラスのコンストラクタの引数はBuilder 型です。 しかし、 実際にはBuilder クラスのインスタンスが引数として与えられることはありません。 なぜなら、 Builderク ラスは抽象クラスなので、 インスタンスを作れないからです。 Directorのコンストラクタに 実際に渡されるのは、Builderクラスのサブクラス (後で述べる TextBuilder クラスや HTMLBuilder クラスなど) のインスタンスです。 与えられたBuilder クラスのサブクラス の種類によって、 Director クラスが作る具体的な文書の形式が定まります。

constructメソッドは、 文書を作るメソッドです。 このメソッドを呼ぶと、 文書が構築 されます。 constructメソッドが使うのは、 Builder で宣言されているメソッドだけです コンストラクト (construct は英語で 「構築する」という意味です)。

List 7-2 Director クラス (Director.java)

1: public class Director (

private Builder builder;

3:

public Director (Builder builder) (

4:

5:

// コンストラクタ

this.builder = builder;

6:

}

7:

2:

8:

9:

// 文書を作るメソッド

10:

public void construct() {

11:

builder.makeTitle("Greeting");

12:

builder.makeString("一般的なあいさつ): builder.makeItems (new String[]{

13:

"How are you?",

14:

90

サンプルプログラム 91

15: 16: 17: 18: 19: 20: 21: 22: 23: 24: 25: 26: ) } }); "Hello.", "Hi.". builder.makeString("B builder.makeItems (new String[]( }); "Good morning.", "Good afternoon.", "Good evening.", builder.close();

TextBuilder クラス

TextBuilder クラス (List 7-3) は、 Builder クラスのサブクラスです。 テキストを使 って文書を構築します。 結果はStringとして返します。

List 7-3 TextBuilder 5 (TextBuilder.java)

1: public class TextBuilder extends Builder (

2:

private StringBuilder sb = new StringBuilder();

3:

@Override

4:

5:

public void makeTitle (String title) (

6:

sb.append("========

sb.append(" [");

8:

7:

sb.append("\n\n");

9:

sb.append(title);

10:

11:

12:

@Override

public void makeString (String str) {

13:

14:

15:

sb.append();

sb.append(str);

16:

17:

sb.append("\n\n");

18:

19:

20:

@Override

=======\n");

public void makeItems (String[] items) (

for (String s: items) (

sb.append(" ");

sb.append(s);

21:

22:

23:

Build 2

24:

25:

sb.append("\n");

7485888

sb.append("\n");

@Override

29:

30:

public void close() { sb.append(

31: =

32: 2

33: 2

======\n");

34: public String getText Result () () 2

35: 2

return sb.toString();

36: 37: 1 25

}

HTMLBuilder クラス

HTMLBuilderクラス (List 7-4) も Builderクラスのサブクラスです。 HTML クラスはHTMLファイルとして文書を構築します。 構築した結果はHTMLファイルで ァイル名として返します。

List 7-4 HTMLBuilder 2 (HTMLBuilder.java)

1: import java.io.*;

2:

3: public class Builder extends Builder (

private String filename = "untitled.html";

4:

5:

private StringBuilder sb new StringBuilder();

6:

7:

@Override

public void makeTitle (String title) {

9:

filename = title.html";

20

b.append("<!DOCTYPE html>\n");

b.append("<html>\n");

<head><title>");

112

w</title> </head>\n");

(title);

<body>\n");

64(1)

496(1616)/

92

20:

サンプルプログラム

21:

@Override public void makeString (String str) { sb.append("<p>"); sb.append(str); sb.append("</p>\n\n"); }

26: : : 29: 30: 31: 32: @Override public void makeItems (String[] items) ( sb.append("<ul>"); for (String s: items) ( sb.append("<li>"); sb.append(s); sb.append("</li>\n"); sb.append("</ul>\n\n"); 33: 34: 35: ) 36: 37: 38: 39: 40: 41: 42: 43: 44: 45: 46: 47: 48: 49: 50: 51: 52: @Override public void close() ( sb.append("</body>"); sb.append("</html>\n"); try ( Writer writer = new FileWriter (filename); writer.write(sb.toString()); writer.close(); } catch (IOException e) { e.printStackTrace(); : : 55: ) public String getHTMLResult () ( ) return filename;

25:

5354

Main クラス

23:

Main クラス (List 7-5) は、 Builderパターンのテストプログラムです。以下のように、 コマンドラインで指定した形式に応じた文書を作ります。

テキストで文書を作成 java Main text java Main html ・HTMLファイルで文書を作成

24:

93

22:

2728

Builderインスタンスを組み立てる

コマンドラインでtextを指定した場合には、 TextBuilderクラスのインスタンスを Director クラスのコンストラクタに渡します。 また、 コマンドラインでhtmlを指定した 場合には、HTMLBuilderクラスのインスタンスをDirectorクラスのコンストラクタに渡 します。

TextBuilderもHTMLBuilderもBuilder のサブクラスであり、 Director は Builderの メソッドのみを使って文書を作ります。 Builderのメソッドのみを使うということは、 Director は、実際に動いているのがTextBuilder なのかHTMLBuilderなのかを意識してい ないことになります。

ですから、Builderは、 文書を構築するという目的を達成するのに必要かつ十分なメソ ッド群を宣言している必要があります。 ただし、テキストやHTMLファイルに固有のメソ ッドまでをBuilder が提供してはいけません。

List 7-5 Main クラス (Main.java)

1: import java.io.IOException;

2: import java.nio.file.Files: 3: import java.nio.file.Path; 4:

5: public class Main (

public static void main(String[] args) {

6:

7:

if (args.length != 1) {

usage();

8:

System.exit(0);

9:

10:

11:

if (args[0].equals("text")) (

12:

TextBuilder textbuilder = new TextBuilder();

Director director = new Director (textbuilder); director.construct();

13:

14:

15:

String result = textbuilder.getTextResult(): System.out.println(result);

16:

} else if (args[0].equals("html')){

17:

18:

HTMLBuilder htmlbuilder = new HTMLBuilder();

19:

Director director = new Director (htmlbuilder);

20:

21:

director.construct();

String filename = htmlbuilder.getHTMLResult();

System.out.println("HTML ファイル filename + が作成されました。

22:

} else {

23:

usage();

24:

System.exit(0);

25:

26:

27:

28:

}

94

サンプルプログラム

29: 30: 31: 32: 33: 34: ) // 使い方を表示する public static void usage() { System.out.println("Usage: java Main text System.out.println("Usage: java Main html }

テキストで文書作成*);

Fig.7-2 実行結果 (テキスト)

HTMLファイルで文書作成");

java Main text

[Greeting]

■一般的なあいさつ

• How are you?

• Hello.

. Hi.

■時間帯に応じたあいさつ

Good morning.

. Good afternoon.

. Good evening.

======

Fig.7-3 (HTML)

java Main html

HTMLファイル Greeting.html が作成されました。

95

章 Builderなインスタンスを組み立てる

第7

Fig.7-4 Greeting.html (HTMLBuilder #7)

<!DOCTYPE html>

<html>

<head><title>Greeting</title></head>

<body>

<h1>Greeting</h1>

<p>一般的なあいさつ </p>

<ul>

<li>How are you?</li>

<li>Hello.</li>

<li>Hi.</li>

</ul>

<p>時間帯に応じたあいさつ </p>

<ul>

<li>Good morning.</li> <li>Good afternoon.</li>

<li>Good evening.</li> </ul>

</body></html>

Fig.7-5 HTMLBuilderが作成したGreeting.html をブラウザで見た様子

Greeting

一般的なあいさつ

• How are you? Hello. Hi.

時間帯に応じたあいさつ

Good morning. Good afternoon. Good evening.

96

Builder パターンの登場人物 97

Builder パターンの登場人物

Builderパターンの登場人物は、次のとおりです。

ビルダー Builder (建築者)の役

Builder役は、インスタンスを作成するためのインタフェース(API)を定めます。 Builder 役には、インスタンスの各部分を作るためのメソッドが用意されます。 サンプルプログラ ムでは、 Builderクラスがこの役をつとめました。

コンクリートビルダー Concrete Builder (具体的建築者)の役

Concrete Builder 役は、 Builder役のインタフェース (API) を実装しているクラスです。 実 際のインスタンス作成で呼び出されるメソッドが、 ここで定義されます。 また、 最終的にで きた結果を得るためのメソッドが用意されます。 サンプルプログラムでは、TextBuilder クラスやHTMLBuilder クラスがこの役をつとめました。

・Director (監督者) の役

Director役は、 Builder 役のインタフェース (API) を使ってインスタンスを生成します。 Concrete Builder 役に依存したプログラミングは行いません。 Concrete Builder 役が何であ ってもうまく機能するように、 Builder 役のメソッドのみを使います。 サンプルプログラ ムでは、 Director クラスがこの役をつとめました。

クライアント Client (依頼人)の役

Builderパターンを利用する役です (GoF本 (付録D [GoF] 参照) では、 Client役は Builder パターンの中には含まれていません)。 サンプルプログラムでは、 Mainクラスがこ の役をつとめました。

11

4

Fig:77 Builderパターンのシーケンス図

client Director new construct buildParti buildPart2 buildPart3 getResult

あなたの考えを広げるためのヒント 99

関連しているパターン

Template Method パターン (第3章)

Builderパターンでは、Director 役が Builder 役をコントロールします。 一方、 Template Methodパターンでは、スーパークラスがサブクラスをコントロールし ます。

Composite パターン (第11章)

Builder パターンによって作られる生成物は、 Composite パターンになる場合があります。

Abstract Factory パターン (第8章)

Builder パターンもAbstract Factoryパターンも、複雑なインスタンスを生成します。

・Facade パターン (第15章)

BuilderパターンのDirector 役は、 Builder役の複雑なメソッドを組み合わせて、 インス タンスを構築する単純なインタフェース (API) を外部に提供します (サンプルプログラ ムでは constructメソッドがそれに相当します)。

FacadeパターンのFacade役は、 内部モジュールを組み合わせて、 作業を行うための単 純なインタフェース (API) を外部に提供します。

あなたの考えを広げるためのヒント

誰が何を知っているか

オブジェクト指向プログラミングでは、 「誰が何を知っているか」 はとても大切です。 すなわち、どのクラスがどのメソッドを使えるか (使ってよいか) に注意してプログラミ ングをする必要があります。

サンプルプログラムを思い出してください。

Main クラスはBuilderクラスのメソッドを知りません (呼び出しません)。 Main クラス は、 Director クラスのconstructメソッドだけを呼び出します。 すると、 Director クラ スの中でむにゃむにゃ仕事が進み (それをMainクラスは気にかけず)、 文書が完成します。 ・方、 Director クラスが知っているのは Builderクラスです。 Director クラスは Builder クラスのメソッドを使って文書を構築します。 しかし、 Director クラスは、自

TEWARTS

に使用しているクラスが 「本当は」 何なのかを知りません。 TextBuilderなのか、 lderなのか、あるいはBuilderの他のサブクラスなのかを知りません。 知らなく てもいいのです。 Director クラスはBuilder クラスのメソッドだけを使っており、 Builderクラスのサブクラスはそのメソッドを実装しているからです。

Director クラスが自分の利用しているBuilderクラスのサブクラスを知らないのは、 とてもいいことです。 なぜなら、「知らないからこそ入れ替えができる」からです。 TextBuilderのインスタンスをDirector に与えても、 HTMLBuilderのインスタンスを Directorに与えても、正しく機能するのは、 Director クラスがBuilderクラスの具体的 なサブクラスを 「知らない」からなのです。

知らないからこそ、入れ替えができる。 入れ替えられるからこそ、 部品としての価値が 高い。 この 「交換可能性」について、 クラスの設計者は常に意識しておく必要があります。

依存性の注入 (Dependency Injection)

Directorクラスは Builderクラスを知っていますが、 Builderクラスのサブクラス TextBuilder PanBuilder) については知りません。 つまり、 Director は TextBuilderや Builderには依存していないといえます。

しかし、 Directorクラスが実際に動作するためには Builder の具体的なインスタンス が必要になります。 ですから、 Directorクラスのコンストラクタを呼び出す際には、 Text Builder や HTMLBuilderのインスタンスを引数として渡しています。 Directorクラ スのソースコードには TextBuilder や HTMLBuilder とは書かれていません。 けれども、 TextBuilder や HTMLBuilderのインスタンスに依存して動作することになります。

「ソースコードには書かれていないけれど、 実際にはこのインスタンスを使って(依存 して)動作してくださいね」という意味を込めてインスタンスを渡すことを一般に依存性 ディペンデンシー インジェクション の注入といいます。 英語ではDependency Injection といい、 DIという略語で呼ばれること もあります。 「依存性の注入」 は慣れるまではわかりにくいですが、 クラス間の結合度を 低くし、プログラムの再利用性を高めるために有用な技法です。

たとえ話で表現しましょう。 依存性の注入とは、 書き物をする人に対して「はい!これ を使って書いてね」 と具体的な筆記具を手渡すのに似ています。 手渡すものは「筆記具」 と決まっていますが、 具体的に何か (鉛筆なのかボールペンなのか) は、手渡す時点で決 めることができます。 Builder が筆記具 TextBuilder や HTMLBuilder が鉛筆やボールペ ンだと考えればわかりやすいでしょう。 具体的な筆記具を渡すのが、依存性の注入に相当 するのです。

あなたの考えを広げるためのヒント

設計時に決められること、 決められないこと

Builderクラスは、 文書を構築するのに (目的を達成するのに) 必要かつ十分なメソッ ド群を宣言している必要があります。 Director クラスに与えられる道具は、 Builderク ラスが提供するものですから、 Builderクラスのメソッドとして何を用意するかは大事で すね。

しかも、 Builder クラスは、 将来増えるかもしれない Builderクラスのサブクラスたち の要求にも応える必要があります。 サンプルプログラムでは、テキストとHTMLファイル だけを作りました。 しかし、 将来他の形式 (例えばXXXX形式) の文書を作りたくなった としましょう。 そのとき、果たしてXXXX形式用のXXXXBuilderクラスを作ることができ るでしょうか。 新たなメソッドが必要になったりしないでしょうか。

クラス設計者は神さまではありませんから、 未来に起こることをすべて見通すことはで きません。 ただし、 近い将来に起こることが予想されている変化には耐えられるように設 計を行う必要があるでしょう。

ソースの読み方、修正の仕方

私たちがプログラミングを行うとき、ゼロから作る場合もありますが、 多くの場合には、 すでにできているソースへの修正や追加を行うことになります。

そのときには、まず既存のソースを読みます。 けれども、 抽象クラスだけを眺めていて もあまり情報は増えません (メソッド名などから手がかりは得られますが)。

サンプルプログラムの例でお話しましょう。 Builder という抽象クラスだけを読んでい てもらちがあきません。 少なくともDirectorのソースを読んで、 Builder というクラスの 使い方(メソッドの呼び出し方) を理解する必要があるでしょう。 その上でTextBuilder やHTMLBuilder というクラスを読むことで、 Builderの抽象メソッドにどのような動作が 期待されているかを知ることができます。 ソースを読む手がかりとして@Override アノテ ーションも役立ちます。

クラスの役割を理解していないと、 修正や追加を行う場合、 どのクラスを変更すべきか の判断を誤ります。 例えば、 Builder クラスを修正するということは、 Director が呼び 出すメソッドを修正することであり、 またBuilderクラスのサブクラスたち全部に影響が 及ぶということです。 あるいは、 うっかり Director クラスが TextBuilderクラスのメソ ッドを呼ぶような修正をしたりすると、 部品としての独立性が失われ、 HTMLBuilder に切 り替えたときにうまく動かなくなる可能性があります。

101

102

Builder-2 スを組み立てる

この章で学んだこと

この章では、構造を持ったインスタンスを組み上げていくBuilder パターンについて学 びました。 組み上げていく過程の詳細はDirector役により隠蔽されます。

練習問題

問題7-1

解答は付録A (p.420)

Java

サンプルプログラムのBuilder クラス (List 7-1) をインタフェースに変更し、それに あわせて他のクラスを修正してください。

●問題 7-2

サンプルプログラムのDirector クラス (List7-2) の constructメソッドを自由に修正 して、異なる文書を作ってみましょう。 そのときに、 TextBuilder クラスやHTMLBuilder クラスを修正する必要はまったくないことを確かめてください。

●問題 7-3

サンプルプログラムのBuilder クラス (List 7-1) のサブクラスとして、 Concrete Builder 役をつとめるクラスを作ってください。 テキスト、HTMLファイル以外なら、 題材は自由 です。

■問題 7-4

Java

TextBuilder クラス (List7-3) で、 文書を構築していくフィールドsbがString クラ スではなく、 StringBuilder クラスになっている理由は何ですか。 String を使った場合、 何かまずいことはあるでしょうか。

第8章

Abstract Factory

関連する部品を 組み合わせて製品を作る

))

凸

Abstract Factory関連する部品を組み合わせて製品を作る

Abstract Factory パターン

この章で私たちは、

アブストラクト・ファクトリー Abstract Factory パターン

について学びます。

アブストラクト abstract は 「抽象的な」 という意味で、 factory は 「工場」 という意味です。 すなわち、 abstract factory は 「抽象的な工場」 という意味になります。

普通に考えると、「抽象的」 という言葉と 「工場」 という言葉はあまり結びつきません ね。工場といったら部品を組み合わせて製品を作り出す場所ですから、やっていることは とても具体的なはずです。 それなのに 「抽象的な工場」 だなんて、いったいどういうこと なのでしょう。

しかし 「抽象的な工場」で驚いていてはいけません。 Abstract Factoryパターンでは、 「抽象的な工場」 だけではなく、 「抽象的な部品」 や 「抽象的な製品」 も登場するからです。 抽象的な工場では、 抽象的な部品を組み合わせて抽象的な製品を作ります。

「やれやれ、いったい何を言っているんだい?」 と思った読者もいらっしゃることでし ょう。 でも、ほら、 オブジェクト指向における 「抽象的」という言葉の意味を思い出して ください。 「抽象的」 という言葉は、 「具体的にどのように実装されているかについては考 えず、インタフェース (API) だけに注目している」状態のことですね。 例えば、 抽象メ ソッド (abstract method) というのは、メソッドの本体は書かれておらず、名前とシグニ チャ(引数の型と数) だけが定まっているメソッドのことでした。

具体的なメソッドの内容は忘れて (忘れたふりをして) 抽象メソッドを使ってプログ ラミングすることの意味は、 Template Methodパターン (第3章) やBuilderパターン (第 7章) でも少しお話しました。

Abstract Factoryパターンでは、抽象的な工場が登場し、抽象的な部品を組み合わせて 抽象的な製品を作ります。 つまり、部品の具体的な実装には注目せず、 インタフェース (API)に注目する。 そして、そのインタフェース (API) だけを使って、 部品を組み立て、 製品にまとめるのです。

Template Method パターンやBuilderパターンでは、 サブクラスのレベルで具体的な実 装を行いました。 Abstract Factoryパターンでも、サブクラスのレベルで具体的な実装を 行います。 サブクラスのレベルでは、具体的な工場が登場し、具体的な部品を組み合わせ て、具体的な製品を作ります。

「抽象的な話はいいから、 早くサンプルプログラムを見せてよ!」 という読者の声が聞 こえてきましたので、さっそく抽象的な工場の具体的なサンプルプログラムを読んでいく ことにいたしましょう。

104

サンプルプログラム

サンプルプログラム

本章のサンプルプログラムは、 「階層構造を持ったリンク集をHTMLファイルとして作る」 というものです。 最後にできあがるHTMLファイルはFig.8-1のようになり、それをWebブ ラウザで見るとFig.8-2のようになることを覚えておいてください。

Fig.8-1 (list.html)

<<html><head><title>Blog and News</title> </head> <body> <h1>Blog and News</h1> <ul> <li> Blog Site <ul> <li><a href="https://example.com/blog1">Blog 1</a></li> <li><a href="https://example.com/blog2">Blog 2</a></li> <li><a href="https://example.com/blog3">Blog 3</a></li> </ul> </li> <li> News Site <ul> <li><a href="https://example.com/news1">News 1</a></li> <li><a href="https://example.com/news2'>News 2</a></li> <li> News 3 <ul> <li><a href="https://example.com/news3us">News 3 (US)</a><<li><a href="https://example.com/news3jp">News 3 (Japan)</ul> </li> </ul> </li> </ul> <hr><address>Hiroshi Yuki</address> </body></html>

!DOCTYPE html>

/li> </a></li>

105

Abstract Factory関連する部品を組み合わせて製品を作る

106

Fig.8-2 階層構造を持ったリンク集をブラウザで見た様子

Blog and News ⚫ Blog Site Blog_1 Blog. 2 • Blog 3 ⚫ News Site • News 1 ⚫ News 2 • News 3 Hiroshi Yuki ⚫ News 3 (US) ⚫ News 3 (Japan)

このサンプルプログラムは、以下の3つのパッケージに分かれたクラス群で構成されて います。

・factory パッケージ ・無名パッケージ ............... . listfactory パッケージ 抽象的な工場・部品 製品を含むパッケージ ・Main クラスを含むパッケージ 具体的な工場・部品 製品を含むパッケージ (ここでは<ul>タグを使って実装している)

クラス一覧を Table 8-1に、UMLのクラス図をFig.8-3に示します。 クラス図の上の方 が抽象的な工場で、下の方が具体的な工場です。 クラス図ではMainクラスを省略してい ます。

Table 8-1 クラス一覧

パッケージ 名前 解說 factory Factory 抽象的な工場を表すクラス (Link, Tray, Page を作る) factory Item Link と Trayを統一的に扱うためのクラス factory Link factory Tray factory Page 無名 Main 抽象的な部品: HTMLのリンクを表すクラス 抽象的な部品: Link や Trayを集めたクラス 抽象的な製品: HTMLのページを表すクラス 動作テスト用のクラス listfactory ListFactory 具体的な工場を表すクラス (ListLink, ListTray, ListPage を作る) 具体的な部品: HTMLのリンクを表すクラス 具体的な部品: LinkやTrayを集めたクラス listfactory ListLink list factory ListTray listfactory List Page 具体的な製品: HTMLのページを表すクラス

サンプルプログラム 107

Fig.8-3 サンプルプログラムのクラス図

factory

url makeHTML Link ListLink makeHTML caption Item makeHTML Creates Creates Tray tray add makeHTML Creates Factory getFactory createLink createTray createPage ListTray makeHTML Creates ListFactory createLink createTray createPage Page title author add output makeHTML Creates ListPage makeHTML Creates

listfactory

Abstract Factory関連する部品を組み合わせて製品を作る

各クラスのソースファイルは、 Fig.8-4に示すディレクトリ上に置きます。

Fig.8-4 ソースファイルを置くディレクトリ

-Main.java

factory

Factory.java

Item.java

-Link.java

-Tray.java

-Page.java

listfactory

-ListFactory.java

-ListLink.java

-ListTray.java

-ListPage.java

CJava コンパイルは、

javac Main.java listfactory/ListFactory.java

のように行います。

これまでのサンプルプログラムでは、 Main.java をコンパイルするだけで、必要なクラス はすべてコンパイルされました。 しかし、今回のサンプルプログラムでは、 Main.java をコ コンパイルするとFactory.java, Item.java, Link.java, Tray.java, Page.java はコンパイルされます が、ListFactory.java, ListLink.java, ListTray.java, ListPage.javaはコンパイルされません。 こ れは、Main クラスはfactoryパッケージだけを使っており、 list factory パッケージは 直接使っていないからです。 そこで、 listfactory/ListFactory.java もコンパイルされるよう に、引数に加えています(これだけで、 ListFactory.java, ListLink.java, ListTray java. ListPage.javaもコンパイルされます)。

| Fig.8-5 コンパイルと実行結果

javac Main.java listfactory/ListFactory.java java Main list.html listfactory.ListFactory list.html を作成しました。

(この後、Webブラウザでlist.html を見るとFig.8-2 になる)

108

サンプルプログラム 109

抽象的な部品 Itemクラス

アイテム Itemクラス (List 8-1) は、 Link と Trayのスーパークラスになっています (item は 「項目」という意味)。 これはLink と Trayを同一視するためのクラスです。

caption フィールドは、この項目の「見出し」を表します。

makeHTMLメソッドは抽象メソッドで、 サブクラスで実装することが期待されています。 このメソッドを呼び出すと、 HTMLの文字列が戻り値となります (なるようにサブクラス を作ります)。

List 8-1 Item クラス (Item.java)

1: package factory;

2: 3: public abstract class Item( protected String caption; public Item (String caption) ( this.caption = caption; 4: 5: 6: 7: 8: } 9: 10: 11: ) public abstract String makeHTML();

抽象的な部品: Linkクラス

Link クラス (List 8-2) は、 HTMLのハイパーリンクを抽象的に表現したクラスです。 url フィールドは、リンクの飛び先のURLを保持するためのものです。 Linkクラスでは 抽象メソッドが1つも登場しないように見えますが、そうではありません。 Link クラスで は、スーパークラス (Item) の抽象メソッド (makeHTML) が実装されていません。 です から、 Link クラスも抽象クラスなのです。

List 8-2 Link クラス (Link.java)

1: package factory;

2: 3: public abstract class Link extends Item ( 4: protected String url; 5: 6: public Link (String caption, String url)

(

8章 Abract Factory関連する部品を組み合わせて製品を作る

T:

8:

super(caption);

this.url = url;

9:

10: )

抽象的な部品: Trayクラス

Trayクラス(List 8-3) は、 複数のLink や Trayを集めてひとまとまりにしたものを表 トレイ すクラスです (trayは 「お盆」のことです。 頭の中では、 お盆の上に箇条書きの1つ1つ の項目を載せる、と想像してください)。

Link や Tray は addメソッドを使って集めます。 「LinkやTray」 という部分を表現する ために、addメソッドではLinkとTrayのスーパークラスであるItemを引数にとります。 Trayクラスも Itemクラスの抽象メソッド makeHTMLを継承していますが、 実装はして いません。 ですから、 Trayクラスは抽象クラスということになります。

List 8-3 Tray クラス (Tray.java)

第

1: package factory; 2: 3: import java.util.ArrayList; 4: import java.util.List; 5: 6: public abstract class Tray extends Item ( protected List<Item> tray = new ArrayList<>(); 7: 8: 9: 10: 11: ' 12: 13: 14: 15: 16: ) public Tray (String caption) ( super (caption); public void add (Item item) ( ) tray.add(item);

抽象的な製品: Pageクラス

さて、 Page クラス (List 8-4) は、 HTMLページ全体を抽象的に表現したクラスです。

110

ンプルプログラム 111

Link や Trayが抽象的な 「部品」 だとすると、 Pageクラスは抽象的な 「製品」 といっても いいですね。 title はページのタイトル、 author はページの作者を表現するためのフィ ールドです。 作者名はコンストラクタへの引数で指定します。

ページには、add メソッドを使ってItem(すなわちLink かTray) を追加します。 追加 したものが、このページで表示されます。

output メソッドの中ではタイトルを元にファイル名を決定し、 makeHTMLメソッドを使 って、自分自身のHTMLの内容をファイルに書き込んでいます。

ファイルへの書き込みでは、 java.nio.file.Filesクラスの writeStringメソッドを 使っています。

・第1引数の Path.of (filename) はfilename というファイル名から得たjava.nio. file.Pathのインスタンスで、 書き込む対象のファイルです。

・第2引数のmakeHTML () は Stringのインスタンスで、ファイルに書き込む文字列で す。

・第3引数以降ではファイルを開くオプションを指定します。 ここでは「存在しなか ったら新たに作る (CREATE)」 と 「存在していたらサイズをいったん0にする(TRU NCATE_EXISTING)」と「書き込む (WRITE)」 とを StandardOpenOption を使って 指定しています。

List 8-4 Page クラス (Page.java)

1: package factory:

2: 3: import java.io.IOException; 4: import java.nio.file.Files; 5: import java.nio.file.Path; 6: import java.nio.file.StandardOpenOption; 7: import java.util.ArrayList; 8: import java.util.List; 9: 10: public abstract class Page ( protected String title; protected String author; protected List<Item> content = new ArrayList<>(); public Page (String title, String author) ( 11: 12: 13: 14: 15: 16: 17: 18: 19: ) 20: this.title = title: this, author author; public void add (Item item) (

112 第8章 Abstract Factory関連する部品を組み合わせて製品を作る

21: 22: } 23: 24: 25: 26: 27: 28: 29: 30: 31: 32: 33: 34: 35: 36: 37: ) content.add(item); public void output (String filename) { try { Files.writeString (Path.of (filename), makeHTML(). StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE); System.out.println(filename を作成しました。 *); } catch (IOException e) { + e.printStackTrace(); public abstract String makeHTML():

抽象的な工場 Factoryクラス

以上で、 抽象的な部品と抽象的な製品のソースを読みました。 今度は、いよいよ抽象的 な工場です。

List 8-5 のgetFactoryメソッドは、クラス名を文字列として指定して具体的な工場のイ コンスタンスを作成するものです。 引数のclassnameには、 例えば、

*listfactory. ListFactory*

のように、作成する具体的な工場のクラス名を文字列で指定します。 getFactoryの中で は、ClassクラスのforNameメソッドを使って、 そのクラスを動的に読み込みます。 そし て、 getDeclared Constructor メソッドでコンストラクタを得て、 newInstance メソッド でインスタンスを作ります。 それがgetFactoryの戻り値となります。

ここでは、クラスやコンストラクタといったプログラムの構成要素を(コンパイラが投 うのではなく) プログラム自身が扱っています。 このような処理を一般にリフレクション (reflection)といいます。

getFactoryというメソッドの中では具体的な工場のインスタンスを作りますが、戻り 値の型は抽象的な工場 (Factory) であることに注意してください。

createLink, createTray, createPageの各メソッドは、この抽象的な工場で部品や 製品を作成するときに用いるメソッドです。 これらは、どれも抽象メソッドになっていて、 実際の具体的な部品や製品の作成はFactoryのサブクラスにまかせています (subclass responsibility)。 ただし、メソッドの名前とシグニチャだけは、ここできっちり定められ

ています。

サンプルプログラム 113

List 8-5 Factory (Factory.java)

1: package factory 2: 3: public abstract class Factory ( 4: 5: 6: 7: public static Factory getFactory (String classname) ( Factory factory = null; try( factory = (Factory) Class.forName (classname).getDeclaredConstructor() newInstance(); } catch (ClassNotFoundException e) { System.out.println("クラス + classname + が見つかりません。"); } catch (Exception e) ( } e.printStackTrace(); return factory: 8: 9: 10: 11: 12: 13: 14: } 15:

public abstract Link createLink (String caption, String url);

16:

public abstract Page createPage (String title, String author):

17:

18:

19: )

public abstract Tray createTray (String caption);

工場を使って部品を組み合わせ、 製品を作る: Main クラス

抽象的な部品 製品 工場のソースコードを読んだところで、 今度はMainクラス (List 8-6) を読んでみましょう。 ここでは、抽象的な工場を使って抽象的な部品を製造し、抽 象的な製品を組み立てています。 import されているのが factory パッケージだけである ことからわかるように、このクラスでは、具体的な部品製品・工場をいっさい利用して いません。

具体的な工場のクラス名は、 コマンドラインから指定します。 例えば、 listfactoryパ ッケージのListFactoryクラスを使うなら、 コマンドラインから、

java Main list.html listfactory. ListFactory

と入力します。 この引数 (args[1])を元にgetFactoryで工場を作り、変数 factory に 代入します。

これ以降、factory を使ってLink を作り、 Tray を作り、 Trayの中にLink や Trayを入 れ、そして最後にPage を作って、 output を行います。

Abstract Factory関連する部品を組み合わせて製品を作る

List 8-6 Main 57 (Main.java)

1: import factory.*;

2: 3: public class Main ( public static void main(String[] args) { if (args.length != 2) { System.out.println("Usage: java Main filename.html class.name.of.Concrete System.out.println("Example 1: java Main list.html list factory. List Factory System.out.println("Example 2: java Main div.html divfactory. DivFactory"); System.exit(0); 4: 5: 6: ory'); 7: 8: 9: 10: } 11:

12:

String filename args[0]; String classname = args[1];

13:

14:

16:

Factory factory = Factory.getFactory (classname);

// Blog

Link blogl Link blog2 Link blog3

17:

18:

19: 20:

15:

factory.createLink ("Blog 1", "https://example.com/blog1"); factory.createLink ("Blog 2", "https://example.com/blog2"); factory.createLink ("Blog 3", "https://example.com/blog3");

22:

Tray blogTray factory.createTray (*Blog Site");

blogTray.add (blog1); blogTray.add(blog2);

27:

23:

24:

25:

26:

blogTray.add (blog3); // News Link news1 Link news2 Tray news3 factory.createLink ("News 1", "https://example.com/news1"); factory.createLink ("News 2", "https://example.com/news2"); factory.createTray ("News 3"); news3.add(factory.createLink ("News 3 (US)", "https://example.com/news3us')) news3.add(factory.createLink ("News 3 (Japan)", "https://example.com/news3jp Tray newsTray factory.createTray ("News Site"); newsTray.add(news1); newsTray.add(news2); newsTray.add(news3); // Page Page page factory.createPage ("Blog and News", "Hiroshi Yuki"); page.add(blogTray); page.add(newsTray); page.output (filename);

28:

29:

30:

31:

32:

21:

33:

34:

35:

36:

37:

38:

39:

40:

41:

42:

43:

44:

45:

46: 1

114

サンプルプログラム 115

| 具体的な工場: ListFactoryクラス

ここで頭を切り替えましょう。 さんざん抽象的な側のコードを読んできましたが、今度 は具体的な側のコードを読みます。 まず、 listfactoryパッケージの工場、 ListFactory クラスです。

ListFactoryクラス (List 8-7) では、 Factoryクラスの抽象メソッド createLink, createTray, createPage を実装しています。 ここでは、単にListLink, ListTray, ListPage を newしています。

List 8-7 ListFactory 57 (ListFactory.java)

1: package listfactory: 2: 3: import factory.Factory; 4: import factory.Link; 5: import factory.Page: 6: import factory.Tray; 7: 8: public class ListFactory extends Factory l @Override public Link createLink (String caption, String url)( return new ListLink (caption, url); @Override public Tray createTray (String caption) ( return new ListTray (caption); 9: 10: 11: 12: } 13: 14: 15: 16: 17: ) 18: 19: 20: 21: @Override public Page createPage (String title, String author) ( return new ListPage (title, author); 22: ) 23: )

| 具体的な部品: ListLinkクラス

ListLink クラス (List 8-8) は、 Linkクラスのサブクラスです。 実装しなければなら ないメソッドはなんでしたか。 そう、 スーパークラスで抽象メソッドだった makeHTMLで す。 ListLink では、 <li>タグと<a>タグを使ってHTMLの断片を作成しています。 あた

116 第8章 Abstract Factory関連する部品を組み合わせて製品を作る

しかも対になったボルトとナットがうまく組み合うように、 このHTMLの断片も、 他の ListTrayやListPageとうまく組み合うような書き方になっています

List 8-8 ListLink クラス (ListLink.java)

1: package listfactory; 2: 3: import factory.Link; 4: 5: public class ListLink extends Link ( public ListLink (String caption, String url) { super (caption, url); 6: 7: 8: 9: 10: 11: @Override public String makeHTML () ( 12: return " <li><a href=\" + url + "\">" + caption + *</a></li>\n"; 13: } 14: )

具体的な部品: ListTrayクラス

ListTrayクラス (List 8-9) は、 Trayクラスのサブクラスです。 ここでも makeHTML がどのように実装されているかに注目しましょう。 tray フィールドの中には、HTMLと して出力すべき Itemたちが集められています。 それらをHTMLのタグとして表現するの が、このmakeHTMLメソッドの使命です。 さあ、どうやっているでしょうか。

最初に <li> を使って見出し (caption) を出力し、 次に <ul> ではさんで個々のItemた ちを出力しています。 出力結果は、 いったんStringBuilder に集められ、最後に toString Stringに変換しています。

さて、個々の Item たちはどうやってHTML化するのでしょうか。 もちろん、 個々のItem のmakeHTML を呼び出してやるのです。 変数 item の中身が実際に ListLinkのインスタンス なのか、 ListTrayのインスタンスなのかを気にかける必要はありません。 ただシンプルに、

item.makeHTML()

という式を使えばいいのです。 ここで、変数 item の中身が実際に何なのかを調べて、 switch文やif文を使うようなプログラムを書いてはいけません。 それは、とても非・オブ ジェクト指向的なプログラムになってしまいます。 変数 item は Item型であり、 Item クラ スではmakeHTMLというメソッドが宣言されています。 そして、 ListLinkやListTrayは

サンプルプログラム 117

どちらもItemクラスのサブクラスです。 ですから、安心してmakeHTMLメソッドを呼び出 していいのです。 あとは、 うまい具合に item 君がmakeHTMLメソッドを処理してくれるの です。 どうやって処理するかは、 item 君という1つのインスタンス (オブジェクト)が知 っています。 これがオブジェクト指向のよさですね。

List 8-9 ListTray 757 (ListTray.java)

1: package listfactory: 2: 3: import factory. Tray; 4: import factory.Item; 5: 6: public class ListTray extends Tray { 7: public ListTray (String caption) ( super (caption); Goverride public String makeHTML () ( StringBuilder sb = new StringBuilder(); sb.append("<li>\n"); sb.append(caption); sb.append("\n<ul>\n"); for (Item item: tray) ( sb.append(item.makeHTML()); sb.append("</ul>\n"); 8: 9: } 10: 11: 12: 13: 14: 15: 16: 17: 18: 19: } 20: 21: 22: 23: 24: ) sb.append("</li>\n"); return sb.toString():

| 具体的な製品: ListPageクラス

ListPage (List 8-10) は、 Page クラスのサブクラスです。 makeHTMLメソッドは、もう わかりますね。ListPage は、 フィールドの内容を使ってページを構成しています。著者 (author)は<address> タグを使って表現しています。

for文を <ul></ul> ではさんでいる理由はわかりますか。 それは、このfor文の中で append される item.makeHTML () の出力結果が、 <ul>の中にはめ込まれることを前提とし ているからです。 ListLinkやListTrayのmakeHTMLメソッドを読み返してみてください。

第8章 Abaract Factory関する

必ず<li>タグが外側にきていましたよね。 ここが、いわば「ボルト」と「ナット」 のっ なぎ目です。

for で使われている content は、 Page クラスから継承しているフィールドです。

List 8-10 ListPage 757 (ListPage.java)

1: package listfactory;

2:

3: import factory.Item:

4: import factory.Page:

5:

6: public class List Page extends Page {

7:

8:

public List Page (String title. String author) (

super (title, author);

9:

1

10:

11:

12:

Override

public String makend() {

13:

14:

StringBuilder sb = new StringBuilder();

15:

sb.append("<!DOCTYPE html>\n");

17: =

sb.append("<html><head><title>");

16:

sb.append(title);

sb.append("</title></head>\n");

18: 1

sb.append("<body>\n");

19: 2

20: &

sb.append("<h1>");

sb.append(title);

21: 3

22:

sb.append("</h1>\n");

23: 0

sb.append("<ul>\n");

for (Item item: content) (

sb.append(Stem.make();

24:

25:

8 8 8 26: 27 29: 30: 31: 32: 33

sb.append("</ul>\n");

sb.append("<hr><address>");

sb.append (author);

sb.append("</address>\n");

sb.append("</body></html>\n"); return sb.toString();

: 1

118

サンプルプログラムに別の具体的な工場

サンプルプログラムに別の具体的な工場を追加

少し長くなってきましたが、もう少しお付き合いください。 前節では、抽象的な工場と 具体的な工場を見てきました。 でも、単にHTMLのリンク集を作ることが目的ならば、 ちょっとおおげさすぎますね。 それに具体的な工場が1つだけでは、 抽象的 具体的と分 ける必要はまったくありません。 そこで、以下ではサンプルプログラムに別の具体的な工 場 (つまり別の形式のHTMLファイルを作るもの) を追加してみることにいたしましょう。

先ほどのlistfactoryパッケージは、 <ul> を使ったデザインでした。 今度は、divfactory パッケージで、 <div> とCSSを使ったデザインにしてみましょう。 コンパイルと実行結果 をFig.8-6に示し、 作られたdiv.html を Fig.8-7に示します。 また、 それをWeb ブラウザで 見たものをFig.8-8に示します (Fig.8-2と見比べてみてください)。

Fig.8-6 コンパイルと実行結果

javac Main.java divfactory/DivFactory.java java Main div.html divfactory. DivFactory div.html を作成しました。

Fig.8-7 divfactoryパッケージを使ったリンク集 (div.html)

<!DOCTYPE html> <html> <head> <title>Blog and News</title> <style> div.TRAY { padding:0.5em; margin-left:5em; border:1px solid black; } div.LINKpadding:0.5em; background-color: lightgray; } </style> </head> <body> <h1>Blog and News </h1> <p> <b> Blog Site</b></p> <div class="TRAY"> <div class="LINK"> <a href="https://example.com/blog1->Blog 1 </a> </div> <div class="LINK"><a href="https://example.com/blog2">Blog 2</a></div> <div class="LINK"><a href="https://example.com/blog3">Blog 3</a></div> </div> <p> <b> News Site</b></p> <div class="TRAY"> <div class="LINK"> <a href="https://example.com/news1>News 1 </a> </div> <div class="LINK"><a href="https://example.com/news2 > News 2</a></div> <p><b>News 3</b></p> <div class="TRAY"><div class="LINK"> <a href="https://example.com/news3us News 3 (US)</a> </div> <div class="LINK"><a href="https://example.com/news3jp > News 3 (Japan) </a> </div> </div>

</div>

<hr> <address> Hiroshi Yuki</address>

</body> </html>

119

第8章 Abstract Factory関連する部品を組み合わせて製品を作る

Fig.8-8 divfactory パッケージを使ったリンク集をブラウザで見た様子

Blog and News Blog Site Blog 1 Blog 2 Blog 3 News Site News1 News 2 News 3 Hiroshi Yuki News 3 (US) News 3 (Japan)

Table 8-2 クラス一覧 (p.106のTable 8-1と比較してください)

パッケージ divfactory 名前 DivFactory divfactory DivLink divfactory DivTray divfactory DivPage 具体的な工場を表すクラス 解說 DivLink, DivTray, DivPageを作る) 具体的な部品: HTMLのリンクを表すクラス 具体的な部品 DivLink や DivTrayを集めたクラス 具体的な製品: HTMLのページを表すクラス

具体的な工場: DivFactoryクラス

DivFactoryクラス (List 8-11) は、 Factoryクラスのサブクラスです。 createLink. createTray, createPageでは、それぞれDivLink, DivTray, DivPage というクラスの インスタンスを作っています。

List 8-11 DivFactory クラス (DivFactory.java)

1: package divfactory; 2: 3: import factory. Factory;

120

サンプルプログラムに別の具体的な工場

4: import factory. Link; 5: import factory. Page; 6: import factory. Tray; 7: 8: public class DivFactory extends Factory ( @Override public Link createLink (String caption, String url) { return new DivLink (caption, url); @Override public Tray createTray (String caption) ( return new DivTray (caption); 9: 10: 11: 12: 13: 14: 15: 16: 17: } 18: 19: 20: 21: 22: } 23: ) @Override public Page createPage (String title, String author) ( return new DivPage (title, author);

| 具体的な部品: DivLink クラス

DivLinkクラス (List 8-12) は、 Linkクラスのサブクラスです。 makeHTMLでは、 <div>タグを使っています。 ほら、思い出してください。 ListLinkクラス (List 8-8) は、 <li>タグを使っていましたね。 今度は <div> タグです。

List 8-12 DivLink 57 (DivLink.java)

1: package divfactory; 2: 3: import factory. Link; 4: 5: public class DivLink extends Link ( public DivLink (String caption, String url) { super (caption, url); 6: 7: 8: ') 9: 10: 11: 12: 13: ) 14: ) @Override public String makeHTML() ( return "<div class=\"LINK\"><a href=\ + url + "\>+caption + "</a></div

>\n";

121

AbstractFactory関連する部品を組み合わせて製品を作る

具体的な部品 : DivTrayクラス

DivTrayクラス (List 8-13) は、 Trayクラスのサブクラスです。 makeHTMLでは、 <div> ではさんで Itemたちを出力しています。

List 8-13 DivTray 757 (DivTray.java)

1: package divfactory;

2:

3: import factory. Item;

4: import factory. Tray;

5:

6: public class DivTray extends Tray (

7:

public DivTray (String caption) { super (caption);

9:

10:

11:

Override

12:

13:

}

public String makeHTML() {

StringBuilder sb = new StringBuilder();

14:

sb.append("<p><b>");

15:

16:

sb.append(caption);

sb.append("</b></p>\n");

17:

sb.append("<div class=\"TRAY\">");

18:

19:

for (Item item: tray) {

20:

21:

}

sb.append(item.makeHTML():

22:

sb.append("</div>\n");

return sb.toString();

23:

8:

24: 1

具体的な製品: DivPageクラス

DivPage クラス (List 8-14) は、 Pageクラスのサブクラスです。 細かい部分の説明は もう不要ですね。 ListPageクラス (List 810) と見比べると、 対応関係がよくわかると 思います。

122

サンプルプログラムに別の具体的な工場を追加

List 8-14 DivPage 57 (DivPage.java) 2: 3: import factory. Item; 4: import factory. Page; 5: 6: public class DivPage extends Page ( 7: public DivPage (String title, String author) ( super (title, author); @Override public String makeHTML() ( StringBuilder sb = new StringBuilder(); sb.append("<!DOCTYPE html>\n"); sb.append("<html><head><title>"); sb.append(title); sb.append("</title> <style>\n"); sb.append("div. TRAY (padding: 0.5em; margin-left: 5em; border:1px solid black; }\n' sb.append("div. LINK { padding: 0.5em; background-color: lightgray; }\n"); sb.append("</style> </head><body>\n"); 8: 9: ) 10: 11: 12: 13: 14: 15: 16: 17: 18: 19: 20: 21: 22: 23: 24: 25: sb.append(item.makeHTML()); sb.append("<h1>"); sb.append(title); sb.append("</h1>\n"); for (Item item: content) {

1: package divfactory;

26:

}

sb.append("<hr><address>");

27:

sb.append(author);

sb.append("</body></html>\n");

28:

30:

sb.append("</address>\n");

return sb.toString();

29:

31:

33: )

32:

123

Abstract Factory関連する部品を組み合わせて製品を作る

Abstract Factory パターンの登場人物

Abstract Factoryパターンの登場人物は、次のとおりです。

AbstractProduct (抽象的な製品) の役

AbstractProduct役は、 AbstractFactory 役によって作り出される抽象的な部品や製品のイ ンタフェース (API) を定めます。 サンプルプログラムでは、 Linkクラス、 Trayクラス、 Page クラスがこの役をつとめました。

ファクトリー AbstractFactory (抽象的な工場) の役

AbstractFactory 役は、 AbstractProduct役のインスタンスを作り出すためのインタフェー ス (API) を定めます。 サンプルプログラムでは、 Factoryクラスがこの役をつとめまし た。

クライアント Client (依頼者)の役

Client役は、 AbstractFactory 役とAbstractProduct役のインタフェース (API)だけを使 って仕事を行う役です。 Client役は、具体的な部品や製品や工場については知りません。 サンプルプログラムでは、 Mainクラスがこの役をつとめました。 なお、 Fig.8-9 では Client 役は省略しています。

コンクリート・プロダクト ConcreteProduct (具体的な製品) の役

Concrete Product役は、 AbstractProduct役のインタフェース (API) を実装します。 サ ンプルプログラムでは、パッケージごとに以下のクラスがこの役をつとめました。

* listfactoryパッケージ ･･･ListLink クラス、ListTray クラス、ListPage クラス divfactory パッケージ ・DivLinkクラス、 DivTrayクラス、 DivPage クラス

コンクリート・ファクトリー Concrete Factory (具体的な工場)の役

Concrete Factory役は、 AbstractFactory 役のインタフェース (API) を実装します。 サン プルプログラムでは、パッケージごとに以下のクラスがこの役をつとめました。

listfactory パッケージ･････････ ListFactory クラス

DivFactoryクラス

divfactory パッケージ

124

Abstract Factoryパターンの登場人物

Fig.8-9 Abstract Factory/3-0777

factory

Abstract Product1 executeA executeB Abstract Product2 doAlpha doBeta Abstract Product3 performOne performTwo concretefactory Concrete Product1 executeA executeB - Creates Creates - Creates - Creates AbstractFactory createProduct1 createProduct2 createProduct 3 Concrete Product2 doAlpha doBeta Concrete Product 3 performone performTwo - Creates ConcreteFactory createProduct1 createProduct2 - Creates

createProduct3

125

Abstract Factory関連する部品を組み合わせて製品を作る

あなたの考えを広げるためのヒント

具体的な工場を新たに追加するのは簡単

Abstract Factory パターンに、具体的な工場を新たに追加するのは簡単です。 「簡単」と いうのは、どのようなクラスを作り、 どのようなメソッドを実装すればいいかがはっきり しているという意味です。

例えば、サンプルプログラムにさらに新たな具体的な工場を追加するとしましょう。 や るべきことは、Factory, Link, Tray, Pageのサブクラスを作り、それぞれの抽象メソ ッドを実装することです。つまり、factoryパッケージのクラスが持っている抽象的な部 分を具体化していくことですね。

このとき、いくら具体的な工場を追加しても(また、 具体的な工場のバグを修正しても 抽象的な工場やMainの部分を修正する必要はまったくありません。

部品を新たに追加するのは困難

Abstract Factoryパターンに新たな部品を追加することを考えましょう。 例えば、 factoryパッケージに画像を表すPicture という部品を追加したとしましょう。 そうする と、すでに存在する具体的な工場すべてに、 Picture に対応した修正が加わることになり ます。 例えば、 listfactoryパッケージならば、

ListFactoryクラスに createPictureメソッドを追加

・新たにListPicture クラスを作成

という修正が加わることになります。 すでに作られた具体的な工場が多ければ多いほど、 これは大変な作業になります。

関連しているパターン

◆Builder パターン (第7章)

Abstract Factory パターンは、インタフェース (API) が定まっている抽象的な部品を組 み合わせて複雑な構造を持ったインスタンスを作ります。

Builder パターンは、段階を追って大きなインスタンスを作ります。

126

インスタンスの作り方いろいろ

◆Factory Method パターン (第4章)

Abstract Factoryパターンで製品や部品を作るところは、 Factory Methodパターンにな ることがあります。

Composite パターン (第11章)

Abstract Factory パターンで作られる製品は、 Compositeパターンになることがあります。

Singleton パターン (第5章)

Abstract Factoryパターンの具体的な工場は、 Singletonパターンになることがあります。

補講 インスタンスの作り方いろいろ

Javaでは、 インスタンスを作るのに以下のような方法があります。

new

インスタンスは通常、 Javaの予約語 newを使って作ります。

次のようにすると、 Something クラスのインスタンスを作り、 変数 obj に代入すること ができます。

Something obj = new Something();

この場合、クラス名 (ここではSomething) をソース中に書いておく必要があります。

clone

Prototype パターン (第6章) で登場したcloneメソッドを使うと、 すでに存在するイン スタンスを元に新しいインスタンスを作ることができます。

次のようにすると、 自分自身 (this) を元に新しいインスタンスを作ることができま す(ただし、 コンストラクタは呼ばれません)。

class Something (

public Something createCopy() ( Something obj = null; try( obj = (Something) clone(); ) catch (CloneNot SupportedException e) { e.printStackTrace();

Java

127

第8章 Abstract Factory関連する部品を組み合わせて製品を作る

return obj;

newInstance

この章に登場したnewInstance メソッドを使うと、 Classのインスタンスを元に、その Class が表しているクラスのインスタンスを作ることができます (List 8-5)。

この章で学んだこと

この章では、抽象的な部品を組み合わせて抽象的な製品を作る抽象的な工場、 Abstract Factoryパターンについて学びました。

私がデザインパターンをはじめて学んだとき、 一番難しいと感じたのはこのAbstract Factoryパターンでした。 複雑で、クラスもたくさん登場するからでしょうか。 たった1つ しかクラスが登場しないSingletonパターンとはずいぶん違いますね。 Singletonパターン が1人芝居だとすれば、 Abstract Factoryパターンは群舞のおもむきがあります。

128

「練習問題

問題 8-1

解答は付録A (p.426)

Trayクラス (List 8-3) では tray フィールドがprotectedとして定義されており、 サ ブクラスから参照できるようになっています。 これを private にした場合の良い点、悪い 点をそれぞれ指摘してください。

●問題8-2

サンプルプログラムのFactoryクラス (List 8-5) に 「Yahoo! (https://www.yahoo.com/) のリンクのみからなるページを作成する具象メソッド」

public Page createYahoo Page ()

を定義してください (ページの作者とタイトルはどちらも "Yahoo!"とします)。このとき、 具体的な工場や具体的な部品の方にはどのような変更が必要になりますか。

Java

問題 8-3

ListLinkクラス (List 8-8)のコンストラクタを見ると、次のようになっています。

public ListLink (String caption, String url) {

super (caption, url);

Java

}

つまり、やっていることはスーパークラスのコンストラクタを呼んでいるだけです。 特 別な処理が不要なら、 どうしてわざわざListLinkのコンストラクタを定義しているので しょうか。

問題8-4

Page クラス (List 8-4) は Trayクラス (List 8-3) と似た働きをしています。 それなの に、なぜPage クラスを Trayクラスのサブクラスにしなかったのでしょうか。

129



第9章 Bridge

機能の階層と 実装の階層を分ける

Bridgeの階層を分ける

Bridge パターン

この章では、

ブリッジ Bridge パターン

について学びます。 bridge というのは 「橋」という意味です。 現実世界の橋が、川のこち ら側とあちら側という2つの場所を結びつける役割を果たしているように、 Bridgeパター ンも2つの場所を結びつける役割を果たしています。

Bridge パターンが橋渡しをしている2つの場所は、

きのう じっそう 「機能のクラス階層」 と 「実装のクラス階層」

です。 「機能のクラス階層」と「実装のクラス階層」 を橋渡しする、 といっても、なかな か頭の中で想像するのは難しいですね。

Bridge パターンのサンプルプログラムを読む前に、

・機能のクラス階層 実装のクラス階層

について、きちんとお話をすることにしましょう。 川の両端の土地について理解しないと、 橋の意義も理解できないですからね。

クラス階層の2つの役割

◆新しい 「機能」 を追加したいときには...

あるクラス Somethingがあったとします。 Something に新しい機能を追加したいと思っ たとき(具体的には新しいメソッドを追加したいと思ったとき)、私たちは Somethingの サブクラス (子クラス、 派生クラス、拡張クラス) として、 SomethingGoodクラスを作り ます。 ここで小さなクラス階層ができました。

Something SomethingGood

これは、機能を追加するために作られた階層です。

スーパークラスは基本的な機能を持っている ・サブクラスで新しい機能を追加する

132

Bridgeパターン 133

このクラス階層を

「機能のクラス階層」

と呼ぶことにします。

さて、SomethingGoodクラスに、 さらに新しい機能を追加するとしましょう。その場合 SomethingGoodクラスのサブクラスとして、 Something Better クラスを作ります。 こ れで、さらに機能のクラス階層が深くなりました。

Something SomethingGood SomethingBetter

新しい機能を追加したいと思ったときに、 クラス階層の中から自分の目的に近いクラス を探し出し、そのサブクラスを作り、 目的の機能を追加した新しいクラスを作る…。 これ が、 機能のクラス階層です。

注意 一般に、クラス階層はあまり深くしすぎない方がよいといわれています。

新しい「実装」 を追加したいときには...

Template Methodパターン (第3章) などで、 私たちは抽象クラスの役割について学び ました。 抽象クラスが一連のメソッド群を抽象メソッドとして宣言し、 インタフェース (API) を規定します。 そしてサブクラスの側で、 その抽象メソッドを実際に実装します。 スーパークラスは抽象メソッドでインタフェース (API) を規定するという役割を持つ。 サブクラスはそれを実装するという役割を持つ。 このようなスーパークラスとサブクラス の役割分担によって、 部品としての価値 (交換可能性) の高いクラスを作ることができま した。

ここにもクラス階層が登場します。 例えば、 スーパークラス AbstractClassの抽象メ ソッドを実装したサブクラスを ConcreteClass とすると、次のような小さなクラス階層 が作られます。

AbstractClass ConcreteClass

でも、ここで使われているクラス階層は、機能を追加するために使われているわけでは ありません。 新しいメソッドを増やすためにクラス階層を作っているのではないのです。 ここでは、次のような役割分担のためにクラス階層が使われています。

・スーパークラスは抽象メソッドによってインタフェース (API) を規定している ・サブクラスは具象メソッドによってそのインタフェース (API)を実装する

第9章 Bridgeの実装の階層を分ける

このクラス階層を、

「実装のクラス階層」

と呼ぶことにします。

さて、AbstractClassの別の実装を作ろうとします。 そのときのサブクラスを Another ConcreteClass とすると、 実装のクラス階層はまた少し変化します。

AbstractClass -ConcreteClass AnotherConcreteClass

新しい実装を作るためには、 AbstractClassのサブクラスを作って、 抽象メソッドを実 装することになります。 これが、 実装のクラス階層です。

クラス階層の混在とクラス階層の分離

機能のクラス階層と、 実装のクラス階層について、おわかりになりましたか。 さて、 私 たちが「よし、サブクラスを作ろう」と思うとき、 自分の意図を次のように確認する必要 があります。 「私は、機能を追加しようとしているのかな? それとも実装を行おうとし ているのかな?」 クラス階層が1つだと、機能のクラス階層と実装のクラス階層とが1つ の階層構造の中に混在することになります。 これは、 クラス階層を複雑にし、見通しを悪 くしてしまう恐れがあります。 自分がサブクラスを作るときに、クラス階層のどこに作っ たらいいか迷ってしまうことになるからです。

そこで、「機能のクラス階層」 と 「実装のクラス階層」 を2つの独立したクラス階層に 分けてしまいましょう。 単に分けただけではばらばらになってしまいますので、その2つ のクラス階層の間に橋渡しをすることが必要です。 この章で紹介する Bridge パターンは、 このような橋渡しを行うデザインパターンなのです。

やれやれ、ずいぶん前置きが長くなってしまいました。 Bridge パターンのサンプルプロ グラムを読んでみましょう。 必ず 「2つのクラス階層」 を意識しながら読んでくださいね。

サンプルプログラム

Bridgeパターンを使ったサンプルプログラムを読んでみましょう。 ここで作るプログラ ムは「何かを表示する」ためのものです。 何だか抽象的な話ですが、 プログラムを読んで いくと、 少しずつ具体的になっていきます。

134

サンプルプログラム

Table 9-1 クラス一覧

橋のどちら側? 機能のクラス階層 機能のクラス階層 実装のクラス階層 実装のクラス階層 名前 Display CountDisplay Display Impl StringDisplay Imp1 Main 解說 「表示する」 クラス 「指定回数だけ表示する」という機能を追加したクラス 「表示する」 クラス 「文字列を使って表示する」 クラス 動作テスト用のクラス

Fig.9-1 サンプルプログラムのクラス図

Display impl open print close display CountDisplay multiDisplay DisplayImpl rawOpen rawPrint rawClose StringDisplayImpl rawOpen rawPrint rawClose

|機能のクラス階層 Displayクラス

Displayクラス (List 9-1) は、 抽象的な 「何かを表示するもの」 です。 このクラスは 「機能のクラス階層」 の最上位にあるクラスです。

imp1 フィールドは、 この Displayクラスの「実装」を表すインスタンスです (implと いうのは implementation (実装) の省略)。 インプリメンテーション

コンストラクタには、実装を表すクラスのインスタンスを渡します。 引数で渡されたイ ンスタンスは、 impl フィールドに保持され、 今後の処理で使われます (このフィールド が2つのクラス階層の 「橋」になります)。

open, print, closeの3つのメソッドは、 このDisplayクラスが提供しているインタ フェース (API) で、 表示を行う手順を表現しています。

135

136 第9章 Bridgeの階層と実装の階層を分ける

. open は表示の前処理 . * print は表示そのもの . close は表示の後処理

という役割を担います。 この3つのメソッドの中身を見てください。 このメソッドを実現 するために、 imp1フィールドの実装のメソッドを用いています。 ここで、 Displayのイ ンタフェース(API) がDisplayImplのインタフェース (API) へ変換されていることに なります。

display, open, print, close Display 0) 137 1-2 (API) を用いて「表示する」という処理を実現しています。

List 9-1 Display 757 (Display.java)

1: public class Display ( private DisplayImpl impl; public Display (Display Impl implthis.impl = impl; 2: 3: 4: 5: 6: ) 7: 8: 9: public void open () { impl.rawOpen(); 10: } 11: 12: public void print() { 13: impl.rawPrint(); 14: 15: 16: public void close() { 17: impl.rawClose(); 18: ) 19: 20: 21: public final void display () () open(); 22: print(); 23: close(): 24: ) 25: 1

) (

サンプルプログラム

機能のクラス階層: CountDisplayクラス

「機能のクラス階層」 の側を見ていきます。

Displayクラスに機能を追加したものがCountDisplayクラス (List 9-2) です。 Display クラスには「表示する」という機能しかありませんでしたが、 CountDisplayクラスでは「指 定回数だけ表示する」という機能を追加してみました。それがmultiDisplayメソッドです。 CountDisplayクラスでは、 open, print, close という Displayクラスから継承して いるメソッドを使って、multiDisplayという新しいメソッドを追加しています。 ここまでが 「機能のクラス階層」 です。

List 9-2 CountDisplay 7 (CountDisplay.java)

1: public class CountDisplay extends Display ( 2: public CountDisplay (Display Impl impl)( 3: super (impl); 4: 5: } public void multi Display (int times) ( open(); for (int i = 0; i < times; i++) { print(); 6: 7: 8: 9: 10: } 11: close(); 12: 13: )

実装のクラス階層 Displaylmplクラス

ここからが 「実装のクラス階層」 です。 Display Implクラス (List 9-3) は、 「実装のクラス階層」 の最上位に位置します。 Display Imp1クラスは抽象クラスで、rawOpen, rawPrint, rawClose という3つのメ ソッドを持っています。 これはDisplayクラスの open, print, close にそれぞれ対応し ていて、 前処理、 表示、 後処理を行うものになっています。

List 9-3 DisplayImpl 2 (DisplayImpl.java)

1: public abstract class DisplayImpl 2: public abstract void rawOpen():

137

第9章 Bridgeの階層と実装の階層を分ける

3: 4: public abstract void rawPrint(); public abstract void rawClose(); 5: )

実装のクラス階層 StringDisplaylmplクラス

それでは、いよいよ本当の「実装」 です。 String DisplayImplクラス (List 9-4) は、 文字列を表示するクラスです。 ただし、ただ表示するのではなく、 Display Imp1クラスの サブクラスとして、rawOpen, rawPrint, rawClose というメソッドを使って表示を行い ます。

List 9-4 StringDisplayImpl 52 (StringDisplayImpl.java)

1: public class String Display Impl extends DisplayImpl{

private String string;

private int width;

2:

3:

4:

public StringDisplayImpl (String string) {

this.string

string;

this.width

string.length();

9:

10:

public void rawOpen () {

11:

12:

5:

6:

7:

@Override

8:

13:

printLine();

)

)

15:

14:

@Override

16:

public void rawPrint () { + + System.out.println("| string *); )

17:

18:

19:

20:

@Override public void rawClose () ( printLine(); }

21:

22:

private void printLine() ( System.out.print ("+");

23:

24:

26:

25:

*ここでは簡単のため、1文字が画面上で1カラムを占めるという前提でコーディングしています。

138

サンプルプログラム 139

27: for (int i = 0; i < width; i++) { 28: 29: } 30: System.out.print("-"); System.out.println("+"); 31: ) 32: )

Display Imp1 と String Display Imp1の2つのクラスが 「実装のクラス階層」に相当し ます。

Main クラス

Mainクラスでは、上記の4つのクラスを組み合わせて文字列の表示を行います。 変数 d1 には Displayクラスのインスタンスを代入し、 変数d2と3には CountDisplayクラス のインスタンスを代入しています。 どちらも、 String Display Implクラスのインスタン スが実装を受け持っています。

実行結果はFig.9-2のようになります。 d1,d2, d3のいずれもDisplayクラスのインスタ ンスの一種ですから、 display メソッドを呼び出すことができます。 d3 では、multiDisplay メソッドも呼び出せます。

List 9-5 Main クラス (Main.java)

1: public class Main ( public static void main(String[] args) ( 2: 3: 4: 5: 6: 7: 8: 9: 10: ) 11: ) Display dl new Display (new StringDisplayImpl("Hello, Japan.")); Display d2 = new Count Display (new StringDisplayImpl("Hello, World.")); CountDisplay d3= new CountDisplay (new StringDisplayImpl("Hello, Universe.")dl.display(); d2.display(); d3.display(); d3.multiDisplay (5);

;

第9章 Bridgeと実装の階層を分ける

Fig.9-2 実行結果 dl.display() が表示 |Hello, Japan. d2.display() が表示 |Hello, World. d3.display () が表示 Hello, Universe.| 3.multiDisplay (5) が表示 Hello, Universe.| Hello, Universe.| Hello, Universe.| Hello, Universe.| Hello, Universe.|

Bridge パターンの登場人物

Bridge パターンの登場人物は、次のとおりです。

アブストラクション Abstraction (抽象化)の役

「機能のクラス階層」 の最上位のクラスです。 Implementor 役のメソッドを使って基本 的な機能だけが記述されているクラスです。 このインスタンスは、 Implementor役を保持 します。 サンプルプログラムでは、 Displayクラスがこの役をつとめました。

リファインド・アブストラクション

RefinedAbstraction (改善した抽象化) の役

Abstraction 役に対して機能を追加した役です。 サンプルプログラムでは、CountDisplay クラスがこの役をつとめました。

インプリメンタ Implementor (実装者)の役

「実装のクラス階層」 の最上位のクラスです。 Abstraction 役のインタフェース (API) を実装するためのメソッドを規定する役です。 サンプルプログラムでは、 Display Implク ラスがこの役をつとめました。

140

あなたの考えを広げるためのヒント 141

コンクリートインプリメンタ Concretelmplementor (具体的な実装者)の役

具体的に Implementor 役のインタフェース (API) を実装する役です。 サンプルプログ ラムでは、StringDisplay Implクラスがこの役をつとめました。

Bridgeパターンをクラス図で表記すると、 Fig.9-3のようになります。 左の2つが機能の クラス階層、右の2つが実装のクラス階層です。 2つの階層をimplフィールドが橋渡しし ているのがわかりますか。

Fig.9-3 Bridgeパターンのクラス図

Abstraction impl methodl method2 method3 RefinedAbstraction refinedMethodA refinedMethodB Implementor implMethodX implMethodY Concrete Implementor implMethodX implMethody

あなたの考えを広げるためのヒント

分けておけば、拡張するのが楽になる

Bridge パターンの特徴は、 「機能のクラス階層」 と 「実装のクラス階層」を分けている 点にあります。 この2つのクラス階層を分けておけば、それぞれのクラス階層を独立に拡 張することができます (具体的な拡張例は練習問題に示します)。

機能を追加したければ、機能のクラス階層にクラスを追加します。 このとき、実装のク ラス階層はまったく修正する必要がありません。 しかも、いま追加した機能は 「すべての 「実装」 で利用できることになります。

例えば、 実装のクラス階層をプログラムの実行環境に当てはめてみます。 あるプログラ ムに、マシンやOSのような実行環境に依存する部分があり、 実行環境に応じてA版、 B

第9章 Bridgeの階層実装の階層を分ける

版、C版にプログラムが分かれるとしましょう。 このとき、 実行環境に依存する部分を Bridge パターンの「実装のクラス階層」 で表現するのです。 つまり、実行環境に共通のイ ンタフェース (API) を決めてImplementor役とし、 Concrete Implementor役としてA版、 B版、C版の3つのクラスを作ります。 こうしておけば、 「機能のクラス階層」 側でいくら 機能を追加しても、3つの実行環境に同時に対応していることになるのです。

継承は固い結びつき、委譲はゆるやかな結びつき

「継承」はクラスを拡張するために便利な方法ですが、 クラス間の結びつきをがっちり 固定してしまいます。 ソースコード上で、

class SomethingGood extends Something (

}

と書いたら、 Something GoodクラスはSomething クラスのサブクラスになります。 そし てこの関係は、ソースコードを書き換えない限り変えることはできません。 ソースコード を書き換えない限り変えられない、というのは非常に固い結びつきですね。 プログラムの 必要に応じてカチカチとクラス間の関係を切り替えたいときには、 継承を使うのは不適切 です。 切り替えるたびにソースコードを変更するなんて、やっていられませんから。 この けいしょう ひじょう ようなときには、 「継承」 ではなく 「委譲」を使います。

サンプルプログラムでは、 Displayクラスの中で委譲が使われています。 Display クラ ス (List 9-1) の implフィールドには、 実装のインスタンスが保持されており、

・open を実行するときには impl.rawOpen() を呼び出す

・print を実行するときには impl.rawPrint () を呼び出す

close を実行するときには imp1. rawClose() を呼び出す

という風に「たらい回し」しています。 「仕事をやれ」 といわれたら、 「implくんにおま かせ」 しているのですね。 これが委譲です。

継承は固い結びつきですが、委譲はゆるやかな結びつきです。 Displayクラスのインス タンスを作る段階で、 引数に渡されてきたものと結びつくのですから。 サンプルプログラ ムでは、Mainクラス (List 9-5) の中でDisplay や CountDisplayのインスタンスを作り、 そのときにStringDisplay Imp1のインスタンスを引数に渡しました。 これは、依存性の 注入 (p.100) の一例になります。

もしも、StringDisplayImplクラス以外のConcreteImplementor役があったとして、そ のインスタンスをDisplay や CountDisplayに渡したなら、それで実装がカチリと切り替 わったことになります。 この切り替えを行うときに修正したのはMainクラスだけです。

142

この章で学んだこと 143

DisplayやDisplay Implなどのソースコードは、まったくいじる必要がありません。 継承は固い結びつきであり、委譲はゆるやかな結びつきです。 複数のクラス設計を行う ときには、このことを理解しておく必要があります。 継承と委譲の関係については、 Adapter パターン (p.28) でも登場しましたので、参考にしてください。

関連しているパターン

Template Method パターン (第3章)

Template Methodパターンでは、 実装のクラス階層を利用します。 スーパークラスでは 抽象メソッドを使ってプログラミングを行い、サブクラスではその抽象メソッドを実装し ます。

Abstract Factory パターン (第8章)

Bridge パターンに登場する ConcreteImplementor 役を環境にあわせて適切に構築するた めに、 Abstract Factory パターンが用いられる場合があります。

Adapter パターン (第2章)

Bridge パターンは、機能のクラス階層と実装のクラス階層をきちんと分離した上で結合 させるパターンです。

Adapter パターンは、機能は似ているがインタフェース (API) は異なるクラス同士を結 合させるパターンです。

この章で学んだこと

この章では、2種類のクラス階層に橋渡しをするBridgeパターンについて学びました。 2種類のクラス階層を分離することで、 クラスの拡張を見通しよく行うことができます。 この章ではまた、クラス同士をゆるやかに結びつける委譲についても学びました。 それでは、以下の練習問題で、この章で学んだことを確認してみましょう。

Bridgeの階との階層を分ける

練習問題

解答は付録A (p.428)

●問題 9-1

本章のサンプルプログラムにクラスを追加して、 「ランダム回数表示する」という処理 を実現してください。 その際に、どのクラスを拡張するかを意識しましょう。

ヒント 表示のメソッドはvoid randomDisplay (int times) とし、 0 以上 times未満だけランダ ムに表示するとします。

●問題 9-2

本章のサンプルプログラムにクラスを追加して、 「テキストファイルの内容を表示する」 という処理を実現してください。 その際に、どのクラスを拡張するかを意識しましょう。

問題 9-3

Fig.9-4 や Fig.9-5のような模様を表示するクラスを本章のサンプルプログラムに追加す るとします。

Fig.9-4 例1 Fig.9-5 模様例2 <>>> <*> <*> <***

これらの模様は、

はじめの文字飾り文字が複数回終わりの文字と改行

を1行として、それが数行繰り返されるものとなっています。 繰り返すごとに、だんだん 飾り文字の個数が増えていきます。

以上のような動きをするクラスをサンプルプログラムに追加するとき、機能のクラス階 層に入れるべきでしょうか、それとも実装のクラス階層に入れるべきでしょうか。

新しい表示の方法を追加するのだから、機能のクラス階層でしょうか。 それとも 文字 を使った表示を追加するのだから、 実装のクラス階層でしょうか。 どうしたらBridge パタ ーンに収まるかを考えてください。

144

第10章 Strategy

アルゴリズムを

ごっそり切り替える

Strategyアルゴリズムをごっそり切り替える

Strategy パターン

この章では、 ストラテジー Strategy パターン

について学びましょう。 strategyというのは、 「戦略」 という意味です。 敵をやっつけると きの作戦、軍隊を動かすときの方策、 それに問題を解いていくときの方法、 そういった意 味合いを持っています。 プログラミングの場合には、「アルゴリズム」 と考えてもいいで しょう。

どんなプログラムも何らかの問題を解くために書かれており、 その問題を解くために特 定のアルゴリズムが実装されています。 Strategyパターンでは、実装したアルゴリズムを ごっそりと交換できるようになっています。 アルゴリズム (戦略作戦・方策) をカチッ と切り替え、 同じ問題を別の方法で解くのを容易にするパターン、 それが Strategy パター ンなのです。

サンプルプログラム

Strategyパターンを使ったサンプルプログラムを読んでみましょう。 ここで作るプログ ラムは、コンピュータで 「じゃんけん」 を行うものです。

じゃんけんの 「戦略」として、2つの方法を考えました。 1つは 「勝ったら次も同じ手 を出す」といういささか愚かな方法 (WinningStrategy)、 もう1つは 「1回前の手から次 の手を確率的に計算する」 という方法 (ProbStrategy) です。

Table 10-1 クラスとインタフェース一覧

名前 Hand Strategy 解說 「じゃんけんの「手」を表すクラス じゃんけんの 「戦略」を表すインタフェース WinningStrategy 勝ったら次も同じ手を出す戦略を表すクラス ProbStrategy Player Main 1回前の手から次の手を確率的に計算する戦略を表すクラス じゃんけんを行うプレイヤーを表すクラス 動作テスト用のクラス

146

サンプルプログラム

Fig.10-1 サンプルプログラムのクラス図

strategy nextHand win lose even Player WinningStrategy nextHand study <<interface>> nextHand study Strategy ProbStrategy nextHand study

Hand 型

Hand (List 10-1) は、 じゃんけんの 「手」 を表す enum型で、 グー チョキ、パーをそ れぞれROCK, SCISSORS, PAPER というenum 定数で表しています。 Java の enum 型は、じ ゃんけんの 「手」 のように列挙された定数 (enumerated constant) を表現する仕組みです。 Hand型はクラスの一種と考え、 enum 定数である ROCK, SCISSORS, PAPER は Handのイ ンスタンスであると考えてかまいません。 そして、 List 10-1でわかるように、 各インスタ ンスはじゃんけんの「手の名前」を表すname フィールドと、 「手の値」 を表すhandvalue フィールドを持っています。

Hand 型の enum 定数は、 ROCK, SCISSORS, PAPERの3つしか作られません。 そしてその インスタンスは配列handsに保持されています。 クラスメソッド getHand を使って、 Hand 型のインスタンスを得ることができます。 手の値 (0,1,2)を引数で与えると、 値に対応 したインスタンスが戻り値となります。 これはSingletonパターン (第5章) の一種です。 またgetHand メソッドは static Factory Method (p.57 参照)といえます。

isStronger Than と isWeaker Than は、 手の強さを比較するメソッドです。 Hand型の hand1 と hand2 という2つの手があるとき、

handl.isStronger Than (hand2)

や、

hand1.isWeaker Than (hand2)

147

148 第20章 Strategyアルゴリズムをごっそり切り替える

のようにして手の強さを比較します。

実際に手の強さを判定しているのは、 fight というメソッドです。 強さの判定では手の 値を使っています。

ここで使われている、

this.handvalue + 1) 8 3 == h.handvalue

という式は少しわかりにくいですね。 この式はthis がんよりも強い手になっているとき (つまり、 this がグーならhはチョキ、 this がチョキならhはバー、 this がパーならhは グーのとき) に true となります。 演算子は余りを得る演算子です。 手の値はゲーは0で、 チョキは1で、パーは2ですから、 1を加えて3で割った余りを求めると、 0は1になり、1 は2になり、2は0になります。

この式で、 this. handvalueとthis を明示したのは、 h.handvalueとの対比がはっきり 見えるようにするためです。 プログラム上は、

(handvalue + 1) 83 == h.handvalue

のように this を省略してもまったく同じ意味になります。

この Hand型は、他のクラス (Player, WinningStrategy, ProbStrategy) から使わ れますが、 Strategyパターンの登場人物には含まれません。

List 10-1 Hand クラス (Hand.java)

1: public enum Hand {

// じゃんけんの手を表す3つの enum定数

2:

ROCK("グー",0),

SCISSORS (チョキ, 1),

3:

PAPER("パー", 2);

4:

5:

6:

// enum が持つフィールド

7:

private String name; // じゃんけんの手の名前

private int handvalue; // じゃんけんの手の値

9:

8:

11:

10:

// 手の値から定数を得るための配列

12:

private static Hand[] hands (

ROCK, SCISSORS, PAPER

13:

14:

15:

);

16:

// コンストラクタ

private Hand (String name, int handvalue) (

17:

18:

this.name=name;

19:

this.handvalue = handvalue;

20:

)

21:

ンプルプログラム

22:

// 手の値から enum定数を得る

24:

public static Hand get Hand (int handvalue) {

return hands [handvalue];

)

25:

26:

27:

public boolean isStrongerThan (Hand h) (

28:

// this がhより強いときtrue

return fight (h) == 1;

30:

29:

32:

// this がんより弱いときtrue

public boolean isWeaker Than (Hand h) (

33:

31:

34:

return fight (h)== -1;

35:

}

36:

// 引き分けは0, this の勝ちなら1, hの勝ちなら-1 private int fight (Hand h) {

37:

if (this ==h) {

return 0;

return 1;

} else {

return -1;

45:

48:

50:

39:

} else if (this.handvalue + 1)#3 == h.bandvalue) (

40:

41:

47:

42:

// じゃんけんの 「手」 の文字列表現 @Override

46:

49:

public String toString() (

51:

return name;

43:

44:

53: )

52:

Strategy インタフェース

Strategyインタフェース (List 10-2) は、じゃんけんの 「戦略」 のための抽象メソッ ドを集めたものです。

nextHand は、 「次に出す手を得る」ためのメソッドです。 このメソッドが呼ばれると、 Strategy インタフェースを実装するクラスは知恵を絞って、「次の一手」 を決めるのです。 study は、 「さっき出した手によって勝ったかどうか」 を学習するためのメソッドです。 直前の nextHandメソッド呼び出しで勝った場合には、 study (true)として呼び出します。

38:

}

23:

)

149

第10章 Strategy アルゴリズムをごっそり切り替える

負けた場合には、 study (false) として呼び出します。 これによって、 Strategy インタフ ェースを実装するクラスは、自分の内部状態を変化させ、次回以降の nextHand メソッド の戻り値を決定する材料とするのです。

List 10-2 Strategy インタフェース (Strategy.java)

1: public interface Strategy { 2: 3: 4: ) public abstract Hand next Hand(); public abstract void study (boolean win);

| WinningStrategy クラス

WinningStrategyクラス (List 10-3) は、 Strategyインタフェースを実装するクラス の1つです。 Strategyインタフェースを実装しているということは、 next Handとstudy という2つのメソッドを実装していることになります。

このクラスは、 前回の勝負に勝ったならば、次も同じ手 (グーならグーパーならバー) を出す、という愚かな戦略をとります。もしも前回の勝負に負けたならば、次の手は乱数 を使って決定します。

random フィールドは、乱数を必要とするときに使うjava.util.Random のインスタン スを保持します。 いわば、 WinningStrategyのインスタンスが使う乱数生成器といえる でしょう。

won フィールドは、前回の勝負の結果を保持します。 勝ったなら true, 負けたなら falseになります。

prevHand フィールドは、前回の勝負で出した手を保持します。

List 10-3 WinningStrategy クラス (WinningStrategy.java)

1: import java.util.Random; 2: 3: public class WinningStrategy implements Strategy ( 4: private Random random; private boolean won = false; private Hand prevHand; 5: 6: 7: 8: public WinningStrategy (int seed) ( 9: random = new Random(seed); 10:

150

サンプルプログラム

11:

13: 14: 15: 16: 17: @Override public Hand nextHand() { if (!won) ( } prevHand= Hand.getHand (random.nextInt(3)); return prevHand; 18: )

12:

19:

20:

@Override

21:

public void study (boolean win) (

22:

23:

won = win;

24: )

}

ProbStrategy クラス

ProbStrategy クラス (List 10-4) は、もう1つの具体的な 「戦略」 です。 こちらはも う少し頭を使っています。 次の手はいつも乱数で決定するのですが、 過去の勝ち負けの履 歴を使って、 それぞれの手を出す確率を変えているのです。 history フィールドが、 過去の勝敗を反映した確率計算のための表になっています。

history は intの2次元配列で、各次元の添え字は次のような意味を持ちます。

history [前回に出した手] [今回出す手]

この式の値が大きければ大きいほど、 過去の勝率が高い、ということになります。もう 少し具体的に書きましょう。

history [0][0] history [0] [1] history [0] [2] グーグーと自分が出したときの過去の勝ち数 グーチョキと自分が出したときの過去の勝ち数 グーパーと自分が出したときの過去の勝ち数

前回、自分がグーを出したとします。 そのとき、次に自分が何を出すかを、 上記の history[0][0], history [0] [1], history [0] [2] の値から確率で計算しようというわ けです。要するに、この3つの式の値を足し (getSum メソッド) 0からその数までの乱 数を計算し、そしてそれを元に次の手を決めるのです (next Hand メソッド)。 例えば、

history [0][0] の値が3

history [0] [1]の値が5

151

10 Strategy 74

history [0] [2] 07

だとします。 このとき、 グー チョキ、パーを出す割合を3:57として次の手を決めま す。 0以上15未満 (15は3+5+7の値) の乱数値を得て

0以上3未満ならグー 3以上8 (=3+5) 未満ならチョキ 8以上15 (=3+5+7) 未満ならバー

とします。

studyメソッドは、 nextHandメソッドで返した手の勝敗を元に、 history フィールドの 内容を更新します。

注意 この戦略では、対戦相手のじゃんけんの手の出し方に一種のパターンがあることが大前提 となっています。

List 10-4 ProbStrategy 757 (ProbStrategy.java)

1: import java.util.Random;

2:

3: public class ProbStrategy implements Strategy (

private Random random;

4:

private int prevHandValue = 0;

5:

private int current HandValue = 0;

private int [][] history = (

7:

(1, 1, 1, ),

6:

8:

9:

10:

(1, 1, 1, ),

(1, 1, 1, ),

11:

12:

public ProbStrategy (int seed) (

13:

random new Random (seed);

14:

15:

};

16:

17:

18:

20:

21:

23:

@Override public Hand nextHand() { int bet random.nextInt (get Sum (current HandValue)); int handvalue = 0; if (bet history[current HandValue][0]) { handvalue = 0; } else if (bet < history [current HandValue] [0] history (current HandValue] [11] handvalue = 1; } else { handvalue = 2;

24:

22:

19:

25:

26:

)

152

サンプルプログラム

27:

})

prevHandValue = current HandValue;

current HandValue = handvalue;

28:

29:

30:

return Hand.getHand (handvalue);

31:

32:

private int getSum (int handvalue)( int sum = 0; for (int i = 0; i < 3; i++) ( } sum += history [handvalue] [i]; return sum; }

33:

34:

勝ったり (win)、負けたり (10se) 引き分けたり (even) した勝負の結果を次回の勝 負に生かすために、 Playerクラスは、 strategy フィールドを通して study メソッドを呼 び出します。 studyメソッドを使って戦略の内部状態を変化させるのです。 wincount, losecount, gamecount は、プレイヤーの勝ち数を記録するものです。

39:

40:

35:

37:

38:

41: 42: 43: 44: 45: 46: 47: 48: 49: 50: ) @Override public void study (boolean win) { if (win){ history (prev HandValue] [currentHandValue]++; ) else ( history (prev HandValue] [(current HandValue + 1) & 3]++; history (prevHandValue][currentHandValue + 2) 83]++;

Playerクラス

Player クラス (List 10-5) は、じゃんけんを行う人を表現したクラスです。 Player クラスは、 「名前」 と 「戦略」 を与えられてインスタンスを作ります。 nextHand メソッドは次の手を得るためのものですが、 実際に次の手を決定するのは自 分の 「戦略」 です。 戦略の nextHandメソッドの戻り値が、 そのままPlayer の nextHand メソッドの戻り値となります。 nextHand メソッドは、 自分の行うべき処理をStrategy に 委ねている、 すなわち 「委譲」していることになります。

153

36:

10 Strategy-7

List 10-5 Player (Player.java)

1: public class Player (

2:

3:

private Strategy strategy:

4:

private int wincount;

5:

private String name;

private int losecount;

private int ganecount:

6:

7:

8:

//名前と戦略を授けてプレイヤーを作る

9:

public Player (String name, Strategy strategy) { this.name = name;

10:

11:

this.strategy strategy;

12:

13:

14:

// 戦略におうかがいを立てて次の手を決める

15:

public Hand nextHand() {

16:

17:

return strategy.nextHand();

18: 19: // 勝った 20: 21: 22: public void win () { strategy.study (true); wincount++; 23: gamecount++; 24: }

25:

// 負けた

26:

27:

28:

public void lose() (

strategy.study (false);

29:

losecount++;

gamecount++;

30:

31:

32:

34:

)

// 引き分け

33:

public void even () {

35:

gamecount++;

36:

37:

}

38:

@Override

39:

return *[*

40:

public String toString() {

+name+:

41:

42:

+ gamecount +

games,

wincount

win,

43:

losecount

lose

+ **;

44:

.

45:

46: 47: )

}

154

サンプル サンブルプログラム 155

| Mainクラス

Main クラス (List 10-6) は、 以上のクラスを利用して、 実際にコンピュータでじゃん けんを行うためのクラスです。 ここでは、次の2人のプレイヤーを対戦させています。

"Taro",

WinningStrategy

"Hana",

ProbStrategy

10000回対戦させて、その結果を表示させます。 コマンドラインで2つの整数を与えて、 乱数を生成する種にしています。

なお、

"Winner: player1

の部分は、 "Winner: player1.toString()

と同じ意味です。

List 10-6 Main 57 (Main.java)

1: public class Main (

public static void main(String[] args) {

if (args.length != 2) (

System.out.println("Usage: java Main randomseed1 randomseed2"); System.out.println("Example: java Main 314 15");

2:

3:

4:

5:

6:

System.exit(0);

7:

int seed1

8:

9:

int seed2

Integer.parseInt(args[0]); Integer.parseInt(args[1]);

seed1)); ));

10:

12:

15:

Player player1 = new Player ("Taro", new Winning Strategy (Player player2 = new Player ("Hana", new ProbStrategy (seed2for (int i = 0; i < 10000; i++) { Hand nextHandl player1.nextHand(); Hand nextHand2 = player2.nextHand(); if (nextHandl.isStrongerThan (nextHand2)) ( System.out.println("Winner:" + player1); player1.win(); player2.lose(); } else if (nextHand2.isStronger Than (next Handl)) { System.out.println("Winner:" + player2); player1.lose(); player2.win(); } else {

16:

17: ་

14:

་ྲགབསླུ 22:

20: 8

11:

13:

18:

19:

21:

23:

)

第10章 Strategy アルゴリズムをごっそり切り替える

24:

System.out.println("Even...");

player1.even();

player2.even();

25:

26:

27:

28:

29: 30:

System.out.println("Total result: ");

System.out.println(playerl);

31:

32:

System.out.println(player2);

33: 1

Fig.10-2 実行結果例 (引数の314と15は乱数の種となる整数)

java Main 314 15 Even...

Winner: [Hana:1 games, 0 win, 0 lose] Winner: [Taro:2 games, 0 win, 1 lose] Even...

Winner: [Hana:4 games, 1 win, 1 lose] Winner: [Taro:5 games, 1 win, 2 lose] Even... Even...

Winner: [Taro:8 games, 2 win, 2 lose] Winner: [Taro:9 games, 3 win, 2 lose] Winner: [Taro:10 games, 4 win, 2 lose] Even...

(中略)

Even...

Winner: [Hana: 9993 games,

3488 win,

Winner: [Taro: 9994 games,

Winner: [Taro:9995 games,

3165 win,

3166 win,

Winner: [Hana: 9996 games, 3489 win, 3167 lose]

Even...

Even...

Even...

Total result:

[Hana: 10000 games, 3490 win, 3167 lose)

-31844

←Hanaが勝った

Taroが勝った

引き分け

Hanaが勝った

Winner: [Taro:9992 games, 3164 win, 3488 lose]

←Taroが勝った

-31844

-31844

Taroが勝った ←Taro が勝った

←Taroが勝った

←引き分け

3165 lose]

-3184747

3489 lose]

←Taroが勝った

3489 lose]

Hana #t Tarot:

Tarot

←Hana が勝った

(Taro:10000 games, 3167 win, 3490 lose]

←引き分け

-3184747

引き分け

Taro は3167勝 3490敗

Hana # 34903167

156

Strategyパターンの登場人物

Strategy パターンの登場人物

Strategyパターンの登場人物は、次のとおりです。

ストラテジー Strategy (戦略)の役

戦略を利用するためのインタフェース (API) を定める役です。 サンプルプログラムで は、 Strategy インタフェースがこの役をつとめました。

コンクリート・ストラテジー Concrete Strategy (具体的戦略)の役

Strategy 役のインタフェース (API) を実際に実装する役です。 ここで具体的な戦略 (作戦方策方法・アルゴリズム) を実際にプログラミングします。 サンプルプログラ ムでは、WinningStrategyクラスと ProbStrategyクラスがこの役をつとめました。

コンテキスト

・Context (文脈) の役

Strategy 役を利用する役です。 Concrete Strategy 役のインスタンスを持っていて、必要 に応じてそれを利用します (あくまで呼び出すのはStrategy役のインタフェース (API) です)。 サンプルプログラムでは、 Playerクラスがこの役をつとめました。

Fig.10-3 Strategy パターンのクラス図

strategy Context contextMethod Strategy strategyMethod ConcreteStrategyl strategyMethod ConcreteStrategy2 strategyMethod

157

第10章 Strategy アルゴリズムをごっそり切り替える

あなたの考えを広げるためのヒント

わざわざStrategy 役を作る必要ってあるの?

普通にプログラミングをしていると、 メソッドの中に溶け込んだ形でアルゴリズムを実 装してしまいがちです。 しかし、 Strategyパターンでは、アルゴリズムの部分を他の部分 と意識的に分離します。 そしてアルゴリズムとのインタフェース (API) の部分だけを規 定します。 そして、 プログラムから委譲によってアルゴリズムを利用するのです。

これはプログラムを複雑にしているように見えますが、 そうではありません。 例えば、 アルゴリズムを改良してもっと高速にしたいとしましょう。 Strategyパターンを使っていれ ば、 Strategy 役のインタフェース (API) を変更しないように注意して、 ConcreteStrategy 役 だけをいじればいいのです。 しかも、委譲というゆるやかな結びつきを使っていますから、 アルゴリズムを容易に切り替えることができます。 例えば、 元のアルゴリズムと改良した アルゴリズムの速度を比較したい場合でも、簡単に切り替えて試すことができるでしょう。 ユーザとの対戦を行うゲームプログラムでStrategyパターンを使えば、ユーザの選択に

あわせて思考ルーチンのレベルを切り替えることも簡単にできるでしょう。

実行中に切り替えることも可能

Strategyパターンを使えば、プログラムの動作中にConcrete Strategy 役を切り替えるこ とができるかもしれません。 例えば、 メモリが少ない環境ではSlowBut LessMemoryStrategy (スピードは遅いが省メモリの戦略) を使い、 メモリが多い環境ではFastBut MoreMemory Strategy (スピードは速いがメモリを食う戦略) を使うといったことも考えられます。

片方のアルゴリズムを他方のアルゴリズムの「検算」に使うこともできますね。 例えば、 表計算ソフトのデバッグ版で、複雑な計算を行うとします。 そのとき、 「バグがあるかも しれない高速なアルゴリズム」 と 「低速だが確実な計算を行うアルゴリズム」 を用意して おき、前者の検算を後者に行わせるのです。

| さまざまな乱数生成器

本書のサンプルプログラムでは、Javaでごく一般的に用いられる java.util. Random ク ラスを用いて乱数を生成しています。 しかし、用途によっては別のクラスを使うべき場合 があります。 Javaのライブラリでよく用いられる乱数生成器を紹介します。 詳細はJavaの APIリファレンスを参照してください。

Java

158

関連しているパターン

• java.util.Randomは、 ごく一般的に用いられる乱数生成器で、 線型合同法を用いて います。 スレッドセーフですが、 ThreadLocalRandomの方が高パフォーマンスに なります。 セキュリティ用途に使ってはいけません。

・java.util.concurrent.ThreadLocalRandomは、マルチスレッド環境でも高パフォー マンスで、他のスレッドの影響を受けない乱数生成器です。 セキュリティ用途に使 ってはいけません。

java.security.SecureRandomは、暗号学的に強い乱数生成器で、 セキュリティ用 途で使われます。 スレッドセーフです。

関連しているパターン

Flyweight パターン (第20章)

ConcreteStrategy 役は、 Flyweightパターンを使って複数箇所から共有できる場合があり ます。

Abstract Factory パターン (第8章)

Strategyパターンでは、アルゴリズムをごっそり切り替えることができます。 Abstract Factoryパターンでは、具体的な工場・部品 製品をごっそり切り替えること ができます。

State パターン (第19章)

Strategy パターンもStateパターンも、ともに委譲先を切り替えるパターンであり、クラ ス間の関係もよく似ています。 しかし、 両方のパターンは目的が異なっています。

Strategy パターンは、「アルゴリズム」を表現するクラスを作成し、 それを Concrete Strategy 役とします。 Strategyパターンではクラスを切り替えることは可能ですが、 必要 がなければ切り替えなくてもかまいません。

方、 Stateパターンでは、「状態」 を表現するクラスを作成し、 それを Concrete State 役とします。 Stateパターンでは状態が変化するたびに委譲先のクラスが必ず切り替 わります。

159

160 mi Seringy-アルゴリズムをごっそり切り替える

この章で学んだこと

この章では、アルゴリズムを容易に切り替えることのできるStrategyパターンを学びま した委譲のおかげで、アルゴリズムの切り替え、 特に動的な切り替えが可能になってい ます。

練習問題

問題 10-1

問題 10-2

解答は付録A (p.435)

でたらめに次の手を出す RandomStrategyクラスを作ってください。

本章のサンプルプログラム中、 Handクラス (List 10-1) のfightメソッド分けの判定をするのに、

Java

this.handvalue ==h.handvalue

という式ではなく、

this == h

という式を使っています (39行目)。 なぜ、これでうまくいくのでしょうか。

●問題 10-3

ある人がWinningStrategy クラス (List 10-3) をプログラミングするときに、 won フィー ルドを、

private boolean won = false;

Java

ではなく、

では、引き

private boolean won;

と書いてしまいました。 しかし、= false をつけたときとまったく同じ動作をしました。 なぜですか。

練習問題 161

●問題10-4

java.util.Listインタフェースのsort(c) メソッドは「Listの要素を比較器cを使っ てソートする (並べ替える) メソッド」 です。 ここで与える比較器cは、 Listが持つ要素 の「順序関係」 を定めるためのインスタンスですので、与える比較器を変えるとソートの 結果が変化します。

例えば、

"D", "B", "C", "E", "A"

という5個の String を要素に持つList<String> のインスタンスを 「辞書式順序で小さい 順」の比較器を使ってソートすれば、

"A", "B", "C", "D", "E"

になりますが 「辞書式順序で大きい順」 の比較器でソートすれば、

"E", "D", "C", "B", "A"

になります。 つまり、 sort(c)の引数で与える比較器cは、やや大げさにいえば順序関係 を決定する 「戦略」 を表現しているといえます。

List 10-7は辞書式順序で 「小さい順」 と 「大きい順」 でList<String> をソートして表 示するプログラムですが、 /* 未実装 */ と書かれた部分が未完成です。 JavaのAPIリファ レンスを調べてこのプログラムを完成させてください。

ヒント: 比較器を表す java.util.Comparatorインタフェースのcompare メソッドと、 java.lang.String クラスのcompareToメソッドを調べます。

「辞書式順序」 は Stringの長さと、含まれる文字のUnicodeの値で決まります。 詳 細は java.lang.StringクラスのcompareTo メソッドのAPIリファレンスを参照して ください。

List 10-7 List<String> をソートして表示するプログラム (Main.java)

1: import java.util.*; 2: 3: class Main ( 4: 5: 6: 7: 8: 9: 10: public static void main(String[] args) List<String> list = Arrays.asList("D", "B", "C", "E", "A"); // 辞書式で小さい順 list.sort * 未実装 */ ); System.out.println(list);

Java

第10章 Strategy アルゴリズムをごっそり切り替える

11:

// 辞書式順序で大きい順

12:

13:

14:

list.sort(* 未実装):

15: )

System.out.println(list);

Fig.10-4 実行結果

[A, B, C, D, E]

辞書式順序で小さい順

[E, D, C, B, Al

←辞書式順序で大きい順

162

第11章 Composite

容器と中身の同一視

164 第11章 Composite 容器と中身の一

Composite パターン

コンピュータのファイルシステムには、「ディレクトリ」というものがあります (OSに よってはフォルダと呼ばれる場合もあります)。 ディレクトリの中にはファイルが入ってい たり、別のディレクトリ (サブディレクトリ)が入っていたりします。 そしてまた、その サブディレクトリの中に他のファイルやサブディレクトリが入っていることもあります。 ディレクトリはそのような「入れ子」 になった構造、 再帰的な構造を作り出しています。

さて、ディレクトリとファイルは異なるものですが、このどちらも 「ディレクトリの中 に入れることができるもの」 ですね。 ディレクトリとファイルをまとめて 「ディレクトリ 「エントリ」と呼ぶこともあります。 ディレクトリエントリという名前によって、 ディレク トリとファイルを同じ種類のものであると見なしている (同一視している) のです。

例えば、あるディレクトリの中に何があるかを順に調べていくとしましょう。 そこで順 に見ていくものは、サブディレクトリかもしれませんし、 ファイルかもしれません。 一言 でいえば、「ディレクトリエントリというもの」を順に見ているのです。

ディレクトリとファイルをまとめてディレクトリエントリとして扱うように、 容器と中 身を同じ種類のものとして扱うと便利な場合があります。 容器の中には、 中身を入れても いいですし、さらに小さな容器を入れることもできます。そして、その小さな容器の中に もっと小さな容器を入れて･･･こんな風にして、 入れ子になった構造、 再帰的な構造を作る ことができます。

この章で学ぶ

コンポジット Composite パターン

は、このような構造を作るためのものです。 容器と中身を同一視し、 再帰的な構造を作る デザインパターン、 それがCompositeパターンなのです。 composite は英語で 「混合物」 「複合物」 という意味です。

サンプルプログラム

Composite パターンのサンプルプログラムとして、ファイルとディレクトリを模式的に 表現したプログラムを作ってみましょう。 ファイルを表すクラスがFile クラス、 ディレ クトリを表すクラスがDirectoryクラスで、その両者をとりまとめる形で、スーパークラ スのEntryクラスがあります。 Entry クラスはディレクトリエントリを表すクラスで、 File と Directoryを同一視するクラスです。

サンプルプログラム 165

Table 11-1 クラス一覧

Entry File Directory Main 名前 解說 File と Directory を同一視する抽象クラス ファイルを表すクラス ディレクトリを表すクラス 動作テスト用のクラス

Fig.11-1 サンプルプログラムのクラス図

Entry

getName

getSize

printList

File

name directory

Directory

name

size

getName getSize

getName getSize

printList

printList

add

Entry クラス

Entry クラス (List 11-1) は抽象クラスで、 ディレクトリエントリを表現するものです。 このサブクラスとして、 FileクラスとDirectoryクラスが作られます。 ディレクトリエントリは名前を持っています。 名前を得るためのメソッドとして

章 Composite 容器と中身の同一視

第11

getName を用意します。 その実装はサブクラスにまかせます (subclass responsibility)。 また、ディレクトリエントリはサイズを持っているものとします。 そして、 サイズを得 るためのgetSizeメソッドを用意します。 これも実装はサブクラスにまかせます。

printListメソッドは、 「一覧」 を表示するメソッドです。 引数なしのprintList()と、 引数ありのprintList (String)の2つのメソッドがあります。 これをprintListメソッドの オーバーロード (多重定義) といいます。 呼び出すときの引数の型に応じて、 オーバーロー ドされたものの中から適切なメソッドが選択実行されます。 ここでは、 printList() は public として公開され、 printList (String) はprotectedとしてEntryのサブクラスで のみ使われるようになっています。

toStringメソッドは、インスタンスの標準的な文字列表現を定義します。 ここではファ イル名とサイズを並べて表現しています。 getName や get sizeは抽象メソッドですが、サ ブクラスがこれらのメソッドを実装することを期待して toString から呼び出しています Template Method パターン)。

List 11-1 Entry クラス (Entry.java)

1: public abstract class Entry { // 名前を得る 2: 3: 4: 5: 6: public abstract String getName(); // サイズを得る public abstract int getSize();

7:

// 一覧を表示する

8:

9:

public void printList() {

10:

printList("");

11:

12:

// prefixを前につけて一覧を表示する

protected abstract void printList (String prefix);

13:

14:

15:

16: 17: 18: 19: 20: 21: ) // 文字列表現 @Override public String toString() ( return getName() + " getSize() * *)*

166

サンプルプログラム

Fileクラス

File クラス (List 11-2) は、 ファイルを表現するクラスです。 Entryクラスのサブク ラスとして宣言しています。

フィールドは2つあります。 ファイルの名前を表現するname と、 大きさを表す size です。 コンストラクタでは、名前とサイズを与えてFileのインスタンスを作ります。 例えば、

new File("readme.txt", 1000)

のようにすると、 readme.txtという名前でサイズが1000のファイルができたことになりま す。もちろん、これは仮想的に作られたファイルであって、 実際のファイルシステム上に ファイルが作られるわけではありません。

getName メソッドとgetSizeメソッドは、それぞれファイルの名前とサイズを返すメソッ ドです。

スーパークラスから作りなさいと押しつけられていたprintList (String) は、ここで 実装しています。 printList (String) は、 prefixと自分の文字列表現を"/"で区切って 表示しています。 ここで、 "/" + this という演算をしていますが、 このように文字列と オブジェクトを加えると、自動的にそのオブジェクトのtoStringメソッドが呼び出され ます。これはJava言語の仕様です。 つまり、以下の式はすべて同じです。

prefix + "/" + this prefix + "/" + this.toString() prefix + "/" + toString()

スーパークラスの Entryクラスでabstractになっていたメソッドはすべてここで実装 されていますので、 File クラスは抽象クラスではありません。

List 11-2 File クラス (File.java)

1: public class File extends Entry ( 2: private String name; 3: private int size; 4: 5: 6: 7: public File (String name, int size)( this.name = name: this.size size; 8: 9: 10: 11: 12: @Override public String getName() { return name;

167

第11章 Composite 容器と中身の同一視

13:

14:

})

@Override public int getSize() { return size: }

16:

17:

15:

18:

19:

20: @Override 21: protected void printList (String prefix) ( 22: 23: 24: ) } System.out.println(prefix + "/" + this);

| Directoryクラス

Directoryクラス (List 11-3) は、 ディレクトリを表現するクラスです。これも Entry クラスのサブクラスとして定義されています。

フィールドは2つあります。 1つ目のフィールドnameはディレクトリの名前を表すもの で、 File クラスと同じです。 しかし、 Directoryにはサイズを表すフィールドはありま せん。それは、ディレクトリのサイズを動的に計算して求めているからです。

もう1つのフィールド directoryは、 ディレクトリエントリを保持しておくためのフィ ールドです。 directory フィールドは、

private List<Entry> directory = new ArrayList<>();

と初期化されています。 directory フィールドはList<Entry> という型で宣言されており、 実際は ArrayList<Entry> のインスタンスが与えられています。 右辺では型パラメータの 部分が <Entry> ではなく ◇となっていますが、 Java コンパイラがArrayList<Entry> であ ると正しく推論してくれるので問題ありません。 <>はその形状から、 ダイアモンド演算 子と呼ばれています。

getName メソッドはname フィールドを返すだけですが、 getSize メソッドは計算を行い ます。 directory の要素を1つ1つ取り出して、そのサイズを合計したものが戻り値とな ります。 この中で使われている次の文に注意してください。

size = entry.getSize();

変数 size に entry のサイズを加えているのですが、この entry は Fileのインスタンス かもしれませんし、Directoryのインスタンスかもしれません。 どちらの場合でも、同じ メソッド getSize でサイズを得ることができています。 これが Composite パターンの特徴、

168

サンプルプログラム

「容器と中身を同じものと見なす」ことの現れです。 Fileのインスタンスであっても Directoryのインスタンスであっても、 entry はとにかくEntryのサブクラスのインスタ ンスなのですから、 getSize を安心して呼ぶことができます。 Entryのサブクラスとして 別のクラスが将来作られたとしても、それもgetSizeメソッドを実装していますから、 Directoryクラスのこの部分を修正する必要はないのです。

entry が Directoryのインスタンスの場合、 entry.getSize() という式を評価すると、 ディレクトリの中のエントリのサイズを1個1個加えます。 また、 その中にディレクトリ があったら、さらにサブディレクトリのgetSize を呼び出し･･･と、 再帰的にメソッド getSize が呼び出されることになります。 Composite パターンの再帰的構造が、 そのまま 再帰的呼び出しに対応していることがわかると思います。

getSize というメソッドの

addメソッドは、ディレクトリの中にファイルやディレクトリを追加するためのもので す。 引数として与えられたentry は、 それが実際は Directoryクラスのインスタンスなの かFileクラスのインスタンスなのかを調べることなく、

directory.add (entry);

としてフィールド directoryに追加されます。 まさに、ファイルとディレクトリを同一視 した「ディレクトリエントリ」として追加しているわけです。

printListメソッドはディレクトリの一覧を表示するものです。 printListメソッドも、 getSizeメソッドと同じようにprintList を再帰的に呼び出しています。 その際に、変数 entryがFileのインスタンスなのか、 Directoryのインスタンスなのかを調べないという のもgetSize メソッドのときと同様です。 容器と中身とを同一視しているからです。

List 11-3 Directory 5 (Directory.java)

1: import java.util.ArrayList; 2: import java.util.List; 3: 4: public class Directory extends Entry ( private String name; private List<Entry> directory = new ArrayList<>(); 5: 6: 7: 8: public Directory (String name) ( 9: this.name = name; 10: 11; 12: 13: 14: @Override public String getName() ( return name; 15: ) 16:

169

170 110 Composite-02-R

17:

@Override

public int getSize() {

int size = 0;

for (Entry entry: directory) (

21:

18:

19:

20:

size += entry.getSize();

22:

23:

return size;

24: } 25: 26: 27: 28: 29: 30: 31: } 32: 33: 34: 35: 36: 37: 38: @Override protected void print List (String prefix) { System.out.println(prefix for (Entry entry: directory) ( this); entry.printList (prefix +/+name); 39: ) // ディレクトリエントリをディレクトリに追加する public Entry add (Entry entry) ( directory.add(entry); return this;

| Mainクラス

Main クラス (List 11-4) では、次のようなディレクトリ階層を作ります。 まずはじめ に root, bin, tmp, usr というディレクトリを作り、 binの下にviというファイルとlatexと いうファイルを入れます。

root

bin

vi

latex

tmp

-usr

それから、 usr ディレクトリの下にyuki, hanako, tomuraというディレクトリを作り、各 人のファイルをその下に作ります。

}

サンプルプログラム 171

root

bin

latex

tmp usr

vi

yuki

diary.html

Composite.java

hanako

memo.tex

tomura

game.doc

-junk.mail

実行結果は Fig.11−2のようになります。 各人のファイルを作った後、 rootディレクトリ のサイズがきちんと大きくなっていることに注目してください。

List 11-4 Main (Main.java)

2: 3: 4: 5: 6: 7: 8: 9: 1: public class Main ( public static void main(String[] args) ( System.out.println("Making root entries..."); Directory rootdir = new Directory("root"); Directory bindir = new Directory("bin"); Directory tmpdir = new Directory("tmp"); Directory usrdir = new Directory("usr"); rootdir.add(bindir); rootdir.add(tmpdir); 10: rootdir.add(usrdir); 11: 12: 13: 14: 15: 16: 17: 18: bindir.add(new File("vi", 10000)); bindir.add(new File("latex", 20000)); rootdir.printList(); System.out.println(); System.out.println("Making user entries..."); Directory yuki = new Directory("yuki"); Directory hanako = new Directory("hanako"); 19: Directory tomura new Directory ("tomura"); 20: usrdir.add(yuki); 21: usrdir.add(hanako);

172 11 Composite 40-R

22:

usrdir.add(tomura);

yuki.add(new File("diary.html", 100)); yuki.add(new File("Composite.java", 200)); hanako.add(new File("memo.tex", 300));

23:

25:

26:

27:

24:

tomura.add(new File("game.doc", 400)); tomura.add(new File("junk.mail, 500)); rootdir.printList();

28:

29:

30: )

}

Fig.11-2 実行結果

Making root entries...

/root (30000)

/root/bin (30000)

/root/bin/vi (10000)

/root/bin/latex (20000)

/root/tmp (0)

/root/usr (0)

Making user entries....

/root (31500)

/root/bin (30000)

/root/bin/vi (10000)

/root/bin/latex (20000)

/root/tmp (0)

/root/usr (1500)

/root/usr/yuki (300)

/root/usr/yuki/diary.html (100)

/root/usr/yuki/Composite.java (200)

/root/usr/hanako (300)

/root/usr/hanako/memo.tex (300)

/root/usr/tomura (900)

/root/usr/tomura/game.doc (400)

/root/usr/tomura/junk.mail (500)

あなたの考えを広げるためのヒント

Composite パターンの登場人物

Composite パターンの登場人物は、次のとおりです。

リーフ Leaf (葉) の役

「中身」 を表す役です。 この役の中には、他のものを入れることはできません。 サンプ ルプログラムでは、 File クラスがこの役をつとめました。

コンポジット Composite (複合体) の役

「容器」 を表す役です。 Leaf役や Composite 役を入れることができます。 サンプルプロ グラムでは、 Directoryクラスがこの役をつとめました。

コンポーネント Component の役

Leaf 役と Composite役を同一視するための役です。 Component役は、 Leaf 役と Composite 役に共通のスーパークラスとして実現します。 サンプルプログラムでは、 Entry クラスが この役をつとめました。

クライアント Client (依頼者) の役

Composite パターンの利用者です。 サンプルプログラムでは、 Main クラスがこの役をつ とめました。

Compositeパターンをクラス図で表記すると、 Fig.11-3のようになります。 この図では、 Composite 役が含んでいる Component役 (つまり、 Leaf役か Composite役) を親に対する 「子ども」に見立てています。 getChild メソッドは Component役から「子ども」 を得る メソッドです。

あなたの考えを広げるためのヒント

| 複数と単数の同一視

Composite パターンは容器と中身の同一視を行うパターンですが、これを複数と単数の 同一視と呼ぶこともできます。 すなわち、 複数個のものを集めて、 それをあたかも1つの ものであるかのように取り扱うのです。

173

第11章 Composite 容器と中身の同一視

Fig.11-3 Composite パターンのクラス図

Uses ▸ Client methodi method2 Component Composite method1 method2 Leaf children methodl method2 add remove getChild

例えば、プログラムの動作テストをまとめるときにCompositeパターンが使えます。 KeyboardTestではキーボードからの入力テストを行い、 FileTestではファイルからの入力 テストを行い、 NetworkTestではネットワークからの入力テストを行って、 Keyboard Test, FileTest, NetworkTestの3つをまとめて扱いたいとしましょう。 そんなときにComposite パターンを使い、複数のテストをまとめてInputTest という 「入力テスト」にするのです。 また同様に、複数の出力テストをまとめた OutputTest も作れそうです。 さらには InputTest OutputTestを合わせてInputOutputTest という 「入出力テスト」さえも作れる でしょう。

また例えば、たくさんの図形を描画したり変形したりするグラフィックツールを作ると しましょう。三角形や円などの図形を複数個まとめて「グループ」 を作る機能にも Composite パターンが使えます。 複数の図形をまとめたグループも、個々の図形と同様に 編集したいからです。 複数のグループをまとめて、さらに大きなグループを作ることもで きるでしょう。

174

関連しているパターン

addはどこに置くべきか

サンプルプログラムでは、 ディレクトリエントリを追加するaddメソッドをDirectory クラスで定義しました (List 11-3)。 ディレクトリエントリを追加できるのはディレクト リだけですから、 これは妥当な判断でしょう。 Fig.11-3でも、 add, remove, getChild などの「子供」 を操作するメソッドはComposite役で定義しています。

GoF本 (付録D [GoF] 参照) では 「子供」 を操作するメソッドもComponent役で定義 しています。 その場合、もしもLeaf役に対して 「子供」 を操作する要求が発生したら、 何 らかのエラー処理が必要になります。

「子供」 を操作するメソッドはComposite 役と Component役のどちらで定義すればいい のでしょうか。 結局のところそれは 「容器と中身を同一視した結果として得られるものは 「何なのか」 に答えることです。 サンプルプログラムでいうならば 「Entryクラスとは何な のか」 に答えることです。

設計者は、そのクラスが持つべきメソッドを定めます。 それは 「そのクラスは何なのか」 に答えることであり、 そのクラスが持つべき責務を明確にすることにほかならないのです。

再帰的構造はあらゆる場面で登場する

サンプルプログラムでは、 ディレクトリエントリを例にお話しましたが、 プログラミン グをしていると、 再帰的な構造および Compositeパターンはさまざまな場面で登場します。 例えば、ウインドウシステムではウインドウの中に子ウインドウを持たせますが、それは Composite パターンの典型です。 文章の箇条書きの各項目の中にさらに箇条書きが含まれ るのも、 再帰的な構造といえるでしょう。 コンピュータに対するコマンド (命令) をまと めたマクロコマンドを作るとき、そのマクロコマンドを再帰的な構造として実現すると、 マクロコマンドのマクロコマンドを作ることもできます。 一般に、 木構造になるデータ構 造はComposite パターンに当てはまります。

関連しているパターン

Command パターン (第22章)

Commandパターンで 「マクロコマンド」 を作るときに、 Composite パターンが使われ ます。

175

第11章 Composite 容器と中身の一

Visitor パターン (第13章) Visitorパターンは、 Compositeを巡りながら処理をするのに使います。

・Decorator パターン (第12章) Composite パターンは、容器 (Composite役) と中身 (Leaf役) を Component役として 同一視します。 Decoratorパターンは、 飾り枠と中身を同一視します。

この章で学んだこと

この章では、容器と中身を同一視し、 再帰的な構造を形作るCompositeパターンについ て学びました。

練習問題

解答は付録A (p.439)

●問題 11-1

ファイルシステム以外に、 Composite パターンが当てはまるような例を考えてください。

●問題 11-2

サンプルプログラムに、 Entryの (サブクラスの) インスタンスから、「フルパス」を 得る機能を追加しようと思います。 例えば、 Fileのインスタンスから、

* /root/usr/yuki/Composite.java"

という文字列を得たいとします。 そのとき、サンプルプログラムのどのクラスを、どのよ うに変更したらよいでしょう。

176

第12章 Decorator

飾り枠と中身の同一視

== O!!!!! স

第12章 Decorator飾り枠と中身の

Decorator パターン

178

スポンジケーキが1つあったとします。 クリームを塗れば、 何ものっていないショート ケーキができあがります。 そこにイチゴを並べれば、 ストロベリーショートケーキになり ます。 さらに板チョコをのせて、ホワイトチョコレートで名前を書き、年齢の数だけキャ ンドルを立てれば、バースディケーキができあがります。

スポンジケーキも、ショートケーキも、ストロベリーショートケーキも、バースディケ ーキも、中心にあるのは同じスポンジケーキです。 でも、クリームを塗り、 ストロベリ ーをのせ...と、いろいろデコレーションをしていくうちに、 よりおいしく、それぞれの目 的にあったケーキになるでしょう。

オブジェクトも、このようなケーキと似ていることがあります。 まず、 中心となるスポ ンジケーキのようなオブジェクトがある。 それに飾り付けとなる機能を一皮一皮かぶせて いって、 より目的にあったオブジェクトに仕上げていくのです。

このような、 オブジェクトにどんどんデコレーション (飾り付け)をほどこしていくよ うなデザインパターンを、

デコレータ Decoratorパターン

デコレート と呼びます。 decorator とは、 「decorate (飾り付け) するもの」という意味です。この章 では、 Decoratorパターンについて学びましょう。

サンプルプログラム

ここで作るサンプルプログラムは、文字列の周りに飾り枠をつけて表示するというもの です。 ここでいう飾り枠とは -,+, | という文字で描いたもののことです。 Hello world. という文字列に飾り枠をつけた例をFig.12-1に示します。

Fig.12-1 Hello, world. に飾り枠をつけた例

Hello, world.|

サンプルプログラム

Table 12-1 クラス一覧

名前 Display Border 解説 文字列表示用の抽象クラス StringDisplay 1行だけからなる文字列表示用のクラス 「飾り枠」 を表す抽象クラス SideBorder 左右にのみ飾り枠をつけるクラス FullBorder Main 上下左右に飾り枠をつけるクラス 動作テスト用のクラス

Fig.12-2 サンプルプログラムのクラス図

string String Display getColumns getRows. getRowText Display getColumns getRows getRowText show SideBorder borderChar getColumns getRows getRowText display Border FullBorder getColumns getRows getRowText makeLine

179

第12章 Decorator飾り枠と中身の同一視

Displayクラス

Displayクラス (List 12-1) は、 複数行からなる文字列を表示するための抽象クラスで す。

getColumns getRows は、 それぞれ横の文字数と縦の行数を得るためのメソッドです。 これは抽象メソッドで、 サブクラスで実装することが期待されています (subclass responsibility)。getRowTextは指定した行の文字列を得るメソッドです。 これも抽象メソッドで、 サブクラスで実装することが期待されています。

showはすべての行を表示するメソッドです。 この中では、 getRowsメソッドで行数を 取得し、 getRowTextメソッドで表示すべき文字列を取得し、 forループを使ってすべて の行を表示しています。 showは、 getRows と getRowTextという抽象メソッドを使った Template Method パターン (第3章) になっています。

List 12-1 Displayクラス (Display.java)

1: public abstract class Display { 2: public abstract int getColumns(); 3: 4: 5: 6: public abstract int getRows(); // 横の文字数を得る // 縦の行数を得る public abstract String getRowText(int row); // row行目の文字列を得る // すべての行を表示する 7: public void show() { 8: for (int i = 0; i < getRows(); i++) ( System.out.println (getRowText(i)); 9: 10: 11: } } 12: )

String Display クラス

Displayクラスだけを見ていてもよくわかりませんので、サブクラスのString Display クラスを見てみましょう。冒頭のケーキのたとえ話に当てはめると、この string Display クラスは、バースディケーキの中心にあるスポンジケーキになります。

StringDisplayクラス (List 12-2) は、1行の文字列を表示するクラスです。 String Display クラスは、 Displayクラスのサブクラスですので、 Displayクラスで宣言されて いる抽象メソッドを実装する責任を負っています。

string フィールドは表示する文字列を保持します。 StringDisplayクラスで表示するの

180

サンプルプログラム 181

string フィールドの内容1行だけですので、 getColumns は string.length() で得られ る文字列長を返し、 getRowsは1を返します。

また、getRowTextは0行目の値をとるときのみstring フィールドを返します。 引数 rowが0以外なら、エラーとしてIndexOutOfBounds Exception 例外を throw します。

List 12-2 StringDisplay クラス (String Display.java)

1: public class String Display extends Display (

private String string; // 表示文字列

3:

public StringDisplay (String string) ( this.string = string;

5:

6:

7:

10:

11:

}

12:

}

@Override

public int getColumns() (

return string.length();

8:

9:

13:

@Override

public int getRows() {

return 1; // 行数は1

14:

15:

16:

}

@Override

17:

18:

19:

public String getRowText (int row) (

throw new IndexOutOfBoundsException();

20:

if (row != 0) (

21:

22:

return string;

23:

24:

}

25: )

Border クラス

Border クラス (List 12-3) は、 「飾り枠」 を表す抽象クラスです。 飾り枠を表すクラス なのですが、 文字列表示を行うDisplayクラスのサブクラスとして定義されています。 すなわち、継承によって飾り枠は中身と同じメソッドを持つことになります。 具体的に

いえば、 Borderクラスは getColumns, getRows, getRowText, show の各メソッドを継

4:

*ここでは簡単のため、1文字が画面上で1カラムを占めるという前提でコーディングしています。

2:

}

182 第12章 Decorator飾り枠と中身の同一視

承しているということです。 飾り枠 (Border) が中身 (Display) と同じメソッドを持つ ということは、インタフェース (API) 的に見れば、 飾り枠と中身を同一視できるという ことを意味します。 おっと、 少し先走りしてしまいました。 まだ、 あまりピンとこないで すよね。もう少し読み進んでいきましょう。

さて、飾り枠のBorderクラスは、 Display 型のdisplay フィールドを持っています。 これは、この飾り枠がくるんでいる 「中身」 を指すものです。 でも、 displayの中身が StringDisplayのインスタンスとは限りません。 なにしろ、 Border も Displayのサブク ラスですから、 display フィールドの中身はさらに別の飾り枠 (Borderクラスのサブク ラスのインスタンス) かもしれません。 そして、 その飾り枠もまたさらに display フィー ルドを持っていて･･･ほら、 そろそろ Decoratorパターンの筋書きが見えてきましたか?

List 12-3 Border クラス (Border.java)

1: public abstract class Border extends Display

protected Display display;

2:

4: 5: protected Border (Display display) { // インスタンス生成時に 「中身」 を引数で指定 this.display = display:

3:

// この飾り枠がくるんでいる 「中身」

6:

}

7: }

SideBorder クラス

SideBorderクラス (List 12-4) は、 具体的な飾り枠の一種で、 Borderクラスのサブク ラスです。 SideBorderクラスは、文字列の左右に決まった文字 (borderChar) で飾りを つけるものです。 例えば、 borderChar フィールドの値が だとすると、

|中身|

のように、 「中身」 の左右にその文字が付加されて、 showで表示されることになります。 borderChar フィールドはコンストラクタで指定します。

SideBorderは抽象クラスではありません。 なぜなら、 スーパークラスで宣言されてい た抽象メソッドが、すべてここで実装されているからです。

getColumns は、表示文字の横の文字数を得るメソッドです。 文字数はどうすれば計算 できるでしょうか。 簡単です。 この飾り枠がくるんでいる 「中身」 の文字数に、 左右の飾 り文字分を加えればよいのです。 中身の文字数はどうやって得ればよいのでしょう。 はい、 もちろん、 display.getColumns() という式で得られます。 display フィールドはBorder

サンプルプログラム

クラスでprotectedでしたから、サブクラスで直接利用できます。 左右の飾り文字分を加 えて、

1+display.getColumns () +1

が戻り値となります。 display.getColumns() + 2と書いてもかまいませんが、ここでは 左右に1ずつ加えたことがはっきりわかるように式を書きました。

getColumns メソッドの作り方がわかれば、 getRowsメソッドもすぐわかりますね。 Side Border クラスは、上下方向には手をまったく加えませんので、 式display.getRows()の 値がそのまま getRows メソッドの値となります。

getRowTextメソッドはどうでしょう。 getRowTextは、引数で指定した行の文字列を得 るものです。 display.getRowText(row) という中身の文字列の両側に、 borderChar とい う飾り文字を付け加えた、

borderChar + display.getRowText(row) + borderChar

が getRowTextの戻り値となります (まさにこれがSideBorder の 「飾り付け」です)。

List 12-4 SideBorder クラス (SideBorder.java)

1: public class SideBorder extends Border {

2: 3: private char borderChar; //飾り文字 // 中身となるDisplayと飾り文字を指定 public SideBorder (Display display, char ch) ( super (display); this.borderChar = ch; @Override public int getColumns () ( // 文字数は中身の両側に飾り文字分を加えたもの return display.getColumns () + 1; 4: 5: 6: 7: 8: } 9: 10: 11: 12: 13: 14: } 15: 16: 17: 18: @Override public int getRows() ( // 行数は中身の行数に同じ

} return display.getRows();

19:

20:

21:

@Override public String getRowText (int row) ( // 指定行の内容は、中身の指定行の両側に飾り文字をつけたもの

22:

23:

24:

183

第12章 Decorator飾り枠と中身の同一視

184

25:

26:

return border Char display.getRowText(row) + borderChar;

27: )

| FullBorder クラス

FullBorderクラス (List 12-5) も、 SideBorderクラスと同様、 Borderのサブクラス の1つです。 SideBorderクラスは左右にだけ飾りをつけましたが、 Full Borderクラスは 上下左右に飾りをつけています。 ただし、 SideBorderクラスでは飾り付けの文字を指定 できましたが、 FullBorderクラスでは飾り付けの文字は固定にしています。 makeLineメソッドは、指定した文字を連続させた文字列を作る、 補助用のメソッドで

す(クラス外から使えないように private にしています)。

List 12-5 FullBorder クラス (FullBorder.java)

1: public class FullBorder extends Border 2: public FullBorder (Display display)

( super (display) ;

4:

5:

@Override

}

public int getColumns(){

// 文字数は中身の両側に左右の飾り文字分を加えたもの

return 1 display.getColumns () + 1;

3:

6:

7:

8:

9:

10:

11:

}

12:

@Override

13:

public int getRows() (

14:

// 行数は中身の行数に上下の飾り文字分を加えたもの

15:

return 1 + display.getRows() + 1;

16:

17:

18:

@Override

19: public String getRowText (int row) { 20: if (row == 0){ // 上端の枠 21: return + makeLine('-, display.getColumns ()) + '+"; 22: } else if (row == display.getRows() + 1) { // 下端の枠 23: return + + makeLine('-' display.getColumns()) ++; 24: } else { // それ以外 25: return "|" + display.getRowText (row 1) + *|*; 26: } 27:

サンプルプログラム

28:

// 文字 chを count個連続させた文字列を作る private String makeLine (char ch, int count) { StringBuilder line = new StringBuilder(); for (int i = 0; i < count; i++) { 29: 30: 31: 32: 33: 34: } 35: 36: line.append(ch); return line.toString(); 37: )

| Mainクラス

Mainクラス (List 12-6) は、 動作テスト用のクラスです。

List 12-6 Main >52 (Main.java)

1: public class Main ( public static void main(String[] args) { 2: 3: Display bl 4: 5: Display b2 Display b3 new FullBorder (b2); new StringDisplay ("Hello, world."); new SideBorder (b1, ''); 6: bl.show(); 7: b2.show(); 8: b3.show(); 9: Display b4= 10: new SideBorder ( 11: new FullBorder ( 12: new FullBorder ( 13: new SideBorder ( 14: new FullBorder ( 15: new StringDisplay ("Hello, world.") 16: ), 17: 18: 19: 20: 21: 22: 23: 24: b4.show(); );

25: )

185

章 Decorator飾り枠と中身の同一視

第12

Mainクラスで使われているインスタンスb1b4の役割は、それぞれ次のとおりで す。

b1 "Hello, world. を飾りなしで表示するもの ・b2 ･･･ b1 に対して、 '#'の文字で左右に飾り付けをしたもの ・b3 ･･･ b2 に対して全体の飾り枠をつけたもの ・b4 "Hello, world. に何重にも飾り枠をつけたもの

Fig.12-3 実行結果

Hello, world. ←b1.show() の表示 #Hello, world. # ←b2.show() の表示 ←b3.show() の表示 #Hello, world.#| +/ ←b4.show() の表示 +-- 711* /+ +*11/ /||*|Hello, world.|*||/ +

ここで、インスタンスb1, b2b3の関係を確認するため、オブジェクト図を示します (Fig.12-4)。 b1の飾り枠が2で、 b2の飾り枠がb3になっている様子がわかりますね。

| Fig.12-4 b3b2b1 のオブジェクト図

b3: FullBorder display b2:SideBorder display bl:StringDisplay

186

Decoratorパターンの登場人物 187

Decorator パターンの登場人物

Decoratorパターンの登場人物は、次のとおりです。

コンポーネント >Component の役

機能を追加するときの核になる役です。 冒頭 (p.178) のたとえ話でいえば、デコレー ションする前のスポンジケーキにあたります。 Component役はスポンジケーキのインタフ (API)だけを定めます。 サンプルプログラムでは、 Displayクラスがこの役をつ とめました。

コンクリート・コンポーネント ConcreteComponent

Component役のインタフェース (API) を実装している具体的なスポンジケーキです。 サンプルプログラムでは、 StringDisplayクラスがこの役をつとめました。

デコレータ Decorator (装飾者)の役

Component役と同じインタフェース (API) を持ちます。 そしてさらに、このDecorator 役が飾る対象となる Component 役を持っています。 この役は、自分が飾っている対象を 「知っている」 わけです。 サンプルプログラムでは、 Border クラスがこの役をつとめまし た。

コンクリートデコレータ Concrete Decorator (具体的な装飾者)の役

具体的な Decoratorの役です。 サンプルプログラムでは、SideBorderクラスとFull Border クラスがこの役をつとめました。

Decoratorパターンをクラス図で表記すると、 Fig.12-5のようになります。

章 Decorator飾り枠と中身の同一視

Fig.12-5 Decoratorパターンのクラス図

Component

第12

methodl

|method2 method3

Concrete Component

methodl

method2

method3

Decorator

component

Concrete Decorator

method1

method2

method3

あなたの考えを広げるためのヒント

透過的なインタフェース (API)

Decoratorパターンでは、飾り枠と中身を同一視しています。 具体的にいえば、 サンプ ルプログラムで、 飾り枠を表す Borderクラスが、 中身を表すDisplayクラスのサブクラ スになっているところで、その同一視が表現されています。 つまり、 Borderクラス ( よびそのサブクラスたち)は、中身を表すDisplayクラスと同じインタフェース (API)

188

あなたの考えを広げるためのヒント

を持っているのです。

飾り枠を使って中身を包んでも、インタフェース (API) は少しも隠されません。 getColumns, getRows, getRowText, それに showというメソッドは隠されることなく他 のクラスから見ることができます。 これを、 インタフェース (API) が 「透過的」 である といいます。

サンプルプログラムのインスタンスb4のように、 飾り枠をたくさん使って包んでも、 インタフェース (API) はまったく変更されていないのです。

インタフェース (API) が透過的であるため、 Decoratorパターンでは、 Composite パタ ーンに似た再帰的な構造が登場します。 すなわち、 飾り枠が保持している 「中身」 が、 実 際には別のものの 「飾り枠」になっているという構造です。 タマネギの皮をむいて中身が 出てきたと思ったら、それもまた皮だったというようなものです。 Decoratorパターンと Composite パターンは、 再帰的な構造を扱うという点では似ていますが、 目的は異なりま す。 Decoratorパターンは外枠を重ねることで機能を追加していく点に主眼があるからです。

中身を変えずに、機能追加ができる

Decoratorパターンでは、飾り枠も中身も共通のインタフェース (API) を持っています。 インタフェース (API) は共通ですが、 包めば包むほど機能が追加されていきます。 Display を SideBorder で包めば、 左右に新しい飾り文字をつける表示ができるようにな ります。 さらにFull Borderで包めば、 今度は周り全体に飾り枠がつきます。 その際に包 まれる方を修正する必要はありません。 包まれるものを変更することなく、機能の追加を 行うことができるのです。

Decoratorパターンでは委譲が使われています。 「飾り枠」 に対してやってきた要求 (メ ソッドの呼び出し) は、 その 「中身」にたらい回し (委譲) されます。 サンプルプログラ ム (List 12-4) では、 SideBorder のgetColumnsメソッドの中でdisplay.getColumns() を呼び出しています。 また、 getRowsメソッドでは、 display.getRows() を呼び出してい ましたね。

動的な機能追加ができる

Decoratorパターンで使われている委譲は、クラス間を動的に結合しています。 ですか フレームワークのソースを変更することなく、 オブジェクトの関係を変えた新しいオ ブジェクトを作ることができます。

189

188 12 Decorator-R

Fig.12-5 Decor

あなたの考えを広げるためのヒント

Line NumberReaderのコンストラクタにも、 BufferedReaderのコンストラクタにも、 Readerクラス (のサブクラス)のインスタンスを渡すことができますから、上のように いろんな組み合わせを作ることができるのです。 次は、行番号は管理するけれども、バッファリングは行わない場合です。

Reader reader = new LineNumberReader (

new FileReader("datafile.txt")

);

次は、行番号を管理し、 バッファリングを行うけれど、 ファイルから読み込むのではな く、ネットワークから読み込むためのものです(細かい部分や例外処理は省略しています)。 java.net.Socket socket = new Socket (hostname, portnumber);

Reader reader = new LineNumberReader (

new BufferedReader(

new InputStreamReader(

socket.getInputStream()

);

ここで使われている InputStreamReaderクラスは、 getInputStreamの戻り値として得 られる InputStreamクラスのインスタンスを元に、 Readerクラスのインタフェース (API) を提供するものです (ちなみに、これはAdapter パターン (第2章) ですね)。 java.io パッケージの他に、 javax.swing.borderパッケージでも、 Decoratorパター ンが登場します。 javax.swing.borderパッケージには、画面に表示されるコンポーネン トに付加できる飾り枠用のクラスが集まっています。

java.nio.file.Files

前節では、 java.io パッケージでDecoratorパターンが使われているという話を書きま したが、よく使われる機能についてはいちいち複数のクラスを組み合わせなくても使いた いですね。

java.nio.file.Files クラスには、 Table 12-2のようなクラスメソッドが用意されて おり、手軽にファイルへアクセスできるようになっています。

191

第12章 Decorator飾り枠と中身の同一視

単純な品揃えでも、 多様な機能追加ができる

Decoratorパターンを使うと、 多様な機能追加を行うことができます。 具体的な飾り枠 (ConcreteDecorator役) をたくさん用意しておけば、それらを自由に組み合わせて新しい オブジェクトを作ることができるからです。 その際に、個々の飾り枠は単純でもかまいま せん。

これは、バニラ、チョコ、ストロベリー、 キーウィ、...といったフレーバーを自由に選べ るアイスクリームのようなものです。 お客さんが注文するかもしれないさまざまなアイス クリームを、はじめから全部用意していたら大変です。 お店では多種類のフレーバーだけ を用意する。 そして、お客さんの注文にあわせてフレーバーを組み合わせ、注文どおりの アイスクリームを作るのです。 バニラだけが食べたい、 コーヒーラムとピスタチオのダブ ルが食べたい、バニラとストロベリーとキーウィのトリプルが食べたい･･･と、お客さんの 注文はさまざまです。 Decoratorパターンは、そのような多様な要求に応えるのに向いて いますね。

java.ioパッケージと Decorator パターン

java.io というパッケージに含まれているクラスのお話をしましょう。 java.ioは入出 力 Input/Output, 略して I/O) を行うためのパッケージです。 ここでは、 Decoratorパタ ーンが使われています。

まず、次のようにすると、 ファイルからデータを読み込むインスタンスが作れます。

Reader reader = new FileReader("datafile.txt");

また、次のようにすると、 ファイルからデータを読み込むときにバッファリングを行う ようになります。

Reader reader = new BufferedReader(

new FileReader("datafile.txt")

);

これは、BufferedReader クラスのインスタンスを作るときに、 実際にデータを読み込 む先として、 FileReaderクラスのインスタンスを指定していることになります。 さらに、次のようにすると、行番号を管理することができるようになります。

Reader reader = new Line NumberReader( new BufferedReader( new FileReader("datafile.txt")

Java

190

あなたの考えを広げるためのヒント

Line Number Readerのコンストラクタにも、 BufferedReaderのコンストラクタにも、 Readerクラス(のサブクラス) のインスタンスを渡すことができますから、上のように いろんな組み合わせを作ることができるのです。 次は、 行番号は管理するけれども、 バッファリングは行わない場合です。

Reader reader = new Line NumberReader ( ); new FileReader("datafile.txt")

次は、行番号を管理し、 バッファリングを行うけれど、 ファイルから読み込むのではな く、ネットワークから読み込むためのものです(細かい部分や例外処理は省略しています)。 java.net.Socket socket = new Socket (hostname, portnumber);

Reader reader = new Line NumberReader(

new BufferedReader(

new InputStreamReader(

socket.getInputStream()

);

ここで使われている InputStreamReaderクラスは、 getInputStreamの戻り値として得 られる InputStreamクラスのインスタンスを元に、 Readerクラスのインタフェース (API) を提供するものです (ちなみに、これはAdapter パターン (第2章) ですね)。 java.io パッケージの他に、 javax.swing.border パッケージでも、 Decorator パター ンが登場します。 javax.swing.borderパッケージには、画面に表示されるコンポーネン トに付加できる飾り枠用のクラスが集まっています。

java.nio.file.Files

前節では、 java.ioパッケージでDecoratorパターンが使われているという話を書きま したが、よく使われる機能についてはいちいち複数のクラスを組み合わせなくても使いた いですね。

java.nio.file. Filesクラスには、 Table 12-2のようなクラスメソッドが用意されて おり、手軽にファイルへアクセスできるようになっています。

191

[Java

第12章 Deerator飾り枠と中身の同一視

Table 12-2 java.nio.file.Files の便利なクラスメソッド (一部)

名前 newBufferedReader 機能 ファイル読み込み用の BufferedReader を得る newBufferedWriter ファイル書き込み用の BufferedWriter を得る newInputStream ファイル読み込み用の InputStream を得る readString newOutputStream ファイル書き込み用の OutputStream を得る ファイルをすべて読み込んだStringを得る writeString ファイルにStringを書き込む readAllBytes ファイルをすべて読み込んだ byteの配列を得る readAllLines ファイルのすべての行を読み込んだList<String> を得る

関連しているパターン

Adapter パターン (第2章) Decoratorパターンは、中身のインタフェース (API) を変えずに外枠を作ります (透過的)。 Adapter パターンは、ずれがある2つのインタフェース (API) をつなぐために用います。

Strategy パターン (第10章) Decoratorパターンは、外枠を取り替えたり、 外枠を重ねたりして機能を追加します。 Strategyパターンは、アルゴリズムを切り替えて機能を変更します。

Composite パターン (第11章)

Decoratorパターンは、機能を柔軟に追加するために再帰的な構造を利用します。 Composite パターンは、機能を追加するところではなく、 容器と中身を同一視するとこ ろに主眼があります。

補講 継承と委譲における同一視

ここで、「同一視」すなわち「同じものと見なす」ということについて少し考えましょう。

継承 サブクラスとスーパークラスとを同一視 -

サブクラスは、スーパークラスと同一視することができます。 簡単な例を示します。

192

継承と委譲における視

class Parent ( ... void parentMethod() { } } class Child extends Parent ( void childMethod() ( } }

このとき、Childのインスタンスは、 Parent 型の変数にそのまま代入することができ ます。そして、Parent から継承しているメソッドをそのまま呼び出すことができます。

Parent obj = new Child(); obj.parentMethod();

つまり、ChildのインスタンスをあたかもParentのインスタンスであるかのように扱 っているのです。 これはサブクラスをスーパークラスだと見なしている例です。 ちなみに、上の例とは逆に、 スーパークラスをサブクラスだと見なすためには、キャス トが必要です。

Parent obj = new Child(); ( (Child) obj).childMethod();

委譲 - 自分と委譲先とを同一視

委譲を使ってインタフェースが透過的になっているときには、 自分と委譲先を同一視す ることができます。

まず、ぎこちない例から見ていきましょう。

class Rose ( Violet obj =... void method() ( obj.method();

193

第12章 Decorator飾り枠と中身の一

class Violet { void method() { } }

Rose と Violet は同じmethodを持っていて、 RoseはVioletに委譲しています。 うーん、 何 となくこのクラスはつながっているような、 つながっていないような•••いやな感じがします。 何がいやかというと、両者は共通のメソッドであるmethodを持っているのですが、そ の 「共通の」という情報が、 ソース中には明示されていないからです。 もちろん、 methodの定義は明示されているのですが…。 次のように共通の抽象クラス Flower がある と、ぐっとひきしまりますね。

abstract class Flower ( abstract void method(); } class Rose extends Flower { Violet obj =... @Override void method() ( obj. method(); class Violet extends Flower ( @Override void method() { }

あるいは、 Flowerはインタフェースかもしれません。

interface Flower ( abstract void method(); class Rose implements Flower ( Violet obj = @Override void method () ( obj.method(); }

194

この章で学んだこと 195

class Violet implements Flower @Override void method() { )

ここまで考えてくると、 Roseの中のフィールドobj は Violet型、 と特化してしまって いいのかな? という疑問も生じます。 もしかしたら、 より広いFlower型の方がいいので はないかな? ･･･どうするべきなのかは、 実際のプログラムによって変わってくるでしょ うね。

この章で学んだこと

この章では、 透過的なインタフェース (API) を保ったまま、 オブジェクトを次々にか ぶせて機能を追加していく Decoratorパターンについて学びました。 継承と委譲について も学びました。 抽象クラスやインタフェースの感じは、だいぶつかめてきたでしょうか。 練習問題にも挑戦してみてください。

第12章 Decorator飾り枠と中身の同一視

練習問題

解答は付録A (p.443)

▶問題12-1

本章のサンプルプログラムに追加する形で、上下に飾り文字がついた UpDown Border ク ラスを作ってください。 UpDown Border クラスはList 12-7のように使うものとします。 実 行結果をFig.12-6に示します。

List 12-7 Main 757 (Main.java)

1: public class Main ( public static void main(String[] args) { Display bl new String Display ("Hello, world."); Display b2 new UpDownBorder (b1, '-'); Display b3 new SideBorder (b2, 2: 3: 4: 5: 6: bl.show(); 7: b2.show(); 8: b3.show(); 9: Display b4 = 10: new FullBorder ( 11: 12: 13: 14: ⠀ **); 15: 16: 17: 18: new UpDownBorder ( new SideBorder ( new UpDownBorder ( new SideBorder ( ). new StringDisplay ("Hello, world."). 19: 20: 21: 22: 23: 24: 25: b4.show(); 26: } 27: )

196

統出問題 197

Fig.12-6 17

Hello, world. bl.show() b2.show() Hello, world. b3.show() Hello, world.. b4.show() Hello, world. *|| ////////\

問題12-2

ConcreteComponent役として、 複数の文字列を表示する MultiString Displayクラスを 作ってください。 MultiStringDisplayは List 12-8のように使うものとします。 実行結 果を Fig.12-7に示します。

List 12-8 Main 57 (Main.java)

1: public class Main ( public static void main(String[] args) ( 2: 3: 4: 5: 6: 7: 8: 9: 10: 11: 12: 13: 14: 15: ) 16: ) MultiStringDisplay md = new MultiString Display(); md.add("Hi!"); md.add("Good morning."); md.add("Good night!"); md.show(); Display dl new SideBorder (md, '#'); dl.show(); Display d2 new Full Border (md); d2.show();

1982 Doratorり枠と中身の同一視

Fig.12-7 R

Hi! Good morning. Good night! -md.show() #Hi! dl.show() T #Good morning.# #Good night! # d2.show() Hi! Good morning.| Good night! I

第13章 Visitor

構造を渡り歩きながら 仕事をする

第3章 Visitor橋を渡り歩きながら仕事をする

Visitor パターン

クリスマスの話を知っていますか。 もうすぐ赤ちゃんが生まれそうなマリアは、夫のヨ セフに連れられて宿屋をめぐっていました。 ベツレヘムにはたくさんの宿屋がありました ので、順番に宿屋の戸を叩いていきました・・・。

この章で学ぶのは、

ビジター

Visitor パターン

です。 visitor というのは「訪問者」という意味です。

データ構造の中にたくさんの要素が格納されており、その各要素に対して何かの「処理」 をしていくとしましょう。 このとき、 その 「処理」 のコードはどこに書くべきでしょうか。 普通に考えれば、 データ構造を表しているクラスの中に書きますね。 でも、もし、その 「処理」 が一種類とは限らなかったらどうでしょう。 その場合、 新しい処理が必要になる たびに、データ構造のクラスを修正しなければならなくなります。

Visitorパターンでは、 データ構造と処理を分離します。 そして、 データ構造の中を巡り 歩く主体である 「訪問者」 を表すクラスを用意し、そのクラスに処理をまかせます。する と、 新しい処理を追加したいときには新しい 「訪問者」 を作ればよいことになります。 そ して、データ構造の方は、戸を叩いてくる「訪問者」 を受け入れてあげればよいのです。

サンプルプログラム

Visitorパターンのサンプルプログラムを読みましょう。 訪問者が渡り歩くデータ構造と して、 Composite パターン (第11章) で登場したファイルとディレクトリの例をもう一度 使うことにします。 ファイルとディレクトリで構成されたデータ構造の中を訪問者が渡り 歩き、ファイルの一覧を表示するプログラムを作成します。

Visitor クラス

Visitor クラス (List 13-1) は、 「訪問者」 を表す抽象クラスです。 この訪問者は、訪 問先のデータ構造 (すなわちFile と Directory) に依存しています。

Visitor クラスでは、 visitという同じ名前を持つメソッドが2つ宣言されています。 名前は同じですが、 引数が異なります。 片方はFileを、 他方はDirectory を引数にとり ます。 名前は同じですが、 メソッド呼び出しを行うときの引数の型によって、 自動的にメ

200

サンプルプログラム

Table 13-1 クラスとインタフェース一覧

名前 Visitor Element ListVisitor 解說 ファイルやディレクトリを訪れる訪問者を表す抽象クラス Visitor クラスのインスタンスを受け入れるデータ構造を表すインタフェース Visitor クラスのサブクラスで、 ファイルやディレクトリの一覧を表示するクラス File と Directoryのスーパークラスとなる抽象クラス (Acceptor インタフェースを実装) ファイルを表すクラス Entry File Directory ディレクトリを表すクラス Main 動作テスト用のクラス

Fig.13-1 サンプルプログラムのクラス図

Visitor

visit (File)

visit (Directory)

<<interface>>

Element

ListVisitor

currentdir

visit (File)

accept

visit (Directory)

Entry

name size

getName getSize

Uses

File

Directory

accept

getName

name

directory

getSize

accept getName getSize add

iterator

Uses

Main

Uses -

201

202 第13章 Visitor 構造を渡り歩きながら仕事をする

ソッドの識別が行われます。 一般にこれをメソッドのオーバーロード (overload) といい ます。

visit (File) は、 File を訪問したときにFileクラスが呼び出すメソッドで、 visit Directory) は、 Directoryを訪問したときに Directoryクラスが呼び出すメソッドです。 Visitorパターンはクラス間の相互呼び出しが複雑なので、 Visitorクラスだけを見つめて いても理解は進みません。 ここでは、 Visitorクラスが2つのvisitというメソッドを持 っていることを理解したら、次のクラスに進みましょう。

List 13-1 Visitor クラス (Visitor.java)

1: public abstract class Visitor { 2: 3: 4: ) public abstract void visit (File file); public abstract void visit (Directory directory);

Elementインタフェース

Visitorクラスは 「訪問者」 を表すクラスです。 一方、 Element インタフェース (List 13-2) は、 訪問者を受け入れるインタフェースです。 Visitorクラスがマリアだとすれば、 Elementインタフェースは宿屋に相当するでしょう (Elementインタフェースを実装して いるクラスのインスタンスが実際の宿屋になります)。

Elementインタフェースで宣言しているメソッドはaccept です (accept は英語で 「受 「け入れる」という意味)。 引数は訪問者であるVisitorクラスになります。

List 13-2 Element インタフェース (Element.java)

1: public interface Element( 2: public abstract void accept (Visitor v); 3: )

| Entry クラス

Entryクラス (List 13-3) は、 Composite パターンのサンプルプログラム (List 11-1) で登場したものと本質的には同じですが、ここではElementインタフェースを実装 implements)しています。 これは、 Entryクラスを Visitorパターンに適合させるためで

サンプルプログラム 203

す。 Element インタフェースで宣言されている抽象メソッド accept を実際に実装するの は、EntryのサブクラスであるFileクラスやDirectoryクラスの側です。 またCommand パターンのサンプルプログラムで使っていたprintListメソッドは使わないので削除して あります。

List 13-3 Entry クラス (Entry.java)

1: public abstract class Entry implemente Element( public abstract String getName(); // 名前を得る 2: 3: public abstract int getSize(); // サイズを得る 4: 5: 6: 7: 8: // 文字列表現 @Override public String toString() ( return getName() getSize() + ")"; 9: } 10: )

File クラス

File クラス (List 13-4) も、 Compositeパターンのサンプルプログラムで登場したもの とほぼ同じです。 Visitorパターンでのポイントは、 もちろん、 acceptメソッドをどう実 装するかです。 accept メソッドの引数はVisitorクラスです。 そして、 acceptメソッド の中からv.visit (this); という文で、 Visitor の visit メソッドを呼び出します。 visitメソッドはオーバーロードされていますが、 ここで呼び出されるのはvisit (File) の方です。 なぜなら、ここのthis は、 Fileクラスのインスタンスだからです。

visitメソッドを呼び出すことで、 Visitor に対し、 訪問したFileのインスタンス (this) を教えていることになります (visitとaccept の関係は、一度読んだだけではビ ンとこないと思います。 p.209 でシーケンス図と共に解説します)。

List 13-4 File クラス (File.java)

1: public class File extends Entry ( 2: private String name; 3: private int size; 4: 5: public File (String name, int size) ( 6: 7: this.name = name; this.size = size;

第13章 Visitor 構造を渡り歩きながら仕事をする

204

8:

public String getName() ()

9:

10:

11:

12:

return name;

13:

14:

15:

@Override

@Override

16:

public int getSize() {

17:

return size;

18:

19:

20: 21: 22: @Override public void accept (Visitor v) ( v.visit (this); 23: } 24: )

)

)

| Directoryクラス

Directoryクラス (List 13-5) は、ディレクトリを表すクラスです。 Composite パター ンで紹介したとき (List 11-3) に比べて、 2つのメソッドが増えています。

1つは、iterator メソッドです。 iteratorメソッドは、 ディレクトリに含まれている ディレクトリエントリ (ファイルやディレクトリ) の一覧を得るための Iterator<Entry> を返します。

もう1つは、もちろん accept メソッドです。 File クラスのaccept がvisit (File) メソ ッドを呼び出したのと同じように、 Directoryクラスのaccept はvisit (Directory) メ ソッドを呼び出しています。 これによって、 訪問者に 「あなたが訪問したのは、この Directoryのインスタンスですよ」と伝えていることになります。

サンプルプログラム

List 13-5 Directory 5x (Directory.java)

1: import java.util.ArrayList;

2: import java.util.Iterator;

3: import java.util.List;

4:

5: public class Directory extends Entry implements Iterable<Entry>(

6:

7:

private String name;

private List<Entry> directory = new ArrayList<>();

8:

public Directory (String name) (

10:

this.name name;

11:

12:

@Override public String getName() { return name; }

13:

23:

26:

14:

15:

16:

9:

} @Override public int getSize() ( int size = 0; for (Entry entry: directory) ( 十二 size + entry.getSize(); return size; )

17:

18:

public Entry add (Entry entry) { directory.add (entry); return this; }

20:

22:

24:

25:

27:

28:

29:

30:

31:

32: 33: @Override public Iterator<Entry> iterator() { return directory.iterator(): 34: 35: } 36: 37: 38: : : 41: ) @Override public void accept (Visitor v) { v.visit (this); )

3940

19:

21:

205

206 第13章 Visitor 構造を渡り歩きながら仕事をする

| ListVisitor クラス

ListVisitor クラス (List 13-6) は、 Visitorクラスのサブクラスで、 データ構造を渡 り歩きながら一覧を表示するためのクラスです。 Visitor クラスのサブクラスなので、 visit (File) メソッドと visit (Directory) メソッドを実装しています。

currentdir フィールドは、現在注目しているディレクトリ名を保持しています。 visit File メソッドは、ファイルを訪問したときにFileクラスのacceptメソッドの中から呼 び出されます。 引数 file は、 訪問したFile クラスのインスタンスです。 つまり、この visit (File) メソッドは、 「Fileクラスのインスタンスに対して行うべき処理」 を記述す る場所なのです。 ここでは、現在のディレクトリ名 (currentdir) の後にスラッシュ(/) 区切りでファイル名を表示しています。

visit (Directory) メソッドは、ディレクトリを訪問したときに Directoryクラスの accept メソッドの中から呼び出されます。 引数 directory は、 Directory クラスのイン スタンスです。

visit (Directory) メソッドには、 「Directoryクラスのインスタンスに対して行うべき 処理」が書かれています。

では、その処理とは何でしょう。 visit (File) と同じようにディレクトリを表示した後、 拡張for文を使って、ディレクトリの各エントリに対してaccept メソッドを呼び出して います。 ディレクトリの中にはたくさんのディレクトリエントリがありますから、 その1 つ1つを訪問しにいくことになります。

accept メソッドはvisitメソッドを呼び、 visit メソッドはacceptメソッドを呼んで います。 これはずいぶん複雑な再帰的なメソッド呼び出しですね。 あるメソッドが自分自 身を呼び出すというのが通常の再帰的な呼び出しですが、 Visitorパターンではvisitメソ ッドとaccept メソッドが互いに相手を呼び出しているのです。

List 13-6 ListVisitorクラス (ListVisitor.java)

1: public class ListVisitor extends Visitor // 現在注目しているディレクトリ名 private String currentdir = ""; // File訪問時 @Override 2: 3: 4: 5: 6: 7: 8: 9: } 10: 11: public void visit (File file) { System.out.println(currentdir + "/" + file); Directory 訪問時

サンプルプログラム

12: 13: 14: 15: @Override public void visit (Directory directory) ( System.out.println (currentdir +/+ directory); String savedir = currentdir; currentdir currentdir +"/"+directory.getName(); for (Entry entry: directory) { 16: 17: 18: 19: ) 20: 21: entry.accept(this); currentdir savedir; 22: )

| Main クラス

Main クラス (List 13-7) は、 Composite パターンのMainクラスとほとんど同じです。 違うのは、 Directory の内容を表示するのに、表示を行う訪問者であるListVisitor のイ ンスタンスを使っている点だけです。

Composite パターンでは、ディレクトリの表示をするために printListというメソッド を使っていました。 このメソッドはDirectoryクラス (つまりデータ構造の側) で実装さ れていました。これに対して、 Visitorパターンでは、ディレクトリの表示をするのも Visitor 側で行います。 ディレクトリの表示も、データ構造内の各要素に対して行う処理 だからです。

List 13-7 Main 7 (Main.java)

1: public class Main ( 2: 3: 4: public static void main(String[] args) { System.out.println("Making root entries..."); Directory rootdir new Directory("root"); Directory bindir = new Directory ("bin"); Directory tmpdir = new Directory("tmp"); Directory usrdir = new Directory ("usr"); rootdir.add(bindir); rootdir.add(tmpdir); 5: 6: 7: 8: 9: 10: rootdir.add(usrdir); 11: bindir.add(new File("vi", 10000)); 12: bindir.add(new File("latex", 20000)); 13: rootdir.accept (new ListVisitor());

14:

System.out.println();

System.out.println("Making user entries...");

15:

16:

207

208 第13章 Visitor 構造を渡り歩きながら仕事をする

new Directory ("yuki"); Directory hanako new Directory ("hanako"); 17: Directory yuki 18: 19: 20: 21: 22: 23: 24: 25: 26: 27: = Directory tomura new Directory (tomura"); usrdir.add(yuki); usrdir.add(hanako); usrdir.add(tomura); yuki.add(new File("diary.html", 100)); yuki.add(new File("Composite.java", 200)); hanako.add(new File("memo.tex", 300)); tomura.add(new File("game.doc", 400)); tomura.add(new File("junk.mail", 500)); rootdir.accept(new ListVisitor()); 28: 29: } 30: )

Fig.13-2

Making root entries.... /root (30000) /root/bin (30000) /root/bin/vi (10000) /root/bin/latex (20000) /root/tmp (0) /root/usr (0)

Making user entries... /root (31500) /root/bin (30000) /root/bin/vi (10000) /root/bin/latex (20000) /root/tmp (0) /root/usr (1500) /root/usr/yuki (300) /root/usr/yuki/diary.html (100) /root/usr/yuki/Composite.java (200) /root/usr/hanako (300) /root/usr/hanako/memo.tex (300) /root/usr/tomura (900) /root/usr/tomura/game.doc (400) /root/usr/tomura/junk.mail (500)

サンプ トンプルプログラム

| Visitor側と Element側の相互呼び出し

さて、ここまで読んできて、 Visitorパターンの動作を理解できましたか。 私がはじめて Visitorパターンを学んだときには、さっぱり理解できませんでした。 visitメソッドと、 accept メソッドの動作が頭の中で混乱してしまったからです。 ここでは、シーケンス図 (Fig.13-3)を使って処理の流れを見てみましょう (シーケンス図の解説はp.xxxivにあり ます)。

Fig.13-3 サンプルプログラムのシーケンス図 (1つのディレクトリに2つのファイルがある場合)

File

Main new :ListVisitor 2 accept visit visit ⑤ :Directory accept :File accept visit

Fig.13-3では、話を単純化するために、1つのディレクトリに2つのファイルがある場合 の処理の流れを図示しています。

209

210 第13章 Visitor 構造を渡り歩きながら仕事をする

① まず、MainクラスがListVisitor のインスタンスを作ります。 サンプルプログラムで は、他の DirectoryやFileのインスタンスもMainクラスが作っていますが、このシーケ ンス図では省略しています。

②Main は、 Directoryのインスタンスに対して、 acceptメソッドを呼び出します。 この とき、引数にはListVisitorのインスタンスを渡していますが、この図では省略してい ます。

③ Directoryのインスタンスは、引数で渡されたListVisitor の visit (Directory) メソ ッドを呼び出します。

④すると、ListVisitor のインスタンスは、そのディレクトリの中を探って、最初のファ イルのaccept メソッドを呼び出します。 引数には自分自身 (this)を渡します。 ⑤Fileのインスタンスは、 引数で渡されたListVisitor の visit (File) メソッドを呼び

出します。このとき、 ListVisitor は visit (Directory) の実行中であることに注意して ください (マルチスレッドとして実行中という意味ではなく、 呼び出し履歴 (コールスタ ック)の中にはvisit (Directory) がある、という意味です。 図では長方形を右に重ねて 示しています)。

⑥ visit (File) から戻り、 accept から戻ると、 今度は別のFileのインスタンス (同じディ レクトリの2番目のファイル) のaccept メソッドを呼び出します。 引数にはListVisitor のインスタンス (this) を渡します。

⑦先ほどと同じように、 Fileのインスタンスは、 visit (File)のメソッドを呼びます。 それぞれのメソッドの処理が終わると呼び出し元にどんどんさかのぼり、最後にはMain の accept メソッドの呼び出しからも戻ります。

以下のポイントを図から読み取ってください。

・DirectoryのインスタンスやFileのインスタンスに対しては、 accept メソッドが 呼び出されている

・accept メソッドは、インスタンスごとに1回しか呼ばれない

・ListVisitorのインスタンスに対しては、 visit (Directory) や visit (File) メソ ッドが呼び出されている

* visit (Directory) や visit (File) を処理しているのは、 1つのListVisitorのイ ンスタンスである

ListVisitor のところに visit による 「処理」 が集中している様子がわかりますか。

Visitorパターンの登場人物

Visitor パターンの登場人物

Visitorパターンの登場人物は、次のとおりです。

Visitor (訪問者) の役

Visitor役は、 データ構造の具体的な要素 (ConcreteElement役) ごとに 「xxxxを訪問し た」という visit (XXXX) メソッドを宣言します。 visit (XXXX) は XXXXを処理するための メソッドで、実際のコードは Concrete Visitor 役の側に書かれます。 サンプルプログラムで は、 Visitor クラスがこの役をつとめました。

コンクリートビジター Concrete Visitor (具体的訪問者)の役

Concrete Visitor役は、Visitor役のインタフェース (API) を実装します。 visit (XXXX) という形のメソッドを実装し、 個々のConcreteElement役ごとの処理を記述します。 サンプ ルプログラムでは、 ListVisitorクラスがこの役をつとめました。 ListVisitorでcurrent dir フィールドの値が変化したように、 visit (XXXX) を処理していく中で、 Concrete Visitor 役の内部状態が変化することもあります。

Element (要素) の役

Element役は、Visitor 役の訪問先を表す役です。 訪問者を受け入れるacceptメソッドを 宣言します。 accept メソッドの引数にはVisitor役が渡されます。 サンプルプログラムで は、Element インタフェースがこの役をつとめました。

コンクリート・エレメント Concrete Element (具体的要素)の役

ConcreteElement役は、Element 役のインタフェース (API) を実装する役です。 サンプ ルプログラムでは、 FileクラスやDirectoryクラスがこの役をつとめました。

ObjectStructure (オブジェクトの構造) の役

オブジェクト・ストラクチャ

ObjectStructure 役は、 Element役の集合を扱う役です。 Concrete Visitor 役が個々の Element役を扱えるようなメソッドを備えています。 サンプルプログラムでは、 Directory クラ スがこの役をつとめました (一人二役です)。 Concrete Visitor役が個々のElement 役を扱 えるように、サンプルプログラムのDirectoryクラスにはiteratorメソッドが用意され ています。

エレメント

211

第13章 Visitor構造を渡り歩きながら仕事をする

Fig.13-4 Visitor パターンのクラス図

Visitor visit (ConcreteElementA) visit (ConcreteElementB) ConcreteVisitor visit (ConcreteElementA) Element ObjectStructure accept visit (ConcreteElementB) Concrete ElementA ConcreteElementB accept accept

あなたの考えを広げるためのヒント

ダブルディスパッチ

Visitorパターンでのメソッド呼び出しを整理しましょう。 accept (受け入れ) メソッドは以下のような呼び出しになります

。 element.accept (visitor)

一方、 visit (訪問) メソッドは次のような呼び出しになります。

visitor.visit (element)

この2つを見比べると、ちょうど反対の関係にありますね。 element はvisitor を accept し visitor は element を visitしています。

Visitorパターンでは、 ConcreteElement役と Concrete Visitor 役の組によって実際の処理 が決定します。 これを一般にダブルディスパッチ (double dispatch:二重の振り分け)と 呼びます。

なぜこんなに複雑なことをするのか

処理の流れが頭に入るまで 「Visitorパターンは話を複雑にしているだけじゃないか」と 感じるかもしれません。 「繰り返しの処理が必要なら、 データ構造の中にループを書けば いいではないか。 どうして accept だの visitだのと、複雑なメソッド呼び出しをしなけ ればならないの?」 と、 思いませんか。

212

あなたの考えを広げるためのヒント 213

Visitorパターンの目的は、 処理をデータ構造から分離することです。 データ構造は、要 素を集合としてまとめたり、 要素間をつないだりしてくれる大事なものです。 しかし、そ の構造を保持しておくことと、その構造を基礎とした処理を書くことは別のものです。

サンプルプログラムでは、 一覧表示という処理を行う Concrete Visitor役として、 List Visitor クラスを作りました。 また練習問題では、他の処理を行う Concrete Visitor役を作 ります。 一般に、 Concrete Visitor 役は、 File クラスやDirectoryクラスとは独立して開 発することができます。 つまり、 Visitorパターンは、 File クラスやDirectoryクラスの 部品としての独立性を高めていることになります。 もし、 処理の内容をFileクラスや Directoryクラスのメソッドとしてプログラムしてしまうと、 新しい 「処理」を追加して 機能拡張したくなるたびに、 Fileクラス (List 13-4) や Directoryクラス (List 13-5) を修正しなければならなくなりますね。

| The Open-Closed Principle拡張については開き、修正については閉じる

オープンクローズ・プリンシプル 機能拡張と修正の話が出たところで、 The Open-Closed Principle (OCP) という原則につ いてお話しましょう。この原則は、Bertrand Meyerによって提示されたもので、 Robert C. Martin が C++ Report (Jan. 1996) に書いたEngineering Notebookというコラム にまとめられています。

この原則は、クラスなどが、

拡張 (extension) については開かれている (open) が、

・修正 (modification) については閉じられている (closed)

べきだと主張しています。

クラスを設計するときには、特別の理由がない限り、 将来の拡張を許すようにしなけれ ばならない。 理由なく拡張を禁止してはいけない。 それが 「拡張については開かれている」 という意味です。

しかし、拡張を行うたびに、 既存のクラスを修正しなくてはならないようでは困ります。 拡張を行っても既存のクラスは修正する必要がない、というのが 「修正については閉じら れている」という意味です。

拡張は大歓迎。 でも既存のクラスを修正しては駄目。 既存のクラスを修正せずに拡張で きるようにせよ。・・・これがThe Open-Closed Principle という原則なのです。 これまでの章でデザインパターンを学んできたあなたは、この原則を読んで「そのとお り」 と大きくうなずかれるのではないでしょうか。

クラスに対する要求は頻繁に変化します。 そしてその要求は、たいていは 「機能を拡張 してほしい」というものです。 そんなときに、クラスが機能拡張に耐えられないようにな

第1章 Visitor 構造を渡り歩きながら仕事をする

っていては困ります。 しかし一方で、すでに作り上げ、 テストまですんでいるクラスに修 正を加えてしまっては、ソフトウェアの品質を下げてしまう危険があります。

拡張については開かれており、修正については閉じられているようなクラスは、 部品と しての再利用性が高いクラスです。 そして、 デザインパターンの目的、 オブジェクト指向 の目的というのは、まさにそのようなクラスを作る仕組みを提供することなのです。

| ConcreteVisitor役の追加は簡単

新しい Concrete Visitor役を追加するのは簡単です。 具体的な処理は Concrete Visitor 役に まかせてしまうことができ、その処理のためにConcrete Element役を修正する必要はまっ たくないからです。

| ConcreteElement役の追加は困難

ConcreteVisitor 役の追加は簡単ですが、 ConcreteElement役の追加は困難です。 例えば、サンプルプログラムで、 EntryクラスのサブクラスとしてDeviceクラスを追 加したいとしましょう。 つまり Device クラスは、 FileクラスとDirectoryクラスの兄弟 にあたるわけです。 そのとき、 Visitor クラスにはvisit (Device) メソッドを作る必要が 生じます。 そして、 Visitorクラスのサブクラス全部に新たに visit (Device) メソッドを 実装しなければならなくなります。

Visitor が処理するためには何が必要か

Visitor パターンでは、データ構造の要素に対する処理を切り出して Visitor役にまかせま す。このようにしてデータ構造とその要素に対する処理が分離できます。 ･･･というのは結 構な話ですが、 Element 役はVisitor役に対して十分な情報を公開する必要があります。

例えば、サンプルプログラムでは、 visit (Directory) の中で、 個々のディレクトリエン トリに対して accept を実行しています。 このような処理を実現するためには、Directory が 「個々のディレクトリエントリを得る」ための iteratorメソッドを提供する必要があ ります。

訪問者はデータ構造から必要な情報を取得して働きます。 必要な情報が得られないと、 訪問者はうまく働くことができません。 その半面、 公開すべきではない情報までを公開し てしまうと、 将来データ構造を改良するのが難しくなります。

214

この章で学んだこと

関連しているパターン

Iterator パターン (第1章) IteratorパターンもVisitorパターンも、あるデータ構造の上で処理を行うものです。 Iterator パターンは、データ構造が保持している要素を1つ1つ得るのに使います。 Visitorパターンは、データ構造が保持している要素に特定の処理をほどこすのに使いま す。

Composite パターン (第11章)

訪問先となるデータ構造は、 Composite パターンになる場合があります。

Interpreter パターン (第23章)

Interpreterパターンでは、 Visitorパターンが使われる場合があります。 例えば構文木を 作った後、 構文木の各ノードを巡回しながら処理を行うようなときです。

この章で学んだこと

この章では、 データ構造を巡り歩きながら処理を行うVisitorパターンについて学びまし た。

215

第13章 Visitor構造を渡り歩きながら仕事をする

練習問題

216

解答は付録A (p.445)

▶問題13-1

本章のサンプルプログラムに追加するクラスとして、 FileFindVisitorクラスを作っ てください。 このクラスは、指定された拡張子のファイルを集めるものとします。 FileFindVisitorクラスはList 13-8のように使うものとします。 FileFindVisitor クラ スの実行結果をFig.13-5に示します。 ここでは拡張子が.htmlのファイルを集めています。

List 13-8 Main 5x (Main.java)

1: import java.util.Iterator;

3: public class Main ( public static void main(String[] args) { Directory rootdir = new Directory("root"); Directory bindir = new Directory ("bin"); Directory tmpdir = new Directory ("tmp"); Directory usrdir = new Directory("usr"); rootdir.add (bindir); rootdir.add(tmpdir); rootdir.add(usrdir); bindir.add(new File("vi", 10000)); bindir.add(new File("latex", 20000)); 4: 5: 6: 7: 8: 9: 10: 11: 12: 13:

14:

15:

16:

Directory yuki =new Directory("yuki"); Directory hanako new Directory ("hanako"); Directory tomura = new Directory ("tomura"); usrdir.add(yuki);

17:

18:

19:

20:

usrdir.add(hanako);

usrdir.add(tomura);

21:

22:

23:

yuki.add(new File("diary.html", 100)); yuki.add(new File("Composite.java", 2001); hanako.add(new File("memo.tex", 300)); hanako.add(new File("index.html", 350));

24:

tomura.add(new File("game.doc", 400));

25:

26:

tomura.add(new File("junk.mail", 500));

27:

28:

29:

FileFindVisitor ffv = new FileFindVisitor (.html"); rootdir. accept (ffv);

30:

31:

System.out.println("HTML files are: ");

for (File file: ffv.getFoundFiles()) {

32:

System.out.println(file);

33:

34:

35:

36: )

2:

Fig.13-5 実行結果

HTML files are:

diary.html (100)

index.html (350)

問題13-2

サンプルプログラムのDirectoryクラス (List 13-5) の getSizeメソッドでは、 「サイ 「ズを得る」 処理を行っています。 「サイズを得る」 処理を行う SizeVisitorクラスを導入 し、DirectoryクラスのgetSizeメソッドを書き換えてください。

問題13-3

java.nio.fileパッケージには、Visitorパターンを使ってファイルシステム中のディレ クトリやファイルを訪問するクラスライブラリが含まれています。

例えば、 FilesクラスのwalkFileTree メソッドは、与えられたファイルシステムを訪 問する staticメソッドです。 このメソッドには訪問の起点となるPathと、 訪問に使う FileVisitor<T> を引数として与えます。

java.nio.fileパッケージには、 FileVisitor<T> を実装するプログラマの便宜を図る ためsimpleFileVisitor<T> というシンプルなクラスも用意されています。プログラマは SimpleFileVisitor<T> のサブクラスを宣言し、 以下のメソッドのうち必要なものだけを オーバーライドすることで、 ファイルシステム中のディレクトリやファイルを訪問するプ ログラムを容易に作ることができます。

217

FileVisitResult preVisit Directory (T dir, BasicFile Attributes attrs) ディレクトリ dir を訪問する前に呼び出されるメソッド

FileVisitResult postVisitDirectory (T dir, IOException e) ディレクトリ dirのすべてのエントリを訪問した後に呼び出されるメソッド FileVisitResult visitFile (T file, BasicFileAttributes attrs) ファイルfile を訪問するときに呼び出されるメソッド

FileVisitResult visitFileFailed (T file, IOException e)

ファイルfile を訪問できなかったときに呼び出されるメソッド

List 13-9 は、 コマンドラインで与えられたディレクトリ以下にある実際のディレクトリ とファイルを表示するプログラムの概略で、あちこちが...で省略されています。 この プログラムを修正して正しく動くようにしてください。

Java

章 Visterを預り歩きながら仕事をする

第13

List 13-9 Main 757 (Main.java)

1: 2: 3: class MyFileVisitor extends SimpleFileVisitor<Path> { preVisit Directory (Path dir,) throws IOException ( System.out.println("dir: dir); + return FileVisitResult.CONTINUE; 4: 5: 6: 7: 8: 9: 10: 11: 12: } 13: ) 14: visitFile(Path file, ) throws IOException { System.out.println("file: +file); return FileVisitResult.CONTINUE; 15: public class Main ( 16: 17: 18: 19: 20: public static void main(String[] args) { if (args.length != 1) ( System.out.println("Usage: java Main dirname"); System.out.println("Example: java Main ."); System.exit(0); 21: 22: 23: String dirname = args[0];

24:

) 33:) try { MyFileVisitor visitor = new MyFileVisitor (); Path root Path. of (dirname); Files.walkFileTree (root, visitor); } catch (IOException e) { e.printStackTrace();

26:

31:

28:

29:

30:

27:

32:

25:

218

練習問題 219

問題13-4

サンプルプログラムのDirectoryクラス (List 13-5) は、 Iterable<Entry> インタフ ェースを実装しています。 もしも、 implements Iterable<Entry> の部分をソースコー ドから削除したら、どんな不都合が起きるでしょうか。

Java



第14章

Chain of Responsibility

責任のたらい回し

222 第14章 Chain of Replity 責任のたらい回し

Chain of Responsibility パターン

たらい回しについて考えます。 ある書類をもらいに会社に出かけたとします。 会社の受 付で聞いたところ、「営業窓口」に行ってほしいといわれました。 そこで営業窓口に行く と、その書類は「ユーザサポート部」 で扱っているといわれました。 そこでユーザサポー 卜部に行くと、その書類は「文書センター」 で入手できるといわれてしまいました。やれ やれ、と思いつつ文書センターに行くと･･･。 こんな風に、 適切な人にたどり着くまで、 次 の人、次の人…に自分の要求が送られていく、これが 「たらい回し」 です。

たらい回しという言葉は否定的な意味合いが強いですが、 まさに 「たらい回し」と表現 したくなる処理が必要になる場合があります。 ある要求が発生したときに、 その要求を処 理するオブジェクトを固定的に決められない場合です。 そのようなとき、 複数のオブジェ クトを鎖(チェーン) のようにつないでおき、そのオブジェクトの鎖を順次渡り歩いて、 目的のオブジェクトを決定する方法が考えられます。 くさわ

このようなパターンを

チューン・オブ・レスポンシビリティ

Chain of Responsibility パターン

と呼びます。 responsibility というのは責任のことですから、日本語でいえば 「責任の連鎖」 ということですが、 要するに、 「たらい回し」 を行う構造と考えた方が覚えやすいですね。 このパターンを使うと 「要求する側」と「処理する側」の結びつきを弱めることができ、 それぞれを部品として独立させることができます。 また、 状況によって要求を処理するオ プジェクトが変化するようなプログラムにも対応することができます。

人に要求がやってくる。 その人がそれを処理できるなら処理する。 処理できないなら、そ の要求を「次の人」 にたらい回しする。 次の人がそれを処理できるなら処理する。 処理でき ないなら、その要求を 「さらに次の人」 にたらい回しする。そして、さらに次の人へ･･･、こ れが Chain of Responsibilityパターンです。

サンプルプログラム

Chain of Responsibilityパターンを使ったサンプルプログラムとして、発生したトラブル を誰かが解決しなければならない状況を考えてみましょう。 登場するクラスを Table 14-1 に示します。

サンプルプログラム

Table 14-1 クラス一覧

名前 Trouble Support 解說 発生したトラブルを表すクラス。 トラブル番号 (number) を持つ トラブルを解決する抽象クラス NoSupport Limit Support OddSupport Special Support Main トラブルを解決する具象クラス (常に 「処理しない」) トラブルを解決する具象クラス (指定した番号未満のトラブルを解決 ) トラブルを解決する具象クラス (奇数番号のトラブルを解決 ) トラブルを解決する具象クラス (特定番号のトラブルを解決 ) Support たちの連鎖を作り、 トラブルを起こす動作テスト用のクラス

| Fig.14-1 サンプルMain Request▸ Support -name -next +support +setNext #resolve NoSupport LimitSupport -limit #resolve #resolve #resolve OddSupport Special Support -number #resolve

プログラムのクラス図

| Trouble クラス

Troubleクラス (List 14-1) は、 発生したトラブルを表現するクラスです。 numberは トラブル番号です。 getNumberメソッドでトラブル番号を得ます。

List 14-1 Trouble クラス (Trouble.java)

1: public class Trouble ( 2: 3: 4: 5: 6: private int number; // トラブル番号 // トラブルの生成 public Trouble (int number) ( this.number = number;

223

224 第14章 Chain of Responsibility責任のたらい回し

7:

8:

9:

// トラブル番号を得る

10:

11:

public int getNumber() {

return number:

12:

13:

14:

15:

// トラブルの文字列表現

16:

@Override

public String toString() {

return [Trouble

+ number + "]";

17:

18:

19: )

| Support クラス

Supportクラス (List 14-2) は、 トラブルを解決する連鎖を作るための抽象クラスです。 nextフィールドは、たらい回しする先を指します。 setNext メソッドはたらい回しす る先を設定します。

resolve メソッドは、サブクラスで実装することを想定した抽象メソッドで、「トラブ ルを解決しようとする」 処理を表します。 戻り値が trueのときにはトラブルが解決され たことを表し、 falseのときにはトラブルはまだ解決されていない (すなわち、 次にたら い回しする)ことを表すことにします。 resolve とは 「解決する」という意味です。 リゾルグ

support メソッドは、 resolve メソッドを呼び出し、 戻り値が false なら、 「次の人」 にたらい回しします。 「次の人」 がいない場合には、自分が連鎖の最後であり、誰も解決 できなかったことになるので、そのことを表示します。 ここでは表示するだけですませて いますが、プログラムによっては例外を投げる方が適切なこともあるでしょう。

ちなみに、このsupportメソッドは、 抽象メソッド resolveを使った Template Method パターン(第3章) になってますね。

}

List 14-2 Support クラス (Support.java)

1: public abstract class Support { private String name; // このトラブル解決者の名前 2: 3: private Support next; // たらい回しの先 4: 5: public Support (String name){ 6: this.name = name; 7: this.next = null;

サンプルプログラム

// たらい回しの先を設定する public Support set Next (Support next) ( this.next next; return next; ) 13: 14: )

15:

16:

// トラブル解決の手順を定める

17:

public void support (Trouble trouble) ( if (resolve (trouble)) ( done (trouble);

19:

18:

20:

21:

22:

23:

) else if (next != null) (

next.support (trouble);

) else (

fail (trouble);

24:

25:

// トラブル解決者の文字列表現

@Override

27:

26:

28:

public String toString() {

return [name]";

30:

}

29:

31:

32:

33:

// 解決しようとする

35: 36: // 解決した 37: protected void done (Trouble trouble) ( 38: System.out.println(trouble is resolved by +this+ ."); 39: } 40: 41: 42: 43: // 解決しなかった protected void fail (Trouble trouble) ( System.out.println(trouble + cannot be resolved."); 44: } 45: )

34:

11:

NoSupport クラス

8:

12:

protected abstract boolean resolve (Trouble trouble);

NoSupport クラス (List 14-3) は Supportクラスのサブクラスです。 NoSupport クラス resolve メソッドは常に false を返します。 すなわち、 自分は何も問題を解決しないと

225

10:

9:

9

| LimitSupport クラス

Limit Support クラス (List 14−4) クラスです。 resolve メソッドでは、判断の後、 来ならばここでトラブルを解決してやる」必要があります。 limitで指定した番号未満のトラブルを解決する 本 返しているだけですが、

List 14-4 LimitSupport 52 (LimitSupport.java

1: public class Limit Support extends Support private int limit; // この番号未満なら解決できる public Limit Support (String name, int limit) [ super (name); this.limit limit; 2: 3: 4: 5: 6: 7: 8:

9:

10:

Override

11:

protected boolean resolve (Trouble trouble) ( if (trouble.getNumber() < limit) {

12:

return true;

13:

} else (

14:

return false;

15:

16:

17: )

サンプルプログラム

| OddSupport クラス

Oddsupport クラス (List 14-5) は、 奇数番号のトラブルを解決するクラスです。 2: 3: List 14-5 OddSupport 757 (OddSupport.java) 1: public class OddSupport extends Support ( public OddSupport (String name) ( super (name); 4: } 5: 6: 7: 8: 9: 10: @Override protected boolean resolve (Trouble trouble) ( if (trouble.getNumber() 2 == 1) { return true; } else { 11: return false; 12: } 13: 14: }

SpecialSupport クラス

Special Support クラス (List 14-6) は、指定した番号のトラブルに限って解決するク ラスです。

List 14-6 SpecialSupport 52 (SpecialSupport.java)

: public class Special Support extends Support { private int number; // この番号だけ解決できる public Special Support (String name, int number) ( super (name); this.number number; : 3: 4: 5: 6: 7: 8: 9: @Override 10: 11: 12: 13: protected boolean resolve (Trouble trouble) ( if (trouble.getNumber() == number) ( return true; } else {

12

227

第14章 Chain of Responsibility 責任のたらい回し

14:

return false;

15:

16:

17: }

| Mainクラス

Main クラス (List 147) では まずAlice ~Fredの6人のトラブル解決者を作成します。 ここではすべてSupport 型の変数を使っていますが、 実際に代入されているのは、 Nosupport, LimitSupport, SpecialSupport, Oddsupport の各クラスのインスタンスです。

次に、setNext メソッドを使ってAlice ~ Fred を一列に並べます。 それから、トラブル を1個ずつ作成して順次aliceに渡し、誰がそのトラブルを解決するかを表示しています。 ここで、トラブル番号は0からはじめて33ずつ増加させていますが、 33ずつ増加させて いることに特に意味はありません。 乱数を使っても面白いでしょう。

List 14-7 Main クラス (Main.java)

1: public class Main { public static void main(String[] args){ Support alice Support bob = new NoSupport ("Alice"); = new LimitSupport ("Bob", 100); Support charlie = new Special Support ("Charlie", 429); Support diana = new LimitSupport ("Diana, 200); 2: 3: 4: 5: 6: 7: Support elmo = new Oddsupport ("Elmo"); 8: Support fred = new LimitSupport ("Fred", 300); 9: 10: 11: 12: 13: 14: 15: // 連鎖の形成 alice.setNext (bob).setNext (charlie).setNext (diana).setNext (elmo).setNext (fred): // さまざまなトラブル発生 for (int i = 0; i < 500; i += 33)( alice.support (new Trouble (i)); 16: } 17: } 18: )

228

サンプルプログラム

| Fig.14-2 実行結果

[Trouble 0] is resolved by [Bob]. [Trouble 33] is resolved by [Bob]. [Trouble 66] is resolved by [Bob]. [Trouble 99] is resolved by [Bob]. [Trouble 132] is resolved by [Diana]. [Trouble 165] is resolved by [Diana]. [Trouble 198] is resolved by [Diana]. [Trouble 231] is resolved by [Elmo]. [Trouble 264] is resolved by [Fred]. [Trouble 297] is resolved by [Elmo]. [Trouble 330] cannot be resolved. [Trouble 363] is resolved by [Elmo]. [Trouble 396] cannot be resolved. Trouble 429) is resolved by (Charlie). [Trouble 462] cannot be resolved. [Trouble 495] is resolved by [Elmo].

実行結果 (Fig.14-2) を見てみましょう。 最初はBob ががんばっていますが、 解決でき なくなるとDiana が登場しはじめますね。 実行結果には、 Alice はまったく登場しません。 Alice はすべてのトラブルをたらい回ししているからです。 トラブル番号が300以上にな ると、このプログラムのLimitSupportのインスタンス (Bob, Diana, Fred) は誰も処 理できなくなります。 300以上でも、奇数番号のトラブルに限り、 OddSupport クラスの Elmoが処理してくれていますね。 Special SupportクラスのCharlie は、 トラブル番号 429の解決専門で、実行結果には一度だけ顔を出しています。

363番のトラブルを処理しているときのシーケンス図をFig.14-3に示します。このシー ケンス図は、 support メソッドの呼び出しに焦点を当てて描いています。 実際には次の support メソッドを呼び出す前に、 自分自身の resolveメソッドを呼び出しています。

229

第14章 Cafebility責任のたらい回し

Fig.14-3 [Trouble 363] を処理しているサンプルプログラムのシーケンス図

Main alice bob charlie diana support support support support support elmo

fred

Chain of Responsibility パターンの登場人物

Chain of Responsibilityパターンの登場人物は、次のとおりです。

◆Handler (処理者)の役

Handler 役は、要求を処理するインタフェース (API)を定める役です。 次の人」を保 持しておき、自分で処理ができない要求がきたら、その人にたらい回しします。 もちろん、 「次の人」 もHandler役です。 サンプルプログラムでは、 Support クラスがこの役をつとめ ました。 要求を処理するメソッドはsupportメソッドでした。

コンクリート・ Concrete Handler (具体的処理者)の役

Concrete Handler 役は、要求を処理する具体的な役です。 サンプルプログラムでは、 NoSupport, LimitSupport, Oddsupport, SpecialSupportの各クラスが、この役をつ とめました。

クライアント Client (要求者)の役

Client 役は、最初の ConcreteHandler役に要求を出す役です。 サンプルプログラムでは、 Main クラスがこの役をつとめました。

Chain of Responsibilityパターンをクラス図で表記すると、 Fig.14-4のようになります。

230

あなたの考えをめ

Fig.14-4 Chain of Responsibility パターンのクラス図 Request▸ Client next request ConcreteHandler1 request Handler Concrete Handler2 request

あなたの考えを広げるためのヒント

| 要求を出す人と要求を処理する人をゆるやかに結びつける

Chain of Responsibilityパターンのポイントは、 要求を出す人 (Client役) と要求を処理 する人 (Concrete Handler 役) をゆるやかに結びつけるところにあります。 Client 役は、 最初の人に要求をポンと出してしまう。 すると、あとは連鎖の中をその要求が流れていき 適切な処理者によって要求が処理されることになります。

もしもこのパターンを使わないと、 「この要求はこの人が処理すべし」という知識を誰 かが中央集権的に持っている必要があります。 その知識を 「要求を出す人」に持たせるの はあまり賢明ではありません。 要求を出す人が処理者たちの役割分担の詳細まで知らなけ ればならないとすると、 部品としての独立性が損なわれてしまうからです。

[補足] サンプルプログラムでは、単純化のために Client 役のMainクラスに対して最初の連鎖形成 の仕事を負わせています。

231

Responsibility責任のたらい回し

動的に連鎖の形態を変える

サンプルプログラムでは、 AliceからFredまでのサポートチームはいつも固定した順序 になっていました。 しかし、要求を処理する Concrete Handler 役のオブジェクトの関係が 動的に変化するような状況も考えられます。 Chain of Responsibility パターンのように委譲 によってたらい回しを行っていれば、 状況の変化に応じてConcrete Handler役を組み替え ることができます。

もしも、 Chain of Responsibilityパターンを使わず、 プログラムの中に「この要求ならこ の処理者」という対応関係が固定的に書かれていたら、プログラムが動いている最中に処 理者を変更することは難しくなります。

GUIアプリでは、ユーザがアプリの画面上にコンポーネント (ボタンやテキスト入力フィ ールド) を自由に追加できる場合があります。 このようなときには Chain of Responsibility パターンが有効に働きます。

自分の仕事に集中できる

「たらい回し」というのは否定的なニュアンスが強いですが、 言い換えれば、各オブジ ェクトが 「自分の仕事に集中できる」 ということでもあります。 個々のConcrete Handler 役は、自分のできる仕事に集中する。 自分ができなかったら、あっさりと「次の人、 お願 いね」 と渡してしまう。 そうすれば、 個々のConcrete Handler 役で書くべき処理は、その Concrete Handler役に固有の内容に絞り込めることになります。

Chain of Responsibilityパターンを使わないとしましょう。 この場合には、 「偉い人が1 人いて、 誰が要求を処理するかをすべて決定する」 という方法をとることになります。 あ るいは、 「自分が処理できなかったら、 あの人にまかせる。 もしもそれでも駄目ならこの 人、 システムの状況がこうならあっちの人」 という 「仕事の振り分け」の仕事まで個々の Concrete Handler役に背負わせる方法をとることになってしまいます。

たらい回しで処理は遅くならないのか

Chain of Responsibilityパターンを使ってたらい回しを行い、 適切な処理を行う相手を探 すというのは、確かに柔軟性は高いかもしれませんが、 処理が遅くなってしまうのではな いでしょうか。

そのとおりです。 誰が要求を処理すべきかが前もって定まっており、 その相手がすぐに 処理をする場合と比較すると、 Chain of Responsibilityパターンを適用した場合の処理は遅 くなるでしょう。

232

この章で学んだこと 233

しかし、これは何を優先するかというトレードオフの問題です。 要求と処理者の関係が 固定的で、しかも処理速度が非常に重要な場合には、 Chain of Responsibilityパターンを使 わない方が有効な場合もあるでしょう。

関連しているパターン

Composite パターン (第11章) Handler役には Composite パターンが登場することがよくあります。

Command パターン (第22章) Handler 役に対して投げられる 「要求」 には、 Commandパターンが使われる場合があ ります。

この章で学んだこと

この章では、要求を処理するインスタンスを鎖状に並べておき、 要求を処理できるかど うかを順番にチェックしていく「たらい回し」のパターンであるChain of Responsibility パ ターンについて学びました。

Chain of Responsibilityパターンは、 GUIアプリなどによく使われます。 練習問題でその 具体例を考えてみましょう。

第14章 Chai Retility責任のたらいし

練習問題

●問題 14-1

GUIアプリでは、 Chain of Responsibilityパターンがよく使われます。

解答は付録A (p.452)

GUIアプリの上には、ボタンやテキストボックス、チェックボックスなどのコンポーネ ント (ウィジェット コントロールなどと呼ばれることもあります) が載っています。 コ ンボーネントをクリックしたときに生じるイベントは、どのようにたらい回しされるでし よう。 Chain of Responsibilityパターンにおける 「next」 (たらい回しする先) はどこに登 場しますか。

●問題 14-2

サンプルプログラムのSupportクラス (List 14-2) では、 support メソッドはpublic になっていますが、 resolve メソッドはprotectedになっています。 この使い分けには設 計者のどのような意図が表現されていますか。

●問題 14-3

サンプルプログラムの support メソッド (List 14-2) を、 再帰的に呼び出すのではなく、 ループで展開してみましょう。

Java

234

第15章 Facade

シンプルな窓口

236 第15章 Facade -シンプルな窓口

Facade パターン

プログラムというものは、だんだん大きくなっていく傾向があります。 たくさんのクラ スが作られ、 相互に関係し合い、 複雑になっていきます。 クラスを使う場合には、クラス の間の関係を正しく理解して、 正しい順番でメソッドを呼び出す必要があります。

大きなプログラムを使って処理を行うためには、関係し合っているたくさんのクラスを 適切に制御しなければなりません。だとすると、その処理を行うための 「窓口」を用意し ておくのがいいですね。 そうすれば、たくさんのクラスを個別に制御しなくても、その 「窓口」 に対して要求を出すだけで仕事がすむからです。

そのような「窓口」 が、この章で学ぶ

ファサード Facade パターン

です。

facadeはフランス語のfaçade を語源とする単語で、「建物の正面」 という意味です(発 音するときはファサードの 「サ」にアクセントを置きます)。

Facadeパターンは、複雑にからみ合ってごちゃごちゃした詳細をまとめ、高レベルの インタフェース (API) を提供します。 Facade役は、システムの外側に対してはシンプル なインタフェース (API) を見せます。 また、 Facade役はシステムの内側にある各クラス の役割や依存関係を考えて、正しい順番でクラスを利用します。

この章では、シンプルな窓口であるFacadeパターンについて学びましょう。

サンプルプログラム

ここで作るサンプルプログラムは、ユーザのWebページを作成するものです。

Facadeパターンのサンプルを作るためには、 本来、 「複雑に入り組んだたくさんのクラス」 が必要になります。 しかし、ここではサンプルプログラムを短くするために、3つのクラス だけからなる簡単なシステムを考えます。 このシステムは、メールアドレスから名前を得 るデータベース (Database) HTMLファイルを作成するクラス (HtmlWriter)、 それから Facade役として高レベルのインタフェース (API) を提供するクラス (PageMaker) で構成 されています。

サンプルプログラムが作るWebページをFig.15-1に示します。

クラス一覧を Table 15-1 に、 UMLによるクラス図をFig.15-2に示します。

各クラスのソースファイルは、 Fig.15-3に示すディレクトリ上に置かれます。

サンプルプログラム

Fig.15-1 サンプルプログラムが作るWebページをブラウザで見た様子

Hiroshi Yuki's web page

Welcome to Hiroshi Yuki's web page!

Nice to meet you!

Hiroshi Yuki

Table 15-1 クラス一覧

パッケージ pagemaker pagemaker pagemaker 無名 名前 解說 Database メールアドレスからユーザ名を得るクラス HtmlWriter HTMLファイルを作成するクラス PageMaker Main メールアドレスからユーザのWebページを作成するクラス 動作テスト用のクラス

Fig.15-2 サンプルプログラムのクラス図

Main Uses ▼ PageMaker makeWelcome Page Uses▼ Uses▾ HtmlWriter writer title paragraph link mailto close Database getProperties

237

15 Facade-

Fig.15-3 ソースファイルを置くディレクトリ

Main.java -maildata.txt pagemaker -Database.java -HtmlWriter.java PageMaker.java

Databaseクラス

Databaseクラス (List 15-1) は、 データベース名 (例えば "maildata") を指定して、 それに対応したProperties を作成するクラスです。 Database クラスは、 java.util. Propertiesクラスを簡易データベースに見立て、メールアドレスと名前の組をデータフ ァイル(例えば *maildata.txt") として管理します。 Database クラスはPropertiesの インスタンスは作らず、 getProperties というstaticメソッドを介してPropertiesの インスタンスを得ています。 List 15-2にデータファイルの例を示します。

List 15-1 Database 757 (Database.java)

1: package pagemaker; 2: 3: import java.io.FileReader; 4: import java.io.IOException; 5: import java.util.Properties; 6: 7: public class Database { 8: 9: 10: 11: 12: 13: 14: 15: 16: 17: 18: ) private Database() { // データベース名から Properties を得る public static Properties getProperties (String dbname) throws IOException { String filename dbname + ".txt"; Properties prop new Properties(); prop. load (new FileReader (filename)); return prop;

238

サンプルプログラム

List 15-27-3771 (maildata.txt)

hyuki@example.com-Hiroshi Yuki hanako@example.com-Hanako Sato tomura@example.com-Tomura mamoru@example.com-Mamoru Takahashi

HtmlWriterクラス

HtmlWriter (List 15-3) は、簡単なWebページを作成するクラスです。 インスタンス 作成時にWriter を与えておき、そのWriterに対してHTMLを出力します。 titleはタイトルを出力するメソッド、 paragraphは段落を出力するメソッド、 link は リンクを出力するメソッド mailtoはメールアドレスのリンクを出力するメソッド、そ して、 close はHTMLの出力を終えるメソッドです。

このクラスには、 title メソッドを一番最初に呼ばなければならないという制約が隠れて います。 そして、 窓口となるPageMakerクラスは、その制約を守るように書かれています。

List 15-3 HtmlWriter >>7 (HtmlWriter.java)

1: package pagemaker;

2:

3: import java.io.Writer;

4: import java.io.IOException;

5:

6: public class Html Writer (

private Writer writer;

8:

public Html Writer (Writer writer) (

this.writer writer;

7:

9:

10:

11:

12:

}

13:

14:

15:

16:

17:

18:

19:

// タイトルの出力 public void title (String title) throws IOException { writer.write("<!DOCTYPE html>"); writer.write("<html>"); writer.write("<head>"); writer.write("<title> title + "</title>"); writer.write("</head>"); writer.write('<h1> title + "</h1>"); writer.write("<body>"); writer.write("\n");

20:

21:

22:

239

第15章 Facade - シンプルな

23:

writer.write("\n");

24:

public void paragraph (String msg) throws IOException {

writer.write("<p>" + msg + "</p>");

25:

26:

27:

// 段落の出力

28:

29:

writer.write("\n");

30:

31:

32:

)

// リンクの出力

33:

public void link (String href, String caption) throws IOException (

34:

35:

paragraph ("<a href=\** + href + "\">" + caption + "</a>");

36:

// メールアドレスの出力

37:

38:

public void mailto (String mailaddr, String username) throws IOException { link("mailto:" + mailaddr, username);

39:

40:

41:

// 閉じる

42:

43:

public void close() throws IOException {

44:

writer.write("</body>");

writer.write("</html>");

45:

writer.write("\n");

46:

47:

writer.close();

48:

49: )

PageMaker クラス

PageMakerクラス (List 15-4) は、 DatabaseクラスとHtmlWriterクラスを組み合わせ て、指定したユーザのWebページを作成するためのものです。

このクラスで定義されているpublicなメソッドはmakeWelcomePageだけです。このメ ソッドにメールアドレスと出力ファイル名を指定するだけで、 Webページが作成されます。 HtmlWriter クラスのメソッドをごちゃごちゃ呼ぶところは、この PageMaker クラスが 一手に引き受け、外部に対してはたった1つのmakeWelcomePage メソッドだけを見せ ているのです。 ここがシンプルな窓口です。

List 15-4 PageMaker クラス (PageMaker.java)

1: package pagemaker;

240

サンプルプログラム

2:

3: import java.io.FileWriter;

4: import java.io.IOException; 5: import java.util.Properties;

6:

7: public class PageMaker (

8:

private PageMaker () {

10: 11: 12: 13: 14: public static void makeWelcome Page (String mailaddr, String filename) ( try ( Properties mailprop Database.getProperties ("maildata"); String username = mailprop.getProperty (mailaddr); HtmlWriter writer = new Html Writer (new FileWriter (filename)); writer.title(username 's web page"); writer.paragraph ("Welcome to username + "'s web page! *); writer.paragraph ("Nice to meet you!"); writer.mailto (mailaddr, username); writer.close(); 15: 16: 17: 18: 19: 20: 21: username + ")"); 22: 23: 24: } 25: System.out.println(filename } catch (IOException e) { e.printStackTrace(); · ⚫ is created for +mailaddr + " (" + 26: }

9:

| Mainクラス

Mainクラス (List 15-5) は、 pagemakerパッケージのPageMakerクラスを利用します。 内容は、

PageMaker.makeWelcome Page ("hyuki@example.com", "welcome.html");

というシンプルな1文だけです。 hyuki@example.comさんの名前を調べ、 welcome.htmlと いうファイル名でWebページを作成しています。

List 15-5 Main 57 (Main.java)

1: import pagemaker. PageMaker; 2: 3: public class Main (

241

第15章 Facade -シンプルな

4:

public static void main(String[] args) {

5:

PageMaker.makeWelcomePage ("hyuki@example.com", "welcome.html);

6:

7: )

| Fig.15-4 コンパイルと実行結果

javac Main.java java Main welcome.html is created for hyuki@example.com (Hiroshi Yuki) (この後、welcome.htmlをブラウザで見ると Fig.15-5になる)

| Fig.15-5 welcome.htmlをブラウザで見た様子

Hiroshi Yuki's web page

Welcome to Hiroshi Yuki's web page!

Nice to meet you!

Hiroshi Yuki

Facade パターンの登場人物

Facadeパターンの登場人物は、次のとおりです。

719-F Facade (正面) の役

Facade役は、システムを構成しているその他おおぜいの役の 「シンプルな窓口」とな ります。 Facade役は、高レベルでシンプルなインタフェース (API) をシステム外部に提 供します。 サンプルプログラムでは、 PageMakerクラスがこの役をつとめました。

◆システムを構成しているその他おおぜいの役

その他おおぜいの役は、それぞれの仕事を行いますが、 Facade 役のことは意識しませ

)

242

Facadeパターンの登場人物

Facade役から呼び出されて仕事を行いますが、その他おおぜいの役の方からFacade 役 を呼び出すことはありません。 サンプルプログラムでは、 Database クラスとHtmlWriter クラスがこの役をつとめました。

クライアント Client (依頼人) の役

Facadeパターンを利用する役です (GoF本 (付録D [GoF] 参照) では、 Client役は Facadeパターンの中には含まれていません)。 サンプルプログラムでは、 Main クラスがこ の役をつとめました。

Fig.15-6 Facadeパターンのクラス図

ClassA Client Uses ▼ Facade ClassB ClassC ClassD

243

第15章 Facade シンプルな窓口

あなたの考えを広げるためのヒント

Facade役がやっていることは何だろう

Facade 役は、複雑なものを単純に見せています。 その 「複雑なもの」 って何でしょう。 裏方で働いているたくさんのクラスの関係や使い方が複雑なのですね。 Facade役は、 そ の複雑さを意識しないですむように気をつかいます。

ここでのポイントはインタフェース (API) を少なくすることです。 クラスやメソッド がたくさん見えていると、 プログラマはどれを使っていいか迷いますし、 また、 呼び出し の順番にも注意しなければなりません。 注意しなければならないということは、 間違えや すいということですね。 ですから、 インタフェース (API) が少ないFacade役を考えるの がいいのです。

インタフェース(API) の数が少ないというのは、外部との結合が疎である、とも表現 できます。 外部との結合が疎になっていると、 パッケージ (クラスの集合) を部品として 再利用しやすくしてくれます。

クラスを設計するときには、どのメソッドをpublicにするかを考えますね。あまり多 くのメソッドをpublicにしてしまうと、 クラス内部を修正しにくくなります。 フィール ドについてもそうです。 不用意にフィールドをpublicにしてしまうと、他のクラスがそ のフィールドの内容を勝手に参照したり変更したりするために、クラスの修正がしにくく なります。

クラスの設計と同様に、パッケージを設計するときには、どのクラスをpublicにする かを考える必要があります。 クラスを外 (パッケージの外) に見せすぎると、 パッケージ 内部を修正しにくくなります(このテーマは練習問題15-1でも考えます)。

再帰的なFacade パターンの適用

クラスから、より大きな単位であるパッケージに目を向けたところで、 さらに発想を広 げてみましょう。

Facade役を持ったクラスの集合が複数個あったとします。 そのとき、 それらの集合を まとめた新たなFacade役を導入することもできますね。 つまり、 Facadeパターンを再帰 的に適用するのです。

多数のクラス、多数のパッケージを抱える非常に大きなシステムに対しては、要所要所 にFacadeパターンを適用すると、 システムはより便利になるでしょう。

244

関連しているパターン

|プログラマがFacadeを作らない理由

心理的要因

ちょっと奇妙な話をします。 複雑なプログラムの内部を熟知しているプログラマは、も しかするとFacade役を作りたがらないかもしれません。 というか、 Facade役を作ること を無意識のうちに避けることがあるのです。

それは、なぜでしょうか。 その熟練プログラマの頭の中には、システムの内容がすべて 入っていて、たくさんのクラスの相互関係が手に取るようにわかっているからかもしれま せん。 あるいは自分の技術を誇り、他のプログラマに 「知ったかぶり」 をすることができ るからかもしれません。

あるプログラマが 「ああ、このクラスを呼ぶ前にはこっちを呼ぶんだよ。 こっちのメソ ッドの呼び出し前には、このクラスに登録しておく必要があるんだぜ」 といった話を 「得 「意げに」 語るときには、 Facade役を導入する必要があることを示唆しています。

はっきりと言葉で表現できるノウハウは、プログラマの頭の中に隠しておくべきもので はなく、コードとして表現しておくべきものなのです。

関連しているパターン

Abstract Factory パターン (第8章)

Abstract Factoryパターンは、 オブジェクト生成という複雑な作業に関する Facade パタ ーンと見なすことができます。 「オブジェクトを生成するには、 これさえ呼べばOK」とい ラインタフェース (API) を提供しているからです。

◆Singleton パターン (第5章)

Facade役は、 Singleton パターンとして作られる場合があります。

◆Mediator パターン (第16章)

Facadeパターンでは、 Facade 役が一方的に他の役を利用して高レベルなインタフェー ス (API) を作りました。

Mediatorパターンでは、 Mediator 役は Colleague役の仲介者としてやりとりを行います。 Facade パターンは一方向ですが、 Mediatorパターンは双方向といえるでしょう。

245

第15章 Facade シンプルな窓口

この章で学んだこと

この章では、複雑なシステムに対するシンプルな窓口の役を果たす Facadeパターンに ついて学びました。

練習問題

問題15-1

Java

解答は付録A (p.454)

将来の拡張やプログラムの改善に備えて、 pagemakerパッケージの外から利用できるの は PageMakerクラスだけにしたい、とクラス設計者は考えました。 Database クラスと HtmlWriterクラスをpagemakerパッケージの外から利用できないようにするには、サン プルプログラムをどのように変更したらいいですか。

問題15-2

Java

データファイル maildata.txt (List 15-2) に含まれているユーザのメールアドレスのリ リンク集を作成する makeLink Page メソッドを、 PageMakerクラスに追加してください。 呼 び出しはList 15-6のようになります。 作成されるリンク集はFig.15-8のようになるとし ます(画面はFig.15-9)。

List 15-6 Main クラス (Main.java)

1: import pagemaker.PageMaker; 2: 3: public class Main { 4: 5: 6: 7: ) public static void main(String[] args){ ) PageMaker.makeLinkPage ("linkpage.html");

246

練習 247

| Fig.15-7 コンパイルと実行結果

javac Main.java

java Main

linkpage.html is created.

この後、linkpage.html をブラウザで見るとFig.15-9 になる)

| Fig.15-8 作成されたlinkpage.html

<!DOCTYPE html> <html> <head> <title>Link page</title> </head> <body> <h1> Link page</h1> <p><a href="mailto:hanako@example.com" Hanako Sato</a></p> <p> <a href="mailto: tomura@example.com Tomura</a></p> <p> <a href="mailto: hyuki@example.com Hiroshi Yuki</a></p> <p><a href="mailto:mamoru@example.com Mamoru Takahashi</a></p> </body> </html>

Fig.15-9 linkpage.html をブラウザで見た様子

Link page

Hanako Sato

Tomura

Hiroshi Yuki

Mamoru Takahashi

問題15-3

サンプルプログラムのHtmlWriter クラス (List 15-3) では、 HTMLを記述するために たくさんの文字列リテラル (" "でくくられた文字列) が登場しました。 ところでJava に は、複数行にまたがる文字列リテラルを読みやすく記述するため、 テキストブロック (text block) があります。 その例を見てみましょう。

* Java 15で正式リリースされた機能です。

Java

248 第15章 Facade シンプルな窓口

テキストブロックは、 List 15-7のように二重引用符3個をペアにして作ります。 テキス トブロック開始の直後は改行でなくてはいけません。 その次の行から終了の... まで が文字列として扱われます。 ただし、各行先頭の空白は、 終了の･･･の字下げに合わせて 無視されます。テキストブロック中の"を\"のように書く必要はありません。 では、 List 15-7 を実行するとどのような出力になるでしょうか。

List 15-7 テキストブロックを使った例 (Main.java)

1: public class Main ( 2: public static void main(String[] args) { String html =*** <!DOCTYPE html> 3: 4: 5: <html> 6: <head> 7: <title>Welcome!</title> 8: </head> 9: <body> 10: 11: <h1 style="text-align: center">Hello, world!</h1> </body> 12: </html> 13: 14: System.out.print(html) 15: 16: )

第16章 Mediator

相手は相談役1人だけ

\I

\ \/

2

250 第16章 Mediator 相手は相談役1人だけ

Mediator パターン

もめているグループを想像してください。 同じ立場のメンバーが10人集まって、 共同作 業をしていますが、 なかなかまとまりがつきません。 メンバーが互いに指示を出し合って 作業は大混乱します。 また、 互いの作業の詳細に首を突っ込んで、もめごとが起こっていま す。 そんなところに、 立場の異なる 「相談役」 が登場して、 こういいました。 「メンバーの みなさんは、 相談役の私に状況を報告してください。そうしたら、 私は全体を考慮した上で みなさんに指示を出しましょう。 でも私は、みなさんの仕事の詳細まではとやかくいいませ

んからね。」 すべてのメンバーがこの相談役のいうことを了承して話はまとまりました。

メンバーはみんな相談役だけに報告し、メンバーへの指示は相談役だけから来るように なりました。 そして、メンバー同士が状況を探りあったり、 指示しあったりすることはな くなりました。

この章では、

メディエイター Mediator パターン

について学びます。 mediator というのは英語で 「調停者」 「仲介者」 という意味ですが、 日本語でメディエイターといっても、イメージをつかむのが難しいですね。 グループにや ってきた頼りになる 「相談役」 を想像するのがいいでしょう。 困ったことがあったら、 相 談役に知らせる。 全体に波及する出来事が起こったら、 相談役に知らせる。 相談役からい われたことは、素直に実行する。 グループの各メンバーが勝手に他のメンバーとコミュニ ケートして判断するのではなく、いつも頼りになる相談役を通して行動を起こすようにす る。 一方、 相談役はグループのメンバーから上がってきた報告を元に大局的な判断を行い、 各メンバーに指示を出す。 Mediatorパターンは、以上のようなデザインパターンです。 Mediatorパターンでは、「相談役」 は mediator (調停者)、 「各メンバー」はcolleague メディエイタ 73-7

(同僚)と呼ばれます。 colleague というつづりはとても間違えやすく、なじみがありませ んが、ここではGoF本 (付録D [GoF] 参照) で使われている用語のままで使います。

サンプルプログラム

Mediatorパターンを使ったサンプルプログラムを読んでみましょう。 ここで作るプログ ラムは、「名前とパスワードを入力するログインダイアログ」 という GUIアプリです。 プ ログラムを実行すると、 Fig.16-1のようになります。

サンプルプログラム

Fig.16-1 ログインダイアログの様子

Mediator Sample Guest O Login Username: Yuki Password: OK Cancel

このダイアログは、次のように使います。

ゲストログイン [Guest] か、 ユーザログイン [Login] かを選択する ・ユーザログインの場合に限り、ユーザ名 [Username] とパスワード [Password] を入力する

ログインするなら [OK] ボタン、 やめるなら [Cancel] ボタンを押す (実際にはどこにもログインしません。 ボタンを押したら単に終了します)

単純なプログラムですね。 ...本当ですか? 上記の文章を読んだ限りでは話は単純そう ですが、以下のような動作をさせようと思うと、 話はちょっと複雑になってきます。

ゲストログインが選ばれているときには、ユーザ名とパスワードを 「無効状態」に して、文字列が入力できないようにする

・ユーザログインが選ばれているときには、 ユーザ名は「有効状態」になり、 文字列 が入力できるようにする

・ユーザ名に文字が1文字も入っていない場合には、パスワードは 「無効状態」になる ・ユーザ名に文字が1文字でも入っていたら、パスワードは「有効状態」になる(も ちろんゲストログインの場合には、パスワードは 「無効状態」である)

・ユーザ名とパスワードの両方に文字が1文字でも入っている場合には、OKボタン は 「有効状態」になり、押せる状態になるが、 ユーザ名とパスワードのどちらか一 方でも空ならば、OK ボタンは 「無効状態」になって、 押せない状態になる (もち ろんゲストログインの場合には、OK ボタンは常に 「有効状態」 である)

・Cancel ボタンは常に 「有効状態」 で、いつでも押せる状態になっている

251

16章 Mediator 相手は相談役1人だけ

Fig.16-2 ユーザログインが選ばれていると、 ユーザ名は 「有効状態」 だが、パスワードは「無効状態」

Mediator Sample

Guest O Login

Username:

Password:

第

OK

Cancel

Fig.16-3 ユーザ名に1文字でも入っていると、パスワードは 「有効状態」 だが、OK ボタンは 「無効状態」

Mediator Sample

Guest

O Login

Username: Y

Password:

OK

Cancel

Fig.16-4 パスワードにも文字が入っていると、 OKボタンも有効に

Mediator Sample

Guest O Login

Username:

Yuki

Password:

OK

Cancel

Fig.16-5 ここでゲストログインにすると、ユーザ名もパスワードも 「無効状態」に

Mediator Sample

Guest

Login

Username: Password:

Yuki

OK

Cancel

Fig.16-6 パスワードが入っていても、ユーザ名を削除するとOKボタンとパスワードは無効

Mediator Sample Guest O Login Username: Password: OK Cancel

252

サンプルプログラム

・・・やれやれ。 ここに書き並べたような条件は、 言葉で表現するとやっかいで複雑なよう にみえますが、 実際にダイアログを使ってみると、 設計者の意図がよくわかると思います。 でも、これはどんな風にプログラミングすればいいんでしょう。

ダイアログ上のラジオボタン(ゲストログインやユーザログインの選択用)やテキスト フィールド(ユーザ名やパスワードの入力用)、 それにボタン (OKやCancel) は、 それぞ れ別々のクラスになっています。 もしも、 上記のロジックを各クラスに分散させると、コ ーディングは非常に大変になります。

なぜならば、それぞれのオブジェクトが互いに関係しあっているため、お互いがお互い をコントロールするような状況に陥ってしまうからです。

「ユーザログインが選ばれたとき、ユーザ名を有効にして、 パスワードも有効にするん だけれど、もしもユーザ名が空だったらパスワードは有効にしない。 そして、 ユーザ名と パスワードの両方に文字列が入っていたら、 OKボタンを有効にする」というコードはど こに書くのでしょう。 ラジオボタンのところですか? でも、そんなことをしていたら、 表示のコントロールのための似て非なるコードが各クラスにばらばらに書かれることにな ります。 それでは、プログラムを書くのも、 デバッグするのも大変です。 しかも、もし仕 様変更が行われて 「メールアドレスを入力する欄を追加」 することになったりしたら…。 ぞっとしますね。

上記のような、 多数のオブジェクトの間の調整を行わなければならないときこそ、 Mediatorパターンの出番です。 個々のオブジェクトが互いに通信しあうのではなく、 「頼 りになる相談役」 を置き、その相談役とだけ通信することにします。 そして、 表示のコン トロールのロジックは、 相談役の中にだけ記述するのです。

前置きが長くなりましたが、 筋書きはわかりましたね。 以下のプログラムを読むときに は、上記のMediatorの筋書きを念頭において読み進めてください。

クラスとインタフェースの一覧を Table 16-1に、 クラス図とシーケンス図をそれぞれ Fig.16-7, Fig.16-8に示します。

Table 16-1 クラスとインタフェース一覧

名前 Mediator Colleague ColleagueButton ColleagueTextField ColleagueCheckbox LoginFrame Main 解說 「相談役」 のインタフェース (API) を定めるインタフェース 「メンバー」のインタフェース (API) を定めるインタフェース Colleague インタフェースを実装。 ボタンを表すクラス Colleague インタフェースを実装。 テキスト入力を行うクラス Colleague インタフェースを実装。 チェックボックス (ここではラジオボタン)を表すクラス Mediator インタフェースを実装。 ログインダイアログを表すクラス 動作テスト用のクラス

253

第16章 Mediator 相手は相談役1人だけ

Fig.16-7 サンプルプログラムのクラス図

Prane <<interface>> Mediator createColleagues colleagueChanged <<interface>> Colleague setMediator set ColleagueEnabled LoginFrame checkGuest checkLogin textUser textPass buttonOk buttonCancel createColleagues colleagueChanged userpassChanged actionPerformed ColleagueButton Button mediator setMediator setColleagueEnabled ColleagueTextField TextField mediator setMediator setColleagueEnabled textValueChanged ColleagueCheckbox Checkbox mediator setMediator setColleagueEnabled

Fig.16-8 サンプルプログラムのシーケンス図

itemStateChanged

:LoginFrame :ColleagueCheckbox :ColleagueTextField :ColleagueButton colleagueChanged setColleagueEnabled setColleagueEnabled

254

サンプルプログラム

| Mediator インタフェース

Mediator インタフェース (List 16-1) は、 「相談役」 を表現するインタフェースです。 具体的な相談役 (後で登場するLoginFrameクラス)は、このインタフェースを実装します。 createColleaguesメソッドは、 このMediator が管理するメンバーを生成するメソッ ドです。 このサンプルプログラムでは、createColleagues メソッドで必要なボタンやテ キストフィールドなどを作成します。

colleagueChangedメソッドは、各メンバーである Colleagueたちから呼び出されるメ ソッドです。 このメソッドは、 相談役への「相談」 に相当します。 サンプルプログラムで は、ラジオボタンやテキストフィールドの状態が変化したときに、このメソッドが呼び出 されます。

List 16-1 Mediator インタフェース (Mediator.java)

1: public interface Mediator ( 2: 3: 4: 5: 6: 7: } // Colleague たちを生成する public abstract void createColleagues(); // Colleageの状態が変化したときに呼ばれる public abstract void colleagueChanged();

| Colleague インタフェース

Colleague インタフェース (List 16-2) は、 相談役に相談を持ちかけるメンバーを表す インタフェースです。 具体的なメンバー (ColleagueButton, ColleagueTextField, ColleagueCheckbox) は、このインタフェースを実装します。

setMediator メソッドは、 Mediator インタフェースを実装したLoginFrameクラスが 「相談役は私なんだから、覚えておいてくださいね」という意味を込めて呼び出すメソッ ドです。 このメソッドの引数で渡されたインスタンスは、あとで相談が必要になったとき colleagueChanged を呼び出すとき)に使います。

setColleague Enabledメソッドは、 相談役からやってくる 「指示」に相当します。 引 数の enabled が trueなら自分自身を 「有効状態」 にし、 false なら自分自身を 「無効状 態」にします。 このメソッドは、自分が 「有効状態」になるべきなのか、 「無効状態」に なるべきなのかを自分で判断するのではなく、相談役の判断に従って決めるということ

255

第16章 Mediator相手は相談役1人だけ

を表しています。

なお、Mediator インタフェースとColleague インタフェースにどのようなメソッドを 持たせるかは、作成するアプリケーションによって変化します。 ここでは Mediator 側に colleagueChanged メソッドを置き、 Colleague 側に setColleague Enabledメソッドを 置きましたが、もっと細かな通信をMediator役と Colleague役で行う必要があるなら、メ ソッドの数を増やす必要があるでしょう。 同じ Mediatorパターンを使っていても、 実際 のメソッドはアプリケーションによって異なります。

List 16-2 Colleague インタフェース (Colleague.java)

1: public interface Colleague ( 2: 3: 4: 5: 6: 7: ) // Mediator を設定する public abstract void setMediator (Mediator mediator); // Mediator から有効/無効が指示される public abstract void setColleagueEnabled (boolean enabled);

| ColleagueButtonクラス

ColleagueButton クラス (List 16-3) は java.awt.Buttonのサブクラスですが、 Coll eague インタフェースを実装して、 LoginFrame クラス (Mediator インタフェース)と協 調動作を行います。

mediator フィールドには、 setMediator で渡されてくるMediator オブジェクト (LoginFrameクラスのインスタンス)を保持します。 setColleague Enabledメソッドは、 JavaのGUIで定義されている setEnabledメソッドを呼び出して、 有効/無効を設定してい ます。setEnabled(true) ではボタンは押せますが、 setEnabled(false) ではボタンは押 せなくなります。

List 16-3 ColleagueButton 52 (ColleagueButton.java)

1: import java.awt.Button

2:

3: public class ColleagueButton extends Button implements Colleague {

4:

private Mediator mediator;

5:

public ColleagueButton(String caption) (

super(caption);

6:

7:

256

サンプルプログラム

8:

// Mediator を設定する @Override public void setMediator (Mediator mediator) { this.mediator = mediator; 9: 10: 11: 12: 13: 14: } 15: 16: 17: 18: 19: 20: 21: } // Mediator から有効/無効が指示される @Override public void setColleague Enabled (boolean enabled)( setEnabled(enabled);

| Colleague TextFieldクラス

ColleagueTextFieldクラス (List 16-4) は java.awt.TextFieldのサブクラスで、 Colleague インタフェースを実装しています。 また、このクラスはjava.awt.event.Text Listener インタフェースも実装しています。 こうするのは、 テキストの内容が変化した ことをtextValueChangedメソッドでキャッチしたいからです。

Javaのクラスは、複数のクラスから拡張 (extends) することはできませんが、複数の インタフェースを実装 (implements) することはできます。 setColleagueEnabledメソ ッドでは、setEnabledメソッドだけではなく、 setBackgroundメソッドも呼んでいます。 これは、有効時には背景色を白色 (ホワイト) に、 無効時には明るい灰色 (ライトグレー) にしたいからです。

text ValueChangedメソッドは、 TextListener インタフェースのためのメソッドです。 このメソッドは、テキストの内容に変更があった場合にAWTのフレームワーク側から呼び 出されます。 サンプルプログラムのtext ValueChangedメソッドでは、 colleagueChanged メソッドを呼び出して、 相談役に 「ちょっとすみません。 私の文字列内容が変化したこと を報告します。 どうぞよろしくお願いします」と伝えています。

List 16-4 Colleague TextField クラス ColleagueTextField.java)

1: import java.awt.Color; 2: import java.awt.TextField; 3: import java.awt.event.TextEvent; 4: import java.awt.event.TextListener;

257

258 16 Mediator-FR1AE

5: 6: public class ColleagueTextField extends TextField implements private Mediator mediator; 7: 8: public ColleagueTextField(String text, int columns) ( super (text, columns); 9: 10: 11: } 12: 13: 14: 15: 16: 17: } 18: // Mediator を設定する @Override public void setMediator (Mediator mediator) ( this.mediator mediator; 19: 20: // Mediator から有効/無効が指示される @Override public void setColleagueEnabled (boolean enabled) ( 21: 22: 23: 24: 25: 26: 27: 28: 29: 30: 31: } 32: ) set Enabled (enabled); // 有効/無効に合わせて背景色を変更する setBackground (enabled ? Color.white Color.lightGray); @Override public void textValueChanged (Text Event e) ( // 文字列が変化したら Mediator に通知する mediator.colleagueChanged();

TextListener, Colleague {

ColleagueCheckbox 557

ColleagueCheckbox" (List 16-5), java.awt.Checkbox 70 #15 スです。 サンプルプログラムでは、チェックボックスとしてではなく、ラジオボタンと して使われます (CheckboxGroupを利用)。

このクラスは、java.awt.event.ItemListener インタフェースも実装しています。 こ れは、ラジオボタンの状態変化を、 itemStateChanged メソッドでキャッチしたいからで す。

サンプルプログラム

List 16-5 ColleagueCheckbox 5x (ColleagueCheckbox.java)

1: import java.awt.Checkbox;

2: import java.awt.CheckboxGroup;

3: import java.awt.event. ItemEvent;

4: import java.awt.event. ItemListener;

6: public class ColleagueCheckbox extends Checkbox implements ItemListener, Colleague ( private Mediator mediator; 7:

public ColleagueCheckbox (String caption, CheckboxGroup group, boolean state) ( super (caption, group, state);

9:

10:

)

11:

12:

// Mediator を設定する

@Override

this.mediator = mediator;

13:

14:

16:

public void setMediator (Mediator mediator) (

// Mediator から有効/無効が指示される

17:

15:

18:

}

public void setColleagueEnabled (boolean enabled) (

19:

21:

@Override

22:

set Enabled (enabled);

23:

@Override

public void itemStateChanged (ItemEvent e) {

24:

25:

5:

26:

27:

}

28: 29: 30: )

// 状態が変化したら Mediator に通知する

mediator.colleagueChanged();

20:

}

LoginFrame クラス

「やっと 「相談役」のクラスまでたどり着きました。 LoginFrameクラス (List 16-6)は java.awt.Frame (GUIアプリを作るためのクラス)のサブクラスで、 Mediator インタフェ ースを実装しています。

JavaのAWT フレームワークについての解説は、本書の範囲を超えますので、ここでは 重要なポイントに絞ってお話します。 コンストラクタの中では、次の仕事を行っています。

8:

259

第16章 Mediator相手は相談役1人だけ

背景色の設定

レイアウトマネージャの設定 (子ウインドウを縦4個×横2個に配置する)

* createColleagues メソッドでColleague の生成

Colleague の配置

・初期状態の設定

表示

createColleagues メソッドでは、このダイアログで必要な Colleague を生成し、それ をフィールドに保持しています。 また、各Colleague に対してsetMediator を呼び出し、 「あなたの相談役は私だからね、 何かあったら知らせるんだよ」 といっておきます。 createColleaguesメソッドでは、この他に各Listener の設定も行います。 これは、 各 Listener が AWTのフレームワークから適切に呼び出されるようにするためです。

このプログラムで最も大事なメソッドは、 LoginFrameクラスのcolleagueChangedメソ ッドです。 このメソッドの中で、 例の「表示の有効/無効を設定する複雑な処理」 を行ってい ます。 これまで読んできたColleagueButton, Colleague TextField, ColleagueCheck boxの各クラスを思い出してください。 これらのクラスには、 自分の有効/無効を設定する メソッドはありましたが、どういうときに有効/無効にするか、というロジックは書かれて いませんでしたね。どのクラスも必要に応じて 「相談役さん、よろしくね」 とcolleague Changedメソッドを呼び出しておしまいでした。 つまり、 すべてのColleagueの相談が、 こ このcolleagueChangedメソッドに集結するのです。

あとは、ラジオボタンの状態を得る getStateメソッドやテキストフィールドの文字列 を得る getTextメソッドなどを駆使して、 あの複雑な条件をコーディングすればよいこと になります。 なお、ここでは共通の処理としてuserpassChanged メソッドを呼んでいま す。userpassChangedメソッドは、この内部だけで使っている privateなメソッドです。

List 16-6 LoginFrame クラス (LoginFrame.java)

1: import java.awt.CheckboxGroup:

2: import java.awt.Color;

3: import java.awt.Frame;

4: import java.awt.GridLayout;

5: import java.awt.Label;

6: import java.awt.event.ActionEvent;

7: import java.awt.event.ActionListener;

8:

9: public class LoginFrame extends Frame implements ActionListener, Mediator

10:

private ColleagueCheckbox checkGuest;

private ColleagueCheckbox checkLogin;

11:

private ColleagueTextField textUser;

private ColleagueTextField text Pass;

13:

12:

260

14:

サンプルプログラム 261

15:

private ColleagueButton buttonOk; private ColleagueButton buttonCancel;

16:

18:

17:

19:

20:

// Colleague たちを生成し、配置後に表示する public LoginFrame (String title) ( super (title); // 背景色を設定する setBackground (Color.lightGray);

21:

22:

23:

// レイアウトマネージャを使って4×2のグリッドを作る setLayout (new GridLayout (4, 2));

24:

25:

26:

27:

// Colleague たちを生成する createColleagues();

28:

29:

30:

32:

33:

34:

// 配置する add (checkGuest); add (checkLogin); add (new Label ("Username:")); add (textUser); add (new Label ("Password: ")); add (textPass); add (buttonOk); add (buttonCancel);

37:

38:

39:

40:

// 有効/無効の初期指定をする colleagueChanged();

41:

42:

35:

43:

// 表示する

pack();

setVisible(true);

44:

45:

46:

36:

47:

48:

49:

31:

// Colleague たちを生成する

@Override

50:

51:

52:

}

public void createColleagues() ( // CheckBox CheckboxGroup g = new CheckboxGroup(); checkGuest = new ColleagueCheckbox ("Guest", g, true); checkLogin new ColleagueCheckbox ("Login", g, false); // TextField textUser = new ColleagueTextField("*, 10); textPass = new ColleagueTextField("", 10); text Pass.setEchoChar (*);

53:

54:

55:

56:

57:

58:

59:

60:

16 Mediator-1AE

61:

// Button

62:

= buttonok new ColleagueButton("OK"); buttonCancel new ColleagueButton("

Cancel");

63:

64:

65:

// Mediator を設定する

checkGuest.setMediator(this);

67:

66:

checkLogin.setMediator(this);

68:

textUser.setMediator (this);

69:

70:

text Pass.setMediator(this);

buttonOk.setMediator(this);

71:

buttonCancel.setMediator(this);

72:

73:

75:

76:

74:

// Listener th checkGuest.addItemListener (checkGuest); checkLogin.addItemListener (checkLogin); textUser.addTextListener (textUser); text Pass.addTextListener (text Pass); button0k.addActionListener(this); buttonCancel.addActionListener(this);

77:

78:

79:

80:

81:

// Colleageの状態が変化したときに呼ばれる

82:

@Override public void colleagueChanged() { if (checkGuest.getState()) { // ゲストログイン textUser.setColleagueEnabled(false); text Pass.setColleagueEnabled (false); buttonOk.setColleagueEnabled(true); } else { // ユーザログイン textUser.setColleagueEnabled (true); userpassChanged();

83:

84:

85:

86:

87:

88:

89:

90:

91:

92:

93:

94:

95:

96:

97: 98: 99: // textUser または textPass の変更があった // 各Colleageの有効/無効を判定する private void userpassChanged() { if (textUser.getText().length() > 0) ( text Pass.setColleagueEnabled (true); if (text Pass.getText().length() > 0) ( buttonok.setColleagueEnabled (true); 100: 101: 102: 103: 104: 105: 106: 107: } else { ) else { buttonOk.setColleagueEnabled (false);

262

108:

Mediatorパターンの登場人物

109:

textPass.setColleagueEnabled (false); buttonOk.setColleagueEnabled (false);

110:

111:

112:

113: 114: 115: 116: 117: ) 118: ) @Override public void actionPerformed (ActionEvent e) { System.out.println(e.toString()); System.exit(0);

| Mainクラス

Main クラス (List 16-7) では、 LoginFrameのインスタンスを生成しています。 main メ ソッドは終わってしまいますが、 LoginFrameのインスタンスは、 AWT のフレームワーク の方で保持されています。

List 16-7 Main クラス (Main.java)

1: public class Main ( 2: 3: 4: } 5: ) public static void main(String[] args) { new LoginFrame("Mediator Sample");

Mediator パターンの登場人物

Mediator パターンの登場人物は、次のとおりです。

イエイタ Mediator (調停者、 仲介者) の役 Mediator役は、Colleague役と通信を行って、調整を行うためのインタフェース (API) を定めます。 サンプルプログラムでは、 Mediator インタフェースがこの役をつとめました。

}

263

第16章 Mediator 相手は相談役1人だけ

コンクリート ConcreteMediator (具体的な調停者、 仲介者)の役

ConcreteMediator役は、 Mediator 役のインタフェース (API) を実装し、 実際の調整を 行います。 サンプルプログラムでは、 LoginFrame クラスがこの役をつとめました。

Colleague (同僚)の役

Colleague 役は、 Mediator役と通信を行うインタフェース (API) を定めます。 サンプル プログラムでは、 Colleagueインタフェースがこの役をつとめました。

コンクリート・コリーグ ◆ConcreteColleague (具体的な同僚)の役

Concrete Colleague役は、 Colleague 役のインタフェース (API) を実装します。 サンプ ルプログラムでは、 ColleagueButton, Colleague TextField, ColleagueCheckboxの 各クラスがこの役をつとめました。

Fig.16-9 Mediator パターンのクラス図 Mediator createColleagues colleagueChanged Concrete Mediator concreteColleaguel concreteColleague2 concreteColleague3 mediator Colleague set Mediator controlColleague ConcreteColleaguel controlColleague Concrete Colleague2 controlColleague createColleagues colleagueChanged Concrete Colleague) controlColleague

264

あなたの考えを広げるためのヒント

あなたの考えを広げるためのヒント

分散が災いになるとき

サンプルプログラムのLoginFrameクラスに書かれている colleagueChanged メソッド (p.262) は、少々複雑です。 仕様変更があったら、この複雑なメソッドの中に結局バグが 入り込むんじゃないでしょうか。 そうかもしれませんが、それは問題にはなりません。た とえcolleague Changedメソッドにバグが入ったとしても、表示の有効/無効に関するロ ジックは、ここ以外には存在しないのですから、ここをデバッグすればいいのです。

考えてみてください。 もしも、 ロジックがColleagueButton, ColleagueTextField, ColleagueCheckbox に分散していたら・・・、 書くのも、デバッグするのも、 修正するのも 大変だと思いませんか。

オブジェクト指向では、一極集中を避け、 処理を分散させることが多いです。 すなわち、 問題を 「分割して統治」 しようとしているのです。 しかし、今回のサンプルプログラムの ような場合には、処理を各クラスに分散させるのは賢明ではありません。 各クラスに分散 させるべきことは分散させ、集中させるべきことは集中させないと、せっかくのクラス分 けがかえって災いとなってしまうのですね。

| 通信経路の増加

AとBの2個のインスタンスがあって、互いに通信し合う (メソッドを呼び合う)とし ます。 そのとき、 通信経路はA→BとABの2本になります。 インスタンスがAとBとC の3個なら、 AB,AB, B→C, B←C, C→A,C←Aの6本になります。 4個になると、 気に12本に増え、 5個になると20本、6個になると30本になります。 同じ立場のインスタ ンスがたくさん存在するとき、 それらを互いに通信させると、 プログラムは複雑になって しまいます。

インスタンスの数が少ないうちは、問題は大きくありません。 しかし最初の設計のまま、 どんどんインスタンスを増やしていくと、 どこかで破綻をきたすでしょう。 Mediatorパタ ーンには、そのような通信経路の増加を抑える効果があります。

再利用できるのは何か?

Concrete Colleague 役は再利用しやすいが、 Concrete Mediator 役は再利用しにくいといえ ます。

265

16章 Mediator相手は相談役1人だけ

例えば、ログインダイアログとは別の、 新しいダイアログを作るとします。 そのとき、 Concrete Colleague ColleagueButton, ColleagueTextField, ColleagueCheck boxは、その新しいダイアログでも再利用できます。 なぜなら、 Concrete Colleague 役の中 には、特定のダイアログに依存したコードは含まれていないからです。

コードのうち、アプリケーションへの依存性の高い部分は、 ConcreteMediator役である LoginFrameクラスの中に閉じ込められています。 アプリケーションへの依存性が高いと いうことは、 再利用性が低いということです。 LoginFrameクラスをそのまま他のダイア ログに再利用することは難しいでしょう。

| GUIプログラミングの注意点

サンプルプログラムでは、JavaのGUIツールキットとして古くから使われているAWT を用いてMediatorパターンを実装しました。 説明の都合もあり、 AWT を用いたプログラ ミングとしてはやや回りくどい書き方になっています。 Colleage インタフェースや Mediator インタフェースをいちいち経由しなくても、 Listener を設定するだけで同じ機 能を持つプログラムは作れます。

またJavaには、新しいGUIツールキットがいくつもあり、それぞれに 「このような考え 方でプログラムを作りましょう」という流儀があります。 この章で紹介したMediatorパ ターンを無理に適用したりせず、各流儀を理解してプログラミングしてください。

関連しているパターン

◆Facadeパターン (第15章)

Mediatorパターンでは、 Mediator 役はColleague役の仲介者としてやりとりを行います。 Facadeパターンでは、 Facade役が一方的に他の役を利用して高レベルなインタフェー ス (API)を作りました。 Mediatorは双方向ですが、 Facadeは一方向といえるでしょう。

Observer パターン (第17章)

Mediator 役と Colleague役の通信は、 Observerパターンを使って行われる場合があります。

第

266

この章で学んだこと

この章では、頼りになる相談役が登場するMediatorパターンについて学びました。 Mediatorパターンは、複雑に絡みあうオブジェクトたち相互の通信をやめ、 Mediator 役に 情報を集中させることによって処理を整理します。

練習問題

●問題 16-1

「ユーザログインのとき、ユーザ名とパスワードの両方が4文字以上の場合にのみOK ボタンが有効になる」 という仕様を満たすように、サンプルプログラムを修正してくださ い。 修正する必要があるのはどのクラスかをよく考えてください。

267

解答は付録A (p.457)



第17章 Observer

状態の変化を通知する

»)

17章 Observer状態の変化を通知する

Observer パターン

この章では、

Observer パターン

オブザーバ

について学びます。

オブザーブ observer とは、観察 (observe) する人、すなわち 「観察者」という意味です。 Observerパターンでは、観察対象の状態が変化したことが、観察者に通知されます。 Observerパターンは、 状態変化に応じた処理を記述するときに有効です。

サンプルプログラム

Observerパターンを使ったサンプルプログラムを読んでみましょう。 ここで作るサンプ ルプログラムは、数をたくさん生成するオブジェクトを観察者が観察して、その値を表示 するという単純なものです。 ただし、表示の方法は観察者によって異なります。 Digit Observerは値を数字で表示しますが、 GraphObserverは値を簡易グラフで表示します。

Table 17-1 クラスとインタフェース一覧

Observer 名前 NumberGenerator 解說 観察者を表すインタフェース 数を生成するオブジェクトを表す抽象クラス RandomNumberGenerator ランダムに数を生成するクラス DigitObserver GraphObserver Main 数字で数を表示するクラス 簡易グラフで数を表示するクラス 動作テスト用のクラス

第

Observerインタフェース

Observerインタフェース (List 17-1) は、 「観察者」 を表現するインタフェースです。 具体的な観察者は、このインタフェースを実装します。 なお、このObserverインタフェー スはサンプルプログラム用に作ったもので、 Javaのクラスライブラリに登場するjava. Java util. Observer とは異なります。 java.util. Observer は非推奨 (deprecated) なインタ フェースなので、新しいプログラムでは使いません。

270

プルプログラム 271

| Fig.17-1 サンプルプログラムのクラス図

Number Generator observers addObserver deleteObserver notifyObservers getNumber execute RandomNumberGenerator random number getNumber execute <<interface>> Observer Notifies▸ update DigitObserver Graphobserver update update

ジェネレータ updateメソッドを呼び出すのは、数を生成する Number Generator です (generator とは、 「生成するもの」 「生成器」 という意味です)。 updateメソッドはNumberGenerator が 「私の内容が更新されました。 表示の方も更新してください」 とObserver に伝えるための メソッドです。

List 17-1 Observer インタフェース (Observer.java)

1: public interface Observer (

2:

public abstract void update (NumberGenerator generator);

3: )

| Number Generatorクラス

NumberGeneratorクラス (List 17-2) は、 数を生成する抽象クラスです。 実際の数の 生成(execute メソッド) と 数を取得する部分 (getNumber メソッド) はサブクラスが 実装することを期待して、 抽象メソッドになっています (subclass responsibility)。 observers フィールドは、 NumberGenerator を観察している Observerたちを保存して いるフィールドです。

第17章 Observer状態の変化を通知する

addObserver は Observer を追加するメソッド deleteObserver は Observer を削除す るメソッドです。

notifyObserversメソッドは、 Observer全員に対して 「私の内容が更新されたので、 あなたの表示を更新してください」と伝えるものです。このメソッドの中では、 observersの中のObserverたち1人1人のupdateメソッドを呼び出しています。

List 17-2 NumberGenerator 57 (NumberGenerator.java)

1: import java.util.ArrayList;

2: import java.util.List;

3:

4: public abstract class NumberGenerator {

// 保持している Observerたち

6:

5:

private List<Observer> observers = new ArrayList<>();

7:

8:

// Observer を追加する

9:

public void addObserver (Observer observer) {

10:

observers.add(observer);

}

11:

// Observerを削除する

12:

13:

public void deleteObserver (Observer observer) {

14:

observers.remove (observer);

15:

16:

20:

for (Observer o: observers) (

// 数を取得する

}

17:

18:

// Observerts

19:

public void notifyObservers () (

o.update(this);

21:

22:

23:

)

24:

25:

public abstract int getNumber ();

26:

27:

28:

// 数を生成する

29:

public abstract void execute();

30: )

272

サンプルプログラム 273

RandomNumberGenerator >57

RandomNumberGeneratorクラス (List 17-3) は NumberGeneratorのサブクラスで、 乱数を生成するものです。

random フィールドには、 java.util. Randomクラスのインスタンス(いわば、乱数生成 器) が保持され、 number フィールドには現在の乱数値が保持されます。

getNumber メソッドは、 number フィールドの値を返します。

execute メソッドは乱数(0~49 の範囲の整数)を20個生成し、そのつどnotifyObservers を使って、 観察者に通知します。 ここで使われている nextIntメソッドは、 java.util. Randomクラスのメソッドでランダムな整数を戻り値とします (0以上、引数で指定した数 未満)。

List 17-3 RandomNumberGenerator 52 (RandomNumberGenerator.java)

1: import java.util.Random; 2: 3: public class RandomNumberGenerator extends NumberGenerator { private Random random = new Random(); // 乱数生成器 4: 5: private int number; 6: 7: // 数を取得する 8: @Override 9: public int getNumber() ( 10: return number; 11: } 12: 13: 14: @Override 15: 16: 17: 18: // 数を生成する public void execute() { for (int i = 0; i < 20; i++) ( number = random.nextInt(50) notifyObservers(); 19: 20: } 21: ) // 現在の数

Digit Observer クラス

Digit Observer クラス (List 17-4) は、 Observerインタフェースを実装しているクラ

第17章 Observer態の変化を追加する

スで、観察した数を「数字」で表示するためのものです。 update メソッドの中で引数と して与えられたNumberGenerator の getNumberメソッドを使って数を取得し、それを表 示します。 ここでは、表示の様子がよくわかるように Thread.sleepを使ってスピードを 遅くしています。

List 17-4 DigitObserver 52 (DigitObserver.java)

1: public class DigitObserver implements Observer { @Override public void update (NumberGenerator generator) ( System.out.println("DigitObserver:" + generator.getNumber()) try { 2: 3: 4: 5: 6: 7: 8: } Thread.sleep(100); } catch (InterruptedException e) { 9: 10: }

GraphObserver 5

GraphObserverクラス (List 17-5) も、 Observerインタフェースを実装しているクラ スです。 このクラスは、観察した数を*****のような「簡易グラフ」 で表示します。

List 17-5 GraphObserver 52 (GraphObserver.java)

2: 3: 1: public class GraphObserver implements Observer ( Override public void update (NumberGenerator generator) { 4: System.out.print ("GraphObserver: "); 5: int count generator.getNumber(); 6: 7: 8: ) 9: 10: 11: 12: for (int i=0; i < count; i++) ( System.out.print (***); System.out.println(""); try ( Thread.sleep(100); catch (InterruptedException e) { 13: ) 14: } 15: }

274

サンプルプログラム 275

| Mainクラス

Mainクラス (List 17-6) では、 RandomNumber Generatorのインスタンスを1個作り、そ の観察者を2個作ります。 observer1はDigitObserver の、 observer2はGraphObserver のインスタンスです。

addObserver メソッドを使って観察者を登録した後、 generator.execute を使って数 を生成します。

List 17-6 Main 57 (Main.java)

1: public class Main ( public static void main(String[] args) { 2: 3: 4: 5: 6: 7: 8: 9: } 10: ) NumberGenerator generator new RandomNumberGenerator(); Observer observer1 = new DigitObserver(); Observer observer2 = new GraphObserver (); generator.addObserver (observer1); generator.addObserver (observer2); generator.execute();

|Fig.17-2 実行結果例(一部)

DigitObserver:23 GraphObserver: DigitObserver:2 GraphObserver:** DigitObserver: 48 GraphObserver: DigitObserver:25 GraphObserver:** DigitObserver:10 GraphObserver: DigitObserver:13 GraphObserver:* DigitObserver: 12 GraphObserver: * DigitObserver: 2 GraphObserver:** DigitObserver:29 GraphObserver: DigitObserver: 11 Graphobserver: DigitObserver:1 Graphobserver:* (以下略)

17章 Observer状態の変化を通知する

Observer パターンの登場人物

第

Observerパターンの登場人物は、次のとおりです。

ブジェクト Subject (被験者)の役

Subject役は、「観察される側」を表します。 Subject役は、観察者であるObserver役を 登録するメソッドと、削除するメソッドを持っています。 また、 「現在の状態を取得する」 メソッドも宣言されています。 サンプルプログラムでは、 NumberGenerator クラスがこ の役をつとめました。

コンクリート・サブジェクト ConcreteSubject (具体的な被験者)の役

Concrete Subject 役は、 具体的な 「観察される側」を表現する役です。 状態が変化した ら、そのことを登録されている Observer役に伝えます。 サンプルプログラムでは、 Random NumberGeneratorクラスがこの役をつとめました。

オブザーバ Observer (観察者)の役

Observer役は、 Subject役から 「状態が変化しましたよ」と教えてもらう役です。その ためのメソッドがupdate です。 サンプルプログラムでは、 Observerインタフェースがこ の役をつとめました。

| Fig.17-3 Observer パターンのクラス図

Subject

Notifies▸

observers

addObserver

deleteObserver

notifyObservers getSubject Status

update Observer ConcreteObserver update

ConcreteSubject

getSubjectStatus

276

あなたの考えを広げるためのヒント

ConcreteObserver (具体的な観察者)の役

コンクリートオブザーバ

ConcreteObserver役は、具体的な Observerです。 updateメソッドが呼び出されると、 そのメソッドの中でSubject役の現在の状態を取得します。 サンプルプログラムでは、 Digit Observer クラスやGraphObserver クラスがこの役をつとめました。

あなたの考えを広げるためのヒント

| ここにも交換可能性が登場する

デザインパターンの目的の1つは、 クラスを再利用可能な部品にすることです。 Observerパターンでは、状態を持っている ConcreteSubject役と、 状態変化を通知して もらう Concrete Observer 役が登場しました。 そして、その2つの役目をつないでいるもの が、インタフェース(API)としてのSubject役とObserver役です。

RandomNumberGeneratorクラスは、 自分を現在観察しているのが(自分が通知する相 手が) DigitObserver クラスのインスタンスなのか、 GraphObserver クラスのインスタ ンスなのかを知りませんし、 気にかけません。 しかし、 observers フィールドに格納され ているインスタンスたちが、 Observerインタフェースを実装していることは知っていま す。それらのインスタンスはaddObserver で追加されたものですから、 必ずObserver イ ンタフェースを実装しており、 updateメソッドを呼び出せることが保証されているので す。

一方、DigitObserverクラスは、自分が観察しているのがRandomNumberGenerator クラ スのインスタンスなのか、他の XXXXNumberGeneratorクラスのインスタンスなのかを気 にかけません。 ただ、 NumberGeneratorのサブクラスのインスタンスであり、 getNumber メソッドを持っていることは知っています。

本書をここまで読み進められてきた読者は、上に述べたことが、これまでのパターンの 中にも何度も登場しているのに気づいていますね。

・抽象クラスやインタフェースを使って、 具象クラスから抽象メソッドをひきはがす 引数でインスタンスを渡すときや、フィールドでインスタンスを保持するときには、 具象クラスの型にしないで、 抽象クラスやインタフェースの型にしておく

このようにしておけば、具象クラスの部分をカチッと交換することができるのです。

277

第17章 Observer状態の変化を通知する

Observer の順序

Subject 役には、複数人の Observer 役が登録されています。 サンプルプログラムの notifyObserversメソッドでは、先に登録したObserver の updateメソッドが先に呼び 出されることになります。

一般に、ConcreteObserver 役のクラスを設計するときには、 updateメソッドが呼び出 される順序が変わっても問題が起きないようにする必要があります。 DigitObserver の updateを呼んだ後でなければ、 GraphObserver の update が正しく動作しない、などとい うことがあってはいけません。 もっとも、各クラスの独立性がきちんと保たれていれば、 あまり依存性の混乱は起きないものです。

しかし、次節のような状況には注意を払う必要があります。

Observerの行為がSubjectに影響を与えるとき

今回のサンプルプログラムでは、 RandomNumber Generator が自分の中でデータを生成 notifyObservers 経由でupdate メソッドを呼んでいました。 しかし、一般の Observer パターンでは、 Subject役がupdateメソッドを呼ぶきっかけが、他のクラスからくる場合 もあります。 例えば、 グラフィックユーザインタフェース (GUI) では、ユーザがボタン を押すというイベントをきっかけとして、 updateメソッドが呼び出される場合がよくあ ります。

ところで、 Subject役がupdateメソッドを呼び出すきっかけが、 当の Observer役である 場合もあります。 このような場合、注意深く設計しないと、 メソッド呼び出しが永遠に続 く可能性があります。 つまり、こういうことです。

Subject の状態が変化 ↓

Observerへ通知

↓

Observer が Subject のメソッドを呼び出す

↓

それによってSubject の状態が変化

Observer

↓

278

あなたの考えを広げるためのヒント 279

現在通知の処理中かどうかをObserver役が判断したり、 通知を送るタイミングを Subject役が考慮したりといった対策が必要になるでしょう。

更新のためのヒント情報の扱い

Number Generator は、 update メソッドを使って 「更新されたよ」 とObserverに通知し ています。 update メソッドの引数として与えられているのは、呼び出しを行ったNumber Generatorのインスタンスだけでした。 Observerはupdateメソッドの中でgetNumber を 呼び出し、必要な情報を得なければなりません。

でも、このサンプルプログラムに限っていえば、 update メソッドの引数として、 更新 された数そのものを与えてもかまいません。 つまり、

void update (NumberGenerator generator);

ではなく、

. (1)

void update (NumberGenerator generator, int number);

. (2)

あるいは、もっと単純に、

void update (int number);

というメソッドにしてしまうのです。

(1) では、 Subject役だけを渡しています。 Observer は、 そのSubject役から必要に応じ て情報を得ます。

(2) では、 Subject役に加えてヒント情報 (ここでは更新情報のすべて) を渡しています。 これにより、 Observer は Subject役から情報を得る手間が省けます。 ただし、このような ヒント情報を与えるということは、 Subject役は Observer役の処理内容を意識しているこ とになります。

サンプルプログラムよりも複雑なプログラムの場合、 本当に Observer役に必要な情報 は何なのかを Subject役に意識させるのは負担になります。 例えば、 前回のupdateメソッ ドを呼び出してから現在までの間に更新された情報だけを送るとしましょう。このとき、 Subject 役は差分の計算を行わなければなりません。 ですから、どの程度のヒント情報を update メソッドに与えるかは、プログラムの複雑さをよく考慮して判断しなければなり ません。

(3) では、(2)をもっと簡略化して、 Subject 役まで省略しています。 サンプルプログラ ムの場合は、これでも動きますが、 1つのObserver 役が複数のSubject役を観察する場合 には不適切です。渡されてきた数がどのSubject役の情報であるかわからないからです。

第17章 Observer状態の変化を通知する

「観察」 よりも 「通知」 になっている

observer という言葉の本来の意味は 「観察者」 ですが、 実際には Observer役は能動的に 「観察」 するのではなく、 Subject役から 「通知」 されるのを受動的に待っていることにな ります。 Observer パターンは、 Publish Subscribeパターンと呼ばれることもあります。 publish (発行)とsubscribe (購読) という表現の方が、実態にあっているかもしれませ パブリッシ んね。

|Model/View/Controller (MVC)

Model/View/Controller (MVC) という言葉を聞いたことはありますか。 MVCの中の Model と Viewの関係は、 ObserverパターンのSubject役とObserver役の関係に対応します。 Model は、 「表示形式に依存しない内部モデル」 を操作する部分のことです。 また、 View はModel を 「どのように見せるか」を管理している部分です。 一般に、 1つのModelに複 数のViewが対応します。

関連しているパターン

Mediator パターン (第16章)

Mediatorパターンでは、 Mediator 役と Colleague役の通信に Observerパターンを使う場 合があります。

MediatorパターンとObserverパターンは、どちらも 「状態変化を通知する」という点 では似ています。 しかし、パターンの目的や視点は異なります。

Mediatorパターンでも、状態変化が通知されます。 しかし、それはColleague役の調停 という目的で動いているMediatorパターンの一部にすぎません。

Observerパターンでは、 Subject役の状態変化をObserver 役 (複数かもしれない) に通 知すること 通知して同期をとることに主眼があります。

この章で学んだこと

この章では、オブジェクトの状態変化を他のオブジェクトに通知するObserverバター ンについて学びました。

280

問題 281

練習問題

問題 17-1

解答は付録A (p.460)

NumberGeneratorクラス (List 17-2) を拡張して、数がだんだん増加していく機能を 持つ Incremental Number Generator というサブクラスを作ってください。 コンストクラ タの引数として、

・開始する数 ・終了する数 (この数を含まない) ·增加分

という3個のint を渡すことにします。 そして、 DigitObserverクラスとGraphObserver クラスに動作を観察させるプログラムを作ってください。

Incremental Number GeneratorクラスはList 17-7 のように使うものとします。 実行結 果を Fig.17-4 に示します。 10以上50未満の数が5刻みで表示されています。

List 17-7 Incremental NumberGenerator > Main 757 (Main.java)

public static void main(String[] args) { NumberGenerator generator = new Incremental NumberGenerator (10,50,512 Observer observer1 = new Digit Observer(); 1: public class Main ( 2: 3: 4: 5: 6: 7: 8: 9: 10: ) Observer observer2 = new GraphObserver(); generator.addObserver (observer1); generator.addObserver (Observer2); generator.execute();

17章 Observer状態の変化を通知する

|Fig.17-4 実行結果

DigitObserver:10 GraphObserver: DigitObserver:15 Graphobserver:*** DigitObserver:20 GraphObserver:* DigitObserver:25 GraphObserver:*** DigitObserver:30 GraphObserver:** DigitObserver:35 GraphObserver:* DigitObserver:40 GraphObserver:** DigitObserver:45 GraphObserver:*

●問題17-2

サンプルプログラムに追加する形で、 新たなConcrete Observer役を自由に作ってくだ さい。 Mainクラス (List 17-6) を変更して、そのConcreteObserver役を利用するように しましょう。

第

282

第18章 Memento

状態を保存する

章 Memento 状態を保存する

第18

Memento パターン

テキストエディタを使っているとき、 必要なテキストを誤って削除してしまっても、ア ドゥ (やり直し) という機能を使えば、削除する前の状態にテキストを復元することが できます。 アンドゥを繰り返せば、 編集作業をいくらでも過去にさかのぼれます。

オブジェクト指向のプログラムでアンドゥを行うには、インスタンスの持っている情報 を保存しておく必要があります。 ただし、保存しておくだけでは駄目で、保存しておいた 情報からインスタンスを元の状態に復元できなくてはいけません。

インスタンスを復元するためには、 インスタンス内部の情報に自由にアクセスできる必 要があります。 しかし、不用意にアクセスを許してしまうと、そのクラスの内部構造に依 存したコードがプログラムのあちこちに散らばり、クラスの修正がしにくくなってしまい ます。 これをカプセル化の破壊といいます。

インスタンスの状態を表す役割を導入して、カプセル化の破壊におちいることなく保存 と復元を行うのが、この章で紹介する

メメント Memento パターン

です。

Mementoパターンを利用すると、 プログラムに対して、

undo (やり直し)

・ redo (再実行)

history (作業履歴の作成)

ヒストリー

snapshot (現在状態の保存)

アンドゥ

スナップショット

などを行うことができます。

memento という英単語は、 「記念品」 「形見」 「思い出の種」という意味です。 「思い出 の写真」が、引き出しの奥からぽろっと出てきたとしましょう。 なつかしい写真を見ると、 その頃の記憶がどっとよみがえってきて、 まるでその時代に戻ったかのような気持ちにな りますね。 Mementoパターンは、ちょうどそのようなデザインパターンです。ある時点 でのインスタンスの状態をパチリと記録して保存しておき、 あとでインスタンスをその時 点の状態に戻してやるのです。

.

284

サンプルプログラム

サンプルプログラム

Mementoパターンを使ったサンプルプログラムを読んでみましょう。 ここで作るサンプルプログラムは、 「フルーツを集めていくさいころゲーム」 です。 ル ールは単純です。

. このゲームは自動的に進みます。 ・ゲームの主人公はさいころを振り、その目が次の状態を決定します。 ・いい目が出ると主人公のお金が増えます。 ・悪い目が出るとお金が減ります。 ・特にいい目が出ると、 主人公はフルーツをもらいます。 ・お金がなくなったら終了します。

プログラムの中では、 お金が貯まったところで、 将来のために Mementoクラスのインス タンスを作って、 「現在の状態」 を保存します (save)。 保存するのは現在持っているお金 とフルーツです。 もしも負け続けてお金が減ってきたら、 お金がなくなって終了しないよ うに、以前保存しておいた Mementoのインスタンスを使って、以前の状態を復元します (restore)。

以上のような小さなプログラムを通して、 Mementoパターンを理解しましょう。

Table 18-1 クラス一覧

パッケージ 名前 解說 game Memento Gamerの状態を表すクラス game Gamer ゲームを行う主人公のクラス。 Mementoのインスタンスを作る 無名 Main ゲームを進行させるクラス。 Mementoのインスタンスを保存しておき、 必要 に応じてGamerの状態を復元する

| Memento クラス

Mementoクラス (List 18-1) は、 主人公 (Gamer) の状態を表現するクラスです。 MementoクラスとGamerクラスは、共通のパッケージgameに置くことにします。 Mementoクラスが持つフィールドは、 money と fruitsです。 moneyは現在の所持金、 fruits は現在持っているフルーツです。

get Money メソッドは、 現在の所持金を得るメソッドです。

285

18章 Memento 状態を保存する

第

Fig.18-1 サンプルプログラムのクラス図

Main game Requests▸ Gamer -money -fruits -random -fruitsName +getMoney +bet +createMemento +restoreMemento +toString -getFruit Creates- Memento -money -fruits

+getMoney

"Memento

"addFruit

Memento クラスのコンストラクタには、public がついていません。 ですから、 Memento クラスのインスタンスは誰でも作れるわけではなく、 同じパッケージ(ここではgameパ ッケージ)に属しているクラスからしか使うことはできません。 具体的には、Memento ク ラスのインスタンスは、 game パッケージのGamerクラスが生成します。

addFruitメソッドは、フルーツを追加するメソッドです。 このメソッドもpublic にな っていません。フルーツを追加できるのは、同じパッケージのクラスだけです。 ですから、 gameパッケージの外からは、 Mementoの内部を変更することはできません。

なお、Mementoクラスの中に 「narrow interface」 と 「wide interface」 というコメントが 入っていますが、この意味については後ほどp.293で詳しく解説します。

List 18-1 Memento クラス (Memento.java)

1: package game;

2:

3: import java.util.ArrayList;

286

サンプルプログラム 287

4: import java.util.List;

5:

6: public class Memento (

// 所持金

private int money;

private List<String> fruits; // フルーツ

7:

8:

// 所持金を得る ( narrow interface)

10:

11:

12:

public int getMoney () (

return money:

13:

// コンストラクタ (wide interface)

Mementor (int money) (

15:

14:

16:

17:

this.money=money;

18:

this.fruits = new ArrayList<>();

19:

20:

)

21:

// フルーツを追加する (wide interface) void addFruit (String fruit) (

22:

fruits.add(fruit);

23:

24:

// フルーツを得る (wide interface) List<String> getFruits() {

25:

}

26:

27:

28:

return new ArrayList<> (fruits);

29:

30: )

}

| Gamer クラス

Gamer クラス (List 18-2) は、 ゲームを行う主人公を表現しているクラスです。 所持金 (money) とフルーツ (fruits) と乱数生成器 (random) を持っています。 また、 クラス フィールドとしてフルーツの名前 (fruitsName) を持っています。

ペット ゲームの中心となるメソッドは、 bet (賭ける) です。 このメソッドは、 もしも主人公 が破産していなかったら、 サイコロを振り、その目に従って所持金やフルーツの個数を変 化させます。

createMemento は、 現在の状態を保存する (スナップショットを撮る) メソッドです。 createMemento メソッドでは、 Mementoの作成を行います。 ここでは、現時点での所持金 とフルーツを元に、 Mementoのインスタンスを1つ作っています。 このようにして作られ たMemento インスタンスは、 「現在のGamer インスタンスの状態」を表現しています。 これ が、 createMemento メソッドの戻り値となります。 パチリと写真を撮るように、 現在の状

9:

18章 Memento 状態を保存する

288 第

態をMemento インスタンスに閉じ込めたのです。 フルーツについては、「おいしい」もの だけを保存することにしましょう。

restoreMemento は createMemento メソッドの逆で、アンドゥを行うメソッドです。 与 えられたMemento インスタンスを元に、自分の状態を復元します。 ゲームで 「復活の呪文」 を唱えるようなものです。

List 18-2 Gamer クラス (Gamer.java)

1: package game;

2:

3: import java.util.ArrayList;

4: import java.util.List;

5: import java.util.Random;

6:

7: public class Gamer (

// 所持金

8:

private int money;

9:

// フルーツ

10:

private List<String> fruits = new ArrayList<>();

11:

// 乱数生成器

12:

private Random random= new Random();

13:

14:

15: 16: 17: 18: }; 19: // フルーツ名の表 private static String[] fruitsName = { リンゴ ぶどう バナナ みかん

20:

// コンストラクタ public Gamer (int money) { this.money=money:

21:

22:

23: 24:

25:

26:

// 現在の所持金を得る public int getMoney() ( return money: }

27:

28:

29:

// 賭ける・・・ゲームの進行 30: 31: 32: 33: 34: 35: 36: 37: public void bet() { // サイコロを振る int dice = random.nextInt(6) + 1; if (dice == 1) { // 1の目･･･ 所持金が増える money += 100; System.out.println("所持金が増えました。 ");

38:

サンプルプログラム 289

39:

40:

41:

42:

43:

44:

45:

46:

47:

} else if (dice == 2) { // 2の目・・・所持金が半分になる money/= 2; System.out.println("."); } else if (dice == 6) ( // 6の目フルーツをもらう String getFruit(); System.out.println(7- (++)651LA."); fruits.add(f); } else { // それ以外何も起きない System.out.println(6) #ATLA "); )

48:

50:

52: 53: 54: 55: 56: 57: 58: 59: // スナップショットをとる public Memento createMemento () ( Memento m = new Memento (money); for (String f: fruits) ( // フルーツはおいしいものだけ保存 if (f.startsWith()) ( m.addFruit (f); 60: } 61: } 62: return m; 63: }

// アンドゥを行う public void restoreMemento (Memento memento) { this.money this.fruits memento.getMoney(); memento.getFruits();

49:

69:

@Override

70:

71:

51:

64:

65:

66:

67:

68:

public String toString() (

73:

return "[money

money, fruits fruits +1:

// フルーツを1個得る

private String get Fruit () ()

String f fruitsName [random.nextInt (fruitsName.length)]: if (random.nextBoolean()) (

72:

75:

74:

}

76:

return L + £;

77:

78:

79:

80:

82:

) else (

return f;

81:

83:

84:

85: )

290 第18章 Memento 状態を保存する

| Mainクラス

Main クラス (List 18-3) では、 Gamerのインスタンスを作成し、それを使ってゲーム を行います。 Gamerのbetメソッドを繰り返し呼び、 そのたびに所持金を表示します。

それだけではサイコロまかせのゲームにすぎませんが、 ここでは Mementoパターンを 持金を元に戻します。

導入しています。 変数 memento には、 「ある時点のGamerの状態」 が保存されています。 運よく所持金が増えてきたら、 createMemento を使って現在の状態を保存しておきます。 所持金が足りなくなってきたら、 restoreMemento メソッドにこのmemento を与えて所

Main がGamerのcreateMememto を呼んだり、 restoreMememtoを呼んだりする様子を Fig.18-2に示します。

List 18-3 Main クラス (Main.java)

1: import game. Memento;

2: import game.Gamer:

4: public class Main (

public static void main(String[] args) { Gamer gamer = new Gamer (100);

5:

Memento memento = gamer.createMemento ();

6:

7:

// ゲームスタート

8:

9:

11:

12:

for (int i = 0; i < 100; i++) { System.out.println("==== " + i); System.out.println("現状: gamer

// 最初の状態を保存しておく

// ゲームを進める

// 現在の主人公の状態表示

10:

System.out.println("所持金は" + gamer.getMoney () + "円になりました。");

13:

3:

15:

gamer.bet();

// 回数表示

14:

16:

17:

18:

19:

20:

// Mementoの取り扱いの決定

if (gamer.getMoney () > memento.getMoney()) {

21:

System.out.println("だいぶ増えたので、現在の状態を保存しておこう!*); memento gamer.createMemento();

22:

23: 24:

);

} else if (gamer.getMoney () <memento.getMoney() / 2) (

System.out.println("だいぶ減ったので、以前の状態を復元しよう!*); gamer.restoreMemento (memento);

25:

26:

27:

// 最初の所持金は100

// 時間待ち

try{

28:

29:

サンプルプログラム 291

30: 31: Thread.sleep(1000); } catch (InterruptedException e) { System.out.println(); 32: ) 33: 34: 35: 36: )

Fig.18-2 サンプルプログラムのシーケンス図

Main

:Gamer

createMemento

new

:Memento

addFruit

restoreMemento

第18章 Memento状態を保存する

Fig.18-3 実行結果例(一部)

現状: [money = 100, fruits = []] 何も起こりませんでした。 所持金は100円になりました。

0

==== 1

現状: [money=100, fruits = []]

何も起こりませんでした。

所持金は100円になりました。

2 現状: [money=100, fruits = []] 所持金が半分になりました。 所持金は50円になりました。

(中略)

現状: [money = 600, fruits = [おいしいリンゴ, バナナ, みかん リンゴ]] 所持金が増えました。

42

所持金は700円になりました。

だいぶ増えたので、現在の状態を保存しておこう!

==== 43

現状: [money = 700, fruits = [おいしいリンゴ、バナナ, みかん リンゴ]]

Mementoの作成

フルーツ(リンゴ)をもらいました。

所持金は700円になりました。

====44

現状: [money = 700, fruits = [おいしいリンゴ, バナナ, みかん, リンゴ,リンゴ]]

フルーツ(おいしいリンゴ)をもらいました。

所持金は700円になりました。

(中略)

-48

現状: [money = 350, fruits = [おいしいリンゴ、バナナ, みかん, リンゴ, リンゴ, おいしいリンゴ]] 所持金が半分になりました。

所持金は175円になりました。

だいぶ減ったので、以前の状態を復元しよう!

Memento による状態復元

49

現状: [money = 700, fruits = [おいしいリンゴ ] ]

所持金が半分になりました。

所持金は350円になりました。

50

現状: [money = 350, fruits = [おいしいリンゴ]]

何も起こりませんでした。

所持金は350円になりました。

(後略)

292

Memento パターンの登場人物

Memento パターンの登場人物

Memento パターンの登場人物は、次のとおりです。

オリジネイター Originator (作成者)の役

Originator役は、自分の現在の状態を保存したいときに Memento役を作ります。 Originator 役はまた、 以前の Memento役を渡されると、 その Memento役を作った時点の状態に 戻る処理を行います。 サンプルプログラムでは、Gamerクラスがこの役をつとめました。

イント Memento (記念品) の役

Memento 役は、 Originator役の内部情報をまとめます。 Memento役は、 Originator 役の 内部情報を持っていますが、その情報を誰にでも公開するわけではありません。 Memento役は、次の2種類のインタフェース (API) を持っています。

ワイド・インタフェース ⚫ wide interface ... 広いインタフェース (API)

Memento 役が提供する「広いインタフェース (API)」 は、 オブジェクトの状態を元に 戻すために必要な情報がすべて得られるメソッドの集合です。 広いインタフェース (API) は Memento役の内部状態をさらけだしてしまいますから、これを使えるのはOriginator 役 だけです。

ナローインタフェース narrow interface･･･ 狭いインタフェース (API)

Memento 役が提供する「狭いインタフェース (API)」 は、 外部の Caretaker役に見せる ものです。 狭いインタフェース (API)でできることには限りがあり、内部状態が外部に 公開されるのを防ぎます。

この2種類のインタフェース (API) を使い分けることで、オブジェクトのカプセル化 の破壊を防ぐことができます。

サンプルプログラムでは、 Memento クラスがこの役をつとめました。

Originator役と Memento役は非常に親密な関係にあります。

テイカ Caretaker (世話をする人) の役

Caretaker役は、現在のOriginator 役の状態を保存したいときに、そのことをOriginator 役に伝えます。 Originator役はそれを受けてMemento役を作り、 Caretaker役に渡します。 Caretaker役は将来の必要に備えて、 そのMemento 役を保存しておきます。 サンプルプロ グラムでは、 Main クラスが Caretaker 役をつとめました。

293

第18章 Memento 状態を保存する

しかし、 Caretaker 役は、 Memento 役の持つ2種類のインタフェース (API) のうち、 「狭いインタフェース (API)」 しか使えませんので、 Memento役の内部情報にアクセスで きるわけではありません。 ただ、 作ってもらったMemento役を、 ひとかたまりのブラッ クボックスとして、まるごと保存しておくだけです。

Originator役と Memento 役は広いインタフェースで結びついていますが、 Caretaker 役 とMemento役は狭いインタフェースで結びついています。 Memento役は Caretaker役に対 して情報隠蔽を行っています。

| Fig.18-4 Memento パターンのクラス図

Caretaker package Requests▸ Originator createMemento restoreMemento Creates▾ Memento <<wide interface>> "get ProtectedInfo << narrow interface>> +get Public Info

あなたの考えを広げるためのヒント

2つのインタフェース (API)とアクセス制御

Mementoパターンに登場する2つのインタフェース (API) を実現するために、サンプ

294

あなたの考えを広げるためのヒント 295

ルプログラムでは、Javaのアクセス制御の機能を使いました。 Javaのメソッドやフィール ドには、 Table 18-2に示す4種類のアクセス制御が用意されています。

Table 18-2 メソッドやフィールドのアクセス制御

アクセス修飾子 解說 public どのクラスからも見える protected なし そのパッケージおよびサブクラスから見える そのパッケージだけから見える private そのクラスだけから見える

Memento クラスのメソッドやフィールドには、 public がついているものと、 private が ついているものと、 何もついていないものの3種類があります。 これは、そのメソッドや フィールドをどのクラスに見せ、どのクラスに見せないかをプログラム上で表現するため です (Table 18-3)。

Table 18-3 Memento クラスで使われているアクセス制御

アクセス修飾子 メソッド private private public なし なし フィールド 誰に見える? コンストラクタ money Memento クラス fruits Memento クラス getMoney Memento クラス、 Gamer クラス、 Main クラス Memento addFruit Memento クラス、 Gamerクラス Memento クラス、 Gamer クラス

Mementoクラスでは、 getMoney メソッドだけにpublicをつけて、狭いインタフェース

(API) にしています。 このメソッドは、 Caretaker 役のMain クラスからも利用できます。 ここでちょっと補足します。 public がついているのに「狭い」というのは、 変な感じ がするかもしれません。 ここでいう「狭い」 とは、 「内部状態を操作できる度合いが少な い」という意味です。 Mementoクラスが持っているメソッドのうち、 public がついてい るものは getMoney ただ1つです。 つまり、できるのは所持金を得ることだけでした。 そ のような 「できることが少ない」という状態を「狭い」と表現しているのです。

Caretaker役のMain クラスは、 game パッケージに含まれていませんから、 Memento クラ スのpublicなメソッドであるget Money しか使うことができません。 ですから、この Mainクラスは、 Memento クラスの内容を勝手に変えることはできません。

Main クラスができることは、 getMoney メソッドで所持金を得ることと、 Memento クラ スのインスタンスを変数などに保持しておくことだけです。

Main クラスには、 Mementoのコンストラクタも見えないことに注意してください。 コ ンストラクタが見えないということは、 Main クラスの中で、

第18章 Memento 状態を保存する

new Memento (100)

のようにMementoのインスタンスを作ることはできないということです。 このように書く とコンパイル時のエラーになります。 Main クラスは、 Mementoのインスタンスが必要なと createMementoメソッドを呼び出して 「現在の状態を保存したいので Mementoのイ ンスタンスを作ってください」 とGamerクラスにお願いするしかありません。

以上のように、 アクセス制御を用いれば「このクラスにはこのメソッドを見せるけれど、 あのクラスには見せない」ということをプログラムで表現できるのです。

なお、ここで解説したのは Javaが持つアクセス制御の概略です。 大規模なプログラムで は Javaのモジュールとも組み合わせて細かいアクセス制御を定める場合があります。

| Mementoをいくつ持つ?

サンプルプログラムでは、 Main クラスが持っている Memento は1つだけでした。 Main クラスが配列などを使ってMementoのインスタンスを複数個持つようにすれば、 インスタ ンスのさまざまな時点での状態を保存しておくことができます。

Mementoの賞味期限は?

サンプルプログラムのように、 メモリ上だけに Memento を保持しておく場合にはあまり 問題はありませんが、 練習問題 18-4でお話するように、 Memento をファイルとして永続的 に保存する場合には、 Mementoの 「賞味期限」 が問題となります。

ある時点のMemento をファイルとして保存しておいたとしても、その後プログラムがバ ージョンアップされたら、ファイルとして保存されている Memento との整合性がとれなく なってしまう恐れがあるからです。

Caretaker役とOriginator 役を分けることの意味

「アンドゥをやりたかったら、 Originator役にその機能を作りこめばいいじゃないか わ ざわざデザインパターンなどを持ち出す必要はあるのかな?」 という疑問を持つ読者もい るかもしれません。

Caretaker役は、どのタイミングでスナップショットを撮るかを決め、いつアンドゥす るかを決め、そしてMemento役を保持するという仕事を行います。

一方、Originator 役は、 Memento役を作る仕事と、与えられた Memento役を使って自 分の状態を元に戻す仕事を行います。

Caretaker役と Originator 役とは、 以上のように役割分担を行っていることがわかります。

296

この章で学んだこと

このように役割分担しておけば、

・複数ステップのアンドゥを行うように変更したい アンドゥするだけではなく、 現在の状態をファイルに保存したい

という修正を行いたいときにも、 Originator役を変更する必要はまったくありません。

関連しているパターン

Command パターン (第22章) Commandパターンを使って命令を処理する場合に、 Mementoパターンを使ってアンド ゥやリドゥを行うことができます。

Prototype パターン (第6章)

Memento パターンでは、 スナップショットとアンドゥのため、現在のインスタンスの 状態を保存します。 保存するのは復元のために必要な情報だけです。

Prototypeパターンでは、現在のインスタンスと同じ状態の別のインスタンスを作りま す。 インスタンスの内容は、 全部コピーされます。

State パターン (第19章) Memento パターンでは、 インスタンスが 「状態」を表現します。 Stateパターンでは、クラスが 「状態」 を表現します。

この章で学んだこと

この章では、現在のオブジェクトの状態を記録し、保存するためのMemento パターン を学びました。 オブジェクトの内部状態をできるだけ公開せずに、 オブジェクトの状態を 保存する方法を考えました。

Caretaker役は Originator 役にお願いして、「現在の状態」 を表現する Memento 役を作っ てもらう (記念写真をパチリ)。 Caretaker 役は Memento 役の内部情報は知らないし、気 にしない。 Caretaker役は、 将来の復元に備えて、大事に Memento役を保存しておく。そ して、必要なときに引き出しの奥から Memento役を取り出して、 Originator 役に渡すと、 きちんと復元される。これが Mementoパターンでした。

情報を見せる/見せないの制御をするために、 public, protected, private などのア クセス制御を使う方法も確認しましたね。

297

18章 Memento状態を保存する

第

解答は付録A (p.464)

【練習問題

●問題 18-1

Caretaker役は、狭いインタフェース (API) を通じてしか Memento役を操作できませ ん。 もしCaretaker役がMemento役を自由に操作できるとすると、 どのような不都合があ りますか。

●問題 18-2

サンプルプログラムでは、所持金とフルーツだけが状態を定めるものでした。 しかし保 存すべき情報が大量の場合は、 Mementoのインスタンスを保存するためには、大きなメモ リ空間やディスク空間が必要となります。 これに対処する方法を考えてください (この問 題は、GoF本(付録D [GoF] 参照) を参考にしました)。

問題18-3

Memento クラス (List 18-1) に新しいフィールド、

Java

int number;

を付け加え、このフィールドの値に関して、クラスごとに以下のような制御を行いたいと します。 どうしたら実現できるでしょうか。

Memento クラスは、 number の値を得ることも、変更することもできる Gamerクラスは、 numberの値を得ることができるが、変更することはできない Main クラスは、 number の値を得ることも、変更することもできない

問題18-4

Java

Memento をファイルに保存することを考えてみましょう。 Mementoのクラスメソッドと して、次の2つを実装してください。

boolean saveToFile (String filename, Memento memento)

Mementoのインスタンスが持つ情報をファイルに保存する。 ファイル名は filename で指定する。

書き込みに成功したらtrueを返し、 失敗したら false を返す。

Memento loadFromFile (String filename)

saveToFileで保存したファイルの情報を元にMementoのインスタンスを生成す る。 ファイル名は filename で指定する。

298

ファイルの読み込みに失敗した場合にはnullを返す。

また、それを使って以下の機能を満たすようにサンプルプログラムを変更してください。

(1) プログラム起動時にファイル game.dat が存在しないときは、 所持金100円からス タートする。 存在するときは、そのファイルに保存されていた状態からスタート する。 (2) サンプルプログラム同様に所持金が 「だいぶ増えた」ときに、現在の状態をファ

イルgame.dat に保存する。

【注意】

Javaのインスタンスをファイルに保存する方法としてシリアライズ (直列化、 Serialization) がよく用いられます。 しかし、 信頼できないデータを復元する場合にセキュリティ上の重 大な問題を起こす場合があります。 詳しくはJavaの java.io.Serializableのドキュメン トならびに "Secure Coding Guidelines for Java SE" を参照してください。

「Effective Java」 (付録D [Bloch] 参照) では、 「あなたが作成する新たなシステムで Javaのシリアライズを使う理由はありません」とまで書かれています。

問題18-4の解答では、シリアライズを用いず、 Memento が持つ情報を改行区切りの文 字列としてファイルに保存しています。

*: https://www.oracle.com/java/technologies/javase/seccodeguide.html

299

Java



第19章 State

状態をクラスとして表現する

第19章 State状態をクラスとして表現する

State パターン

Javaでオブジェクト指向プログラミングを行うとき、プログラムする対象を「クラス」 として表現します。 どのようなものをクラスとして表現するかは、 設計をする人が考える ことになります。 クラスに対応する具体的な 「もの」 が実世界に存在する場合もあります し、存在しない場合もあります。 ときには、 「こんなものがクラスになるの?」 と驚くよ うなものをクラスにする場合もあります。

この章で学ぶ

ステート State パターン

では、 「状態」 というものをクラスとして表現します。 stateとは英語で 「状態 (ものごと のありさま)」を意味します。現実世界で私たちは、 いろんなものの「状態」について考 えます。 しかし、状態を「もの」として考えることはめったにありません。 ですから 「状 態をクラスで表現する」というのは、なかなか理解しにくいかもしれません。

この章では、「状態」 をクラスで表現する方法について学びます。 状態をクラスとして 表現していれば、 クラスを切り替えることによって「状態の変化」 が表せますし、 新しい 状態を追加しなければならないときに何をプログラムすればよいかがはっきりします。

サンプルプログラム

Stateパターンを使ったサンプルプログラムを読んでみましょう。

金庫警備システム

ここでは、時刻ごとに警備の状態が変化する金庫警備システムを考えてみましょう。 金 庫警備システムといっても、 Table 19-1のような単純なものです。 このシステムの構成図 をFig.19-1に示します。

このような金庫警備システムをプログラムで実現してみましょう。 実際に警備センター を呼び出すわけにはいかないので、画面に呼び出し状況などを表示してすませることにし ます。 また、時間の経過はリアルタイムだと試すのが大変なので、 プログラム上の1秒を 実世界の1時間と仮定します。 実行の様子を Fig.19-2に示します。

302

サンプルプログラム 303

Table 19-1 金庫警備システム

・金庫が1つある ・金庫は警備センターと接続されている ・金庫には非常ベルと通常通話用の電話が接続されている ・金庫には時計がついていて、現在の時刻を監視している ・昼間は 9:00 ~ 16:59. 夜間は17:00 ~ 23:59 および 0:00~8:59 の範囲である ・金庫は昼間だけ使用できる 昼間、 金庫を使用すると、 警備センターに使用記録が残る ・夜間、 金庫を使用すると、 整備センターに非常事態の通報が行く 非常ベルはいつでも使用できる 非常ベルを使用すると、 警備センターに非常ベルの通報が行く ・通常通話用の電話はいつでも使用できる (が、 夜間は録音のみ) 昼間、電話を使用すると、警備センターが呼び出される

・夜間、電話を使用すると、整備センターの留守録が呼び出される

Fig.19-1 金庫警備システムの構成図

時計 金庫 金庫使用 通常通話用 非常ベル ボタン 電話 警備 センター

Fig.19-2 サンプルプログラム実行の様子

現在時刻は 03:00 call! 非常: 夜間の金庫使用! record 金庫使用(昼間) ・・・ call! 非常ベル (昼間 call! 通常の通話(昼間) call! 非常 夜間の金庫使用! call! 非常ベル (夜間) record 夜間の通話録音 State Sample 金庫使用 非常ベル 通常通話 終了

304 第19章 State状態をクラスとして表現する

Stateパターンを使わない擬似コーディング

Stateパターンを使ったサンプルプログラムの説明に入る前に、 あなただったらどんな 風にプログラミングするか、少し考えてみてください。 私だったら、前節を読んで、 頭の中でこう考えます。

「まあ、要するに現在の時刻によってシステムの振る舞いが変わるのだな。 金庫使用、 非常ベル 通常通話という3つの出来事のどれかが起こり、その結果、警備センターに何 らかの連絡がいくのだ。 で、 連絡の内容が時刻によって変化する...と」

そして、 List 19-1のような擬似コードを思い浮かべるかもしれません。 そのあとで、 この擬似コードをプログラミング言語で実際に表現するにはどうするかを考えるでしょう ね。

List 19-1 State パターンを使わない金庫警備システムの擬似コード (1)

警備システムのクラス( 金庫使用時に呼ばれるメソッド() ( if () ( 警備センターに利用の記録 } else if (夜間) ( 整備センターに非常事態の通報 非常ベル使用時に呼ばれるメソッド() { 整備センターに非常ベルの通報 ) 通常通話時に呼ばれるメソッド() ( if (昼間) { 警備センターの呼び出し } else if (夜間) ( 警備センターの留守録の呼び出し

Stateパターンを使った擬似コーディング

さて、 List 19-1のやり方は決して間違っているわけではありません。 しかし、この章 で紹介するStateパターンは、これと同じことを、 まったく違う観点で考え、 List 19-2の ようにプログラミングするものです。

サンプルプログラム

List 19-2 Stateパターンを使った金庫警備システムの擬似コード (2)

昼間」という状態を表現するクラス( 金庫使用時に呼ばれるメソッド() { 整備センターに利用の記録 非常ベル使用時に呼ばれるメソッド () { 整備センターに非常ベルの通報 通常通話時に呼ばれるメソッド ( 整備センターの呼び出し }

夜間という状態を表現するクラス ( 金庫使用時に呼ばれるメソッド() { 整備センターに非常事態の通報 } 非常ベル使用時に呼ばれるメソッド () ( 警備センターに非常ベルの通報 ) 通常通話時に呼ばれるメソッド () { 警備センターの留守録の呼び出し

2つの擬似コードの違いがわかりますか。

Stateパターンを使わない方 (1) では、昼間・夜間という状態は各メソッドの中のif文の ところに登場します。 そして、各メソッドの中で現在の状態チェックを行います。 一方、 Stateパターンを使う方 (2) では、昼間・夜間という状態がクラスとして表現され

ています。 状態がクラスとして表現されていますので、 その中のメソッドには、もはや現 在の状態チェックをするためのif文は登場しません。

(1) では 「状態」がメソッドの中に書かれていますが、 (2) ではクラスとして書かれてい ます。 メソッドの奥深くに埋もれていた「状態」を掘り起こして、 外側に引きずり出した 様子がつかめますか。

それでは、(1)(2)を頭の片隅に置いて、サンプルプログラムを読んでいくことにいた しましょう。

305

306 第19章 State状態をクラスとして表現する

Table 19-2 クラスとインタフェース一覧

名前 解說 State 金庫の状態を表すインタフェース DayState State を実装しているクラス。 昼間の状態を表す NightState State を実装しているクラス。 夜間の状態を表す Context SafeFrame Main 金庫の状態変化を管理し、警備センターとの連絡をとるインタフェース Context を実装しているクラス。 ボタンや画面表示などのユーザインタフェースを持つ 動作テスト用のクラス

State インタフェース

Stateインタフェース (List 19-3) は、 金庫の状態を表すものです。 Stateインタフェー スは、

・時刻が設定されたとき ・金庫が使用されたとき ・非常ベルが押されたとき ・通常通話を行うとき

という出来事に対応して呼び出されるインタフェース (API) を規定しています。 先ほど お見せした擬似コードで 「金庫使用時に呼ばれるメソッド」などと表現していたものが、 このインタフェース (API) です。 ここで規定されているメソッドはすべて状態に応じて 処理が変化するものになります。 すなわち、 State インタフェースは状態依存のメソッド の集まりなのです。

引数で渡されているContext は、 状態の管理を行っているインタフェースですが、詳し くは、後で見ていくことにします。

List 19-3 State インタフェース (State.java)

1: public interface State { 2: 3: public abstract void doClock (Context context, int hour); public abstract void doUse (Context context); 4: public abstract void doAlarm (Context context); 5: public abstract void do Phone (Context context); 6: ) // 時刻設定 // 金庫使用 // 非常ベル // 通常通話

サンプルプログラム

Fig.19-3 サンプルプログラムのクラス図

<<interface>> Context setClock changeState callSecurityCenter recordLog SafeFrame -state setClock changeState callSecurityCenter recordLog <<interface>> State doClock doUse doAlarm do Phone

DayState

-singleton

NightState

-DayState getInstance

-singleton

doClock doUse

-NightState

getInstance

doAlarm

doPhone

doClock

doUse doAlarm

do Phone

307

第19章 State状態をクラスとして表現する

DayStateクラス

DayStateクラス (List 19-4) は、 昼間の状態を表すクラスです。 このクラスは State インタフェースを実装していますので、 State インタフェースで宣言されているメソッド を実装しています。

状態を表すクラスは、1つずつしかインスタンスを作らないことにします。 状態が変化 するたびに新しいインスタンスを作っていては、 メモリと時間の無駄だからです。 そのた め、 Singletonパターン (第5章) を使っています。

doClockメソッドは、時刻を設定するメソッドです。 引数で与えられた時刻が夜間の時 せんい 刻であれば、夜間の状態へシステムを移行します。 ここで状態の変化 (状態遷移) が起き ます。 ここでは、 ContextインタフェースのchangeStateメソッドを使って状態の変化を 表現しています。 夜間の状態は NightState クラスで表現されており、そのインスタンス は getInstance メソッドで得ています(ここでSingletonパターンを使っていますね。 new NightState()としていないことに注意しましょう)。

douse, doAlarm, doPhoneは、 それぞれ金庫使用、 非常ベル、 通常通話という出来事 に対応したメソッドです。 やっていることは、 Contextのメソッドを呼び出して、必要な 仕事を行うだけです。 これらのメソッドの中に、 「現在の状態をチェックする」というif 文が入っていないことを確認しましょう。 これらのメソッドをプログラミングしていると き、プログラマは常に 「今は昼間の状態だぞ」 と心の中で唱えているようなものです。 Stateパターンでは、状態の違いがクラスの違いとして表現されますので、 if文や switch 文による状態ごとの分岐が不要になるのです。

List 19-4 DayState クラス (DayState.java)

1: public class DayState implements State ( private static DayState singleton = new DayState(); private DayState(){ 2: 3: 4: 5: ) 6: 7: 8: 9: ) 10: 11: 12: public static State getInstance() { return singleton; 13: @Override public void doclock (Context context, int hour) ( if (hour < 9 || 17 <= hour) { 14: context.changeState(NightState.getInstance())

15:

}

308

サンプルプログラム 309

16:

@Override public void doUse (Context context) { } context.recordLog("());

17:

20:

22: 23: 24: 25: 26: 27: 28: 29: : : 32: 33: 34: 35: : :) @Override public void doAlarm (Context context) ( context.callSecurityCenter (()); @Override public void doPhone (Context context) { ) context.callSecurityCenter (ROK()); @Override public String toString() { return []"; }

21:

3637

NightState クラス

NightStateクラス (List 19-5) は、 夜間という状態を表すクラスです。 これもDayState クラス同様、 Singletonパターンを使っています。 構成はDayStateクラスと同じですから、 特に解説は必要ありませんね。

List 19-5 NightState 757 (NightState.java)

19:

3031

1: public class NightState implements State ( private static NightState singleton = new NightState(); private NightState() ( 2: 3: 4: 5: 6: 7: 8: 9: } 10: 11: 12: public static State getInstance() ( return singleton; @Override public void doclock (Context context, int hour) {

18:

310 第19章 State状態をクラスとして表現する

13:

if (9 <= hour && hour < 17) (

context.changeState(DayState.getInstance());

17:

19:

14:

15:

}

16:

@Override

18:

public void douse (Context context) {

context.callSecurityCenter (J!");

20: å

22: Ñ

21: ä

@Override

23: ¤

}

24:

public void doAlarm (Context context) {

context.callSecurityCenter (L ({{|}})) *);

¤ ¤ ¯ 25: 26: 27:

@Override

28: я

public void doPhone (Context context) (

29: я

context.recordLog(**);

30: ä

31: ä

}

32:

}

@Override

33:

public String toString() {

return *[夜間];

1: public interface Context ( 2: public abstract void setClock (int hour); 3: public abstract void changeState (State state); 4: 5: 6: ) public abstract void callSecurityCenter (String msg); public abstract void recordLog (String msg); // 時刻の設定 // 状態变化 // 整備センター警備員呼び出し // 警備センター記録

34:

35:

37:)

)

36:

Context インタフェース

Contextインタフェース (List 19-6) は、 状態を管理したり、 警備センターの呼び出し を行ったりするものです。 実際に何を行うかは、 SafeFrame クラス (List 19-7)を読みな がらお話しましょう。

List 19-6 Context 1371-3 (Context.java)

}

サンプルプログラム 311

| SafeFrameクラス

SafeFrameクラス (List 197) は、 GUI を使って金庫警備システムを実現するものです セイフ (safe は 「金庫」という意味です)。 SafeFrameクラスは、Contextインタフェースを実装 しています。

SafeFrameクラスのフィールドは、画面上に表示されるテキストフィールドやテキスト エリア、 それにボタンなどの部品です。 ただし、 state フィールドだけは画面に登場する 部品ではなく、 金庫の現在の状態を表すためのものです。 最初は 「昼間」の状態に初期化 されています。

コンストラクタでは、次の処理を行います。

・背景色の設定 レイアウトマネージャの設定 • 部品の配置 . リスナーの設定

リスナーの設定は重要ですから、少し詳しく説明しておきましょう。 各ボタンの addActionListener メソッドを呼び出してリスナーを設定します。 このとき、addAction Listener メソッドの引数に 「ボタンが押されたときに呼び出されるインスタンス」 を指 定します。 addActionListenerメソッドの引数は、 ActionListenerインタフェースを実 装している必要があります。 ここでは、 this すなわちSafeFrameのインスタンスを指定 しています(確かに、SafeFrame は ActionListener を implements していますね)。ボタ ンが押されたときにリスナー (listener (聞いている人)) が呼び出されるという機構は、 Observerパターン (第17章) と似ています。

actionPerformedメソッドは、 ボタンが押されたときに呼び出されるメソッドです。 こ のメソッド名は、ActionListener インタフェース (java.awt.event.ActionListener インタフェース) で定められている名前ですから、勝手に変えてはいけません。 このメソ ッドの中では、どのボタンが押されているかを調査し、それに応じた処理を行っています。 ちょっと注意しておきます。 ここに if文が登場していますが、ここでの注文による分 岐は 「ボタンの種類」 に応じたものであって、 「現在の状態」 に応じたものではありませ ん。 「Stateパターンではif文が出てこないといってたのに、ここで出てくるじゃないか」 と誤解しないでくださいね。 なお、 練習問題 19-1では、 ラムダ式を用いてここのif文も なくします。

さて、処理の内容はState パターンにとって重要な部分です。 例えば、 金庫使用ボタン が押されたとき、

state.douse (this);

第19章 State状態をクラスとして表現する

という文が実行されます。 現在の時刻や現在の金庫の状態を調べることなく、いきなり doUse を呼び出していますね。 これがStateパターンの特徴です。 もし、 State パターンを 使わないでプログラミングをした場合には、いきなりdoUse を呼び出すのではなく 「現在 の時刻に応じた処理の分岐」 を行うことになるはずです。

setClockメソッドでは、現在時刻を指定した時刻に設定します。 次の文で、標準出力 に現在時刻を表示します。

312

System.out.println(clockstring);

次の文で、textClock というテキストフィールド(画面最上部)に現在時刻を表示しま す。

textClock.setText(clockstring);

そして、次の文で、 現在の状態に依存した処理を行います (この中で、 状態の遷移が起 こります)。

state.doClock(this, hour);

changeStateメソッドは、 DayState クラスやNightStateクラスから呼び出されます。 このメソッドは、状態の遷移が起こるときに呼び出されるメソッドです。 実際の状態遷移 は、

this.state = state:

という文で行われています。 現在の状態を表しているフィールドに、状態を表すクラスの インスタンスを代入することが、 状態遷移に相当します。

call SecurityCenterメソッドは、 警備センター呼び出しを表現したもので、 recordLog メソッドは、 警備センターの記録を表現したものです。 ここでは、 text Screen というテ キストエリアに文字列を追加しています。 本来なら、ここで実際の警備センターをネット ワークか何かを使って呼び出すところですね。

List 19-7 SafeFrame クラス (SafeFrame.java)

1: import java.awt.BorderLayout:; 2: import java.awt.Button; 3: import java.awt.Color; 4: import java.awt.Frame; 5: import java.awt.Panel; 6: import java.awt.TextArea; 7: import java.awt.TextField; 8: import java.awt.event.ActionEvent;

サンプルプログラム 313

9: import java.awt.event.ActionListener;

10:

11: public class SafeFrame extends Frame implements ActionListener. Context ( 12: private TextField textClock private TextArea text Screen private Button buttonUse private Button buttonAlarm =new Button("J*^*); new TextField(60); new TextArea (10, 60); new Button(""); // 現在時刻表示 // 警備センター出力 // 金庫使用ボタン // 非常ベルボタン // 通常通話ボタン // 終了ボタン new Button(); new Button("T"); 13: 14: 15: 16: 17: private Button button Phone private Button buttonExit

18:

19:

private State state = DayState.getInstance();

20:

22:

23:

現在の状態

// コンストラクタ public SafeFrame (String title) { super (title); setBackground (Color.lightGray); setLayout (new BorderLayout()); // textClock add (textClock, BorderLayout.NORTH); textClock.setEditable(false); panel.add(buttonPhone); panel.add(buttonExit); // そのパネルを配置 add (panel, BorderLayout.SOUTH); // 表示 pack(); setVisible(true); // リスナーの設定 buttonUse.addActionListener(this); // text Screen add (text Screen, BorderLayout.CENTER); text Screen.setEditable (false); // パネルにボタンを格納 Panel panel = new Panel(); panel.add(buttonUse); panel.add(buttonAlarm); buttonAlarm.addActionListener(this); buttonPhone.addActionListener(this); buttonExit.addActionListener(this);

28:

29:

32:

33:

34:

35:

36:

37:

44:

45: 46:

47:

48:

// ボタンが押されたらここに来る @Override public void action Performed (ActionEvent e) { System.out.println(e.toString()); if (e.getSource() == buttonUse) { state.douse (this);

49:

50:

51:

52:

// 金庫使用ボタン

30:

38:

39:

40:

41:

43:

25:

27:

42:

21:

24:

26:

53: 54:

55:

31:

第19章 Sate状態をクラスとして表現する

56:

else if (e.getSource() == buttonAlarm) (//

state.doAlarm(this);

58: 59:

60:

} else if (e.getSource () == buttonPhone) ( //**

state.doPhone (this);

} else if (e.getSource() == buttonExit) ( // 終了ボタン

61:

57:

62:

System.exit(0);

} else {

64:

System.out.println("?");

63:

65:

66:

// 時刻の設定 public void setClock (int hour) { String clockstring = String.format("BE 02:00", hour); System.out.println(clockstring); textClock.setText (clockstring); state.doClock(this, hour); @Override }

67:

// 状態变化

74:

75:

76:

77:

78:

79:

80:

68:

69:

70:

71:

72:

73:

@Override

public void changeState (State state) {

System.out.println(this.state +5 +state LL.");

this.state = state;

81:

82:

警備センター警備員呼び出し

@Override

84:

85:

public void callSecurityCenter (String msg) {

textScreen.append(*call! msg "\n");

87:

88:

83:

)

// 警備センター記録

89:

90:

91:

86:

@Override

public void recordLog (String msg) (

text Screen.append("record

+msg "\n");

92:

93:

94: )

}

}

...

状態遷移の前後でdoUseを行っている様子をシーケンス図 (Fig.19-4) で示します。 はじ めはDayStateの側のdoUse が呼ばれていますが、 changeStateした後では、 NightState の側のdouse が呼ばれています。

)

314

サンプルプログラム 315

Fig.19-4 サンプルプログラムのシーケンス図

Main framework of java.awt :SafeFrame actionPerformed doUse :DayState setClock doClock changeState actionPerformed doUse

NightState

| Mainクラス

Main クラス (List 19-8) は、 SafeFrameのインスタンスを1つ作り、そのインスタンス に対してsetClockで定期的に時刻を設定します。 時刻の設定は1秒ごとに行われますが、 これはプログラムの中では1時間ごとのつもりです。

List 19-8 Main 52 (Main.java)

1: public class Main ( 2: 3: 4: 5: 6: public static void main(String[] args) ( SafeFrame frame = new SafeFrame("State Sample"); while (true) ( for (int hour 0; hour 24; hour++) { frame.setClock (hour); //

第19章 State状態をクラスとして表現する

7: 8: 9: 10: 11: 12: } 13: 14: ) try { Thread.sleep(1000): } catch (InterruptedException e) {

Stateパターンの登場人物

Stateパターンの登場人物は、次のとおりです。

ステート

State (状態) の役

State役は、 状態を表すためのものです。 状態ごとに異なる振る舞いをするインタフェ ース (API)を定めます。 このインタフェース (API) は、 状態に依存した振る舞いをす るメソッドの集まりになります。 サンプルプログラムでは、 State インタフェースがこの 役をつとめました。

コンクリート・ステート ConcreteState (具体的な状態)の役

ConcreteState 役は、具体的な個々の状態を表現するものです。 State役で定められたイ ンタフェース (API) を具体的に実装します。 サンプルプログラムでは、 DayState クラス および NightState クラスがこの役をつとめました。

コンテキスト Context (状況、 前後関係、文脈) の役

Context役は、現在の状態を表す ConcreteState役を持ちます。 また、 Stateパターンの利 用者に必要なインタフェース (API) を定めます。 サンプルプログラムでは、 Context イン タフェースとSafeFrame クラスがこの役をつとめました。

少し補足します。 サンプルプログラムでは、Context インタフェースがインタフェース (API)を定める部分を担い、 SafeFrameクラスがConcreteState役を持つ部分を担いまし た。

316

あなたの考えを広げるためのヒント

| Fig.19-5 Stateパターンのクラス図

state requestX requestY request Z Context methodA methodB methodC methodD ConcreteStatel methodA methodB methodC methodD State ConcreteState2 methodA methodB methodC methodD

あなたの考えを広げるためのヒント

分割して統治せよ

・アンド・コン 分割して統治せよ (divide and conquer) という方針は、プログラミングによく登場し ます。 これは、複雑で大規模なものを取り扱う場合の方針です。 大きくてややこしい問題 は、そのまま解こうとしてはいけません。 その問題をまず小さな問題に分けなさい。 それ でもまだ解きにくかったら、さらに小さな問題に分けなさい。 問題は、簡単に解けるまで 小さくしてから解きなさい。 大きくてややこしい問題を1つ解く代わりに、小さくてやさ しい問題をたくさん解きなさい。・・・分割して統治せよ、というのは、簡単にいえばそうい うことです。

317

318 第19章 Sate状態をクラスとして表現する

State パターンでは、 「状態」 というものをクラスで表現しました。 個々の具体的な状態 を、別々のクラスとして表現して、問題を分割したわけです。1つのConcreteState 役のク ラスをコーディングしている最中、プログラマは、他のクラスのことを (ある程度) 頭か ら追い出すことができます。 今回の金庫警備システムのように、 状態が2つしかない場合 には、あまりありがたみを感じませんが、 状態が多いときには、 Stateパターンはその強 みを発揮します。

p.304 で紹介した擬似コード (1) と (2) を思い出してください。 Stateパターンを使わない と、金庫を使用したときに呼び出されるメソッドの中で、 現在の状態に応じた条件分岐が 発生します。 状態が多くなればなるほど、 この条件分岐が増えていくことになるのです。 しかも、同じような条件分岐は、 出来事が起こったときに呼び出されるメソッド全部に書 く必要があるのです。

Stateパターンは、システムの 「状態」をクラスとして表現することで、 複雑なプログ ラムを分割しているのです。

状態に依存した処理

SafeFrameクラスのsetClock メソッド (p.314) と、 State インタフェースのdoClock メソッド (p.306) の関係について考えましょう。

SafeFrameクラスのsetClockメソッドは、 Main クラスから呼び出されています。 Main クラスは setClockメソッドを 「時刻の設定をしてね」 と呼び出しています。 setClock メソッドの中では、 その処理を

state.doClock(this, hour);

として、 stateに委譲しています。 つまり、 時刻の設定を 「現在の状態に依存した処理」 として扱っているのです。

これは、doClock メソッドに限りません。 State インタフェースで宣言されているメソ ッドというのは、すべて「状態に依存した処理」 であり、 「状態によって振る舞いが異な る処理」なのです。 これは、 当たり前ですが、きちんと押さえておくべきポイントです。 Stateパターンでは、「状態に依存した処理」 というものをプログラムでどのように表現 しているでしょうか。 次の2点にまとめられます。

・抽象メソッドとして宣言し、 インタフェースとする

・具象メソッドとして実装し、 個々のクラスとする

これが、 Stateパターンにおける「状態に依存した処理」 の表現方法なのです。 上記の2点はわざと抽象的に書きましたが、この2点を読んでうなずくことができたら、

.

あなたの考えを広げるためのヒント 319

あなたはState パターンについて、またインタフェースとクラスの関係について、はっき りと理解しているといえるでしょう。

| 状態遷移は誰が管理すべきか

状態をクラスで表現し、 状態に依存した振る舞いを個々の ConcreteState 役に分担させ るのは、とてもよい方法です。

しかし、 Stateパターンを使う場合、 状態遷移は誰が管理すべきかという点には注意し てください。

サンプルプログラムでは、 Context役の SafeFrame クラスが、 状態遷移を実際に行う changeState メソッドを実装しました。 しかし、 changeState メソッドを実際に呼び出し ているのは、 Concrete State 役のDayStateクラスやNightState クラスです。 すなわち、 サンプルプログラムでは、「状態遷移」 を 「状態に依存した振る舞い」 であると見なして いるのです。 このやり方には、良い点と悪い点があります。

良い点は、 「他の状態に遷移するのはいつか」という情報が、1つのクラス内にまとまっ ている点です。 すなわち、 「DayState クラスが他の状態に遷移するのはいつかな?」と知 りたいときには、 DayState クラスのコードを読めばいいのです。

悪い点は、「1つのConcreteState 役が、 他のConcreteState役を知らなければならない」と いう点です。 例えば、 DayState クラスはdoClockメソッドの中でNightStateクラスを使 っています。 これは、 将来 NightStateクラスを削除したくなったときには、 DayStateク ラスも修正する必要が生じるということです。 状態遷移を ConcreteState役にまかせると いうことは、その ConcreteState役が、少なくとも他の ConcreteState 役を知らなければな らないということになります。 つまり、 状態遷移をConcreteState役にまかせてしまうと、 クラス間の依存関係を深めてしまうのです。

サンプルプログラムのようなやり方をやめて、すべての状態遷移をContext 役の SafeFrameクラスにまかせてしまうこともできます。 そうすれば、個々のConcreteState 役 の独立性が高まり、プログラム全体の見通しがよくなる場合があります。 しかし今度は、 Context役が 「すべてのConcrete State 役」 を知らなければならなくなります。ここに Mediatorパターン (第16章) を適用できるかもしれません。

あるいはまた、Stateパターンの代わりに状態のテーブル (表) を使って設計する手も あります。 詳細は省きますが、 テーブルは、 「入力と内部状態」を元に 「出力と次の内部 状態」 が得られるような一覧表になります。 状態遷移が固定的なルールに基づいている場 合には、このようなテーブルを使ったプログラムも有効といえるでしょう。

さらに、状態数が多い場合には、 手で書くのをやめ、 プログラムを自動生成する別のプ ログラムを使う方法もあります。

19章 State状態をクラスとして表現する

320 第

自己矛盾が起こらない

Stateパターンを使わず、 システムの状態が複数の変数の値の集合で表現されていると しましょう。 そのとき、 変数の値の間に自己矛盾や不整合があってはいけません。

Stateパターンでは、状態をクラスで表現します。 現在の状態を表す変数は、たった1つ です。 サンプルプログラムでは、SafeFrameクラスのstate フィールドでした。 state フ ィールドの値が、 システムの状態をずばり決定しています。 このため、自己矛盾をはらん だ状態というのが存在しないことになります。

新しい状態を追加するのは簡単

Stateパターンに新しい状態を追加するのは簡単です。 サンプルプログラムでいえば、 State インタフェースを実装した XXXStateクラスを作り、 必要なメソッドを実装すれば よいからです。 あ、もちろん、 状態遷移の部分は注意深くコーディングする必要がありま す。 状態遷移の部分こそが、 他のConcreteState役との接点となるからです。

しかし、できあがっているStateパターンに、 新しい 「状態依存の処理」 を追加するの は困難です。 それは、 State役のインタフェースにメソッドを追加することを意味し、す べてのConcreteState役に処理を追加することになるからです。

困難ではありますが、しかし、 メソッドの追加をうっかり忘れる危険はありません。 例 えば、サンプルプログラムのStateインタフェースにdoYYYというメソッドを追加したと します。 DayState クラスやNightStateクラスでそのメソッドを実装し忘れたとすると、 ソースをコンパイルするときに「メソッドが実装されていない」というエラーになるから です。

もしStateパターンを使っていなかったら、 どうなるでしょう。 Stateパターンを使って いない場合、状態を考慮するのはif文の中の条件式です。 そのため、「この状態について 実装忘れがあるよ」というエラーをコンパイル時に検出するのは非常に困難になります。 (実行時に検出するのはそれほど難しくありません。 考慮していない状態を検出したらエ ラーにするというコーディングを、各メソッドの中に前もって行っておけばよいからで す。)

複数の顔を持つインスタンス

SafeFrameクラス中に登場した、 以下の2つの文を見てください (p.313)。

関連しているパターン 321

・SafeFrame のコンストラクタの中:

buttonUse.addActionListener(this);

actionPerformed メソッドの中:

state.douse (this);

この2つの文には、 this が登場しています。 このthis は何でしょうか。 もちろん、 どち らもsafeFrameクラスのインスタンスです。 今回のサンプルプログラムでは、SafeFrame のインスタンスは1個しか生成しないので、 この this は同じ値です。

しかし、addActionListener に渡されるときと、 doUse に渡されるときでは、ちょっと 扱いが異なります。

addActionListenerメソッドに渡されるとき、このインスタンスは 「ActionListener イ ンタフェースを実装しているクラスのインスタンス」 として扱われます。 それは、 addActionListener メソッドの引数がActionListener型だからです。 addActionListen erメソッドの中では、 「ActionListener インタフェースで規定されているメソッドの範 囲」で引数が利用されます。 引数として渡されたものが、 SafeFrameのインスタンスなの かどうかは重要ではありません。

一方、douse メソッドに渡されるときは、同じインスタンスが 「Contextインタフェー スを実装しているクラスのインスタンス」 として扱われます。 それは、douse メソッドの 引数がContext 型だからです。 douse メソッドの中では、 「Context インタフェースで規定 されているメソッドの範囲」で引数が利用されるのです (DayStateクラスや NightState クラスのdouseメソッドを読み直せば、はっきりわかります)。

同じ1つのインスタンスが複数の顔を持っていることを、しっかりとつかんでください。

関連しているパターン

Singletonパターン (第5章)

ConcreteState 役は、 Singleton パターンとして実装される場合があります。 サンプルプ ログラムでもSingletonパターンを使っています。 状態を表すクラスは、インスタンスフ ィールド (つまりインスタンスの状態)を持っていないからです。

Flyweight パターン (第20章)

状態を表すクラスはインスタンスフィールドを持ちません。 ですから、 Flyweight パター ンを使って、 ConcreteState役を複数のContext役で共有できる場合もあります。

第19章 State状態をクラスとして表現する

この章で学んだこと

この章では、システムの各状態を個別のクラスで表現するStateパターンについて学び ました。 状態遷移は、状態を表しているクラスのインスタンスを切り替えることで表現し ます。

練習問題

●問題 19-1

解答は付録A (p.468)

Java サンプルプログラムのSafeFrameクラス (List 19-7) はActionListener インタフェー スを実装しており、4種類のボタンのどれが押されてもSafeFrameクラスのactionPerformed メソッドが呼び出されます。 そのため、 actionPerformedメソッドの中でどのボタンが 押されたかを判断する

ためのif文が書かれています。 このif文をなくしてみましょう。 addActionListenerメソッドを使ってボタンにリスナーを設定する際に、引数として this (SafeFrameのインスタンス) を渡すのではなく、 「そのボタンが押されたときに行 うべき処理」をラムダ式で表現して渡すようにサンプルプログラムを修正してください。 例えば、 buttonUse に関しては次のようになります。

// ボタンが押されたときのリスナーをラムダ式で設定 buttonUse.addActionListener (e> state.doUse (this)):

●問題 19-2

サンプルプログラムで、昼間と夜間の時刻の範囲を次のように変更するとします。 ソー スプログラムのうち、どこを修正する必要がありますか。

昼間 夜間 9:00-16:59 17:00~23:59 および 0:00~8:59 現在 変更 8:00-20:59 21:00~23:59 および 0:00 ~ 7:59

322

練習問題 323

●問題 19-3

サンプルプログラムに、 「昼食時」 (12:00~12:59) という以下のような新しい状態を追 加してください。

昼食時、金庫を使用すると、警備センターに非常事態の通報が行く

・昼食時、非常ベルを使用すると、 警備センターに非常ベルの通報が行く ・昼食時、電話を使用すると、 警備センターの留守録が呼び出される

●問題 19-4

サンプルプログラムに、「非常時」 という以下のような新しい状態を追加してください。 こうしておけば、 非常時には、 時刻によらず警備センターに連絡がつくようになります。

非常ベルを押すと、 非常時という状態に遷移する ・非常時、 金庫を使用すると、 警備センターに非常事態の通報が行く (時刻によらず) 非常時、非常ベルを使用すると、警備センターに非常ベルの通報が行く (時刻によらず) ・非常時、電話を使用すると、 警備センターが呼び出される (時刻によらず)

ただし、この仕様には問題点があります。 それは何ですか。



第20章 Flyweight

同じものを共有して 無駄をなくす

Mississippi Misp

Flyweight 同じものを共有して無駄をなくす

326

Flyweight パターン

この章では、 フライウエイト Flyweight パターン

について学びます。 flyweight というのは 「フライ級」のことで、 ボクシングで最も体重が 軽い階級を表します。 このデザインパターンは、オブジェクトを 「軽く」するためのもの です。

オブジェクトはコンピュータの中に仮想的に存在するものですから、 「重い」 や 「軽い」 といっても、実際の重さのことを表しているわけではありません。 ここでいう重さは、 「メモリの使用量」のことです。 たくさんのメモリを使うオブジェクトを 「重い」と表現 し、少ししかメモリを使わないオブジェクトを 「軽い」と表現しているのです。 Javaでは、

new Something ()

という式で、 Somethingクラスのインスタンスを作ることができます。 このとき、 そのイ コンスタンスを保持するために、メモリが確保されます。 Somethingクラスのインスタンス が数多く必要なときに、 たくさん newしてしまうと、 メモリの使用量が大きくなります。 Flyweightパターンで使っている技法は、一言でいえば、

「インスタンスをできるだけ共有して、 無駄に new しない」

きょうゆう

というものです。 インスタンスが必要なときに、いつもnewするのではない。 すでに作っ てあるインスタンスを利用できるなら、それを共有して使う。 ･･･これがFlyweight パター ンの核心です。 それでは、Flyweight パターンを学んでいくことにいたしましょう。

サンプルプログラム

Flyweightパターンを使ったサンプルプログラムを読んでみましょう。重いインスタン スを作るクラスとして「大きな文字」を表現するクラスを考えます。 文字を集めて 「大き な文字」 を作っています。 テスト用に、 数字10'~'9' と、 '-' をファイルとして用意しま した (List 20-1~List 20-11)。

サンプルプログラム 327

List 20-1 0 (big0.txt)

List 20-21 (big1.txt)

##

".

##

List 20-3 2 (big2.txt)

..

List 20-4 3 (big3.txt).

List 20-5 4 (big4.txt)

List 20-6 5 (big5.txt)

##.

##.

.##.

List 20-7 6 (big6.txt)

List 20-8 7 (big7.txt)

#.

#.

".

第20章 Flyweight同じものを共有して無駄をなくす

List 20-9数字8 (big8.txt)

List 20-10 数字9 (big9.txt)

H.

##.

#..

"....

.....

#.

List 20-11 文字 (big-.txt)

このサンプルプログラムで使用するクラス一覧を Table 20-1に示します。

Table 20-1 クラス一覧

名前 BigChar 解說 「大きな文字」 を表すクラス BigCharFactory BigChar のインスタンスを共有しながら生成するクラス BigString Main Big Char を集めて作った 「大きな文字列」を表すクラス 動作テスト用のクラス

Big Char は、 「大きな文字」を表現するクラスです。 ファイルから大きな文字のテキス トを読み込んでメモリ上に蓄え、 printメソッドでそれを表示します。 大きな文字はメモ リを消費するので、 BigCharのインスタンスを共有することを考えましょう。

Big CharFactoryクラスは、 BigChar クラスのインスタンスを作ります。 しかし、同じ 文字に対応するBigCharクラスのインスタンスがすでに作ってあった場合は、 それを利用 して、新しいインスタンスは作りません。 これまでに作ったインスタンスは、すべて pool というフィールドに蓄えてあります。 目的の文字に対応するインスタンスをこれま でに作ったかどうかを高速に判断できるように、 java.util. HashMap を用いています。

328

サンプルプログラム 329

BigStringクラスは、 Big Char を集めて作った「大きな文字列」 クラスです。 Main クラスは、動作テスト用のクラスです。

Fig.20-1 サンプルプログラムのクラス図

Uses ▸ -charname -fontdata print -pool BigChar Creates BigCharFactory -singleton -BigCharFactory getInstance getBigChar Uses Uses BigString Main -bigchars print

| BigChar クラス

Big Charクラス (List 20-12) は、「大きな文字」 を表すクラスです。 コンストラクタでは、引数で与えられた文字の「大きな文字」 バージョンを作成します。 作成した文字列は、fontdata フィールドに格納します。 例えば、 引数に'3' が与えられる

第20章 Pyweight同じものを共有して無をなくす

と、次のような文字列が fontdata フィールドに格納されます (読みにくいので、ここで は\nの後で改行して示します)。

......\n .##....\n ##....\n ..\n .##....\n ##....\n .\n ..\n

ところで、「大きな文字」 を構成しているデータ(いわば、フォントデータ)は、ファ イルとして用意することにします (List 20-1~List 20-11)。 文字の前に "big" という文字 列をつけ、 拡張子として".txt"をつけたファイル名というルールにしましょう。 例えば、 '3'という文字のフォントデータは*big3.txt"というファイルに格納することにします。 もしも目的のファイルがない場合には、文字の後に"?" をつけたものをフォントデータと することにします。

このクラスには、 Flyweight パターンの「共有」 に関わるコードは、まだ登場しません。 共有を制御しているのは、 List 20-13 の Big CharFactoryクラスです。

List 20-12 BigCharクラス (BigChar.java) 1: import java.io.IOException; 2: import java.nio.file.Files; 3: import java.nio.file.Path; 4: 5: public class BigChar ( // 文字の名前 6: 7: 8: 9: 10: 11: 12: 13: 14: 15: 16: 17: 18: 19: 20: private char charname; // 大きな文字を表現する文字列('*' private String fontdata; // コンストラクタ public BigChar (char charname) ( this.charname = charname; try( '\nの列 String filename = "big" + charname.txt StringBuilder sb = new StringBuilder(); for (String line: Files.readAllLines (Path.of (filename))) { sb.append(line); sb.append("\n");

330

21:

サンプルプログラム 331

22:

} this.fontdata = sb.toString(); } catch (IOException e){ ) this.fontdata = charname + "?";

23:

25:

27: 28: 30: 31: ) // 大きな文字を表示する public void print() ( System.out.print(fontdata); )

| Big CharFactory クラス

Big CharFactoryクラス (List 20-13) は、BigCharのインスタンスを作成する工場 (factory) です。 ここで共有の仕組みを実現しています。

pool フィールドは、これまでに作ったBig Charのインスタンスを管理するものです。 pool というのは、 水泳のプールと同じです。 ともかく何かが溜まっているところをプール と呼びます。 水泳のプールでは水が溜まっていますが、 BigCharFactoryのpool には、す でに作られたBigChar のインスタンスが溜まっています。

ブール

pool フィールドの型はjava.util.Map<String, BigChar> インタフェースで、これは 「String→BigChar」 という対応関係を管理するものです。 pool フィールドを実際に初期 化しているのは java.util. HashMap<String,BigChar>クラスのインスタンスです。 pool. putメソッドで、 ある文字列 (キー) に対して1つのインスタンス (値) を対応づけ ます。 そして、 pool. get メソッドでキーに対応した値を得ることができます。 例えば、 文字13に対応するBigChar を得たい場合には、 String.value of メソッドで得られる*3* という文字列がキーで、ファイル "big3.txt"から作られるBigCharのインスタンスが値 になります。

ここでBig CharFactoryクラスは、 Singletonパターン (第5章) を使って実現されていま す。 BigCharFactoryのインスタンスは、1つだけ存在すればよいからです。 get Instance メソッドは、 Big CharFactoryのインスタンス (Big Char のインスタンスではないですよ) を得るためのメソッドです。

次の getBigCharメソッドは、 Flyweight パターンの中心となるメソッドです。 このメソ ッドは、引数で与えられた文字に対応するBigCharのインスタンスを作ります。ただし、 すでに同じ文字に対応するインスタンスが作られていたら、新しいインスタンスは作らず に、以前作ったインスタンスを戻り値とします。

24:

26:

29:

332 第20章 Flywright同じものを共有して無駄をなくす

ここのロジックは、よく読みましょう。 まず、 pool. get によって、与えられた文字 charname)に対応したBig Charのインスタンスがあるかどうかを調べます。もしも戻り 値がnullだったら、これまでそのインスタンスは作られたことがないことを示していま すので、 new を使って Big Charのインスタンスを作ります。 そして、そのインスタンスを pool.putによって登録します。 一方、pool.getの戻り値が nullではなかったら、 すで に作られたインスタンスを戻り値とします。

以上の処理により、 BigChar のインスタンスをうまく共有していることがわかると思い ます。

なぜget BigCharメソッドがsynchronizedになっているかは、練習問題20-3で考えま しょう。

1: import java.util. HashMap;

2: import java.util.Map;

3:

4: public class BigCharFactory ( 5: 6: 7: 8: 9: // すでに作ったBigChar のインスタンスを管理 private Map<String, BigChar> pool = new HashMap<>(); // Singletonパターン private static BigCharFactory singleton new BigCharFactory

// コンストラクタ

10:

11:

();

private BigCharFactory() {

12:

13:

} // 唯一のインスタンスを得る public static BigCharFactory getInstance() { return singleton;

14:

15:

List 20-13 BigCharFactory クラス (BigCharFactory.java)

17:

16:

19: 20: 21: 22: // BigChar のインスタンス生成(共有) public synchronized BigChar getBigChar (char charname) ( Big Char be pool.get (String.valueOf(charname)) if (bc == null) { 23: 24: 25: 26: ) 27: 28: ) // ここでBigCharのインスタンスを生成 bc= new Big Char (charname); pool.put (String.valueOf (charname), bc); return bc;

18:

29: )

サンプルプログラム 333

| BigString クラス

BigStringクラス (List 20-14) は、 BigChar を集めた「大きな文字列」 クラスです。 bigchars フィールドはBigCharの配列であり、 Big Charのインスタンスを保持します。 コンストラクタのfor文を見ると、 getBigChar を使って、

BigCharFactory factory BigCharFactory.getInstance(); bigchars =new BigChar [string.length()); for (int i=0; i < bigchars.length; i++) ( bigchars[i] factory.getBigChar (string.charAt(i)); #h

のように書かれています。 次のようにnewをしてはいませ

ん。

bigchars =new BigChar[string.length()); for (int i=0; i < bigchars.length; i++) ( bigchars[i] = new BigChar (string.charAt(i)); }

←共有されない

BigCharFactory を使っているので、同じ文字からできるBig Charのインスタンスは、ち ゃんと共有されているはずです。 例えば、 "1212123" という文字列に対応するBigString のインスタンスを作ったとき、そのbigchars フィールドは、 Fig.20-2のようになります。

List 20-14 BigString 757 (BigString.java)

1: public class BigString ( 2: 3: 4: 5: 6: 7: 8: // 「大きな文字」の配列 private BigChar[] bigchars; // コンストラクタ public BigString (String string) { BigCharFactory factory BigCharFactory.getInstance(); bigchars =new BigChar[string.length()); for (int i=0; i < bigchars.length; i++) ( bigchars[i] factory.getBigChar (string.charAt(11) 9: 10: 11: 12: 13: 14: 15: 16: 17: 18: // 表示 public void print () { for (BigChar be: bigchars) ( bc.print(); )

}

第20章 Flyweight 同じものを共有して無駄をなくす

19:

Fig.20-2 *1212123 に対応するBigStringのインスタンスの様子

20: )

BigString のインスタンスのbigcharsフィールド

(BigCharの配列) 1 2 1 2 1 2 3 1 2 3 BigChar BigChar インスタンス インスタンス BigChar インスタンス

| Mainクラス

Main クラス(List 20-15) は単純です。 引数で与えられた文字列を元にBigStringのイ ンスタンスを作り、それを表示するだけです。 実行結果は省略します。

List 20-15 Main 52 (Main.java)

1: public class Main ( 2: 3: 4: 5: 6: 7: 8: 9: 10: 11: 12: ) public static void main(String[] args) ( if (args.length == 0) { System.out.println("Usage: java Main digits"); System.out.println("Example: java Main 1212123"); System.exit(0); BigString bs = new BigString (args[0]); bs.print();

334

あなたの考えを広げるためのヒント

Flyweight パターンの登場人物

Flyweightパターンの登場人物は、次のとおりです。 クラス図はp.336に示します。

フライウエイト ◆Flyweight (フライ級) の役

普通に扱うとプログラムが重くなるので共有した方がよいものを表す役です。 サンプル プログラムでは、 BigCharクラスがこの役をつとめました。

フライウエイトファクトリー

FlyweightFactory (フライ級の工場) の役

Flyweight役を作る工場の役です。 この工場を使ってFlyweight役を作ると、インスタン スが共有されます。 サンプルプログラムでは、 BigCharFactoryクラスがこの役をつとめ ました。

クライアント Client (依頼者)の役

FlyweightFactory 役を使って Flyweight役を作り出し、それを利用する役です。 サンプル プログラムでは、 BigString クラスがこの役をつとめました。

注意 ここでは、 GoF本 (付録D [GoF] 参照) に書かれている役とは多少異なる分け方をして います。 GoF本には、 Concrete Flyweight 役とUnshared Concrete Flyweight 役が登場します。 GoF 本の ConcreteFlyweight 役が本章の Flyweight役に相当します。 UnsharedConcrete Flyweight役は本 章のサンプルプログラムには登場しません。

あなたの考えを広げるためのヒント

複数箇所に影響が及ぶ

Flyweightパターンでは、インスタンスを「共有」することがテーマです。 インスタン スを共有するときにはどんなことに注意したらよいでしょう。

すぐに思いつくのは 「共有しているものを変更すると、 複数箇所に影響が及ぶ」という ことです。 つまり、1つのインスタンスを変更するだけで、そのインスタンスを使ってい る複数箇所に同時に変更が反映されるのです。 サンプルプログラムに登場したBigCharク ラスの3のfontdataを変更したなら、 BigString で使われている'3' のフォント (字形) はすべて変わります。このように複数箇所に影響が及ぶことは、常に悪いというわけでは なく、プログラムが扱う問題によってよい場合もあればよくない場合もあります。ともか

335

336 第20章 Flyweight 同じものを共有して無駄をなくす -1

Fig.20-3 Flyweight パターンのクラス図

Uses▸

Flyweight

methodA methodB

Creates

Flyweight Factory

|pool

getFlyweight

Uses-

Client

く、共有は「1つを変更しただけで、それを使っている箇所全部に影響を及ぼす」という 特性を持っているわけです。

ですから、 Flyweight 役に持たせる情報は、よくよく考えて選ぶ必要があります。 本当 に複数箇所に共有するべき情報だけを、 Flyweight役に持たせるのがよいのです。 少し例を示します。 サンプルプログラムに機能を追加して、「色つきの大きな文字列」

を使いたいとします。 このとき 「色」の情報は、どのクラスに持たせるべきでしょうか。 まず、BigCharに「色」 の情報を持たせるとしましょう。 Big Char のインスタンスは共 有されますから、色の情報も共有されることになります。 つまり、 BigStringの中で使わ れる同じBigCharのインスタンスは必ず同じ色を持つことになります。

あるいは、BigChar ではなく、 BigString に 「色」 の情報を持たせるとしましょう。 「3 番目の文字は赤」といった色情報を、 BigStringが管理するわけです。そのときには、同 じ BigCharのインスタンスでも違う色にすることができます。

この2つのうち、どちらが正しいとは決められません。 どの情報を共有し、どの情報を

あなたの考えを広げるためのヒント 337

共有しないかは、そのクラスの使用目的によるからです。 Flyweight パターンを使ってク ラスの設計をする人は、 何を共有するべきかをよく考える必要があります。

intrinsic extrinsic

前節でお話した 「共有する情報/共有しない情報」 には、それぞれ以下のような名前が ついています。

インドリンジック 共有する情報は、 intrinsicな情報と呼ばれています。 intrinsicという単語は、 「本来備わ っている」 「本質的な」という意味です。言い換えれば、そのインスタンスをどこに持っ ていっても、どんな状況下でも変わることのない情報、状態に依存しない情報という意味 になります。BigCharのフォントデータは、BigStringのどこに登場しても変わることが ありません。 ですから、 BigCharのフォントデータはintrinsicな情報になります。

エクストリンジック 一方、 共有しない情報は、 extrinsicな情報と呼ばれています。 extrinsicという単語は、 「外からやってきた」 「非本質的な」 という意味です。 インスタンスを置く場所によって変 化する情報、状況によって変化する情報、 状態に依存する情報という意味です。置く場所 によって変化するような情報を共有するわけはいきませんね。 例えば、 Big Charのインス タンスがBigStringの何番目の文字であるか、という情報は Big Char の置かれる場所によ って変化するので、 Big Charに持たせるわけにはいきません。 この情報はextrinsicな情報 ということになります。

前節でお話した 「色」 の情報を BigChar に持たせるか持たせないか、という話は、色を intrinsicな情報として扱うか、 extrinsicな情報として扱うか、と言い換えることもできま す。

Table 20-2 intrinsic extrinsic

intrinsic な情報 場所や状況に依存しないので共有できる extrinsic な情報 場所や状況に依存するので共有できない

管理されているインスタンスは、ガベージコレクションされない

BigCharFactory では、 java.util. HashMapを使って、 生成したBigCharのインスタン スを管理しています。 このように「インスタンスを管理する」という機能をJavaで実現し たときには、 必ず 「管理されているインスタンスはガベージコレクションされない」とい うことを意識する必要があります。

ガベージコレクションについて簡単に説明します。 Javaのプログラムはnewによってメ

Java

338 第20章 Flyweight 同じものを共有して無駄をなくす

モリを確保します。 たくさんメモリを確保していくと、そのうちにメモリが不足します。 メモリが不足したとき、Javaのプログラムを動かしている仮想マシンは、ガベージコレク ションという処理をはじめます。 これは、自分のメモリ空間 (ヒープ領域)を調査して、 使われていないインスタンスを解放し、メモリの空き領域を増やす処理です。 ガベージ (garbage) というのは 「ゴミ」 で、 コレクション (collection) というのは 「収集」 です。 要するに、使われなくなったメモリをゴミ収集車のように集め、 リサイクルするのです。

ガベージコレクションの機能のおかげで、 Javaプログラマは、いったん newしたインス タンスをほったらかしにしておくことができます。 Java では new で作成したインスタンス を削除する方法はありませんし、する必要もありません。

ここでポイントとなるのは、ガベージコレクションの 「使われていないインスタンスを 「解放」 という部分です。 ガベージコレクションを行うときには、 各インスタンスに対して ガベージかどうかの判定が行われますが、他から参照されているインスタンスは 「使われ 「ている」と見なされ、 ガベージとは判定されません。

さて、サンプルプログラムを振り返ってみますと、 pool フィールドでは、作った BigCharのインスタンスを管理しています。 そのため、 pool フィールドで管理されてい るインスタンスは、ゴミとは見なされません。 たとえ、そのBigCharのインスタンスが実 際にはBigStringのインスタンスから参照されなくなったとしても、です。 ということは 一度作ったBigCharクラスのインスタンスはずっとメモリに残りつづけることになりま す。サンプルプログラムは、 文字列を表示してすぐに終了しますから、 メモリが不足する ことはありませんが、長期間動作するプログラムを設計する場合や、少ないメモリで動作 するプログラムを設計する場合には、 「管理されているインスタンスはガベージになれな 「い」ということを覚えておく必要があります。

インスタンスを明示的に削除することはできませんが、 インスタンスへの参照をなくす ことはできます。 管理されているインスタンスをガベージにするためには、明示的に参照 をなくして管理外に置く必要があります。 例えば、 HashMapからそのインスタンスを含む エントリを削除すれば、インスタンスへの参照をなくすことができます。

| メモリ以外のリソース

サンプルプログラムでは、インスタンスを共有するとメモリ使用量が少なくなるという お話をしてきました。 より一般的にいえば、インスタンスを共有すると、インスタンスを 生成するのに必要なリソースの量を減らすことができる、 となります。 リソースとはコン ピュータ上の資源であり、メモリはリソースの一種です。

時間もリソースの一種です。 インスタンスをnewするときに、一定の時間がかかるとし ましょう。 Flyweightパターンを使ってインスタンスを共有すれば、 インスタンスをnew

関連しているパターン 339

する数を減らすことができます。 これによってプログラムのスピードを上げることができ ます。

ファイルハンドル (ファイルディスクリプタ)やウインドウハンドルなども、 リソース の一種です。 OSによっては、同時に使用できるファイルハンドルやウインドウハンドルの 数に制限があります。 そんなとき、 インスタンスを共有しておかないと、この制限にひっ かかってプログラムが動かなくなる危険性があります。

static Factory Method

サンプルプログラムのBigCharFactoryクラス (List 20-13) にはインスタンスを得る ためのクラスメソッド (staticメソッド) がいくつか登場しました。 getInstance メソッドは、唯一のインスタンスを得るためのものです (Singleton パタ

ーン)。

String.valueOf メソッドは、 特定の文字 (char) に対応する文字列表現 (String) を 得るためのものです。

これらはp.57 でも触れた static Factory Method といえます。

関連しているパターン

・Proxy パターン (第21章) Flyweight パターンでは、 インスタンスの生成に時間がかかる場合、 インスタンスの共 有によって処理スピードが上がります。 Proxyパターンでは、代理人を立てることによって処理スピードを上げます。

Composite パターン (第11章)

Flyweightパターンを使って、 Composite パターンのLeaf役を共有できる場合があります。

Singleton パターン (第5章)

FlyweightFactory 役は、 Singletonパターンになる場合があります。

また、SingletonパターンのSingleton 役は、 1つしかインスタンスを作りませんので、そ のインスタンスが使われるところすべてで共有されることになります。 Singleton 役のイ ンスタンスはintrinsicな情報しか持っていません。

340 第20章 Flyweight同じものを共有して無駄をなくす

この章で学んだこと

この章では、メモリの消費を少なくするためにインスタンスを共有 (シェア) させる Flyweight パターンについて学びました。 共有しているインスタンスを変更すると、複数 箇所に影響が及びます。 ですから、 共有するべき intrinsicな情報と、 共有してはいけない extrinsic な情報を意識して区別する必要があります。

【練習問題

●問題 20-1

解答は付録A (p.477)

サンプルプログラムのBigStringクラス (List 20-14) に、 次のようなコンストラクタ を追加してください。

BigString (String string, boolean shared)

shared が trueのときはBig Charを共有し、 false のときには共有しないものとします。

●問題20-2

問題20-1で修正したBigStringクラス (List A20-1) を使い、 BigChar のインスタンス を共有した場合としない場合のメモリ消費量を比較してください。

参考 現在使用しているメモリ消費量は、次の手順である程度知ることができます。 メモリ消費 量をできるだけ正確に得るために、直前でgcメソッドを使ってガベージコレクションを行うよ うにリクエストします。

Runtime.getRuntime().gc(); long used = Runtime.getRuntime().totalMemory ( ) System.out.println("使用メモリ=' + used); - Runtime.getRuntime().freeMemory

●問題 20-3

サンプルプログラムのBig CharFactoryクラス (List 20-13) では、 getBigChar メソッ ドがsynchronizedメソッドになっています。 synchronizedメソッドにした場合としな い場合の違いは何でしょうか。

第21章 Proxy

必要になってから作る

100

21章 Proxy必要になってから作る

Proxy パターン

342

この章では、

プロキシー Proxyパターン

について学びます。 proxyという単語は、「代理人」という意味です。 代理人というのは、 仕事を行うべき本人の代わり (代理) となる人ですね。 本人でなくてもできるような仕事 をまかせるために代理人をたてます。 代理人はあくまで代理にすぎませんから、できるこ とには限界があります。 代理人ができる範囲を超えた仕事がやってきたら、 代理人は本人 のところに行って相談する必要があるでしょう。

オブジェクト指向では 「本人」 も 「代理人」もオブジェクトとなります。 忙しくてその 仕事ができない本人オブジェクトの代わりに、代理人オブジェクトが (ある程度) 仕事を こなしてやることになります。

サンプルプログラム

Proxyパターンを使ったサンプルプログラムを読んでみましょう。 ここで作るサンプルプログラムは、 「名前つきのプリンタ」です。 プリンタといっても、 実際には画面に文字列を表示するだけです。 Main クラスは、 Printer Proxyクラスのイン スタンス(これは「代理人」) を生成します。 そのインスタンスには 「Alice」という名 前をつけ、その名前を表示します。 その後 「Bob」 という名前に変更して、その名前を表 示します。 名前の設定や取得では、まだ本物のPrinter クラスのインスタンス (これが 「本人」) は生成していません。 名前の設定と取得という部分は PrinterProxyクラスが代 理で行います。 最後にprintメソッドを呼び出して、 実際にプリントを行う段階になって はじめて、 PrinterProxyクラスは Printerクラスのインスタンスを生成します。 クラス図は Fig.21-1に、 シーケンス図はFig.21-2 (p.344) に示します。

PrinterProxyクラスとPrinter クラスを同一視するため、 Printable というインタフ ェースが定義されています。

ここでは、 Printerクラスのインスタンス生成にとても時間がかかるという前提で、プ ログラムを作ります。 時間がかかるということを表現するために、 コンストラクタから heavyJob というメソッドを呼び出し、わざと 「重い仕事」 をさせています (といっても、 heavyJob メソッドでは単に5秒ほどの時間稼ぎをしているだけですが)。

第

サンプルプログラム

Table 21-1 クラスとインタフェース一覧

名前 解說 Printer 名前つきのプリンタを表すクラス (本人) Printable Printer と PrinterProxyに共通のインタフェース PrinterProxy 名前つきのプリンタを表すクラス (代理人) Main 動作テスト用のクラス

Fig.21-1 サンプルプログラムのクラス図

PrinterProxy Uses▸ Main -name -real set PrinterName get PrinterName print -realize <<interface>> Printable set PrinterName get PrinterName print Printer Uses▸ -name set PrinterName get PrinterName print -heavyJob

| Printerクラス

Printerクラス (List 21-1) は、 「本人」 を表すクラスです。 コンストラクタでは、先ほどもお話したように、 ダミーの「重い仕事」 heavyJob を行 っています。

setPrinterNameは名前を設定するメソッド getPrinterName は名前を取得するメソ ッドです。

printメソッドは、プリンタの名前つきで文字列を表示しています。

heavyJobメソッドは、実行に5秒かかる重い仕事を表現しています。 1秒 (1000ミリ秒) に1回、ピリオド (.) を表示します。

Proxyパターンの中心はPrinterProxyクラスにあります。 Printer クラスには特に難 しいところはありません。

343

章 Proxy必要になってから作る

第21

Fig.21-2 サンプルプログラムのシーケンス図

Main new :Printer Proxy get PrinterName set PrinterName get PrinterName print new :Printer print

List 21-1 Printer 57 (Printer.java)

1: public class Printer implements Printable { private String name; // 2: 3: 4: 5: 6: 7: // コンストラクタ public Printer () ( heavyJob("Printer 01232&*);

344

8:

サンプルプログラム

// コンストラクタ (名前指定)

public Printer (String name) {

9:

this.name name;

10:

11:

12:

13:

heavy Job ("Printer 01232 (+name+) E&4*);"

}

14:

// 名前の設定

15:

@Override

17:

public void set Printer Name (String name) (

16:

18:

this.name name;

19:

// 名前の取得

@Override

20:

21:

22:

23:

public String getPrinterName() {

24:

25:

return name;

}

26:

27:

28:

29:

34: 35: 36: 37: 38: 39: 40: 41: 42: 43: 44: 45: 46: ) // 重い作業(のつもり) private void heavyJob (String msg) ( } System.out.print (msg); for (int i = 0; i < 5; i++) { try ( Thread.sleep(1000); } catch (InterruptedException e) { } System.out.print("."); System.out.println("T. ");

30:

31:

} // 名前付きで表示 @Override public void print (String string) ( System.out.println("=== System.out.println(string); + name + ===");

32:

33:

| Printableインタフェース

Printable インタフェース (List 212) は、 PrinterProxyクラスと Printerクラスを 同一視するためのものです。 setPrinterName メソッドは名前の設定、 getPrinterName

345

346 第21章 Proxy必要になってから作る

メソッドは名前の取得、 そして、 printメソッドがプリントアウト (文字列表示) のため のものです。

List 21-2 Printable クラス (Printable.java)

1: public interface Printable { 2: public abstract void setPrinterName (String name); // 名前の設定 3: public abstract String getPrinterName(); 4: 5: } public abstract void print (String string); // 名前の取得 // 文字列表示 (プリントアウト)

| PrinterProxyクラス

PrinterProxyクラス (List 21-3) は、 代理人の役割を果たすものです。 Printable イ ンタフェースを実装しています。

name フィールドは名前を保持するためのもので、 real フィールドは「本人」 を保持す るためのものです。

コンストラクタでは、名前を設定します (この時点では、 まだ 「本人」 は作られません)。 setPrinterName メソッドは、 新しく名前を設定します。 もしもreal が nullではない なら(つまり 「本人」 がすでに作られていたら)、 本人に対してもその名前を設定します。 しかし、 real がnullなら (つまり 「本人」 がまだ作られていないなら)、 ただ、 自分 (PrinterProxyのインスタンス) のname フィールドに名前を設定するだけです。

getPrinterName メソッドは、 自分のname フィールドの値を返します。

リアライズ printメソッドは、この代理人の守備範囲外の処理なので、 ここで realizeメソッドを 呼び出し、本人を生成します。 realize というのは「現実化する」という意味です(リアル なものにするわけです)。 realizeメソッドを実行した後、 real フィールドには本人 (Printerクラスのインスタンス)が保持されているので、 real.print を呼び出します。 これは「委譲」ですね。

setPrinterName や getPrinterName を何回呼んでも、 Printerのインスタンスは生成され ません。Printerのインスタンスが生成されるのは、「本人」 が本当に必要になったとき です (本人が生成されているかどうかは、 PrinterProxyの利用者にはまったくわかりま せんし、気にする必要もありません)。

realizeメソッドは単純です。 real フィールドがnullなら、 new Printer によって、 Printerのインスタンスを作ります。 もしもreal フィールドがnullでないなら(つまり すでに作られていたら)、 何もしません。

サンプルプログラム 347

覚えておいてほしいのは、 PrinterクラスはPrinterProxyの存在を知らない、ということ です。 自分がPrinter Proxy経由で呼ばれているのか、それとも直接呼ばれているのか、 Printer クラスは知りません。

一方、PrinterProxyクラスは、 Printerクラスを知っています。 知っている? ええ、 だって、 Printer Proxyクラスのreal フィールドは、 Printer 型ですよね。 PrinterProxy クラスのソースコードの中には、 Printer というクラス名が書かれています。 ですから、 Printer ProxyクラスはPrinter クラスと固定的に結合した部品になっているのです(こ れを切り離す方法については、練習問題21-1で考えます)。

注意深いあなたは、 setPrinterName メソッドと realizeメソッドがsynchronized メ ソッドになっていることにお気づきですね。 この理由は、練習問題21-2で考えましょう。

List 21-3 PrinterProxy クラス (PrinterProxy.java)

1: public class Printer Proxy implements Printable{

private String name;

private Printer real;

// 名前

2:

4:

// コンストラクタ

// 「本人」

public PrinterProxy () (

this.name = "No Name":

5:

this.real = null;

7:

8:

9:

10:

// コンストラクタ (名前指定)

}

public Printer Proxy (String name) (

12:

13:

14:

this.name = name;

this.real = null;

15:

}

11:

16:

// 名前の設定

17:

18:

19:

@Override

public synchronized void setPrinter Name (String name) (

20:

21:

if (real != null) (

22:

3:

6:

// 「本人」にも設定する

23:

24:

real.setPrinterName (name);

this.name = name:

25:

26:

// 名前の取得

27:

}

)

@Override

public String getPrinterName() {

return name:

28:

30:

29:

348 第21章 Proxy必要になってから作る

31: 32: 33: 34: 35: 36: 37: 38: 39: 40: 41: 42: 43: 44: 45: 46: ) //表示 @Override public void print (String string) ( realize(); real.print(string); / /「人」を private synchronized void realize() { if (real == null) { real new Printer (name);

| Mainクラス

Main クラス (List214) は、 Printer Proxy経由でPrinter を利用するクラスです。 こ のクラスは、最初にPrinterProxyを生成し、 getPrinterNameを利用して名前を表示し ます。 それから setPrinterNameで名前を設定します。 そして最後に、 print で "Hello, world."と表示します。

実行結果 (Fig.21-3) を見て、名前の設定や表示の間は Printer のインスタンス (本人) は生成されず、 printメソッドを呼び出してから生成されていることを確認してください。

List 21-4 Main 757 (Main.java)

1: public class Main ( public static void main(String[] args) { 2: 3: 4: 5: 6: 7: 8: } 9: ) Printable p new Printer Proxy ("Alice"); System.out.println("% p.setPrinterName("Bob"); p.getPrinter Name () + "); System.out.println("Ep.getPrinterName() +"です。 : p.print ("Hello, world.");

Proxyパターンの登場人物

Fig.21-3 実行結果

名前は現在Aliceです。 名前は現在 Bob です。 Printerのインスタンス (Bob) を生成中... 完了。 === Bob === Hello, world.

Proxyパターンの登場人物

Proxyパターンの登場人物は、次のとおりです。

サブジェクト Subject (主体)の役

Proxy役と RealSubject 役を同一視するためのインタフェース (API) を定めます。 Subject役があるおかげで、 Client役は、 Proxy 役と RealSubject 役の違いを意識する必要が ありません。 サンプルプログラムでは、 Printableインタフェースがこの役をつとめまし た。

プロキシー Proxy (代理人)の役

Proxy役は Client 役からの要求をできるだけ処理します。 もしも、 自分だけで処理でき なかったら、 Proxy 役は RealSubject役に仕事をおまかせします。 Proxy役は、ほんとうに RealSubject 役が必要になってから RealSubject役を生成します。 Proxy役はSubject役で定 められているインタフェース (API) を実装しています。 サンプルプログラムでは、 Printer Proxyクラスがこの役をつとめました。

サブジェクト RealSubject (実際の主体)の役

「代理人」のProxy役では手に負えなくなったときに登場するのが、 「本人」 のRealSubject 役です。 この役も、 Proxy役と同じくSubject役で定められているインタフェース (API) を実装しています。 サンプルプログラムでは、 Printer クラスがこの役をつとめました。

クライアント Client (依頼人)の役

Proxyパターンを利用する役です (GoF 本 (付録D [GoF] 参照) では、 Client 役は Proxyパターンの中には含まれていません)。 サンプルプログラムでは、 Mainクラスがこ の役をつとめました。

349

章 Proxy必要になってから作る

350 第21

Fig.21-4 Proxyパターンのクラス図

Uses Client Subject request 1 request2 request 3 Uses▸ Proxy realSubject request1 request2 request3 RealSubject request1 request2 request3

あなたの考えを広げるためのヒント

代理人を使ってスピードアップ

Proxyパターンでは、 Proxy役が代理人となって、 できるだけ処理を肩代わりします。 例えば、サンプルプログラムでは、 Proxy役を使うことによって、 実際に print するとき まで、重い処理 (インスタンス生成) を遅らせることができました。

このサンプルプログラムでは、重い処理といってもたかが知れていますので、 あまりあ りがたみは感じられません。 しかし、 例えば、 初期化に時間がかかる機能がたくさん存在 するような大きなシステムを考えてみてください。 起動の時点では利用しない機能まで全 部初期化してしまったら、アプリケーションの起動に時間がかかってしまうことになりま す。 これではユーザは不満を感じてしまいます。 実際にその機能を使う段階になってはじ めて初期化した方が、 ユーザに与えるストレスは少なくなるでしょう。

GoF本 (付録D [GoF] 参照) では、 Proxyパターンの例として、文書中にグラフィッ クオブジェクト (画像など) を埋め込むような文書エディタが示されています。 グラフィ ックオブジェクトを生成するためには、 画像ファイルを読み込んだりして時間がかかるこ とがありますから、文書のオープン時にすべてのグラフィックオブジェクトを生成してい

あなたの考えを広げるためのヒント

ては時間の無駄です。 個々のグラフィックオブジェクトを画面に表示するときになってか ら生成するのがいいでしょう。 Proxyパターンは、 そんなときに威力を発揮します。

代理人と本人を分ける必要はあるのか

Printer Proxyクラスと Printer クラスの2つに分けず、 Printerクラスの中に最初か ら遅延評価の機能 (必要になってからはじめてインスタンスを生成する機能) を入れてお くこともできます。 しかし、 Proxy 役と RealSubject 役を分けることで、プログラムの部品 化が進み、個別に修正を加えることができます (分割して統治せよ!)。

Printer Proxy クラスの実装を変えれば、 Printable インタフェースで宣言されている メソッドのうち、 何を代理人が処理し、 何を本人が処理するのかを変更することができま す。 しかも、そのような変更をいくら加えても、 Printerクラスの方を修正する必要はま ったくないのです。 もしも、 遅延評価をまったく行わないようにしたいなら、Main クラ スでPrinterProxyクラスのインスタンスをnewするのではなく、 Printerクラスのイン スタンスを new すればいいのです。 PrinterProxyクラスとPrinterクラスのどちらも、 Printableインタフェースを実装していますので、 Mainクラスは安心して Printer Proxy と Printer を切り替えて使用することができます。

PrinterProxy というクラスは、 「Proxy 役」 という機能を表現しています。 ですから、 その機能を利用する/しないという選択は、 PrinterProxyを使う/使わないという点に表 現されていることになります。

代理と委譲

代理人だけで処理できる仕事は代理人が処理します。 代理人が処理できないときには処 理できる本人に 「おまかせ」 します。 この「おまかせ」 は本書のあちこちで登場する 委 譲」ですね。 PrinterProxy クラスのprint から real.print を呼び出しているところが、 まさにその「委譲」になります。

もっとも、現実の世界では、 そもそも本人が代理人に対して責任を委譲しているので、 デザインパターンにおける委譲とは逆転していますけれど。

透過的ということ

PrinterProxy クラスとPrinter クラスは、同じPrintableというインタフェースを実 装しています。 Main クラスは、実際に呼び出すのが PrinterProxyクラスでもPrinter ク ラスでも、気にしません。 Printer を直接利用しても、 間に PrinterProxy が入っても、

351

352 第21章 Proxy必要になってから作る

問題なく使用できます。

このようなとき、 PrinterProxyクラスは 「透過的」 であるといえます。 あなたと絵の 間に透明なガラス板が置かれても、絵が透けて見えるように、 Main クラスとPrinter ク ラスの間にPrinterProxyクラスが置かれても、問題は起きません。

HTTPプロキシー

プロキシーというと、 HTTP プロキシーを思い浮かべる人もいると思います。 HTTP プ ロキシーは、 HTTP サーバ (Webサーバ) とHTTPクライアント (Webブラウザ)の間に 入って、Webページのキャッシングなどを行うソフトウェアです。 これもProxyパターン に当てはめて考えることができます。

HTTPプロキシーはたくさんの機能を持っているため、ここでは、一例としてページの キャッシング (caching) についてお話しましょう。

WebブラウザがあるWebページを表示するとき、 いちいち遠隔地にあるWebサーバに アクセスして、そのページを取得するのではなく、 HTTPプロキシーがキャッシュしてあ るページを代わりに取得します。 最新情報が必要になったときやページの有効期限が切れ たときにはじめて、 Web サーバに Webページを取りに行くのです。

ここでは、WebブラウザがClient役、 HTTPプロキシーがProxy役、 そしてWebサーバ が RealSubject役をつとめています。

さまざまなProxy

Proxyパターンには、さまざまなバリエーションがあります。

バーチャル・プロシ Virtual Proxy ( 仮想プロキシー)

Virtual Proxyは、この章で紹介したProxyパターンです。 本当にインスタンスが必要に なった時点で、 生成 初期化を行います。

リモートプロキシー Remote Proxy (遠隔プロキシー)

Remote Proxy は、 RealSubject役がネットワークの向こう側にいるにもかかわらず、あ たかも自分のそばにいるかのように (透過的に)、 メソッド呼び出しができるものです。 リモート・メソッド・インボケーション JavaのRMI (Remote Method Invocation:遠隔メソッド呼び出し) などが、これに相当し ます。

この車で学んだこ 353

プロキ Access Proxy

Access Proxy は、 RealSubject 役の機能に対して、 アクセス制限を設けるものです。 定め られたユーザならメソッド呼び出しを許可しますが、 それ以外はエラーになるような処理 を行うプロキシーです。

関連しているパターン

Adapter パターン (第2章)

Adapter パターンは、インタフェース (API) が異なるオブジェクトの間を埋める働きを します。 一方、 Proxyパターンでは、 Proxy役と RealSubject役でインタフェース (API) は異なりません (透過的)。

Decorator パターン (第12章)

DecoratorパターンとProxyパターンはどちらも透過的なインタフェース (API) を用い ており、 よく似ています。 しかし、この2つのパターンは目的が異なります。 Decorator パターンの目的は、 新しい機能を追加することです。 一方、 Proxyパターンの目的は、新 しい機能を追加するというよりも、 本人の作業を肩代わりして本人へのアクセスを軽減す ることです。

この章で学んだこと

この章では、 本人が必要になるときまで代理人に仕事をしてもらうProxyパターンにつ いて学びました。

354 第21章 Proxy必要になってから作る

練習問題

[Java

解答は付録A (p.481)

●問題21-1

サンプルプログラムでは、 PrinterProxyクラス (List 21-3) は Printer クラス(List 211) を知っています。 すなわち、 PrinterProxyクラスの中にPrinter というクラス名 が直接書かれています。

PrinterProxyクラスがPrinter クラスを 「知らなくてもすむ」ように PrinterProxy クラスを修正してください。

ヒント いろいろ方法はありますが、 例えば、 PrinterProxyクラスのコンストラクタにクラス名を文字 列として渡してみましょう。

問題21-2

Java

PrinterProxyクラス (List 21-3)では、 setPrinterName メソッドと realizeメソッ ドがsynchronizedメソッドになっています。 synchronizedメソッドにしなかった場合 に起こる不具合を例示してください。

22 Command

命令をクラスにする

章 Command命令をクラスにする

356 第22

Command パターン

クラスが仕事を行うときには、 自分のクラスや他のクラスのメソッドを呼び出します。 メソッドを呼び出した結果はオブジェクトの状態に反映されるでしょうが、 仕事の履歴は どこにも残りません。

こんなとき 「この仕事を行いなさい」 という 「命令」 を表現するクラスがあれば便利 です。 行いたい仕事を 「メソッドを呼び出す」 という動的な処理として表現するのではな く、命令を表すクラスのインスタンスという1個の「もの」 として表現することができる からです。 履歴を管理したいときには、そのインスタンスの集まりを管理すればいいこと になります。 命令の集まりを保存しておけば、 同じ命令の再実行もできることになります。 あるいはまた、複数の命令をまとめたものを新しい命令として再利用することもできるで しょう。

デザインパターンでは、このような 「命令」に、

Commandパターン

コマンド

という名前をつけています (commandは 「命令」 という意味です)。

Commandは、 Event と呼ばれる場合もあります (eventは 「出来事」 という意味です)。 「イベント駆動プログラミング」 で使われる「イベント」 と同じ意味です。 マウスをクリ ックした、キーを押した、といったイベントが起きたときに、その出来事をいったんイン スタンスという「もの」にしておき、発生順に待ち行列に並ばせます。 そして、 並んでい るイベントを、順番に処理していくのです。 GUI (graphical user interface) に関わるプロ グラミングでは、 よくこの「イベント」 が登場します。 グラフィカルユーザインタフェース

イベント

この章では、 「命令」 を取り扱う Commandパターンについて学びましょう。

サンプルプログラム

Commandパターンを使ったサンプルプログラムを読んでみましょう。 ここで作るサン プルプログラムは、簡単なお絵かきソフトです。 マウスをドラッグすると、 赤い点の列が 描画され、 [clear] ボタンを押すと、 点がすべて消えます。

ユーザがマウスをドラッグするたびに、 「この位置に点を描け」 という命令が DrawCommandクラスのインスタンスとして生成されます。 このインスタンスを保存してお けば、必要に応じて点を再描画することができます。

サンプルプログラム 357

Fig.22-1 実行結果

Command Pattern Sample clear

サンプルプログラムに登場するクラスとインタフェースの一覧を Table 22-1に示しま す。 サンプルプログラムは、3つのパッケージに分かれています。

Table 22-1 クラスとインタフェース一覧

解說 「命令」 を表現するインタフェース MacroCommand 「複数の命令をまとめた命令」 を表現するクラス DrawCommand 「点の描画命令」 を表現するクラス パッケージ 名前 command Command command drawer drawer Drawable drawer 無名 Main 「描画対象」 を表現するインタフェース DrawCanvas 「描画対象」 を実装したクラス 動作テスト用のクラス

commandパッケージには 「命令」に関するものを、 drawerパッケージには 「描画」に 関するものをまとめています。 Mainクラスは、無名パッケージに入れています。

| Command インタフェース

エグゼキュート Commandインタフェース (List 22-1) は、 「命令」 を表現するためのものです。 このイ ンタフェースは、たった1つのメソッド executeを持ちます (execute は 「実行する」とい う意味です)。 executeメソッドを呼び出したとき具体的に何が起こるかは、 Command イ ンタフェースを実装したクラスが定めますが、ともかく何かを 「実行する」のが Command インタフェースなのです。

Command-x:+8

Fig.22-2 サンプルプログラムのクラス図

<<interface>> Command execute DrawCommand MacroCommand commands execute append undo clear <<interface>> Drawable draw drawable position execute DrawCanvas history color radius draw paint history Main canvas clearButton

List 22-1 Command 1371-2 (Command.java)

1: package command;

2: 3: public interface Command ( 4: public abstract void execute(); 5: )

MacroCommand 57

マクロ MacroCommandクラス(List 22-2) は、 「複数の命令をまとめた命令」 を表します。 こ のクラスは、Commandインタフェースを実装しています。 MacroCommandの macro は 「大 きな」という意味ですが、 プログラミングでは、一般に複数の命令をまとめたものを意味 します。

358

サンプルプログラム

ダブル・エンデ Macro Commandクラスのcommands フィールドはjava.util.Deque インタフェース型で、 複数個のCommandのインスタンスを集めておくためのものです。 Dequeはdouble ended ・キュー queue (両端キュー) と呼ばれるデータ構造を表すインタフェースで、ここではpushと popを行えるスタックとして使っています。 実際に commands フィールドに代入されるの は ArrayDequeのインスタンスです。

なお、Javaにはスタックを表現する java.util. Stackクラスがありますが、これは Java Collection Frameworkに含まれていない古いクラスなので使いません。

MacroCommandクラスはCommandインタフェースを実装していますから、 execute メソ ッドが定義されています。 executeメソッドでは複数命令を実行します。 つまり、 commands フィールドに保持されている1つ1つのインスタンスのexecuteメソッドを呼び出してや ればいいのです。 こうすれば、自分が保持している複数の Command をすべて実行したこと になります。 もしかしたら、このforループで実行しようとしているCommandは、 新たな MacroCommandのインスタンスかもしれません。 その場合でも、さらにそのインスタンス のexecute が呼び出されますから、 結局すべてのCommandが実行されることになります。

appendメソッドは、このMacroCommandのインスタンスに新たなCommandのインスタン スを追加するメソッドです。 追加されるCommandのインスタンスは、もしかしたら別の MacroCommandのインスタンスかもしれません。 誤って自分自身をpushしてしまうと executeメソッドは永遠に終わらなくなってしまうので、引数をチェックしています ( のチェックは簡易的なものです)。

undo メソッドは、 最後に追加したCommandのインスタンスを削除するメソッドです。 ここで使っているpopメソッドは最後にpushメソッドで追加した要素を取り出すもので す。

clearメソッドは、すべての命令を削除するメソッドです。

List 22-2 MacroCommand クラス (MacroCommand.java)

1: package command; 2: 3: import java.util. ArrayDeque; 4: import java.util.Deque; 5: 6: public class MacroCommand implements Command ( // 命令の列 private Deque<Command> commands = new ArrayDeque<>(); 7: 8: 9: 10: // 実行 11: @Override 12: public void execute() {

359

360 第22章 Command命令をクラスにする

13: 14: for (Command cmd: commands) ( cmd.execute(); 15: 16: 17: 18: // 追加 19: 20: 21: 22: } 23: public void append (Command cmd) ( if (cmd == this) ( throw new IllegalArgumentException("infinite loop caused by append"); commands.push(cmd); 24: } 25: 26: 27: 28: 29: // 最後の命令を削除 public void undo () ( if (!commands.isEmpty()) { commands.pop(); 30: 31: 32: 33: 34: 35: // 全部削除 public void clear() { commands.clear(); 36: } 37: )

DrawCommandクラス

DrawCommandクラス (List 22-3) は、 Commandインタフェースを実装したクラスで、「点 の描画命令」を表現したものです。 drawable と position という2つのフィールドを持っ ています。 drawableフィールドは描画を行う対象を保持します (Drawableインタフェー スは、後ほど登場します)。 position フィールドは、 描画を行う位置を表します。 Point クラスはjava.awtパッケージで定められているクラスで、 X座標とY座標を持つ二次元平 面上の位置を表します。

コンストラクタでは、 Drawableインタフェースを実装したクラスのインスタンスと Point クラスのインスタンスを引数に渡して、フィールドに代入します。 これが、「この 位置に点を描け」という命令を作っているところですね。

executeメソッドでは、 drawable フィールドのdrawメソッドを呼び出しています。 こ れは命令を実行しているところです。

サンプルプログラム

List 22-3 DrawCommand 52 (DrawCommand.java)

1: package drawer;

2:

3: import command.Command;

4: import java.awt.Point;

5:

6: public class DrawCommand implements Command{

// 描画对象

protected Drawable drawable;

8:

// 描画位置

private Point position;

10:

11:

7:

// コンストラクタ

12:

13:

14:

public DrawCommand (Drawable drawable, Point position) (

this.drawable = drawable;

this.position = position;

// 实行

22: 23:

@Override

24: }

Drawableインタフェース (List 22-4) は、 「描画対象」 を表現するものです。 drawは、 描画するメソッドです。 このサンプルプログラムでは、仕様を単純化しているため、色の 指定や描画する点の大きさの指定はできません。色の指定については練習問題22-1で考 えます。

1: package drawer: 2: 3: public interface Drawable ( 4: 5: ) public abstract void draw(int x, int y);

15:

}

17:

18:

19:

16:

public void execute() {

drawable.draw(position.x, position.y);

| Drawableインタフェース

20:

21:

List 22-4 Drawable 1371-2 (Drawable.java)

361

9:

2章 Command命令をクラスにする

362 第

DrawCanvas クラス

DrawCanvas クラス (List 22-5) は、 Drawableインタフェースを実装しているクラスで、 java.awt.Canvas クラスのサブクラスです。

自分が描画すべき命令の集合は、 history フィールドに保持しています。 このフィール ドの型は、 command. MacroCommandですね。

コンストラクタでは、幅 (width) と高さ (height) と描画内容 (history) をもらっ て、 DrawCanvasのインスタンスを初期化します。 この中で呼び出している setSizeや setBackgroundメソッドは、 java.awt.Canvas クラスのメソッドで、それぞれ大きさと 背景色を指定するものです。

paintメソッドは、このDrawCanvas を再描画する必要が生じたときに、 Java 処理系から (java.awtのフレームワークから) 呼び出されるメソッドです。 行う処理は、 history. execute を呼び出すだけです。 これだけで、 history に記録されている命令の集まりが再 実行されることになります。

drawメソッドは、 Drawableインタフェースの実装のために定義されているメソッドで す。 この中では、 g.setColor で色を指定し、g.fill0valで円を表示しています。

List 22-5 DrawCanvas クラス (DrawCanvas.java)

1: package drawer; 2: 3: import command. MacroCommand; 4: 5: import java.awt.Canvas; 6: import java.awt.Color; 7: import java.awt.Graphics; 8: 9: public class DrawCanvas extends Canvas implements Drawable { private Color color = Color.red; // 描画する点の半径 private int radius = 6; // 履歴 private MacroCommand history; 10: //描画色 11: 12: 13: 14: 15: 16: 17: 18: 19: 20: 21: 22: // コンストラクタ public DrawCanvas (int width, int height, MacroCommand history) ( setSize(width, height); setBackground (Color.white); this.history = history:

サンプルプログラム 363

23: 24: 25: 26: 27: // 履歴全体を再描画 @Override public void paint (Graphics g) ( history.execute(); 28: } 29: 30: //描画 31: @Override 32: 33: public void draw (int x, int y) ( Graphics g= getGraphics(); g.setColor (color): 34: 35: 36: g.filloval (x radius, y - radius, radius 2, radius*2); ) 37: )

| Mainクラス

Main クラス (List 22-6) は、 サンプルプログラムを動作させるためのものです。 history フィールドは、 描画履歴を保持します。 これは、後でDrawCanvasのインスタ ンスに渡すものと同じです。 つまり、 描画履歴はMainのインスタンスとDrawCanvasのイ ンスタンスで共有されているのです。

canvas フィールドは描画領域です。 ここでは初期サイズとして、400×400を与えてい ます。

clearButton フィールドは、 描画した点を消す消去ボタンです。 JButton クラスは、 javax. swingパッケージのクラスでボタンを表現したものです。

コンストラクタでは、マウス押下などのイベントを受け取るためのリスナー (listener) を設定し、 描画するコンポーネント (部品)をレイアウトしています。

ボタンのレイアウトは、 練習問題での拡張に備えて、 ちょっと複雑にしてあります。 ま ず、横に部品を並べるボックス buttonBoxを作ります。 横に並べるために、 コンストラク タにBoxLayout.X_AXISを渡しています。 そして、 buttonBoxの上にclearButton を載せ ます。 その上で、 縦に部品を並べるボックスmainBoxを作り、 mainBox に buttonBox と canvas を載せます。

最後に、mainBox を JFrameに載せます。 java.awt.Frameには直接コンポーネントを載 せることができますが、 javax.swing.JFrameでは、 getContentPaneメソッドで得られ るコンテナにコンポーネントを載せます。 レイアウトの概略をFig.22-3に示します。

第22章 Command命令をクラスにする

Fig.22-3 コンポーネントのレイアウト

javax.swing.JFrame | getContentPane で得られるコンテナ mainBox buttonBox clearButton canvas

clearButton.addActionListener を呼び出すところでは、 ラムダ式を用いて 「描画履 歴を消去した上で再描画を行う」という処理を設定しています。

mouseMoved メソッドとmouseDraggedメソッドは、 MouseMotionListener インタフェ ースを実装するためのものです。 ここでは、マウスをドラッグしたとき (mouseDragged) に「この位置に点を描け」 という命令を作っています。 作った命令は、

history.append(cmd);

で実行履歴に追加した後、

cmd.execute();

で即実行しています。

window... で始まるメソッド群は、WindowListener インタフェースを実装するための ものです。 ここでは、 終了処理 (exit) のみ実装しています。

mainメソッドでは、Mainクラスのインスタンスを作って実行しています。 シーケンス図は、 Fig.22-4に示します。

List 22-6 Main クラス (Main.java)

1: import command.*; 2: import drawer.*; 3:

364

サンプルプログラム 365

4: import java.awt.*;

5: import java.awt.event.*;

6: import javax.swing.*;

7:

8: public class Main extends JFrame implements MouseMotionListener, WindowListener (

9:

10:

// 描画履歷

11:

private MacroCommand history = new MacroCommand()

12:

// 描画領域

private DrawCanvas canvas = new DrawCanvas (400, 400, history); // 消去ボタン

14:

private JButton clearButton = new JButton("clear");

15:

16:

// コンストラクタ

public Main(String title) (

18:

19:

super (title);

this.addWindowListener (this);

20:

21:

canvas.addMouseMotionListener(this); clearButton.addActionListener (e -> {

23:

history.clear();

22:

canvas.repaint ();

24:

25:

26:

});

Box buttonBox = new Box (BoxLayout.X_AXIS); buttonBox.add(clearButton);

27:

28:

29:

30:

Box mainBox new Box (BoxLayout.Y_AXIS); mainBox.add(buttonBox);

31:

32:

33:

mainBox.add(canvas);

getContentPane().add (mainBox);

pack();

setVisible(true);

35:

34:

36:

38:

// MouseMotionListener @Override public void mouseMoved (MouseEvent e) { )

41:

39:

40:

42:

43:

44:

@Override public void mouseDragged (MouseEvent e) { Command cmd = new DrawCommand (canvas, e.get Point ()); history.append(cmd); cmd.execute();

45:

37:

46:

47:

13:

// WindowListener I

@Override

17:

48:

49:

50:

51:

)

22 Command-

52: 53: 54: 55: 56: 57: 58: 59: 60: 61: 62: 63: public void windowClosing (WindowEvent e) { System.exit(0); @Override public void windowActivated (WindowEvent e) () @Override public void windowClosed (WindowEvent e) () @Override public void windowDeactivated (WindowEvent e) () @Override public void windowDeiconified (WindowEvent e) {} @Override public void windowIconified (WindowEvent e) () @Override public void windowOpened (WindowEvent e) {} public static void main(String[] args) { new Main ("Command Pattern Sample"); 64: 65: ) 66:

Fig.22-4 サンプルプログラムのシーケンス図

framework of java.awt :Main mouseDragged new DrawCommand execute paint draw draw :DrawCanvas MacroCommand execute execute

366

Command パターンの登場人物

Commandパターンの登場人物

Commandパターンの登場人物は、次のとおりです。

コマンド Command (命令)の役 命令のインタフェース (API) を定義する役です。 サンプルプログラムでは、Command インタフェースがこの役をつとめました。

コンクリートコマンド

ConcreteCommand (具体的命令)の役

Command役のインタフェース (API) を実際に実装している役です。 サンプルプログ ラムでは、 MacroCommandクラスとDrawCommandクラスがこの役をつとめました。

レシーバ Receiver (受信者)の役

Command役が命令を実行するときに対象となる役です。 命令の受け取り手と呼んでも よいでしょう。 サンプルプログラムでDrawCommandの命令を受け取っているのは、 DrawCanvas クラスです。

クライアント Client (依頼者) の役

ConcreteCommand役を生成し、 その際に Receiver役を割り当てる役です。 サンプルプ ログラムでは、Main クラスがこの役をつとめました。 Mainクラスは、マウスのドラッグ にあわせてDrawCommandのインスタンスを生成しますが、その際にReceiver 役として DrawCanvasのインスタンスをコンストラクタに渡しています。

インカー Invoker (起動者) の役

命令の実行を開始する役です。 Command役で定義されているインタフェース (API) を呼び出す役になります。 サンプルプログラムでは、 MainクラスとDrawCanvas クラスが この役をつとめました。 この2つのクラスがCommandインタフェースのexecuteメソッド を呼び出しています。 Main クラスは、 Client役と Invoker役の2役をつとめていることに なります。

367

22 Command-

Commandパターンのクラス図をFig.22-5に、 シーケンス図を Fig.22-6に示します。

Fig.22-5 Command/2 action Receiver execute Command ConcreteCommand receiver execute Creates Client Invoker

Fig.22-6 Command/15-01-12

:Invoker execute :Client new ConcreteCommand action :Receiver

368

あなたの考えを広げるためのヒント

あなたの考えを広げるためのヒント

命令が持つべき情報は?

「命令」 にどれだけの情報を持たせるべきかは、目的によって異なります。 DrawCommand クラスには、 描画する点の位置という情報だけを持たせました。 点の大きさや色、形など の情報は持たせていません。

DrawCommandが 「そのイベントが発生した時刻 (タイムスタンプ)」という情報を持っ ていたとしましょう。 そうすると、 再描画するときに、 単なる描画ではなく、 ユーザのマ ウス動作の緩急も再現できるかもしれませんね。

ところで、 DrawCommandクラスは、 描画対象を表すフィールド (drawable) も持って います。 サンプルプログラムでは、 DrawCanvasのインスタンスは1つだけであり、すべ ての描画はそこに対して行われますから、このdrawable フィールドはあまり意味があり ません。 しかし、 描画対象 (すなわち Receiver役) が複数存在するようなプログラムの場 合には、このようなフィールドが役に立ちます。 ConcreteCommand 役自身が Receiver 役 を「知っている」ことにより、 ConcreteCommand役を誰が管理しても、誰が持っていて も、いつでもexecuteすることができるからです。

履歴の保存

サンプルプログラムでは、 描画の履歴をMacroCommandのインスタンス (history) と して表現しました。 このインスタンスは、これまでの描画の情報をすべて持っているわけ です。 ということは、このインスタンスをファイルとしてうまく保存すれば、 描画履歴が 保存されることになります。

アダプター

サンプルプログラムのMainクラス (List 22-6) は、2つのインタフェースを実装してい ます。 しかし、 インタフェースのメソッドのうち、 実際に使っているのはその一部です。 例えば、 MouseMotionListener の

public void mouseMoved (MouseEvent e

public void mouseDragged (MouseEvent e)

).

というメソッドのうち、使っているのはmouseDraggedメソッドだけです。 また、 例えば

369

Java

WindowListener では、

public void windowClosing (WindowEvent e) public void windowActivated (WindowEvent e). public void windowClosed (WindowEvent e) public void windowDeactivated (WindowEvent e) public void windowDeiconified (WindowEvent e) public void windowIconified (WindowEvent e) public void windowOpened (WindowEvent e)

という7つのメソッドのうち、 windowClosingメソッドだけを使っています。 プログラミングを簡略化するために、アダプターと呼ばれるクラス群がjava.awt.event パッケージに用意されています。 例えば、 MouseMotionListener インタフェースに対し てはMouseMotionAdapter クラス、WindowListener インタフェースに対してはWindow Adapter クラスが用意されています (Table 22-2)。 このようなアダプターはAdapter パタ ーン (第2章) の一例になっています。

Table 22-2 インタフェースとアダプター

インタフェース MouseMotionListener インタフェース WindowListener インタフェース アダプター MouseMotionAdapter クラス WindowAdapter クラス

370 第2章 Command をクラスにする

ここでは、MouseMotionAdapter クラスを例にとりましょう。 このクラスは、 MouseMotionListener インタフェースを実装し、 このインタフェースが要求するメソッ ドをすべて実装しています。 しかし、その実装はすべて空 (何もしないメソッド) にな っています。 ですから、 MouseMotion Adapterクラスのサブクラスを作り、必要なメソッ ドを実装するだけで、 目的を達することができます。

とくめい アノニマス 特に、Javaの無名クラス (匿名クラス) (anonymous class) という機構と組み合わせて アダプターを使うと、さらにスマートにプログラムを記述することができます。 以下に、 インタフェースとしてMouseMotionListener を使った場合 (List 22-7) と、無名として MouseMotionAdapter を使った場合 (List 22-8) を比較します。 細かい内容は... で省略 しています。

あなたの考えを広げるためのヒント

List 22-7 MouseMotionListener を使った場合 (空のmouseMoved メソッドが必要)

public class Main extends JFrame implements MouseMotionListener, WindowListener ( public Main(String title) ( canvas.addMouseMotionListener(this); // MouseMotionListener public void mouseMoved (MouseEvent e) ( public void mouseDragged (MouseEvent e) ( Command cmd = new DrawCommand (canvas, e.getPoint()); history.append(cmd); cmd.execute();

List 22-8 MouseMotion Adapter を使った場合 (空の mouseMoved メソッドは不要)

public class Main extends JFrame implements WindowListener (

public Main(String title) ( canvas.addMouseMotionListener(new MouseMotionAdapter() { public void mouseDragged (MouseEvent e) { )); Command cmd = new DrawCommand (canvas, e.getPoint()); history.append(cmd); cmd.execute();

371

22章 Command-命令をクラスにする

372 第

無名クラスの構文は、慣れないと読みにくいですが、 List 22-8 を注意深く見てみると、

new MouseMotionAdapter() のところは、ちょうどインスタンスを作る式に似ている ・その後に続く... } は、 クラス定義の中の部分 (メソッドの定義) に似ている

ことがわかりますね。 これでMouseMotionAdapter というクラスのサブクラス (名前なし) を作り、そのインスタンスを生成していることになるのです。 オーバーライドすべきメソ ッド (mouseDragged) だけを実装すれば、あとは何も書く必要がありません。

練習問題22-3では、 MouseMotionAdapter と WindowAdapter を使って、サンプルプロ グラムを書き換えます。

関連しているパターン

・Composite パターン (第11章)

マクロコマンドを実現するために、 Composite パターンが使われる場合があります。

Memento パターン (第18章)

Command役の履歴を保存する場合に、 Mementoパターンが使われる場合があります。

・Prototype パターン (第6章) 発生したイベント (作成した命令) を複製したい場合に、 Prototypeパターンが使われ る場合があります。

この章で学んだこと

この章では、 「命令」 をオブジェクトとして表現し、 履歴をとったり再実行を行ったり することができるCommandパターンについて学びました。 普段はモノとして意識してい ない 「もの」も、オブジェクトとして表現すると、 取り扱いやすくなる場合がありますね。

www 373

練習問題

解答は付録A (p.484)

●問題22-1

サンプルプログラムに、 「描画色を設定する」 という機能を追加してください。 これは、 ちょうど絵筆を持ち替えるようなもので、 新しい色を設定した後、 マウスをドラッグする と、 新しい色で点が描画されます。

ヒント 描画色を設定する命令を表す ColorCommandクラスを新規に作成します。

●問題22-2 サンプルプログラムに、 「最後に描画した点を削除する」というアンドゥ機能を追加し てください。

問題22-3

MouseMotionListener インタフェースとWindowListenerインタフェースを使う代わり に、MouseMotion AdapterクラスとWindowAdapter クラス (アダプター)を使うように、 サンプルプログラムのMainクラス (List 22-6) を修正してください。

Java



第23章

Interpreter 文法規則をクラスで表現する

begin color begin red blue green end size begin width 640 end begin height 480 end end

color size red blue green width 640 (height 480

第23章 Interpreter 文法則をクラスで表現する

Interpreter パターン

私たちは本書を通じて、さまざまなデザインパターンを学んできました。 デザインパター ンの目的の1つは、クラスの再利用性を高めることでした。 再利用性とは、 一度作成したク ラスをあまり修正せずに(できればまったく修正せずに)何度も使えるようにすることです。 この章では、

インタプリタ

Interpreter パターン

について学びます。

Interpreterパターンでは、プログラムが解決しようとしている問題を簡単な 「ミニ言語」 で表現します。 具体的な問題を、 ミニ言語で書かれた「ミニ・プログラム」で表現するの です。 ミニ・プログラムは、それだけでは動きませんので、 Java言語で 「通訳 (interpreter)」 の役目を果たすプログラムを作っておきます。 通訳プログラムは、 ミニ言語を理解し、ミ ・プログラムを解釈 実行します。 この通訳プログラムのことをインタプリタと呼ぶこ ともあります。 解決すべき問題が変化したときには、 Java言語で書かれたプログラムを書

き換えるのではなく、 ミニ・プログラムの方を書き換えることで対処するのです。

問題が変化したときに、どのレベルのプログラムを書き換えるかを図示してみましょう。 Java言語でプログラミングをしている場合、通常はFig.23-1のようにプログラムを書き換 えます。 できるだけプログラムの修正は少なくしたいわけですが、 多かれ少なかれ、 Java 言語のプログラムを書き換えなければなりません。

Fig.23-1 問題が変化した場合、通常はJava言語で書かれたプログラムを書き換える

書き換え Java言語で書かれた プログラムA Java言語で書かれた ブログラムB Java言語の実行環境 Java言語の実行環境

Fig.23-2 Interpreter バターンでは、ミニ言語で書かれたミニプログラムを書き換える

書き換え ミニ言語で書かれた ミニ・プログラムA ミニ言語で書かれた ミニ・プログラムB Java言語で書かれた ミニ言語のインタプリタ Java言語の実行環境 Java言語で書かれた ミニ言語のインタプリタ Java言語の実行環境

376

ミニ

しかし、 Interpreterパターンを使った場合には、Java言語で書かれたプログラムは修正 せず、ミニ言語で書かれたミニ・プログラムの方を書き換えます (Fig.23-2)。

ミニ言語

ミニ言語の命令

Interpreterパターンのサンプルプログラムの説明に入る前に、この章で扱う 「ミニ言語」 の説明をしておきましょう。 ここでは、ラジコンで車を動かすための言語を考えます。 車 を動かすといっても、できることは次の3つだけです。

前へ1メートル進め (go) ・右を向け (right) 左を向け (left)

この3つが車に対して発行できる命令 (コマンド) です。 goは1メートル進んで止まる 命令です。 right はその場で右を向く命令、 leftはその場で左を向く命令です。 実際の車 では、位置をまったくずらさずに右や左を向くというのは不可能ですが、ここでは話を簡 単にするために、 位置を変えることなくターンテーブルを回すように向きを変えられると します。

これだけではつまらないので、 繰り返し命令も加えてみます。

・繰り返せ (repeat)

これらの命令を組み合わせて車を動かすための言語が、 この章で用いるミニ言語です。

Fig.23-3 車を動かすミニ言語

go

left

right

repeat

377

378 第23章 Interpreter 文法規則をクラスで表現する

ミニ・プログラムの例

ミニ言語で書かれたミニ・プログラムの例をいくつか見てみましょう。 次に示すものは、 車を前に進める(そして止める) ミニ・プログラムです。

program go end

プログラムのはじめと終わりがわかるように、 program と endという単語ではさむこと にします(ミニ言語の「文法」についてはすぐ後でお話します)。 このミニ・プログラム を実行した例をFig.23-4に示します(このGUIを持ったプログラムは、 練習問題23-1で 作成するものです)。

| Fig.23-4 program go endの実行

Interpreter Pattern Sample program go end ミニプログラム 実行結果

goで前に進む

出発点

次は、車を前に進め、回れ右をして戻ってくるミニ・プログラムです。programとend の間には、任意個の命令を入れることができます。

program go right right go end

次は、回れ右ではなく、正方形を描いて戻ってくるミニ・プログラムです。 実行例を Fig.23-5に示します。

program go right go right go right go right end

(A)

ミニ 379

Fig.23-5 program go right go right go right go right end

Interpreter Pattern Sample program go right go right go right go right end 出発点 right go right go ①go ⑥ right ⑦go Dright

(A) のプログラムで、 最後 (endの直前) に right を含めているのは、車の向きを最初 と同じ向きに戻したいからです。 (A) のプログラムをじっと見ると、 go right というの を4回繰り返しているのがわかりますね。 これは repeat ... endという構文を使って、 次の (B) のように書くこともできます (書くことができるようにミニ言語の文法を定め ることにします)。 実行例を Fig.23-6に示します。

program repeat 4 go right end end

･･･(B)

| Fig.23-6 program repeat 4 go right end end の実行 (Fig.23-5と同じ)

Interpreter Pattern Sample program repeat 4 go right end end 出発点

380 第3章 Interpreter 文法規則をクラスで表現する

(B) の最後にはendが2つ重なっていますが、 はじめ (左側) のendはrepeatの終わり を表し、 最後 (右側) の endはprogramの終わりを表しています。 つまり、こういうこと です。

program repeat プログラムの開始 繰り返しの開始 4 繰り返しの回数 go right 進め 右向け end 繰り返しの終了 プログラムの終了 end

頭の中で車がくるくる動いていますか? それでは、次のミニ・プログラムは、車をど のように動かすでしょうか。

program repeat 4 repeat 3 go right go left end right end end

車は、 Fig.23-7のようにギザギザな辺を持つひし形を描きます。 repeat が二重 (入れ 子) になっているので複雑ですが、次のように分解すればわかるでしょう。

program repeat プログラムの開始 繰り返しの開始 (外側) 4 repeat 3 繰り返しの回数 繰り返しの開始 (内側) 繰り返しの回数 go 進め right 右向け go 進め end left 左向け 繰り返しの終了 (内側) 右向け right end 繰り返しの終了 (外側) プログラムの終了

end

内側の繰り返しの内容 「go right go left」 は、 「前に進んで右に向き、 前に進んで 左に向け」という命令です。 これを3回繰り返します。 つまり、 ギザギザを描きながら右 前に進みます。 そして、全体としては、「ギザギザ右前に進んだ後、 1回だけrightで右に 向く」という動きを4回繰り返します。 これによって、 ギザギザのひし形を描くことがわ かります。

Fig.23-7 program repeat 4 repeat 3 go right go left end right end end の実行

Interpreter Pattern Sample program repeat 4 repeat 3 go right go left end right end end 出発点.

ミニ言語の文法

バッカス・ナウル・フォーム [バッカス・ノーマル・フォーム さて、ここでミニ言語の文法を示します (Fig.23-8)。 ここで使う表記法は、 「BNF」 と 呼ばれるものの変形です。 BNF は Backus Naur Form、 またはBackus Normal Formの略 で、言語の文法を表記するときによく用いられます。

Fig.23-8 サンプルプログラムのインタプリタが解釈するミニ言語の「文法」

<program> ::= program <command list> <command list> :: <command> end <command> ::= <repeat command> | <primitive command> <repeat command> ::= repeat <number> <command list> <primitive command> ::= go | right | left

順番に解説しましょう。

<program> ::= program <command list>

ここでは、プログラムというもの <program> を定義しています。「<program> とは、 program という単語の後にコマンドの列 <command list> が続いたもの」 と定義していま す。 の左辺が定義されるもので、 右辺が定義の内容です。

381

382 第23章 Interpreter文法規則をクラスで表現する

<command list> ::= <command> end

ここでは、コマンドの列 <command list> を定義しています。 「 <command list> とは、 コマンド<command>が0個以上繰り返した後、 endという単語がきたもの」と定義してい ます。 は、直前のものの0回以上の繰り返しを表します。

<command> ::= <repeat command> | <primitive command>

今度は、コマンド<command> を定義していますね。 <command> とは、繰り返しコマン ド<repeat command> または基本コマンド <primitive command> のいずれか」と定義し ています。 は、「または」を表します。

<repeat command> ::= repeat <number> <command list>

を定義しています。 「<repeat command> と は、 repeat という単語の後に繰り返し回数 <number> が続き、さらにコマンドの列 <command list> が続いたもの」と定義しています。 コマンドの列 <command list>は、 すでに定義しましたね。 <command list> の定義の中に <command> が使われ、 <command> の定義の中に<repeat command> が使われ、 <repeat command> の定義の中に <command list> が使われています。 このように、あるものを定義している途中に、 自分自身が登場 してくる定義を、 「再帰的な定義」 といいます。 後ほど、 Java言語を使ってこのミニ言語 のインタプリタを作りますが、 そのときにも再帰的な定義が反映された構造が登場します ので、覚えておいてください。

次に、繰り返しコマンド <repeat command>

<primitive command> ::= go | right | left

基本コマンド <primitive command> を定義します。 「<primitive command> とは、go またはright または left」 と定義しています。

残っているのは<number> ですが、この定義をすべて書くと複雑になるので、ここでは 説明を省略します。とりあえず、 <number> は3や4や12345 のような0以上の整数を表す ものだと思ってください。

注意 厳密にはここで使っているのは拡張されたBNF です。 オリジナルのBNFには0回以上の 繰り返しを表す*はなく、繰り返しも再帰的な定義で表現します。

ターミナルエクスプレッションとノンターミナルエクスプレッション

ちょっと用語の説明をしておきましょう。

前述した文法の中で、 goやright や leftのように、 それ以上展開されない表現を「タ ーミナル・エクスプレッション (terminal expression)」 と呼びます。 バスや列車の終着駅

サンプルプログラム 383

のことをターミナルといいますね。 あれと似ています。 文法規則の終着点ですね。 また、<program> や <command> などのように、さらに展開される表現を「ノンターミナ ル・エクスプレッション (nonterminal expression)」と呼びます。

|サンプルプログラム

さて、ミニ言語の説明が終わったところで、サンプルプログラムの説明に移りましょう。 こうぶんかいせき ここで作るサンプルプログラムは、先ほどのミニ言語を構文解析するものです。

先ほど、ミニ・プログラムの内容を説明するときに、 ミニ・プログラムの各部分を分解 してお話しましたね。 ただの文字列であるミニ・プログラムを分解して、各部分がどのよ うな構造になっているかを解析するのが、構文解析です。 例えば、

program repeat 4 go right end end

というミニ・プログラムが与えられたときに、 Fig.23-9のような構造 (構文木)をメモリ 上に作り上げる処理が、 構文解析です。

サンプルプログラムでは、この構文木を構築するまでを扱います。 実際に「実行」 する 部分は、練習問題23-1で扱うことにします。

Fig.23-9 ミニ・プログラム program repeat 4 go right end end の構文木

:ProgramNode

:CommandListNode

:Repeat CommandNode

:CommandListNode

go: PrimitiveCommandNode

right: PrimitiveCommandNode

第23章 Interpreter文法規則をクラスで表現する

Table 23-1 クラス一覧

Node 名前 ProgramNode CommandListNode CommandNode Repeat CommandNode Primitive CommandNode Context ParseException Main 解說 構文木の 「ノード」になるクラス <program> に対応するクラス <command list> に対応するクラス <command> に対応するクラス <repeat command> に対応するクラス <primitive command> に対応するクラス 構文解析のための前後関係を表すクラス 構文解析中の例外クラス 動作テスト用のクラス

Fig.23-10 サンプルプログラムのクラス図

Creates Main Context nextToken currentToken skipToken currentNumber Uses‣ Node parse ProgramNode Repeat CommandNode CommandListNode commandListNode number CommandNode commandListNode parse list parse node parse parse PrimitiveCommandNode name parse

| Node クラス

Nodeクラス (List 23-1) は、 構文木の各部分 (ノード) を構成する最上位のクラスで す。 Node クラスには抽象メソッドparseだけが宣言されています。 このparse は 「構文解 「析という処理を行う」ためのメソッドです。 Nodeクラスでは parseメソッドを宣言して いるだけであり、具体的にどう解析するかは、 Node クラスのサブクラスの方にまかされ

384

サンプルプログラム 385

ています (subclass responsibility)。 parseメソッドの引数で渡されている Context は、 構 文解析を行っている 「状況」 を表すクラスですが、 これについては後で詳しく説明します。 parseメソッドの宣言にはthrows 節がありますね。 このthrows節は、もしも構文解析中 にエラーが起きたときに、 ParseException という例外を投げることを示しています。

Node クラスばかり眺めていても、具体的なことは何もわからないので、先に進みまし

ょう。

List 23-1 Node クラス (Node.java)

1: public abstract class Node (

3: )

2:

public abstract void parse (Context context) throws ParseException;

| Program Node クラス

これから、先ほど Fig.23-8に示したミニ言語の文法 (BNF) に従って、 クラス定義を見 ていきます。 まずは、プログラムというもの <program> を表す Program Node クラス (List 23-2) です。 このクラスには、 Node 型のCommandListNodeのフィールドがあります。 こ のフィールドは、自分の後に続く <command list> に対応する構造(ノード)を保持する ためのものです。

Program Nodeのparseメソッドではどんな処理を行っていますか。 BNFを見ると、 <program のはじめには、 programという単語が来るはずですね。 次の文で、その programという単語を読み飛ばしています。

context.skipToken ("program");

構文解析の際の処理単位をトークン (token) と呼びます。 このミニ言語では、「トーク ン」は「英単語」 と同義ですが、 通常のプログラミング言語では、例えば+ や == なども トークンになります。 もう少し詳しくいえば、 字句解析 (lex) は文字からトークンを作 り 構文解析(parse) はトークンから構文木を作ります。

このskip Token メソッドは、 programというトークンを読み飛ばします。 そしてもしも programというトークンがなかったら、 ParseException の例外を投げます。

BNF を見ると、 その後に <command list> が続きます。 そこで、<command list> に対 応したCommandListNodeのインスタンスを生成し、そのインスタンスのparseメソッド を呼び出します。 <command list> がどういう内容になっているかは、 Program Node クラ スのメソッドには記述されていないことにご注意ください。 Program Nodeクラスで記述す

第23章 Interpreter 文法規則をクラスで表現する

るのは、あくまで

<program> program <command list>

というBNFで見えている範囲だけです。

さて、toString メソッドは、このノードの文字列表現を記述するためのものです。 Javaでは、 インスタンスを文字列と連結すると、 toStringメソッドが自動的に呼び出さ れますから、

* [program commandListNode + "]"

という式は、 * [program + commandListNode.toString() + "]"

という式と等価です。 このtoStringメソッドも、やはりBNFの内容にぴったりあわせて コードが書かれていることに注目しましょう。

List 23-2 Program Node クラス (ProgramNode.java)

1: // <program> = program <command list> 2: public class Program Node extends Node { 3: private Node commandListNode; 4: 5: @Override public void parse (Context context) throws ParseException { context.skipToken ("program"); commandListNode = new CommandListNode(); commandListNode.parse(context); 6: 7: 8: 9: 10: } 11: 12: 13: @Override public String toString() ( 14: + return program commandListNode + "]"; 15: ) 16: )

| CommandListNode クラス

次は、CommandListNodeクラス (List 23-3)を読みましょう。 BNFはこうなっています。

<command list> ::= <command> end

386

サンプルプログラム

<command> が0回以上繰り返して、 最後に endが来ます。 0回以上繰り返す <command> を保持するため、 CommandListNodeクラスはjava.util.List< Node>型のフィールド listを持っています。 このフィールドに、 <command>に対応したCommandNode クラスの インスタンスを格納します。

parseメソッドはどうなっていますか。 まず、現在注目しているトークン、context. currentToken ()の値がnu11だったら、もう残りのトークンがない (つまり、ミニ・プロ グラムを最後まで読んだ) ということです。その場合には、 parseメソッドは 「endがな い (Missing 'end')」というメッセージをつけて、 ParseException の例外を投げます。

次に、現在注目しているトークンがendだったら、 <command list> の終わりまで来た ことになります。 その場合には、 endを読み飛ばしてから while文を breakします。 現在注目しているトークンがendではなかったら、 それは <command> ということになり ますから、CommandNodeのインスタンスを作ってparseします。そして、そのインスタン スを CommandListNodeのlist フィールドにaddします。

ここでもまた、 BNF で記述された範囲だけの処理を行っていることがおわかりですね。 できるだけ BNF に忠実に、 あたかもBNF を Javaに移し変えるかのようにプログラミング しています。 このようにすると、プログラムミスが少なくなります。 つい、「こうした方 が高速化できるのでは?」という誘惑にとらわれて、より詳しい構造まで読み込んだ処理 をしたくなるものですが、そうすると思わぬバグを仕込んでしまう危険性があります。 Interpreterパターンは、もともとミニ言語という間接的な処理方法をとっているので、あ まり小手先で効率化をはかるのは賢明ではありません。

List 23-3 Command ListNode クラス (CommandListNode.java)

1: import java.util.ArrayList: 2: import java.util.List; 3: 4: // <command list> ::= <command> end 5: public class CommandListNode extends Node { 6: 7: 8: 9: 10: 11: 12: 13: 14: 15: 16: 17: private List<Node> list = new ArrayList<>(); @Override public void parse (Context context) throws ParseException { while (true) ( if (context.currentToken() == null){ throw new ParseException("Error: Missing 'end'); } else if (context.currentToken().equals("end")) ( context.skipToken("end"); break; ) else ( Node commandNode = new CommandNode();

387

章 Interpreter 文法規則をクラスで表現する 18: 19: 20: 21: 22: 23: 24: 25: 26: 27: 28: } commandNode.parse (context); list.add(commandNode); @Override public String toString() ( return list.toString();

388 第3

CommandNodeクラス

ProgramNode クラスとCommandListNode クラスの説明を読んで理解できたなら、 CommandNodeクラス (List 23-4) についてもすぐに理解できるでしょう。 BNFは、

<command> :: <repeat command> | <primitive command>

でした。 Node型のフィールド nodeは、<repeat command> に対応する RepeatCommand Node クラスのインスタンス、 または<primitive command> に対応する PrimitiveCommand Node クラスのインスタンスを格納するために使われます。

List 23-4 CommandNode 252 (CommandNode.java)

1: // <command> :: <repeat command> | <primitive command> 2: public class CommandNode extends Node { private Node node; @Override public void parse (Context context) throws ParseException { if (context.currentToken().equals("repeat")) { node = new Repeat CommandNode(): node.parse (context); 3: 4: 5: 6: 7: 8: 9: 10: 11: 12: 13: 14: 15: 16: @Override } else { node new PrimitiveCommandNode(); node.parse (context);

サンプルプログラム 389

17: 18: 19: 20: } public String toString() { return node.toString();

| Repeat CommandNode クラス

Repeat CommandNode クラス (List 23-5) は、 <repeat command> に対応しています。 <repeat command> ::= repeat <number> <command list>

<number の部分はint型の number フィールド、 <command list> の部分はNode 型の commandListNode フィールドに格納されます。

parseメソッドが持っている再帰性には、もうお気づきですね。 メソッド呼び出しをた どってみましょう。

• Repeat CommandNode の parseメソッドの中では、

CommandListNodeのインスタンスを作り、parse メソッドを呼び出し、

CommandListNodeのparse メソッドの中では、

CommandNodeのインスタンスを作り、 parseメソッドを呼び出し、

CommandNodeのparseメソッドの中では、

Repeat CommandNodeのインスタンスを作り、 parse メソッドを呼び出し、

Repeat CommandNodeのparse メソッドの中では、

...

この 「parse メソッドを呼び出していく旅」 は、どこまで続くのでしょうか。 はい、旅 の終着点はターミナル・エクスプレッションですね。 CommandNode の parseメソッドの中 f文により、 いつかは RepeatCommandNode ではなく PrimitiveCommandNodeを作る方に 進みます。 そして、 PrimitiveCommandNodeのparse メソッドの中からは、他のparse メ ソッドを呼び出しません。 この点については、すぐ次で紹介しますから確認しましょうね。 再帰的な定義の取り扱いに慣れないと、何だか無限ループになるような気がするのです が、それは錯覚です。 BNF でもJava でも、 いつかは必ずターミナル・エクスプレッショ ンにたどり着いて落ち着くことになるのです。 もし、いつまでもターミナル・エクスプレ ッションにたどり着かないなら、その定義は誤っていることになります。

23章 Interpreter 文法規則をクラスで表現する

第

List 23-5 RepeatCommandNode 52 (Repeat CommandNode.java)

1: <repeat command> ::repeat <number> <command list> 2: public class Repeat CommandNode extends Node { private int number; private Node commandListNode; @Override public void parse (Context context) throws ParseException ( context.skipToken ("repeat"); number context.currentNumber(); context.nextToken(); 3: 4: 5: 6: 7: 8: 9: 10: 11: 12: 13: } 14: 15: 16: @Override public String toString() { 17: return 18: } commandListNode = new CommandListNode(); commandListNode.parse (context); [repeat + number + + commandListNode "]";

19: )

PrimitiveCommandNode 57

PrimitiveCommandNode クラス (List 236) に対応する BNFは、

<primitive command> ::= go | right left

です。

確かに、ここのparseメソッドからは他のparseメソッドを呼び出し

List 23-6 PrimitiveCommandNode 757 (PrimitiveCommandNode.java)

1:

<primitive command> ::= go | right | left

2: public class Primitive CommandNode extends Node (

private String name;

ていませんね。

4:

@Override

public void parse (Context context) throws ParseException {

} else if (!name.equals("go") && !name.equals("right") && !name.equals("left"))

3:

5:

6:

7:

name context.currentToken();

if (name == null) {

8:

throw new ParseException("Error: Missing <primitive command>");

9:

10:

390

サンプルプログラム 391

throw new ParseException("Error: Unknown <primitive command>" + name + context.skipToken (name); 11: 12: } 13: 14: } 15: 16: 17: @Override public String toString() ( 18: return name; 19: } 20: )

Contextクラス

以上で、 Node クラスとそのサブクラスたちの解説は終わりました。 残っているのは、 Contextクラスです。 Contextクラス (List 23-7) は、 構文解析のために必要なメソッド を提供します。

Table 23-2 Contextクラスが提供するメソッド

名前 nextToken currentToken skipToken current Number 解說 次のトークンを得る (次のトークンに進む) 現在のトークンを得る (次のトークンへは進まない) 現在のトークンをチェックしてから、次のトークンを得る (次のトークンに進む) 現在のトークンを数値として得る (次のトークンへは進まない)

Contextクラスでは、与えられた文字列から 「空白文字の1個以上の連続」を区切りと してトークンの配列を作ります。 使われている splitメソッドは、 引数で渡された正規表 現にマッチする文字列を区切りとして文字列を分割し、結果を配列に変換してくれます。 「空白文字の1個以上の連続」 を意味する正規表現は\sなので、 text.split("\\s+*)で 目的の配列が得られます。 "\\s" で最初にバックスラッシュが2つ入っているのはJava の文字列リテラルでは\を表すのに、と書く必要があるからです。

例えば、textの値が "program go end" のとき、 text.split("\\s+ ")の結果は "program","go", "end"という3つの文字列からなる配列になります。

"'");

23 Interpreter-

List 23-7 Context 252 (Context.java)

1: import java.util.*;

2:

3: public class Context {

4:

5:

private String[] tokens;

private String lastToken;

6:

private int index;

8:

7:

public Context (String text) {

this.tokens = text.split("\\s+");

10:

9:

11:

12:

this.index = 0;

nextToken();

13:

14:

public String nextToken(){

if (index < tokens.length) {

}

15:

16:

lastToken tokens [index++];

17:

} else {

18:

lastToken = null;

19:

return lastToken;

20:

public String currentToken () {

21:

22:

23:

return lastToken;

24:

25:

}

26: 27: 28: 29: 30: 31: public void skipToken (String token) throws ParseException ( if (currentToken() == null) { more token is found."); is expected, but no throw new ParseException("Error: token + } else if (!token.equals (currentToken())) { throw new ParseException("Error: + token is expected, but. currentToken() is found."); 32: 33: nextToken(); 34: ) 36: 335332=22 public int current Number () throws ParseException { if (currentToken() == null) { 37: 38: 39: } 40: 41: 42: 43: throw new ParseException("Error: No more token."); int number = 0; try ( number Integer.parseInt(currentToken()); } catch (NumberFormatException e) {

392

throw new ParseException ("Error: ' + e): return number; 44: 45: } 46: 47: } 48: ) 393

サンプルプログラム

ParseExceptionクラス

ParseException クラス (List 23-8) は、 構文解析中の例外のためのクラスです。特に 変わったところはありません。

List 23-8 ParseException 52 (ParseException.java)

1: public class ParseException extends Exception { 2: 3: public ParseException (String msg) ( super (msg); 4: 5: ) )

| Main クラス

Main クラス (List 23-9) は、 私たちがここまで読んできたミニ言語のインタプリタを 動かすためのクラスです。 Mainは、 "program.txt"というファイルを読み込み、その1行 1行をミニプログラムだと思って構文解析し、その結果を文字列として表示します。

Fig.23-11の実行結果の中で、 text =で始まっている部分が与えられたミニプログラ ムで、 node = で始まっている部分が構文解析の結果です。 その表示を見ると、与えられ t: program endという単なる文字列に、まとまりを表す[]が挿入されていることが わかりますね。 与えられたミニ・プログラムを、 インタプリタは正しく理解していること になります。 ...

[注意] CommandListNodeのインスタンスを文字列化した部分、 例えば、 [go, right] の部分で 大カッコ[ ]やコンマ, をつけているのは、 java.util.ArrayListのtoStringメソッドです。

List 23-9 Main クラス (Main.java)

1: import java.nio.file.Files;

of program.txt"))) (

14

17

List 23 ミニープログラム

program g

program -

program repeat &

program gest &amp

pode pe

de

de v

ghe geight

night

halerterタンの登場人物

Interpreter パターンの登場人物

Interpreterパターンの登場人物は、次のとおりです。

アブストラクト・エクスプレッション

AbstractExpression (抽象的な表現)の役

構文木のノードに共通のインタフェース (API) を定める役です。 サンプルプログラム では、Node クラスがこの役をつとめました。 Fig.23-12ではインタフェース (API)を interpret という名前で表現しましたが、 サンプルプログラムではparse というメソッド でした。

ターミナル・エクスプレッション TerminalExpression (終端となる表現) の役

BNFのターミナル・エクスプレッションに対応する役です。 サンプルプログラムでは、 PrimitiveCommandNode クラスがこの役をつとめました。

ノンターミナル・エクスプレッション NonterminalExpression (非終端となる表現) の役

BNFのノンターミナルエクスプレッションに対応する役です。 サンプルプログラム では、 Program Node, CommandNode, RepeatCommandNode, CommandListNodeの各クラ スがこの役をつとめました。

コンテキスト

• Context (文脈、 前後関係) の役

インタプリタが構文解析を行うための情報を提供する役です。 サンプルプログラムでは、 Contextクラスがこの役をつとめました。

クライアント Client (依頼者)の役

構文木を組み立てるために、 TerminalExpression 役や NonterminalExpression 役を呼び 出す役です。 サンプルプログラムでは、 Main クラスがこの役をつとめました。

395

396 第23章 Interpreter- 文法規則をクラスで表現する

Fig.23-12 Interpreterパターンのクラス図

Client Creates▸ Context getInfoToInterpret Uses ▸ Abstract Expression interpret Terminal Expression Nonterminal Expression childExpressions interpret interpret

あなたの考えを広げるためのヒント

他にどんなミニ言語があるだろうか

この章では、ラジコンで車の制御を行うミニ言語を考えました。 これは Interpreter パタ ーンの一例にすぎません。 他にはどんなミニ言語があるのでしょうか。 いくつか挙げてお きましょう。

正規表現

GoF本 (付録D [GoF] 参照) には、 ミニ言語の例として正規表現 (regular expression) が登場します。 ここでは、

raining & (dogs | cats) *

のような表記を解釈し、構文木を作成します。 ちなみに、 上記は、 raining の後にdogs またはcatsが0回以上繰り返すということを表現しています。

関連しているパターン 397

◆検索構文

Webの検索エンジンでは、特殊な検索を行うために検索構文や検索オプションと呼ばれ る表現が用意されています。 例えばGoogleでは、 語句の前にマイナス(-) をつけて 「そ の語句を含まない検索」 を表したり、語句を二重引用符 () でくくって 「その語句と完 全一致する検索」 を表したりします。 さらに、

site example.com 語句1" AND "語句2"

のように指定すると 「example.comという特定のサイトで、 語句と語句2の両方に完全 一致する検索」 を表すことができます。 このように検索構文を使ってユーザが行うさまざ まな検索に柔軟に対応するのは、 Interpreter パターンと同じ発想です。

◆バッチ処理言語

基本的な命令がいくつか用意されており、それらを順番に実行したり、繰り返し実行し たりする言語(バッチ処理言語) も、 Interpreterパターンで処理できるでしょう。この章 のラジコン制御も、 バッチ処理言語の一種といえるかもしれません。

読み飛ばすか読み取るか

インタプリタを作っているときによく起きるのが、 トークンを1個多く読みすぎたり、 読み残したりするバグです。 各ノンターミナルに対応するメソッドを書くときは、常に 「このメソッドに来たときにはどこまでトークンを読んでいるか、このメソッドから出る ときにはどこまでトークンを読むべきか」 を意識しておく必要があります。

関連しているパターン

Composite パターン (第11章)

NonterminalExpression 役は、 再帰的な構造を持つことが多いので、 Composite パターン を使って表現されることが多いでしょう。

Flyweight パターン (第20章)

TerminalExpression 役は、 Flyweightパターンを使って共有される場合もあるでしょう。

第2章 Interpreter 文法規則をクラスで表現する

Visitor パターン (第13章)

構文木を作った後、 構文木の各ノードを巡回しながら処理を行うときには、 Visitorパタ ーンが使われる場合があります。

398

この章で学んだこと、そして最後の言葉

この章では、ミニ言語を使って問題解決を行う Interpreterパターンについて学びました。 BNF を使って言語を再帰的に定義する方法、そして構文木を構築する方法について考え ました。

さて、 GoFが紹介した23個のデザインパターンをめぐる旅も、いったん終着点 (ター ミナル) にたどり着いたようです。 みなさんの感想はいかがでしょうか。 簡単なパターン やよく理解できるパターンがある一方で、複雑なパターンやあまり理解できないパターン もあったことと思います。

しかし、個々のパターンの理解はさておき、プログラムを 「デザインパターン」という 視点から見る力は、だいぶついたのではないでしょうか。 抽象クラスやインタフェースの 役割、 継承や委譲の使い方、 クラスやメソッドを見せたり隠したりすること、 交換可能性、 ソースを書き換えずに部品として再利用する方法･･･。 ほら、各章で学んできたデザインパ ターンというドラマがよみがえってきませんか。

読者の設計するプログラムが素晴らしいドラマを生み出すことを期待しつつ、 本書を閉 じたいと思います。 ここまでお読みくださり、ありがとうございました。 またいつかお会 いできる日を楽しみにしています。

Enjoy Patterns!

練習

「練習問題

解答は付録A (p.493)

●問題23-1

サンプルプログラムでは、 構文解析のみを行いました。 プログラムを修正して、 構文解 析に与えられたプログラムを 「実行」 するようにしてください。 goやright, leftという 基本コマンド (<primitive command>) をどのように 「実行」 するかは、自由に考えて ください。

ヒント これは本書での最後の練習問題ですので、パターンのまとめも兼ねて、以下のようにたく さん手を加えた解答を用意しました。

. GUI を使って基本コマンドの結果を描画するようにしました。 ・Facade パターン (第15章) を使って、 インタプリタを利用しやすくしました。 ・基本コマンドを生成するクラスを作りました (Factory Methodパターン (第4章))。 インタプリタ部分を別パッケージにまとめました。

Fig.23-4~Fig.23-7でミニ言語を解説しているときにお見せしたものが実行例となります。

399



付録

付録A 練習問題の解答 付録B GoFによるデザインパターンの分類 付録C デザインパターン Q&A 付録D 参考文献

402 M

付録A

練習問題の解答

|第1章

問題1-1の解答

(問題はp.16)

以下のようになります。 Main クラスの while文と拡張for文は、 まったく変更する必要 がありません。

List A1-1 BookShelf 257 (BookShelf.java)

1: import java.util.ArrayList;

2: import java.util.Iterator:

3: import java.util.List;

5: public class BookShelf implements Iterable<Book> {

4:

private List<Book> books;

6:

public BookShelf (int initialsize) (

7:

8:

this.books new ArrayList<> (initialsize);

10:

11:

9:

}

12:

public Book getBookAt (int index) {

13:

return books.get(index);

14:

15:

16:

public void appendBook (Book book) { books.add(book);

17:

18:

19:

public int getLength() {

20:

return books.size();

21:

)

22:

@Override

23:

24:

25:

public Iterator<Book> iterator() {

return new BookShelf Iterator(this);

26:

)

28: )

27:

付録A 練習問題の解答 403

List A1-2 Main 57 (Main.java)

1: import java.util.Iterator;

2:

3: public class Main () public static void main(String[] args) { Bookshelf bookshelf = new BookShelf (4); bookShelf.appendBook (new Book ("Around the World in 80 Days")); bookShelf.appendBook (new Book (*Bible")); bookshelf.appendBook (new Book ("Cinderella")); bookShelf.appendBook (new Book ("Daddy-Long-Legs")); bookShelf.appendBook (new Book (*East of Eden")); bookshelf.appendBook (new Book ( "Frankenstein")); bookShelf.appendBook (new Book ("Gulliver's Travels")); bookShelf.appendBook (new Book ("Hamlet")); 4: 5: 6: 7: 8: 9: 10: 11: 12: 13:

14:

15:

16:

17: 18:

// 明示的に Iteratorを使う方法

Iterator<Book> it

while (it.hasNext()) {

bookShelf.iterator();

19:

Book book it.next(); =

20:

}

System.out.println(book.getName());

21:

22:

System.out.println();

23: 24: 25: 26: } 27: // 拡張for文を使う方法 for (Book book: bookshelf) ( System.out.println(book.getName()); System.out.println(); 28: } 29: )

Fig.A1-1

Around the World in 80 Days Bible Cinderella Daddy-Long-Legs East of Eden Frankenstein Gulliver's Travels Hamlet Around the World in 80 Days Bible Cinderella Daddy-Long-Legs East of Eden Frankenstein Gulliver's Travels Hamlet

404 付録

第2章

(問題はp.30)

問題2-1の解答

「Print インタフェースのメソッドだけを用いる」 という点を強調したかったからです。 このサンプルプログラムでは、 Print BannerクラスとPrintインタフェースが提供してい るメソッドは同じです。 しかし、場合によってはPrintBannerクラスの方が多くのメソ ッドを持っているかもしれません。 Print型の変数に代入してそれを使うことで、 「PrintBannerクラスのメソッドを利用しているのではなく、 Printインタフェースのメ ソッドを利用しているのだ」 というプログラマの意図がはっきりするのです。

補足 たとえ Print型の変数に代入されていても、実際にそのインスタンスが PrintBanner クラ スのインスタンスならば、次のようにキャストを行うことでPrintBannerの固有のメソッドも、 呼び出すことができます。

((PrintBanner)p).method whichExistsOnlyInPrint Banner();

もしも、pに代入されているのが、 PrintBannerクラスおよびそのサブクラス以外のクラスの インスタンスだったら、 実行時の例外 (java.lang.ClassCastException) になります。 ただし、Javaのプログラミングでキャストがどうしても必要になる場面は限定的です。 キャス トを安易に使わないようにしましょう。

問題2-2の解答

(問題はp.30)

解答は次のようになります。 ここでは委譲を使ったAdapterパターンを適用しています。

List A2-1 FileProperties クラス (FileProperties.java)

1: import java.io.FileReader; 2: import java.io.FileWriter; 3: import java.io.IOException; 4: import java.util.Properties; 5: 6: public class FileProperties implements FileIO { Properties property = new Properties(); @Override 7: 8: 9: 10: 11: 12: ) public void readFromFile (String filename) throws property.load(new FileReader (filename));

IOException (

付録A 練習問題の解答 405

13:

@Override public void writeToFile (String filename) throws IOException { property.store (new FileWriter (filename), "written by FileProperties"); @Override public void setValue (String key, String value) ( property.setProperty (key, value); } ) @Override public String getValue(String key)( ) return property.getProperty (key, "");

14:

15:

16:

17:

19:

18:

20:

21:

22:

23:

25:

28:

24:

26:

27:

第3章

| 問題3-1 の解答

(問題はp.46)

サブクラスで実装することが要請されているのは、 java.io.InputStream の read() メ ソッド (引数がないもの) です。 read() メソッドは、 java.io.InputStreamのテンプレ ートメソッドである read (byte[] b, int off, int len) によって繰り返し呼び出され ます。

つまりここでは 「1バイト読む」という処理の具体的な内容はサブクラスにまかせ java.io.InputStreamの側では 「指定数バイトを配列の指定位置に読み込む」という処理 のテンプレートを形作っていることになります。

問題3-2の解答

(問題はp.46)

display メソッドが、サブクラスでオーバーライド (override) できないことを表して います。

強いて言葉を補えば、このクラス作成者は、「もしもサブクラスを作るなら、 display メソッドをオーバーライドせずに機能拡張せよ」 と、 サブクラス作成者に対して要請して いることになります。

406 付録

GoF 本 (付録D [GoF] 参照) には、テンプレートメソッドはオーバーライドすべきで はないと書かれています。 メソッドのオーバーライドを禁止するには、このサンプルプロ グラムのように final宣言をします。

問題3-3の解答

(問題はp.46)

AbstractDisplayクラスにおいて、 open, print, closeメソッドをprotected宣言 します。 すると これらのメソッドは継承関係にあるサブクラスからは呼び出せますが、 他のパッケージにあるクラスからは呼び出せなくなります(ただし、 同じパッケージにあ るクラスからは呼び出せてしまいます)。

問題3-4の解答

問題はp.46)

AbstractDisplay インタフェースはList A3-1のようになります。 また Char Displayと StringDisplay では、クラスの拡張を表す extends ではなくインタフェースの実装を表す implements を使う修正が必要になります。 Mainクラスの修正は不要です。 なお、インタ フェースのdefaultメソッドはあくまでデフォルト実装の提供が目的なので、 final宣言 はできません。

List A3-1 AbstractDisplay.java

1: public Interface AbstractDisplay { public void open(); 2: 3: public void print(); 4: public void close(); 5: 6: 7: 8: public default void display() ( open(): for (int i = 0; i < 5; i++) { 9: print(); 10: } 11: close(); 12: 13: )

List A3-2 CharDisplay.java

1: public class CharDisplay implements AbstractDisplay ( 2: private char ch; // 表示すべき文字

RNA ROS 407

3:

// コンストラクタ public CharDisplay (char ch) ( this.ch = ch; }

4:

5:

7:

6:

8:

9:

10:

@Override public void open () { // 開始文字列として"<<"を表示する System.out.print ("<<");

11:

13:

12:

14: 15: 16: 17: 18: 19: ) 20: 21: 22: 23: 24: 25: 26: } @Override public void print () ( // フィールドに保存しておいた文字を1回表示する System.out.print (ch); @Override public void close () ( // 終了文字列として" を表示する System.out.println(">>");

List A3-3 StringDisplay.java

1: public class StringDisplay implements AbstractDisplay ( 2: private String string; // private int width; // 文字列の表示幅 // コンストラクタ public String Display (String string) { this.string this.width string; string.length(); 3: 4: 5: 6: 7: 8: 9: 10: 11: 12: 13: 14: ) 15: 16: 17: 18: 19: } @Override public void open () ( printLine(); @Override public void print() ( System.out.println("| string +|*);

408 付録

20:

21: @Override 22: 23: public void close() { printLine(); 24: 25: 26: 27: 28: 29: 30: //openclose から呼び出されて+----+"という文字列を表示するメソッド private void printLine() { System.out.print("+"); for (int i = 0; i < width; i++) { System.out.print("-"); 31: } 32: System.out.println("+"); 33: 34: )

第4章

問題4-1の解答

IDCardのインスタンスは、 idcardパッケージ外からnewを使って生成できないことを表 しています。 ですから、IDCardのインスタンスを生成するときは、 必ず IDCardFactoryを 経由しなければならないことになります。

例えば、 Mainクラス (無名パッケージ)から、

IDCard idcard = new IDCard ("Hiroshi Yuki");

のようにしてIDCardのインスタンスを作ることはできません。 このコードはコンパイル 時のエラーになります。

足 Java では、public, protected, privateなどのアクセス制御が何もついていないコン ストラクタやメソッドは、同じパッケージ内のクラスからのみ利用できます。

問題4-2の解答

(問題はp.59)

(問題はp.59)

List A4-1, List A4-2のようになります。 framework. Productクラス (List 4-1)、 framework. Factoryクラス (List 4-2)、 それにMainクラス (List 4-5) を修正する必要は ありません。 IDCardクラスとIDCardFactoryクラスを修正しても、 フレームワーク側の

付録A 練習問題の解答 409

ソースコードは修正する必要がまったくないことに注目してください

。 通し番号は100番から開始していますが、 特に意味はありません。

IDCardFactoryクラスのcreateProductメソッドを synchronizedメソッドにしている のは、マルチスレッドで動作させたときに、異なるインスタンスに同じ通し番号がつくの を防ぐためです。 複数のスレッドからアクセスされないのであれば、 synchronized メソ ッドにする必要はありません。

List A4-1 通し番号をつけた IDCard クラス (IDCard.java)

1: package idcard; 2: 3: import framework. Product; 4: 5: public class IDCard extends Product { private String owner; private int serial; IDCard (String owner, int serial) { System.out.println(owner + this.owner owner; this.serial = serial; + - serial + *番で作ります。 *); @Override public void use () { System.out.println(this +" "); 6: 7: 8: 9: 10: 11: 12: 13: } 14: 15: 16: 17: 18: } 19: 20: 21: 22: 23: ) 24: 25: 26: 27: ) @Override public String toString() ( return [IDCard: owner (serial)]*; public String getOwner() { return owner;

28:

29:

30:

public int getSerial () (

return serial;

31:

32: )

)

410 M

List A4-2 通し番号をつけたIDCardFactory クラス (IDCardFactory.java)

1: package idcard; 2: 3: import framework.Factory: 4: import framework.Product; 5: 6: public class IDCardFactory extends Factory ( 7: 8: 9: private int serial = 100; protected synchronized Product createProduct (String owner) ( return new IDCard (owmer, serial++); 10: 11: } 12: 13: 14: 15: 16: 17: ) @Override protected void register Product (Product product) ( System.out.println(productを登録しました。 ");

Fig-A4-1 実行結果

Hiroshi Yukiのカードを100番で作ります。 [IDCard: Hiroshi Yuki (100) ] を登録しました。 Tomuraのカードを101番で作ります。 IDCard: Tomura (101)] を登録しました。 Hanako Satoのカードを102番で作ります。 [IDCard: Hanako Sato (102)] を登録しました。 [IDCard: Hiroshi Yuki (100) ] を使います。 IDCard: Tomura (101)] を使います。 [IDCard Hanako Sato (102)] を使います。

問題4-3の解答

問題はp.59)

Java では abstract なコンストラクタを作ることができないからです。 Java ではコンスト ラクタは継承されませんので、 abstractなコンストラクタには意味がありません。 コンストラクタで製品に名前をつけるのではなく、名前をつけるためのメソッドを別途 宣言する必要があります。

付録A の解答

| 第5章

| 問題5-1 の解答

(問題はp.68 )

List A5-1のようになります。

Singletonパターンの話題からは少し外れますが、ここではgetNext TicketNumber を synchronized メソッドにしたことにご注意ください。 これは、マルチスレッド環境で getNext TicketNumber メソッドが呼び出されても正しく動くようにするための措置です。 もしsynchronizedがついていないと、複数のスレッドに対して同じ値を返す危険性があ ります。

List A5-1 Singleton->Tub TicketMaker 757 (TicketMaker.java)

1: public class TicketMaker ( private int ticket = 1000; private static Ticket Maker singleton = new Ticket Maker(); private Ticket Maker() { 2: 3: 4: 5: 6: } 7: public static Ticket Maker getInstance() { return singleton; 8: 9: 10: } 11: 12: 13: 14: ) 15: ) public synchronized int getNextTicketNumber () ( return ticket++;

List A5-2 TicketMaker 555 (Main.java)

1: public class Main ( public static void main(String[] args) { System.out.println("Start."); for (int i=0; i<10; i++) ( 2: 3: 4: 5: 6: } 7: 8: System.out.println(i + Ticket Maker.getInstance().getNextTicket Number(System.out.println("End."); 9: )

));

411

M

Fig.A5-1 実行結果

Start. 0:1000 1:1001 2:1002 3:1003 4:1004 5:1005 6:1006 7:1007 8:1008 9:1009 End.

問題5-2の解答

(問題はp.68 )

Tripleクラス (List A5-3) インスタンスは、自分の名前 (name) を持ちます。 Triple クラスは、 static フィールド (クラス変数) として名前とTripleインスタンスの対応表 mapを持ち、そこに"ALPHABETA", "GAMMA " という名前を持つインスタンスを登録しま す。 getInstance メソッドは、引数で与えられたname を使って対応表mapからインスタ ンスを1つだけ返します。

名前の配列 (names) を使って3つのインスタンスを登録する以下の部分では、Javaの ストリームを使っています。

String[] names = { "ALPHA", "BETA", "GAMMA" };

Arrays.stream (names).forEach(smap.put(s, new Triple(s)));

Arrays.stream (names)で作ったストリームをforEachメソッドに流し、 ストリームか ら渡された個々の名前は、

smap.put(s, new Triple(s))

というラムダ式に引数sとして渡されます。 要するにここでは、

map.put("ALPHA", new Triple ("ALPHA*));

map.put("BETA", new Triple("BETA"));

map.put("GAMMA", new Triple ("GAMMA"));

という処理を行っているのです。

412

練習問題の解答

List A5-3 Triple 52 (Triple.java)

1: import java.util.Arrays; : import java.util.HashMap;

23: import java.util.Map; 4: 5: public class Triple ( private static Map<String, Triple> map = new HashMap<>(); static ( String names ("ALPHA", "BETA", "GAMMA' ); Arrays.stream (names).forEach (s -> map.put (s, new Triple(s))); private String name; private Triple (String name) { . System.out.println("The instance + name + is created."); this.name name; = 6: 7: 8: 9: 10: ) 11: 12: 13: 14: 15: 16: 17: } 18: 19: 20: 21: 22: } 23: 24: 25: 26: 27: ) public static Triple getInstance(String name) { return map.get(name); @Override public String toString() ( return this.name; }

List A5-4 Triple 53552 (Main.java)

2: 3: 1: public class Main () public static void main(String[] args) { System.out.println("Start."); 4: Triple al Triple.getInstance("ALPHA"); 5: Triple bl Triple.getInstance("BETA"); 6: Triple cl Triple.getInstance("GAMMA"); 7: Triple a2 Triple.getInstance("ALPHA"); 8: Triple b2 Triple.getInstance("BETA"); 9: Triple c2 Triple.getInstance("GAMMA"); 10: 11: if (al ==a2) ( System.out.println("ala2 (+al+*)*); 12: } else { 13: System.out.println("al != a2");

413

414 t

14: if (b1 ==b2) ( System.out.println("b1 == b2 ("+b1 + ")"); } else { 15: 16: 17: 18: 19: } 20: 21: 22: 23: 24: 25: 26: 27: ) } System.out.println("b1 = b2"); if (c1 ==c2) ( System.out.println('c1 == c2 (" +c1 + ")"); } else { System.out.println("c1 = c2"); System.out.println("End.");

Fig.A5-2

Start.

The instance ALPHA is created. The instance BETA is created. The instance GAMMA is created.

al == a2 (ALPHA)

b1 == b2 (BETA)

c1 == c2 (GAMMA) End.

List A5-3では複数のインスタンスを保持するのに配列を使いましたが、 List A5-5のよ うにenumを使う方法もあります。 enumには自動生成される value of メソッドがあり、文 字列表現からインスタンスを得ることができます。

List A5-5 enum & Triple 57 (Triple.java)

1: public enum Triple ( 2: 3: ALPHA, BETA, GAMMA; 4: private Triple() { System.out.println("The instance +this+ is created."); 5: 6: } 7: 8: 9: 10: 11: ) public static Triple get Instance (String name) { return valueof (name);

付録A 練習問題の解答 415

問題5-3の解答

(問題はp.68 )

複数のスレッドからほぼ同時にSingleton.getInstance メソッドが呼ばれたときに、 複数のインスタンスが生成されてしまう可能性があるからです。

List A5-6 5 Singleton.getInstance

1: public class Main extends Thread (

(Main.java)

2: 3: 4: 5: 6: public static void main(String[] args) { System.out.println("Start."); new Main ("A").start(); new Main ("B").start(); new Main ("C").start(); System.out.println("End."); 7: 8: ) 9: 10: 11: @Override public void run() { 12: Singleton obj = Singleton.getInstance(); 13: System.out.println (getName() + obj = obj); + 14: } 15: 16: public Main(String name) ( 17: super (name); 18: } 19: )

List A5-6は、実行したときのマシンの状態によって結果が異なりますから、確実に複 数のインスタンスを生成させるには、 List A5-7のようにします。 例えば、 Fig.A5-3のよ うな実行結果になります。

List A5-7 確実に複数インスタンスを生成させるためにわざとスピードを遅くしたもの (Singleton.java)

1: public class Singleton ( 2: 3: 4: 5: 6: 7: private static Singleton singleton = null; private Singleton () { System.out.println(1237LLA."); slowdown();

8:

416 付録

9: 10: public static Singleton getInstance() { if (singleton == null) { singleton = new Singleton(); return singleton; 11: 12: } 13: 14: ) 15: 16: 17: 18: 19: 20: } 21: 22: private void slowdown () { try ( Thread.sleep(1000); } catch (InterruptedException e) {

Fig-A5-3 実行結果例

Start. End. インスタンスを生成しました。 インスタンスを生成しました。 インスタンスを生成しました。 A: obj = Singleton@6ec612 B: obj = Singleton@dd1f7 C: obj = Singleton@53c015 複数回インスタンスが作られている A,B,Cでインスタンスの内容が異なる

このようになるのは、

if (singleton == null) { singleton = new Singleton (); }

の条件判断が甘い (スレッドセーフではない)からです。

singleton == null

を使って、最初のインスタンスかどうかを判断した後、

singleton = new Singleton();

を実行していますが、この代入の実行より前に、他のスレッドが最初の条件式の評価を行 うかもしれないのです。

List A5-8のように synchronizedを使えば、複数のスレッドから getInstance メソッド が呼び出されても複数のインスタンスが生成されることはありません。 しかしこの場合に

Aの解答

はgetInstanceメソッドの動作スピードが遅くなってしまいます。

この問題5-3のように、フィールドの値が必要になるまで初期化を遅らせる方法を一般 に遅延初期化といいます。 遅延初期化を行うのは、インスタンスが必要になるまで生成の タイミングを遅らせて初期化のスピードアップを狙うためですが、 初期化後の動作に時間 が掛かってしまうことになります。 はっきりした理由がなければ、遅延初期化を行わず、 サンプルプログラムのList 5-1のように普通に初期化する方が無難です ( 練習問題 5-3は 付録Dの [Bloch] を参考にしました)。

List A5-8 厳密なSingleton パターンにしたもの (Singleton.java)

1: public class Singleton ( private static Singleton singleton = null; private Singleton () ( 2: 3: 4: 5: 6: 7: } System.out.println(インスタンスを生成しました。 "); slowdown(); 8: 9: public static synchronized Singleton getInstance() { if (singleton == null) ( singleton = new Singleton () return singleton; 10: 11: 12: } 13: 14: } 15: 16: 17: 18: 19: 20: 21: 22:) private void slowdown () ( try( Thread.sleep(1000); } catch (InterruptedException e) (

Fig.A5-4 実行結果例

Start.

End.

インスタンスを生成しました。

C: obj = Singleton@ldeee304

インスタンスは1回しか作られていない ←A.B.Cでインスタンスの内容が同じ

B: obj = Singleton@ldeee304

A: obj = Singleton@ldeee304

417

418 付録

第6章

問題6-1の解答

(問題はp.86 )

例えば、以下のような方法があります。

(a) ProductインタフェースをProductクラスにして、 createCopyメソッドを実装 します (Template Method パターン)。

(b) UnderlinePen クラスとMessageBoxクラスの共通のスーパークラスとして、 ConcreteProductクラスを定義します。 ConcreteProductクラスはProduct イ ンタフェースを実装するものとし、その中で createCopyメソッドを実装します。

どの場合でも、 createCopy メソッドを継承によって共有しています。

問題6-2の解答

(問題はp.86)

Productインタフェースは Cloneableを拡張するのをやめます (List A6-1)。 MessageBox (List A62) と UnderlinePen (List A6-3) では、新たにコピーコンストラク タを作り、 createCopyメソッドの中ではcloneの代わりにコピーコンストラクタを使っ てインスタンスを作ります。

Manager クラスとMainクラスを修正する必要はありません。

List A6-1 Product クラス (Product.java)

1: package framework; ||

2: 3: public interface Product { 4: 5: 6: ) public abstract void use (Strings); public abstract Product createCopy();

List A6-2 MessageBox 752 (MessageBox.java)

1: import framework.Product; 2: 3: public class MessageBox implements Product { 4: private char decochar; 5:

付録A 練習問題の解答 419

6:

public MessageBox (char decochar) ( this.decochar = decochar; }

7:

8:

9:

10:

11:

// コピーコンストラクタ public MessageBox (MessageBox prototype) { this.decochar prototype.decochar; }

12:

13:

14: 15: 16: 17: 18: 19: 20: 21: 22: 23: 24: 25: 26: 27: } 28: 29: 30: 31: 32: 33: ) @Override public void use (String s) ( int decolen 1 s.length() + 1; for (int i = 0; i < decolen; i++) { System.out.print (decochar); System.out.println(); System.out.println (decochar s + decochar); for (int i = 0; i < decolen; i++) { } System.out.print (decochar); System.out.println(); @Override public Product createCopy() ( return new MessageBox (this);

List A6-3 UnderlinePen 52 (UnderlinePen.java)

5: 6: 7: 1: import framework. Product; 2: 3: public class Underline Pen implements Product ( 4: private char ulchar; public Underline Pen (char ulchar) { this.ulchar ulchar; 8: } 9: 10: 11: 12: // コピーコンストラクタ public Underline Pen (UnderlinePen prototype) ( this.ulchar prototype.ulchar; 13: ) 14: 15: @Override 16: public void use (String s) {

420 M

17: 18: 19: 20: 21: 22: 23: 24: 25: 26: 27: 28: 29:1 ៥ ១ ១៩៨៧ ៩៥ ភ្នំកំព int ulen s.length(); System.out.println(s); for (int i=0; i < ulen; i++) { } System.out.print (ulchar); System.out.println(); @Override public Product createCopy() { return new Underline Pen (this);

第7章

問題7-1の解答

(問題はp.102)

修正点は以下の3点です。 List 7-2のDirectorクラスと、 List 7-5のMainクラスの修正 は不要です。

・Builderクラス(List 7-1)の修正点 public abstract class Builder ↓ public interface Builder

TextBuilderクラス (List 7-3)の修正点

public class TextBuilder extends Builder

↓

public class TextBuilder implements Builder

HTMLBuilderクラス ( List 7-4)の修正点 public class HTMLBuilder extends Builder ↓ public class HTMLBuilder implements Builder

問題7-2の解答

例えば、 List A7-1のようになります。 確かに、 TextBuilderもHTMLBuilderも修正する

(問題はp.102)

付録A 練習問題の解答 421

必要はありません。

List A7-1 Director (Director.java)

1: public class Director ( 2: 3: 4: private Builder builder; public Director (Builder builder) { this.builder builder; public void construct() { builder.makeTitle("Bye"); builder.makeString("h builder.makeItems (new String[] [ 5: 6: } 7: 8: 9: 10: 11: 12: 13: 14: 15: }); 16: 17: 18: 19: 20: 21: 22: } 23: ) "See you.", "Take care.", "Bye." builder.makeString("Th builder.makeItems (new String[]{ }); "It was nice to see you.", "I'm looking forward to seeing you again.", builder.close();

Fig.A7-1 実行結果 (テキスト)

javac Main.java

java Main text

[Bye]

■気軽な別れのあいさつ

⚫ See you.

Take care.

. Bye.

丁寧な別れのあいさつ

It was nice to see you.

I'm looking forward to seeing you again.

M

Fig-A7-2 (HTML>>JL)

javac Main.java java Main html HTML ファイル Bye.html が作成されました。

Fig.A7-3 Bye.html (HTMLBuilder #77)

<!DOCTYPE html>

<html>

<head><title>Bye</title> </head>

<body>

<h1>Bye</h1>

<p>気軽な別れのあいさつ </p>

<ul>

<li>See you.</li>

<li>Take care.</li>

<li>Bye.</li>

</ul>

<p> 丁寧な別れのあいさつ </p>

<ul>

<li>It was nice to see you.</li>

<li>I'm looking forward to seeing you again. </li> </ul>

</body></html>

| Fig.A7-4 HTMLBuilder が作成した Bye.html をブラウザで見た様子

Bye 気軽な別れのあいさつ . See you. . Take care. . Bye. 丁寧な別れのあいさつ It was nice to see you. I'm looking forward to seeing you again.

422

付録 練習問題の解答 423

問題7-3の解答 問題はp.102)

Concrete Builder 役として、 JFC/Swingを利用したグラフィカルユーザインタフェース (GUI) を作ってみました。 List A7-2 の FrameBuilder クラスでは、makeStringの部分は ウインドウ上のラベル (JLabel) として実現し、makeItemsの部分はウインドウ上のボ タン (JButton) として実現しています。 BuilderクラスとDirector クラスはサンプル プログラムと同じです。

実行すると、 Fig.A7-5のようなウインドウが表示されます。 ボタンをクリックすると、 ボタンに書かれている 「Good morning.」 などが標準出力に表示されます。

List A7-2 Frame Builder 2 (FrameBuilder.java)

1: import java.awt.*;

2: import java.awt.event.*;

3: import javax.swing.*;

4:

5: public class Frame Builder extends Builder (

private JFrame frame = new JFrame();

private Box box = new Box (BoxLayout.Y_AXIS);

@Override

public void makeTitle (String title) (

frame.setTitle(title);

11:

13:

14:

15:

7:

6:

10:

19:

12:

@Override

public void makeString (String str) (

16:

JLabel label = new JLabel (str);

label.setBorder (BorderFactory.createEmptyBorder (10,10,10,10)); box.add(label);

18:

)

21:

20:

22:

23:

25:

24:

26:

27:

' @Override public void makeItems (String[] items) ( Box innerbox = new Box (BoxLayout. Y_AXIS); for (String caption: items) ( JButton button = new JButton (caption); button.addActionListener(e -> ( }); System.out.println(e.getActionCommand()); innerbox. add (button); innerbox.setBorder (BorderFactory.createEmpty Border (10,10,10,10)); box. add (innerbox);

28:

29:

30:

17:

31:

9:

32:

8:

424

34: 35: @Override 36: 37: 38: 39: 40: 41: public void close() { frame.getContentPane().add(box); frame.pack(); frame.addWindowListener(new WindowAdapter() { public void windowClosing (WindowEvent e) { System.exit(0); 42: ) 43: }); 44: }

33:

45:

public JFrame getFrameResult() {

46:

return frame;

47:

48:

49: )

List A7-3 Main 75% (Main.java)

1: import javax.swing.JFrame;

2: 3: public class Main ( public static void main(String[] args) { 4: 5: 6: 7: 8: 9: 10: } FrameBuilder framebuilder = new FrameBuilder(); Director director = new Director (framebuilder); director.construct(); JFrame frame framebuilder.getFrameResult(); frame.setVisible(true); 11: )

Fig.A7-5

)

Greeting 一般的なあいさつ How are you? Hello. HI. 時間帯に応じたあいさつ Good morning. Good afternoon. Good evening.

}

付録A 練習問題の解答

問題7-4の解答

(問題はp.102 )

String を使っても、 List A7-4 のように appendを+=に修正すれば、問題はありません。 ただし、このプログラムのように文字列の修正や追加が頻繁に発生する場合には、 Stringを使うより、 StringBuilder を使う方が高速です。 String を使うと、 修正や追加 のたびに、 Stringクラスの新しいインスタンスを生成してしまうからです。

List A7-4 TextBuilder 57 (TextBuilder.java)

2: 3: 4: 5: 1: public class Text Builder extends Builder { private String text = ""; @Override public void makeTitle (String title) ( 6: text ======== \n"; 7: text [title] \n"; 8: text "\n"; 9: ) 10: 11: 12: @Override public void makeString (String str) ( 13: text + str + "\n"; 14: text "\n"; 15: ) 16: 17: 18: 19: @Override public void makeItems (String[] items) ( for (String s: items) ( 20: text + s + "\n"; 21: ' 22: text "\n"; 23: ) 24: 25: 26: 27: @Override public void close() ( text

28:

29:

30:

)

public String getTextResult() (

31:

return text;

32:

33: )

)

425

426 M

第8章

(問題はp.129 )

問題8-1の解答

private にした場合の良い点は、 Trayのサブクラス (つまり具体的な部品) 、 tray フィールドの実装に依存したコードにならないことです。

private にした場合の悪い点は、適切なアクセス用のメソッドを新たに作成する必要が 生じることです。

一般に、 protected フィールドを使うよりも、フィールドをprivateにしてアクセス用 のメソッドを作る方が安全なプログラムになります。

問題8-2の解答

以下のようになります。 修正が必要なのはFactoryクラスとMainクラスだけです。

List A8-1 Factory 757 (Factory.java)

(問題はp.129 )

1: package factory; 2: 3: public abstract class Factory ( public static Factory getFactory (String classname) { 4: 5: 6: 7: 8: 9: 13: 14: Factory factory = null; try{ factory = (Factory)Class.forName(classname) .getDeclaredConstructor() .newInstance(); } } catch (ClassNotFoundException e) { System.out.println("クラス } catch (Exception e) { e.printStackTrace(); return factory; . classname + が見つかりません。");

9101121155789022 16:

public abstract Link createLink (String caption, String url); public abstract Tray createTray (String caption);

public abstract Page create Page (String title, String author);

public Page createYahooPage()( Link link = createLink("Yahoo!", "https://www.yahoo.com/*); Page page = createPage("Yahoo!" "Yahoo!");

HNA ON

23: 24: 25: 26: ) page.add(link); return page;

List A8-2 Main 57 (Main.java)

1: import factory.*; 2: 3: public class Main ( 4: 5: 6: 7: 8: public static void main(String[] args) ( if (args.length != 2) { System.out.println("Usage: java Main filename.html class.name.of.Con creteFactory"); System.out.println("Example 1: java Main list Yahoo.html list factory. ListFactory"); vFactory"); System.out.println("Example 2: java Main divyahoo.html divfactory. Di System.exit(0); 9: 10: } 11: 12: 13: 14: 15: 16: 17: 18: 19: 20: 21: 22: } String filename = args[0]; String classname = args[1]; Factory factory Factory.getFactory (classname); // Page Page page factory.createYahooPage(); page.output (filename);

Fig.A8-1 listfactory Yahoo!

Yahoo! . Yahool Yahool

Fig.A8-2 divfactory Yahoo! Yahoo!

Yahool

Yahoo!

427

428 付録

問題8-3の解答

Javaではコンストラクタは継承されないからです。

(問題はp.129 )

スーパークラスでLink (String caption, String url) というコンストラクタがあっ たとしても、ListLinkの側でListLink (String caption, String url)というコンスト ラクタを定義しなければ、

new ListLink("Yahoo!", "https://www.yahoo.com/*)

のように呼び出すことはできません。 コンパイル時のエラーになります。

問題8-4の解答

(問題はp.129 )

Page は Tray に addすることはできない (HTMLの文法上不適切) からです。もしPage クラスを Trayクラスのサブクラスにしてしまうと、 Page も Item のサブクラスになり、 addの対象になってしまいます。

その代わり、 Page クラスでmakeHTMLを宣言する必要が生じてしまいました。makeHTML メソッドを含むJavaのインタフェース HTMLableを次のように作り、 Item クラスと Page クラスはHTMLableをimplementsするように変更すれば、よりすっきりとまとめることが できます。

public interface HTMLable { public abstract String makeHTML(); }

第9章

問題9-1の解答

(問題はp.144 )

これは 「機能のクラス階層」 への追加になります。

RandomCountDisplayクラス (List A9-1) は、 Displayのサブクラスとして作ってもか まいませんが、ここでは、CountDisplayのサブクラスとして作りました。 java.util.Randomは乱数生成器を表現したクラスで、 nextInt(n) メソッドは、 0 以上 n未満の整数をランダムに生成し、 戻り値とします。

List A9-2のMainクラスでは、 RandomCountDisplayの randomDisplay メソッドを呼び 出しています。 実行すると、 0~9個の "Hello, Japan."という文字列が表示されます。

付録A 練習問題の解答

List A9-1 RandomCountDisplay 752 (RandomCountDisplay.java)

1: import java.util.Random;

2:

3: public class RandomCount Display extends CountDisplay ( private Random random = new Random(); 4:

5:

6:

public RandomCount Display (DisplayImpl impl) ( super (impl);

7:

8:

9:

10:

}

public void randomDisplay (int times) ( multiDisplay (random.nextInt (times));

}

11:

12:

13: )

List A9-2 Main (Main.java)

1: public class Main ( 2: 3: public static void main(String[] args) ( RandomCount Display d = new RandomCount Display (new String Display Impl("Hello, Japan.")); d.randomDisplay (10); 4: 5: } 6: )

Fig.A9-1 実行例1 (4回繰り返し。 実行するたびに異なる場合がある)

|Hello, Japan. | |Hello, Japan. | |Hello, Japan. | |Hello, Japan. |

Fig.A9-2 実行例2 (8回繰り返し)

|Hello, Japan. | |Hello, Japan. | |Hello, Japan. | |Hello, Japan. | |Hello, Japan. | |Hello, Japan. | |Hello, Japan. | |Hello, Japan. |

429

430 付録

Fig-A9-3 実行例3 (0回繰り返し)

クラス図は、 Fig.A9-4のようになります。

Fig-A9-4 RandomCountDisplay を追加したクラス図

impl open print close display Display DisplayImpl rawOpen rawPrint rawClose Count Display StringDisplayImpl multiDisplay rawOpen rawPrint rawClose RandomCountDisplay randomDisplay

問題9-2の解答

(問題はp.144)

これは「実装のクラス階層」 への追加になります。 Display Imp1クラスのサブクラスと してFileDisplay Imp1クラスを作りました。

List A9-3のFileDisplay Imp1クラスでは、ただ表示するだけではつまらないので、少 し飾りをつけました。

List A9-4のMainクラスでは、CountDisplayクラスとFileDisplay Implクラスを使っ て star.txtファイル (List A9-5) を3回表示させています。

付録A 練習問題の解答 431

前問の RandomCountDisplay と FileDisplay Impl を使えば、ファイルをランダムな回 数表示できます。

List A9-3 FileDisplayImpl 57 (FileDisplayImpl.java)

1: import java.io.IOException;

2: import java.nio.file.Piles; 3: import java.nio.file.Path; 4: 5: public class FileDisplay Impl extends DisplayImpl{ 6: 7: private String filename; public FileDisplay Impl (String filename) ( this.filename filename; @Override public void rawOpen () { // 飾り枠 System.out.println("=-=-=-=-=-= 8: 9: 10: } 11: 12: 13: 14: 15: 16: ) 17: 18: 19: 20: 21: 22: 23: 24: 25: 26: 27: 28: 29: 30313233+filename + =-=-=-=-="); @Override public void rawPrint () { try ( for (String line: Files.readAllLines (Path. of (filename))) { } System.out.print(">"); System.out.println(line); } catch (IOException e) ( e.printStackTrace();

: : : : 34: ) 35: ) @Override public void rawClose() ( // 飾り枠 System.out.println("=-=-=-=-=-= *);

M

List A9-4 Main クラス (Main.java)

1: public class Main ( public static void main(String[] args){ 2: 3: 4: 5: } 6: ) CountDisplay d = new CountDisplay (new FileDisplayImpl("star.txt")); d.multiDisplay (3);

List A9-5 表示用テキストファイル (star.txt)

Twinkle, twinkle, little star, How I wonder what you are.

Fig.A9-5 実行結果

=-=-=-=-=-= star.txt =-=-=-=-=-= > Twinkle, twinkle, little star. > How I wonder what you are. > Twinkle, twinkle, little star, > How I wonder what you are. > Twinkle, twinkle, little star, > How I wonder what you are. -----

クラス図は、 Fig.A9-6のようになります。

問題9-3の解答

(問題はp.144 )

問題では、機能の追加と実装の追加を1つのクラスで同時に行おうとしていました。 し かし、 追加する内容を、 まずは機能と実装とに分離して別のクラスとし、片方は機能のク ラス階層に入れ、他方は実装のクラス階層に入れると、 Bridge パターンにぴったり収まり ます。 しかも、そのようにすると、 追加した実装は他のクラス (Count Display や Random CountDisplay) からも使えますし、 追加した機能は他のクラス (StringDisplay Implや FileDisplayImpl) 上でも動作します。

432

付録A 練習問題の解答

Fig.A9-6 FileDisplayImpl

impl open print close display Display DisplayImpl rawOpen rawPrint rawClose CountDisplay StringDisplay Impl multiDisplay rawOpen rawPrint rawClose RandomCountDisplay FileDisplayImpl rawOpen rawPrint rawClose

randomDisplay

問題文のような模様を作るクラスを次の2つのクラスに分離します。

IncreaseDisplay 757 (List A9-6). だんだん回数を増やして表示するという 「機能」を表すクラス

CharDisplayImpl 57 (List A9-7).

・文字で表示するという「実装」を表すクラス

List A9-6 IncreaseDisplay 2 (IncreaseDisplay.java)

1: public class IncreaseDisplay extends CountDisplay ( 2: private int step: // public IncreaseDisplay (Display Impl impl, int step) ( super (impl); 3: 4: 5: 6: 7: } 8: 9: 10: 11: 12: 13: 14: this.step step; public void increase Display (int level) ( int count = 0; for (int i=0; i<level; i++) ( multiDisplay (count); count step;

433

434 | 付绿

15:

List A9-7 CharDisplayImpl 57 (CharDisplayImpl.java)

16: }

1: public class CharDisplay Impl extends DisplayImpl {

private char head;

private char body;

private char foot;

4:

3:

public CharDisplayImpl (char head, char body, char foot) (

5:

6:

this.head = head;

7:

this.body

this.foot foot;

9:

8:

body;

10:

11:

@Override

public void rawOpen () {

1: public class Main (

2: public static void main(String[] args) ( 3: 4: 5: dl.increaseDisplay (4); Increase Display d1 = new IncreaseDisplay (new CharDisplayImpl('<', '**'>'), 11Increase Display d2 = new Increase Display (new CharDisplayImpl('', "), 216: d2.increaseDisplay (6);

7:

12:

13:

System.out.print (head);

14:

15:

}

@Override

16:

17:

public void rawPrint () {

18:

System.out.print(body);

19:

}

20:

21:

22: 23: @Override public void rawClose() ( 24: System.out.println(foot); 25: 26: }

List A9-8 Main 5 (Main.java)

8: )

: :

2:

問題の解答

Fig.A9-7 実行結果

|-

クラス図は、 Fig-A9-8のようになります。 このクラス図には、サンプルプログラムに登場 したクラスと練習問題に登場したクラスをすべて含めてあります。 左側にある機能のクラ ス階層、 右側にある実装のクラス階層、そして両者をつなぐ委譲のブリッジが見えますか。

Fig.A9-8 IncreaseDisplay と CharDisplaylmp! とを追加したクラス図

Display impl open print close display DisplayImpl rawOpen rawPrint rawClose Count Display multiDisplay StringDisplayImpl FileDisplay Impl CharDisplayImpl rawOpen rawPrint rawOpen rawClose rawPrint rawClose rawOpen rawPrint rawClose IncreaseDisplay RandomCountDisplay increaseDisplay randomDisplay

第10章

| 問題 10-1の解答

(問題はp. 160 )

List A10-1のとおりです。 でたらめに次の手を出すので、 studyは空になっています。

435

436 M

List A10-1 RandomStrategy 52 (RandomStrategy.java)

1: import java.util.Random; 2: 3: public class RandomStrategy implements Strategy ( 4: 5: private Random random; public RandomStrategy (int seed) ( random new Random (seed); @Override public void study (boolean win) { 6: 7: 8: 9: 10: 11: 12: } 13: 14: 15: 16: 17: 18: ) @Override public Hand nextHand() { ) return Hand.getHand (random.nextInt(3));

List A10-2 Main 57 (Main.java)

1: public class Main (

public static void main(String[] args) (

2:

if (args.length != 2) {

3:

4:

5:

System.out.println("Usage: java Main randomseed1 randomseed2"); System.out.println("Example: java Main 314 15");

System.exit(0);

6:

7:

int seedl = Integer.parseInt(args[0]);

int seed2

Integer.parseInt(args[1]);

8:

9:

10:

11:

12:

Player player new Player ("Taro", new ProbStrategy (seed1)); Player player2 = new Player ("Hana", new RandomStrategy (seed2)); for (int i=0; i <10000; i++) {

13:

14:

Hand nextHandl player1.nextHand();

15:

Hand nextHand2

if (nextHandl.isStronger Than (next Hand2)) {

16:

System.out.println("Winner: +player1);

17:

playerl.win();

player2.lose();

18:

19:

20:

player2.nextHand();

} else if (nextHand2.isStronger Than (nextHandl)) {

System.out.println("Winner:

player1.lose();

player2.win();

player2);

21:

22:

}

=

付録A 練習の解答

System.out.println("Even..."); player1.even(); player2.even(); } else { } ) System.out.println("Total result:"); System.out.println (player1.toString()); System.out.println (player2.toString());

23:

24:

25:

26:

27:

29:

28:

30:

31:

32:

33:

問題10-2の解答

(問題はp.160 )

Hand型のインスタンス (enum定数) は、もともと (ROCK, SCISSORS, PAPERの) 3つ しか存在しないことが保証されているからです。 handvalue フィールドの値が等しい2つ のインスタンスがあったら、 実は、それらは同じインスタンスなのです。

問題10-3の解答

(問題はp.160 )

Javaでは、明示的に初期化されていないフィールドは、 自動的に初期化されるからです。 boolean 型のフィールドはfalse で初期化されます。 数は0、 参照型はnullで初期化され ます。

注意 フィールドは初期化されますが、局所変数 (ローカル変数) は初期化されません。

問題10-4の解答

(問題はp. 161 )

「無名クラス」 を用いた解答と 「ラムダ式」 を用いた解答の2つを示します。 List A10-3は 「無名クラス」 を用いた解答です。

sortメソッドの引数として与えるのは java.util.Comparator <String> インタフェー スのインスタンスになります。 Comparator <String>インタフェースを実装 (implements) し たクラスを宣言し、そのクラスのインスタンスをnewによって作るのが一般的ですが、次 のようにインタフェースから直接インスタンスを作ることもできます。

437

438 付録

new Comparator <String>() { public int compare (String a, String b){ return a.compareTo (b); }

この式の中で、 抽象メソッドである compare の実体が定義されていることに注意してく ださい。 Javaのコンパイラはこの式を元にして、 名前が表面に出てこない無名クラス(匿 名クラス) を作り、 そのクラスのインスタンスを生成してくれるのです。

a.compareTo (b) で使われている compareTo は Stringのインスタンスメソッドで、 aとb の順序関係を得るものです。 辞書式順序でa<bなら負の値 a bなら正の値、 aとbが等 しいなら0が戻り値となります (そしてこれはcompareメソッドが期待する戻り値に一致 します)。 b.compareTo(a)のようにaとbを入れ換えれば辞書式順序の逆順になります。

List A10-3 無名クラスを用いたプログラム (Main.java)

1: import java.util.*; 2: 3: class Main ( public static void main(String[] args) { List<String> list = Arrays.asList"", "B", "C", "E"// 辞書式順序で小さい順 list.sort (new Comparator <String>()( public int compare (String a, String b) ( 4: 5: 6: 7: 8: 9: 10: 11: } 12: 13: 14: 15: 16: 17: 18: 19: } 20: }); 21: return a.compareTo (b); System.out.println(list); // 辞書式順序で大きい順 list.sort (new Comparator<String>() { public int compare (String a, String b) ( return b.compareTo(a); System.out.println(list); 22: 23: )

, "A");

さて、 List A10-4 は 「ラムダ式」 を用いた解答です。 これはList A10-3とまったく同じ 動作をしますが、ずっとシンプルになります。

付録A 問題の解答 439

java.util.Comparator <String> は、 compare という唯一の抽象メソッドを持つイン タフェースですから、 Javaの関数型インタフェース (functional interface) の一種です。 関数型インタフェースのインスタンスは、 List A10-4にあるように、

(a, b) ->a.compareTo(b)

のようなラムダ式によって生成することができます。 List A10-3の無名クラスの書き方と 比較すると、(a, b) の部分が引数に当たり、a.compareTo (b) の部分がメソッドの本体に 当たることがわかるでしょう。 ラムダ式によって 「引数a, bを比較する関数」という抽象 的な概念を簡潔に表現でき、与えるラムダ式に応じてソートの順序を変えることができる のです。

List A10-4 ラムダ式を用いたプログラム (Main.java)

1: import java.util.*; 2: 3: class Main ( 4: 5: 6: 7: 8: 9: 10: 11: 12: 13: 14: 15: ) public static void main(String[] args){ ) List<String> list = Arrays.asList("D", "B", "C", "E", "A"); // 辞書式順序で小さい順 list.sort((a, b) ->a.compareTo(b)); System.out.println(list); // 辞書式順序で大きい順 list.sort((a, b) -> b.compareTo(a)); System.out.println(list);

第11章

| 問題11-1 の解答

(問題はp.176)

例えば、HTMLのリスト (ul 要素, ol 要素 dl 要素) やテーブルなどはCompositeバ ターンとして表現することができます。

440 付録

問題11-2の解答

(問題はp.176 )

いろいろやり方はありますが、ここでは Entryクラスにparent フィールド (このイン スタンスを持っているDirectoryのインスタンス) を持たせてみましょう。 ルートディレ クトリ (最上位のディレクトリ)は、このparent フィールドがnu11になることとします。 与えられたインスタンスからparent フィールドを上向きにたどっていって、フルパスを 構成します。 修正するのはEntryクラスとDirectoryクラスです。 Directoryクラスでは addメソッドの中でsetParentメソッドを呼び出します。

List A11-1 変更した Entry クラス (Entry.java)

1: public abstract class Entry (

private Entry parent;

3:

2:

4:

// 親を設定する

protected void setParent (Entry parent) (

5:

6:

this.parent parent;

7:

8:

// 名前を得る

public abstract String getName();

10:

// サイズを得る

11:

12:

public abstract int getSize();

13:

14:

// 一覧を表示する

16:

public void printList() (

printList (**);

15:

17:

18:

protected abstract void printList (String prefix);

19:

// prefixを前につけて一覧を表示する

20:

21:

22:

23: 24: @Override // 文字列表現 public String toString() { return getName() + " ( + getSize() + ")"; ) // フルバスを得る public String getFullName()( StringBuilder fullname = new StringBuilder(); Entry entry = this; do (

29:

28:

30:

26:

27:

31:

32:

33:

25:

9:

付録A 練習問題の解答 441

fullname.insert (0, entry.getName());

36: ཚ་

34:

35:

ཤྩ ུ 37: 38: 39: 40

fullname.insert(0, "/");

entry entry.parent;

: )

while (entry != null);

return fullname.toString();

)

List A11-2 : Directory 757 (Directory.java)

1: import java.util.ArrayList;

2: import java.util.List;

3:

4: public class Directory extends Entry (

private String name;

6:

private List<Entry> directory = new ArrayList<>();

public Directory (String name) {

5:

7:

this.name name;

}

10:

11:

@Override

public String getName() {

12:

return name;

}

9:

13:

14:

15:

16:

17:

@Override

18:

public int getSize() {

19: 20:

for (Entry entry: directory) (

entry.getSize();

21:

int size = 0;

size +

8:

22:

23: 24:

return size;

}

25:

27:

26:

28:

@Override protected void printList (String prefix) ( System.out.println(prefix +/+ this); for (Entry entry: directory) ( entry.printList (prefix +/+name);

29:

30:

31:

32:

public Entry add (Entry entry) ( directory.add (entry);

33:

34:

35:

36:

37: 38:

entry.setParent (this); return this;

39: )

List A11-3 Main 5 (Main.java)

1: public class Main ( public static void main(String[] args) { Directory rootdir = new Directory ("root"); 2: 3: 4: 5: 6: 7: 8: 9: 10: 11: 12: 13: 14: 15: 16: 17: 18: ) 19: ) Directory usrdir = new Directory ("usr"); rootdir.add(usrdir); Directory yuki new Directory ("yuki"); usrdir.add(yuki); File file new File("Composite.java*,100); yuki.add(file); rootdir.printList(); System.out.println(); System.out.println("file = file.getFullName()); System.out.println("yuki = + yuki.getFullName());

Fig.A11-1

/root (100) /root/usr (100) /root/usr/yuki (100) /root/usr/yuki/Composite.java (100)

file /root/usr/yuki/Composite.java yuki /root/usr/yuki

)

442

付録の解答 443

第12章

| 問題 12-1 の解答

解答は以下のようになります。

(問題はp.196 )

List A12-1 UpDownBorder >> (UpDownBorder.java)

1: public class UpDownBorder extends Border (

2:

private char borderChar; //X

4:

3:

// 中身となるDisplayと飾り文字を指定

public UpDownBorder (Display display, char ch) ( super (display);

6:

7:

this.borderChar = ch;

8:

}

@Override

public int getColumns () (

// 文字数は中身の文字数に同じ

13:

return display.getColumns();

14:

15:

16:

@Override

public int getRows() {

17:

18:

// 行数は中身の上下に飾り文字分を加えたもの return 1 display.getRows() + 1;

19:

20:

11:

)

21:

9:

@Override public String getRowText (int row) ( if (row 0 || row = getRows() - 1) ( // 最上行と最下行は飾り文字だけの行 return makeLine (borderChar, getColumns()); ) else ( // 中身の行 (最上行の分だけ行番号を減らす) return display.getRowText (row - 1);

12:

22:

10:

23:

24:

25:

26:

27:

28:

29:

30:

31:

32:

33:

// 文字chを count個連続させた文字列を作る private String makeLine (char ch, int count) ( StringBuilder line new StringBuilder();

34:

)

35:

5:

444 M

36: for (int i=0; i < count; i++) { 37: line.append(ch); 38: 39: return line.toString(); 40: 41: )

問題12-2の解答

(問題はp.197 )

解答は以下のようになります。 updatePaddingメソッドでは、幅を一定にするために、 文字列の最後に空白を追加しています。 また、 spacesメソッドは、 java.lang.Stringク ラスのrepeatメソッドを使っても実現できます。

List A12-2 MultiString Display 57 (MultiString Display.java)

1: import java.util.ArrayList;

2: import java.util.List;

3:

4: public class MultiString Display extends Display (

// 表示文字列の格納場所

private List<String> body = new ArrayList<>(); // 表示文字列の最大文字数

// 文字列追加

11:

12:

13:

5:

7:

6:

8:

private int columns = 0;

9:

10:

public void add (String msg) {

body.add(msg);

14:

if (columns <msg.length()) { //最大文字数を更新 columns msg.length();

15:

16:

updatePadding();

17:

18:

}

19:

20:

21:

@Override

public int getColumns() {

return columns;

22:

23:

24:

@Override public int getRows() { return body.size();

25:

}

26:

27:

付録A 練習問題の解答

28:

@Override public String getRowText (int row) ( return body.get(row); }

29: 30:

31:

32:

33:

34:

35:

37:

// 表示文字列の右端に詰める空白を必要に応じて増やす private void updatePadding () ( for (int row 0; row <body.size(); row++) { String line body.get(row); int padding columns line.length(); if (padding > 0) { body.set (row, line spaces (padding));

38:

39:

40:

41:

42:

43:

44:

45:

// count 個の空白を作る private String spaces (int count) { StringBuilder spaces new StringBuilder(); for (int i=0; i < count; i++) { }) spaces.append(' '); return spaces.toString(); } )

46:

47:

52:

53:

54:

3: import java.util.List;

48:

49:

50:

51:

第13章

問題13-1の解答

List A13-1050. File.java (List 13-4) Directory.java (List 13-5) 正は不要です。

(問題はp. 216 )

List A13-1 FileFindVisitor 52 (FileFindVisitor.java)

1: import java.util.ArrayList;

2: import java.util.Iterator;

4:

36:

445

446

5: public class FileFindVisitor extends Visitor ( 6: 7: 8: private String filetype; private List<File> foundFiles = new ArrayList<>(); // *.txt"のように拡張子を付きで指定 public FileFindVisitor (String filetype) ( this.filetype = filetype; // 見つかったファイルを得る public Iterable<File> get Found Files() { return foundFiles; 9: 10: 11: 12: ) 13: 14: 15: 16: 17: J 18: 19: 20: 21: 22: 23: } 24: 25: 26: 27: 28: 29: 30: ) 31: } 32: ) @Override public void visit (File file) ( if (file.getName().endsWith(filetype)) ( foundFiles.add(file); @Override public void visit (Directory directory) { for (Entry entry: directory) ( entry.accept(this);

問題13-2の解答

List A13-2, List A13-3のようになります。 実行結果は Directoryクラスの書き換え前 (Fig.13-2)と同じです。

List A13-2 Directory 757 (Directory.java)

(問題はp.217)

1: import java.util.ArrayList; 2: import java.util.Iterator; 3: import java.util.List; 4: 5: public class Directory extends Entry implements Iterable<Entry> { 6: private String name; 7: private List<Entry> directory new ArrayList<>();

8:

AM 447

9:

public Directory (String name) { this.name name; }

10:

11:

12:

@Override public String getName() return name; )

13:

14:

15:

16:

17:

()

@Override public int getSize() ( SizeVisitor v new SizeVisitor (); accept (v); return v.getSize(); }

23:

18:

20:

19:

21:

22:

public Entry add (Entry entry) {

24:

25:

26:

directory.add(entry);

return this;

27:

28:

}

30: 31: 32: 33: } 34: 35: 36: 37: @Override public Iterator<Entry> iterator() { return directory.iterator(); @Override public void accept (Visitor v) { v.visit(this); 38: 39: ) }

29:

List A13-3 SizeVisitor 5x (SizeVisitor.java)

1: public class SizeVisitor extends Visitor ( private int size = 0; public int getSize() ( 2: 3: 4: 5: 6: ) 7: 8: 9: 10: return size; @Override public void visit (File file) ( size file.getSize();

448 付解

11: ) 12: 13: 14: 15: 16: 17: 18: 19: ) @Override public void visit (Directory directory) ( for (Entry entry: directory) { entry.accept(this); )

問題13-3の解答

(問題はp.217 )

List A13-4. import, extends, @Override, public кO) 引数や戻り値などを補いました。

List A13-4 Main.java

1: import java.io.IOException; 2: import java.nio.file.PileVisitResult; 3: import java.nio.file.Files; 4: import java.nio.file.Path; 5: import java.nio.file. SimpleFileVisitor; 6: import java.nio.file.attribute. BasicFileAttributes; 7: 8: class MyFileVisitor extends SimpleFileVisitor<Path> { @Override public FileVisitResult preVisit Directory (Path dir, BasicFileAttributes attrs) throws IOException { System.out.println("dir: +dir); 9: 10: 11: 12: 13: 14: } 15: 16: 17: 18: 19: 20: 21: 22: 23: return FileVisitResult. CONTINUE; @Override public FileVisitResult visitFile (Path file, BasicFileAttributes attrs) throws IOException ( System.out.println("file: +file); return FileVisitResult. CONTINUE; 24: public class Main ( 25: 26: public static void main(String[] args) ( if (args.length != 1) {

27:

付録A 練習問題の解答 449

28:

System.out.println("Example: java Main.");

System.exit(0);

29:

30:

31:

System.out.println("Usage: java Main dirname");

32:

String dirname = args[0];

33:

34: try { 35: 36: 37: 38: 39: 40: ) 41: 42: ) MyFileVisitor visitor = new MyFileVisitor(); Path root = Path.of (dirname); Files.walkFileTree (root, visitor); ) catch (IOException e) { e.printStackTrace();

別解です。 List A13-5は同じ動作をするプログラムですが、 MyFileVisitor クラスを Mainクラスのstaticなメンバークラスとして宣言しています。

List A13-5 Main.java

1: import java.io.IOException;

2: import java.nio.file. FileVisitResult;

3: import java.nio.file.Files;

4: import java.nio.file.Path;

5: import java.nio.file. SimpleFileVisitor;

: import java.nio.file.attribute. BasicFileAttributes;

67: 8: public class Main ( static class MyFileVisitor extends SimpleFileVisitor<Path>{ @Override public FileVisitResult preVisitDirectory (Path dir. 9: 10: 11: 12: 13: 14: 15: ) 16: 17: 18: 19: 20: 21: 22: 23: BasicFileAttributes attrs) throws IOException ( System.out.println("dir: +dir); return FileVisitResult. CONTINUE: @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException ( System.out.println("file: file); return PileVisitResult. CONTINUE;

}

450 M

public static void main(String[] args) ( if (args.length != 1) { System.out.println("Usage: java Main dirname"); System.out.println("Example: java Main."); System.exit(0); String dirname args[0]; 24: 25: 26: 27: 28: 29: 30: 31: 32: 33: 34: try { 35: 36: 37: 38: 39: 40: ) 41: 42: ) MyFileVisitor visitor = new MyFileVisitor(); Path root Path. of (dirname); Files.walkFileTree (root, visitor); } catch (IOException e) { e.printStackTrace();

さらに別解です。 List A13-6も同じ動作をするプログラムですが、 処理を行うクラスを 無名クラス (匿名クラス)として宣言しています。

List A13-6 Main.java

1: import java.io.IOException; 2: import java.nio.file. FileVisitResult; 3: import java.nio.file.Files; 4: import java.nio.file.Path; 5: import java.nio.file.FileVisitor; 6: import java.nio.file. SimpleFileVisitor; 7: import java.nio.file.attribute. BasicFileAttributes; 8: 9: public class Main ( public static void main(String[] args) { if (args.length != 1) { System.out.println("Usage: java Main dirnameSystem.out.println("Example: java Main ."); System.exit(0); 10: 11: 12: 13: 14: 15: } 16:

String dirname args[0];

");

17:

try (

18:

19:

20:

付録A 練習の解答

21:

23:

24:

26:

27:

28:

29:

30:

31:

32:

FileVisitor <Path> visitor = new SimpleFileVisitor<>() @Override public FileVisitResult preVisitDirectory (Path dir, BasicFileAttributes attrs) throws IOException ( System.out.println("dir: dir); return FileVisitResult. CONTINUE; } @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { System.out.println("file: file); return FileVisitResult. CONTINUE; ): Path root = Path. of (dirname);

33:

34:

35:

36:

37:

38:

Files.walkFileTree (root, visitor);

} catch (IOException e){

39:

40:

e.printStackTrace();

41:

42: )

問題13-4の解答

問題はp.219)

implements Iterable<Entry を削除すると、 2つの問題が発生します。 1つ目は、 Directoryクラスのiteratorメソッドに付加されている @Override アノテ ーションでコンパイルエラーになることです。 このメソッドは、 Iterableインタフェー スで宣言されているメソッドを実装したものであり、それを明示的に表現するため @Override アノテーションが付加されているからです。

2つ目は、 ListVisitorクラス (List 13-6) のvisit (Directory) メソッド中にある、

for (Entry entry: directory) ( entry.accept(this); }

という拡張for文でコンパイルエラーになることです。 拡張for文は、配列または Iterableインタフェースに対する繰り返し処理を行うものだからです。 拡張for文につ いてはp.10も参照してください。

22:

この問題13-4は、 @Override アノテーションがメソッドの位置付けを明確にしてくれ

25:

451

452 M

ることと、拡張for文を使いたいクラスではIterableインタフェースを実装することを 再確認するために出題しました。

第14章

問題14-1の解答

(問題はp.234)

コンポーネントが載っている親コンポーネント (親ウインドウ、 コンテナ) が 「next」 になる場合が多いでしょう。 コンポーネントに渡されてきたイベント (要求) は、そのコ ンポーネントで処理しないとき、順次親コンポーネントに渡されます。

問題14-2の解答

(問題はp.234)

Supportクラスのインスタンスに対して、他のクラスから 「トラブル解決」 を依頼する ときには、 resolveメソッドではなくsupportメソッドを使ってほしい、という意図が表 現されています。

resolveメソッドがpublicになっていると、 Support クラスとは無関係なクラスから もresolve がいきなり呼び出せてしまいます。 そうすると、 resolve メソッドがSupport クラスで期待しているのとは異なる使い方をされてしまう危険性があります。

また、resolveメソッドがpublicになっていると、 resolveメソッドの名前やシグニ チャを将来変更した場合、 修正すべき対象がプログラムのあちこちに散らばってしまうこ とになります。

[注意] Javaでは、 protectedな名前はサブクラスから見えるだけではなく、 同じパッケージのク ラスからも見えます。 ですから、 サンプルプログラムのように1つのパッケージの中で使ってい る間は、public でもprotectedでも違いはありません (サンプルプログラムのクラスは、すべ て無名パッケージの中にあります)。 しかし将来、 特定のパッケージにクラスを移行するときに、 protected が効果を発揮します。

Javaにはまた、複数のパッケージをまとめるモジュール (module) という仕組みもあります。 どのクラスやメソッドを誰に見せるかは、一般にアクセス制御 (access control) と呼ばれ、 パッ アクセス コントロール ケージやモジュールと深い関係にあります。 アクセス制御を理解することは、 巨大なシステムを 構築する際に特に重要です。

問題の解答 453

| 問題14-3の解答

さまざまな書き方がありますが、 例えばList A14-1のようになります。

(問題はp.234 )

List A14-1 : Support 57 (Support.java) 1: public abstract class Support ( private String name; // このトラブル解決者の名前 2: 3: 4: 5: 6: 7: private Support next; // 50% public Support (String name) ( 8: ) this.name name: this.next null; 9: 10: 11: // たらい回しの先を設定する public Support setNext (Support next) ( this.next next; return next; 12: 13: 14: ) 15: 16: 17: 18: 19: 20: 21: 22: 23: 24: 25: 26: 27: 28: // トラブル解決の手順を定める public void support (Trouble trouble) ( for (Support obj = this; true; obj = obj.next) { if (obj.resolve(trouble)) { obj.done (trouble); break; } else if (obj.next == null) ( obj.fail (trouble); break; 29: 30: 31: @Override public String toString() ( return name + "]";

32:

)

33:

34:

// 解決しようとする

35:

protected abstract boolean resolve (Trouble trouble);

// 解決した protected void done (Trouble trouble) { System.out.println(trouble is resolved by this *."); +

36:

37:

38:

39:

454 M

40:

// 解決しなかった protected void fail (Trouble trouble) ( System.out.println(trouble + cannot be resolved."); 41: 42: 43: 44: 45: } 46: )

第15章

問題15-1の解答

(問題はp.246)

Database クラス List 15-1) とHtmlWriterクラス (List 15-3) の定義を、次のように public なしにします。 これで、 DatabaseクラスとHtmlWriterクラスの名前は、 pagemaker パッケージの外から参照できなくなります (メソッドについているpublic は 削除しなくてもかまいません)。

●変更前

▶变更後

Database クラス public class Database ( class Database ( } HtmlWriter クラス |public class HtmlWriter { ) ) class HtmlWriter ( }

Javaのパッケージはクラスやインタフェースなどをまとめる仕組みですが、 さらに複数 のパッケージをまとめるモジュール (module) という仕組みもあります。 モジュールを 使うと、どのパッケージをモジュール外からアクセス可能にするかをコントロールできま す。

題の解答 455

| 問題15-2の解答

(問題はp.246 )

解答はList A15-1のようになります。

List A15-1 PageMaker 52 (PageMaker.java)

1: package pagemaker;

2:

3: import java.io.FileWriter;

4: import java.io.IOException;

5: import java.util.Properties; 6:

7: public class PageMaker (

private PageMaker () (

public static void makeWelcome Page (String mailaddr, String filename) { try ( 9: }) 10: 11: 12: 13: 14: 15: 16: 17: 18: 19: 20: 21: Properties mailprop Database.getProperties ("maildata"); String username mailprop.getProperty(mailaddr); HtmlWriter writer = new Html Writer (new FileWriter (filename)); writer.title(username 's web page'); writer.paragraph ("Welcome to + username's web page!"); writer.paragraph ("Nice to meet you!"); writer.mailto (mailaddr, username); writer.close(); System.out.println(filename is created for " +mailaddr + (+ username + ")"); catch (IOException e) { e.printStackTrace(); public static void makeLinkPage (String filename) ( 22: 23: 24: ) 25: 26: 27:

28:

29:

30:

8:

try ( Html Writer writer = new HtmlWriter (new FileWriter (filename)); writer.title("Link page"); ) Properties mailprop Database.getProperties ("maildata"); for (String mailaddr: mailprop.stringPropertyNames () ) { String username mailprop.get Property (mailaddr, "(unknown)"); writer.mailto (mailaddr, username); writer.close(); System.out.println(filename is created."); } catch (IOException e) {

31:

32:

33:

35:

34:

36:

37:

38:

456 M

39:

e.printStackTrace();

40:

42: )

問題15-3の解答

実行結果はFig.A15-1のようになります。

(問題はp.247)

41:

Fig.A15-1

<!DOCTYPE html> <html> <head> <title>Welcome!</title> </head> <body> <h1 style="text-align: center">Hello, world!</h1> </body> </html>

ちなみに、 文字列中にs などの制御文字列を含め、 java.lang.Stringクラスの formattedメソッドを使うと、 List A15-2のように変数 title, message の内容を埋め込 むことができます(List A15-2の実行結果はFig.A15-1と同じです)。

List A15-2 formatted (Main.java)

2: 3: 4: 5: 1: public class Main ( public static void main(String[] args) { String title "Welcome!"; String message "Hello, world!"; String html = ... 6: <!DOCTYPE html> 7: <html> 8: <head> 9: <title></title> 10: </head> 11: <body> 12: <h1 style="text-align: center">%s

</h1>

13:

付録A 練習問題の解

14:

</body>

15:

.formatted (title, message);

16:

</html>

17:

18: )

System.out.print (html);

)

第16章

問題16-1の解答

if (textUser.getText().length() >= 4 && textPass.getText().length() >= 4) (

他のクラスはまったく修正する必要がありません。

Fig.A16-1 パスワードが3文字のときは、まだOKボタンは押せない

Mediator Sample Guest Username: O Login Yuki Password: OK Cancel

| Fig.A16-2 パスワードが4文字になると、OK ボタンが押せる

Mediator Sample Guest O Login Username: Yuki Password: OK Cancel

457

LoginFrameクラス (List 16-6) の userpassChangedメソッドを次のように修正します。 if (textPass.getText().length() > 0) {

(問題はp. 267 )

List A16-1 LoginFrame 57 (LoginFrame.java)

1: import java.awt.CheckboxGroup; 2: import java.awt.Color; 3: import java.awt.Frame; 4: import java.awt.GridLayout; 5: import java.awt.Label; 6: import java.awt.event.ActionEvent; 7: import java.awt.event.ActionListener; 8: 9: public class LoginFrame extends Frame implements ActionListener, Mediator ( 10: 11: 12: private ColleagueCheckbox checkGuest; private ColleagueCheckbox checkLogin; private ColleagueTextField textUser; 13: private ColleagueTextField textPass; private ColleagueButton buttonOk; private ColleagueButton buttonCancel; 14: 15:

16:

17:

// Colleague たちを生成し、配置後に表示する public LoginFrame (String title) (

19:

18:

super (title);

20:

// 背景色を設定する

21:

22:

setBackground (Color.lightGray);

23:

24:

25:

// レイアウトマネージャを使って4×2のグリッドを作る setLayout (new GridLayout (4, 2));

26:

27:

28:

// Colleague たちを生成する createColleagues();

29:

// 配置する add (checkGuest); add(checkLogin); add(new Label ("Username:")); 30: 31: 32: 33: 34: 35: 36: 37: add (buttonOk); 38: add(textUser); add (new Label ("Password: ")); add (textPass); add (buttonCancel);

39:

40: // 有効/無効の初期指定をする colleagueChanged();

41:

42:

43:

// 表示する pack(); setVisible(true);

44:

45:

458

46:

HA

47:

}

50:

// Colleague たちを生成する @Override public void createColleagues () { // CheckBox CheckboxGroup g = new CheckboxGroup(); checkGuest new ColleagueCheckbox ("Guest", g, true); checkLogin new ColleagueCheckbox ("Login". g. false);

52:

54:

55:

57:

// TextField textUser new ColleagueTextField("", 10); text Pass new ColleagueTextField("*, 10); text Pass.setEchoChar (*);

58:

59:

60:

// Button buttonOk new ColleagueButton("OK"); buttonCancel = new ColleagueButton("Cancel");

61:

69:

70:

71:

72:

64:

66:

// Mediator を設定する checkGuest.setMediator (this); checkLogin.setMediator (this); textUser.setMediator(this); text Pass.setMediator (this); buttonOk.setMediator (this); buttonCancel.setMediator (this);

73:

74:

75:

// Listener のセット checkGuest.addItemListener (checkGuest); checkLogin.addItemListener (checkLogin); textUser.addTextListener (textUser); text Pass.addTextListener (text Pass); buttonOk.addActionListener(this); buttonCancel.addActionListener(this);

53:

76:

77:

62:

67:

78:

79:

68:

80:

81:

// Colleageの状態が変化したときに呼ばれる @Override

82:

83:

84:

85:

86:

87:

88:

89:

48:

63:

public void colleagueChanged() { if (checkGuest.getState()) ( // ゲストログイン textUser.setColleagueEnabled(false); textPass.setColleagueEnabled(false); buttonOk.setColleagueEnabled (true); ) else ( // ユーザログイン textUser.setColleagueEnabled (true);

56:

65:

90:

91:

92:

49:

459

51:

460 M

93:

userpassChanged();

94: 95:

96: 97: 98: 99: 100: 101: 102: 103: // textUser または textPass の変更があった // 各Colleageの有効/無効を判定する private void userpassChanged() ( if (textUser.getText().length() > 0) { textPass.setColleagueEnabled (true); if (textUser.getText().length() >=4&& textPass.getText().length() >= 4) ( buttonOk.setColleagueEnabled(true); 104: } else { 105: buttonOk.setColleague Enabled (false); 106: 107: } else { 108: textPass.setColleagueEnabled(false); 109: buttonOk.setColleagueEnabled(false); 110: 111: 112: 113: 114: 115: 116: @Override public void actionPerformed (ActionEvent e) { System.out.println(e.toString()); System.exit(0); 117: 118: )

第17章

問題17-1 の解答

解答はList A17-1のようになります。

問題はp.281)

List A17-1 < IncrementalNumberGenerator 52 (IncrementalNumberGenerator.java)

1: public class Incremental Number Generator extends NumberGenerator ( 2: private int number; // BE 3: private int end; // 終了値(この値を含まない) 4: private int inc; // 增加分

付録A 練習問題の解

5: 6: 7: 8: public Incremental NumberGenerator (int start, int end, int inc) ( this.number start; this. end end; 9: this.inc inc; 10: 11: 12: 13: 14: 15: // 数を取得する @Override public int getNumber () ( return number; 16: ' 17: 18: // 数を生成する 19: @Override 20: public void execute() ( 21: while (number < end) { 22: notifyObservers(); 23: number += inc; 24: ) 25: } 26: )

問題17-2の解答

(問題はp.282)

GUI を使って、円グラフ風のConcreteObserver役を作ってみました (Fig-A17-1)。 なお、ここでは3種類のConcreteObserver役が登場しますが、 実際にRandomNumber Generator から呼び出されるのは FrameObserver (List A17-2) だけです。 FrameObserver はGraphText と GraphCanvas を呼び出しています (委譲)。

Fig.A17-1 実行の様子

461

M

List A17-2 GUIT FrameObserver 5 (Frame Observer.java)

1: import java.awt.BorderLayout; 2: import java.awt.Button; 3: import java.awt.Canvas; 4: import java.awt.Color; 5: import java.awt.Frame; 6: import java.awt.Graphics; 7: import java.awt.TextField; 8: import java.awt.event.ActionEvent; 9: import java.awt.event.ActionListener; 10: 11: public class FrameObserver extends Frame implements Observer, ActionListener ( // GraphText は通知された数をテキストフィールドで表示するstaticクラス 12: static class GraphText extends TextField implements Observer { public GraphText (int columns) ( super (columns); 13: 14: 15: 16: 17: 18: 19: 20: 21: number 22: BOverride public void update (NumberGenerator generator) { int number String text generator.getNumber(); for (int i=0; i<number; i++) { :; 23: text += ***; 24: } 25: setText(text); 26: } 27: 28: 29: // GraphCanvas は通知された数を円グラフ風に表示する staticクラス

30:

31:

static class GraphCanvas extends Canvas implements Observer { private int number;

32:

33:

@Override

34:

35:

public void update (NumberGenerator generator) (

number generator.getNumber();

36:

37:

repaint();

38:

39:

public void paint (Graphics g) (

40:

int width getWidth();

41:

int height

getHeight();

42:

g.setColor(Color.white);

g.fillArc (0, 0, width, height, 0, 360);

43:

g.setColor(Color.red);

- number 360 / 50);

44:

45:

g.fillArc (0, 0, width, height, 90,

462

46:

付録A 練習問題の解答 463

47:

48:

49:

50:

private GraphText textGraph = new GraphText (60); private GraphCanvas canvasGraph = new GraphCanvas(); private Button buttonClose = new Button("Close");

51:

52:

53:

public FrameObserver () (

54:

55:

super("FrameObserver");

57:

58:

setLayout (new BorderLayout()); setBackground (Color.lightGray): textGraph.setEditable (false); canvasGraph.setSize(500, 500);

60:

add (textGraph, BorderLayout.NORTH); add (canvasGraph, BorderLayout.CENTER); add (buttonClose, BorderLayout.SOUTH);

buttonClose.addActionListener(this);

62:

63:

pack();

@Override

public void actionPerformed (ActionEvent e) { System.out.println(e.toString());

70:

64:

setVisible(true);

65:

67:

68:

69:

System.exit(0);

71:

72:

73:

74:

59:

75:

}

@Override

public void update (NumberGenerator generator) (

76:

textGraph.update (generator);

canvasGraph.update (generator);

77:

78: )

}

66:

61:

}

List A17-3 Main 757 (Main.java)

2: 3: 4: 1: public class Main ( public static void main(String[] args) ( NumberGenerator generator = new RandomNumberGenerator(); Observer observer1 new DigitObserver(); 5: Observer observer2 new GraphObserver(); 6: Observer observer3 = new Frame Observer(); 7: generator.addObserver (observer1); 8: 9: generator.addObserver (observer2); generator.addObserver (observer3);

56:

4641

10:

generator.execute():

12: )

11:

第18章

問題18-1の解答

問題はp.298)

「Caretaker役」と「Originator 役 Memento役」 との間の独立性が失われます。 もしもCaretaker 役が Memento役を自由に操作できるとすると、 Originator 役の内部に 修正が加わったときに、 Caretaker 役にも同様の修正を行わなければならなくなってしま います。

Caretaker役が狭いインタフェース (API) しか使っていないならば、そのインタフェー ス(API)に変更が及ばない限り、 Caretaker 役は修正せずに、 Originator 役および Memento役を自由に修正することができます。

問題18-2の解答

(問題はp.298 )

すでに保存されている Memento との差分を計算すれば、少ない空間でも保存できるよう になるかもしれません。あるいは、データ圧縮を行って保存するデータ量を少なくする方 法もあるでしょう。

問題18-3の解答

(問題はp.298 )

number を private なフィールドにして、値取得用のメソッドgetNumberをデフォルト のアクセス制御 (public, protected, private がつかないもの) にすることで実現で きます。

public class Memento ( private int number; int getNumber() { return number;

)

問題の解答 465

Gamer クラスがnumberの値を得る場合には、 get Numberメソッドを使います。

問題18-4の解答

List A18-1, List A18-21 Dt.

(問題はp. 298 )

9: 10: 11: 12: 13: 14: List A18-1 ファイル保存に対応した Memento クラス (Memento.java) 1: package game; 2: 3: import java.io.*; 4: import java.nio.file.*; 5: import java.util.ArrayList; 6: import java.util.List; 7: 8: public class Memento ( private int money; //所持金 private List<String> fruits; // 7- // 所持金を得る (narrow interface) public int getMoney ( ) [ return money; 15: } 16: 17: 18: 19: 20: 11392+55 (wide interface) Memento (int money) ( this.money money; this.fruits = new ArrayList<>(); 21: 22: 23: 24: 25: // フルーツを追加する (wide interface) void addFruit (String fruit) ( fruits.add(fruit); 26: ) 27: 28: 29: 30: // フルーツを得る (wide interface) List<String> get Fruits() ( return new ArrayList<> (fruits); 31: ) 32:

// ファイルに保存

33:

34:

public static boolean saveToFile(String filename, Memento momento ( StringBuilder sb new StringBuilder();

//所持金

sb.append(String.format("%d", memento. money));

35:

36:

37:

38:

464

10:

generator.execute():

11:

12: )

第18章

]

問題18-1の解答

(問題はp. 298 )

. 「Caretaker役」 と 「Originator 役 Memento役」 との間の独立性が失われます。 もしもCaretaker 役がMemento役を自由に操作できるとすると、 Originator役の内部に 修正が加わったときに、 Caretaker役にも同様の修正を行わなければならなくなってしま います。

Caretaker役が狭いインタフェース (API) しか使っていないならば、そのインタフェー ス(API)に変更が及ばない限り、 Caretaker 役は修正せずに、 Originator 役および Memento 役を自由に修正することができます。

問題18-2の解答

すでに保存されている Memento との差分を計算すれば、少ない空間でも保存できるよう になるかもしれません。あるいは、 データ圧縮を行って保存するデータ量を少なくする方 法もあるでしょう。

問題はp.298 )

問題18-3の解答

(問題はp.298 )

number を private なフィールドにして、値取得用のメソッド getNumber をデフォルト のアクセス制御 (public, protected, private がつかないもの) にすることで実現 きます。

public class Memento { private int number; int getNumber() { return number; }

A の解

Gamerクラスがnumber の値を得る場合には、 getNumber メソッドを使います。

問題18-4の解答

問題はp.298)

List A18-1, List A18-20.

List A18-1 771 Memento 292 (

1: package game;

2:

3: import java.io.*;

4: import java.nio.file.';

Memento.java)

5: import java.util.ArrayList;

6: import java.util.List;

7:

8: public class Memento (

9:

private int money;

10:

11:

private List<String> fruits; // 72-7

12:

//所持金

(narrow interface)

public int getMoney () (

13:

return money:

14:

15:

}

2999 (wide interface)

16:

o(int money) {

s.money money:

fruits new ArrayList<>();

interface)

it) (

. ⚫

465

466 M

39:

sb.append("\n");

40: 41: 42: 43: // フルーツ for (String f: memento.getFruits()) { sb.append(f); 44: sb.append("\n"); 45: } 46: 47: // 書き込み 48: try { 49: 50: Files.writeString (Path. of (filename), sb, StandardOpenOption.CREATE, 51: 52: StandardOpenOption. TRUNCATE_EXISTING, StandardOpenOption.WRITE); 53: 54: 55: 56: 57: } catch (IOException e) { System.out.println(e.toString()); return false; return true; 58: ) 59: 60: 61: 62: 63: 64: // ファイルから生成 public static Memento loadFromFile(String filename) { try { // 読み込み List<String> lines Files.readAllLines (Path. of (filename)); if (lines.size() == 0) ( System.out.println("Empty file"); return null; 65: 66: 67: 68: 69: 70: //所持金 71: int money=0; 72: try ( 73: 74: 75: 76: money Integer.parseInt(lines.get(0)); } catch (NumberFormatException e) { System.out.println("Format error: return null; + e); 77: 78: 79: 80: // 生成 Memento memento new Memento (money);

81:

// フルーツ

82:

83:

for (int i=1; i < lines.size(); i++) { memento.addFruit (lines.get(i));

84:

85: 86:

return memento;

)

* 467

87: 88: 89: 90: 91: 92: ) } catch (IOException e) { System.out.println(e.toString()); return null;

List A18-2 ファイル保存に対応したMain クラス (Main.java) 1: import game. Memento; 2: import game. Gamer; 3: 4: import java.io.*; 5: 6: public class Main ( public static final String SAVEFILENAME = "game.dat"; 7: 8: 9: public static void main(String[] args) { 10: Gamer gamer new Gamer (100); // 最初の所持金は100 11: 12: 13: 14: 15: 16: 17: 18: 19: // ファイルから読み込む Memento memento Memento.loadFromFile(SAVEFILENAME); if (memento == null) ( System.out.println(23-FL); memento gamer.createMemento(); // } else { System.out.println("前回保存した結果からスタートします。 ); gamer.restoreMemento (memento); 20: } 21: 22: // ゲームスタート 23: for (int i=0; i <100; i++) {

System.out.println("

24:

25:

27:

26:

+ i);

//回数表示

System.out.println(":" + gamer); // 現在の主人公の状態表示

// ゲームを進める

28:

29:

30:

gamer.bet();

System.out.println("

31:

32:

33:

. gamer.getMoney () +PED & LA. *):

// Memento の取り扱いの決定 if (gamer.getMoney () > memento.getMoney()) ( System.out.println(だいぶ増えたので、現在の状態を保存しておこう!* memento gamer.createMemento (); // ファイルへ書き込む if (Memento, saveToFile (SAVEFILENAME, memento) (

34:

35: 36:

37:

468 付録

System.out.println("現在の状態をファイルに保存しました。"); } else if (gamer.getMoney() < memento.getMoney() / 2) ( System.out.println("だいぶ減ったので、以前の状態を復元しよう!"); gamer.restoreMemento (memento); } // 時間待ち try { Thread.sleep(1000); } catch (InterruptedException e) { } System.out.println(); } )

38:

43:

42:

44:

45:

46:

47:

39:

40:

41:

53:

48:

49:

50:

51:

52:

第19章

問題19-1の解答

問題はp.322)

List A19-1のようになります。 SafeFrameクラス以外の修正は不要です。 サンプルプログラムとの違いは次のとおりです。

・SafeFrameクラスから ActionListener の implements宣言を削除

・SafeFrameクラスからactionPerformedメソッドを削除

・4種類のボタンに対して、 addActionListener を次のように呼び出す。

buttonUse.addActionListener (e -> state. doUse (this)); buttonAlarm.addActionListener (e -> state.doAlarm (this)); button Phone.addActionListener(e -> state.doPhone (this)); buttonExit.addActionListener (e -> System.exit(0));

引数として渡されている

estate.doUse (this)

の部分がラムダ式になります。 eはactionPerformedメソッドの引数として渡される ActionEventのインスタンスで、処理内容は->の右に書かれています。 ラムダ式を使う

付録A 練習問題の解答 469

と記述がシンプルになるのがよくわかります。

List A19-1 ラムダ式を用いてリスナーを設定したSafeFrame クラス (SafeFrame.java)

1: import java.awt. BorderLayout; 2: import java.awt.Button; 3: import java.awt.Color; 4: import java.awt. Frame; 5: import java.awt.Label; 6: import java.awt. Panel; 7: import java.awt.TextArea; 8: import java.awt.TextField;

9:

11: 12: 13: 10: public class SafeFrame extends Frame implements Context ( private TextField textClock = new TextField(60); private TextArea text Screen = new TextArea (10, 60); private Button buttonUse new Button("); private Button buttonAlarm = new Button (***); private Button buttonPhone = new Button(); private Button buttonExit = new Button("#"); 14: 15: 16:

// 現在時刻表示 // 警備センター出力 // 金庫使用ボタン // 非常ベルボタン // 通常通話ボタン

17:

// 終了ボタン

private State state DayState.getInstance();

19:

// コンストラクタ public SafeFrame (String title) { super (title); setBackground (Color.lightGray); setLayout (new BorderLayout()); // textClock add (textClock, BorderLayout.NORTH); textClock.setEditable (false); // textScreen & add (text Screen, BorderLayout.CENTER); text Screen.setEditable (false); // パネルにボタンを格納 Panel panel new Panel (); = panel.add(buttonUse); panel.add(buttonAlarm); panel.add(buttonPhone); panel.add(buttonExit); // そのパネルを配置 add (panel, BorderLayout.SOUTH);

20:

// 現在の状態

21:

22:

23:

24:

25:

26:

27:

28:

18:

35:

29:

30:

31:

32:

33:

36:

// buttonUse.addActionListener(e -> state. doUse (this)); buttonAlarm. addActionListener(e -> state.doAlarm(this));

ボタンが押されたときのリスナーをラムダ式で設定

34:

37:

39:

38:

40:

41:

42:

470 M

43:

44:

buttonPhone.addActionListener(e ->state.doPhone(this)); buttonExit.addActionListener (e -> System.exit (0));

// 表示

46:

47:

pack();

48:

49:

45:

setVisible(true);

50:

51:

52:

}

// 時刻の設定

@Override

public void setClock (int hour) (

String clockstring

String.format (BE 802d: 00", hour);

53:

54:

55:

System.out.println(clockstring);

textClock.setText(clockstring);

56:

57:

state.doClock(this, hour);

58:

59:

//状態变化

61:

60:

@Override

62:

public void changeState (State state) {

System.out.println(this.state +5 +state E. "); this.state state;

63:

66: 67: 68: 69: 70: // 整備センター警備員呼び出し @Override public void callSecurityCenter (String msg) ( text Screen.append("call! +msg + "\n"); 71: { 72: 73: 整備センター記録 74: 75: @Override public void recordLog (String msg) ( 76: text Screen.append("record +msg "\n"); 77: ) 78: )

64:

問題19-2の解答

DayState 57 (List 19-4) Night State 57 (List 19-5), doClock ドを修正する必要があります。

(問題はp.322)

65:

もしもあらかじめ SafeFrameクラス (List 197) に isDay メソッドとisNightメソッド

}

)

付録A

を作っておき、現在が昼間なのか夜間なのかを調べる手段を用意しておけば、具体的な時 刻の範囲を SafeFrameクラスの内部に閉じ込めておけます。 そのような処置をしておけば、 時刻の範囲の変更に対してSafeFrame クラスの変更だけですませることができます。

問題19-3の解答

(問題はp.323 )

ConcreteState役として、昼食時という状態を表す NoonStateクラス (List A19-2)を作 ります。 DayStateクラスとNightStateクラスのdoClock メソッドも修正する必要があり (List A19-3, A19-4!!).

List A19-2 NoonState 757 (NoonState.java)

1: public class NoonState implements State (

private static NoonState singleton new NoonState();

3:

private NoonState() {

4:

2324

2:

7:

9:

}

5:

6:

public static State getInstance() {

return singleton;

@Override public void doclock (Context context, int hour) ( if (hour 9 || 17 <= hour) ( context.changeState (NightState.getInstance()); } else if (9 <= hour && hour <12 || 13 <= hour && hour <17) ( context.changeState (DayState.getInstance()); 10: 11: 12: 13: 14: 15: 16: 17: } 18: 19: 20: 21: 22: : : 25: 26: 27: 28: ) 29: 30: 31: @Override public void doUse (Context context) { context.callSecurityCenter (**); @Override public void doAlarm (Context context) { context.callSecurityCenter (()); @Override public void do Phone (Context context) {

8:

471

472 M

32:

context.recordLog();

33:

34:

35:

36:

37:

public String toString() {

38:

39: )

@Override

return();

List A19-3 DayState 752 (DayState.java)

1: public class DayState implements State (

2:

3:

private static DayState singleton = new DayState();

private DayState() {

4:

5:

7:

public static State getInstance() {

8:

return singleton;

9:

10:

11:

@Override

public void doclock (Context context, int hour) ( if (hour 9 || 17 <= hour) {

12:

13:

14: 15:

context.changeState (NightState.getInstance()); } else if (12 <= hour && hour <13) {

context.changeState (NoonState.getInstance());

16:

17:

18:

19:

20: 8

@Override

public void doUse (Context context) {

22 33 3 8 26: 27: 28: 29: 30:

21:

context.recordLog(*());

23:

24:

}

25:

@Override

public void doAlarm (Context context) {

context.callSecurityCenter (());

@Override

31: =

public void doPhone (Context context) (

32:

context.callSecurityCenter ("RO());

6:

)

33:

34:

}

付録A

35: 36: @Override public String toString() { 37: 38: } 39: ) return "[]";

List A19-4 NightState 757 (NightState.java)

1: public class Night State implements State ( private static Night State singleton 2:

new NightState();

3: 4: 5: 6: private NightState() { } 7: 8: 9: public static State getInstance() { return singleton; 10: 11: 12: 13: 14: 15: @Override public void doclock (Context context, int hour) ( if (12 <= hour && hour < 13) ( context.changeState (NoonState.getInstance()); } else if (9 <= hour && hour < 17) ( context.changeState (DayState.getInstance()); @Override public void doUse (Context context) ( context.callSecurityCenter (":"); @Override public void doAlarm (Context context) { context.callSecurityCenter ("^()); 16: 17: } 18: 19: 20: 21: 22: 23: ) 24: 25: 26: 27:

28:

29:

}

@Override

public void do Phone (Context context) { context.recordLog ("));

30:

31:

32:

33:

@Override

34:

35:

}

public String toString() (

return "[]";

36:

37:

38:

39: )

473

474 t

(問題はp.323 )

問題19-4の解答

アージェント・ステート 非常時を表すürgentState (緊急事態) クラス (List A19-5) を導入します。 また、 DayState クラスとNightStateクラスのdoAlarm に状態遷移のコードを追加します (List A19-6, A19-7). この仕様の問題点は、いったん非常時になった後、 元の状態に復帰する手段がないこと

です。

List A19-5 UrgentState 52 (UrgentState.java)

1: public class Urgent State implements State (

private static Urgent State singleton = new UrgentState();

2:

3:

private UrgentState() {

// コンストラクタはprivate

6: 7: public static State getInstance() { 8: return singleton; 9: } 10: 11: @Override 12: 13: public void doclock (Context context, int hour) ( // 時刻設定では何も処理をしない // 時刻設定 14: 15: 16: @Override 17: public void doUse (Context context) { // 金庫使用 18: context.callSecurityCenter (J: JOB!"); 19: } 20: 21: @Override 22: public void doAlarm (Context context) { // 非常ベル 23: context.callSecurityCenter (L()); 24: } 25: 26: @Override 27: public void doPhone (Context context) { // 通常通話 28: context.callSecurityCenter (()); 29: } 30: 31: @Override 32: public String toString() ( // 文字列表現 33: return *[非常時]": 34: 35: )

// 唯一のインスタンスを得る

4:

}

5:

A

List A19-6 DayState 57 (DayState.java)

1: public class DayState implements State (

private static DayState singleton

new DayState();

2:

3:

4:

private DayState() {

5:

public static State getInstance() (

6:

7:

return singleton;

8:

12:

10:

9:

@Override

11:

13:

public void doclock (Context context, int hour) ( if (hour 9 || 17 <= hour) (

}

14:

15:

context.changeState (NightState.getInstance());

16:

@Override public void doUse (Context context) { context.recordLog ("H (5)"); }

17:

@Override

18:

public void doAlarm (Context context) {

context.callSecurityCenter (()); context.changeState (UrgentState.getInstance());

25:

27:

20:

@Override

public void do Phone (Context context) {

context.call SecurityCenter (());

32:

33:

@Override

34:

35:

36:

return ()";

37:

38: )

19:

22:

21:

23:

24:

26:

30:

28:

29:

}

31:

}

}

public String toString() (

475

M

List A19-7 NightState 757 (NightState.java) 1: public class Night State implements State ( 2: 3: 4: 5: 6: 7: private static Night State singleton private NightState() { } public static State getInstance() { return singleton; new NightState(); @Override public void doclock (Context context, int hour) { if (9 hour && hour < 17) { context.changeState (DayState.getInstance()); @Override public void doUse (Context context) { context.callSecurityCenter (*!*); 8: 9: 10: 11: 12: 13: 14: 15: } 16: 17: 18: 19: 20: 21: } 22: 23: 24: 25: 26: 27: } 28: 29: 30: 31: 32: 33: @Override public void doAlarm (Context context) { context.callSecurityCenter (()); context.changeState (UrgentState.getInstance()); @Override public void doPhone (Context context) { context.recordLog(**);

34:

35:

36:

@Override

public String toString() {

return *[夜間]':

37:

)

38: }

476

付録A の解答 477

第20章

(問題はp.340 )

問題20-1の解答

BigChar を共有しない場合には、 Big CharFactoryは使わず、 new BigCharします。 List A20-1では、プログラムを見やすくするために、 下請け用のprivate なメソッド initShared と init Unsharedを作っています。

List A20-1 BigString 757 (BigString.java)

1: public class BigString ( 2: 3: 4: // 「大きな文字」の配列 private BigChar[] bigchars; // コンストラクタ (引数なし、共有する) public BigString (String string) ( initShared (string); // コンストラクタ (引数で共有するかどうかを指定する) public BigString (String string, boolean shared) ( if (shared) ( initShared (string); } else { 5: 6: 7: 8: } 9: 10: 11: 12: 13: 14: 15: 16: ) 17: 18: initUnshared (string);

19:

) ) // 共有して初期化 private void initShared (String string) { BigCharFactory factory BigCharFactory.getInstance(); bigchars new BigChar [string.length()); for (int i=0; i < bigchars.length; i++) { bigchars[i] factory.getBigChar(string.charAt(i));

20:

22:

21:

23:

24:

25:

28: 30: // 共有ㄝ初期化 private void initUnshared (String string) ( bigchars new BigChar[string.length()); for (int i = 0; i < bigchars.length; i++) { bigchars[i] =new BigChar(string.charAt(i));

26:

27:

29:

31:

33:

32:

478 付録

34: } 35: 36: // 表示 37: 38: 39: 40: 41: 42: } public void print() ( for (BigChar be: bigchars) ( bc.print();

List A20-2 Main クラス (Main.java)

1: public class Main { public static void main(String[] args) { if (args.length == 0) { 2: 3: 4: 5: 6: 7: } 8: 9: 10: 11: 12: 13: System.out.println("Usage: java Main digits"); System.out.println("Example: java Main 1212123"); System.exit(0); BigString bs; bs = new BigString args[0], false); bs.print(); bs = new BigString (args[0], true); bs.print(); // 共有しない // 共有する 14: ) 15: )

問題20-2の解答

(問題はp.340 )

List A20-3のMainクラスでは、 "1212123 に対応したBigStringのインスタンスを配 列上に10000個確保して、 使用メモリを比較しています。 確かに、共有している方が使用 メモリ量がずっと少ないのがわかります。

また、プログラムを実行してみると、共有しない場合の方が実行速度が遅いこともわか るでしょう。これは、共有しない場合には、 BigCharのインスタンスを作るごとにファイ ルを読み込んでいるからです。

付録A 練習問題の解答

List A20-3 Main クラス (Main.java)

1: public class Main ( private static BigString[] bsarray = new BigString [10000]: public static void main(String[] args){ System.out.println("共有した場合:"); testAllocation (true); System.out.println("共有しない場合:"); testAllocation (false); public static void testAllocation (boolean shared) { for (int i = 0; i < bsarray.length; i++) { 2: 3: 4: 5: 6: 7: 8: 9: 10: 11: 12: 13: 14: ) 15: 16: } 17: bsarray[i] = new BigString("1212123 showMemory(); shared);

18: 19: 20: 21: 22: 23: } public static void showMemory() { Runtime.getRuntime().gc(); - long used Runtime.getRuntime().totalMemory () Runtime.getRuntime().freeMemory(System.out.println(使用メモリ=used);

Fig.A20-1 実行結果例 (環境によって結果は異なる)

共有した場合: 使用メモリ =5032672 共有しない場合: 使用メモリ =19052616

| 問題20-3の解答

(問題はp. 340 )

getBigChar メソッドを synchronizedメソッドにしない場合、 複数のスレッドからほ ぼ同時に呼ばれてしまうと、すでにそのインスタンスを作ったかどうかの判断を誤って、 多くnewしてしまう可能性があります。

以下のリストで説明します。

);

479

List A20-4 synchronizedメソッドにしない場合

public BigChar getBigChar (char charname){ BigChar bc = pool.get(String.valueOf(charname)); if (be == null) { bc = new BigChar (Charname); 1: 2: 3: 4: 5: 6: 7: return be; 8: } pool.put(String.valueOf(charname), be);

例えば、スレッドAとスレッドBが同じ charname でgetBigChar を呼んだとすると、 Fig. A20-2のようになることがあります。

Fig-A20-2 synchronized をつけないと、無駄なnewをしてしまうことがある

スレッドA 2: bcに値を得る 3: でbc が nullだと判断する 4: new BigChar する スレッド B 2:でbcに値を得る(※B) 3でbcがnu11だと判断する 4: new BigCharする 5: で pool.putする 7: 5: で pool. put する ( ※A) return する 7: で return する

この場合、スレッドAとスレッドBの両方がnew BigCharしています。 これは、(A) よりも先に (B) が実行される場合に起きる現象です。

このような現象を防ぐために、 bcに値を得たときから pool. putするまでの間は、他の スレッドが割り込まないようにする必要があります。 synchronizedを使うことで、それ が実現できるのです。

ただし、どんな場合でもsynchronizedメソッドにしなければならないわけではありま せん。synchronizedメソッドにすると一般にスピードが低下しますから、マルチスレッ ドを考える必要がない場合には synchronizedメソッドにしない方が有効です。 その場合 にはドキュメントにマルチスレッド対応ではないことを明記した方がいいでしょう。

480 付録

付録A 練習問題の解

第21章

(問題はp. 354 )

| 問題21-1の解答

解答は List A21-1, A21-2のようになります。 インスタンスの生成部分は、

real = (Printable) Class.forName (className).getDeclaredConstructor().newInstance():

のようになります。 また、 real フィールドはPrinter 型ではなく、 Printable型にして おきます。

このようにしておけば、 PrinterProxyクラスは Printer クラスから独立した部品とな り、Printableインタフェースを実装したクラスすべてに対してProxy役を果たすことが できるようになります。

注意 コンパイルの際には、次のようにMain.javaだけではなく、 Printer.javaも指定する必要が あります (Printer クラスが直接使われていないからです)。

javac Main.java Printer.java

ClassクラスとforNameメソッドについては、 Abstract Factory (p.112) で詳しく解説しまし たので、そちらも参照してください。

List A21-1 PrinterProxy クラス (PrinterProxy.java)

1: public class Printer Proxy implements Printable ( 2: private String name; 3: private Printable real; 4: private String className; // 名前 「本人」 // 「本人」のクラス名 5: 6: 7: 8: 9: 10: // コンストラクタ (名前とクラス名指定) public Printer Proxy (String name, String className) ( this.name = name; this.real = null; this.className=className; 11: ) 12: 13: 14: 15: 16: 17: 18: // 名前の設定 @Override public synchronized void set PrinterName (String name) { if (real != null) ( // 「本人」にも設定する real.setPrinterName (name); 19:

481

482 付錄

20:

this.name name;

// 名前の取得

@Override

21:

public String getPrinterName() {

return name;

8833 = 3 23: 24: 25: 26: 27: 28: 29: 30: 31: 32: 33: 3435:

// 表示

@Override

public void print (String string) {

realize();

real.print(string);

// 「本人」を生成

22:

36:

37:

if (real null) {

38: 3

private synchronized void realize() {

try (

39: 40:

or () .newInstance();

= real (Printable) Class.forName (className).getDeclaredConstruct

41:

real.setPrinterName (name);

} catch (ClassNotFoundException e) {

System.out.println(57 + className #h. ");

42:

43:

} catch (Exception e) {

44:

e.printStackTrace();

* 65 66 48: 4946: 47:

45:

: )

List A21-2 Main 757 (Main.java)

1: public class Main ( 2: 3: 4: 5: 6: 7: 8: 9: ) public static void main(String[] args) { Printable p = new PrinterProxy ("Alice", "Printer"); System.out.println("Ep.getPrinter Name () F. *); p.setPrinterName("Bob"); System.out.println(p.getPrinter Name () + "); p.print ("Hello, world.");

==

}

:

}

}

付録A の解答

Fig.A21-1 コンパイルと実行結果

javac Main.java Printer.java java Main 名前は現在Alice です。 名前は現在Bob です。 Printer のインスタンスを生成中.....完了。 === Bob === Hello, world.

サンプルプログラムの実行結果 (Fig.21-3) Fig.A21-1の実行結果を注意深く見比べ てください。 Fig.A21-1では、 「Printer のインスタンスを生成中」のところに名前 (Bob) が表示されていません。 これは、 インスタンスをnewInstanceメソッドで生成したため に、 Printer クラスの引数なしコンストラクタが呼び出されているためです。

問題21-2の解答

synchronized メソッドにしなかった場合、 複数のスレッドからsetPrinterName と realize が個別に呼ばれると、 PrinterProxyクラスのname と Printerクラスのnameに ずれが生じる場合があります。

(問題はp.354)

synchronized をつけなかった場合のプログラムを、 List A21-3に示します。

List A21-3 synchronized をつけなかった場合

1: public void setPrinterName (String name)2: 3: 4: 5: 6: } if (real != null) { } real.setPrinterName (name); this.name = name; a: b: C: d: ... private void realize() { if (real null) ( } real = new Printer (name); e:

(

483

484 付録

| Fig-A21-2 synchronizedをつけなかった場合に発生するnameのずれ

name の値 realの値 スレッドA スレッド B *Alice* null 1 :にやってくる *Alice* null 'Alice* null *Alice' null 2でrealはnullだと判断する スレッドBに切り替わる a: にやってくる b: で realはnullだと判断する *Alice* 非null *Bob* 非 null c: real Printer のインスタンス Alice) を代入する 「スレッドAに切り替わる 5:nameにBob* を代入する

※この時点で、 PrinterProxyクラスのname は "Bob だが、 Printer クラスのname は Alice" になってしまった

最初に、 Printer Proxyのname フィールドの値が Alice" で、 real フィールドの値が null (つまり、Printerクラスのインスタンスはまだ生成されていない)とします。

スレッドAがsetPrinterName("Bob*) を実行すると同時に、スレッドBが (printメソ ッド経由で) realizeメソッドを呼び出したとしましょう。 もしもFig.A21-2のようにス レッドが切り替わったら、 PrinterProxyクラスのname フィールドの値は "Bob" になりま すが、 Printer name フィールドの値は "Alice"になってしまいます。

setPrinterName メソッドとrealizeメソッドを synchronizedメソッドにすることで、 このようなスレッド切り替えが起きなくなります。synchronizedメソッドによって、 real フィールドの値の判断と値の変更がばらばらに行われないようにしているのです。 synchronizedメソッドで、 realフィールドをいわば「守っている」ことになります。

第22章

問題22-1の解答

(問題はp.373 )

いろいろな追加方法があると思いますが、 ここでは次のようにしました。

① drawer パッケージに、 「描画色を設定する命令」 を表す Color Commandクラスを追 加する (List A22-1)

② Drawableインタフェースに、 「描画色を変更するメソッド」 setColor を追加する (List A22-2)

付録A

③それにあわせてDrawCanvas クラスに setColor メソッドを実装する (List A22-3) ④ Main クラスに 「赤」 「緑」 「青」 の色変更ボタンを追加する (List A22-4)

commandパッケージのクラスやインタフェースにはまったく変更はありません。

Fig.A22-1 サンプルプログラムに描画色の設定機能を追加する

clear Command Pattern Sample green blue I

List A22-1

ColorCommand >52 (ColorCommand.java)

1: package drawer;

2:

3: import command.Command;

4: import java.awt.Color;

6: public class ColorCommand implements Command{

5:

// 描画对象

protected Drawable drawable;

7:

8:

// 描画色

9:

10:

11:

private Color color:

12:

13:

14:

// コンストラクタ public ColorCommand (Drawable drawable, Color color) { } this.drawable drawable; this.color color; //实行 @Override

15:

16:

17:

18:

19:

485

21: 20: สสสส 22: 23: 1 public void execute() { drawable.setColor(color);

List A22-2 Drawable 1971-7 (Drawable.java)

1: package drawer;

2:

3: import java.awt.Color;

5: public interface Drawable (

4:

public abstract void init();

7:

6:

public abstract void draw(int x, int y); public abstract void setColor(Color color);

9:1

8:

List A22-3 DrawCanvas 57 (DrawCanvas.java)

1: package drawer; 2: 3: import comand. MacroCommand; 4: 5: import java.awt.Color; 6: import java.awt.Graphics; 7: import java.awt.Canvas; B: 9: public class DrawCanvas extends Canvas implements Drawable ( // 搭兩色 private Color color: 10: 11: 12: 描画する点の半径 13: private int radius; 14: 15: private MacroCommand history; 16: 17: コンストラクタ 18: 18: 20: 21: public DrawCanvas (int width, int height, MacroCommand history) ( setSize(width, height); setBackground (Color.white); this history history; 22 22 24

486

付録 同期の解

25:

26:

// 履歴全体を再描画 @Override public void paint (Graphics g) ( history.execute();

27:

29:

31:

// 初期化

@Override

33:

32:

public void init() (

34:

color Color.red;

37:

36:

35:

radius = 6;

history.append (new ColorCommand (this, color));

// 描画

@Override

39:

40:

public void draw(int x, int y) {

41:

Graphics g = getGraphics();

42:

g.setColor (color);

44:

43:

45:

g.filloval (x-radius, y - radius, radius 2, radius 2);

46:

47:

@Override

public void setColor (Color color) (

48:

30:

this.color color;

49: 50:

}

51: }

}

487

28:

38:

List A22-4 Main (Main.java)

1: import command.*; 2: import drawer.*; 3: 4: import java.awt.*; 5: import java.awt.event.*; 6: import javax.swing.*; 7: 8: public class Main extends JFrame implements MouseMotionListener. WindowListener ( 9: 10: 11: 12: 13: 14: // 描画履歷 private MacroCommand history new MacroCommand(); // 描画領域 private DrawCanvas canvas = new DrawCanvas (400, 400, history): // 消去ボタン private JButton clearButton new JButton("clear");

488

15: 16: 17: 18: 19: 20: 21: 22: 23: 24: 25: 26: 27: 28: 29: 30: // 赤ボタン private JButton redButton = new JButton("red"); // 緑ボタン private JButton greenButton = new JButton("green"); 11 青ボタン private JButton blueButton = new JButton("blue"); // コンストラクタ public Main(String title) { super (title); this.addWindowListener(this); canvas.addMouseMotionListener(this); clearButton.addActionListener(e -> ( history.clear(); canvas.init(); 31: canvas.repaint(); 32: }); 33: 34: 35: 36: 37: 38: 39: 40: 41: 42: )); 43: 44: 45: 46: redButton.addActionListener(e -> { }); Command cmd = new ColorCommand (canvas, Color.red); history.append(cmd); cmd.execute(); greenButton.addActionListener(e -> ( Command cmd = new ColorCommand (canvas, Color.green); history.append(cmd); cmd.execute(); blueButton.addActionListener (e -> ( Command cmd = new ColorCommand (canvas, Color.blue); history.append(cmd); cmd.execute(); 47: }); 48: 49: 50: 51: 52: Box buttonBox new Box (BoxLayout.X_AXIS); buttonBox.add(clearButton); buttonBox.add(redButton); buttonBox.add(greenButton);

53:

buttonBox.add (blueButton);

54:

55:

Box mainBox new Box (BoxLayout.Y_AXIS); mainBox.add(buttonBox);

56:

57:

mainBox.add(canvas);

getContentPane().add(mainBox);

58:

pack();

59:

setVisible(true);

60:

61:

)

付録A 練習問題の解答 489

62:

63:

36 66: 67:

// MouseMotionListener J

65:

68:

@Override

public void mouseMoved (MouseEvent e) {}

@Override

public void mouseDragged (MouseEvent e) {

64:

Command cmd = new DrawCommand (canvas, e.getPoint());

history.append(cmd);

69:

cmd.execute();

70:

71:

72:

73:

74:

75:

} // WindowListener J @Override public void windowClosing (WindowEvent e) ( System.exit(0);

76:

@Override public void windowActivated (WindowEvent e) () @Override public void windowClosed (WindowEvent e) {) @Override public void windowDeactivated (WindowEvent e) () @Override public void windowDeiconified (WindowEvent e) () @Override public void windowIconified (WindowEvent e) {} @Override public void windowOpened (WindowEvent e) () public static void main(String[] args) { new Main ("Command Pattern Sample"); } )

82:

86:

87:

88:

89:

90:

84:

85:

| 問題22-2の解答

(問題はp.373 )

Main クラスに変更を加え、 List A22-5のようにしました。変更点は以下の2つです。

アンドゥボタンを追加する

アンドゥボタンを押したときには、 history. undo を呼び出して再描画 (repaint) する

commandパッケージおよびdrawerパッケージにはまったく変更はありません。 アンドゥを行っている様子を、 Fig.A22-2~Fig.A22-4に示します。

77:

78:

79:

80:

83:

81:

}

Fig-A22-2 形が気に入らないから、アンドゥしたいな・・・

Fig-A22-3 数回アンドゥボタンを押した後

Command Pattern Sample clear undo

Command Patter Sampl

Fig. A22-4 さらに数回アンドゥボタンを押した後

Command Peter Sample

List A22-5 Main 25% (Main.java)

1: import command.*; 2: import drawer.*; 3: 4: import java.awt.*; 5: import java.awt.event.*; 6: import javax.swing.*; 7: 8: public class Main extends JFrame implements MouseMotionListener, WindowListener ( 9: 10: 11: // 描画履歷 private MacroCommand history = new MacroCommand(); // 描画領域

490 ft

12:

HHA ROM 491

, history):

13:

14:

15:

16:

17:

18:

19:

// アンドゥボタン private DrawCanvas canvas = new DrawCanvas (400, 400// 消去ボタン private JButton clearButton private JButton undoButton = new JButton("undo"); // コンストラクタ public Main(String title) ( super (title); this.addWindowListener (this); canvas.addMouseMotionListener(this); clearButton.addActionListener(e-> ( history.clear(); canvas.repaint(); new JButton("clear"); )); undoButton.addActionListener (e -> ( history.undo(); canvas.repaint(); });

25:

20:

22:

21:

23:

24:

26:

27:

29:

Box buttonBox new Box (BoxLayout.X_AXIS); buttonBox.add(clearButton); buttonBox.add(undoButton);

30:

31:

Box mainBox new Box (BoxLayout. Y_AXIS);

mainBox.add(buttonBox);

mainBox.add(canvas);

32:

28:

getContentPane().add(mainBox);

37:

38:

39:

40:

41:

34:

33:

35:

36:

pack();

setVisible(true);

42:

43:

45:

)

44:

// MouseMotionListener

@Override

46:

public void mouseMoved (MouseEvent e) {

47:

48:

49:

}

50:

51:

52:

@Override public void mouseDragged (MouseEvent e) ( Command cmd new DrawCommand (canvas, e.getPoint()); history.append(cmd); cmd.execute(); )

53:

54:

55:

// WindowListener

@Override

56:

57:

58:

492

59: 60: 61: 62: 63: : : : : public void windowClosing (WindowEvent e) { System.exit(0); } @Override public void windowActivated (WindowEvent e) {} @Override public void windowClosed (WindowEvent e) ( ) @Override public void windowDeactivated (WindowEvent e) () @Override public void windowDeiconified (WindowEvent e) {} @Override public void windowIconified (WindowEvent e) () @Override public void windowOpened (WindowEvent e) {} : 69: 70: public static void main(String[] args) { 71: new Main ("Command Pattern Sample"); 72: 73: ) }

問題22-3の解答

解答はList A22-6のようになります。

List A22-6 Main 52 (Main.java)

1: import command.*;

2: import drawer.*;

3:

4: import java.awt.";

5: import java.awt.event.*;

6: import javax.swing.*;

8: public class Main extends JFrame (

// 描履歷

10:

9:

11:

private MacroCommand history new MacroCommand();

// 描画領域

12:

13:

private DrawCanvas canvas new DrawCanvas (400, 400, history);

// 消去ボタン

14:

private JButton clearButton = new JButton("clear");

15:

// コンストラクタ

16:

17:

public Main(String title) (

super (title);

18:

19:

(問題はp.373 )

this.addWindowListener(new WindowAdapter() {

6667

7:

public void windowClosing (WindowEvent e) { System.exit(0);

20:

21:

6465

68

22:

23:

問題の解

24:

});

25:

26:

27:

28:

29:

canvas.addMouseMotionListener (new MouseMotionAdapter() { public void mouseDragged (MouseEvent e) { Command cmd = new DrawCommand (canvas, e.getPoint()); history.append(cmd); cmd.execute(); ) });

31:

30:

32:

33:

34:

35:

clearButton.addActionListener (e -> ( )); history.clear(); canvas.repaint();

36:

37:

38:

Box buttonBox = new Box (BoxLayout.X_AXIS); buttonBox.add(clearButton);

39:

40:

Box mainBox new Box (BoxLayout.Y_AXIS);

mainBox.add(buttonBox);

41:

mainBox.add(canvas);

getContent Pane().add(mainBox);

42:

43:

pack();

44:

46:

setVisible(true);

47:

48:

49:

public static void main(String[] args) { new Main ("Command Pattern Sample");

50:

51:

52:

53: )

第23章

問題23-1の解答

(問題はp. 399 )

45:

ここでは、 turtleパッケージにGUI関連を集め、 language パッケージにはGUI関連が 入らないようにしました。 他のパッケージにExecutor や ExecutorFactory インタフェー スを実現するクラスを作れば、 languageパッケージはまったく修正せずに、同じプログ ラムを 「実行する」 別のプログラムを作ることもできるでしょう。

}

493

494 付録

Table A23-1 クラスとインタフェース一覧

パッケージ language 名前 InterpreterFacade language ExecutorFactory language Context language Node language Executor language language ProgramNode CommandNode language Repeat CommandNode language CommandListNode language PrimitiveCommandNode language ParseException turtle TurtleCanvas turtle 解說 インタプリタを使いやすくするクラス (FacadeパターンのFacade役) 基本コマンドを生成するインタフェース (Factory Method パターンのCreator 役) サンプルプログラムとほぼ同じ サンプルプログラムとほぼ同じ 「実行」 を表現するインタフェース サンプルプログラムとほぼ同じ サンプルプログラムとほぼ同じ サンプルプログラムとほぼ同じ サンプルプログラムとほぼ同じ サンプルプログラムとほぼ同じ 構文解析時の例外クラス タートルグラフィクスを実現するクラス TurtleExecutorFactory コマンド名に応じたExecutor を生成するクラス turtle GoExecutor turtle LeftExecutor turtle Right Executor 無名 Main (Factory MethodパターンのConcrete Creator 役) *go* を実行する Executor TurtleExecutorFactoryの内部クラス) *left" を実行する Executor TurtleExecutorFactoryの内部クラス) "right" を実行する Executor TurtleExecutorFactoryの内部クラス) 動作テスト用のクラス

List A23-1 InterpreterFacade クラス (InterpreterFacade.java)

1: package language;

2:

3: public class InterpreterFacade implements Executor {

4:

private ExecutorFactory factory;

private Context context;

5:

6:

private Node programNode;

7:

public InterpreterFacade (ExecutorFactory factory) { this.factory = factory:

8:

9:

)

10:

11:

public void parse (String text) throws ParseException { this.context = new Context(text);

12:

13:

this.context.setExecutorFactory (factory):

this.programNode = new ProgramNode(); programNode.parse(context);

14:

15:

16:

System.out.println(programNode.toString()); 17: 18: } 19: 20: 21: 22: 23: 24: ) 25: 26: ) @Override public void execute() { if (programNode != null) ( programNode.execute(); 495

付録A

List A23-2 ExecutorFactory 1-371-7 (ExecutorFactory.java)

1: package language; 2: 3: public interface Executor Factory ( 4: 5: ) public abstract Executor createExecutor (String name);

List A23-3 Context 757 (Context.java)

1: package language;

2:

3: public class Context implements ExecutorFactory (

private ExecutorFactory factory;

4:

5:

private String[] tokens;

6:

private String lastToken;

7:

private int index;

public Context (String text) (

10:

9:

this.tokens text.split("\\s+");

11:

this.index = 0;

12:

13:

nextToken();

14:

)

8:

15: 16: 17: 18: public String nextToken() ( if (index < tokens.length) lastToken tokens [index++); ) else ( 19: lastToken=null; 20: 21: return lastToken; 22:

23:

24:

public String currentToken() (

496 M

, but no

, but **

25: 26: return lastToken; 27: ៩ឆ៩ ខ៖ 28: 29: 30: 31: 32: public void skipToken (String token) throws ParseException { if (currentToken() == null) { more token is found."); is expectedthrow new ParseException("Error: token + } else if (!token.equals (currentToken())) ( throw new ParseException("Error: token is expectedcurrentToken() is found."); 33: } 34: nextToken(); 35: public int current Number () throws ParseException { if (currentToken() == null) { throw new ParseException("Error: No more token."); int number = 0; try { number Integer.parseInt(currentToken()); } catch (NumberFormatException e) { throw new ParseException("Error: e); return number; 36: 37: 38: 39: 40: } 41: 42: 43: 44: 45: 46: } 47: 48: 49: 50: 51: 52: } 53: 54: 55: 56: 57: ) 58: ) public void setExecutor Factory (ExecutorFactory factory) ( this. factory factory; @Override public Executor create Executor (String name) ( return factory.createExecutor (name);

List A23-4 Node 57 (Node.java)

1: package language; 2: 3: public abstract class Node implements Executor ( 4: 5: ) public abstract void parse (Context context) throws ParseException;

+

HAA

List A23-5 Executor 1371-7 (Executor.java)

1: package language; 2: 3: public interface Executor { 4: 5: ) public abstract void execute();

List A23-6 ProgramNode 75x (ProgramNode.java)

1: package language;

3: <program> program <command list>

4: public class ProgramNode extends Node ( private Node commandListNode; 5:

@Override

6:

public void parse (Context context) throws ParseException {

context.skipToken ("program");

commandListNode = new CommandListNode();

7:

8:

2:

9:

commandListNode.parse(context);

10:

11:

} @Override public void execute() { commandListNode.execute();

18:

19: 20: 21: @Override public String toString() ( return [program commandListNode ]*; 22: 23: )

12:

1: package language; 2: 3: // <command> ::= <repeat command> <primitive command> 4: public class CommandNode extends Node ( 5: 6: 7: 8: private Node node; @Override public void parse (Context context) throws ParseException {

13:

14:

15:

16:

17:

List A23-7 CommandNode 57 (CommandNode.java)

}

497

498 付

9:

10:

if (context.currentToken().equals("repeat")) node new Repeat CommandNode(); node.parse(context);

11:

12:

} else {

13:

node new PrimitiveCommandNode(); node.parse(context);

14:

}

15:

16:

17:

18:

@Override

public void execute() {

19:

20:

node.execute();

21:

22:

@Override

23:

)

public String toString() {

24:

return node.toString();

25:

26:

27: 1

List A23-8 RepeatCommandNode 52 (RepeatCommandNode.java)

1: package language; 2: 3: // <repeat command> ::= repeat <number> <command list> 4: public class Repeat CommandNode extends Node ( private int number; 5: 6: private Node commandListNode; 7: 8: 9: 10: 11: 12: 13: 14: @Override public void parse (Context context) throws ParseException ( context.skipToken ("repeat"); number context.currentNumber(); context.nextToken(); commandListNode = new CommandListNode(); commandListNode.parse(context); 15: 16: 17: 18: 19: 20: @Override public void execute() { for (int i=0; i<number; i++) { commandListNode.execute(); 21: 22: ) 23: 24: @Override

付録A 問題の解答 499

25: public String toString() () 26: : : ) return [repeat "+number+commandListNode"]; )

2728

List A23-9 CommandListNode 52 (CommandListNode.java)

1: package language;

2:

3: import java.util.ArrayList;

4: import java.util.List;

6://<command list> :: <command>* end

7: public class CommandListNode extends Node (

private List<Node> list = new ArrayList<>();

5:

@Override

8:

9:

10:

11:

public void parse (Context context) throws ParseException { while (true) (

if (context.currentToken() == null) {

throw new ParseException("Error: Missing 'end'); } else if (context.currentToken().equals("end")) {

15:

context.skipToken("end");

break;

} else {

12:

13:

21:

16:

18:

Node commandNode = new CommandNode(); commandNode.parse (context);

list.add(commandNode);

17:

19:

20:

14:

22:

23:

24:

25:

@Override

26:

27:

public void execute() {

28:

29:

30:

for (Node node: list) (

node.execute();

31:

33: 34: 35: @Override public String toString() ( return list.toString(); 36: 37: )

32:

500 M

List A23-10 PrimitiveCommandNode 57 (PrimitiveCommandNode.java) 1: package language; 2: 3: // <primitive command> ::=go | right left 4: public class PrimitiveCommandNode extends Node { private String name; private Executor executor; @Override public void parse (Context context) throws ParseException ( 5: 6: 7: 8: 9: 10: 11: 12: 13: 14: 15: 16: 17: 18: 19: 20: } name = context.currentToken(); if (name == null) { throw new ParseException("Error: Missing <primitive command>"); } else if (!name.equals("go") && !name.equals("right") && !name.equals("left")) { throw new ParseException("Error: Unknown <primitive command>: + name + "); context.skipToken (name); executor = context.createExecutor (name); @Override

public void execute() {

22:

executor.execute();

23:

@Override

25:

public String toString() {

26:

27:

28:

24:

return name;

List A23-11 ParseException 57 (ParseException.java)

1: package language; 2: 3: public class ParseException extends Exception { 4: public ParseException(String msg) { 5: 6: 7: } super (msg);

)

21:

29: )

}

NA

List A23-12 TurtleCanvas 57 (TurtleCanvas.java)

1: package turtle;

2:

3: import language. Executor;

4: import language. Executor Factory;

5: import java.awt.*;

6:

7: public class TurtleCanvas extends Canvas ( 8: 9: 10: 11: 12: final static int UNIT_LENGTH = 30; final static int DIRECTION_UP = 0; final static int DIRECTION_RIGHT = 3; final static int DIRECTION_DOWN = 6; final static int DIRECTION_LEFT = 9; // 動くときの単位長さ // 上向き // t // T //* 13: 14: 15: final static int RELATIVE_DIRECTION_RIGHT = 3; // < final static int RELATIVE DIRECTION_LEFT=-3; //< final static int RADIUS = 3; // **

16:

17:

private int direction = 0;

19:

private Point position;

private Executor executor = null;

public TurtleCanvas ( int width, int height) (

22:

setSize (width, height);

initialize();

23:

private void initialize() ( Dimension size = getSize(); position new Point (size.width / 2, size.height / 2); direction = 0; set Foreground (Color.red); setBackground (Color.white); Graphics g getGraphics (); if (g = null) { g.clearRect(0, 0, size.width, size.height);

24:

25:

26:

27:

28:

29:

21:

30:

31:

32:

18:

20:

34:

33:

35:

36:

37:

38:

39:

40:

public void set Executor (Executor executor) ( this.executor executor; void setRelativeDirection (int relative Direction) ( setDirection (direction relative Direction);

41:

42:

43:

44:

45:

}

501

502

46:

void setDirection(int direction) ({

47:

if (direction < 0) {

48:

49:

50:

direction 12 (-direction) 12;

} else {

51:

direction direction 12;

52:

this.direction direction 12;

53:

54:

55:

)

void go (int length) {

56:

int newx position.x;

57:

58:

int newy position.y;

switch (direction) (

59:

60:

case DIRECTION_UP:

61:

newy-length;

break;

case DIRECTION_RIGHT:

62:

63:

64:

newx += length; break;

65:

case DIRECTION DOWN:

66:

67:

newy += length; break;

68:

69:

case DIRECTION_LEFT:

newx -= length;

break;

70:

71:

default:

break;

72:

73:

74:

75:

Graphics g

getGraphics();

if (g!= null) {

76:

g.drawLine (position.x, position.y, newx, newy);

77:

78:

g.filloval (newx - RADIUS, newy -RADIUS, RADIUS 2+1, RADIUS 2+ 1);

position.x newx;

79:

80:

position.y newy;

81:

83:

}

82:

84:

}

@Override

public void paint (Graphics g) (

initialize();

85:

86:

if (executor != null) {

87:

executor.execute();

88:

89:

90: )

)

=

付録A の無着

List A23-13 Turtle ExecutorFactory 757 (Turtle ExecutorFactory.java)

1: package turtle; 2: 3: import language. Executor; 4: import language. Executor Factory; 5: 6: public class TurtleExecutor Factory implements ExecutorFactory ( 7: private final TurtleCanvas canvas; // 内部クラス ("go* を実行) private class GoExecutor implements Executor ( @Override public void execute() { canvas.go (TurtleCanvas. UNIT_LENGTH); // 内部クラス ("left" を実行) private class LeftExecutor implements Executor ( @Override public void execute() { canvas.setRelative Direction (TurtleCanvas. RELATIVE DIRECTION_LEFT); 8: 9: 10: 11: 12: 13: 14: } 15: ) 16: 17: 18: 19: 20: 21: 22: 23: ) 24: 25: 26: // 内部クラス ("right" を実行) private class Right Executor implements Executor (

@Override

27:

28:

public void execute() {

canvas.setRelative Direction (TurtleCanvas. RELATIVE_DIRECTION_RIGHT);

29:

30:

31:

32:

)

// コンストラクタ

public TurtleExecutor Factory (TurtleCanvas canvas) (

33:

34:

35:

this.canvas canvas;

36:

37: 38: 39: 40: 41: 42: 43: 44: 45: @Override public Executor createExecutor (String name) { if (name.equals("go")) ( return new GoExecutor(); } else if (name.equals("right")) { return new Right Executor (); } else if (name.equals("left")) ( return new LeftExecutor ();

)

503

504

46: 47: >: } else { throw new IllegalArgumentException("Error: Unknown <primitive command name + ***); 48: 49: 50: } }

List A23-14 Main 57 (Main.java)

1: import language.*;

2: import turtle.*; 3: 4: import java.awt.*; 5: import java.awt.event.*; 6: import javax.swing.*; 7: 8: public class Main extends JFrame ( 9: 10: 11: 12: 13: 14: 15: 16: 17: 18: 19: 20: 21: 22: 23: 24: 25: 26: 27: private TurtleCanvas canvas = new TurtleCanvas (400, 400); private Interpreter Facade facade = new Interpreter Facade (new TurtleExecutorFa ctory (canvas)); private TextField programTextField = new TextField("program repeat 3 go right go left end end"); // コンストラクタ public Main(String title) ( super (title); canvas.setExecutor (facade); setLayout (new BorderLayout()); programTextField.addActionListener (e ->parseAndExecute()); this.addWindowListener (new WindowAdapter() { }); public void windowClosing (WindowEvent e) ( System.exit(0); }

28:

29:

add (programTextField, BorderLayout.NORTH); add (canvas, BorderLayout.CENTER);

30:

31:

pack();

32:

setVisible(true);

parseAndExecute();

34:

33:

35:

付録A 練習問題の解答

private void parseAndExecute() { 36: 37: 38: 39: 40: 41: 20= 42: 43: 44: 45: 46: } 47: String programText = programTextField.getText(); System.out.println("programText = + programText); try ( facade.parse (programText); canvas. repaint(); } catch (ParseException e) { JOptionPane.showMessageDialog(this, e.getMessage(), "Error", JOptionPane. ERROR_MESSAGE); 48: 49: 50: 51: ) public static void main(String[] args) ( new Main ("Interpreter Pattern Sample"); }

}

505

506 M

付録B

GoFによるデザインパターンの分類

GoF 本 (付録D [GoF] 参照) では、デザインパターンを以下のように分類しています。 ( )の中は、本書で紹介した章番号を示しています。

生成に関するパターン

Abstract Factory (第8章) Factory Method (第4章) Singleton (第5章)

構造に関するパターン

Builder (第7章)

Adapter (第2章)

Composite (第11章)

Prototype (第6章)

Facade (第15章)

Proxy (第21章)

Bridge (第9章)

Decorator (第12章)

Flyweight (第20章)

振る舞いに関するパターン

Chain of Responsibility (第14章)

Interpreter (第23章)

Mediator (第16章)

Observer (第17章)

Strategy (第10章) Visitor (第13章)

Command (第22章)

Iterator (第1章)

Memento (第18章)

State (第19章)

Template Method (第3章)

C デザインパターンQ&A

付録

C デザインパターンQ&A

付録Cでは、 デザインパターンに関して誤解されがちな項目をQ&

A形式で解説します。

| デザインパターンとは

Q. デザインパターンとは何ですか?

A. デザインパターンとは、ソフトウェアの設計時に繰り返して起こる問題に対する解 法です。 Gang of Four (GoF) と呼ばれる4人によってまとめられた、 23個のデザインパ ターンが最も有名なものです。 他にも多数のデザインパターンが世界中で議論され、 作ら れています。

| デザインパターンは万能か

Q. デザインパターンはソフトウェアの問題

A. いいえ。

をすべて解決しますか?

個々のデザインパターンは、ソフトウェアの設計上の問題を解決するためのものですが、 どんな解決方法にもトレードオフがつきものです。 すべての問題を解決できるわけではあ りません。

適切なデザインパターンの選択

Q. どうすれば、 適切なデザインパターンを選択することができますか?

A. まず、自分が設計しているソフトウェアがどのような「問題」をかかえているかを 見つけましょう。 解決すべき問題がはっきりしなければ、適切なデザインパターンを選ぶ ことはできません。

507

508 付録

例えば、いま直面している問題が 「オブジェクトが多すぎてメモリを無駄に消費してし まう」とはっきりすれば、 「Flyweightパターンが適用できるかも」とわかります。 Flyweight パターンは、オブジェクトを共有してメモリの消費量を少なくするためのパタ ーンだからです。

パターンを学ぶときには、そのパターンが「どんな問題を解決できるのか」 に注目する とよいでしょう。

なお、 どんなプログラムに対してもデザインパターンを適用しなければならないわけで はありません。 金科玉条のようにデザインパターンを考えたり、すべてに当てはめようと するのは間違いです。

デザインパターンは当たり前

Q.デザインパターンといわれている解法は、すべて当たり前のことばかりです。 注目 したり、改めて勉強する価値があるとは思えません。 どうしてデザインパターンが 重要なのですか?

A. たくさんの経験を積んだプログラマは、デザインパターンとして紹介されているも のを「当たり前」だと感じることが多いようです。 それは当然のことです。 もともとデザ インパターンは、プログラマが繰り返し経験してきた問題とそれに対する解法をまとめた ものだからです。

デザインパターンが重要なのは、経験を積んだプログラマの知恵を効率よく学ぶことが できるからです。

デザインパターンは覚えにくい

Q. GoF のデザインパターンは23個もあり、全部覚えるのは難しいです。 どうしたらよ いですか?

A. 無理に全部を覚える必要はありません。 GoF が提唱しているデザインパターンがす べて同じような頻度で使われているわけではないからです。

特に、 機械的に丸暗記してしまうのはあまり意味がありません。 それよりも、そのデザ インパターンが問題をどのように解決しているかを自分の頭で理解することが大切です。

デザインパターンQ&

A 509

| 初級プログラマとデザインパターン

Q.デザインパターンは初級プログラマにも役に立ちますか?

A.もちろんです。

プログラミング言語の基本を学んで、 自分で少しずつプログラムを組めるようになった 人が、デザインパターンを通して 「オブジェクト指向プログラミングでは、どのような点 に注意してプログラムを作るのか」 を学ぶのはよいことです。 本書でも解説したとおり、 再利用性、 交換可能性、 インタフェース (API), 継承と委譲、 抽象化･･･といった重要な概 念について学ぶことができるでしょう。

また、クラスライブラリを自分で 「使う」 場合にも、デザインパターンの知識は役に立 ちます。 なぜなら、クラスライブラリの中には、デザインパターンに関係しているものも あるからです。

もちろん、 自分の技術がレベルアップしてクラスライブラリを 「作る」 立場になったと きには、デザインパターンの知識はいっそう役に立つでしょう。

| デザインパターンとパターン

Q. 「デザインパターン」とは別に、 「パターン」という用語を聞くことがあります。両 者は同じものですか?

A. 厳密には違います。

どのような分野であっても、 「ある文脈のもとで繰り返し発生する問題に対する解法」 に対して名前をつけて整理したものを、一般にパターンといいます。

デザインパターンは、パターンをソフトウェアの設計・開発の分野に適用したものであ り、パターンの一種と考えればよいでしょう。

ただし、ソフトウェアの分野では 「デザインパターン」のことを短く 「パターン」と呼 ぶことがよくあります。

510録

| デザインパターンとアルゴリズム

Q. 「デザインパターン」 は 「アルゴリズム」と同じですか?

A. 違います。 でも、 深い関係があります。

「アルゴリズム (algorithm)」 は、 入力から出力を得るための機械的な手順です。 アル ゴリズムは有限ステップで停止する必要があります。 例えば、 バイナリサーチやクイック ソートは代表的なアルゴリズムです。

アルゴリズムを 「問題解決の手法」 とみなして記述し、 パターンとして表現することは できますが、 アルゴリズム=デザインパターンではありません。

デザインパターンは、 「アルゴリズム」のほかに「イディオム」とも関係があります。 「イディオム (idiom)」 というのは、 コーディングする際によく使われる決まり文句 ( 慣 用句)のことです。 一般にイディオムは、プログラミング言語への依存度が高いという特 をもちます。 イディオムも 「問題解決の手法」としてパターンのように表現することは 可能ですが、 イディオム=デザインパターンではありません。

本書では、デザインパターンの理解を深めるために具体的なサンプルプログラムを使い ましたが、デザインパターンは具体的な実装そのものではありません。 ただし、プログラ ミング言語やライブラリが設計・実装されるときに、 デザインパターンの考え方が組み込 まれているケースはよくあります。 そのような実装を行う背後にある考え方、 解法がデザ インパターンなのです。

付録D

D

参考文献

[GoF]

Erich Gamma+Richard Helm+Ralph Johnson+John Vlissides, 本位田真一十吉田和樹監訳, 「オブジェクト指向における再利用のためのデザインパターン 改訂版」 ソフトバンクパブリッシング株式会社, ISBN978-4-7973-1112-9, 1999年

[Bloch]

Joshua Bloch, 柴田芳樹訳, 「Effective Java 第3版」, 丸善出版, ISBN 978-4-6213-0325-2,2018年.

[JavaSE] Java Platform, Standard Edition Documentation https://docs.oracle.com/en/java/javase/

511

512

索引

◆記号

<>

clone メソッド

.83, 127

168 CloneNotSupportedException -84

247 Colleague 12.

◆ A

AbstractClass

AbstractExpression

Abstract Factory->

-264

Command- 83, 175, 233, 297, 356

Command

41 compare メソッド

・395

AbstractFactory

67, 99, 104, 143, 159, 245 Composite/->

Abstraction

Abstract Product

367

.161

compareTo メソッド -161

Adaptee

Adapter/->

Adapter役

Aggregate

Component

-173, 187

-124

15, 58, 83, 99, 127, 164,

140 Composite

192, 215, 233, 339, 372, 397

124 ConcreteAggregate

25

18, 143, 192, 353, 370

asListメソッド

ConcreteBuilder 12

ConcreteClass 1.

25 ConcreteColleague -

11 ConcreteCommand

AWT

57 ConcreteComponent

266 ConcreteCreator 2

Builder

173

.97

-264

41

-367

187

B

Concrete Decorator 1

BNF

ConcreteElement

Bridge パターン

Builder パターン

12

55

187

381

ConcreteFactory

211

29, 132 ConcreteFlyweight

335

67, 88, 126

Concrete Handler

124

97 ConcreteImplementor

C

Caretaker

Chain of Responsibility/-> Client役 25, 80,

.230

ConcreteIterator

Concrete Mediator 1

293 ConcreteObserver

141

222 Concrete Product 12-

264

97, 124, 173, 230,

243, 335, 349, 367, 395

Concrete Prototype ConcreteState

11

277

-55, 124

.80

316

#51 513

Concrete Strategy 1 Concrete Subject 157 276 Concrete Visitor 1. 211 Context役 157, 316, 395 GoF Creator 54 Google

D

Decoratorパターン･

29, 83, 176, 178, 353

Decorator

default

Dependency Injection-

GUI

DI

Director役

-100

divide and conquer

♦E

-iii, 506 397

187 H

Element役

46 Handler

100 HTTP

.97

enum

66, 147, 414

Event

extrinsicな情報

G

317 Implementor

211

▶F

-356 | Invokerfa

337 Iterator -> Iterator

2, 58, 215

Facadeパターン 67, 99, 236, 266, 399

Facade役

367

Factory Method (static Factory Method)

Factory Method

-15, 43, 48, 127, 399

field-for-field copy

232, 234, 250, 266, 278,

311, 356, 399, 423, 461

instanceof -43

11

final

57 java.awt.Canvas -362

Flyweight 3-

Flyweight役,

242 java.awt.Button

forEachメソッド・

getDeclaredConstructor F 112

getInstance .57

230

352

140

<<interface>> xxxi

Interpreter/<-> 215, 376

intrinsic s -337

256

java.awt. Checkbox -

258

84 java.awt.event.ActionListener

46, 406

67, 82, 159, 321, 326, 397

FlyweightFactory

formatted メソッド

forName メソッド

java.awt.event. TextListener

-257

java.awt.Frame

335 java.awt.Point

259

335 java.awt.TextField-

412 java.io.

360

257

456 java.io.InputStream..

190

112 java.io.Reader

46

java.io.Serializable.

299

30

514 索引

java.io.Writer

30 L

java.lang.ClassCastException.

java.lang.Cloneable.

404 Leaf

83 Liskov Substitution Principle-

java.lang.CloneNot SupportedException

LSP

கக 43 .43

.83

173

M

java.lang.IndexOutOfBoundsException 181 java.lang.Iterable. 3, 219, 452 Main java.lang.String 57, 161, 444, 456 java.lang.StringBuilder 102, 425 java.nio.file.Files -111, 191, 217 java.nio.file.FileVisitor 217 java.nio.file.Path 111 java.nio.file.SimpleFileVisitor java.nio.file.StandardOpenOption 217 111 java.security. SecureRandom -57, 159 MVC java.time. Instant -57 java.time.Month. APRIL- 66 java.util.ArrayList xxxiii, 13, 16 java.util.Arrays -57 java.util.Comparator - 161

main F

.viii

marker interface Mediator パターン Mediator

84

-245, 250, 280

Memento パターン

-263

Memento 1

82, 284, 372

Model/View/Controller-

293

java.util.concurrent. ThreadLocalRandom

newBufferedReader F

newBufferedWriter F

280

narrow interface

293

280

new

N

.127, 326

192

.192

159 newInputStream F

java.util.Deque 359 newInstance java.util.HashMap 328, 331 java.util.Iterator 5, 204 NonterminalExpression java.util.List 57, 161, 387 java.util.Map java.util.Observer. .75, 331 -270 java.util.Properties- 30, 238 java.util.Random 150, 159, 273 java.util.Stack 359 javax.swing.border javax.swing.JFrame ･191 363

newOutputStream F

112, 128

192

192

now F

-395

-57

ObjectStructure 1

0

Observer/->

-266, 270, 311

Observer

-276

of メソッド

Open-Closed Principle

Originator

@Override

-211

6, 21, 37, 44, 101, 452

.57

213

293

31 515

private

privateなコンストラクタ

Product

Subject 役 129 synchronized

63

276,349 -340,354, 409

54 T

protected..

Prototype パターン

129, 406 Target

Prototype

Proxy パターン

Proxy役

public

Publish-Subscribe/->

-25

P

67, 73, 127, 297, 372

-80

Template Method ->

34, 58, 99, 143, 180, 224, 418

339, 342 TerminalExpression f

349 this

-395

127

59 toString F..

-280

R

readAll Bytes メソッド readAllLines メソッド

readString メソッド

RealSubject役

Receiver

U UML

RefinedAbstraction 12

repeat メソッド

RMI

S

shallow copy 84

Singleton パターン

308, 321, 331, 339 Singleton -65 sort メソッド ･161 splitメソッド 391 State パターン -67, 159, 297, 302 State役 -316 static Factory Method - -57, 63, 147, 339 Strategy 3-y 43, 146, 192 Strategy 157 subclass responsibility 44, 112, 166, 180, 271, 385

58, 62, 127, 147, 245,

166

192 UnsharedConcreteFlyweight

xxix

192

192

-367 Visitor/3-7.

335

.349 valueOf メソッド

140

-57, 331, 414

-15, 176, 200, 398

Visitor ..

444

-352

211

-293

W

wide interface

Wrapper パターン

writeString *F

18

-111, 192

55

アクセス制御 浅いコピー・ 294,453 84 アダプター 18, 370, 373 アノテーション アルゴリズム・ アンドゥ 6,21 146 284, 373 23, 28, 142, 158, 189, 232, 346, 351, 435, 461 イベント駆動プログラミング・ 100, 142 356 依存性の注入

516 51

入れ子・ 164 インスタンスの作り方・ ･･127 インタフェース .viii, 14, 46, 277 インタフェース (API) ・ix オーバーライド -37, 44, 372, 405 オーバーロード 166, 202

◆か

拡張for文

・10,452

拡張と修正・

型パラメータ

213

カプセル化の破壊

-3,168 サブクラスへの要請・

-284, 293

ガベージコレクション

関数型インタフェース・ 木構造・・

・15,337,340

機能追加

·xxxiv

･439 知ったかぶり ・

・175

機能のクラス階層・

キャスト・

コールスタック 210

互換性･･･ .....

コピーコンストラクタ -85, 86

-27

コンストラクタ 59, 129

さ

再帰性。 -389

再帰的な構造 164, 169, 189

再帰的な呼び出し 206

再利用 265, 277, 376

シーケンス図・・

-44

実装のクラス階層・

集約・ ・xxxiii

.190 熟練プログラマ

・132

･･404

共有

クラス

.245

状態・ -302

状態遷移 308, 319

・326,335 白雪姫・ ・ix

クラス階層

xxxix,58

-44, 132

クラス階層の2つの役割

ストリーム

クラス図

132 スピード

·xxix

158, 274, 339, 350, 417

クラス名

-54,82, 354

シリアライズ 299

-412

クラス名の束縛・

群舞・

继承

継承と委譲・

132

検索構文:

検算･･

交換可能性

スレッドセーフ 正規表現

.245

416

391,396

-82

クラスライブラリ

貴務･･

-xxxvii セキュリティ

175

159, 299

128

・19,28,142 た

192 ･397 ダイアモンド演算子・

.158 多重定義。

ターミナル・エクスプレッション 382, 389

工場

100,277 ダブルディスパッチ

104, 331

168

構文解析:

たらい回し

-383 遅延初期化・

構文木

215,383 遅延評価・

166

-212

-222

417

351

抽象クラス

13, 44, 46, 277

Template Method パターン

34, 58, 99, 143, 180, 224, 418

Visitorパターン・

5517

-15, 176,200, 398

抽象クラスの意義・ -44 抽象的な工場・ 104 抽象メソッド 36, 44, 55, 104, 277 直列化 ディレクトリ 164 ･299 テーブル･･ -319 テキストブロック ·247 デザインパターン (パターン)

Abstract Factory パターン 67, 99, 104, 143, 159, 245 Adapter パターン ・18,143, 192,353,370 Bridge パターン -29, 132 Builder パターン -67, 88, 126 Chain of Responsibilityパターン 222 Commandパターン 83, 175, 233, 297, 356 Composite パターン･･･ 15, 58, 83,99, 127, 164, 192,215,233,339,372,397 Decoratorパターン 29, 83, 176, 178, 353 Event (パターン)・ ・356 Facadeパターン ・67, 99,236,266,399 Factory Method パターン 15,43,48,127,399 Flyweight パターン 67,82,159,321,326,397 Interpreterパターン Iterator パターン Mediatorパターン ・215,376 ･･2,58,215 ・245,250,280 Memento パターン ･･82,284,372 Observerパターン -266, 270, 311 Prototype パターン 67, 73, 127,297,372 Proxyパターン ・339,342 Publish-Subscribeパターン -280 Singleton パターン

Wrapper パターン・

-46, 56, 406

デフォルト実装 テンプレート

18

35, 41, 406

テンプレートメソッド

-34

同一視

透過的

164

351,352

透過的なインタフェース (API)

トークン･･

匿名クラス

188

-370, 450

な

385

ノンターミナルエクスプレッション... 383

は バージョンアップ・ パターン パッケージ････ パッケージ名・ -27 -ix 246 -48 反復子・・ ヒープ・・ -2 338 1人芝居 -58 ヒント情報・・ -279 プール･･ 331 複雑なものを単純に 244 複数と単数の同一視・ 173 部品としての再利用、 -82 部品としての独立性 213 フレームワーク 分割して統治 55, 72 265, 317, 351

-58, 62, 127, 147, 245, 308, 321, 331, 339 State パターン Strategy パターン -67,159,297,302 ま ・43,146,192

マーカーインタフェース･･

84

518 51

.187

マクロ・ +358 マルチスレッド 三二言語: -159, 409, 411, 480 -377 無名クラス -370, 372, 437, 450 メモリ メンバークラス 158, 298, 326, 338, 340 -449 モジュール -296, 453, 454 文字列リテラル・ -247

や

12

AbstractClass 41

Abstract Expression

AbstractFactory

Abstraction

-395

AbstractProduct

-124

Adaptee役

Adapter 12

.230

141

-140 Concrete Visitor

124

Aggregate

Builder役

Concrete Decorator 1.

ConcreteElement

ConcreteFactory.

124

ConcreteFlyweight

211

ConcreteHandler

-335

ConcreteImplementor

ConcreteIterator

11

Concrete Mediator 1

Caretaker

Concrete Product

Client役。

ConcreteObserver 1

Concrete Builder

Concrete Class

ConcreteComponent

-264

-277

.55, 124

Concrete Prototype 1

ConcreteState 1

.80

316

Concrete Strategy

Concrete Subject 1

157

Context役

-276

.25 Creator 1

-25 Decorator

157, 316, 395

Director役

11

.97 Element役

25, 80, 97, 124, 173, 230,

243, 335, 349, 367, 395

Colleague

Facade役

Command役

Flyweight

-264 Handler役

Component

Composite

FlyweightFactory 1

+367 Implementor

173, 187

Concrete Aggregate

ConcreteColleague

ConcreteCommand

.264

Concrete Creator

-211

Invoker{}

Iterator役

Memento役

-367

187

ObjectStructure

276

293

-54

187

.97

211

.242

-335

293

335

-173

12

230

140

Leaf役。 173

.97 Mediator

.41

-367

263

NonterminalExpression

11

Observer 1

-293

395

.55 Originator

211

#91 519

UnsharedConcreteFlyweight 335

Product役 -54 Prototype -80 Proxy -349 RealSubject 349 Receiver -367 RefinedAbstraction 12 140 Singleton 65 State ·316 乱数 Strategy 157 Subject役 -276,349 Target 25 TerminalExpression .395

Visitor 211

◆ら

ライフライン・ XXXvi

ラッパー .18

ラムダ式 322, 364, 412, 437, 468

リスナー

-311, 363

リソース・・・・

158

リフレクション・

-338

レガシーシステム

112

28

518 割引

マクロ・・

マルチスレッド

ミニ言語・・

無名クラス

メモリ

-159, 409, 411, 480 ConcreteElement

-377

-370, 372, 437, 450

158, 298, 326, 338, 340

メンバークラス

モジュール

文字列リテラル・

358 Concrete Decorator

ConcreteFactory

ConcreteFlyweight -

や

Concrete Handler

-449

役

Concrete Implementor

-296, 453, 454 ConcreteIterator

-247 Concrete Mediator

Concrete Observer

-ix

AbstractClass

Abstract Expression

AbstractFactory

Abstraction

AbstractProduct

.211

124

-335

230

Concrete Product

Adaptee

Adapter

141

-264

Aggregate

Builder

Caretaker

Client役。

Colleague

Command

Component

Concrete Builder.

Concrete Class

ConcreteCommand

ConcreteComponent

11

55, 124

Concrete Prototype

41 Concrete State

-395

25, 80, 97, 124, 173, 230, 243, 335, 349, 367, 395

277

Concrete Strategy

-124 ConcreteSubject

.80

-140 ConcreteVisitor

-124

187

.316

.157

Context 役

-25

Creator役,

-157, 316, 395

-276

-25 Decorator

.11 Director 1

-97 Element役

-293

Facade役

Composite

Flyweight

FlyweightFactory

-264 Handler役

-367 Implementor

173, 187

Invokerf

ConcreteAggregate

-173

Iterator役

Concrete Colleague -

12

Leaf役,

-97 Mediator

41

264

Concrete Creator

230

Memento役

NonterminalExpression 1

-367 ObjectStructure ..

-187

Observer 1

395

-55 Originator

335

140

367

11

173

263

-293

242

335

.97

211

-54

.211

187

** 519

Product Prototype 54 80 Proxy役 +349 RealSubject 役 +349 Receiver 役 367 RefinedAbstraction i 140 ラッパー Singleton 12 65 State 役 316 Strategy 2 157 リスナー Subject -276, 349 Target 役 25 リフレクション TerminalExpression .395

UnsharedConcreteFlyweight (

Visitor

◆ら

ライフライン

335

214

xorvi

ラムダ式

18

22, 364, 412, 437,468

乱数:

15

311.368

リソース・

388

レガシーシステム・

צעיר

本書をお読みいただいたご意見、ご感想を以下のURLにお寄せください。

https://isbn2.sbcr.jp/09801/

じゃぱげんご まな にゅうもんだいさんばん Java言語で学ぶデザインパターン入門第3版

2021年11月22日 初版発行

著者:結城 浩

ひろし

発行者: 小川 淳

発行所: SBクリエイティブ株式会社

〒106-0032 東京都港区六本木2-4-5

販売 03(5549)1201 編集 03(5549) 1234

組版:スタヂオ ポップ

印刷:昭和情報プロセス株式会社

装丁 : 米谷テツヤ 本文イラスト: 火取ユーゴ

落丁本 乱丁本は小社営業部にてお取り替えいたします。 定価はカバーに記載されています。

Printed in Japan

ISBN978-4-8156-0980-1

長崎県立 312.02 [長時因書館

