---
name: gof-design-patterns-23
description: GoFの23デザインパターンを10の思考カテゴリに再分類した学習・適用フレームワーク。設計課題の性質に応じて適切なパターンを選択するための実践的ガイド。
---

# GoF 23デザインパターン：思考カテゴリ別適用フレームワーク

## 概要

GoF（Gang of Four）が体系化した23のデザインパターンを、結城浩の分類に基づき「設計上の思考法」の観点から10カテゴリに整理したフレームワーク。設計課題に直面したとき、「何を考えるべきか」から逆引きして適切なパターンを選択できるようにする。

## 使用場面（When to Use）

- オブジェクト指向設計で繰り返し現れる課題に対して、実績ある解法を適用したいとき
- コードレビューやアーキテクチャ議論で、設計意図を共有語彙で伝えたいとき
- 既存コードのリファクタリングにおいて、改善の方向性を見定めたいとき
- 拡張性・保守性・再利用性を意識した設計判断を行いたいとき

## フレームワーク：10カテゴリ × 23パターン

### Category 1: デザインパターンに慣れる
基本的な反復処理とインタフェース変換。最初に学ぶべきパターン。

| パターン | 目的 | 適用場面 |
|---------|------|---------|
| **Iterator** | 集合体の要素を順にアクセスする | コレクション内の要素を内部構造を隠して走査したいとき |
| **Adapter** | インタフェースを変換して再利用する | 既存クラスのAPIが要求仕様と合わないとき |

### Category 2: サブクラスにまかせる
処理の骨組みをスーパークラスで定め、詳細をサブクラスに委ねる。

| パターン | 目的 | 適用場面 |
|---------|------|---------|
| **Template Method** | 処理の骨組みを定義し、具体的処理をサブクラスに委ねる | アルゴリズムの大枠は共通で、一部のステップだけ異なるとき |
| **Factory Method** | インスタンス生成をサブクラスに委ねる | 生成するオブジェクトの型をサブクラスごとに変えたいとき |

### Category 3: インスタンスを作る
オブジェクト生成に関する4つのパターン。

| パターン | 目的 | 適用場面 |
|---------|------|---------|
| **Singleton** | インスタンスを1つに制限する | システム全体で唯一のリソース管理が必要なとき |
| **Prototype** | コピーでインスタンスを作る | クラスからの生成が複雑で、既存インスタンスの複製が効率的なとき |
| **Builder** | 複雑なインスタンスを段階的に組み立てる | 多数のパラメータを持つオブジェクトの生成手順を整理したいとき |
| **Abstract Factory** | 関連する部品群を一貫して生成する | 製品ファミリーの切り替えを容易にしたいとき |

### Category 4: 分けて考える
複雑さを分離して管理可能にする。

| パターン | 目的 | 適用場面 |
|---------|------|---------|
| **Bridge** | 機能の階層と実装の階層を分離する | 機能拡張と実装拡張が独立に進む可能性があるとき |
| **Strategy** | アルゴリズムを交換可能にする | 同一の入力に対して異なるアルゴリズムを動的に切り替えたいとき |

### Category 5: 同一視
異なるものを統一的に扱う。

| パターン | 目的 | 適用場面 |
|---------|------|---------|
| **Composite** | 容器と中身を同一視する | ツリー構造のデータを再帰的に処理したいとき |
| **Decorator** | 飾り枠と中身を同一視する | 既存オブジェクトに動的に機能を追加したいとき |

### Category 6: 構造を渡り歩く
データ構造を走査しながら処理を行う。

| パターン | 目的 | 適用場面 |
|---------|------|---------|
| **Visitor** | 構造を渡り歩きながら処理する | データ構造と処理を分離し、処理の追加を容易にしたいとき |
| **Chain of Responsibility** | 責任を連鎖的にたらい回す | 複数のハンドラの中から適切なものに処理を委ねたいとき |

### Category 7: シンプルにする
複雑な関係をシンプルにまとめる。

| パターン | 目的 | 適用場面 |
|---------|------|---------|
| **Facade** | シンプルな窓口を提供する | 複雑なサブシステムに対する統一的なアクセスポイントが必要なとき |
| **Mediator** | 相談役を1つに集約する | 多数のオブジェクトが相互に通信し、関係が複雑化しているとき |

### Category 8: 状態を管理する
状態の変化・保存・表現に関するパターン。

| パターン | 目的 | 適用場面 |
|---------|------|---------|
| **Observer** | 状態の変化を通知する | あるオブジェクトの変化を複数のオブジェクトに自動通知したいとき |
| **Memento** | 状態を保存・復帰する | アンドゥ機能やスナップショットの仕組みが必要なとき |
| **State** | 状態をクラスで表現する | 状態に応じた条件分岐が増殖し、管理が困難になっているとき |

### Category 9: 無駄をなくす
リソース効率を高める。

| パターン | 目的 | 適用場面 |
|---------|------|---------|
| **Flyweight** | 同じものを共有する | 多数の類似オブジェクトがメモリを圧迫しているとき |
| **Proxy** | 必要になるまで生成を遅延する | 重いオブジェクトの初期化を遅延させ、アクセス制御を加えたいとき |

### Category 10: クラスで表現する
命令や文法規則をオブジェクトとして表現する。

| パターン | 目的 | 適用場面 |
|---------|------|---------|
| **Command** | 命令をオブジェクトにする | 操作の履歴記録、アンドゥ、キューイングが必要なとき |
| **Interpreter** | 文法規則をクラスで表現する | 独自のミニ言語やルールエンジンを構築したいとき |

## 具体的な実行手順

### Step 1: 設計課題の特定
1. 現在のコードで「繰り返し書いている」「変更のたびに多くの箇所を修正する」部分を列挙する
2. 変更の頻度と影響範囲を評価する
3. 「何が変化しやすいか」を明確にする

### Step 2: カテゴリからの逆引き
1. 設計課題を上記10カテゴリのどれに該当するかを判定する
2. 該当カテゴリ内のパターン候補を比較検討する
3. パターンの「登場人物（役）」を自分のコードのクラスに当てはめてみる

### Step 3: パターンの適用判断
1. パターン適用による利点（拡張性、可読性、テスタビリティ）を評価する
2. パターン適用によるコスト（クラス数の増加、間接参照の増加）を評価する
3. 利点がコストを上回る場合にのみ適用を決定する

### Step 4: 実装とレビュー
1. パターンの「役」に対応するクラス・インタフェースを設計する
2. サンプルプログラムを参考にしつつ、自分のドメインに合わせて実装する
3. チームメンバーとパターン名を共有し、設計意図が伝わるかをレビューで検証する

## パターン選択クイックリファレンス

| 設計課題 | 第一候補 | 第二候補 |
|---------|---------|---------|
| if/switchの条件分岐が増殖している | State, Strategy | Command |
| オブジェクト生成が複雑になっている | Builder, Abstract Factory | Factory Method, Prototype |
| 既存クラスのAPIが合わない | Adapter | Facade |
| 機能追加のたびに既存クラスを修正している | Decorator, Visitor | Observer |
| ツリー構造を再帰的に処理したい | Composite | Visitor |
| サブシステムが複雑すぎる | Facade | Mediator |
| 変更通知を複数オブジェクトに配信したい | Observer | Mediator |
| アンドゥ機能が必要 | Memento, Command | - |
| メモリ使用量を削減したい | Flyweight | Proxy |
| 処理の骨組みは同じで詳細だけ変えたい | Template Method | Strategy |

## 注意点

- デザインパターンは「適用すべき」ものではなく「必要に応じて活用する」ものである。過剰適用（over-engineering）に注意
- Singletonはグローバル状態を導入するため、テスタビリティの低下に注意。依存性の注入（DI）との併用を検討
- パターンは単独で使うだけでなく、組み合わせて使うことが多い（例：Abstract Factory + Singleton、Composite + Visitor）
- GoFの23パターンは1994年時点の体系化であり、現代のソフトウェア開発ではDI、リポジトリパターン、CQRS等の追加的なパターンも重要
- パターンの名前を知っていることの価値は、実装の詳細を暗記していることの価値より大きい。設計コミュニケーションの共通語彙として活用する
