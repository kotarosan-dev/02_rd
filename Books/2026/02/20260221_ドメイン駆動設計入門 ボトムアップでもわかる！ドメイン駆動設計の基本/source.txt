ドメイン駆動 設計入門

ボトムアップでわかる! ドメイン駆動設計の基本

成瀬 允宣 著

SE

SHOEISHA

Chapter 14 アーキテクチャ

完成サンプル 収録

学習しやすいパターンからスタート! コードを見ながら基礎を習得! 値オブジェクト ドメインサービス アプリケーション サービス 集約 エンティティ リポジトリ ファクトリ 仕様

ドメイン駆動設計を やさしく学べる入門書!

本書の概要

本書は、「エリック・エヴァンスのドメイン駆動設計」 (ISBN978-4-7981-2196-3、 翔泳社)や「実践ドメイン駆 動設計」 (ISBN978-4-7981-3161-0、 翔泳社)に感銘を受 けた著者が贈る、 ドメイン駆動設計をよりやさしく学べる入 門書です。

ドメイン駆動設計の理解に必要な前提知識と実装パターン を網羅的に学習できます。

対象読者 ドメイン駆動設計を手軽に理解・実践したい方。

本書の特徴 初心者にとって、理解しやすい、 そして実践しやすいパタ ーンからスタート。 具体的なサンプルを交えながら、 ドメイ ン駆動設計に頻出するパターンの目的と記述方法を1つ1つ ボトムアップで解説します 本書で解説するパターンは以下のとおりです。

知識を表現するパターン

・値オブジェクト

. エンティティ . ドメインサービス

アプリケーションを実現するためのパターン リポジトリ アプリケーションサービス ・ファクトリ

知識を表現する、 より発展的なパターン

集約

・仕様

プロフィール

成瀬 宣 (なるせ・まさのぶ)

岐阜県出身。 プログラマ。 プログラミングに初めて触れたのは25 歳のとき。業務システム開発からキャリアをはじめ、 ゲーム、 Webと業種を変えながらもアプリケーション開発全般に従事。 好きな原はDRY 原則。 趣味は車輪の再開発

カバーイラスト iStock.com:imam Fathoni

ドメイン駆動 設計入門

ボトムアップでわかる! ドメイン駆動設計の基本

成瀬 允宣 著

SE HEAD

本書内容に関するお問い合わせについて

このたびは翔泳社の書籍をお買い上げいただき、誠にありがとうございます。 弊社では、読者の皆様からのお問い合わせに適切に対応させていただくため、以下のガイドライン へのご協力をお願い致しております。

下記項目をお読みいただき、手順に従ってお問い合わせください。

ご質問される前に

弊社Webサイトの「正誤表」をご参照ください。 これまでに判明した正誤や追加情報を掲載してい ます。

正誤表 https://www.shoeisha.co.jp/book/errata/

ご質問方法

弊社 Web サイトの 「刊行物Q&A」をご利用ください。

刊行物 Q&A https://www.shoeisha.co.jp/book/qa/

インターネットをご利用でない場合は、FAXまたは郵便にて、 下記翔泳社愛読者サービスセン ターまでお問い合わせください。 電話でのご質問は、お受けしておりません。

回答について

回答は、 ご質問いただいた手段によってご返事申し上げます。 ご質問の内容によっては、回答に 数日ないしはそれ以上の期間を要する場合があります。

ご質問に際してのご注意

本書の対象を越えるもの、 記述個所を特定されないもの、また読者固有の環境に起因するご質問 等にはお答えできませんので、予めご了承ください。

郵便物送付先およびFAX番号 送付先住所 〒160-0006 東京都新宿区舟町5 FAX番号 宛先 03-5362-3818 (株)翔泳社愛読者サービスセンター

※本書に記載されたURL等は予告なく変更される場合があります。

※本書の対象に関する詳細はvページをご参照ください。

※本書の出版にあたっては正確な記述につとめましたが、著者や出版社などのいずれも、本書の内容に対して なんらかの保証をするものではなく、内容やサンプルに基づくいかなる運用結果に関してもいっさいの責任

を負いません。

※本書に掲載されているサンプルプログラムやスクリプト、および実行結果を記した画面イメージなどは、特 定の設定に基づいた環境にて再現される一例です。

※本書に記載されている会社名、製品名はそれぞれ各社の商標および登録商標です。 本書の内容は、2020年1月執筆時点のものです。

DPreface D

はじめに

開発者にとってドメイン駆動設計を学ぶことはその後のエンジニアリングに対す るスタンスを変えうるほどの大きな学びです。

ドメイン駆動設計のコンセプトは単純です。 ビジネスの問題を解決するためにピ ジネスの理解を進め、ビジネスの表現をする。 ビジネスとコードを結びつけて継続 的かつ反復的な改良を施せるように枠組みを作ることにより、 ソフトウェアをより 役立つものにしようというものです。いわば、ソフトウェアシステムにおいて当た り前のことを行おうとしています。

しかし、いざドメイン駆動設計を学ぼうとした初学者の多くは、 その難解さに打 ちのめされてしまいます。 なぜ打ちのめされてしまうのでしょうか。 その原因は多 種多様な専門用語の難しさにあるのではないかと考えます。

ドメイン駆動設計の解説はユビキタス言語という用語の解説から始まります。 ページを少しめくってみればドメインエキスパートという言葉を筆頭に、 境界付け られたコンテキスト、エンティティ、値オブジェクトといった多くの専門用語が現 れます。 これらの用語は当然のことながら、 初学者にとっては初めて見聞きするも のです。 専門用語の中には多くの予備知識を前提とするものが存在し、 ほとんど恐 怖と似たような感情を思い起こさせ、 理解を妨げてしまっています

人が恐怖する原因をご存知でしょうか。

人は知らないことに恐怖します。 たとえ風に揺れるカーテンも、 正体を知らなけ れば幽霊になり替わります。 まさにドメイン駆動設計の専門用語は幽霊で、 恐怖を 与えるものに違いありません。 恐怖は人を鈍らせます。 恐怖は人を遠ざけます。 幽霊が怖い理由はもちろん、 その正体がわからないからです。 怖さを和らげるた めにすべきことは単純です。 幽霊の正体を確かめて、 それがカーテンであることを 知ってしまえばよいのです。

ドメイン駆動設計を学習するうえで登場する用語は大別すると2種類に分かれま す。 ソフトウェアにとって重要な概念を抽出するためのモデリングと概念を実装に 落とし込むためのパターンです。 モデリングに関しては言葉による説明を理解し実 践して学ぶほかありませんが、 パターンに関しては詳細なサンブルをもって説明で きます。 開発者にとって理解しやすいのはもちろん後者です。

そこで本書はモデリングについてはいったん棚上げにして、 具体的なコードを ベースにパターンを集中的に解説し、 全体を通して最終的なコードを提示します。 どこかへ行こうとするとき、 目的地がわからないということはとても不安を覚えま す。 本書が提示するコードは明確な形をもった目的地としてあなたの道しるべにな るものです。

本書はパターンを解説することに重きを置いています。 しかし、 これはパターン を実践することがすなわちドメイン駆動設計の実践であり、 そのすべてであるとい う主張をしているわけではありません。 本書が目的としているのは、ドメイン駆動 設計という巨大な試練に立ち向かうための準備です。 ある知識を理解しようとする とき、また別の知識が手掛かりとなることは多く、なるほど知識は連鎖するもので す。 ドメイン駆動設計という大きなテーマと対峙する準備として必要なことは、 あ らかじめ理解の領地を広げておくことです。

本書から得られるパターンに関しての理解はモデリングを含めたドメイン駆動設 計の全貌を理解するのに役に立つものです。 これからドメイン駆動設計の世界を旅 するあなたの武器となるでしょう。

よりよいソフトウェアを開発するために、 開発者として一段と高みへ上るため に、 あなたがドメイン駆動設計を学ぶことを選んだのは間違いではありません。

2020年1月吉日 成瀬允宣

Acknowledgments 謝辞

本書を執筆するにあたり、 多くの方々に助けをいただき、支えていただきました。

末安章花氏の熱烈な後押しがなければ本書は始まりませんでした。 大平 道介氏が背中を押さなければここまではたどり着けませんでした。 林 宏勝氏の丁寧な査読は多くの言葉に磨きをかけました。 森怜峰氏の鋭いコメントはその度に大幅な加筆につながりました。 松岡幸一郎氏の芯の通った考えは筆者の考察をより強固にしました。 加藤潤一氏の忌憚ない意見は考察の機会を与えてくれました。 増田 亨氏の言葉は筆者に勇気を与えてくれました。

貴重な時間を惜しみなく費やし、支えてくれた彼等に感謝を。 そして私を励まし続けてくれた妻に感謝を。

Introduction 本書の対象読者

本書は主にオブジェクト指向プログラミング言語を用いているソフトウェア開発 者向けに書かれていますが、 これはドメイン駆動設計を実践するにはオブジェクト 指向プログラミング言語が必須であるということを意味しません。 オブジェクト指 向以外のパラダイムをもつ言語であっても、 本書のエッセンスをソフトウェア開発 に役立てることは可能です。

本書を読み進めるには一般的なオブジェクト指向プログラミングの基礎知識が必 要です。 具体的に求められるレベルとしては、クラスとインスタンスについての理 解が必要です。 他にはインターフェース (抽象型) 機能をふんだんに利用している ので、インターフェースを用いたポリモーフィズムの処理の流れは理解しておくと 読み進める助けになります。

本書で取り扱うサンブルコードのプログラミング言語はC#を採用しています。 C#は一般的なオブジェクト指向プログラミング言語としての機能を網羅しており、 また記述方法にあまり癖がない言語と考えているからです。 たとえ C#について まったく知識がなかったとしても、オブジェクト指向プログラミング言語を利用し ている開発者であれば読み換えることはそう難しいことでないでしょう。

いずれにせよ深い知識は必要なく、 コードを書くことを生業とする読者であれば 読み進めることは可能でしょう。

Introduction 取り扱うC#特有の構文

本書ではいくつか C#特有の構文が利用されています。 いずれも冗長さを排除す るための記述ですが、 事前にここで解説をしておきます。

I readonly

フィールド(インスタンス変数) に再代入される可能性があるか否かというのは 貴重な情報です。 再代入が不可能であれば、その値が変化したときのことを考慮せ ずに済みます。

C#ではインスタンス変数に readonly 修飾子を付けることで再代入を不可能に できます。

リスト 1: readonly 修飾子を用いたフィールドの定義

class MyClass

{ } private readonly string invariant; // 再代入不可能 private string variant; // 再代入可能 (------)

なお、 readonly で修飾されたインスタンス変数はコンストラクタ以外で代入を 行うことができません。

リスト2: readonly への代入

class MyClass

{

private readonly string value;

public MyClass(string value) { } this.value = value; // OK

public void ChangeValue(string value) {

} } this.value = value; // コンパイルエラー

プロパティ

プロパティはフィールドに外部からアクセスするための機能です。 リスト3のように 定義すると内部でフィールドが自動実装され、 アクセスできるようになります。

リスト3 プロパティによる定義

class MyClass { } public string Property { get; private set;}

プロパティは値を取得するためのゲッターと値を設定するためのセッターを定義 できます。 ゲッターとセッターはそれぞれ異なるアクセス修飾子を設定できます。 ゲッターのみを定義した場合は読み取り専用のプロパティになり、コンストラクタ でのみ代入が可能になります。

またゲッターやセッターはメソッドのようにふるまいをもたせることも可能です。

リスト 4:ふるまいをもったプロパティ

class MyClass { private string property; public string Property { get { return property; } set { property = value; } } }

Jusing

ファイルなどのリソースを保持するオブジェクトは、オブジェクトが不要になっ たときにリソースの解放するために、 終了処理を実行する必要があります。 C#では そういった終了処理を確実に呼び出すために using 句を利用します。

using 句はオブジェクトのスコープを明示し、スコープから抜ける際にそのオブ ジェクトの終了処理を呼び出します。

vii

r

リスト 5 using句を用いたリソースの取得

using (var connection = new SqlConnection (connectionString))

{

(･･･略･･･)

}

using 句に指定されるオブジェクト (リスト5でいうところのSqlConnection) は IDisposable インターフェースを実装する必要があります。 スコープを抜ける際 IDisposable インターフェースのDispose メソッドが呼び出されます。

Introduction 本書のサンプルの動作環境とサンプルプログラムについて

本書の第14章のサンプルは表1の環境で、問題なく動作することを確認してい ます。

項目

内容

OS

Windows 10 Home

IDE

表1 実行環境

Visual Studio 16.4

付属データのご案内

付属データは、以下のサイトからダウンロードできます。

・付属データのダウンロードサイト

URL https://github.com/nrslib/itddd

【注意

付属データに関する権利は著者および株式会社翔泳社が所有しています。 許可な く配布したり、 Web サイトに転載したりすることはできません。

付属データの提供は予告なく終了することがあります。 予めご了承ください。

viii

| 会員特典データのご案内

会員特典データは、以下のサイトからダウンロードして入手いただけます。 ・会員特典データのダウンロードサイト

URL https:///www.shoeisha.co.jp/book/present/9784798150727

注意

会員特典データをダウンロードするには、 SHOEISHA iD (翔泳社が運営する無料 の会員制度) への会員登録が必要です。 詳しくは、 Web サイトをご覧ください。 会員特典データに関する権利は著者および株式会社翔泳社が所有しています。 許

可なく配布したり、 Web サイトに転載したりすることはできません。

会員特典データの提供は予告なく終了することがあります。 予めご了承ください。

|免責事項

付属データおよび会員特典データの記載内容は、2020年1月現在の法令等に基 づいています。

付属データおよび会員特典データに記載されたURL等は予告なく変更される場 合があります。

付属データおよび会員特典データの提供にあたっては正確な記述につとめました が、著者や出版社などのいずれも、 その内容に対して何らかの保証をするものでは なく、 内容やサンプルに基づくいかなる運用結果に関してもいっさいの責任を負い ません。

付属データおよび会員特典データに記載されている会社名、製品名はそれぞれ各 社の商標および登録商標です。

著作権等について

付属データおよび会員特典データの著作権は、著者および株式会社翔泳社が所有 しています。 個人で使用する以外に利用することはできません。 許可なくネット ワークを通じて配布を行うこともできません。 個人的に使用する場合は、ソース コードの改変や流用は自由です。 商用利用に関しては、 株式会社翔泳社へご一報く ださい。

2020年1月 株式会社翔泳社 編集部

取り扱うC#特有の構文/本書のサンプルの動作環境とサンプルプログラムについて

D Contents

015

vi

目次

はじめに 謝辞 本書の対象読者 取り扱う C#特有の構文 本書のサンプルの動作環境とサンプルプログラムについて viii

ドメイン駆動設計とは

Chapter 1

001

1.1 ドメイン駆動設計とは何か 002 1.2 ドメインの知識に焦点をあてた設計手法 003 1.2.1 ドメインモデルとは何か 004 1.2.2 知識をコードで表現するドメインオブジェクト 006 1.3 本書解説事項と目指すゴール 007 COLUMN ドメイン駆動設計の実践を難しくするもの 009 1.4 本書で解説するパターンについて 010 1.4.1 知識を表現するパターン 011 1.4.2 アプリケーションを実現するためのパターン 1.4.3 知識を表現する、より発展的なパターン COLUMN なぜいま、ドメイン駆動設計か 011 012 014

システム固有の値を表現する 「オブジェクト」

Chapter 2

2.1 値オブジェクトとは 016 2.2 値の性質と値オブジェクトの実装 019 019 2.2.1 不変である COLUMN 不変のメリット 021 2.2.2 交換が可能である 022 2.2.3 等価性によって比較される 023 2.3 値オブジェクトにする基準 028 2.4 ふるまいをもった値オブジェクト 033 035 2.5 値オブジェクトを採用するモチベーション 036 037

2.4.1 定義されないからこそわかること

2.5.1 表現力を増す

2.5.2 不正な値を存在させない

039

2.5.3 誤った代入を防ぐ 2.5.4 ロジックの散在を防ぐ

2.6 まとめ

Chapter 3 ライフサイクルのあるオブジェクト 「エンティティ」

047

3.1 エンティティとは 3.2 エンティティの性質について 3.2.1 可変である COLUMN セーフティネットとしての確認 048 049 049 052 3.2.2 同じ属性であっても区別される 052 3.2.3 同一性をもつ 055 3.3 エンティティの判断基準としてのライフサイクルと連続性 058 3.4 値オブジェクトとエンティティのどちらにもなりうるモデル_059 3.5 ドメインオブジェクトを定義するメリット 059

3.5.1 コードのドキュメント性が高まる

3.5.2 ドメインにおける変更をコードに伝えやすくする 3.6 まとめ

Chapter 4

不自然さを解決する 「ドメインサービス」

4.1 サービスが指し示すもの 4.2 ドメインサービスとは

046

4.2.1 不自然なふるまいを確認する 4.2.2 不自然さを解決するオブジェクト 4.3 ドメインサービスの濫用が行き着く先

4.3.1 可能な限りドメインサービスを避ける

4.4 エンティティや値オブジェクトと共に ユースケースを組み立てる

4.4.1 ユーザエンティティの確認

4.4.2 ユーザ作成処理の実装

COLUMN ドメインサービスの基準

4.5 物流システムに見るドメインサービスの例

066

4.5.1 物流拠点のふるまいとして定義する

4.5.2 輸送ドメインサービスを定義する

COLUMN ドメインサービスの命名規則 4.6 まとめ

067

069

070

078

079

079

065

066

072

073

073

075

081

040

043

082

083

060

062

063

Chapter 5 データにまつわる処理を分離する「リポジトリ」

085

086

5.1 リポジトリとは

COLUMN リポジトリはドメインオブジェクトを際立たせる 087

5.3 リポジトリのインターフェース

087

5.2 リポジトリの責務

092

COLUMN nullOption

094

5.4 SQL を利用したリポジトリを作成する

5.5 テストによる確認

094

098

5.5.1 テストに必要な作業を確認する

5.5.2 祈り信者のテスト理論

5.5.3 祈りを捨てよう

099

099

5.6 テスト用のリポジトリを作成する

5.7 オブジェクトリレーショナルマッパーを用いた

リポジトリを作成する

100

100

5.8 リポジトリに定義されるふるまい

5.8.1 永続化に関するふるまい

104

108

5.8.2 再構築に関するふるまい

5.9 まとめ

Chapter 6 」

ユースケースを実現する アプリケーションサービス

108

109

【COLUMN アプリケーションサービスという名前

6.2 ユースケースを組み立てる

114

6.2.1 ドメインオブジェクトから準備する

6.2.2 ユーザ登録処理を作成する

6.4.1 凝集度が低いアプリケーションサービス 6.5 アプリケーションサービスのインターフェース 6.6 サービスとは何か

111

6.1 アプリケーションサービスとは

113

114

115

115

6.2.3 ユーザ情報取得処理を作成する

119

COLUMN 煩わしさを減らすために

120

6.2.4 ユーザ情報更新処理を作成する

COLUMN エラーかそれとも例外か

6.3 ドメインのルールの流出

127

127

6.2.5 退会処理を作成する

133

6.4 アプリケーションサービスと凝集度

134

135

144

147

153

155

6.6.1 サービスは状態をもたない 6.7 まとめ

Chapter 7 柔軟性をもたらす依存関係のコントロール

156

Chapter 8

159

7.1 技術要素への依存がもたらすもの 7.2 依存とは 160 161 7.3 依存関係逆転の原則とは 165 7.3.1 抽象に依存せよ 166 7.3.2 主導権を抽象に 167 7.4 依存関係をコントロールする 168 7.4.1 Service Locator パターン 170 7.4.2 loC Container パターン 175 7.5 まとめ 178

ソフトウェアシステムを組み立てる

8.1 ソフトウェアに求められるユーザーインターフェース COLUMN ソフトウェアとアプリケーションの使い分け 8.2 コマンドラインインターフェースに組み込んでみよう COLUMN シングルトンパターンと誤解 8.2.1 メインの処理を実装する

8.3 MVC フレームワークに組み込んでみよう

8.3.1 依存関係を設定する

8.3.2 コントローラを実装する

COLUMN コントローラの責務

8.4 ユニットテストを書こう

179

185

157

192

180

181

182

183

186

8.4.1 ユーザ登録処理のユニットテスト

8.5 まとめ

COLUMN 本当に稀な怪談話

Chapter 9

195

複雑な生成処理を行う「ファクトリ」

9.1 ファクトリの目的 9.2 採番処理をファクトリに実装した例の確認 COLUMN ファクトリの存在に気づかせる

196

196

203

204

205

206

207

213

180

9.2.1 自動採番機能の活用 214 9.2.2 リポジトリに採番用メソッドを用意する 216 9.3 ファクトリとして機能するメソッド 218 9.4 複雑な生成処理をカプセル化しよう 220 COLUMN ドメイン設計を完成させるために必要な要素 221 9.5 まとめ 221

Chapter 10

データの整合性を保つ

223

10.1 整合性とは

224

225

10.2 致命的な不具合を確認する

10.3 ユニークキー制約による防衛

228

10.3.1 ユニークキー制約を重複確認の主体としたときの

問題点 228 10.3.2 ユニークキー制約との付き合い方 230 10.4 トランザクションによる防衛 231 10.4.1 トランザクションを取り扱うパターン 232 10.4.2 トランザクションスコープを利用したパターン 235 10.4.3 AOP を利用したパターン 237 10.4.4 ユニットオブワークを利用したパターン 239 COLUMN 結局どれを使うべきか 250 10.4.5 トランザクションが引き起こすロックについて 250 250 10.5 まとめ

Chapter 11

アプリケーションを1から組み立てる

11.1 アプリケーションを組み立てるフロー

251

252

252

11.2 題材とする機能

253

253

262

11.2.1 サークル機能の分析

11.3 サークルの知識やルールをオブジェクトとして準備する

11.4 ユースケースを組み立てる

11.4.1 言葉との齟齬が引き起こす事態

11.4.2 漏れ出したルールがもたらすもの

258

263

11.5 まとめ

266

XIV

Chapter 12

ドメインのルールを守る 「集約」

12.1 集約とは

267

12.1.1 集約の基本的構造 COLUMN 集約を保持するコレクションを図に表すか 268 272 12.1.2 オブジェクトの操作に関する基本的な原則 12.1.3 内部データを隠蔽するために 273 276 COLUMN よりきめ細やかなアクセス修飾子 (Scala) 280 12.2 集約をどう区切るか 280 12.2.1 ID によるコンポジション 285 COLUMN IDのゲッターに対する是非 288 12.3 集約の大きさと操作の単位 289 COLUMN 結果整合性 12.4 言葉との齟齬を消す 125 まとめ 290 291 292

Chapter 13

複雑な条件を表現する 「仕様」

13.1 仕様とは 294 13.1.1 複雑な評価処理を確認する 294 13.1.2 「仕様」 による解決 297 13.1.3 リポジトリの使用を避ける 299 13.2 仕様とリポジトリを組み合わせる 302 13.2.1 お勧めサークルに見る複雑な検索処理 302 13.2.2 仕様による解決法 304 13.2.3 仕様とリポジトリが織りなすパフォーマンス問題 307 13.2.4 複雑なクエリは 「リードモデル」で 309 COLUMN 遅延実行による最適化 314

13.3 まとめ

Chapter 14 アーキテクチャ

316

317

14.1 アーキテクチャの役目 14.1.1 アンチパターン: 利口なUI 14.1.2 ドメイン駆動設計がアーキテクチャに求めること 14.2 アーキテクチャの解説 14.2.1 レイヤードアーキテクチャとは

318

318

268

321

293

322

322

14.2.2 ヘキサゴナルアーキテクチャとは 14.2.3 クリーンアーキテクチャとは 14.3 まとめ

Chapter 15

ドメイン駆動設計のとびらを開こう

334 338 342

343

15.1 軽量 DDDに陥らないために

344

344

345

COLUMN パターンの濫用とパターンを捨てるとき

15.2 ドメインエキスパートとモデリングをする

15.2.1 本当に解決すべきものを見つけよう

15.2.2 ドメインとコードを結びつけるモデル

15.3 ユビキタス言語

347

Appendix 付録

348

349

15.3.1 深い洞察を得るために

352

15.3.2 ユビキタス言語がコードの表現として使われる

COLUMN ユビキタス言語と日本語の問題

INDEX

374

353

15.4 境界付けられたコンテキスト

15.5 コンテキストマップ

15.5.1 テストがチームの架け橋に 15.6 ボトムアップドメイン駆動設計 15.7 まとめ

354

ソリューション構成

355

A.1 ソフトウェア開発の最初の一歩 COLUMN C#特有のプロジェクト管理用語 366 366 A.1.1 ドメインレイヤーのパッケージ構成 367 A.1.2 アプリケーションレイヤーのパッケージ構成 369 A.1.3 インフラストラクチャレイヤーのパッケージ構成 370 A.2 ソリューション構成 370 A.2.1 すべてを別のプロジェクトにする 371 A.2.2 アプリケーションとドメインだけ 同じプロジェクトにする A.2.3 言語機能が与える影響 A.3 まとめ 372 373 373

360

365

参考文献

362

363

364

374

xvi

Chapter 1

ドメイン駆動設計とは

ドメイン駆動設計が目指すゴールと本書が目指す ゴールを確認します。

ドメイン駆動設計はエリック・エヴァンス氏が提唱す る設計手法です。 書籍 『エリック・エヴァンスのドメ イン駆動設計』に端を発したこの考えは、いまやソフ トウェア開発の世界に大きな影響を与えています。 本章ではまずドメイン駆動設計が何かを知ることから 始め、本書が提示するゴールとそこへの道のりを確認 します。 各章で紹介するトピックの概要とそれらの関 係性についての説明は本書を読み進めるあなたの道 しるべとなるでしょう。

DDD 1.1

ドメイン駆動設計とは何か

ソフトウェアを開発するとき、 私たちは新たに何かを学びます。 たとえば会計シ ステムを開発するのであれば経理について学ぶでしょう。 物流システムを開発する のであれば輸送や配送について学びます。 ソフトウェアシステムを開発する上で学 んだ知識は汎用的な知識であることもあれば、 ある組織特有の知識である場合もあ ります。

開発者はソフトウェアの利用者を取り巻く世界について基本的に無知です。 彼ら の問題を解決するために開発者が彼らの世界を学ぶことは当然ながら必要なことで す。 しかしながら、 そのようにして学んだ知識がそのままソフトウェア開発の役に 立つことは稀です。

たとえば物流システムを例に考えてみましょう。 トラックの積載容量や燃費など の概念は物流システムにとって利用価値の高い知識です。 しかし、 トラックの語源 がラテン語のtrochus で、 その意味は 「鉄の輪」 であるといった知識は物流システ ムにとってほとんど無価値でしょう。 知識は取捨選択される必要があります。

利用者にとって役に立つソフトウェアを開発するためには、価値ある知識と無価 値な知識を慎重に選り分けて、 選び抜かれた知識をコードに落とし込む必要があり ます。 そうした手順を踏んで作り上げられたコードは有用な知識が込められたド キュメントの様相を呈してきます。

開発者がソフトウェアを開発するために必要な知識と不要な知識を選り分けるに は何が必要でしょうか。 当たり前のことですが、 ソフトウェアの利用者を取り巻く 世界について知る必要があります。 ソフトウェアの利用者にとって重要な知識が何 であるのかは、その世界の有り様に左右されるのです。 価値あるソフトウェアを構 築するためには利用者の問題を見極め、 解決するための最善手を常に考えていく必 要があります。 ドメイン駆動設計はそういった洞察を繰り返しながら設計を行い、 ソフトウェアの利用者を取り巻く世界と実装を結びつけることを目的としていま す。

あなたが学んだ知識はそれが何であろうと、 貴重なあなたの人生の時間をいくば くか費やした、とても大切なものです。 知識がコードに埋め込まれ、 ソフトウェア となって直接的に誰かを支援する。 そこに喜びを覚えない開発者はいないでしょ う。 ドメイン駆動設計はまさに知識をコードへ埋め込むことを実現するのです (図 1.1).

ドメイン駆動

002

知識をコードへ <1>

図1.1 知識をコードへ

DDD 12

ドメインの知識に焦点をあてた 設計手法

ドメイン駆動設計はその名のとおり、 ドメインの知識に焦点をあてた設計手法で す。 この説明はすぐに次の疑問を呼び起こします。 すなわち 「ドメインとは何か」 という疑問です。 まずはしっかりとドメインという言葉が何なのかということから 確認をしていきます。

ドメインは 「領域」 の意味をもった言葉です。 ソフトウェア開発におけるドメイ ンは、「プログラムを適用する対象となる領域」 を指します。 重要なのはドメインが 何かではなく、ドメインに含まれるものが何かです。

たとえば会計システムを例にしてみましょう。 会計の世界には金銭や帳票といっ た概念が登場します。 これらは会計システムのドメインに含まれます。 物流システ ムであればどうでしょうか。 会計システムとは打って変わって貨物や倉庫、 輸送手 段などの概念が存在し、 それらがそのまま物流システムのドメインに含まれます。 このようにドメインに含まれるものはシステムが対象とするものや領域によって大 きく変化します (図1.2)。

次に 「知識に焦点をあてる」 というのはどういうことでしょうか。

ソフトウェアにはその利用者が必ず存在します。 ソフトウェアの目的は利用者の ドメインにおける何らかの問題の解決です。 彼らが直面している問題を解決するに は何が必要でしょうか。 当たり前のことですが、 「彼らが直面している問題」を正確 に理解することが必要です。 利用者が何に困っていて何を解決したいと考えている のかを知るには、 彼らの考えや視点、取り巻く環境を真に理解する必要があります。 つまりドメインと向き合う必要があるのです。

ドメインの概念や事象を理解し、その中から問題解決に役立つものを抽出して得

OC

会計システム 物流システム |||||| 金钱 帳票 品 倉庫 貨物 輸送手段

図1.2: システムごとのドメインに含まれる要素

られた知識をソフトウェアに反映する。 こういったことはソフトウェアを開発する 上で当たり前の行為です。 しかし同時に技術指向の開発者であればあるほど疎かに しやすい工程でもあります。

たとえば最新のフレームワークや開発手法、 最新技術といったワードは開発者の 心を躍らせるものです。 本来であれば問題を解決するにはその問題と向き合うこと が求められますが、 技術指向の開発者は技術的なアプローチで解決を図ろうとして しまいがちです。 結果としてできあがったものが的外れなソフトウェアでは目もあて られません。ピカピカのハンマーは開発者の目を曇らせ、 見るものすべてを釘に変え てしまうのです。

こういった悲惨な結果を招かないためにも、ソフトウェアを適用する領域 (ドメ イン)と向き合い、 そこに渦巻く知識に焦点をあてる必要があります。 よく観察し、 よく表現すること。 ソフトウェアを構築する上で当たり前の行為です。 しかし当た り前のことを実践することこそが難しいのです。 ドメイン駆動設計のプラクティス はその実践を補佐するでしょう。 ドメイン駆動設計はいわば当たり前を当たり前に 実践するための開発手法なのです。

1.2.1 ドメインモデルとは何か

モデルという言葉は開発者にとって身近な言葉です。 世に多く存在するソフト ウェア開発に関する文献を紐解いてみれば、頻繁といっても差し支えないほどの頻 度でモデルという言葉に出会えることでしょう。 書籍 「エリック・エヴァンスのド

004

メイン駆動設計」 においてもこれは同様で、モデルという言葉は第1部の部題 (第 1部 ドメインモデルを機能させる) に登場しています。

開発者にとって身近な存在のモデルですが、さてモデルとは何でしょうか。 改め て問われると、 案外答えづらいものではないでしょうか。

モデルとは現実の事象あるいは概念を抽象化した概念です。 抽象は抽出してる という言葉のとおり、 現実をすべて忠実に再現しません。 必要に応じて取捨選択を 行います。 何を取捨選択するかはドメインによります。

たとえばペンはどのような性質を抽出すべきでしょうか。小説家にとってペンは 道具で、 文字が書けることこそが大事な性質です。 一方、 文房具店にとってペンは 商品です。 文字が書けることよりも、 その値段などが重要視されます。 このことが 指し示すのは、対象が同じものであっても何に重きを置くかは異なるということで す (図1.3)。

図1.3: 道具としてのペンと商品としてのペン

人の営みは根本的に複雑です。 ドメインの概念を完全に表現しきることはとても 難しいです。 何かと制約の多いコードで表現するとなれば尚のことです。 しかし、 ソフトウェアがその責務を全うするために必要な情報に限定をすれば、コードで表 現することも現実的になります。 たとえば物流システムにおいて、 トラックは 「荷 運びできる」ことを表現すればそれで十分です。 「エンジンキーを回すとエンジンが かかる」 といったことまで表現する必要はありません。

こういった事象、 あるいは概念を抽象化する作業がモデリングと呼ばれます。 そ の結果として得られる結果がモデルです。 ドメイン駆動設計では、 ドメインの概念 をモデリングして得られたモデルをドメインモデルと呼びます。

ドメインモデルはこの世界に初めから存在しているわけではありません。 ドメイ ンの世界の住人はドメインの概念についての知識はあっても、ソフトウェアにとっ て重要な知識がどれかはわかりません。 反対に開発者はソフトウェアにとって重要 な知識を判別できても、 ドメインの概念についての知識がありません。 ドメインの

問題を解決するソフトウェアを構築するために、両者は協力してドメインモデルを 作り上げる必要があります。

1.2.2 知識をコードで表現するドメインオブジェクト

ドメインモデルはあくまでも概念を抽象化した知識にとどまります。 残念ながら 知識として抽出しただけでは問題を解決する力はありません。 ドメインモデルは何 かしらの媒体で表現されることで、 問題解決の力を得ます。

ドメインモデルをソフトウェアで動作するモジュールとして表現したものがドメ インオブジェクトです。

どのドメインモデルをドメインオブジェクトとして実装するかは重要な問題で す。 開発者は真に役立つモデルを選り分ける必要があります (図1.4)。 長い時間を かけて作り上げたドメインモデルであっても、それが利用者の問題の解決に何ら関 わりのないものであれば、 ドメインオブジェクトとして実装することはただの徒労 になってしまいます。

図1.4 ドメインモデルの取捨選択

ソフトウェアの利用者を取り巻く世界が常に凝り固まったものとは限りません。 人の営みは移ろいやすく、 ときの流れと共に変化します。 変化の多くは軽微なもの が積み重なるものですが、ときには常識すらも変わるでしょう。 そんなときドメイ ンオブジェクトがドメインモデルを忠実に表現していれば、 ドメインの変化をコー ドに伝えることはたやすいです。

ドメインで起こった変化はまずドメインモデルに伝えられます。

ドメインの概念の射影であるドメインモデルは、変化を忠実に受け止めます。 ド メインオブジェクトはドメインモデルの実装表現ですから、変化したドメインモデ ルと変化していないドメインオブジェクトの両者を見比べてみれば、 自ずと修正点 は浮き彫りになるでしょう。 ドメインの変化はドメインモデルを媒介にして連鎖的

006

にドメインオブジェクトまで伝えられるのです。

また反対にドメインオブジェクトがドメインに対する態度を変化させることもあ ります。 プログラムは人の曖昧さを受け入れられません。 ドメインに対する曖昧な 理解は実装の障害となります。 それを解決するにはドメインモデルを見直し、 ひい てはドメインの概念に対する捉え方を変える必要があるでしょう。 ドメインに対す る鋭い洞察は実装時にも得られるものなのです。

かくしてドメインの概念とドメインオブジェクトはドメインモデルを媒介に繋が り、お互いに影響し合うイテレーティブ (反復的) な開発が実現されます (図1.5)。

ドメインの 概念 ドメイン モデル ドメイン オブジェクト

図1.5 イテレーティブな開発

DDD

1.3 本書解説事項と目指すゴール

ドメイン駆動設計を理解するのは難しいといわざるを得ません。 ドメイン駆動設 計の学習を進めるとまるで翻弄するかのように多くの概念や用語が出てきます。 こ れは多くの初学者を混乱させ、 恐怖に陥れます。

知識は連鎖するものです。 ある知識を得るために、 前提として異なる知識が求め られることは多くあります。 ドメイン駆動設計で語られる概念や用語を理解するた めには、その結論に至る過程で得られる多くの前提知識を要求します。 ひとつひと 一つは些細な知識であったとしても、それがいくつもとなると対応するのは難しいも のです。

もうひとつ重大な問題があります。 ドメイン駆動設計のプラクティスにはそもそ も実践の難しいものが存在するということです。 百聞は一見に如かずという言葉も あるとおり、 知識を理解に落とし込むための最善の手段は実践です。 残念ながらド メイン駆動設計のプラクティスには、実践するためにある程度の環境を要求するも

OC

のも存在します。

とはいえ、理解が難しく実践も難しいとあってはいつまで経ってもドメイン駆動 設計の世界に踏み込めません。 そこで本書では概念の理解や実践が難しいものを一 旦棚上げし、 理解と実践がしやすい実装に関するパターンに集中してボトムアップ で解説していきます。 概念の前提となる知識も、その都度必要に応じて解説します。 そうして少しずつ理解の領地を広げていって、 ドメイン駆動設計の本質に立ち向か う準備を完了することをゴールとします (図1.6)。

Goal

図1.6:ボトムアップでゴールに向かう

008

COLUMN ドメイン駆動設計の実践を難しくするもの

ドメイン駆動設計はソフトウェア開発をテーマにしています。 ソフトウェア開発 の現場には実際に手を動かすかの違いがあるものの、関係者が複数存在します。 し たがって、 ドメイン駆動設計のトピックは実装だけに留まらず、 関係者とのコミュ ニケーションやチームビルディングと密接に関わるものが存在します。 つまり開発 者個人に収まらず、 多くの関係者を巻き込む必要があるのです。

たとえばドメインモデルを形作る作業を開発者だけで完結することは不可能で す。 ドメインの概念に対する捉え方はドメインの実践者の視点が欠かせません。 開 発者はドメインの実践者の助力を得る必要があります。 しかし、残念ながらそれが 叶わない現場も多いでしょう。

もしあなたがそういった環境に置かれていても悲観することはありません。 ドメ イン駆動設計のすべてのトピックがそういった類のものとは限りません。 ドメイン 駆動設計はソフトウェア開発を包括的に取り扱った設計手法です。 そこには開発者 個人の裁量で実践できるプラクティスも多くあります。 本書で学ぶパターンはまさ に今すぐ実践できる類のものです。

ドメイン駆動設計に関わらず、 設計にはある種の理想としての側面があります。 重要なのは理想を無理やり現実に当て込むことではなく、現実に適合させるために 取るべき手段を考え選択することです。 理想を掲げ、 妥協しなくてはならないとき に、 どこを妥協するのか悩むのもまたソフトウェア開発の楽しみ方の1つです。

ドメイン駆動設計は当たり前のことを当たり前にやるためのプラクティスです。 当たり前とはどういうことなのか。 それを実現するための手法を知っているのと知 らないのでは大きな違いです。 もし、 あなたがドメイン駆動設計のすべてを実践で きない環境にいたとしても、 あなたが開発者として学びを得るためにドメイン駆動 設計を選んだのは決して間違いではありません。

DDD 14

本書で解説する

パターンについて

目的地を知らされずに道を辿ることは、さながら迷路を彷徨うようなものです。 ドメイン駆動設計に関わらず、 同じ道のりであっても、目的地までどれくらいなの か、いま自分がどこにいるのかさえわかっていればペース配分を考えられます。 こ こで一度、 本書で学ぶドメイン駆動設計のパターンを俯瞰しておきましょう。

・知識を表現するパターン

・値オブジェクト

エンティティ

・ドメインサービス

アプリケーションを実現するためのパターン

リポジトリ

・アプリケーションサービス

ファクトリ

・知識を表現する、 より発展的なパターン

・集約

仕様

これらはドメイン駆動設計に登場する代表的なパターンです。 本書ではこの一覧 の順序で解説していきます。

パターンはドメインの知識を表現するためのパターンとアプリケーションを実現 するためのパターンに分けられます。 これらの関係性を図に表したのが図1.7で す。

010

アプリケーションを実現するためのパターン ドメインの知識を表現するためのパターン

アプリケーション サービス ファクトリ リポジトリ 集約 ドメイン サービス 值 利用する オブジェクト 仕様 エンティティ

図1.7 用語の関連性

1.4.1 知識を表現するパターン

最初に解説するのは知識を表現するパターンです。 まずはドメインの知識をオブ ジェクトとして表現するドメインオブジェクトを理解することから始めます。 値オブジェクト (第2章) はドメイン固有の概念 (金銭や製造番号など) を値と して表現するパターンです。 その概念や目的はとても理解しやすいものです。 まさ

にドメイン駆動設計を学ぶ足掛かりとして最適な概念です。

次に学ぶのはエンティティ (第3章) です。 エンティティは値オブジェクトと同 じくドメインの概念を表現するオブジェクトですが、 値オブジェクトと対を為すよ うな性質があります。 値オブジェクトで学んだことはそのままエンティティを理解 するのに役に立ちます。 エンティティを学ぶのは値オブジェクトを学んだ直後が最 適です。

ドメインサービス (第4章) は値オブジェクトやエンティティではうまく表現で きない知識を取り扱うためのパターンです。 値オブジェクトとエンティティがどう いったもので、 どういったことができるのかを確認してから学習に臨むと理解がし やすいため、値オブジェクトとエンティティを把握した後に学びます。

1.4.2 アプリケーションを実現するためのパターン

ドメインの知識を表現しただけではドメインの写しがコードとして表現されてい るだけに過ぎません。 ソフトウェアに求められる必要は満たされていません。 した

L

01

がって、 知識の表現方法を学んだ後は、 利用者の必要を満たすアプリケーションを 構築するための手法を学びます。

リポジトリ (第5章) はデータの保存や復元といった永続化や再構築を担当する オブジェクトです。 データの永続化というとリレーショナルデータベースなどの具 体的なデータストアが思い浮かびますが、 リポジトリはそれらを抽象化するもので す。 データの永続化を抽象化することでアプリケーションは驚くほどの柔軟性を発 揮します。

値オブジェクト・エンティティ・ドメインサービス リポジトリの4つの要素で 最低限の準備が整い、 アプリケーションとして組み立てることができます。 これら の要素を協調させ、アプリケーションとして成り立たせる場がアプリケーション サービス(第6章) と呼ばれるものです。 本書ではアプリケーションサービスにつ いて学んだのちに、 実際に動作可能なWebアプリケーションへ組み込みを行いま す。

Webアプリケーションとして動作させるところまで確認した次はファクトリ (第9章) を学びます。 ファクトリはオブジェクトを作る知識に特化したオブジェク トです。 複雑な機構をもつものは得てしてその生成方法も複雑になりがちで、 それ はドメインオブジェクトであっても同じです。 複雑なオブジェクトの生成方法はあ る種の知識となります。 オブジェクトの生成は至るところで発生します。 対策せず にいると煩雑な手順はコードの至る所にばらまかれ、 処理の趣旨をぼやけさせるで しょう。ファクトリを利用して生成に関する知識を一箇所にまとめあげることは、 ドメインオブジェクトを際立たせ、 処理の趣旨を明確にするために必要なことで す。

1.4.3 知識を表現する、 より発展的なパターン

集約と仕様は知識を表現するオブジェクトですが、 より発展的なパターンです。 ここまでの内容にひとしきり慣れた上で学習に臨むとよいでしょう。

集約 (第12章)は整合性を保つ境界です。 値オブジェクトやエンティティといっ たドメインオブジェクトを束ねて複雑なドメインの概念を表現します。 前提知識を いくらか要求されるため理解することが難しく、 同時に正しく実践することが難し い代物です。 もちろん前提知識として必要なものはここまでの内容で揃っていま す。 ここまでたどり着けたのであればきっと乗り越えることができる壁です。

集約の後に学ぶ仕様 (第13章) はオブジェクトの評価をします。 オブジェクトが ある特定の条件下にあるかを判定する評価のふるまいをそのオブジェクト自身に実

12

装すると、 オブジェクトが多くの評価のふるまいに塗れて煩雑になってしまうこと があります。 仕様を適用することで、 オブジェクトの評価をモジュールとしてうま く表現できます。

本書は構成上、 前後の章が繋がっています。 各章は単独でも理解できる内容です が、順序に沿って読み進めると、より理解に繋げやすくなることでしょう。

COLUMN なぜいま、ドメイン駆動設計か

ドメイン駆動設計が提唱されたのは2003年頃です。 ITという分野の進化は目覚 ましく、最新の技術も十年過ぎれば陳腐化してしまうといったことは往々にして発 生します。 にもかかわらず昨今のシステム開発の現場において、 ドメイン駆動設計 という言葉を耳にする機会が増えたのには、いったいどのような背景があるので しょうか。

ひと昔前はサービスをいち早く世に出すことこそがもっとも重要なこととされて いたように感じます。 そのためモデリングに重きを置き、 開発の最初期にコストを 支払うドメイン駆動設計は重厚で鈍重なものであると誤解され、 敬遠されていまし た。

とにかく早くサービスを打ち出すことはほとんどミサイルのような片道ロケット に乗ることに似ています。 打ち上げた後に帰ってこれないという欠点に目を瞑れ ば、システム開発の過酷な生存競争に勝つために取れる最良の選択肢でしょう。 そ れに対してモデリングをしっかりと行い、 長期的な運用を視野に入れた設計手法は |飛行機に運用するようなことです。 飛行機は片道ロケットと違って往復することは 可能ですが、 その速度は圧倒的に見劣りします。 それにもかかわらず、 なぜ私たち は片道ロケットの打ち上げ競争を辞めて、 飛行機を安定運用したいと願うように なったのでしょうか。

ソフトウェアは変化するものです。 ごく最初期の局所的な開発速度を優先したソ フトウェアは、柔軟性に乏しく、 変化を吸収しきれません。 ソフトウェアに求めら れる変化に対応するために、 開発者は継ぎはぎのような修正を重ねます。 数年もす ればソフトウェアは複雑怪奇な進化を遂げるでしょう。 それでも時代の変化につい ていくために、開発者は辟易しながら継ぎはぎだらけの修正を積み重ねるのです。 場当たり的な対応に嫌気の差した開発者たちが片道ロケットの打ち上げ競争ではな く、飛行機の安定運用を願うようになるのも想像に難くありません。 救いを求めて 手にしたものの中にドメイン駆動設計がありました。

ドメイン駆動設計はドメインと向き合うことで分析から設計、 そして開発までが 相互作用的に影響し合うよう努力を重ねることを求めます。 ソフトウェアを構築す る最初期においても一定の効果はありますが、 その真価は変化に対応するときにこ そ表れます。 ドメイン駆動設計を取り入れてみた当時はさほど効果が見られなかっ たでしょう。 ときが流れ、段々とドメイン駆動設計が認められてきたのは、 偉大な る先人たちによって撒かれた種が芽吹いてきたからに他なりません。

プログラムは動かすだけなら簡単で、しかし動かし続けることは難しい代物で す。 システムを長期的に運用したいと願うのならば、安定的な飛行機の運用を願う のならば、 ドメイン駆動設計をいまこそ学ぶべきでしょう。

014

Chapter 2

システム固有の値を 表現する 「値オブジェクト」

値オブジェクトはドメインオブジェクトの基本です。

値オブジェクトはドメイン駆動設計を学ぶ足掛かりと して最適です。

なぜなら、 皆さんは値を日常的に取り扱っています。 オブジェクトも日常的に目にしているのではないで しょうか。 値オブジェクトはよく見れば、それらが組 み合わさっただけの言葉です。 知らない言葉に対して 恐怖する必要がありません。

値オブジェクトはその概念もとても単純で、 システム に登場する金銭や単価といった値をオブジェクトとし て定義するというものです。 そのコンセプトを理解す れば 「何だそんなことか」 と拍子抜けしてしまうに違 いありません。

ものごとを理解するには小さな領域で足場を固めて、 段々とその領域を広げるように学んでいくのがよいプ ラクティスです。 理解するのに易しいこの値オブジェ クトを足掛かりとして、 ドメイン駆動設計の世界に足 を踏み入れましょう。

6

4

5

2

DDD 2.1

値オブジェクトとは

プログラミング言語にはプリミティブな値が用意されています。 それらをやりく りしてシステムを組み上げることも可能ですが、 システム固有の値を定義すること がときに必要となります。 このシステム固有の値を表現するために定義されたオブ ジェクトが値オブジェクトと呼ばれるものです。

値オブジェクトがどういったものかを把握するために、 まずは少しコードに触れ ながら 「値」を観察してみましょう。 リスト2.1のコードを確認してください。

リスト2.1 プリミティブな値で 「氏名」 を表現する

var fullName = "naruse masanobu";

Console.WriteLine (fullName); // naruse masanobu が表示される

fullName は文字列型の値を格納する変数で、 「氏名」 を表現しています。 このプ ログラムを実行すれば、 コンソールにはうまく氏名が表示されます。

さて、この氏名ですが、 システムにおける氏名の取り扱い方はさまざまです。 た とえば、あるシステムでは氏名をそのまま表示したいでしょう。 他方のシステムで は姓だけを表示したいときもあります。 その要求に応えるため fullNameを利用し て、姓だけを表示するコードはリスト2.2です。

リスト 2.2 姓だけを表示する

var fullName = "naruse masanobu";

var tokens = fullName.Split(''); // ["naruse", "masanobu"] → という配列に var lastName = tokens [0];

Console.WriteLine (lastName); // naruse が表示される

このコードは意図したとおり、 fullNameから姓だけを取り出して表示します。 少し回りくどいコードにも思えますが、 何しろ fullName は文字列型の値であるた め致し方ありません。 もし、 他にも姓を表示したいことがあったら、このロジック をコピーしてペーストすれば問題ありません。 このプログラムはうまくやっていく でしょう。

・・・・・・果たして本当にそうでしょうか。

016

実はこのロジックは場合によってはうまく動作しません。 リスト2.3のコードを 見てみましょう。

リスト2.3: うまく姓を表示できないパターン

var fullName = "john smith"; var tokens = fullName.Split('');//["john", "smith"] という配列に var lastName = tokens [0]; Console.WriteLine (lastName); // john が表示される

"john smith"氏の姓は "smith" です。 リスト2.3は姓を表示するプログラムであ リスト2.2をそのまま利用しています。 つまり、 "john smith" 氏の姓である "smith" を表示することを期待しています。 しかし、その期待もむなしく、 プログ ラムを実行したときコンソールに表示されるのは、姓ではなく名の "john" です。 残 念ながらリスト2.2の 「姓を表示するプログラム」はうまく動作しません。 世界に は名が前方に配置され、 姓が後方に配置される氏名が存在していたのです。

こういった問題を解決する手段としてオブジェクト指向プログラミングでは一般 にクラスが利用されます (リスト2.4)。

リスト 2.4 氏名を表現する FullName クラス

class FullName

{ public FullName (string firstName, { } FirstName = firstName; LastName = lastName; public string FirstName { get; }

string lastName)

public string LastName { get; }

}

文字列型で扱っていた氏名はFullNameクラスとして定義されました。 姓を取得 したいときは FullNameクラスのLastName プロパティを利用します (リスト 2.5).

01

リスト 2.5 FullNameクラスのLastName プロパティを利用する

var fullName = new FullName("masanobu", "naruse"); Console.WriteLine(fullName.LastName); // naruse が表示される

FullNameクラスはコンストラクタで第1引数に名、 第2引数に姓を指定するよ うになっているので、そのルールさえ守られれば、たとえ姓と名の順序が入れ替わ るような氏名であっても姓を取り出すことが可能です (リスト 2.6)。

リスト 2.6 確実に姓を表示できる

var fullname = new FullName("john", "smith"); Console.WriteLine (fullname.LastName); // smith が表示される

このFullName はその名のとおり氏名を表現したオブジェクトで、 値の表現なの です。

この例からわかることは、システムに最適な値が必ずしもプリミティブな値であ るとは限らないということです。 システムには必要とされる処理にしたがって、 そ のシステムならではの値の表現があるはずです。 FullName クラスはまさにそう いった値の表現です (図2.1)。 オブジェクトであり、 値でもある。ゆえに値オブ ジェクトである。 ドメイン駆動設計ではこのようにシステム固有の値を表したオブ ジェクトを値オブジェクトと呼んでいます。

string string ← FullName string string 値オブジェクト

図2.1:システム固有の値

018

DDD 2.2

値の性質と 値オブジェクトの実装

開発者は 「値」を頻繁に利用します。 数字や文字、 文字列など、 値にはいくつも の種類があります。 普段から何気なく利用しているこれらの値ですが、 実は一定の 性質をもっています。 この性質こそが値オブジェクトを理解する鍵となるのです が、皆さんは値の性質を考えたことはあるでしょうか。

もちろん 「値の性質とは何か」 をいちいち考えながらプログラミングをすること はないでしょう。 そんな哲学的なことは考えずともプログラミングはできます。 値 はあまりにも自然と扱うことができるため、 「値の性質とは何か」といった疑問を抱 くことがほとんどないのです。

値がもつ性質を学ぶことは値オブジェクトを知る上で重要な事柄です。 ここで一 度、値にはどのような性質があるのかしっかりと確認しておきましょう。 代表的な値の性質は次の3つです。

・不変である

・交換が可能である

・等価性によって比較される

値オブジェクトはシステム固有の値の表現であり、 値の一種です。 値がもつ性質 は値オブジェクトにそのまま適用されます。

ここでは値の性質を確認し、 値オブジェクトで実現する方法を確認していきま す。

2.2.1 不変である

値は不変の性質をもっています。 プログラミングにおいて値を変更する操作は日 常的な行為です。 にもかかわらず値は不変であるというのは矛盾しているように感 じるでしょう。 いったいどういうことなのでしょうか。

たとえばリスト2.7は値の変更をしています。

019

22 値の性質と値オブジェクトの実装

リスト2.7: 値の変更をしている

var greet = "こんにちは"; Console.WriteLine(greet); // こんにちは が表示される greet = "Hello"; Console.WriteLine(greet); // Hello が表示される

greetの値は最初は"こんにちは"になっており、 出力したのちに "Hello" に変更 されています。 したがって値は変更できるものです。 不変だなんてとんでもありま せん!・・・・・・果たして本当にそうでしょうか。

私たちは値の変更をするとき代入を利用します。 そう、代入です。 実をいうと代 入は厳密には値の変更をしていません。 代入によって変更しているのは変数の内容 であって、 値そのものを変更しているわけではありません。

値は一貫して変化することがありません。 もしも値を変更できてしまったら、ど のようなことが起こってしまうでしょうか。

実際にコードで確認してみましょう。 リスト2.8のコードは値を変更している疑 似的なコードです。

リスト2.8 「値の変更」を行う疑似コード

var greet = "こんにちは";

greet.ChangeTo("Hello"); // このようなメソッドは本来存在しない

Console.WriteLine(greet); // Hello が表示される

変数 greet には宣言と同時に"こんにちは"という値が代入されています。 続く行 でプログラムはgreet に対して値の変更を行います。 greetの実体は"こんにちは" という値でしたので、"こんにちは"という値は "Hello" に変更されます。 リスト2.8 はまさに 「値の変更」 を行っているコードです。

さて、リスト2.8では気づきにくいのですが、この値の変更は面白い事態を引き 起こします。 つまり、 もしもリスト2.8のコードが許されるのであれば、 リスト2.9 のコードも許されるということです。

リスト2.9 値が変更できることを利用したコード

"こんにちは".ChangeTo("Hello"); // このようなメソッドは本来存在しない Console.WriteLine("こんにちは"); // Hello が表示される

Change To メソッドは値を変更するふるまいです。 Change To メソッドを実行 すると値自体が変更されるため、 "こんにちは"は"Hello" に変更され、 コンソール には "Hello" が表示されます。 この挙動は開発者を大きく混乱させるものでしょう。 値が変更できてしまうと、私たちは安心して値を利用できません。 1という数値 がある日突然0 (ゼロ)になってしまったらどれほどの混乱を引き起こすでしょう か。 1という数値はどこまでいっても1であることが求められます。 値は不変であ るからこそ、安全に利用できるのです。

さて、 値は不変であることが美徳と理解したところで今度はリスト2.10を見て みましょう。

リスト 2.10: 一般的に見られる値の変更

var fullName = new FullName("masanobu", "naruse");

fullName.ChangeLastName("sato");

誰しもが一度はこういったコードを目にしたことはあるでしょう。 このコードは ごくごく自然なものとして、 多くの開発者に受けいれられています。 しかし、 FullNameクラスを値として捉えた場合、 ここには不自然さが存在しています。 そ う、値を変更しているのです。

FullName はシステム固有の値を表している値オブジェクトです。 FullName は 値です。 FullName は不変にすべきです。 値を変更するためのふるまいである ChangeLastName メソッドはFullName クラスに定義されるべきものではありま せん。

COLUMN

不変のメリット

ときにソフトウェア開発はバグとの闘いになることもあります。 バグはさまざま なことを起因として開発者を悩ませますが、 状態の変化もその原因の1つです。 生成したインスタンスをメソッドに引き渡したら、自身のあずかり知らぬところ でいつの間にか状態の変更をされ、 意図せぬ挙動となりバグを引き起こしてしまっ た、といった失敗話は非常にありふれています。

状態の変更を起因とするバグを防ぐために取れるもっとも単純な作戦は、状態を 不変にすることです。 いつの間にか変更されることが問題であるなら、 そもそも変 更できないようにしてしまえばよいのです。 これは単純ながら強力な防衛策です。 状態を変更できないというのはプログラムをシンプルにする可能性を秘めた制約

です。 たとえば並行 並列処理を伴うプログラムでは、 変化する可能性のあるオブ ジェクトに対するアプローチは課題になります。 変化をしないオブジェクトであれ .

. ば、値の変更を考慮する必要がなくなり、 並行 並列処理を比較的容易に実装でき ます。

また他にも、たとえばコンピュータのリソースであるメモリがひっ迫したとき に、オブジェクトをキャッシュする戦略を取ることができます。 状態が変更されな いオブジェクトであれば、まったく同じ状態のオブジェクトを複数準備する必要は ありません。 ひとつのオブジェクトをキャッシュして使いまわすことでリソースの 節約が可能です。

もちろんオブジェクトを不変にすることによるデメリットも存在します。 代表的 なデメリットとして挙げられるのは、オブジェクトの値を一部変更したいときに、 新たなインスタンスを生成する必要があるということです。 これは状態を変更でき るときに比べてパフォーマンスの観点で不利になります。 あまりに深刻な事態とな る場合には値オブジェクトであっても可変を許容するという戦略をとることすらあ るでしょう。

とはいえ、可変なオブジェクトを不変なオブジェクトに変更するのと不変なオブ ジェクトを可変なオブジェクトに変更するのでは、 後者の方が労力は少ないです。 もしも可変にするか不変にするかに迷うようなことがあれば、いったんは不変なオ ブジェクトにしておくとよいでしょう。

2.2.2 交換が可能である

値は不変です。 しかし、ソフトウェアを作るにあたって値を変更せずに目的を達 成するのは難しいでしょう。 値は不変ですが値を変更することは必要です。矛盾し ているようですが、 私たちは普段そのようなことに悩みながらプログラミングはし ません。 私たちが普段どのように値を変更しているかを確認してみましょう (リス +2.11).

リスト 2.11 普段行っている値の変更

// 数字の変更 var num = 0; num = 1; // 文字の変更 var c = '0'; c='b';

022

// 文字列の変更 var greet = "こんにちは"; greet = "hello";

リスト2.11 はいずれも代入をしています。 これは代入こそが値の変更の表現方 法であるということです (リスト2.12)。

「不変」の性質をもつ値はそれ自体を変更できません。 値オブジェクトにおいても これは同じことです。 値オブジェクトの変更は値と同じように代入操作によって交 換をすることで表現されます。

リスト 2.12: 値オブジェクトの変更方法

var fullName = new FullName("masanobu", "naruse"); fullName = new FullName("masanobu", "sato");

リスト2.12 の記述の仕方は、 値の変更 (代入) と同じ記述であることに気づけた でしょうか。 値オブジェクトが不変であるがゆえに、 代入操作による交換以外の手 段で変更を表現できなくなっているのです (図2.2)。

X- Value Value2 Value ↑ Value2

図2.2 交換以外の手段で変更を表現できない

2.2.3 等価性によって比較される

数値同士や文字同士など、 同じ種類の値同士はリスト 2.13のように比較するこ

023

22 値の性質と値オフジェクトの実装

とができます。

リスト 2.13: 同じ種類の値同士の比較

Console.WriteLine (0== 0); // true Console.WriteLine(0: == 1); // false Console.WriteLine('a' == 'a'); // true Console.WriteLine('a' = == 'b'); // false Console.WriteLine("hello" == "hello'); // true Console.WriteLine("hello"=="こんにちは"); // false

たとえば0 == 0 という式の左辺の0と右辺の0はインスタンスとして別個のも のですが、 等価として扱われます。 これが意味することは、 値は値自身でなく、 それを構成する属性によって比較されるということです。 システム固有の値である 値オブジェクトも値と同様に、 値オブジェクトを構成する属性 (インスタンス変数) によって比較されます (リスト2.14)。

リスト2.14 値オブジェクト同士の比較

var nameA = new FullName("masanobu", "naruse"); var nameB = new FullName("masanobu", "naruse"); // 別のインスタンス同士の比較 Console.WriteLine(nameA.Equals (nameB)); // インスタンスを構成する→ 属性が等価なのでtrue

しかし、ことオブジェクト同士の比較となると、 リスト2.15のコードのように属 性を取り出して、直接比較を行ってしまうことがあります。

リスト2.15 属性を取り出して比較

var nameA = new FullName("masanobu", "naruse");

var nameB = new FullName("john", "smith");

var compareResult =

最適化によって同一のインスタンスになることもあります。

024

•1]

nameA.FirstName == nameB.FirstName

&& nameA.LastName == nameB. LastName;

Console.WriteLine (compareResult);

実行可能なモジュールであるという意味でこのコードは正しく、 一見すると自然 なコードに見えます。 しかし、 FullName オブジェクトが値であることを考えると 不自然な記述です。 たとえば数値を例にして、 リスト2.15と同じように値を比較す るとリスト 2.16になります。

リスト2.16 属性を取り出して比較する操作を数値にあてはめる

Console.WriteLine (1.Value == 0.Value); // false ?

ほとんどの読者がリスト2.16のようなコードを見たことはないでしょう。 値の 値 (Value) を取り出すとはいったいどういうことなのでしょうか。 これはいかに も不自然な記述です。

値オブジェクトはシステム固有の値です。 あくまでも値なのです。 その属性を取 り出して比較をするのではなく、 値と同じように値オブジェクト同士が比較できる ようにする方が自然な記述になります (リスト2.17)。

リスト 2.17: 値同士で比較する

var nameA = new FullName("masanobu", "naruse"); var nameB = new FullName("john", "smith");

var compareResult = nameA.Equals (nameB);

Console.WriteLine(compareResult);

// 演算子のオーバーライド機能を活用することも選択肢に入る

var compareResult2 = nameA== nameB;

Console.WriteLine (compareResult2);

このような自然な記述を行うためには値オブジェクトが比較するためのメソッド を提供する必要があります (リスト2.18)。

025

・2 個の性質とオフシュクトの実装

2

リスト2.18: 比較メソッドを提供する FullNameクラス

class FullName: IEquatable<FullName> { public FullName(string firstName, string { } FirstName = firstName; LastName = lastName;

lastName)

public string FirstName { get; } public string LastName { get; }

public bool Equals (FullName other)

{

if (ReferenceEquals (null, other)) return false; if (ReferenceEquals(this, other)) return true; return string.Equals (FirstName, other. FirstName)

} && string.Equals (Last Name, other. LastName);

public override bool Equals(object obj)

if (ReferenceEquals(null, obj)) return false;

if (ReferenceEquals(this, obj)) return true;

if (obj.GetType() != this.GetType()) return false; return Equals((FullName) obj);

}

// C#ではEqualsをoverrideする際にGetHashCodeをoverrideするルールが→ 553

public override int GetHashCode()

{

unchecked

{

{

026

0) * 397)

return ((FirstName != null ? FirstName.GetHashCode(): ->

^ (LastName != null ? LastName.GetHashCode(): 0);

}

}

このコードはC# における典型的な比較の実装方法です。 値オブジェクト同士を 比較する際には値オブジェクトの属性を取り出して比較するのではなく、 Equals メソッドを利用して比較を行います。 これにより値オブジェクトは値と同じように 比較できるようになります。

これだけ大掛かりなコードを書く動機付けが 「記述の自然さ」 では少し心もとな いでしょうか。 ご安心ください。 この手法は記述として自然であるということ以外 に明確なメリットがあります。 そのメリットは値オブジェクトに新たなインスタン ス変数が追加されたときにわかります。

属性が追加されても修正不要

世の中にはミドルネームという姓と名の中間に存在する名前があります。このミ ドルネームを表現するために、氏名を表現する FullNameクラスに新たな属性が追 加されたときのことを考えてみてください。

値オブジェクトが比較用のメソッドを提供しておらず、 コード上で属性を直接的 に取得して比較を行っている場合は、 新たに追加された属性も比較するように修正 する必要があります (リスト 2.19)。

リスト 2.19 新たに追加された属性も比較するように修正する

}

var compareResult = nameA.FirstName == nameB.FirstName // 条件式を追加 && nameA. LastName == nameB. LastName && nameA. MiddleName == nameB.MiddleName; ⇒

この改修の難易度は易しいものです。 しかしながら、果たして FullNameの比較 を行っているのはここだけにとどまるでしょうか。 ひょっとすると FullName の比 較はここ以外でも行われていて、 リスト2.19 と同じような記述がプログラムの至 る所に記述されてしまってはいないでしょうか。

027

L

22 値の性質と値オブジェクトの実装

ひとつひとつの修正は易しいものだとしても、それが積み重なると難易度は飛躍 的に上昇します。 リスト2.19 と同等の記述がされている箇所をすべて探し出して、 間違いなく修正していくために求められる慎重さは開発者を疲弊させるものでしょう。 この至極単調で退屈な作業は、 値オブジェクトが比較の手段を提供することで回

避できます (リスト2.20)。

リスト 2.20 新たな属性が追加されたときの修正

class FullName: IEquatable <FullName> {

(------)

public bool Equals (FullName other)

if (ReferenceEquals(null, other)) return false;

if (ReferenceEquals (this, other)) return true;

return string.Equals (firstName, other.firstName) && string.Equals (lastName, other. lastName) && string.Equals (middleName, other.middleName); → // 条件式の追加はここだけ

} }

FullNameのインスタンスを比較するとき、開発者はこのEqualsメソッドを呼 び出して比較を行います。 したがって、 値オブジェクトに新たに属性が追加された としても、その変更はEqualsメソッドの修正だけで済みます。 比較処理に限らず、 値の属性を操作する処理を値オブジェクトが提供してまとめることは変更箇所をま とめることと同義です。

DDD 2.3 値オブジェクトにする基準

FullNameクラスを構成する firstName や lastName といった姓や名を表現する 属性が値オブジェクトでなくプリミティブな文字列型で定義されていることに気づ

{

028

いたでしょうか。 実をいうと、システムに登場する概念のうち、どこまでを値オブ ジェクトにするかは難しい問題です。 単純にドメインモデルとして定義される概念 であれば値オブジェクトとして定義されますが、 そうでないときは迷いを生みます。 たとえばリスト2.21のコードは可能な限り値オブジェクトを適用したFullName です。

リスト2.21 可能な限り値オブジェクトを適用した FullName クラス

class FullName: IEquatable<FullName>

{ private readonly FirstName firstName; private readonly LastName LastName; public FullName (FirstName firstName, LastName LastName) } { } this.firstName = firstName; this.lastName = lastName; (･･･略･･･)

コンストラクタに渡されている引数は値オブジェクトです (リスト2.22、 リスト 2.23).

リスト 2.22: 名を表す値オブジェクト

class FirstName { private readonly string value; public FirstName (string value) {

if (string.IsNullOrEmpty (value)) throw new ⇒

ArgumentException("1文字以上である必要があります。 ", nameof (value));

this.value = value;

リスト2.23 姓を表す値オブジェクト

class LastName

{

private readonly string value;

public LastName (string value)

{

if (string.IsNullOrEmpty (value)) throw new

ArgumentException("1文字以上である必要があります。 ", nameof (value));

this.value = value;

}

}

これを「やりすぎ」 という人もいれば、 「正しい」 と評する人もいるでしょう。こ の正当性はコンテキストによるからです。 どちらが正しいとも言い切れませんし、 どちらが間違いとも言い切れません。

それでも 「判断基準が欲しい」 という気もちも理解できます。 そこで参考意見と してここに筆者個人の判断基準を記しましょう。

ドメインモデルとして挙げられていなかった概念を値オブジェクトにすべきかど うかの判断基準として、筆者は「そこにルールが存在しているか」という点と「そ れ単体で取り扱いたいか」という点を重要視しています。

たとえば氏名には 「姓と名で構成される」というルールがあります。また本文で 例示したように単体で取り扱っています。 筆者の判断基準に照らし合わせると値オ ブジェクトとして定義されます。

では姓や名はどうでしょうか。 いまのところ姓や名にシステム上の制限はありま せん。 姓だけを取り扱ったり、 名だけを利用するシーンもいまのところありません。 筆者の判断基準からするとこれらはまだ値オブジェクトにしないでしょう。

少し前提を変えて、 もし姓や名に使用可能な文字種が制限されるのであったとし

たらどうでしょうか。 実をいうと値オブジェクトにしなくてもルールを担保するこ とは可能です (リスト2.24)。

リスト2.24: FullNameでルールを担保する

class FullName: IEquatable <FullName>

private readonly string firstName;

private readonly string lastName;

public FullName (string firstName, string lastName)

{

if (firstName == null) throw new ArgumentNullException→ (nameof(firstName));

if (lastName == null) throw new ArgumentNullException→ (nameof (lastName));

if (!ValidateName (firstName)) throw new ArgumentException→ (許可されていない文字が使われています。 ", nameof (firstName));

if (!ValidateName (lastName)) throw new ArgumentException→ (許可されていない文字が使われています。 ", nameof (lastName));

this.firstName = firstName;

this.lastName= lastName;

}

private bool ValidateName (string value)

{

{

// アルファベットに限定する

return Regex.IsMatch (value, @"^ [a-zA-Z]+$");

}

(･･････)

}

リスト 2.24のFullNameのようにプリミティブな値を利用していたとしても、 引数として渡された時点でチェックを行えば、 ルールは担保されます。

もちろん値オブジェクトにするという判断も否定しません。 値オブジェクトにす るのであれば、次に考えるべきは姓と名を分けるかどうかという点でしょう。 姓と 名を別のものとして取り扱う必要がなかった場合にはそれらを同じ名前として取り

03

扱う選択肢があります (リスト2.25)。

リスト 2.25名前を表現するクラス

class Name

{

private readonly string value;

public Name (string value)

{

if (value == null) throw new ArgumentNullException (nameof➡ (value));

if (!Regex.IsMatch (value, @"^[a-zA-Z]+$")) throw new Argu➡ mentException("X.", nameof (value));

this.value = value;

}

}

リスト2.26 リスト2.25を利用した FullName クラス

class FullName

{

private readonly Name firstName; private readonly Name LastName;

public FullName (Name firstName, Name LastName) {

if (firstName == null) throw new ArgumentNullException❤ (nameof(firstName));

if (lastName == null) throw new ArgumentNullException➡ (nameof (lastName));

this.firstName = firstName;

this.lastName = lastName;

}

032

(･･･...)

重要なのは値オブジェクトを避けることではありません。 値オブジェクトにすべ きかどうかを見極めて、 そうすべきと判断したのであれば大胆に実行すべきという ことです。

そして値オブジェクトとして定義する程の価値がある概念を実装中に発見したの であれば、それはドメインモデルとしてフィードバックすべきものです。 ドメイン 駆動設計が目的とするイテレーティブ (反復的) な開発はこういった実装時の気づ きによって支えられます。

DDD 2.4

ふるまいをもった

値オブジェクト

値オブジェクトで重要なことは独自のふるまいを定義できることです。 たとえば お金を表現するお金オブジェクトを考えてみましょう。

お金には量と通貨単位 (円やドル) の2つの属性があります。 これを値オブジェ クトとして定義するとリスト2.27 です。

リスト 2.27 量と通貨単位を属性にもつお金オブジェクト

class Money

{

private readonly decimal amount;

private readonly string currency;

public Money (decimal amount, string currency)

{

if (currency == null) throw new ArgumentNullException→ (nameof (currency));

this.amount = amount;

033

ふるまいをもった値オブジェクト

}

} } this.currency = currency;

値オブジェクトはデータを保持するコンテナではなく、ふるまいをもつことがで きるオブジェクトです。 実際にふるまいを追加してみましょう。

お金は加算することがあります。 加算を行うふるまいをAddメソッドとして実 装してみます (リスト2.28)。

リスト2.28 金銭の加算処理を実装する

class Money

{

private readonly decimal amount; private readonly string currency;

(------)

public Money Add (Money arg)

{

if (arg == null) throw new ArgumentNullException (nameof→ (arg));

if (currency != arg.currency) throw new ArgumentException→ ($"通貨単位が異なります (this: {currency}, arg:{arg.currency}) ");

return new Money (amount arg.amount, currency); } }

お金を加算するときは通貨単位を揃える必要があるため、 通貨単位が同一かどう かの確認が行われています。 また値オブジェクトは不変であるため、計算を行った 結果は新たなインスタンスとして返却されます。

加算した結果を受け取るときは変数に代入します。 リスト2.28を利用した加算 処理はリスト 2.29です。

034

リスト 2.29 加算した結果を受け取る

var myMoney = new Money (1000, "JPY"); var allowance = new Money (3000, "JPY"); var result = my Money.Add (allowance);

この記述はプリミティブな値同士の計算処理と同じ記述の仕方です(リスト 2.30).

リスト 2.30 プリミティブな値同士の加算

var my Money = 1000m; var allowance = 3000m; var result = myMoney + allowance;

なお通貨単位が異なる場合には例外を送出するため、 異なる通貨単位同士で加算 してしまうといった誤った操作は防がれます (リスト 2.31)。

リスト2.31: 異なる通貨単位同士で加算は例外を送出する

var jpy = new Money (1000, "JPY"); var usd = new Money (10, "USD"); var result = jpy.Add(usd); // 例外が送出される

いつだってバグは思い違いから始まるものです。 計算処理にルールを記述し、そ れにそぐわない操作を弾くようにして、システマチックに誤った操作を防止できる のであればそれを活用すべきです。

値オブジェクトは決してただのデータ構造体のことを指しているわけではありま せん。 オブジェクトに対する操作をふるまいとして一処にまとめることで、値オブ ジェクトは自身に関するルールを語るドメインオブジェクトらしさを帯びるのです。

2.4.1 定義されないからこそわかること

オブジェクトに定義されるふるまいは、そのオブジェクトができることを示しま す。このことを反転するとオブジェクトに定義されないふるまいは、そのオブジェ クトができないことになります。

たとえばお金同士は加算することはできても、お金同士を乗算することはできま

03

せん。 「100円+100円=200円」は成立しますが、 「100円×100円=10000円」 とはならないのです。

お金を乗算することがあるとしたら金利を計算するときなどでしょうか。 それを 実現するふるまいのシグネチャはリスト2.32です。

リスト2.32:お金を乗算するふるまい

class Money

(------)

{

public Money Multiply (Rate rate);

// public Money Multiply (Money money) は定義されない }

お金同士の乗算は定義されないことで、暗にそれができないことを示しているの です。

DDD 値オブジェクトを採用する 2.5 モチベーション

当然のことながらシステム固有の値をオブジェクトで表現するということは、そ れだけ定義されるクラスの数も増加するということです。 プリミティブな値を 「う まく」 使ってプログラムを書くことに慣れきってしまい、クラスを増やすことに抵 抗を感じる開発者は多く存在します。

本来であればモジュール性の観点で、 コードは適切な大きさに細分化し、分散し て定義すべきです。 残念ながらその意識のないプロジェクトは世の中に多く存在し ます。 その状況では、 開発者は値オブジェクトを採用して数多くのクラスファイル を定義することに抵抗を感じます。 最初の一歩はいつだって困難がつきまとうので す。値オブジェクトを採用するには、この心理的ハードルを乗り越える必要があり ます。

そこで、ここでは最初の壁を乗り越える勇気を得るために、 値オブジェクトを採 用する際のモチベーションを紹介します。 どういった動機で値オブジェクトが必要 になるのかを理解すれば、誰しもが値オブジェクトを使いたいと願い、 使い始める

036

はずです。

値オブジェクトを使うモチベーションとして紹介するのは次の4つです。

・表現力を増す . . ・不正な値を存在させない ・誤った代入を防ぐ ロジックの散在を防ぐ

いずれも単純なことながら、 あなたのシステムを強力に保護するものです。

2.5.1 表現力を増す

工業製品にはロット番号やシリアル番号、 製品番号など識別するためにさまざま な番号が存在しています。 それらは数字だけで構成されることもあればアルファ ベットも含めた文字列で構成されていることもあります。 製品番号をプリミティブな 値で表現したとき、プログラムはどういったものになるでしょうか (リスト2.33)。

リスト 2.33: プリミティブな値を利用した製品番号

var modelNumber = "a20421-100-1";

modelNumberはプリミティブな文字列型の変数です。 リスト 2.33 であれば直 接代入されている値を確認できるため、 製品番号は3種類の番号で構成されている と認識できます。 しかしスクリプト上に突然modelNumber という変数が現れた 際には、その内容がどういったものかをうかがい知ることはできません (リスト 2.34).

リスト 2.34: 製品番号はどういったものだろうか

void Method (string modelNumber) // かろうじて文字列であることはわかる {

(･･･略･･･)

}

製品番号の構成を知るには、 modelNumber がどこで生み出され、 どこから来た のかを辿る旅を始めることになります。

値オブジェクトを使って製品番号を表したときはどうなるでしょう (リスト

03

2.35).

リスト 2.35:製品番号を表す値オブジェクト

class ModelNumber

{

private readonly string product Code;

private readonly string branch;

private readonly string lot;

public Model Number (string productCode, string branch, → string lot)

{

if (productCode == null) throw new ArgumentNullException➡ (nameof (productCode));

if (branch == null) throw new ArgumentNullException➡ (nameof (branch));

if (lot == null) throw new ArgumentNullException➡

(nameof(lot));

this.productCode = productCode;

this.branch branch;

this.lot lot;

public override string ToString()

}

{ } return product Code + "" + branch + ""+ lot;

}

Model Number クラスの定義を確認してみれば、 製品番号はプロダクトコード (productCode)と枝番 (branch)、 そしてロット番号 (lot) から構成されている ことがわかります。 これは無口な文字列と比べると大きな進歩です。

値オブジェクトはその定義により自分がどういったものであるかを主張する自己 文書化を推し進めます。

038

2.5.2 不正な値を存在させない

システムに存在する値にはルールが存在します。 たとえばユーザ名を例にとって みましょう。

ユーザ名は端的にいってしまえば文字列です。 しかし、システムによっては 「ユーザ名の文字数はN文字以上M文字以下」といったルールや、 「利用できる文字 はアルファベットと数字のみ」 といったルールが存在します。

たとえば「ユーザ名は3文字以上」 というルールが存在するとき、リスト2.36の コードは正しいでしょうか。

リスト 2.36: 存在してはいけない値

var userName = "me";

ユーザ名を表す user Name は2文字の文字列ですから、 「ユーザ名は3文字以上」 というルールに違反をしている異常な値です。 しかし、 プログラムにとって2文字 の文字列が存在することに問題はまったくありません。 コンパイラにとって2文字 の文字列が存在することは当たり前のことですし、プログラムを実行したとしても 問題なく動作します。 したがって、 ユーザ名であるにも関わらず2文字である不正 な値の存在が許されてしまうのです。

不正な値は遅効性の毒のような厄介な代物です。 一度不正な値の存在が許容され てしまうと、その値を利用しようとするときに常に値の確認を行う必要が生じます (リスト2.37)。

リスト 2.37値を利用する前にルールに照らし合わせる必要がある

if (userName.Length >= 3) { } // 正常な値なので処理を継続する else { throw new Exception ("異常な値です"); }

値が正しいものかを確認することで急場をしのぐことはできます。 しかし、その

対応は値の正当性を確認するコードをプログラムのいたるところに埋め込むことを 肯定します。 開発者は同じルールを何度も書くことを強いられるでしょう。それは とても煩雑な作業でありながら、 しかし一箇所でも間違えばシステムの破綻に繋が る作業です。

値オブジェクトをうまく利用すると、 そもそもこのような異常な値の存在を防げ ます。 リスト 2.38のUserName クラスはユーザ名を表す値オブジェクトです。

リスト 2.38: ユーザ名を表す値オブジェクト

class UserName { private readonly string value;

public UserName (string value)

{

if (value == null) throw new ArgumentNullException(nameof→ (value));

if (value.Length <3) throw new ArgumentException("ユーザ名→ は3文字以上です。 ", nameof (value));

this.value = value;

}

}

このUserName クラスはガード節 (*2)により3文字未満のユーザ名を許可しない ようになっています。 もはやシステムにとって異常な値はこのチェックにより許容 されません。 結果としてシステムは、ルールにしたがっていない不正な値の存在に 怯える必要がなくなったのです。

2.5.3 誤った代入を防ぐ

皆さんは代入を間違えた経験はあるでしょうか。 代入はプログラミングにおいて 頻繁に行われる操作で、 私たちは何の気なしに代入を日常的に行っています。 それ

処理の対象外とする条件を関数の初期に確認すること

040

[2]

ほど日常的な行為であるがために、開発者は稀に(もしくは頻繁に) 代入を間違え るときがあります。

たとえばリスト2.39 は単純な代入を行っています。

リスト 2.39 : 単純な代入を行うコード

User CreateUser(string name) { } var user = new User(); user.Id = name; return user;

User クラスのIdプロパティに引数で受け取ったname を代入しています。 この コードは問題なく実行できるコードですが、 さてこちらのコードは正しいコードで しょうか。

ユーザのIDがどういったものかはシステムによって異なります。 ユーザ名がそ のままIDになることもあれば、メールアドレスなど別の値がIDになる場合もあり ます。 前者であればリスト 2.39のコードは正しいですし、 後者であれば間違いです。 こ のコードの正当性はコードを見ただけでは判別できません。 正しさを判定するには システムがどういった仕様になっているのかについて深く知っておく必要があるの です。

コードの正しさを証明するために関係者の記憶やドキュメントに頼るよりも、よ りよいアプローチは自己文書化を進めることです。 コードの正しさをコードで表現 できるのであれば、それに越したことはありません。 値オブジェクトはそれを可能 にします。 実際に値オブジェクトを適用してみましょう。

まずは値オブジェクトがなくては始まりません。 ユーザIDとユーザ名をそれぞ れ値オブジェクトとして用意します (リスト2.40、 リスト2.41)。

リスト 2.40 ユーザIDの値オブジェクト

class UserId

{ private readonly string value; public UserId(string value) {

if (value == null) throw new ArgumentNullException (nameof→ (value));

}

this.value = value;

}

リスト 2.41 ユーザ名の値オブジェクト

class UserName { private readonly string value; public UserName (string value) {

if (value == null) throw new ArgumentNullException(nameof (value));

this.value = value;

}

}

UserldとUserName はそれぞれプリミティブな値である文字列をラップしただ けの単純なオブジェクトです。 ふるまいはまだありませんが、 今回の問題を解決す るにはこれで十分です。

User オブジェクトのプロパティはこれらの値オブジェクトに変更されます(リス ト2.42)。

リスト2.42: 値オブジェクトを利用するように変更したUser クラス

class User { } public UserId Id { get; set; } public UserName Name { get; set; }

042

さぁ、リスト2.39のコードを変化させてみましょう。 関数の引数として受け取っ ていた文字列は、 UserName オブジェクトを受け取るように変更されます (リスト 2.43).

リスト 2.43: 値オブジェクトを利用する

User CreateUser (UserName name) { } var user = new User(); user.Id = name; // コンパイルエラー! return user;

User クラスのIdプロパティはUserId型の値オブジェクトです。 それに対して代 入しようとしている name はUserName型の変数です。 コンパイラはこの代入操 作をタイプ不一致エラーとして検知します。 リスト2.43は明確に間違ったコード であるとコンパイラが検出してくれるのです。

エラーというものがいつ生まれどこに潜むかを予測することは難しいです。 それ が実行して初めて気づくのと実行前に気づくのとでは、後者の方が嬉しいはずで す。 値オブジェクトを作ることで型の恩恵に与ることができれば、予測不能なエ ラーが潜む箇所を減らすことができます。

静的型付けを行うプログラミング言語であれば、この力は積極的に使うべきで す。 またそれ以外のプログラミング言語であっても、 昨今ではタイプヒンティング などにより統合開発環境 (IDE) がエラーを可視化してくれます。

値オブジェクトを使って可能な限りエラーを事前に防ぐことは、面白くもないバ グ潰しからあなたを解放します。

2.5.4 ロジックの散在を防ぐ

DRY 原則 [3] で知られるようにコードの重複を防ぐことは重要です。 コードの重 複を許してしまうと、 変更に対する難易度が途端に跳ね上がります。

たとえば値オブジェクトを利用しないユーザの作成処理ではリスト2.44のよう に入力値の確認が必要です。

[3] Don't Repeat Yourself の頭文字を取ったもの。 知識を整理整頓し、重複なくまとめること で、信頼できるものとする考え。

リスト2.44 入力値の確認を伴うユーザの作成処理

void CreateUser (string name )

{

if (name == null) throw new ArgumentNullException(nameof(→ name));

if (name.Length <3) throw new ArgumentException("ユーザ名は 3文字以上です。", nameof(name));

var user = new User (name);

(------)

}

局所的にはこのコードに問題はありません。 しかし、たとえば他にユーザ情報を 更新する処理があったときはどうでしょうか (リスト 2.45)

リスト 2.45 ユーザ情報更新処理でも同様のコードを記述する

void UpdateUser(string id, string name)

if (name == null) throw new ArgumentNullException (nameof(→ name));

if (name.Length < 3) throw new ArgumentException("ユーザ名は → 3文字以上です。",nameof(name));

{

(･･･略･･･)

}

リスト2.44に記述されていた引数を確認するコードが更新処理にも記述され、 コードは重複することになります。 これが引き起こす弊害はルールの変更が必要と なったときに表れます。

たとえば「ユーザ名の最小文字数」 を変更することを仮定してみましょう。 開発 者はまずユーザを新規作成するリスト2.44でnameの長さ確認を行っているコー ドを変更する必要があります。 そして、もちろんユーザ情報の更新処理であるリス ト2.45も同じように書き換える必要があります。

044

それでも書き換える箇所はたったの2箇所です。 それほど難しいことではありま せん・・・・・・と言い切るほど事は単純ではありません。 こういったコードは他にもシス テムのどこかに潜んでいる可能性があります。 開発者は「ユーザ名の最小文字数」 を取り扱っているコードを探索することを強いられます。 それは並たいていでない 慎重さと徒労にも似た労力が要求される作業でしょう。

いうまでもなく理想はルールの変更に対してコードの変更箇所が1箇所で済む状 態です。 値オブジェクトを定義して、ルールをまとめることでそれは達成できます (リスト2.46)。

リスト 2.46 値オブジェクトにルールをまとめる

class UserName

{ private readonly string value;

public UserName (string value )

if (value == null) throw new ArgumentNullException (nameof(→ value));

if (value.Length <3) throw new ArgumentException("ユーザ名は→ 3文字以上です。", nameoff (value));

this.value = value;

}

}

{

値オブジェクトを利用した新規作成と更新処理はリスト 2.47になります。

リスト 2.47: 値オブジェクトを利用した新規作成処理と更新処理

void CreateUser (string name ) { } var userName = new UserName (name); var user = new User (userName); (･･･略･･･)

void UpdateUser (string id, string name) { var userName = new UserName (name); } (------)

ルールはUserNameに記述され、 「ユーザ名の最小文字数」 に対する変更は UserName にまとめられます。 ルールをまとめることは変更箇所をまとめること と同義です。 ソフトウェアが変更を受けいれることができる柔軟さを確保するため には、このまとめる作業こそが重要なのです。

DDD 2.6 まとめ

本章では値の性質を学ぶことで値オブジェクトの性質と具体的なメリットについ て示しました。

値オブジェクトのコンセプトは 「システム固有の値を作ろう」という単純なもの です。 システムには、 そのシステムならではの値が必ずあるはずです。 もちろん、 プリミティブな値だけでソフトウェアを構築することは可能です。 しかし、プリミ ティブ型は汎用的すぎて、どうしても表現力が乏しくなってしまいます。

ドメインにはさまざまなルールがあります。 値オブジェクトを定義するとそう いったルールは値オブジェクトに記述され、 コードがドキュメントとして機能し始 めます。 システムの仕様は一般的にドキュメントにまとめられますが、 もしもコー ドでルールを表現できるのであればそれに越したことはありません。キャビネット からドキュメントを取り出す手間を減らす努力は継続して取り組むべき課題です。

値オブジェクトはドメインの知識をコードへ落とし込むドメイン駆動設計におけ る基本のパターンです。 ドメインの概念をオブジェクトとして定義しようとすると きに、まずは値オブジェクトにあてはめてみることを検討してみてください。

次の章では値オブジェクトと並ぶドメイン駆動設計の基本要素であるエンティ ティを解説します。

す

046

Chapter 3 ライフサイクルのある オブジェクト 「エンティティ」

エンティティは値オブジェクトと対を為すドメインオ ブジェクトです。

エンティティという言葉を見聞きしたことがあるで しょうか。

ソフトウェア開発の文脈でエンティティという単語は よく出てくる用語です。 たとえばデータベースのテー ブル設計などで用いられる実体関連図 (ER図)には エンティティが登場します (そもそもその名前からし て entity-relationship diagram です)。 またオブジェ クト関係マッピング (Object-relational mapping、 ORM) では永続化対象のデータをエンティティと呼 びます。

しかし、ドメイン駆動設計におけるエンティティはそ れらとは異なるものです。 もしもあなたの知るエン ティティがドメイン駆動設計の文脈をもたないのであ れば、いったんその知識はしまい込みましょう。 ここ で解説をしようとしているのは 「ドメイン駆動設計の」 エンティティです。

13

10

11

19

12

8

DDD 3.1

エンティティとは

ドメイン駆動設計におけるエンティティはドメインモデルを実装したドメインオ ブジェクトです。 第2章 「システム固有の値を表現する 「値オブジェクト」」で解説 した値オブジェクトもドメインモデルを実装したドメインオブジェクトです。 両者 の違いは同一性によって識別されるか否かです。 同一性という言葉はあまり耳慣れ ないことでしょう。 まずは同一性がどういったものなのかを確認します。

人間には名前や身長、体重、 趣味などさまざまな属性があります。 これらの属性 は固定ではなく、 さまざまな要因によって変化します。 たとえば年齢は誕生日を迎 えると年を重ねる可変な属性です。 ここで考えるべきは誕生日を迎えた当事者は、 誕生日以前と以後で別人になりうるかということです。

当然ながら年齢を重ねたからといって、 その人がまったくの別人になってしまう ことはありません。 同じように身長や体重が増減したところで、別人になり変わる ことはないでしょう。 その人がその人たる所以は属性とはまったく別の無関係なと ころにあり、 同一性を担保する何かが存在することを示唆しています。

ソフトウェアシステムにおいても同じように、 属性で区別されないオブジェクト は存在します。 たとえばシステムのユーザという概念はその典型です。

システムの利用者は最初にユーザ登録を行い、 利用者個人の情報をユーザ情報と して登録します。 ユーザ情報はたいていの場合任意で変更可能です。 このとき、 ユーザ情報として登録されているデータが変更されたからといって、 まったく別の ユーザになってしまうことはありません。 ユーザはその名前が変更されたとして も、ユーザ情報が変更されただけであって、 ユーザ自体が変更されたわけではあり ません。ユーザは属性ではなく同一性 (identity) により識別されています。

ソフトウェアシステムにはエンティティが多く登場します。 まさにソフトウェア 開発を行う上では切っても切れない関係です。 この章では値オブジェクトと並んで ドメイン駆動設計の中核を担うドメインオブジェクトであるエンティティについて 学んでいきましょう。

048

DDD 3.2

エンティティの性質について

冒頭でも解説したとおり、 エンティティは属性ではなく同一性によって識別され るオブジェクトです。 これとは反対に同一性ではなく属性によって識別されるオブ ジェクトも存在します。

たとえば姓と名の属性からなる氏名は、 そのいずれかの属性が変更されたらまっ たく異なるものになってしまいます。 反対に属性が同じであった場合はまったく同 じものであるとみなされます。 まさしく氏名はその属性によって識別されるオブ ジェクトです。 そのようなオブジェクトのことを何と呼ぶか、 皆さんは既に学んで います。 氏名はまさに「値オブジェクト」です。

エンティティと値オブジェクトは共にドメインモデルの実装であるドメインオプ ジェクトとして似通っていますが、 その性質は異なります。 エンティティの性質は 次のとおりです。

・可変である ・同じ属性であっても区別される ・同一性により区別される

エンティティの性質には値オブジェクトの性質を真逆にしたような性質もありま す。 この先の解説は、 値オブジェクトとの違いを意識しながら読み進めるとより理 解しやすい内容です。 もしも値オブジェクトに対する理解に不安が残っているよう であれば、 第2章 「システム固有の値を表現する 「値オブジェクト」」 の解説を確認 しに戻ってみるとよいでしょう。

3.2.1 可変である

値オブジェクトは不変なオブジェクトでした。 それに比べてエンティティは可変 なオブジェクトです。 人々がもつ年齢や身長といった属性が変化するのと同じよう に、エンティティの属性は変化することが許容されています。

人生において名前を変更するケースはそれほど頻繁には発生しませんが、 システ ム上のユーザ名を変更したいケースは存在します。 ユーザ名の変更を例に 「可変で ある」 性質がどういったものか確認してみましょう。

•2 エンティティの性質について

リスト3.1はユーザを表すUser クラスですが、 現在のところユーザ名の変更を行 うことができません。

リスト3.1 ユーザを表すクラス

class User { private string name;

public User(string name)

{

if (name == null) throw new ArgumentNullException (nameof(→ name));

if (name.Length <3) throw new ArgumentException("ユーザ名は→ 3文字以上です。 ",nameof(name));

this.name = name;

}

}

最初はこれでよいと思ったユーザ名であっても、システムを利用しているうちに 素敵なユーザ名を後から思いつくこともあるでしょう。 そのとき、 せっかく思いつ いた素敵なユーザ名を使うことができないと、 とても残念な体験になってしまいま す。素敵なユーザ名を利用できるようにUserオブジェクトを可変なオブジェクト にしてみましょう (リスト3.2)。

リスト3.2 可変なオブジェクトに変化させる

class User { private string name; public User(string name) { } ChangeName (name);

「エンティティ」

050

public void ChangeName (string name)

if (name == null) throw new ArgumentNullException (nameof(→ name));

{

if (name.Length <3) throw new ArgumentException("ユーザ名は→ 3文字以上です。 ", nameof (name));

this.name = name;

}

}

User オブジェクトはChangeNameメソッドを通じて名前を表す属性を変更で きます。 無味無色のセッターによってユーザ名の交換を行わないことで、 メソッド 名によりそのふるまいが何であるかが語られ、またガード節により異常な値が設定 されることはありません。

値オブジェクトは不変の性質が存在するため交換 (代入) によって変更を表現し ていましたが、 エンティティは交換により変更を行いません。 エンティティの属性 を変化させたいときには、 そのふるまいを通じて属性を変更することになります (図3.1)。

3.1 可変なオブジェクト

なるせ nrs

但し、 すべての属性を必ず可変にする必要はありません。 エンティティはあくま でも、必要に応じて属性を可変にすることが許可されているに過ぎません。 可変な オブジェクトは基本的には厄介な存在です。 可能な限り不変にしておくことはよい 習慣です。

COLUMN

セーフティネットとしての確認

モデルを表現したオブジェクトの値がドメインのルールに適合しているかどうか は重要な問題です。 したがってドメインのルールに違反するようなことは排除する 必要があります。 本文に登場したUserオブジェクトはまさにそれを行っていて、 異 常な値 (nullや短すぎる名前) が引き渡されるとオブジェクトは例外を送出し、 プ ログラムは終了します。

この例外はあくまでもセーフティとして機能する例外です。

したがって、 例外が起こりうることを前提にするのではなく、 その検査は事前に 行うべきです。 たとえばユーザの名前を変更するときに、 新たなユーザ名が異常な 値を取りうるのであれば、クライアント側で事前に検査をします。 この検査を行う と 「新たなユーザ名に異常な値が混ざりうる」という意図を明確にできます (リス ト3.3)。

リスト3.3: クライアントで事前に検査する

if (string.IsNullOrEmpty (request.Name))

{

throw new ArgumentException("リクエストのNameがnullまたは→ 空です。");

}

user. ChangeName (request.Name);

3.2.2 同じ属性であっても区別される

値オブジェクトは同じ属性であれば同じものとして扱われました。 エンティティ はそれと異なり、たとえ同じ属性であっても区別されます。 この性質を理解するた めに、値オブジェクトとの違いを確認していきましょう。

ここで例に挙げる氏名の値オブジェクトは姓と名の2つの属性で構成されていま す。値オブジェクトは等価性によって比較されるため、姓の値と名の値がそれぞれ 同じである氏名オブジェクト同士はまったく同じものとして扱われます (図3.2)。

052

姓 naruse 名 masanobu 姓 naruse 名 masanobu

図3.2: 等価であれば同一とみなされる

この値がもつ性質は、たとえば人間にはあてはめることはできません。 もしこの 性質を人間にあてはめたならば、氏名がまったく同じ人間同士は同一人物であると いうことになってしまいます (図3.3)。

Masanobu Naruse ? Masanobu Naruse

図 3.3 同姓同名は同一人物

もちろんそんなことはありえません。 同姓同名という言葉があるとおり、氏名が 一致したからといって必ずしも同じ人物のことを指していると断定はできません (図3.4)。

Masanobu Naruse Masanobu Naruse

3.4 同姓同名は同一人物でない

私たち人間は属性だけでは区別されないのです。 人間が区別されるのはもっと別 のところにあります。 ここで例にしている人間はまさしくエンティティとして表現 されるものです。

人間が何をもってして区別されるのか、というのは哲学的な問いになってしまい ますが、 エンティティ同士を区別するためには識別子 (Identity) が利用されます。

人間と同様にシステム上の利用者であるユーザもまた、 等価性でなく同一性に よって識別される必要があります。 そこでUserオブジェクトに識別子を追加して みましょう。 次のコードは識別子であるUserldとそれを追加したUser オブジェク トです (リスト3.4)。

リスト3.4 識別子とそれを利用したユーザのオブジェクト

class UserId { private string value;

public UserId(string value)

{

if (value == null) throw new ArgumentNullException(nameof(→ value));

this.value = value;

}

}

class User

{ private readonly UserId id; private string name;

public User(UserId id, string name)

{

if (id == null) throw new ArgumentNullException (nameof(id)); if (name == null) throw new ArgumentNullException(nameof(→ name));

this.id = id;

this.name = name;

}

}

054

まったく同じ名前のユーザがいたとき、 それが同一のユーザかそれとも別のユー ザかどうかはこの識別子によって区別されます。

3.2.3 同一性をもつ

たとえばユーザ名を変更したときを考えてみましょう (図3.5)。

naruse

図3.5: ユーザ名変更のケース

nrs

ユーザ名を変更する前のユーザとユーザ名を変更した後のユーザは同一のユーザ と判定されるべきでしょうか。 それとも別のユーザと判定されるべきでしょうか。

たいていのシステムではユーザ名が異なったとしても、 変更前と変更後のユーザ を同一のユーザとして認識してほしいでしょう。 ユーザには同一性があります。 オブジェクトには属性が異なっていたとしても同じものとしてみなす必要がある ものが存在します。それらはみな同一性により識別されるオブジェクトです。

もちろんプログラムはユーザが同一かどうかを判断できませんから、 同一性を判 断するために何らかの手段が必要です。 プログラムでは同一性の判断を実現するた めに識別子を利用します (リスト3.5)。

リスト3.5 同一性の判断するために識別子を追加

class User

{

private readonly UserId id; // 識別子 private string name;

public User (UserId id, string name )

{

if (id == null) throw new ArgumentNullException (nameof (id));

} this.id = id; ChangeUserName (name);

public void ChangeUserName (string name)

{

if (name == null) throw new ArgumentNullException(nameof(→ name));

if (name.Length <3) throw new ArgumentException("ユーザ名は → 3文字以上です。", nameof(name));

this.name = name;

}

識別子は同一性の実体です。 その性質からして可変にする必要はありません。C# では readonly 修飾子を付けて再代入を不可能にすることで、 インスタンスが実体 化している間もIDが変化しないことを保証できます。

こうして定義された識別子は、 フィールドとして保持するだけでは意味がありま せん。 同一性の比較を行うためのふるまいが必要です。 リスト3.6の Equalsメソッ ドは比較手段の典型的な実装です。

}

リスト3.6 比較手段の実装

class User: IEquatable<User>

private readonly UserId id;

private string name;

(･･･略･･･)

{

public bool Equals (User other)

056

{

if (ReferenceEquals (null, other)) return false;

if (ReferenceEquals(this, other)) return true;

return Equals(id, other.id); // 比較は id 同士で行われる

}

public override bool Equals(object obj)

{

if (ReferenceEquals (null, obj)) return false;

if (ReferenceEquals(this, obj)) return true;

if (obj.GetType() != this.GetType()) return false; return Equals((User) obj);

}

// 言語によりGetHashCode の実装が不要な場合もある

public override int GetHashCode() {

return (id != null ? id.GetHashCode(): 0);

}

}

第2章 「システム固有の値を表現する 「値オブジェクト」」 で紹介した値オブジェ クトの比較処理ではすべての属性が比較の対象となっていましたが、 エンティティ の比較処理では同一性を表す識別子 (id) だけが比較の対象となります。 これによ り、エンティティは属性の違いにとらわれることなく同一性の比較が可能になりま す (リスト3.7)。

リスト3.7 エンティティの比較を行う

void Check (User leftUser, User rightUser) { if (leftUser. Equals(rightUser)) { } Console.WriteLine("同一のユーザです");

else

{

Console.WriteLine("別のユーザです");

}

}

DDD エンティティの判断基準として 33 のライフサイクルと連続性

値オブジェクトとエンティティはドメインの概念を表現するオブジェクトとして 似通っています。 であれば何を値オブジェクトにして、 何をエンティティにするか という判断の基準が欲しいところです。 ライフサイクルが存在し、 そこに連続性が 存在するかというのは大きな判断基準になります。

たとえばこれまでサンプルにしてきたユーザという概念にはライフサイクルがあ るでしょうか。

ユーザはシステムを利用するために利用者によって作成されます。 システムを利 使用していくうちにユーザ名を変更することもあるでしょう。 そうして月日が流れ、 あるとき利用者にとってシステムが不要になったとき、 残念なことですがユーザは 削除されます。

作成されて生を受け、削除されて死を迎える。 まさにユーザはライフサイクルを もち、 連続性のある概念です。 ユーザはエンティティで間違いなさそうです。

もしもライフサイクルをもたない、 またはシステムにとってライフサイクルを表 現することが無意味である場合には、ひとまずは値オブジェクトとして取り扱うと よいでしょう。 ライフサイクルをもつオブジェクトは生まれてから死ぬまで変化を することがあります。 正確さが求められるソフトウェアを構築するにあたって、 可 変なオブジェクトはその取扱いに慎重さが要求される厄介なものです。 不変にして おけるものは可能な限り不変なオブジェクトのままにして取り扱うことは、 シンプ ルなソフトウェアシステムを構築する上で大切なことです。

058

DDD 値オブジェクトとエンティティの 3.4 どちらにもなりうるモデル

ものごとの側面は決してひとつだけとは限りません。 それがまったく同じ概念を 指していても、 システムによっては値オブジェクトにすべきときもあればエンティ ティにすべきときもあります。

たとえば車にとってタイヤはパーツです。 特性に細かい違いはあるものの交換可 能でまさに値オブジェクトとして表現可能な概念です。 しかし、タイヤを製造する 工場にとってはどうでしょうか。 タイヤにはロットがあり、 それがいつ作られたも のであるかという個体を識別することは重要なことです。 タイヤはエンティティと して表現する方が相応しいでしょう。

同じものごとを題材にしても、それを取り巻く環境によってモデルに対する捉え 方は変わります。 値オブジェクトにも、 エンティティにもなりえる概念があること を認識し、 ソフトウェアにとって最適な表現方法がいずれになるのかは意識してお くとよいでしょう。

DDD ドメインオブジェクトを 3.5 定義するメリット

エンティティと値オブジェクトは異なる性質をもちますが、 いずれもドメインモ デルの表現であるドメインオブジェクトです。 ドメインモデルをドメインオブジェ クトとして定義することでどのようなメリットがあるでしょうか。 ここで一度ドメ インオブジェクトを定義するメリットについて確認しておきましょう。 ここに提示するメリットは次の2つです。

・コードのドキュメント性が高まる

・ドメインにおける変更をコードに伝えやすくする

これらのメリットはソフトウェアを生み出す製造工程よりも、 その後の保守開発 において際立つものです。 少しソフトウェアの未来に思いをはせながら確認して いってください。

5 ドメインオブジェクトを定義するメリット

3

3.5.1 コードのドキュメント性が高まる

開発者は自身が受けもつソフトウェアについて、 必ずしも知識があるとは限りま せん。プロジェクトに途中から参画したり、 前任者の異動により引き継いだりと いった理由で、 まったく知識のないソフトウェアに取り掛かることがあります。 事 前知識のない開発者はソフトウェアが満たす要件をどのようにして知るのでしょう か。

多くの場合は仕様書などのドキュメントを手掛かりにするでしょう。 しかし、残 念ながら仕様書というのはマクロな要件について有効であってもミクロな要件につ いては無力であることが多いです。 たちの悪いことにドキュメントはコードと異 なって、記載されている内容が誤っていてもソフトウェアが動作しなくなるような 問題を引き起こしません。

ソフトウェアが満たす要件を知るのにドキュメントが役に立たないのであれば、 開発者はコードに頼ることになります。 しかし、 たとえばユーザ名に関する仕様を 知ろうとしたとき、 Userクラスのコードがリスト3.8のように記述されていたらど うでしょうか。

リスト3.8 無口なコード

class User

{ } public string Name { get; set; }

コードは自身のことを一切語っていません。 この無口なコードを前にしては、開 発者はユーザ名に関する一切の手掛かりを得ることもできないのです。 それに比べてリスト3.9のコードはどうでしょうか。

リスト3.9 饒舌なコード

class UserName

{

private readonly string value;

public UserName (string value ) {

I

060

if (value == null) throw new ArgumentNullException (nameof(→ value));

if (value.Length <3) throw new ArgumentException("ユーザ名は→ 3文字以上です。", nameof (value));

this.value = value;

}

(...8...)

}

UserName クラスを見たときに、ユーザ名は3文字以上でないと動作しないこと は自明です。 コードを饒舌にする努力を怠らなければ、 開発者はコードを手掛かり にして、そこに存在するルールを確認できるのです。

なお、本来ドメイン駆動設計ではドメインについて学びドメインモデルを作り上 げるところから始め、 それをドメインオブジェクトとして実装します (図3.6)。

[ユーザ class User 最小3文字 ユーザ名 class UserName

図3.6 ドメインモデルをドメインオブジェクトに

ドメインモデルに渦巻くルールはそのままドメインオブジェクトに記述されるこ ととなります。 これはドメインオブジェクトの正当性を担保することに役立ちま す。

たとえば図3.6に記載されている 「ユーザ名は最小3文字」 といったルールはド メインオブジェクトとしてリスト3.9に記述されています。

開発者であればリスト3.9を見て、 ユーザ名が最小3文字であるというルールが

守られていることは読み取れることでしょう。 ともすればプログラミングに関する 知識がない者であったとしても、1行ずつ意味をかみくだいて説明すれば、このド メインオブジェクトの正当性を理解することも可能ではないでしょうか。

もしもこういったルールがオブジェクトに記述されていないリスト3.8のような 無口なコードの場合、その正当性を主張することは困難になります。 そこに存在す るルールが守られているかの判断はすべてのコードを洗い出す必要があり、 たとえ 熟練した開発者であっても多大な労力を求められるでしょう。

3.5.2 ドメインにおける変更をコードに伝えやすくする

ドメインオブジェクトにふるまいやルールを記述することは、 ドメインにおける 変更をコードに伝えやすくする効果があります。

たとえばドメインのルールに変化が起きたと仮定してみましょう。 具体的には図 3.6にあった「ユーザ名は最小3文字」 というルールが 「ユーザ名は最小6文字」に 変更されたときです。

ドメインモデルはドメインにおける変化を受けて、 図3.7のように変化されま す。

ユーザ ユーザ 最小3文字 最小6文字 ユーザ名 ユーザ名

図3.7: ドメインの変化はドメインモデルへ

このルールの変化はコードにも反映する必要があります。 そのときユーザを表す User クラスのコードがリスト3.8のようなただのデータ構造体であったならば、そ の変更は極めて困難な道のりです。 プログラムの随所に散らばったコードから変更 すべき箇所をを探し出す必要があります。

反対に、もしコードがリスト3.9のようにそこにあるルールを語っていたらどう でしょうか。 ドメインモデルのルールが記載されているところは明白で、 その修正 もまた容易いものでしょう。

ドメインオブジェクトにルールやふるまいを記述することは、 ドメインからドメ インモデルへ伝播した変化をドメインオブジェクトまで到達させるために必要なこ とです。

062

人の営みは移ろいやすく、 ドメインもまた変化するものです。 ソフトウェアはド メインに生きる利用者のために存在するものである以上、 こうした変化への対応が 頻繁に求められます。 ソフトウェアが健全に成長していく未来を守るため、コード を饒舌にする努力は常に念頭に置くべき事項でしょう。

DDD 3.6 まとめ

本章では値オブジェクトと並んで重要なモデルを表現するオブジェクトであるエ ンティティについて解説をしました。

豊かなふるまいをもったオブジェクトはソフトウェアがどのドメインの知識に関 心があるか、 それをどのように識別しているかということを浮き彫りにします。 こ れはもちろん後続の開発者にとってドメインを理解する有効な手掛かりになりま す。

ドメインに対する鋭い洞察は実装時にも現れます。 これは人が得意とする曖昧さ をソフトウェアが受け入れられないことに端を発します。 もしもエンティティを実 装しようとしてそこに曖昧さを感じたのであれば、それはドメインの捉え方を見つ め直すきっかけです。

・まとめ

3



Chapter 4

不自然さを解決する 「ドメインサービス」

ドメインサービスは不自然さを解消します。

ドメインの概念を知識として落とし込み、 それをコー ドで表現しようとしたとき、 値オブジェクトやエンティ ティのふるまいとして定義すると違和感が生じるもの が存在します。 この違和感はドメインのものを表現し ようとしたときよりも、 ドメインの活動を表現しようと するときに見られる傾向があります。

違和感のあるふるまいを値オブジェクトなどに無理や り実装しようとすると、 オブジェクトの責務を歪なも のに変えてしまいます。 このようなときに求められる ことは、そのふるまいをまた別のオブジェクトとして 定義することです。 本章で解説するドメインサービス はまさにそのオブジェクトです。

11

10

12

9

13

8

14

7

15

5

APP

4

DDD

サービスが指し示すもの 4.1

サービスとは何でしょうか。

たとえばサービス業と呼ばれる業種を聞いたことがあるでしょう。 ソフトウェア システムをサービスとして提供するという言い回しもよく聞きます。 他には「サー 「ビスする」という動詞として使われることもあります。 それぞれ同じサービスとい う言葉でありながら、 意味合いは明確に異なるものです。 サービスという言葉に慣 れ親しんではいても、いざ「サービスとは何か」と問われると案外答えづらいもの です。

ソフトウェア開発の文脈で語られるサービスはクライアントのために何かを行う オブジェクトです。 その定義域は幅広く、 実にさまざまなことをこなします。 さら に紛らわしいことにドメイン駆動設計だけに焦点を絞ってみても、同じサービスと いう言葉が付く用語でありながら、 その意味合いの異なるものが存在します。 これ は大きな混乱を引き起こしているように感じます。

ドメイン駆動設計で取りざたされるサービスは大きく分けて2つです。 ひとつが ドメインのためのサービスで、もうひとつがアプリケーションのためのサービスで す。 この2つを混同することは混乱のもとです。 その区分けをしっかりとするため に前者をドメインサービスと呼び、後者をアプリケーションサービスと呼びます。

この章で解説するのはドメインのサービスであるドメインサービスです。 アプリ ケーションサービスの解説は第6章 「ユースケースを実現する 「アプリケーション サービス」」 で行います。 数多くあるサービスという言葉に惑わされないように読み 進めていきましょう。

DDD 4.2 ドメインサービスとは

値オブジェクトやエンティティなどのドメインオブジェクトにはふるまいが記述 されます。たとえば、ユーザ名に文字数や利用できる文字種に制限があるのであれ ば、 その知識はユーザ名の値オブジェクトに記述されてしかるべきでしょう。

しかし、 システムには値オブジェクトやエンティティに記述すると不自然になっ

ゾービス」

不自然

4

066

てしまうふるまいが存在します。 ドメインサービスはそういった不自然さを解決す るオブジェクトです。

まずは値オブジェクトやエンティティに記述されると不自然なふるまいがどう いったものなのかを確認し、 その後ドメインサービスによる解決策を確認しましょ う。

4.2.1 不自然なふるまいを確認する

現実において同姓同名は起こりえますが、システムにおいてはユーザ名の重複を 許可しないことはありえます。 ユーザ名の重複を許さないというのはドメインの ルールであり、ドメインオブジェクトのふるまいとして定義すべきものです。 さて、 このふるまいは具体的にどのオブジェクトに記述されるべきでしょうか。 ユーザに関することはユーザを表すオブジェクトに、 という健全な論理的思考か

らまずはUserクラスに重複確認のふるまいを追加してみます (リスト 4.1)。

リスト4.1 重複確認のふるまいをUserクラスに追加

class User

{

private readonly UserId id; private UserName name;

public User (UserId id, UserName name)

if (id == null) throw new ArgumentNullException (nameof(id)); if (name == null) throw new ArgumentNullException (nameof(→ name));

this.id = id;

this.name = name;

{

}

// 追加した重複確認のふるまい

public bool Exists (User user)

{

} } // 重複を確認するコード (---5---)

現時点では重複確認の具体的な処理についてを論じたいわけではありません。い ま認識すべきことは重複の確認を行う手段がUserクラスのふるまいとして定義さ れているということです。

このオブジェクトの定義を確認する限りでは問題がないように見えますが、実は これは不自然さを生み出すコードです。 実際にこのメソッドを利用して重複確認を してみましょう (リスト4.2)。

リスト 4.2 リスト4.1を利用して重複確認を行う

var userId = new UserId("id");

var userName = new UserName("nrs");

var user = new User(userId, userName);

// 生成したオブジェクト自身に問い合わせをすることになる

var duplicateCheckResult = user.Exists(user);

Console.WriteLine (duplicateCheckResult); // true? false?

重複を確認するふるまいはUserクラスに定義されているので、 重複の有無を自 身に対して問い合わせることになります。 これは多くの開発者を混乱させる不自然 な記述です。 自身が重複しているかどうかの確認を自身に依頼したとき、果たして 問い合わせの結果は真を返すべきでしょうか。 それとも偽を返すべきでしょうか。

重複確認を行うときに、生成したオブジェクト自身に問い合わせを行うというの は開発者を惑わせるようです。 異なるアプローチを考えてみましょう。 たとえば重 複を確認するために専用のインスタンスを用意するのはどうでしょうか(リスト 4.3).

リスト4.3 重複確認専用のインスタンスを用意する

var checkId = new UserId("check");

var checkName = new UserName("checker");

var checkObject = new User (checkId, checkName);

068

var userId = new UserId("id");

var userName = new UserName("nrs");

var user = new User(userId, userName);

// 重複確認専用インスタンスに問い合わせ

var duplicateCheckResult = checkObject.Exists(user);

Console.WriteLine (duplicateCheckResult);

リスト 4.3は自身に問い合わせをせずに済む点では、不自然さがいくばくか軽減 されています。 しかし、 重複確認のために作成された check Object はユーザを表す オブジェクトでありながらユーザではない不自然なオブジェクトです。 このような 不自然な存在を容認するのが正しいコードであるとは思えません。

どうやら重複確認はエンティティであるユーザオブジェクトに記述すると不自然 になるふるまいの典型のようです。 こういった不自然さを解決するのに活躍するの がドメインサービスです。

4.2.2 不自然さを解決するオブジェクト

ドメインサービスは通常のオブジェクトと何ら変わりはありません。 ユーザのド メインサービスはリスト 4.4のように定義します。

リスト 4.4 ユーザのドメインサービスの定義

class UserService { public bool Exists (User user) { } // 重複を確認する処理 (------) }

ドメインサービスは値オブジェクトやエンティティと異なり、 自身のふるまいを 変更するようなインスタンス特有の状態をもたないオブジェクトです。

重複を確認するための具体的な実装についてはこの後に解説を行います。 いまは 重複確認を行うメソッドがUserServiceクラスに定義されていることだけを確認 してください。

このユーザのドメインサービスを利用して、 実際にユーザの重複確認を行ってみ ましょう (リスト4.5)。

リスト 4.5 リスト4.4を利用して重複確認を行う

var userService = new UserService();

var userId = new UserId("id");

var userName = new UserName("naruse");

var user = new User(userId, userName);

// ドメインサービスに問い合わせ var duplicateCheckResult = userService.Exists (user); Console.WriteLine(duplicateCheckResult);

ドメインサービスを用意することで、自身に重複を問い合わせたり、 チェック専 用のインスタンスを用意したりする必要がなくなりました。 リスト4.5のコードは 開発者を困惑させない自然なものでしょう。

値オブジェクトやエンティティに定義すると不自然に感じる操作はドメインサー ビスに定義することで、 そこに存在する不自然さは解消されます。

DDD ドメインサービスの濫用が 4.3 行き着く先

エンティティや値オブジェクトに記述すると不自然なふるまいはドメインサービ スに記述します。 ここで重要なのは「不自然なふるまい」 に限定することです。 実 をいうとすべてのふるまいはドメインサービスに記述できてしまいます。

たとえばユーザ名変更のふるまいをエンティティではなくドメインサービスに記 述すると、 コードはリスト4.6のようになります。

170

リスト4.6: ドメインサービスにユーザ名変更のふるまいを記述する

class UserService

{

public void ChangeName (User user, UserName name) { if (user == null) throw new ArgumentNullException (nameof(→ user)); if (name == null) throw new ArgumentNullException (nameof(→ name)); } user.Name = name;

リスト4.6は意図したとおり、 ユーザ名の変更をこなします。 そういった意味で は正しいコードですが、 このときUserクラスの記述はどのようなものになってい るでしょうか (リスト4.7)。

リスト 4.7 リスト4.6で利用されている User クラスの定義

class User

{

private readonly UserId id;

public User (UserId id, UserName name) { } this.id = id; Name= name; public UserName Name { get; set; }

}

ドメインサービスにすべてのふるまいを記述するとエンティティにはゲッターと セッターだけが残ります。 いかに熟練した開発者であっても、このクラスの定義を

}

見ただけでユーザにどのようなふるまいやルールが存在するのかを読み取ることは 不可能です。

無思慮にドメインサービスへふるまいを移設することは、ドメインオブジェクト をただデータを保持するだけの無口なオブジェクトに変容させる結果を招きます。 ドメインオブジェクトに本来記述されるべき知識やふるまいが、 ドメインサービス やアプリケーションサービスに記述され、語るべきことを何も語っていないドメイ ンオブジェクトの状態をドメインモデル貧血症といいます。 これはオブジェクト指 向設計のデータとふるまいをまとめるという基本的な戦略の真逆をいくものです。

ユーザ名を変更するふるまいは本来であればUser クラスに定義するべきもので す (リスト 4.8)。

リスト4.8: User クラスにふるまいを定義する

class User

{

private readonly UserId id;

private UserName name;

public User (UserId id, UserName name) { } this.id = id; this.name = name;

public void ChangeUserName (UserName name)

if (name == null) throw new ArgumentNullException(nameof(→ name));

this.name = name;

} }

4.3.1 可能な限りドメインサービスを避ける

先の例からわかるとおり、すべてのふるまいはドメインサービスに移設できま

{

072

す。やろうと思えばいくらでもドメインモデル貧血症を引き起こせてしまいます。 もちろんふるまいの中にはドメインサービスとして抽出しないと違和感のあるも のは存在します。 ふるまいをエンティティや値オブジェクトに定義するべきか、 そ れともドメインサービスに定義するべきか、 迷いが生じたらまずはエンティティや 値オブジェクトに定義してください。 可能な限りドメインサービスは利用しないで ください。

ドメインサービスの濫用はデータとふるまいを断絶させ、 ロジックの点在を促す 行為です。 ロジックの点在はソフトウェアの変化を阻害し、 深刻に停滞させます。 ソフトウェアの変更容易性を担保するためにも、コードを一元的に管理することを 早々に諦めることは絶対にしてはいけません。

DDD エンティティや値オブジェクトと 4.4 共にユースケースを組み立てる

ドメインサービスは値オブジェクトやエンティティと組み合わせて利用されま す。 ドメインサービスの扱い方を確認するために、 ここで実際にユースケースを組 み立ててみましょう。 ここで組み立てるユースケースはこれまで題材にしてきた ユーザを作成する処理です。

ユーザ作成処理の仕様は単純です。 クライアントはユーザ名を指定してユーザ作 成処理を呼び出します。 そのときユーザ名が重複しないようであればユーザを作成 し保存します。 今回取り扱うデータストアは一般的なリレーショナルデータベース を対象にします。

4.4.1 ユーザエンティティの確認

まずはユーザを表現するUser クラスを定義します (リスト 4.9)。

リスト 4.9 User クラスの定義

class User { public User (UserName name ) {

if (name == null) throw new ArgumentNullException (nameof (→ name));

Id = new UserId (Guid.NewGuid().ToString());

Name = name;

}

public UserId Id { get; }

public UserName Name { get; }

}

ユーザはIdにより識別されるオブジェクトであるエンティティです。 なおユー ザ作成処理においてはUserクラスにふるまいは不要なので、 主だったメソッドは 定義されていません。

User クラスを構成するオブジェクトについても確認しておきましょう。 User ク ラスにはUserld型の識別子が属性として定義されています。 またユーザ名を表す UserName型のプロパティも定義されています。 これらの実装はリスト4.10です。

リスト4.10 Userld クラスとUserName クラスの定義

class UserId

{

public UserId(string value)

{

if (value == null) throw new ArgumentNullException (nameof(→ value));

Value = value;

}

public string Value { get; }

}

class UserName

976

public UserName (string value)

if (value == null) throw new ArgumentNullException(nameof(→ value));

if (value.Length <3) throw new ArgumentException ("ユーザ名は 3文字以上です", nameof (value));

Value = value;

}

public string Value { get; }

UserldとUserName はいずれもデータをラップしているだけの単純な値オブ ジェクトです。 UserName は特に3文字未満のユーザ名は例外を送出することで、 ユーザ名が3文字以上であることを強制しています。

4.4.2 ユーザ作成処理の実装

ユーザエンティティとそれを構成するオブジェクトの実装について確認したとこ ろで、 いよいよ具体的なユーザ作成処理に移ります。 リスト4.11はユーザ作成処理 この具体的な実装です。 まずはコードを俯瞰しましょう。

{

リスト4.11 : ユーザ作成処理の実装

class Program ( public void CreateUser(string userName) { var user = new User( new UserName (userName) );

}

var userService = new UserService();

if(userService.Exists(user))

throw new Exception($"{userName}は既に存在しています");

{

}

var connectionString = ConfigurationManager.→

ConnectionStrings [ "FooConnection"].ConnectionString;

using (var connection = new SqlConnection(connectionString))

using (var command = connection.CreateCommand())

{

connection.Open(); command.CommandText = "INSERT INTO users (id, name) → VALUES (@id @name)"; command.Parameters.Add(new SqlParameter ("@id", user.Id.Value)); command.Parameters.Add(new SqlParameter("@name", user.Name.Value)); command.ExecuteNonQuery(); } } }

コードをあまり深く読み込むことをしなくても、 まず最初にユーザを作成し、 次 に重複確認を行っているところまでは読み取れます。 しかし、 その後に続く処理に ついてはどうでしょうか。

後半のコードはそれまでのコードと異なり、 眺めるだけでは意図を掴めません。 処理を注意深く読み込むとリレーショナルデータベースに接続するための接続文字 列を用いてデータストアに接続し、 SQLを発行してユーザ情報の保存を行っている のが読み取れます。 それまでのユーザ作成や重複確認に比べて、コードの大部分は データストアに対する具体的な操作が多く記述されています。 コード自体はさほど 難易度が高くないものですが、 作成されたユーザを保存する意図を読み取るには コードを読み込む必要があります。

ドメインサービスであるUser Service の実装はどうでしょうか (リスト 4.12)。

076

リスト4.12: ドメインサービスの実装

class UserService

{

public bool Exists(User user)

{

var connectionString = ConfigurationManager.→ ConnectionStrings [ "FooConnection"].ConnectionString; using (var connection = new SqlConnection (connectionString)) using (var command = connection.CreateCommand()) { connection.Open(); command.CommandText = "SELECT * FROM users WHERE name = ⇒ @name"; command.Parameters.Add(new SqlParameter ("@name", user.Name.Value)); using (var reader = command.ExecuteReader()) { var exist = reader.Read(); return exist; } } } }

ユーザ名の重複を確認するにはデータストアへの問い合わせが必要です。 そのた め、 UserServiceの重複確認処理はデータストアの操作に終始しています。

これらのコードはいずれも正しく動作しますが、 柔軟性に乏しいコードです。 た とえば、もしもデータストアがリレーショナルデータベースではなくNoSQLデー タベースへ変更する必要に迫られたとしたら、どのようなことが起きるでしょう か。 ユーザ作成処理の本質は何も変わっていないにもかかわらず、 そのコードの大 半を変更する必要があるでしょう。 UserService クラスにいたっては、すべての コードを NoSQLデータベースを操作するコードに

置き換える必要があります。

データを取り扱う以上、 データの保存や読み取りにまつわる処理を記述すること は避けられません。 しかしユーザ作成処理において、コードの大半はデータストア

に対する操作処理が占めるべきでしょうか。 特定のデータストアに依存することが 正しい道でしょうか。

もちろんそんなことはありません。 ユーザ作成処理の本質は 「ユーザが作成され る」ことと「重複確認が行われる」こと、そして 「生成されたユーザが保存される」 ことです。 コードで表現すべきはこういった本質的なことです。 決して特定のデー タストアにまつわるアレやコレやではありません。

ソフトウェアシステムにおいてデータの保存処理はなくてはならないものです。 しかし、保存処理にまつわるコードをそのまま記述すると処理の趣旨がぼやけてし まいます。 この問題を解決するには、次の章で解説するリポジトリというパターン が役立ちます。

COLUMN ドメインサービスの基準

ドメインサービスはドメインモデルのコード上の表現であり、括りとしては値オ ブジェクトやエンティティと同一です。 そのためドメインサービスは入出力を伴う 処理を取り扱わないようにすべきという考えもあります。 それに照らし合わせると 本文のように「ユーザの重複」に関する確認をドメインサービスとして実装するこ とは間違っています。

本来データストアが存在しないドメインにとって、 入出力操作はアプリケーショ ンを構築する上で追加されたもので、 アプリケーションの関心事です。そのためド メインの概念や知識のコード上の表現であるドメインオブジェクトが、 データスト ア操作を取り扱うことは好ましくありません。 ドメインオブジェクトはドメインモ デルを表現することに徹するべきです。 にもかかわらず題材を、それに反するもの にしたのかというと、筆者の見解と異なるからです。

その処理がドメインサービスかどうかを見極める際に筆者が重要視していること は、ドメインに基づくものかそうでないかという点です。 「ユーザの重複」という考 えがドメインに基づくものであれば、それを実現するサービスはドメインサービス です。 それをコードとして表現するためにインフラストラクチャのサービスの協力 を得ることは問題ないと考えています。 反対に、 もしもアプリケーションを作成す るにあたって必要になったのであれば、それはドメインサービスでありません。 そ れはアプリケーションのサービス(第6章) として定義されるものでしょう。

もちろん、可能な限り入出力はドメインサービスで取り扱わないようにするとい う方針には賛成です。 それを考慮した上で、必要とあらば入出力の伴う操作をドメ インサービスとすることも厭いません。 いと

DDD 物流システムに見る 4.5 ドメインサービスの例

ドメインサービスにはデータストアといったインフラストラクチャが絡まないド メインオブジェクトの操作に徹したものも存在します。 というよりむしろこちらの 方が本流でしょう。 少し脇道に逸れることになりますが、ここでユーザの重複確認 以外のドメインサービスの例を確認します。

ここで題材とするのは物流システムです。

物流システムでは、 荷物を拠点から直接配送するのではなく、 拠点から配送先の 近くの拠点に輸送してから配送をします (図 4.1)。

輸送 配送 transport delivery 物流提点 物流提点 配送先

図4.1 配送のイメージ

この輸送の概念をコードに落とし込んでみましょう。

4.5.1 物流拠点のふるまいとして定義する

図4.1には物流拠点という用語があります。 これはドメインの重要な概念で、エ ンティティとして定義されています (リスト4.13)。

リスト 4.13 物流拠点エンティティ

// 処理の具体的な内容は主題ではないので省略 class Physical DistributionBase { (･･･略･･･) public Baggage Ship (Baggage baggage) { (･･･ ･･･) }

public void Receive (Baggage baggage)

{

(------)

}

}

物流拠点には出庫 (Ship) と入庫 (Receive) のふるまいがあります。 出庫と入 庫はセットで取り扱われるべき活動です。 誤って出庫していない架空の荷物を入庫 してしまったり、出庫したまま荷物をほったらかすということは起きてはいけませ ん。 現実では物理法則に従い出庫と入庫は確実にセットで実施されますが、 プログ ラムではそうはいきません。 間違いなくセットで実行する 「輸送」 の処理を準備す る必要があります。

さて、輸送処理を準備するにあたって、 どこにその記述をすべきでしょうか。 拠 点から拠点へ荷物を移す輸送は物流拠点を起点にしています。 物流拠点に輸送のふ るまいを定義してみましょう (リスト4.14)。

リスト4.14: 物流拠点に輸送のふるまいを定義する

class PhysicalDistributionBase

{

(･･･略･･･)

public void Transport (Physical Distribution Base to, ➡

Baggage baggage)

{

var shippedBaggage = Ship (baggage);

to. Receive (shippedBaggage);

// たとえば配送の記録は必要だろうか

}

}

リスト4.14の処理自体は問題なく完了するでしょう。 Transportメソッドを利 用する限り出庫と入庫は1対1で行われます。 しかし、 物流拠点が他の物流拠点へ

直接荷物を渡すというのは少しぎこちなさを感じます。 また現時点のコードはコン テキストによる要素をそぎ落としている極力シンプルなサンプルです。実際にはリ スト4.14にコメントとして記述されているような、 配送の記録などの操作が必要 となる可能性もあります。 それらの操作がすべて物流拠点オブジェクトによって執 り行われるというのは、違和感を覚えるのと同時に扱いづらさも感じることでしょ う。

4.5.2 輸送ドメインサービスを定義する

どうやら輸送という概念は特定のオブジェクトのふるまいとすると不都合のある ふるまいのようです。 そこで今度は物流拠点のふるまいではなく、 輸送を執り行う ドメインサービスとして定義してみましょう (リスト4.15)。

リスト4.15 輸送ドメインサービス

class TransportService

public void Transport (Physical Distribution Base from, ➡

PhysicalDistribution Base to, Baggage baggage)

var shippedBaggage = from.Ship (baggage);

to. Receive (shippedBaggage);

{

// 配送の記録を行う

(......)

{

リスト 4.14 に存在したぎこちなさがなくなっています。 もし配送の記録を行っ たとしても、違和感を感じることはありません。

そのオブジェクトの定義に納まらない操作を無理やり押し込むことになりそうな ときは、ドメインサービスとして切り出すことがドメインの概念を自然に表現する ことに繋がります。

}

COLUMN 規則

ドメインサービスの命名

ドメインサービスの命名規則は次の3つに分けられます。

① ドメインの概念 ② ドメインの概念 + Service ③ ドメインの概念+DomainService

サービスはドメインの活動がその対象となりやすく、動詞に基づいて命名される ことが多いです。

筆者は②の接尾句にService を付けるルールを採用することが多いです。 接尾句 として Domain Service ではなく Service を採用している理由はドメインサービス はそもそもサービスであり、 それがドメインサービスかどうかはその由来によって 決定づけられるべきと考えているからです。 具体的なコードでいえばXxxDomain. Services.XxxService という名前空間により、 XxxService はドメインサービスであ ることがわかります。

「ユーザの重複確認」 といったある特定のドメインオブジェクトと密接に関わる ようなサービスは、 User Service のようにドメインオブジェクト名に Service を付 けた名前にし、そこに処理をまとめます。 もしも 「ユーザの重複を確認する」こと がそれ単体で独立させる必要があればCheckDuplicateUserService といったクラ スに仕立てることもあります。

①のドメインの概念単体で定義する方がより表現として適切ですが、 それがサー ビスであることを常に頭の片隅で意識しておく必要があるでしょう。

③はドメインサービスを強調するものです。 コード単体で見たときのわかりやす さは他の追随を許しません。

いずれにせよ、ドメインサービスであることがチームの共通の認識となるのであ ればどれを選択しても構いません。

082

DDD 4.6

まとめ

本章ではドメインのサービスであるドメインサービスを学びました。 ドメインにはドメインオブジェクトに実装すると不自然になるふるまいが必ず存 在します。 これは複数のドメインオブジェクトを横断するような操作に多く見られ ます。 そんなときに活用するのがサービスと呼ばれるオブジェクトです。

サービスは便利な存在です。 ドメインオブジェクトに記述すべきふるまいは、や ろうと思えばすべてサービスに移し替えられてしまいます。 ドメインモデル貧血症 を起こさないために、 そのふるまいがどこに記述されるべきかということに細心の 注意を払うようにしてください。 ふるまいに乏しいオブジェクトは手続き型プログ ラミングを助長し、 ドメインの知識をオブジェクトのふるまいとして表現するチャ ンスを奪います。

ここまでの内容で値オブジェクト・エンティティ・ドメインサービスという基本 的なドメインの概念を表現する手段が揃ったことになります。 さらに本章ではそれ らの要素を使い、ついにユースケースを組み立てることを行いました。

しかし、それと同時に1つの課題が浮き出てきました。 その課題はユースケース がデータストアの操作に終始してしまっていることです。 次章で解説するリポジト リはこの課題を解決する力をもったパターンです。



Chapter 5 データにまつわる 処理を分離する 「リポジトリ」

リポジトリは永続化や再構築を担います。

ソフトウェアを継続して成長させるためにはコードの 意図を明確にすることが求められます。 オブジェクト の永続化 (保存) や再構築 (復元)といった操作は 重要ですが、 データストアを操作するコードはプログ ラムの意図をぼやけさせます。 意図を明確にするには データストアにまつわる処理を切り離すことが必要で す。 リポジトリはそういった操作を抽象的に扱えるよ うに仕立てて、処理の意図を明確にすることを可能に します。

リポジトリがもたらすものはそれだけではありません。 データストアにまつわる処理をリポジトリに寄せるこ とは、データストアの差し替えを実現します。 これは テスト実行を容易にさせ、ひいては変更の難易度を下 げることに繋がります。

リポジトリはソフトウェアの柔軟性に寄与する重要な パターンです。

10

6

5

7

4

8

2 3

DDD 5.1

リポジトリとは

リポジトリという言葉の一般的な意味は保管庫です。 ソフトウェア開発の文脈で 登場するリポジトリはまさにデータの保管庫です (図 5.1)。

図5.1:データの保管庫

ソフトウェア上にドメインの概念を表現しただけでは、アプリケーションとして 成り立たせることが難しいです。 プログラムが実行される過程でメモリ上に展開さ れたデータは、 プログラムが終了すると消えてなくなります。 特にエンティティは ライフサイクルのあるオブジェクトですから、 プログラムが終了したからといって 消えてしまっては困ります。

オブジェクトを繰り返し利用するには、何らかのデータストアにオブジェクトの データを永続化 (保存) し、 再構築 (復元) する必要があります。 リポジトリはデー タを永続化し再構築するといった処理を抽象的に扱うためのオブジェクトです。

オブジェクトのインスタンスを保存したいときは直接的にデータストアに書き込 みを行う処理を実行するのではなく、リポジトリにインスタンスの永続化を依頼し ます。 また永続化したデータからインスタンスを再構築したいときにもリポジトリ にデータの再構築を依頼します (図 5.2)。

値オブジェクト エンティティ * データストア リポジトリ

図 5.2 リポジトリを経由する

086

このようにしてデータの永続化と再構築を直接行うのではなく、 リポジトリを経 由して行うというだけのことが、 ソフトウェアに驚くほどの柔軟性を与えます。 この章ではまずリポジトリの具体的な実装方法を紹介した後、 リポジトリの利用 の仕方について確認します。 そしてリポジトリのもたらす恩恵を確認したのちに、 前章で提起された課題を解決していきます。

COLUMN

リポジトリはドメインオブジェクトを際立たせる

リポジトリはこれまで解説してきたドメインオブジェクトと異なり、 ドメインの 概念を由来とするものではありません。 その点では明確にドメインオブジェクトと は一線を画す存在です。 ではドメインと無関係であるかというとそれもまた異なり ます。

ドメインオブジェクトを利用してプログラムを組み上げて問題を解決しようとす ると、どうしてもそこには技術的要素を由来とする手の込んだコードが必要になり ます。 そうしたコードをそのまま放置すると問題解決の場は技術的要素に侵食さ れ、その趣旨やドメインオブジェクトを見えづらくします。 リポジトリはそういっ たコードを引き受け、表現の場を防衛します。

ドメインの概念を由来としないため、 リポジトリはドメインオブジェクトではあり ませんが、 ドメインモデルを表現するドメインオブジェクトを際立たせる役割があ ります。 ドメインをうまく表現するというドメイン設計の構成要素としてリポジト リは欠かせないものです。

DDD 5.2

リポジトリの責務

リポジトリの責務はドメインオブジェクトの永続化や再構築を行うことです。 永 続化とは、 インスタンスを保存し、復元できるようにすることです。

永続化というとリレーショナルデータベースを思い浮かべがちですが、 永続化を 行う具体的な技術基盤はそれに限りません。 リレーショナルデータベースと一口に いってもさまざまな種類がありますし、 それ以外にも単純にファイルにデータを保 存する場合もあれば、 NoSQLデータベースを利用する場合もあります。

いずれにせよ、 永続化を実施するために記述される特定のデータストアに基づく 具体的な手順はたいていややこしいです。 そのややこしさをそのままスクリプトに 記述するとどのような事態が発生するかをまず確認してみましょう。

リスト 5.1は第4章 「不自然さを解決する 「ドメインサービス」」 に登場したユー ザ作成処理です。

リスト 5.1:第4章で登場したユーザ作成処理

class Program

{

public void CreateUser(string userName)

{ var user = new User( ); new UserName(userName)

var userService = new UserService();

if (userService.Exists(user))

throw new Exception($"{userName}");

{

}

var connectionString = ConfigurationManager..

ConnectionStrings ["FooConnection"].ConnectionString;

using (var connection = new SqlConnection (connectionString)) using (var command = connection. CreateCommand())

{

connection.Open();

command.CommandText = "INSERT INTO users (id, name) → VALUES (@id, @name)";

command.Parameters.Add(new SqlParameter("@id", →

user.Id.Value));

command.Parameters.Add(new SqlParameter("@name",

user. Name.Value));

command.ExecuteNonQuery();

}

}

}

088

コードの前半部分でユーザの生成と重複確認を行っていることを読み取るのはた やすいです。 後半はどうでしょうか。 SqlConnection を利用していることからリ レーショナルデータベースの操作をしていることは読み取れます。 しかし、その具 体的な処理内容が User オブジェクトのインスタンスを保存していることまで把握 することは、コードを詳しく読み込むまではわからないでしょう。

次にリスト 5.1 で利用されている UserService の処理を確認してみます (リスト 5.2).

リスト 5.2 UserService の処理内容

class UserService

{ public bool Exists (User user) {

var connectionString = ConfigurationManager.→ ConnectionStrings [ "FooConnection").ConnectionString; using (var connection = new SqlConnection (connectionString)) { using (var command = connection.CreateCommand()) connection.Open(); command.CommandText = "SELECT * FROM users WHERE name= @name"; command.Parameters.Add(new SqlParameter("@name", user.Name.Value)); using (var reader = command.ExecuteReader()) { var exist = reader.Read(); return exist; } }

UserService の Existsメソッドはリレーショナルデータベースの操作に終始し ています。 ユーザの重複が何をもってして判断されるか読み取ることができたで しょうか。 ユーザの重複のルールは処理を詳しく読み込み、 発行しようとしている

クエリを確認することで初めて読み取れる情報です。

ユーザ作成処理と重複確認処理はいずれも間違いなく動作はするものの、 その コードの大半はデータストアの具体的な操作に追われてしまっているため、趣旨が 読み取りづらくなっています。 このような具体的でややこしいデータ永続化の処理 は抽象的に扱うと処理の趣旨が際立ちます。 永続化処理を抽象化して取り扱うリポ ジトリを利用するように変更してみましょう。

まずはユーザ作成処理をリポジトリを利用した実装に書き換えます (リスト 5.3).

リスト 5.3 リポジトリを利用したユーザ作成処理

class Program { private IUserRepository userRepository;

public Program (IUserRepository userRepository)

{ } this.userRepository = userRepository;

public void CreateUser(string userName)

{

var user = new User ( ); new UserName (userName)

var userService = new UserService (userRepository); if (userService.Exists(user)) { } throw new Exception($"{userName}は既に存在しています");

userRepository.Save (user);

}

}

090

User オブジェクトの永続化はリポジトリである IUserRepository オブジェクト に対して依頼されるようになります。 データストアがリレーショナルデータベース か、それとも NoSQL データベースなのか、はたまたファイルなのかということは ドメインにとって重要なことではありません。 重要なことはインスタンスを何らか の手段によって保存するということです。 データストアに対する命令を抽象的に行 うことで、コードは具体的なデータストアにまつわるややこしい処理から解き放た れ、ユーザ作成処理として純粋なロジックになったのです。 もはやコードの意図す るところは明確であり、コメントで補足することすら不要です。

次にドメインサービスの実装はどのように変化するでしょうか。 確認してみま しょう (リスト5.4)。

リスト 5.4 リポジトリを利用したドメインサービスの実装

class UserService

{

private IUserRepository userRepository;

} public UserService (IUserRepository userRepository) { } this.userRepository = userRepository; public bool Exists (User user) { } var found = userRepository. Find (user.Name); return found != null;

データベース操作によって処理の大半を埋め尽くされていたドメインサービスの コードが、 リポジトリを経由してインスタンスを再構築するようになり、 「User オ ブジェクトの重複チェックはユーザ名を起因としてチェックされる」 という意図を 示すようになりました。 ユーザ作成処理と同様に、目を凝らしてスクリプトの意図 を確認する必要はもはやありません。

このようにリポジトリは現在のインスタンスの状態を永続化し、またインスタン

スを再構築するオブジェクトです。 オブジェクトの永続化にまつわる処理をリポジ トリという抽象的なオブジェクトに任せることでビジネスロジックはより純粋なも のに昇華されるのです。

DDD リポジトリのインターフェース 5.3

リポジトリを利用したコードとそれがもたらす効果を確認できたところで、今度 はリポジトリの定義を確認しましょう。 リポジトリはインターフェース (抽象型) で定義されています (リスト5.5)。

リスト 5.5 User クラスのリポジトリインターフェース

public interface IUserRepository { } void Save (User user); User Find (UserName name);

ユーザ作成処理を実現するにあたって必要な処理はインスタンスの保存をするこ とと重複チェックのための復元です。 したがってIUserRepository はインスタンス を保存するためのふるまいとユーザ名によるインスタンスの復元を提供していま す。 再構築をしようとしたとき、 対象となるオブジェクトが見つからなかった場合 にはnull を返却することで見つからなかったことを表現します。

重複チェックという目的を鑑みるとExistsメソッドをリポジトリに実装すると いうアイデアが浮かぶこともあるでしょう (リスト5.6)。

リスト5.6 リポジトリに重複確認メソッドを追加した場合

public interface IUserRepository { } void Save (User user); User Find (UserName name); bool Exists (User user);

092

しかし、リポジトリの責務はあくまでもオブジェクトの永続化です。 ユーザの重 複確認はドメインのルールに近く、 それをリポジトリに実装するというのは責務と して相応しくありません。 もしもリポジトリに Exists が定義されると、 リポジトリ の実装次第で動作が変わってしまう可能性があります。 ユーザの重複確認はあくま でドメインサービスが主体となって行うべきです (リスト 5.7)。

リスト 5.7 リスト 5.6を利用するとドメインサービスが主体とならない

class UserService

{

private IUserRepository userRepository; (･･････) public bool Exists (User user) { // ユーザ名により重複確認を行うという知識は失われている return userRepository. Exists (user); } }

ドメインサービスにインフラストラクチャにまつわる処理を嫌って、 リポジトリ に重複確認を定義する場合は、リスト 5.8のように具体的な重複確認のキーを引き 渡すようにするとよいでしょう。

リスト5.8 リポジトリに重複確認を定義する場合

public interface IUserRepository { } (･･･略･･･) public bool Exists (UserName name);

その他に、 リポジトリに定義するふるまいは、たとえばUserの識別子である Userldによる検索メソッドなども考えられます。 しかし、いま焦って準備する必要 はありません。 早まって準備しても、結局不要になることもあります。 いま時点で

は最低限必要な処理だけを定義するにとどめておきましょう。

COLUMN nullOption

C#ではnullを利用してオブジェクトの有無を表現しますが、 null を扱うことに 拒否感を覚える方もいるでしょう。 それはおそらく正しい感覚です。

null は人類が取り扱うには難しい概念です。 null が存在するプログラミング言語 に携わる開発者であれば、誰しも一度は null参照によるエラーを引き起こしたこと があるのではないでしょうか。 それほど null を発端とするバグは多くの開発者を悩 ませています。

null によるバグを起こさないために取れる最善の手段はnullを扱わないことで す。 世の中にはnullが存在しないプログラミング言語も存在します。 そういった言 語ではオブジェクトの有無を表現するのに Option 型 (またはそれに類するもの) を利用します (リスト 5.9)。

リスト 5.9 Option 型を取り入れたリポジトリ

public interface IUserRepository { } void Save (User user); Option <User> Find (UserName name);

Option 型は戻り値のオブジェクトが存在することもあればしないこともある、 という型です。 Option 型を戻り値とするメソッドは、その型情報だけでオブジェク トが見つからない 「こともある」 ということを表現していることになります。 した がってOption 型を採用すれば 「// 見つからないときはnull を返却する」とコメン トする必要もなくなります。

DDD SQL を利用したリポジトリを 54 作成する

インターフェースを準備したところでいよいよインターフェースの実体となるリ ポジトリを実装していきます。

094

もともとのコードはデータストアとしてリレーショナルデータベースを利用して いました。 最初に実装するリポジトリは、このリレーショナルデータベースを対象 とするリポジトリです (リスト 5.10)。

リスト 5.10:SQLを利用したリポジトリ (Save メソッド)

public class UserRepository: IUserRepository

{

private string connectionString = ConfigurationManager.➡ ConnectionStrings ["DefaultConnection"].ConnectionString;

public void Save (User user)

{

using (var connection = new SqlConnection (connectionString))

using (var command = connection. CreateCommand())

{

connection.Open();

command.CommandText = @"

MERGE INTO users

USING (

SELECT @id AS id, @name AS name

) AS data

ON users.id = data.id

WHEN MATCHED THEN

UPDATE SET name = data.name

WHEN NOT MATCHED THEN

INSERT (id, name)

VALUES (data.id, data.name);

command.Parameters.Add(new SqlParameter("@id", user.Id.Value));

command.Parameters.Add(new SqlParameter("@name", → user.Name.Value));

command.ExecuteNonQuery();

}

}

(---B---)

}

UserRepository の SaveメソッドはUserのインスタンスをリレーショナルデー タベースへ保存するために UPSERT 処理 (データが存在したらUPDATE、 さもな ければINSERT を行う)を行います。 UPSERT 処理の実現方法は自身でSELECT 文を発行しデータが存在するか否かで処理を切り替えてもよいですし、 サンプル コードのようにデータベース固有の構文 (MERGE文) を使用しても構いません。 ビジネスロジックに特定の技術基盤に依存した処理を記述したいとは思いません が、リポジトリの実装クラスでは技術基盤に依存した処理を記述しても問題ないの です。

次にFindメソッドの実装も確認してみましょう (リスト 5.11)。

リスト 5.11SQLを利用したリポジトリ (Findメソッド)

public class UserRepository: IUserRepository

(------)

public User Find (UserName userName)

using (var connection = new SqlConnection (connectionString)) using (var command = connection.CreateCommand()) {

connection.Open();

@name"; command.CommandText = "SELECT * FROM users WHERE name=

command.Parameters.Add(new SqlParameter ("@name",

userName.Value)); using (var reader = command.ExecuteReader()) { if (reader.Read()) {

{

{

096

var id = reader['id'] as string;

var name = reader["name"] as string;

return new User(

new UserId(id),

new UserName (name)

);

}

else

{

return null;

}

}

}

} }

Findメソッドは引数として渡されたデータによってusersテーブルに問い合わ せを行い、 Userオブジェクトのインスタンスを構築して返却します。 もしもデータ が見つからなかったときはnull を返却します。

こうして実装されたリポジトリはリスト 5.12のようにコンストラクタでProgram クラスに引き渡されます。

リスト5.12 リポジトリを Program クラスに引き渡す

var userRepository = new UserRepository(); var program = new Program (userRepository); program.CreateUser ("naruse");

Program クラスはIUserRepository を扱いますが、 その実体はUserRepository です。 したがってIUserRepository のSaveメソッドが呼び出されるとUserRepository のSave メソッドに制御が移り、 UPSERT 処理が実行されます。 また、 UserService でも同様にIUserRepository の Findメソッドが呼び出されるとUserRepository のFindメソッドが実行され、リレーショナルデータベースからオブジェクトが再 構築されます (図 5.3)。

Program UserService IUserRepository Save UserRepository Save Find Find

図5.3 UserRepository の動作イメージ

このようにインターフェースをうまく活用することで、 Program クラス上では 具体的な永続化にまつわる処理を記述せずにデータストアにインスタンスを永続化 できるようになります。

DDD 5.5 テストによる確認

ソフトウェアを開発するにあたり、テストは欠かせないものです。 開発者は自身 の意図にしたがってプログラムが動作することを期待しますが、 残念ながらプログ ラムは開発者の意図ではなく記述に沿って動作します。

プログラムが開発者の意図どおりの動作をしているかどうかは常に確認する必要 があります。 その確認方法として代表的なものがテストです。 意図したとおりに動 作するかどうか、 実際に動かしてしまえばよいというわけです。

またテストは動作の確認以外に、 ソフトウェアの柔軟性を担保することにも寄与 します。

ソフトウェアの変更は簡単なものではありません。 要件にしたがって変更すべき コードの特定と変更を慎重に行い、 なおかつソフトウェアを破壊しないことが求め られます。このときテストが前もって用意されているのであれば、 コードを変更し た後にテストを実施することでソフトウェアを破壊していないこと (または破壊し ていること)がわかります。 この保証は変更にかかる検証のコストを減らすものです。

ドメインの変化を受けてソフトウェアが変化するためにはテストを用意すること が重要です。

わる処理を分離する「リポジトリ」

098

5.5.1 テストに必要な作業を確認する

ユーザ作成処理が意図したとおりに動作しているかを確かめるために、テストを 行うイメージをしてみましょう。

テストをするにはまずリレーショナルデータベースが必要です。 インストーラを 手に入れてインストールしましょう。 無事インストールが終わったら接続文字列を ローカルのデータベースへ向けるために書き換える必要があります。 コンフィグ ファイルを一時的に変更しましょう。 データベースが準備できたら問い合わせ先と なるテーブルも用意しないといけません。 コードを確認すると "SELECT * FROM users" というクエリ文が発行されているのでusersテーブルが必要そうです。 また テーブル作成のためにはカラムの定義が必要です。 もう一度コードを確認すると ユーザIDとユーザ名のカラムをそれぞれ文字列のデータタイプで定義すればよさ そうです。 集まった情報をもとにテーブル作成をしましょう。 コードにはユーザの 重複を確認する処理もあります。 重複の確認処理が正しく動作しているかを確認す るためにデータの投入をしておきましょう。

データベースの準備は一度行ってしまえば、よほどのことがなければ再度行う必 要はありません。 しかし、 テーブルの準備はそうではありません。 ロジックによっ て必要なデータが異なるため、 ロジックが増えるにしたがって適宜テーブルを追加 する必要があります。 処理にいくつもの機能があったときはもっと悲惨です。 確認 したい項目にしたがって最適なテスト用のデータをいちいち投入しなくてはいけま せん。 場合によっては以前のテストで使用したデータを消す必要もあるでしょう。 イメージはできたでしょうか。 それは恒常的に行いたい作業でしょうか。

5.5.2 祈り信者のテスト理論

テストを行うための手間が積み重なると開発者は次第にテストに対して誠実でな くなっていきます。

開発者は多くのタスクを抱えているため、 タスクをこなすための効率化に熱心 で、 作業に対するコストとそれに対する対価に敏感です。 それと同時にある程度の 経験値を積んだ開発者であれば、記述したコードが 「おそらく」 意図したとおりに 動作するだろう、といった判断ができてしまいます。 効率化に熱心な開発者にとっ て、「たいてい」うまく動作するコードに対して多大な労力をかけてテストを行うこ とは、コストと対価が見合わないように感じられてしまいます。結果として動く 「だろう」と予測されたコードはプロダクトに混入されるのです。

テストをしなかったコードに対して、 開発者にできることは祈りを捧げることだ けです。

「どうか、 このコードが問題なく動きますように」

願いは不安の裏返しです。 開発者はリリース直後から不安を抱えることになりま す。 そして数日後、 また数週間後、 あるいはもっと先の未来になってやっとひとつ の感想を抱くのです。

「あぁ、あのコードはどうやら正しかったみたいだ」

こうした歪な成功経験は、より一層開発者をテストから遠ざけ、 動く 「だろう」 で記述したコードが正しく動くように祈ることに夢中にさせます。 もちろん祈るこ とは最善策ではありません。 プログラムの挙動が祈りによって変わることはありえ ないのですから。

5.5.3 祈りを捨てよう

祈ることに慣れた開発者に祈りを捨てさせ、テストをするように駆り立てる方法 は大きく分けて2つあります。 恐怖による統制を行うか、 効率的にテストが行える ようにするかです。 システム開発に携わるものが取るべきアクションとして適切な のは後者です。 ここではテストの効率化を考えましょう。

現在の問題はテストをするためにデータベースをインストールしたり、 テーブル を準備しなくてはいけなかったりと、 準備作業が煩雑なことです。 この問題を解消 する方法は単純です。 データベースを利用しないようにすればよいのです。 つまり、 具体的にはデータベースに依存しないテスト用のリポジトリを利用します。

DDD テスト用のリポジトリを 56 作成する

テストを行う際に特定のインフラストラクチャを準備するのはとても億劫です。 これを解決するためにはメモリをデータストアとして、 インメモリで動作するよう にすることです。 インスタンスを保存する媒体としてメモリを利用する際にもっと も扱いやすいものは連想配列です。 リスト 5.13 は連想配列をベースとしたリポジ トリの実装です。

わる処理を分離する「リポジトリ」

100

リスト 5.13: 連想配列をベースとしたリポジトリ

class InMemoryUserRepository: IUserRepository

// テストケースによってはデータを確認したいことがある

// 確認のための操作を外部から行えるようにするためpublicにしている

public Dictionary<UserId, User> Store { get; } = → new Dictionary<UserId, User>();

public User Find (UserName userName)

{

var target = Store. Values

.FirstOrDefault(user = userName. Equals(user.Name));

if (target != null) {

// インスタンスを直接返さずディープコピーを行う

return Clone (target);

}

else

return null;

{

}

}

public void Save (User user) { } // 保存時もディープコピーを行う Store[user.Id] = Clone (user);

// ディープコピーを行うメソッド

private User Clone (User user) { } } return new User (user.Id, user.Name);

{

まずはデータの保存先を確認しましょう。 データの保存先になる連想配列は一般 的なものです。 添え字にはオブジェクトの識別子にあたる値オブジェクトを利用し ています。 値オブジェクトを連想配列の添え字として採用する場合はEquals メ ソッドとGetHashCodeをオーバーライドする必要があります。 もしもメソッドの オーバーライドができない場合は、ラップされた実際の値を添え字として利用する 選択肢もあります。

次に Findメソッドを確認します。 このメソッドは連想配列からターゲットとな るインスタンスの検索をしています。 First OrDefault は C# 特有の集合操作のライ ブラリ (Linq) の検索メソッドです。 もちろんリスト 5.14のように繰り返し構文で 記述する手立てもあります。

リスト 5.14: リスト 5.13の Findを繰り返し構文で記述したとき

public User Find (UserName name) { foreach (var elem in Store.Values) { if (elem.Name.Equals (name)) { return Clone (elem); } } } return null;

検索して見つけ出したインスタンスはそのまま返却せず、ディープコピー(*1)を して返却します。 これは復元したインスタンスへの操作がリポジトリ内で保持して いるインスタンスにまで影響を及ぼす (リスト5.15) ことを防ぐためです。

[*1] オブジェクトのみのコピーではなく、 オブジェクトとメモリ上にロードされたデータの両方 をコピーすること。

102

リスト 5.15 オブジェクトへの操作がリポジトリ内部のインスタンスに影響してしまう

// オブジェクトを再構築する際にディープコピーを行わないと var user = userRepository. Find (new UserName("Naruse")); // 次の操作がリポジトリ内部で保管されているインスタンスにまで影響する user.ChangeUserName (new UserName("naruse"));

同じ理由で Save メソッドにおいてもインスタンスを保存する際にインスタンス のディープコピーを行っています。 これは先ほどとは反対の理由で、 保存処理後に リポジトリ内部のインスタンスに影響を及ぼす (リスト5.16) ことを防ぐためで す。

リスト 5.16 保存処理後にリポジトリの内部のインスタンスに影響してしまう

// ここでインスタンスをそのままリポジトリに保存してしまうと

userRepository.Save (user);

// インスタンスの操作がリポジトリに保存したインスタンスにまで影響する

user.ChangeUserName (new UserName ("naruse"));

データベースなどに保存を行うプロダクション用のリポジトリでは最適化などを 理由に差分を検知して、 差分だけの更新を行うことがありますが、 InMemoryUser Repository はその用途がテストに限られています。 現段階ではそこまでの考慮は 不要でしょう。

さぁ、テストのためのリポジトリの解説はおしまいです。 いよいよユーザ作成処 理をテストしてみましょう (リスト5.17)。

リスト 5.17 ユーザ作成処理をテストする

var userRepository = new InMemoryUserRepository(); var program = new Program (userRepository); program.CreateUser ("nrs");

// データを取り出して確認 var head userRepository.Store.Values.First(); Assert. AreEqual("nrs", head.Name);

データベースに接続する必要がなくなるだけで、テストは驚くほど気軽に行えま

す。 もはや不安を抱えて眠れぬ夜を過ごしながらリリースを迎える必要はありませ ん。 間違いなく動作する自信がつくまで、思う存分テストをしてください。

DDD オブジェクトリレーショナルマッパー 5. 7 を用いたリポジトリを作成する

昨今のソフトウェア開発においては直接SQL文をコード上で組み立てて実行せ ず、オブジェクトリレーショナルマッパー (ORM、O/R Mapper) を利用する手 法がメジャーです。 この節ではオブジェクトリレーショナルマッパーを活用したリ ポジトリの実装を確認しましょう。

C#のオブジェクトリレーショナルマッパーとしてはEntityFramework が有名 です。 リスト 5.18 は EntityFrameworkを利用したリポジトリの実装です。

リスト 5.18 Entity Framework を利用したリポジトリ

public class EFUserRepository: IUserRepository {

private readonly MyDbContext context;

public EFUserRepository (MyDbContext context)

{

this.context = context;

}

public User Find (UserName name )

var target = context.Users

{

FirstOrDefault (userData => userData.Name == name.Value);

if (target == null)

{

return null;

}

104

return ToModel (target);

}

public void Save (User user)

var found = context.Users. Find (user.Id.Value);

if (found == null)

{

var data = ToDataModel (user);

context.Users.Add(data);

}

else

{

var data = Transfer (user, found);

context.Users.Update(data);

}

context.SaveChanges();

}

private User ToModel (UserDataModel from)

{

return new User(

new UserId(from.Id),

new UserName (from. Name)

);

}

private UserDataModel Transfer (User from, UserDataModel model)

model.Id = from. Id.Value;

{

model.Name = from. Name.Value;

{

return model;

}

private UserDataModel ToDataModel (User from)

{

return new UserDataModel

{

Id = from.Id.Value,

Name = from.Name.Value,

};

}

}

名前空間を利用しEF.UserRepository というクラス名にしても構いません。 紙 面上では見分けづらいためクラス名はEFUserRepository としています。

EntityFrameworkにおいてはデータストレージとして利用するオブジェクト (データモデル)のことをエンティティといいます。 UserDataModel は Entity Frameworkのエンティティです (リスト 5.19)。

リスト 5.19 EntityFrameworkが直接利用するデータモデル

[Table("Users")] public class UserDataModel

[Database Generated (DatabaseGeneratedOption.None)]

public string Id { get; set; }

{

[Required]

[MinLength(3)]

public string Name { get; set; }

}

このエンティティは名前こそ同じものの第2章で解説したドメイン駆動設計のエ ンティティとは明確に異なるものです。 UserDataModelという名前はそれを強調 しています。 もちろん名前空間を利用しUserというデータモデルを作成しても構

106

いません (リスト5.20)。

リスト 5.20: 名前空間によりUserクラスとして定義する

namespace Infrastructure. DataModel. Users { [Table("Users")] public class User { } [DatabaseGenerated (DatabaseGeneratedOption.None)] public string Id { get; set; } [Required] [MinLength(3)] public string Name { get; set; } }

重要なことはドメインオブジェクトがドメインの知識を表現することに集中する ことです。 特定の技術基盤に流用するためにドメインオブジェクトにゲッターや セッターを定義するようなことは避けるべきです。

さぁ、EFUserRepository を使ってみましょう。 EFUserRepository は IUser Repository を実装しているので、 Program クラスに引き渡せます(リスト5.21)。

リスト 5.21: Entity Framework を利用したリポジトリを使ったテスト

var userRepository = new EFUserRepository (myContext);

var program = new Program (userRepository);

program.CreateUser ("naruse");

// データを取り出して確認

var head = myContext.Users.First();

Assert, AreEqual("naruse", head. Name);

リポジトリの実体が差し変わっているだけで、 Program クラスがインスタンス 化された以降の処理はインメモリのリポジトリを使ったテスト (リスト5.17) と まったく同じです。

10.

DDD リポジトリに 5.8 定義されるふるまい

リポジトリにはオブジェクトの永続化と再構築に関するふるまいが定義されま す。 ここで一度それらを確認しておきましょう。

5.8.1 永続化に関するふるまい

オブジェクトを永続化するふるまいは既にサンプルとして登場しているSaveメ ソッドです (リスト 5.22)。

リスト 5.22: 永続化を行うふるまい

interface IUserRepository { void Save (User user); } (･･･略･･･)

メソッド名がSave であることは強制されるものではなく、 たとえばStoreと いった名前でも構いません。

永続化のふるまいは永続化を行うオブジェクトを引数に取ります。 したがって、 リスト 5.23のような対象の識別子と更新項目を引き渡して更新させるようなメ ソッドは用意しません。

リスト 5.23: 更新項目を引き渡す更新処理 (悪い例)

interface IUserRepository { } void UpdateName (UserId id, UserName name); (･･･略･･･)

リスト 5.23 のコードが行き着く先はリポジトリに多くの更新処理を定義させる 結果に繋がります (リスト5.24)。

まつわる処理を分離する「リポジトリ」

108

リスト 5.24 煩雑な更新処理が定義されたリポジトリ (悪い例)

interface IUserRepository { } void UpdateName (UserId id, UserName name); void UpdateEmail (UserId id, Email mail); void UpdateAddress (UserId id, Address address); (･･･略･･･)

そもそもオブジェクトが保持するデータを変更するのであれば、それはオブジェ クト自身に依頼すべきです。 こういったコードは避けましょう。

同様にオブジェクトを作成する処理もリポジトリには定義しません。 コンストラ クタを使った生成以外のオブジェクト生成は第9章 「複雑な生成処理を行う 「ファ クトリ」」で取り上げます。

他に、永続化に関係するふるまいとして挙げられるのはオブジェクトの破棄に関 する操作です。 ライフサイクルのあるオブジェクトは不要になったとき破棄されま す。 それをサポートするのはリポジトリの役目です。 リスト 5.25のように破棄を行 うメソッドがリポジトリに定義されます。

リスト 5.25 破棄を行うふるまいを定義したリポジトリ

interface IUserRepository { } void Delete (User user); (･･･略･･･)

5.8.2 再構築に関するふるまい

もっとも頻繁に利用される再構築のふるまいは識別子によって検索されるメソッ ドです (リスト 5.26)。

リスト 5.26 識別子によって検索されるメソッド

interface IUserRepository { User Find (UserId id); } (------)

基本的にはこの識別子による検索メソッドを利用しますが、 たとえばユーザ名の 重複が発生しているかを確認するためには全件取得する必要があります。 そういっ たときには対象となる全オブジェクトを再構築するメソッドを定義します (リスト 5.27).

リスト 5.27: すべてのオブジェクトを再構築するメソッド

interface IUserRepository { List<User> FindAll(); (･･･略･･･) }

ただし、この操作を定義することについては慎重にならなくてはなりません。 再 構築されるオブジェクトの数によっては、 コンピュータのリソースを食いつぶして しまうからです。

パフォーマンスを起因とする深刻な問題を避けるために、 探索を定義する際には それに適したメソッドを定義します (リスト 5.28)。

リスト 5.28 探索に適したメソッド

interface IUserRepository

{

User Find (UserName name);

// オーバーロードがサポートされていない言語の場合は命名によりバリエーションを→ 増やす

// User FindByUserName (UserName name);

(･･････)

}

110

これであれば検索に利用するデータを引数で受け取っているので、 リポジトリの 実体が最適化した検索を行えます。

DDD 5.9

まとめ

ロジックが特定のインフラストラクチャ技術に依存することはソフトウェアを硬 直化させることに繋がります。 コードの大半はデータストアに対する詳細な操作に 汚染され、処理の目的がぼやけてしまっているでしょう。

リポジトリを利用するとデータの永続化にまつわる処理を抽象化することができ ます。 たったそれだけのことが驚くほどの柔軟性をソフトウェアに与えます。 たとえば、開発初期にどのデータストアを採用するのかが決まっていなかったと

しても、インメモリのリポジトリを利用してロジックを実装できます。 それ以外にも、 より高性能なデータストアがリリースされたときは専用のリポジトリを実装して差

し替えられます。 そしてもちろん、 テストを実施したいときにテストができます。 もちろん、 不具合はデータストアを取り扱うモジュール上で発生したり、 実行環 境に依存して発生することもあります。 そのため、最終的にはデータストアを絡め た実環境上でテストを実施することは不可欠です。 その上で、 テストを気軽に実施 できるよう仕立てる努力は品質の向上に寄与するものに違いありません。

ドメインのルールに比べると、 データストアが何であるかは些末な問題です。 リ ポジトリをうまく活用して処理の意図を明確にすることは、 後続の開発者の助けに なるでしょう。

11



Chapter 6 ユースケースを実現する 「アプリケーション サービス」

アプリケーションサービスはドメインオブジェクトを 協調させてユースケースを実現します。

値オブジェクトやエンティティといったドメインオブ ジェクトはドメインモデルをコードによって表現した オブジェクトです。

ソフトウェアとして利用者の問題を解決するために は、これらのドメインオブジェクトをまとめあげて問 題を解決するように導く必要があります。

アプリケーションサービスはドメインオブジェクトが 行うタスクの進行を管理し、 問題の解決に導くもので す。

13

10

11

9

12

8

14

7

15

6

APPA

5

DDD 6.1 アプリケーションサービスとは

第4章 「不自然さを解決する 「ドメインサービス」」 で予告した2つ目のサービス が本章で解説するアプリケーションサービスです。 アプリケーションサービスを端 的に表現するならば、ユースケースを実現するオブジェクトです。

たとえばユーザ登録の必要なシステムにおいて、 ユーザ機能を実現するには 「ユーザを登録する」 ユースケースや「ユーザ情報を変更する」 ユースケースが必要 です。 ユーザ機能のアプリケーションサービスはユースケースにしたがって 「ユー ザを登録する」 ふるまいや 「ユーザ情報を変更する」 ふるまいが定義されます。 そ れらのふるまいは実際にドメインオブジェクトを組み合わせて実行するスクリプト のようなふるまいです。

この章ではこのユーザ機能に必要なユースケースを作成する過程を確認すること で、アプリケーションサービスがどういったものかを確認していきます。

COLUMN

アプリケーションサービスという名前

アプリケーションの意味を知ることはアプリケーションサービスを知る手掛かり です。

アプリケーションは一般的に利用者の目的に応じたプログラムのことを指しま す。 アプリケーションの目的は利用者の必要を満たしたり、 目的を達成することで す。

ドメインオブジェクトはドメインのコード上の現身です。 ドメインをコードとし て表現したとしても、 そこに存在する必要や問題は依然として残ったままです。 利 用者の必要を満たしたり、 問題を解決するためにはドメインオブジェクトの力を束 ね上げて導く必要があるのです。

ドメインオブジェクトを操作し、 利用者の目的を達成するように導くアプリケー ションサービスにアプリケーションの名が冠していることも自然に思えるのではな いでしょうか。

ースケースを実現する「アプリケーションサービス」

114

DDD 6.2 ユースケースを組み立てる

アプリケーションサービスのサンプルとしてこの章で取り扱うのは、SNS(ソー シャルネットワーキングサービス) のユーザ機能です。 システムとして成り立たせ るために開発しなくてはならないものを洗い出すため、 まずはユーザ機能がどう いったものかを確認します。

利用者は最初にシステムを利用するためにユーザ登録をする必要があります。 こ のユーザはシステム上の利用者自身にあたります。 利用者は登録しておいたユーザ 情報を参照し、 場合によっては変更を行えます。 もしもシステムが利用者にとって 不要になった際には、退会を行うことでシステムの利用を停止できます。

これらの機能をもつシステムのユースケース図が図6.1です。

ユーザを登録する ユーザ情報を確認する ユーザ情報を更新する 退会する 利用者

図6.1 ユーザ機能を実現するユースケース図

ユーザ機能を実現するための 「登録する」 「情報を取得する」 「情報を更新する」 「退会する」 といったユースケースはいわゆるCRUD (CREATE READ UPDATE、 DELETE) 処理です。 これら4つの処理はシステムを開発する上では基本的な処理 です。 まさにアプリケーションサービスを作るチュートリアルとして最適でしょう。

6.2.1 ドメインオブジェクトから準備する

まずはアプリケーションサービスが取り扱うドメインオブジェクトを準備します。 今回取り扱うユーザの概念はライフサイクルがあるモデルなので、 エンティティ として実装されます (リスト6.1)。

115

62 ユースケースを組み立てる

リスト 6.1 ユーザを表すエンティティ

public class User

// はじめてインスタンスを生成する際に利用する

{

public User (UserName name)

{

if (name == null) throw new ArgumentNullException (nameof (→

name));

Id = new UserId ( Guid. NewGuid().ToString());

Name = name;

}

// インスタンスを再構成する際に利用する

public User (UserId id, UserName name)

{

if (id == null) throw new ArgumentNullException (nameof (id)); if (name == null) throw new ArgumentNullException (nameof (→ name));

} Id = id; Name = name;

public UserId Id { get; }

public UserName Name { get; private set; }

public void ChangeName (UserName name)

{

if (name == null) throw new ArgumentNullException (nameof (❤ name));

Name = name;

}

}

776

User には同一性を識別するためのUserld という識別子が属性として定義されて います。 ユーザ情報としての属性はユーザ名のみが定義されています。 いずれの属 性もシステム固有の値である値オブジェクトとして定義しますが、 現在のところは 特別なふるまいがないため、ほとんどプリミティブな文字列型の値をラップしただ けのオブジェクトです (リスト6.2)。

リスト 6.2: User クラスが利用している値オブジェクトの定義

public class UserId

{

public UserId(string value) {

if (string.IsNullOrEmpty (value)) throw new ⇒ ArgumentException("valueがnullまたは空文字です");

Value = value;

}

public string Value { get; }

}

public class UserName

{

public UserName (string value)

if (value == null) throw new Argument NullException (nameof (value));

{

if (value.Length <3) throw new ArgumentException ("ユーザ名→ は3文字以上です。", nameof (value));

if (value.Length > 20) throw new ArgumentException("ユーザ名→ は20文字以下です。 ", nameof (value));

Value = value;

} public string Value { get; }

またユーザの重複がないことを確認する必要があります。 ドメインサービスを用 意する必要があるでしょう (リスト6.3)。

リスト 6.3 ユーザのドメインサービス

public class UserService

{

private readonly IUserRepository userRepository;

public UserService (IUserRepository userRepository) { this.userRepository = userRepository; }

public bool Exists (User user)

{

var duplicatedUser = userRepository.Find(user.Name);

return duplicatedUser != null;

}

さらにユーザの永続化や再構築を行う必要があります。 ドメインモデルを表現す るドメインオブジェクトではありませんがリポジトリの準備も必要です(リスト 6.4).

リスト 6.4 ユーザのリポジトリ

}

public interface IUserRepository { User Find (UserId id); User Find (UserName name); void Save (User user);

118

}

void Delete (User user);

リポジトリにはリスト6.3が利用するメソッド以外にもCRUD処理を作るにあ たって必要となる永続化や破棄のメソッドも定義しています。 なおリポジトリの実 装クラスはまだ用意する必要がありません。 ロジックを組み立てる分にはインター フェースさえあれば十分です。

これらのオブジェクトはここまでの解説で登場してきたものばかりです。 さっそ ユーザ機能を作っていきましょう。

6.2.2 ユーザ登録処理を作成する

最初に実装するユースケースはユーザの登録処理です。 ユーザ登録処理をアプリ ケーションサービスのふるまいとして実装するとリスト6.5になります。

リスト 6.5 ユーザ登録処理の実装

public class UserApplicationService

{

private readonly IUserRepository userRepository; private readonly UserService userService;

public UserApplication Service (IUserRepository

userRepository, UserService userService)

{

this.userRepository = userRepository; this.userService = userService;

}

public void Register(string name)

{

var user = new User(

new UserName (name)

);

if (userService.Exists (user))

{

throw new CanNotRegisterUserException (user, "ユーザは既に→

存在しています。");

}

userRepository.Save (user);

}

Registerメソッドでは最初にUser オブジェクトを生成し、重複チェックをドメ インサービスであるUserService に依頼しています。 その結果としてユーザが重複 しないことを確認できた場合に、 IUserRepository にインスタンスの永続化を依頼 することでユーザの登録を完了します。

第5章 「データにまつわる処理を分離する 「リポジトリ」」 の解説を読み終えた読 者は不思議なことに気づくでしょう。 このコードはこれまでの解説で取り扱ってき た Programクラスとほとんど同じコードです。 そう、実は Programクラスはアプ リケーションサービスだったのです。

6.2.3 ユーザ情報取得処理を作成する

ユーザを登録したら登録された情報を確認する必要があります。 ユーザ情報取得 処理を UserApplicationService に追加しましょう。

ユーザ情報取得処理はユーザ登録処理と異なり、 結果を返却する必要がありま す。 このとき、 結果となるオブジェクトとしてドメインオブジェクトをそのまま戻 り値とするか否かの選択は、重要な分岐点です。

リスト6.6のコードはドメインオブジェクトを公開することに決めた場合のユー ザ情報取得メソッドの実装です。

リスト6.6戻り値としてドメインオブジェクトを公開したユーザ情報取得メソッド

public class UserApplicationService

{

private readonly IUserRepository userRepository;

}

ケースを実現する「アプリケーションサービス」

120

(---88---)

public User Get(string userId) { var targetId = new UserId(userId); var user = userRepository. Find (targetId); } } return user;

ドメインオブジェクトを公開する選択肢を選んだ場合、 アプリケーションサービ スの実装コードは比較的シンプルなものになります。 しかし、 これは同時にわずか な危険性をはらみます。 アプリケーションサービスを利用するクライアントについ て考えてみましょう。

アプリケーションサービスを利用するクライアントは、 結果として受け取ったド メインオブジェクトの属性を取得してファイルなり画面なりに出力します。 それ自 体に問題はありません。 ここで問題となるのは、リスト6.7のように意図せぬメ ソッド呼び出しを可能にする点です。

リスト6.7 ドメインオブジェクトのメソッドの意図せぬ呼び出し

public class Client

private UserApplication Service userApplicationService;

(･･･略･･･)

{

} public void ChangeName (string id, string name) { var target = userApplicationService.Get (id); var newName = new UserName (name); target.ChangeName (newName); }

リスト6.7はユーザ名の変更を目的にしたコードです。 このコードを実行したと しても、データの永続化を行っていないためその目的は達成されません。

ここで問題とすべきはこのコードの無意味さではなく、 アプリケーションサービ ス以外のオブジェクトがドメインオブジェクトの直接のクライアントとなって自由 に操作できてしまうということです。 ドメインオブジェクトのふるまいを呼び出す 役目はアプリケーションサービスの役目です。 その枠組みを超えてドメインオプ ジェクトのふるまいが呼び出されてしまうと、 本来であればアプリケーションとし て提供されるべきであったコードが各所に散りばめられる可能性を生みます。

またそれ以外にもドメインオブジェクトに対する多くの依存が発生することは問 題です。 ドメインの変化は即座にオブジェクトへ反映されるべきですが、 複雑な依 存関係の中核となるコードの変更は熟練した開発者であっても躊躇するものです。 ドメインオブジェクトを外部に向けて公開する選択肢は処理自体を単純なものに

しますが、 その代償として多くの危険性を内包します。

これを防ぐための選択肢としてアクセス修飾子によるメソッド呼び出しの制限が ありますが、 クライアントやアプリケーションサービス、 そしてドメインオブジェ クトが同一パッケージに定義される構成であったときにはそれも難しいです。 また 開発チーム内で紳士協定を結び、 ドメインオブジェクトのメソッド呼び出しに対し て制限を加える選択肢もあります。 ただし、 こういったルールによる防衛はもっと も強制力が小さく、 脆いものであることも知っておかなくてはなりません。 いずれ にせよ特効薬というほどの効力はありません。

そこで筆者がお勧めするのはドメインオブジェクトを直接公開しない方針です。 ドメインオブジェクトを非公開としたとき、クライアントにはデータ転送用オプ ジェクト (DTO、 Data Transfer Object) にデータを移し替えて返却します。

具体的なコードを見ていきましょう。 まずはUser クラスのデータを受け渡すた めのDTOを準備します (リスト6.8)。

リスト 6.8: Userクラスのデータを公開するために定義されたDTO

public class UserData { public UserData(string id, string name) { } Id = id; Name = name

122

} public string Id { get; } public string Name { get; }

DTOに対するデータの移し替え処理はアプリケーションサービスの処理上に記 述されます (リスト 6.9)。

リスト6.9 ドメインオブジェクトからDTOへのデータ移し替え処理 public class UserApplication Service { private readonly IUserRepository userRepository; (---88--) public UserData Get(string userId) { var targetId = new UserId(userId); var user = userRepository. Find (targetId); } } var userData = new UserData (user.Id.Value, user. Name.Valuereturn userData;

);

User のインスタンスは外部に引き渡されないため、 UserApplicationService の クライアントはUserのメソッドを呼び出すことができません。

なお、外部に公開するパラメータが追加されたとき、 コードはリスト6.10のよう に変更する必要があります。

リスト6.10 外部公開するパラメータが追加されたときの変化

public class UserApplicationService

private readonly IUserRepository userRepository;

{

(---88---)

public UserData Get(string userId)

{

var targetId = new UserId(userId);

var user =

userRepository.Find(targetId);

// var userData = new UserData (user.Id.Value, user.Name.Value); // コンストラクタの引数が増える var userData = new UserData (user.Id.value, → user. Name.Value, user. MailAddress.Value); } return userData; }

この修正は至極単純なもので機械的にこなせますが、 UserData オブジェクトを インスタンス化している箇所すべてにおいて同様の修正が必要です。 静的言語であ ればコンパイルエラーで該当箇所は示唆されますし、 正規表現や文字列置換を駆使 して修正を終えることは可能ですが、 あまり面白い作業でもないでしょう。可能で あれば修正箇所をまとめたいところです。

修正箇所をまとめるために取れる戦術として、 DTOのコンストラクタでUserの インスタンスを引数として受け取る方法が考えられます (リスト6.11)。

リスト6.11 ドメインオブジェクトを引数として受け取るコンストラクタを用意する

public class UserData

{

public UserData (User source) // ドメインオブジェクトを受け取っている {

Id = sourceId.Value;

Name = source.Name.Value;

}

124

} public string Id { get; } public string Name { get; }

UserData はコンストラクタの引数として受け取るUser と密な関係にあります。 Userのデータを公開するためのオブジェクトであるUserData が User に依存する ことはあまり問題になりません。

専用のコンストラクタを利用したとき、データを移し替えるコードはリスト6.12 になります。

リスト6.12: 専用のコンストラクタを利用したときのデータ移し替えを行うコード

var userData = new UserData (user);

もしもパラメータが追加されることになったとしても修正箇所はUserData クラ スを変更するだけで十分です (リスト 6.13)。

リスト6.13: 変更箇所はUserData クラスにまとめられる

public class UserData

{

public UserData (User source)

{

Id = source.Id.Value;

Name = source.Name.Value;

MailAddress = source.MailAddress.Value; // 属性への代入処理

}

public string Id { get; }

public string Name { get; }

public string MailAddress { get; } // 追加された属性

}

最後にリスト6.13を利用したユーザ情報取得処理を確認しましょう (リスト 6.14).

12

リスト6.14 リスト6.13を利用したユーザ情報取得処理

public class UserApplicationService

private readonly IUserRepository userRepository;

(･･･略･･･)

public UserData Get(string userId)

{

var targetId = new UserId (userId);

var user = userRepository. Find (targetId);

if (user == null)

{

return null;

}

return new UserData (user);

}

{

}

DTOはそのクラス自体を定義する手間とデータの移し替えを行うためドメイン オブジェクトを直接公開した場合に比べるとパフォーマンス上劣る部分はありま す。 とはいえ、よほど大量の移し替えが発生しない限り、 その影響は微々たるもの です。 不用意な依存を防ぎ、 ドメインオブジェクトの変化を妨げないようにするこ との方がときに重要視されるでしょう。

ドメインオブジェクトを公開するかしないかは大きな分岐点です。 ドメインオプ ジェクトを公開したからといって即問題が起きるわけではありません。 ドメインオ ブジェクトを非公開にしたことで増えるコード量に煩わしさを感じることもありま す。 どちらを採用するかはプロジェクトのポリシーによるところです。 重要なこと は、その選択がソフトウェアの未来を左右する可能性の秘めた決定事項であること を認識した上で決定を下すことです。

126

COLUMN

煩わしさを減らすために

あなたがドメインオブジェクトを公開しないことを決めたとしても、開発チーム のメンバーから理解を得られない可能性もあります。 単純に記述量が増えることを 嫌う開発者は一定数います。 そうしたとき取れる手段は、 彼らに降りかかる煩わし さの肩代わりをするものを用意することです。

具体的にはドメインオブジェクトを指定すると、そのDTO となるクラスコード を生成するツールを作るとよいでしょう。

開発者は面倒なものを嫌う生き物です。 だからこそ効率化に対して熱心でいられ るのです。 その熱意を否定して面倒さを押し付けるよりも、 代替手段を用意する方 がよほど建設的です。

6.2.4 ユーザ情報更新処理を作成する

更新処理では項目ごとに別々のユースケースとするか、それとも単一のユース ケースで複数項目を同時更新できるようにするかは悩ましい問題です (図6.2)。

ユーザ名を更新する メールアドレスを 更新する 住所を更新する ユーザ情報を 更新する

図6.2 更新のユースケース

捉え方次第でどちらも正解になりえますが、 今回は複数項目を同時に更新できる ユースケース (図6.2の右側) をサンプルにします。

まずはリスト6.15のユーザ名を変更するコードを確認してみましょう。

リスト 6.15 ユーザ名の変更を行う更新処理

public class UserApplicationService

private readonly IUserRepository userRepository;

private readonly UserService userService;

{

(･･･略･･･)

public void Update(string userId, string name)

var targetId = new UserId(userId); var user = userRepository. Find (targetId);

if (user == null) { } throw new UserNotFoundException (targetId);

var newUserName = new UserName (name);

user.ChangeName (newUserName);

if (userService.Exists(user))

throw new CanNotRegisterUserException (user, "ユーザは既に 存在しています。");

{

}

userRepository.Save (user);

}

User オブジェクトにはユーザ名しかパラメータがないので引数として新しい ユーザ名を受け取っています。 しかし、ユーザの情報が今後もユーザ名だけである というのは考えにくいです。 もしも項目が増えたらどのように変化するのでしょう か。

}

たとえばユーザ情報としてメールアドレスが追加されたときの更新処理を確認し てみましょう (リスト6.16)。

{

128

リスト 6.16 更新項目を増やす

public class User ApplicationService

{

private readonly IUserRepository userRepository;

private readonly UserService userService;

(…略…)

// メールアドレスを引数で受け取る

public void Update (string userId, string name = null, ➡ string mailAddress = null)

{

var targetId = new UserId (userId);

var user = userRepository. Find (targetId); if (user == null) { } throw new UserNotFoundException (targetId); // メールアドレスだけを更新するため、ユーザ名が指定されないことを考慮 if (name != null) { var newUserName = new UserName (name); user. ChangeName (newUserName); if (userService. Exists (user)) { throw new Can Not RegisterUserException (user, "1-fl➡ 存在しています。"); } }

// メールアドレスを変更できるように

121

if (mailAddress != null)

var newMailAddress = new MailAddress (mailAddress);

{

user.ChangeMailAddress (newMailAddress);

}

userRepository.Save (user);

}

}

情報変更にあたってユーザ名だけを変更したいときがあれば、 メールアドレスだ けを変更したいときもあります。 引数にデータを引き渡すか引き渡さないかによっ てその挙動を制御できるようにします。

このような戦略をとるとユーザ情報が追加されるたびにアプリケーションサービ スのメソッドのシグネチャが変更されることになります。 それを避ける方法として コマンドオブジェクトを用いる戦術があります。 コマンドオブジェクトはリスト 6.17のように定義できます。

リスト6.17 コマンドオブジェクトの例

public class UserUpdateCommand { public UserUpdateCommand(string id) { Id = id; }

public string Id { get; }

/// <summary> データが設定されると変更される </summary>

public string Name { get; set; }

/// <summary> データが設定されると変更される </summary>

public string MailAddress { get; set; }

}

ユースケースを実現する「アプリケーションサービス」

130

// 次のようにコンストラクタで名前やメールアドレスが任意であることを主張させてもよい public class UserUpdateCommand

{

public UserUpdateCommand(string id, string name = null, ➡ string mailAddress = null)

{

Id = id;

Name name;

MailAddress = mailAddress;

}

} public string Id { get; } public string Name { get; } // この場合セッターがなくなる public string MailAddress { get; } //<13

コマンドオブジェクトを用いてパラメータが追加されたとしてもシグネチャが変 更されないように対処してみましょう (リスト6.18)。

リスト6.18: コマンドオブジェクトを利用するように変更した更新処理

public class UserApplicationService

{

private readonly IUserRepository userRepository; private readonly UserService userService;

(------)

public void Update (User UpdateCommand command)

(

var targetId = new UserId(command. Id);

var user = userRepository. Find (targetId); if (user == null)

(

13

} throw new UserNotFoundException (targetId);

var name = command. Name; if (name != null)

{

var newUserName = new UserName (name);

user. ChangeName (newUserName);

if (userService.Exists(user))

{

throw new CanNot RegisterUserException(user, "1

存在しています。 ");

}

}

var mailAddress = command.MailAddress;

if (mailAddress != null)

{

var newMailAddress = new MailAddress (mailAddress);

user. ChangeMailAddress (newMailAddress);

}

} } userRepository.Save(user);

コマンドオブジェクトを作ることは間接的にアプリケーションサービスの処理を 制御することと同義です (リスト6.19)。

リスト6.19: コマンドオブジェクトを利用してアプリケーションサービスの制御を行う

// ユーザ名変更だけを行うように var updateNameCommand = new UserUpdateCommand(id) {

132

Name="naruse"

};

userApplicationService.Update (updateNameCommand);

// メールアドレス変更だけを行うように var updateMailAddress Command = new UserUpdateCommand(id) { }; MailAddress = "xxxx@example.com" userApplicationService.Update (updateMailAddressCommand);

このことからコマンドオブジェクトは処理のファサード (*1) といえます。

COLUMN

エラーかそれとも例外か

更新処理の中でユーザが見つからなかったときに例外を送出することに疑問を抱 いた方もいるでしょう。 その処理が失敗したときにエラーを返却するのか例外を送 出するのかは、 議論するのに値するテーマであることは間違いありません。

エラーを返却する道を選ぶと戻り値として結果オブジェクトを返却することにな ります。 結果オブジェクトは開発者に対して強制力をもちません。 つまり失敗につ いてのハンドリングを行うかどうかはクライアントの任意となり、 意図せず失敗を 見過ごすことに繋がります。

反対に例外を送出する道を選んだ場合は戻り値を返却しないようになります。 例 外を送出したとき、 何もしなければプログラムが終了しますし、終了しないように するにはtry-catch句を記述する必要があるので、 例外は開発者に対して失敗のハ ンドリングを強制します。 これは失敗に気づかず、意図せずして後続処理が継続し てしまうという事態を防ぐことに繋がりますが、 デメリットとしてパフォーマンス がわずかに劣る場合があり、 また戻り値のエラータイプによって送出されるエラー を表現することができなくなります。

いずれにせよ一長一短です。 メリットデメリットを天秤にかけた上で方針を決め てください。

] ファサードは 「建物の正面」 という意味です。 転じて複雑な処理を単純な操作にまとめるこ とを意味します。

[*1

6.2.5 退会処理を作成する

システムの利用を中止するにはさまざまな理由がありますが、 利用者がとれる選 択肢は多くありません。 フェードアウトするようにシステムを利用しなくなるか、 退会処理を行うかです。 リスト6.20 は後者を実現する退会処理です。

リスト 6.20: 退会処理

public class UserApplicationService {

private readonly IUserRepository userRepository;

(･･･略･･･)

public void Delete (UserDeleteCommand command)

var targetId = new UserId (command.Id);

var user = userRepository.Find(targetId);

} if (user == null) { } throw new UserNotFoundException (targetId); } userRepository.Delete (user);

退会処理はリポジトリから対象となるインスタンスの復元を行い、そのインスタ ンスの削除をリポジトリに依頼するだけのシンプルなスクリプトです。 リスト 6.21 のサンプルコードではユーザが見つからないときに例外を送出していますが、 退会 する対象が見つからなかったときも退会成功として、 例外を発生させず正常終了と する判断もあります。

{

134

リスト 6.21 ユーザが見つからない場合は退会成功とする

public class UserApplicationService

{

private readonly IUserRepository userRepository;

(･･･略...)

public void Delete (UserDeleteCommand command)

var targetId = new UserId (command.Id);

var user = userRepository. Find (targetId);

if (user == null)

{

// 対象が見つからなかったため退会成功とする

return;

{

userRepository.Delete(user);

}

DDD 6.3

}

ドメインのルールの流出

アプリケーションサービスはあくまでもドメインオブジェクトのタスク調整に徹 するべきです。 アプリケーションサービスにはドメインのルールは記述されるべき ではありません。 もしもドメインのルールをアプリケーションサービスに記述して しまうと、 同じようなコードを点在させることに繋がります。

たとえばユーザの重複を許さないというルールはドメインにおける重要なルール です。 アプリケーションサービスにこのルールを記述したときのユーザ登録処理は

13

リスト 6.22 のようになります。

リスト 6.22 アプリケーションサービスに重複に関するルールが記述されているユーザ登録処理

public class UserApplicationService

{

private readonly IUserRepository userRepository;

(･･･略･･･)

public void Register (string name)

{

// 重複確認を行うコード

var userName = new UserName (name);

var duplicatedUser = userRepository. Find (userName);

if (duplicatedUser != null)

throw new CanNotRegister UserException (userName, ➡ ユーザは既に存在しています。");

}

} var user = new User( ); userName userRepository.Save (user);

}

{

「ユーザの重複が許可されない」というルールは、 ユーザ情報を変更する際にも 認をしなくてはいけないルールです。 ユーザ情報更新処理においても同じように重 複を確認する必要があります (リスト6.23)。

136

リスト 6.23: ユーザ情報更新処理においても重複確認を行う必要がある

public class User ApplicationService { private readonly IUserRepository userRepository; (…略…)

public void Update (UserUpdateCommand command)

{

var targetId = new UserId(command. Id);

var user = userRepository. Find (targetId);

if (user == null)

{

throw new UserNotFoundException (targetId);

}

var name

command. Name;

if (name != null)

{

// 重複確認を行うコード

var newUserName = new UserName (name);

var duplicatedUser = userRepository. Find (newUserName);

if (duplicated User != null)

{

throw new Can Not Register UserException (user, ➡

ユーザは既に存在しています。");

}

user. ChangeName (newUserName);

}

var mailAddress = command. MailAddress;

if (mailAddress != null)

{

var newMailAddress = new MailAddress (mailAddress);

user.ChangeMailAddress (newMailAddress);

}

userRepository.Save(user);

}

}

いずれのメソッドにおいてもユーザの重複確認は行われ、意図したとおりに動作 します。 しかし、 もしも 「ユーザの重複」 のルールが変更されたときはどうなるで しょうか。

たとえばシステムの利用者が増えたとき、 利用したいと思ったユーザ名を他の利 用者が既に使っているといった事態は容易に発生します。 これを解決するために、 ユーザの重複に関するルールを 「ユーザ名の重複」 ではなく 「メールアドレスの重 複」 に変更してみましょう。

重複のキーがユーザ名ではなくメールアドレスに変更されるため、 メールアドレ スによる検索をサポートする必要があります。 まずはリポジトリをユーザ名ではな メールアドレスで検索できるように変更します (リスト6.24)。

リスト6.24 リポジトリにメールアドレスによる検索手段を追加

public interface IUserRepository { (------) public User Find (MailAddress mailAddress); }

このインターフェースを利用しているユーザ登録処理もこれに引きずられるよう に変更を加える必要があります (リスト6.25)。

138

リスト 6.25 ユーザ登録処理に変更を加える

public class User ApplicationService

{

private readonly IUserRepository userRepository;

(---88---)

public void Register(string name, string rawMailAddress)

{

{

// メールアドレスによる重複確認を行うように変更された

var mailAddress = new MailAddress (rawMailAddress);

var duplicatedUser = userRepository. Find (mailAddress); if (duplicatedUser != null)

throw new Can Not RegisterUserException (mailAddress);

}

var userName = new UserName (name);

var user = new User(

userName,

mailAddress

);

} userRepository.Save (user);

}

さて、この変更だけで完了するのであれば話は単純なのですが、 ユーザ情報更新 処理においてもユーザの重複を確認していたことを思い出してください。 ユーザの 重複のルールが変更になったのであればこちらも修正が必要です (リスト6.26)。

13-

リスト6.26 ユーザ情報更新処理も同様に重複確認のロジックを修正する必要がある

:

public class User Application Service

private readonly IUserRepository userRepository;

{

(…略…)

public void Update (UserUpdateCommand command)

{

var targetId = new UserId (command. Id);

var user = userRepository. Find (targetId);

if (user == null) { } throw new UserNotFoundException (targetId);

var name

command. Name;

if (name != null)

{

// ユーザ名での重複確認はなくなる

var newUserName = new UserName (name);

user. ChangeName (newUserName);

}

var mailAddress = command. MailAddress;

if (mailAddress != null)

// メールアドレスで重複確認を行うようになる

{

var newMailAddress = new MailAddress (mailAddress);

var duplicatedUser = userRepository. Find (newMailAddress); if (duplicatedUser != null)

{

140

throw new Can Not RegisterUserException (newMailAddress);

}

user.ChangeMailAddress (newMailAddress);

}

userRepository.Save (user);

}

修正自体は単純なものでありますが、これは大きな問題をはらんでいます。 いま はコードの量が少ないので全体を見通すことができるため、 修正しなくてはいけな い箇所に気づくことができます。 しかし今後コードの量が増えてきたときはどうで しょうか。 ユーザの重複を確認するコードがこの2箇所ですべてであると保証でき るでしょうか。 修正すべき箇所を網羅しきれず、 結果として修正漏れ、 つまりバグ を引き起こしてしまうのは目に見えています。

この問題を解決するのは簡単です。 ユーザの重複を確認するというドメインの ルールをアプリケーションサービスに記述しないことです。 ドメインのルールはド メインオブジェクトに記述し、 アプリケーションサービスはそのドメインオブジェ クトを利用するように仕立てます。

リスト6.27 のコードはユーザの重複を確認するためにドメインサービスを利用 するように変更したものです。

リスト 6.27: ドメインサービスを利用するように変更したユーザ登録処理

public class UserApplicationService

{

private readonly IUserRepository userRepository; private readonly UserService userService;

(------)

public void Register (string name, string mailAddress)

{

}

var user = new User(

new UserName (name),

);

new MailAddress (mailAddress)

// ドメインサービスを利用して重複を確認する

if (userService.Exists (user))

{

throw new CanNotRegister UserException (user, →

ユーザは既に存在しています。");

}

userRepository.Save (user);

}

}

これは当初のユーザ登録処理と同じコードです。 ユーザの重複のルールにした がって重複を確認するコードが隠蔽され、アプリケーションサービスはドメインオ ブジェクトを操作することに徹するよう変化しました。

同様にユーザ情報更新処理もドメインサービスを利用するように修正します (リ スト 6.28)。

リスト6.28 ドメインサービスを利用するようにしたユーザ情報更新処理

public class UserApplicationService

{

private readonly IUserRepository userRepository; private readonly UserService userService;

(･･･略･･･)

public void Update (UserUpdateCommand command)

{

var targetId = new UserId (command.Id);

var user = userRepository. Find (targetId);

142

if (user == null)

throw new UserNotFoundException (targetId);

{

}

var name = command. Name;

if (name != null)

{

var newUserName = new UserName(name);

user. ChangeName (newUserName);

if (userService. Exists (user))

{

throw new Can Not RegisterUserException (user, →

ユーザは既に存在しています。");

}

var mailAddress = command. MailAddress;

if (mailAddress != null)

var newMailAddress = new MailAddress (mailAddress);

user. ChangeMailAddress (newMailAddress);

} } userRepository.Save(user);

{

}

}

ユーザ登録処理と同様にユーザ情報更新処理もドメインオブジェクトの操作に徹 しています。 ユーザの重複に関するルールに変更があったときは、まずドメイン サービスであるUser Service を修正します (リスト6.29)。

リスト 6.29: ドメインサービス上でユーザの重複に関するルールを変更する

public class UserService

{

private readonly IUserRepository userRepository;

(･･･略･･･)

public bool Exists (User user)

{

// 重複のルールをユーザ名からメールアドレスに変更

// var duplicatedUser = userRepository. Find (user.Name);

var duplicatedUser = userRepository. Find (user.MailAddress);

return duplicatedUser != null;

}

後はUserServiceのExistsメソッドを利用している箇所を確認し、必要に応じて 修正することで漏れなく修正を完了できるでしょう。 IUserRepository の Find メ ソッドを使っている箇所をすべて洗い出すよりずっと簡単な作業です。

ルールをドメインオブジェクトに記述することは、 同じルールが点在することを 防ぎ、ひいては修正漏れを起因とするバグを防ぐ効果があるのです。

DDD アプリケーションサービスと 64 凝集度

プログラムには凝集度という考えがあります。 凝集度はモジュールの責任範囲が どれだけ集中しているかを測る尺度です。 凝集度を高めると、モジュールがひとつ の事柄に集中することになり、 堅牢性・信頼性 再利用性 可読性の観点から好ま しいとされています。

この凝集度を測る方法にLCOM (Lack of Cohesion in Methods) という計算 式があります。 端的に説明するとすべてのインスタンス変数はすべてのメソッドで

144

使われるべき、というもので、 計算式はインスタンス変数とそれが利用されている メソッドの数から計算されます。

計算式を覚えることは主題ではないので、ここでは凝集度がどういったものかを 具体的なコードで確認しながら理解していきましょう。 リスト6.30 のLow Cohesion クラスはその名のとおり凝集度が低いクラスです。

リスト 6.30:凝集度が低いクラス

public class LowCohesion

{

private int valuel;

private int value2;

private int value3;

private int value4;

public int MethodA()

{

return valuel + value2;

}

public int MethodB()

{

return value3 + value4;

}

}

LowCohesion クラスのvaluel は MethodA で利用されていますが、 MethodB では利用されていません (図6.3)。 valuel MethodB は本質的に関係がありませ ん。 同じことが他の属性とふるまいにもいえます。 これらを分離することで凝集度 はもっと高めることができます (リスト 6.31)。

14

LowCohesion value1 value2 value3 value4 MethodA MethodB

図6.3: 低凝集なクラスのフィールドとメソッドの関係性

リスト 6.31 分離することで凝集度を高める

public class HighCohesionA

private int value1;

private int value2;

public int MethodA()

{

return valuel + value2;

}

}

public class HighCohesionB

private int value3;

{

private int value4;

public int MethodB()

return value3 + value4;

{

}

{

}

146

いずれのクラスもすべてのフィールドがそのクラスに定義されているすべてのメ ソッドで利用されています。 これは凝集度が高い状態です (図6.4)。

value1 HighCohesionA MethodA value2 value3 HighCohesion B MethodB value4

図6.4: リファクタリングにより高凝集になったクラス

もちろん凝集度を高くすることが常に正解ではありません。 そのコードを取り巻 く環境によっては、あえて凝集度を下げる選択肢が正解となることもありえます。 しかしクラスの設計をする上で、凝集度は一考の価値がある尺度であることには間 違いないでしょう。

6.4.1 集度が低いアプリケーションサービス

凝集度のことを念頭に置きながらアプリケーションサービスを改めて眺めてみま しょう。 次のコードはユーザ登録処理とユーザ退会処理です (リスト6.32)。

リスト 6.32: ユーザ登録処理とユーザ退会処理

public class UserApplicationService

( private readonly IUserRepository userRepository; private readonly UserService userService; (------) public void Register (UserRegister Command command) {

var user = new User( ); new UserName (command.Name)

if(userService.Exists(user))

{

throw new CanNotRegister UserException (user, ➡ ユーザは既に存在しています。");

}

userRepository.Save (user);

}

public void Delete (UserDeleteCommand command)

{ var userId = new UserId (command.Id); var user = userRepository.Find(userId); if (user == null) { } throw new UserNotFoundException (userId);

userRepository.Delete(user);

}

まずは userRepository フィールドに着目してみます。 userRepository はすべて のメソッドで利用されているので凝集度の観点からも好ましい状態にあります。 そ れに比べてuserService フィールドはどうでしょうか。 このフィールドは現在のと ころユーザの重複の確認のためだけに利用されています。 UserService が利用され るのはユーザを登録するときです。 ユーザを削除する際には重複の確認など行いま せんから、ユーザ退会処理ではuserService を利用していません。 User Application Service は凝集度の観点から考えると望ましくない状態にあります (図6.5)。

}

148

UserApplicationService Delete userService userService⭑ userRepository 利用していない Register Delete

6.5: UserApplication Service 7

凝集度を高めるためにはクラスを分割するというのが簡単な対処です。 User ApplicationService を凝集度が高まるように分割してみます。 まずはユーザ登録 処理を分割してみましょう (リスト 6.33)。

リスト 6.33 ユーザ登録処理クラス

public class UserRegisterService

private readonly IUserRepository userRepository; private readonly UserService userService;

{

public UserRegisterService (IUserRepository userRepository, ➡ UserService userService)

{

this.userRepository = userRepository;

this.userService = userService;

}

public void Handle (UserRegister Command command)

var userName = new UserName (command. Name);

{

var user = new User(

userName

);

14

if (userService.Exists(user))

{

throw new CanNot Register UserException (user, ➡

ユーザは既に存在しています。");

}

userRepository.Save (user);

}

}

必要なオブジェクトをコンストラクタで受け取ることや処理内容自体は変わりま せんが、ユーザ登録処理でひとつのクラスになりますのでクラス名もそれに合わせ て変更します。 Registerという意図がクラス名で表現されているのでメソッド名は シンプルな表現に変更できます。

次に同じようにクラス分割をしたユーザ退会処理を確認してみましょう (リスト 6.34).

リスト 6.34 ユーザ退会処理クラス

public class UserDeleteService

{

private readonly IUserRepository userRepository;

public UserDeleteService (IUserRepository { } this.userRepository = userRepository;

userRepository)

public void Handle (UserDeleteCommand command)

{

var userId = new UserId (command.Id);

var user = userRepository. Find (userId);

if (user == null)

150

{ } throw new User Not FoundException (userId); } userRepository.Delete(user);

}

ユーザ登録処理と同様に必要なオブジェクトはコンストラクタで受け取るように して、 メソッド名の変更などを行っています。 特筆すべき大きな変化は、 User Service オブジェクトが退会処理ではまったく登場しなくなったということです。

現在、ユーザ登録処理とユーザ退会処理のフィールドはいずれもすべてのメソッ ドで利用され、凝集度が高い状態になっています (図6.6)。 クラスの見通しはどう でしょうか。 ユーザ登録クラスはユーザ登録のみを行っていますし、 ユーザ退会ク ラスはユーザの退会のみを行っています。

UserRegisterService userRepository Handle UserDeleteService userService userRepository Handle

図6.6 分割され凝集度が高まったクラス

そもそもユーザの登録処理とユーザの退会処理は 「ユーザ」 という概念で繋がっ てはいるものの、 目的や処理内容はまったく真逆のものです。 責務を厳密に分担し たのであれば、クラスが分かれることも当然のことです。

とはいえ、ユーザに関係する処理としてどんなものが既に用意されているのかと いったことは俯瞰して見れるようにすべきです。 現在のコードはクラスを分けてし まうことにより、 まとまりが表現できなくなってしまっています。 こうしたときま

151

とまりを表現するために利用するのがパッケージ [*2] です。 ユーザ登録処理とユー ザ退会処理は次のようにパッケージによってまとめます。

• Application. Users.UserRegisterService

• Application. Users.UserDeleteService

パッケージはそのままディレクトリ構造に反映されることも多いです。 図6.7は ソースファイル配置の例です。

UserRegisterService Application Users UserGetInfoService UserUpdateInfoService UserDeleteService

図6.7: ソースファイルのディレクトリ構造

パッケージでクラスをまとめることで、ユーザに関わる処理はひとつのパッケー ジ、ひとつのディレクトリにまとまります。 この構造であれば開発者がユーザに関 する処理を探すことは容易でしょう。

なお、ここで主張しているのは 「ユースケースごとにクラスは必ず分けるべきで 「ある」ということではありません。 フィールドとメソッドに基づく凝集度に着目し、 こういったクラス構成を採択する道もありうるということです。 ユーザに関する ユースケースだからといって、 すべて UserApplicationServiceクラスに同居させ る必要はないのです。

凝集度こそが絶対の指標ではありません。 クラスを構成するインスタンス変数と メソッドには対応関係があり、 それが健全であるかどうかを示す凝集度の視点は、 コードを整頓する際のヒントとして頭の片隅に入れておくべきものです。

名前空間とも呼ばれます。

ユースケースを実現する「アプリケーションサービス」

6

152

[2]

DDD アプリケーションサービスの インターフェース 6.5

より柔軟性を担保するためにアプリケーションサービスのインターフェースを用 意することがあります。 たとえばリスト6.35のようなインターフェースです。

リスト 6.35 ユーザ登録処理のインターフェース

public interface IUserRegisterService { } void Handle (UserRegister Command command);

アプリケーションサービスを呼び出すクライアントはアプリケーションサービス の実体を直接呼び出すのではなく、 インターフェースを操作して処理を呼び出すよ うになります (リスト6.36)。

リスト 6.36: クライアントはインターフェースを利用する

public class Client

{

private IUser RegisterService user RegisterService;

} (･･･略･･･) public void Register(string name) { var command = new UserRegisterCommand (name); userRegisterService.Handle (command);

これはクライアント側の利便性を高めます。

たとえばクライアント側の開発者とアプリケーション側の開発者で分業して開発 を行うと、クライアント側の開発者はアプリケーションサービスの実装を待つこと になります。 待ち時間に他の作業を行えるのであれば問題はありませんが、そうで

15

ない場合クライアント側の開発者はただ待ちぼうけをするのみです。 これは非常に 勿体ない時間の使い方です。

アプリケーションサービスのインターフェースを用意すれば、 モックオブジェク トを利用してプロダクション用のアプリケーションサービスの実装を待たずして 開発を進めることが可能になります (リスト6.37)。

リスト6.37インターフェースを実装したモックオブジェクト

public class MockUser RegisterService IUser RegisterService { public void Handle (User Register Command command) { } // nop }

それ以外にも、たとえばアプリケーションサービスで例外が発生したときのクラ イアント側の処理を実際にテストしたいといった要求にも応えることができます (リスト 6.38)。

リスト6.38 モックオブジェクトに例外を送出させる

public class Exception User RegisterService: IUserRegisterService {

public void Handle (UserRegister Command command) { throw new ComplexException(); } }

エラーを起こすように整合性のとれたデータを準備するのは、いかにプログラム に精通していたとしても面倒な作業です。 その処理に意味はなく、 例外が投げられ たときの処理を確認したいだけであれば、インターフェースによりアプリケーショ ンサービスを差し替え可能にすることで対応できます (図6.8)。

154

Client UserRegisterService <I> Client IUserRegisterService UserRegisterService MockUser RegisterService ExceptionUser RegisterService

図6.8 モジュール構成の変化と処理の流れのイメージ

DDD 6.6 サービスとは何か

第4章 「不自然さを解決する 「ドメインサービス」」 でドメインサービスを確認 し、本章でアプリケーションサービスを確認しました。 ここで改めてサービスとは 何かを確認しておきましょう。

サービスはクライアントのために何かを行うモノです。 値オブジェクトやエン ティティは自身のためのふるまいをもっていますが、 サービスは自身のためのふる まいをもちません。 したがってサービスはものごとではなく、活動や行動であるこ とが多いです。

サービスはどのような領域にも存在します。 そのうち、 ドメインにおける活動を ドメインサービスとしていて、アプリケーションとして成り立たせるためのサービ スをアプリケーションとしているのです。

たとえば第4章 「不自然さを解決する 「ドメインサービス」」 で紹介したユーザの 重複確認はドメインの活動です。 したがってそれを行うサービスオブジェクトはド メインのサービス、 すなわちドメインサービスです。 ドメインサービスはれっきと したドメインの知識を表現したオブジェクトです。

15

ではアプリケーションサービスはどうでしょうか。 アプリケーションはその利用 者の問題を解決するために作られます。 ソフトウェアには必ずアプリケーション固 有の機能があるはずです。

たとえば本章で示したユーザを登録したり、 退会したりといったことはアプリ ケーションを成り立たせるための操作です。 それらのふるまいはドメインに存在す る概念ではなく、ユーザ機能を新たに実現するために作られたものです。 したがっ てユーザの登録や退会といったふるまいはアプリケーション固有のふるまいであ り、それが定義されるサービスはアプリケーションのサービス、つまりアプリケー ションサービスです。

ドメインサービスとアプリケーションサービスは対象となる領域が異なるだけで 本質的には同じものです。 まずサービスがあり、 それの向いている方向がドメイン であるか、 アプリケーションであるかで分けられているのです。

6.6.1 サービスは状態をもたない

サービスは自身のふるまいを変化させる目的で状態を保持しません。 サービスが 状態をもつようになると、サービスがいまどのような状態にあるのかを気にする必 要ができてしまいます。 しかし、 それと同時に勘違いしていけないのは、状態を一 切もっていないことを意味しないことです。

たとえば本章で取り扱ったUserApplicationService は状態をもっているサービ スです (リスト6.39)。

リスト6.39 状態をもったサービス

public class UserApplicationService

} private readonly IUserRepository userRepository; (･･･略･･･)

{

UserApplicationService は IUserRepository 型のフィールドuserRepository を状態としてもちますが、 userRepositoryは直接的にサービスのふるまいを変更 しません。 したがって自身のふるまいを変化させる目的の状態ではありません。 反対にリスト 6.40の状態はふるまいを変化させる目的で保持している状態です。

ユースケースを実現する「アプリケーションサービス」

6

156

リスト 6.40:自身のふるまいを変化させる目的で状態をもつ

public class UserApplicationService { private bool sendMail; (･･･略･･･) } } public void Register() { (-----) if (sendMail) { MailUtility. Send ("user registered"); }

Registerメソッドは sendMail の値によって処理が分岐します。 sendMailは直 接的にサービスのふるまいを変更しています。 Register メソッドを利用するときに はインスタンスがどういった状態にあるかを気にする必要ができてしまいます。

状態がもたらす複雑さは多くの開発者を混乱させるものです。 状態をもたせる以 外の方法を考えてください。

DDD 6.7

まとめ

本章ではドメインの知識を表現するドメインオブジェクトの力をまとめあげて、 ドメインの問題を解決に導くアプリケーションサービスを学びました。

ドメインモデルを表現するだけではアプリケーションとして完成しません。 アプ

リケーションサービスはドメインオブジェクトの操作に徹することでユースケース を実現します。

157

アプリケーションを実装するときに気を付けることはドメインのルールが記述さ れないようにすることです。 アプリケーションサービスにドメインの知識が流出す ることは短期的には問題とならないこともありますが、ソフトウェアは長期的に利 用されることが期待されます。 知識を一所にまとめて変更を容易にするためにも、 ドメインのルールはドメインオブジェクトに実装するようにしましょう。

ここまでの内容で利用者の問題を解決するアプリケーションを作ることができる ようになりました。 次の章ではソフトウェアの柔軟性を左右する依存の取り扱い方 についてを解説します。

158

Chapter 7 柔軟性をもたらす 依存関係の コントロール

ソフトウェアに柔軟性をもたらすために必要なことは 依存関係を制御することです。

プログラムには依存という概念があります。 依存はオ ブジェクトがオブジェクトを参照するだけで発生しま す。 したがって、 オブジェクト同士に依存関係が発生 するのは自然なことです。 しかし、この依存関係を軽 視するとソフトウェアはその柔軟性を失います。

ソフトウェアを柔軟に保つために必要なことは、 特定 の技術的要素への依存を避け、変更の主導権を主た る抽象に移すことです。 本章で解説する依存のコント ロールはその方法です。

オブジェクト同士の依存がどういったものかを確認 し、 ソフトウェアを柔軟に保つために技術的要素への 依存から脱却する術を確認しましょう。

AP

9

92

B

14

7

DDD 71

技術要素への依存が もたらすもの

図7.1 複雑な依存関係

積み上がった積み木の中ほどに位置するブロックを抜き出すことを想像してみて ください (図7.1)。 抜き出そうとしたブロックは直上のブロックを支えています。 手荒くブロックを抜き出せば、たちまちに積み木は崩れ去るでしょう。 誰しもがブ ロックを抜き出すことを難しいと感じるはずです。 プログラムにおける依存も同じ ことがいえます。

ソフトウェアの中核に位置するオブジェクトを変更することを想像してみてくだ さい。 そのオブジェクトは多くのオブジェクトに依存されていますし、多くのオブ ジェクトに依存しています。 たったひとつの変更が多くのオブジェクトに影響しま す。 緻密に組み上げられたコードを変更することの厄介さは、ほとんど恐怖と似た ような感覚となって開発者に襲い掛かるでしょう。

プログラムを組み上げていく過程でオブジェクト同士の依存は避けられません。 依存関係はオブジェクトを利用するだけで発生するのです。 重要なことは依存を避 けることではなく、コントロールすることです。

本章で解説する依存のコントロールはドメインのロジックを技術的要素から解き 放ち、ソフトウェアに柔軟性を与えるものです。 コードが技術的要素に支配される ことの問題を確認し、 その解決法を確認していきましょう。

たらす依存関係のコントロール

160

DDD 7.2

依存とは

まずは簡単なサンプルで依存がどういったものかを確認します。 依存はあるオブ ジェクトからあるオブジェクトを参照するだけで発生します。 リスト7.1の単純な コードに存在している依存関係を確認してみましょう。

リスト7.1: ObjectA は ObjectB に依存する

public class ObjectA { private ObjectB objectB; }

ObjectAはObjectB を参照しています。 そのため、 ObjectB の定義が存在しな い限り ObjectAは成り立ちません。 ObjectAはObjectBに依存しているといえま す。

こういった依存関係は図で表すことができます。 図7.2は ObjectAとObjectB の依存関係を表した図です。

ObjectA ObjectB

7.2 参照による依存関係

依存は依存する側のモジュールから依存される側のモジュールへと矢印を伸ばし て表現します。 図7.2の矢印は参照による依存を表す矢印です。

依存関係が生じるのは参照に限ったことではありません。 たとえばインター フェースとその実体になる実装クラスの関係にも依存が生まれます (リスト7.2)。

161

依存とは

7

リスト7.2: UserRepository は IUserRepository に依存する

public interface IUserRepository { User Find (UserId id); }

public class UserRepository: IUserRepository

{

public User Find (UserId id)

(･･･略･･･)

}

UserRepository クラスはIUserRepositoryインターフェースを実装しています。 もしもIUserRepository の定義が存在しなかったとしたらクラスの宣言部にてコ ンパイルエラーが検出され、 UserRepository は成り立ちません。 UserRepository は IUserRepository に依存していることになります。

UserRepository IUserRepository

図7.3: 汎化による依存関係

}

インターフェースと実装クラスの依存関係を表したものが図 7.3です。 依存の方 向性を表す白抜きの矢印は汎化を示します。

これらの例を見てわかるとおり、 プログラムを組み上げていく上で、 依存は自然 と発生するものです。 もちろん、これまでの解説で取り扱ってきたオブジェクトに も依存は発生しています。 たとえば次のUserApplicationService に登場するモ ジュールの依存関係を確認してみましょう (リスト7.3)。

のコントロール

162

リスト7.3: UserApplicationService の依存関係に着目

public class UserApplicationService { private readonly UserRepository userRepository; public UserApplication Service (UserRepository userRepository) { } this.userRepository = userRepository; } (･･･略･･･)

UserApplicationService にはUserRepository がフィールドとして定義されて います。 したがってUser ApplicationService はUserRepository に依存している 状態です (図7.4)。

UserApplication Service UserRepository

7.4 リスト7.3の依存関係

実をいうと、このUserApplicationService には問題があります。 具体的にいえ ば具象クラスであるUserRepositoryクラス、ひいてはそこで利用されているデー タ永続化に関する特定の技術基盤に依存していることが問題です。

UserRepository が取り扱っているデータストアがリレーショナルデータベース なのか、それともNoSQLデータベースであるかということはリスト7.3を眺めて も計り知れませんが、 UserApplicationService がいずれかのデータストアに対し て結びついていることは確かです。 ソフトウェアが健全に成長するためには開発や テストで気軽にコードを実行できるように仕向けることが重要です。 特定のデータ ストアに結びついてしまうとそれは不可能になります。 コードを実行するためには データベースを準備して、 必要なテーブルを作成する必要があります。 取り扱うロ ジックによっては事前にデータを投入する必要が生じることもあるでしょう。 ただ

16

動作させるというだけで、 途方もない労力がのしかかってきます。

このような問題を解決するためには第5章 「データにまつわる処理を分離する 「リ 「ポジトリ」」で解説をしたリポジトリが役に立ちます。 UserApplicationService が具 象クラスであるUserRepository を受け取るのではなく、 リポジトリのインター フェースを参照するようにしてみましょう (リスト7.4)。

リスト7.4 リポジトリのインターフェースを参照する

public class UserApplicationService

{

// インスタンス変数として保持しているのはインターフェース

private readonly IUserRepository userRepository;

// コンストラクタが受け取る引数もインターフェースになる

public UserApplication Service (IUserRepository userRepository)

{ this.userRepository = userRepository; }

(･･･略･･･)

}

User ApplicationService が IUserRepository という抽象型 (インターフェース は抽象型とも呼ばれる) に対して依存するようになったことで、 IUserRepository を実装した具象クラスであればその実体が何であっても引き渡すことができます。 つまりUserApplicationServiceはUserRepository という具象クラス、ひいては 特定のデータストアに結びつくことがなくなったのです。 現在のUserApplication Service であれば、たとえばインメモリで動作するテスト用のリポジトリを引き渡 してユニットテストを実施することが可能です。 あるいは、別のデータストアを利 使用するリポジトリを用意することで、 主たるロジックに変更を加えることなくデー タストアを差し替えることも可能になります。

リスト7.4の依存関係を表した図が図7.5です。

たらす依存関係のコントロール

7

164

UserApplicationService IUserRepository UserRepository

図7.5 抽象型に依存

抽象型を利用するようになると、 具象型に向いていた依存の矢印が抽象型へ向く ようになります。 このように依存の方向性を制御し、 すべてのモジュールが抽象へ 依存するように制御することはビジネスロジックを具体的な実装から解き放ち、よ 純粋なものに昇華する効果があります。

この抽象型を用いた依存関係の制御は 「依存関係逆転の原則」 として知られてい ます。

DDD 7.3 依存関係逆転の原則とは

依存関係逆転の原則 (Dependency Inversion Principle) は次のように定義さ れています (以下引用 (*1)。

> A. 上位レベルのモジュールは下位レベルのモジュールに依存してはならな い、 どちらのモジュールも抽象に依存すべきである。

> B. 抽象は、実装の詳細に依存してはならない。 実装の詳細が抽象に依存す べきである。

1 「実践ドメイン駆動設計」(翔泳社) P.119より引用。 なお本書では、 「上位」 を 「上位レベ ル」、「下位」 を 「下位レベル」と表記しています。

L

依存関係逆転の原則とは

165

7

依存関係逆転の原則はソフトウェアを柔軟なものに変化させ、ビジネスロジック を技術的な要素から守るのに欠かせないものです。 ここでしっかりと内容を理解し ていきましょう。

7.3.1 抽象に依存せよ

プログラムにはレベルと呼ばれる概念があります。 レベルは入出力からの距離を 示します。 低レベルといえば機械に近い具体的な処理を指し、 高レベルといえば人 間に近い抽象的な処理を指します。 依存関係逆転の原則に表れる上位レベルや下位 レベルというのはこれと同じです。

たとえばデータストアを操作するUserRepository の処理は、 UserRepository を操作するUserApplicationService よりも機械に近い処理です。 レベルの概念に 照らし合わせると UserRepository は下位レベルでUserApplicationService は上 位レベルになります。 抽象型を利用しなかったとき (リスト7.3)、 User Application Service は具体的な技術基盤と比べて上位レベルのモジュールでありながら、デー タストアの操作を行う下位レベルのモジュールである UserRepository に依存して いました。 これはまさに 「上位レベルのモジュールは下位レベルのモジュールに依 存してはならない」 という原則に反しています。

この依存の関係は User ApplicationService が抽象型である IUserRepository を 参照する (リスト7.4) ようになると図7.6のように変化します。

UserApplication Service UserRepository UserApplicationService. IUserRepository UserRepository

図7.6 依存関係の変化

もたらす依存関係のコントロール

11

7

166

抽象型を導入することでUserApplicationService と UserRepository は、双方 ともに抽象型である IUserRepository に依存の矢印を伸ばすことになります。 もは や上位レベルのモジュール (UserApplicationService) が下位レベルのモジュー ル(UserRepository) に依存しなくなり、「どちらのモジュールも抽象に依存すべ きである」 という原則にも合致します。 もともと具体的な実装に依存していたもの が抽象に依存するように、 依存関係は逆転したのです。

一般的に抽象型はそれを利用するクライアントが要求する定義です。 IUser Repository はいわばUserApplicationServiceのために存在しているといっても過 言ではありません。 このIUserRepository という抽象に合わせてUserRepository の実装を行うことは、 方針の主導権をUserApplicationService に握らせることと 同義です。 「抽象は実装の詳細に依存してはならない。 実装の詳細が抽象に依存すべ きである」 という原則はこのようにして守られます。

7.3.2 主導権を抽象に

伝統的なソフトウェア開発手法では高レベルなモジュールが低レベルなモジュー ルに依存する形で作成される傾向がありました。 言い換えるなら抽象が詳細に依存 するような形で構築されていました。

抽象が詳細に依存するようになると、 低レベルのモジュールにおける方針の変更 が高レベルのモジュールに波及します。 これはおかしな話です。 重要なドメインの ルールが含まれるのはいつだって高レベルなモジュールです。 低レベルなモジュー ルの変更を理由にして、重要な高レベルのモジュールを変更する(たとえばデータ ストアの変更を理由にビジネスロジックを変更する) などということは起きてほし くない事態です。

主体となるべきは高レベルなモジュール、 すなわち抽象です。 低レベルなモ ジュールが主体となるべきではありません。

高レベルなモジュールは低レベルのモジュールを利用するクライアントです。 ク ライアントがすべきはどのような処理を呼び出すかの宣言です。 先述したとおり、 インターフェースはそれを利用するクライアントが宣言するものであり、主導権は そのクライアントにあります。 インターフェースを宣言し、 低レベルのモジュール はそのインターフェースに合わせて実装を行うことで、より重要な高次元の概念に 主導権を握らせることが可能になるのです。

16

DDD

7.4

依存関係をコントロールする

User ApplicationService がインメモリで動作するテスト用のリポジトリを利用 してほしいのか、それともリレーショナルデータベースに接続するプロダクション 用のリポジトリを利用してほしいのかどうかは、 ときと場合によります。 開発中で あれば前者でしょうし、 リリースビルドはもちろん後者です。 重要なのはどれを扱 うかではなく、それをどのようにして制御するかです。 依存関係をコントロールす る手段について確認していきます。

まずはあまりよくない例から見ていきましょう。 たとえば開発中にインメモリの リポジトリを利用するという目的を達成することだけを考えた短絡的なコードはリ スト7.5です。

リスト 7.5 インメモリのリポジトリをコンストラクタで生成する

public class UserApplicationService

private readonly IUserRepository userRepository;

public UserApplication Service()

{

this.userRepository = new InMemoryUserRepository();

}

{

(･･･略･･･)

}

リスト7.5は、フィールドであるuserRepository は抽象型であるものの、具象ク ラスを内部でインスタンス化しているために User ApplicationService は InMemory UserRepository という詳細なオブジェクトに依存してしまっています。 この依存 が引き起こす問題は単純で、 完成したはずのコードに修正を加えることが必要にな ることです。 ある程度動作するようになってからか、それとも考えうる限りのテス トをしきってからかはわかりませんが、 リスト7.6のようにリリースの際にはプロ ダクション用リポジトリを利用するように完成したはずのコードを修正する必要が あります。

性をもたらす依存関係のコントロール

168

リスト7.6プロダクション用のリポジトリに差し替える

public class UserApplicationService

{

private readonly IUserRepository userRepository;

public UserApplication Service()

// this.userRepository = new InMemoryUserRepository();

this.userRepository = new UserRepository();

}

(･･･略･･･)

また修正作業を無事完遂してリリースしたとしても、 場合によってはインメモリ のリポジトリを利用したくなるときがあります。 たとえばソフトウェアに不具合が 発生したときの原因究明をしたいときなどがそれにあたります。 ソフトウェアに不 具合が生じたとき、 その不具合の状況を再現するためのデータをデータベースに用 意するのは手間がかかります。 多くの場合 「エラーを発生させるための整合性が取 れたデータ」は用意しづらいものです。

こういったときはテスト用のリポジトリを用意して、それを利用するように差し 替えて、プログラムの挙動を確かめたいところです。 そのとき開発者に与えられる のは、プロダクション用のリポジトリをまたテスト用のリポジトリに差し替える単 調な作業です。

こういった問題を解決するために取られるパターンとして、 Service Locatorパ ターンとIoC Containerパターンがあります。 それぞれどういったものか確認し ていきましょう。

}

もちろんこの作業はここだけにとどまりません。 この造りが許されるなら、きっ と他のコードも似たような構造をしているでしょう。 それらも間違いなくプロダク ション用リポジトリを取り扱うようにコードを修正していく必要があります。 修正 自体は至極単純な作業と予測できますが、いかにも開発者向きでない愚直で面倒な 作業です。

16

{

7.4.1 Service Locatorパターン

Service LocatorパターンはServiceLocator と呼ばれるオブジェクトに依存解 決先となるオブジェクトを事前に登録しておき、 インスタンスが必要となる各所で ServiceLocator を経由してインスタンスを取得するパターンです。

言葉だけではイメージがしづらいので具体例を見てみましょう。 リスト7.7 は Service Locatorパターンを適用した User Application Service です。

リスト7.7: Service Locator を適用する

public class UserApplicationService

private readonly IUserRepository userRepository;

{

public UserApplication Service()

// ServiceLocator経由でインスタンスを取得する

this.userRepository = ServiceLocator. Resolve→

<IUserRepository>();

}

(･･･略･･･)

}

コンストラクタでServiceLocator に IUserRepository の依存を解決するように 依頼しています。この依頼に対して返却される実際のインスタンスはスタートアッ プスクリプトなどで事前に登録しておきます (リスト7.8)。

リスト7.8 事前にインスタンスを登録する

ServiceLocator. Register<IUserRepository, → InMemoryUserRepository>();

リスト7.8 のように登録すると IUserRepository の依存解決が依頼された際に InMemory UserRepositoryをインスタンス化して引き渡します。 もしもプロダク ション用データベースに接続するリポジトリを利用したいときはServiceLocator

{

170

への登録をリスト7.9のように変更することで対応します。

リスト 7.9 プロダクションに移行するためリポジトリを切り替える

// この修正のみで全体に変更が行き渡る

ServiceLocator.Register<IUserRepository, UserRepository>();

IUserRepository を要求するオブジェクトがすべてServiceLocator経由でイン スタンスを取得していれば、 修正箇所は依存関係を設定しているスタートアップス クリプトの修正だけでこと足ります。

このようにServiceLocator に依存を解決させることにより InMemory User Repository ないしUserRepositoryのインスタンス化を行うコードがプログラム の随所に点在しなくなり、 アプリケーションの中核を担うロジックに修正を加える ことなく、リポジトリの実体を差し替えられるようになります (図7.7)。

Resolve <IUserRepository? ServiceLocator UserApplication Service Return UserRepository

7.7: Service Locator による依存の解決

ServiceLocator に登録されるインスタンスの設定はプロダクション用とテスト 用など用途に応じて一括で管理すると便利です。 スタートアップスクリプトでプロ ジェクトの構成設定などをキーにして、 用途ごとのインスタンス設定に切り替えを 行えるようにします (図7.8)。

171

依存関係をコントロールする

Production ServiceLocator Test Production Config IUserRepository :UserRepository Test Config ICircle Repository: Circle Reposotory IUserRepository :InMemoryUser Repository ICircle Repository: InMemoryCircle Repository

図7.8 スタートアップスクリプトによる切り替え

Service Locatorパターンは大がかりな仕掛けを用意する必要がないため導入し やすいものです。 一方で Service Locatorパターンはアンチパターンであるともい われています。 その理由は次の2つの問題を起因とします。

・依存関係が外部から見えづらくなる ・テストの維持が難しくなる

それぞれがどういった問題なのかを具体的に確認します。

1 依存関係が外部から見えづらくなる

Service Locatorパターンを採用した場合、 コンストラクタはたいていひとつに なります。 これは Service Locator から必要なインスタンスを取り出すようになる ためです。 このとき外部から見えるクラス定義はリスト7.10です。

リスト7.10 外部から確認したときのクラスの定義

public class UserApplication Service { } public UserApplicationService(); public void Register (UserRegister Command command

);

7

172

この定義を見たとき、 開発者はUser ApplicationServiceをインスタンス化して Registerメソッドを呼び出すでしょう。 それ以外にこのオブジェクトに対してでき ることがないからです。 しかし、それは実行時エラーによってプログラムを強制終 了させる結果に終わります。 なぜならUserApplicationService のコンストラクタ は ServiceLocator に IUserRepository の依存解決を依頼するからです(リスト 7.11).

リスト 7.11 : リスト7.10のコンストラクタ

public class UserApplicationService

{

private readonly IUserRepository userRepository;

public UserApplicationService()

{

// IUserRepository の依存解決先が設定されていないのでエラーを起こす

this.userRepository = ServiceLocator.Resolve

<IUserRepository>();

}

(･･･略･･･)

事前に ServiceLocator に対して依存解決の設定を行っていないため、 User ApplicationService が要求する依存解決は失敗します。

}

「UserApplicationService を正しく動作させるためには、 事前に IUserRepository が要求された際に引き渡すオブジェクトの登録が必要である」ことが、 クラスの定 義を確認しただけではわからないことはあまり良い傾向とはいえません。 User ApplicationService を動作させるために UserRepository を ServiceLocator に登 録できるのは、 UserApplicationService の実装を確認したか、さもなければ超能 力に目覚めたかのどちらかでしょう。 もちろんコメントにより補足を行う手立ても 考えられますが、 コメントは実際のコードと乖離することがある以上、 解決策とし て上策ではありません。

テストの維持が難しくなる

優れた開発者は 「人間が間違いを犯す生き物である」という事実を知っています

し、その最たる例が自分であることも熟知しているでしょう。 テストはそのような 間違いを未然に発見できるツールです。 すべての間違いを防ぐことは叶いません が、思い違いや意図しない動作をある程度は見つけ出してくれます。 リスト 7.12 は User ApplicationServiceのテストを行うスクリプトの一部です。

リスト7.12: テストを行うための準備

ServiceLocator.Register<IUserRepository,

InMemoryUserRepository>();

var userApplication Service = new UserApplicationService();

UserApplicationService が実装された当初、 このコードは問題なく動作してい ました。 テストは開発者の思い違いを正し、 大いに役立ったものです。 そうしてう まくやってのけたコードも月日が経つにつれて変化が求められます。 User ApplicationServiceもまたそのうちのひとつでした(リスト7.13)。

リスト7.13 UserApplicationServiceに変化が起きた

public class UserApplication Service

private readonly IUserRepository userRepository; // 新たなフィールドが追加された

{

private readonly IFooRepository fooRepository;

public UserApplication Service()

this.userRepository = ServiceLocator.Resolve→ <IUserRepository>();

// ServiceLocator経由で取得している

this.fooRepository = ServiceLocator.Resolve→

<IFooRepository>();

}

{

(･･･略･･･)

}

新しいコードには新たな依存関係が追加されています。 しかし、 リスト7.12のテ

174

ストコードでは当然のことながら IFooRepository に対する依存解決が登録されて いません。 この変更によってテストは破壊されるのです。

とはいえ、テストが破壊されること自体はそれほど問題ではありません。 User ApplicationService を変更したことで、 それを取り扱うテストコードにも変更が 必要になるというのはよくあることです。 ここで問題とすべきは、 テストが破壊さ れたことが、 テストを実行するそのときまでわからないことです。

開発者にとってテストは自身を助けるものですが、 同時に途方もなく面倒なもの です。 テストを維持するにはある程度の強制力が必要です。 今回のような依存関係 の変更に自然と気づき、テストコードの変更を余儀なくさせる強制力をもたせるこ とができなければ、 近い将来テストは維持されなくなってしまうでしょう。

7.4.2 loC Container パターン

IoC (2) Container (DI Container) について知るにはまず Dependency Injection パターンについて知る必要があります。

Dependency Injection パターンは依存の注入という言葉で訳されます。 ほとん ど直訳ですので、 わかったようなわからないような言葉です。 具体例を確認して理 解しましょう。 リスト7.14はUserApplicationService に InMemory UserRepository に対する依存を注入、 つまり Dependency Injection をしています。

リスト7.14 依存を注入する

var userRepository = new InMemoryUserRepository();

var userApplication Service = new UserApplication Service (→ userRepository);

この形式はコンストラクタで依存するオブジェクトを注入しているのでコンスト ラクタインジェクションとも呼ばれます。 これまでの解説で何度も登場してきたパ ターンです。 Dependency Injectionパターンはこれ以外にメソッドで注入するメ ソッドインジェクションなど多くのパターンが存在します。 注入する方法はいくつ もありますが、いずれも依存するモジュールを外部から注入することに変わりあり ません。

Dependency Injection パターンであれば依存関係の変更に強制力をもたせら

loC は Inversion of Control の略で、 「制御の反転」 を意味します。

175

2

れます。 たとえばリスト7.15のようにUserApplicationService に新たな依存関係 を追加してみましょう。

リスト 7.15 新たな依存関係を追加する

public class UserApplicationService

{

private readonly IUserRepository userRepository;

// 新たにIFooRepositoryへの依存関係を追加する

private readonly IFooRepository fooRepository;

// コンストラクタで依存を注入できるようにする

public UserApplication Service (IUserRepository → userRepository, IFooRepository fooRepository)

{

this.userRepository = userRepository; this.fooRepository = fooRepository;

}

(･･･略･･･)

User ApplicationServiceでは新たな依存関係を追加するためコンストラクタに 引数が追加されています。 これによりUserApplicationServiceをインスタンス化 して実施しているテストはコンパイルエラーにより実行できなくなります (リスト 7.16).

リスト7.16 テストがコンパイルエラーになる

var userRepository = new InMemoryUserRepository();

// 第2引数にIFooRepositoryの実体が渡されていないためコンパイルエラーとなる

var userApplicationService = new UserApplication Service (→ userRepository);

テストを実施するために開発者はコンパイルエラーを解消することを余儀なくさ れます。 この強制は大いなる力です。

}

しかし、これは便利な一方で、 依存するオブジェクトのインスタンス化をあちこ

176

ちに記述する必要が生み出します。 たとえば開発時にインメモリのリポジトリでプ ログラムを動作させていた場合、 プロダクション環境へ移行するときにはデータ ベースに接続するリポジトリを利用するように変更する必要があります。 リスト 7.16 のようなリポジトリのインスタンス化を行っている箇所すべてを見つけ出 し、依存させたいリポジトリに差し替える必要があるのです。

この問題を解決するために活躍するのがIoC Containerパターンです。 リスト 7.17 のコードはC#のIoC Containerを利用してUser ApplicationService をイ ンスタンス化するコードです。

リスト7.17: loC Container を利用して依存関係を解決させる

// IoC Container

var serviceCollection = new ServiceCollection ();

// 依存解決の設定を登録する

serviceCollection. AddTransient <IUserRepository,

InMemoryUserRepository> ();

serviceCollection.AddTransient<UserApplicationService>();

// インスタンスはIoC Container経由で取得する

var provider = serviceCollection. BuildServiceProvider();

var userApplication Service

<UserApplicationService>();

provider.GetService➡

IoC Containerは設定にしたがって依存の解決を行い、 インスタンスを生成しま す。

リスト7.17を例に処理の流れを追ってみましょう。 オブジェクトのインスタンス 化が始まるのはリスト7.17の最終行からです。 GetService <UserApplicationSer vice > が呼び出され、 IoC Container は User ApplicationService を生成しようと します。 UserApplicationService はコンストラクタでIUserRepository を必要と するので、内部的に依存関係を解決し、 IUserRepositoryを取得しようとします。 IUserRepository は In Memory User Repository を利用するように登録されている ので、 User ApplicationService は InMemory UserRepositoryのインスタンスを 受け取り、インスタンス化されます (図7.9)。

177

4

L

7

Client GetService <UserApplicationService> loC Container UserRepository UserApplication Service IUserRepository ) Return

図7.9 loC Container による依存の解決

IoC Containerに対する設定方法は Service Locatorと同じくスタートアップ スクリプトなどで行います。

DDD 7.5

まとめ

この章ではプログラムとは切っても切れない関係にある重要な概念の依存と、 そ のコントロールの仕方について学びました。

依存関係はソフトウェアを構築する上で自然と発生するものです。 しかしながら その取り扱い方を間違えると手の施しようがないほど硬直したソフトウェアを生み 出すことに繋がります。

ソフトウェアは本来柔軟なものです。 利用者を取り巻く環境の変化に対応し、利

用者を助けるために柔軟に変化できるからこそ「ソフト」 ウェアと呼ばれるのです。 依存を恐れる必要はありません。 依存すること自体は避けられなくとも、依存の 方向性は開発者が絶対的にコントロールできるものです。 この章で学んだようにド メインを中心にして、 主要なロジックを技術的な要素に依存させないように仕立て 上げ、ソフトウェアの柔軟性を保つことを目指してください。

らす依存関係のコントロール

12

178

Chapter 8

ソフトウェアシステムを 組み立てる

ユーザーインターフェースに組み込んで、システムを 成り立たせます。

利用者がアプリケーションを利用するためにはユー ザーインターフェースが必要です。

ユーザーインターフェースと一口にいっても、文字を ベースにしたものやグラフィックをベースとしたもの など、実にさまざまな種類がありますが、これまで取 り扱ってきたアプリケーションはユーザーインター フェースを選びません。 文字ベースであってもグラ フィックベースであっても、任意のユーザーインター フェースに組み込むことが可能です。

そこで、本章ではまず文字ベースのユーザーインター フェースに組み込む手順と Web GUIに組み込む手順 を紹介します。

これまでに登場した要素をユーザーインターフェース に組み込み、 ソフトウェアとして成り立たせる方法を 確認していきましょう。

13

9

10

8

1

7

12

6

14

5

14

4

AP

3

DDD ソフトウェアに求められる ユーザーインターフェース 8.1

ソフトウェアの利用者はユーザーインターフェースを通してアプリケーションを 利用します。 ソフトウェアとして成り立たせるためにはユーザーインターフェース が必要です。

ユーザーインターフェースには沢山の種類があります。 たとえば利用者が文字列 によって指示を出す CLI (コマンドラインインターフェース) や操作対象がグラ フィックによって表現される GUI (グラフィカルユーザーインターフェース)はそ の代表です。

本書では Web GUI をユーザーインターフェースとしたWebアプリケーション をメインのサンプルにしますが、これはもちろんドメイン駆動設計が Webアプリ ケーションに限ったものということを意味しません。 その処理の指示方法が文字列 によるものであっても、グラフィカルなアイコンを駆使して指示されたものであっ ても、「ユーザを登録する」 というビジネスロジックに変わりはないからです。 ユー ザーインターフェースとして採用するのがCLIであったり GUIであったとしても ドメイン駆動設計の強力な力の恩恵を受けることは可能です。

それを証明するかのように、 本章ではまず最初にCLIで問題なくアプリケーショ ンの処理が実行できることを確認し、 その後に Web GUI をベースとした実践的な システムを構築していきます。 また、ソフトウェアはただ動作するだけでは完成で はありません。 間違いなく動作することを確かめてこそ本当の完成です。 したがっ て、 本章の最後にはアプリケーションが正しく動作する確認のためにユニットテス トを実施します。

アプリケーションのインターフェースがCLI や GUI、 果てはユニットテストと まったく異なるものであったとしても、ソフトウェアとして成り立たせることが可 能であることを確認していきましょう。

COLUMN

ソフトウェアとアプリケーションの使い分け

ソフトウェアとアプリケーションは一般的に同じものを指しますが、 本書ではド メインの問題を解決するなど利用者の必要を満たす主要なモジュール群をアプリ ケーションと呼び、 それらにユーザーインターフェースなどを付加してシステムと して成り立たせたものをソフトウェアと区別して記述しています。

14

13

12

システムを組み立てる

8

180

DDD コマンドラインインターフェース 8.2に組み込んでみよう

開発者はしばしばCLIを好んで利用しますが、 その理由はさまざまです。 たとえ ばグラフィックに関わる処理の実装が不要で単純であることや、 コマンドを正確に 入力するよう要求されるため誤操作を起こしづらい、 といったことが代表的な理由 でしょう。 ここでCLI を題材とする理由は、 主に前者を理由としています。

さっそくCLI で動作させるコードを確認していきましょう。 まずは依存関係の登 録を行うコードです。 依存関係のコントロールにはIoC Containerを利用します。 ServiceCollection は C# における IoC Container です (リスト 8.1)。

リスト 8.1 依存関係の登録を行う

class Program

{

private static ServiceProvider serviceProvider;

static void Main(string[] args)

Startup();

(･･･略･･･)

{

private static void Startup()

{

}

// IoC Container

var serviceCollection = new ServiceCollection ();

// 依存関係の登録を行う (以下コメントにて補足)

// IUserRepository が要求されたら InMemory UserRepository を生成して→ 引き渡す (生成したインスタンスはその後使いまわされる)

serviceCollection.AddSingleton <IUserRepository, InMemoryUserRepository>();

// UserServiceが要求されたら都度UserServiceを生成して引き渡す

serviceCollection.AddTransient<UserService>();

// UserApplicationServiceが要求されたら都度→ UserApplicationServiceを生成して引き渡す

serviceCollection.AddTransient<UserApplicationService>();

// 依存解決を行うプロバイダの生成

// プログラムはserviceProviderに依存の解決を依頼する

serviceProvider = serviceCollection. BuildServiceProvider();

}

}

IUserRepositoryの依存解決に利用する InMemory UserRepository は Add Singletonでシングルトンとして登録します。 シングルトンでの登録は一度インス タンスを作成したら、そのインスタンスを使いまわす設定です。 もしも InMemory UserRepository がシングルトンとして登録されていないと、 IoC Container は IUserRepository の依存解決が要求されるたびに、 InMemory User Repository の インスタンスを新たに生成します。 InMemory UserRepositoryはインメモリで動 作するオブジェクトであるので、 インスタンスごとにデータを保持します。 インス タンスの使いまわしをしないと余所で保存したデータが消えてしまいます。

COLUMN

シングルトンパターンと誤解

シングルトンパターンほど誤解を招きやすいデザインパターンはないでしょう。 その誤解というのはシングルトンをstaticの代わりとして扱われてしまうことで す。 もしシングルトンパターンがstaticの代わりとして使うためのパターンである なら、 素直に static を利用すればいいはずです。

シングルトンを利用する理由はインスタンスをひとつに限定しながら、 通常のオ ブジェクトと同様に取り扱えることです。 言い換えるなら、 static と異なり、 ポリ モーフィズムなどのオブジェクト指向プログラミングが実現する機能の恩恵を受け ることができるのです。

シングルトンをstaticの代わりとして扱うのは誤りです。 通常のオブジェクト指 向プログラミングの流れを組ませるためにシングルトンを利用するのが正しい利用 方法です。

UserApplicationService は AddTransientで登録します。 AddTransient での 登録はオブジェクトが要求されるたびに新しいインスタンスを生成する設定です。

182

今回のスクリプトではAddSingletonで登録したとしても問題ありませんが、 イン スタンスの生存期間はなるべくなら短くしておくことが管理をしやすくするコツで す。 パフォーマンスに問題がないようであれば、都度インスタンスを生成したとし ても問題ないでしょう。

なお、 AddSingleton や AddTransient といったメソッドはC#のIoC Container ライブラリである ServiceCollection に定義されたメソッド名にすぎません。皆さ んがご利用のプログラミング言語や loC Containerライブラリによって命名は異 なりますので、 対応するメソッドを確認してください。

8.2.1 メインの処理を実装する

スタートアップスクリプトにて依存の設定をしたのちは、いよいよメインの処理 です (リスト 8.2)。

リスト 8.2 メインとなる処理を実装する

class Program

private static Service Provider serviceProvider;

static void Main(string[] args)

{

Startup();

while (true)

Console.WriteLine("Input user name");

Console.Write(">");

var input = Console.ReadLine();

var userApplication Service = serviceProvider.GetService➡

<UserApplicationService>();

{

{

var command = new UserRegisterCommand (input);

userApplicationService.Register(command);

Console.WriteLine("-

Console.WriteLine("user created: ");

-");

183

Console.WriteLine("-

-");

Console.WriteLine("user name: ");

Console.WriteLine("-" + input);

Console.WriteLine ("-

---");

Console.WriteLine("continue? (y/n)");

Console.Write(">");

var yesOrNo = Console.ReadLine();

if (yesOrNo== "n")

{

break;

}

}

{

{

}

(------)

}

IoC Container (serviceProvider) からUserApplicationService を取得し、 ユーザ登録処理を呼び出しています。 インスタンスを直接生成せずにIoC Container経由でインスタンスを取得するようにすることで、 スタートアップスク リプトなどに依存関係の設定に関する記述を集中させられます。

プロダクション用のリレーショナルデータベースに接続するリポジトリを使用し たいときはスタートアップスクリプトを変更します (リスト8.3)。

リスト8.3 リポジトリを差し替える

class Program

(･･･略･･･)

private static void Startup()

var serviceCollection = new ServiceCollection ();

184

// UserRepositoryに差し替え

// serviceCollection.AddSingleton < IUserRepository,

InMemoryUserRepository>();

serviceCollection.AddTransient<IUserRepository,

UserRepository> ();

serviceCollection.AddTransient<UserService>();

serviceCollection.AddTransient<UserApplicationService>();

serviceProvider = serviceCollection. BuildServiceProvider();

}

より本格的なソフトウェアとして成り立たせるべくWebアプリケーションを組 み立ててみましょう。

Webアプリケーションを開発する際には、 Webフレームワークを利用するのが 一般的です。 C# における WebフレームワークはASP.NETというフレームワーク がメジャーです。 ASP.NETにはいくつかのバージョンが存在していますが、本書 では ASP.NET Core MVC を題材にします。

ここではCLIのときと同じように、 まずスタートアップスクリプトにて依存関係 を設定し、システムの利用者のアクションに応じて適宜必要なインスタンスをIoC Containerに要求するように設定と実装を確認していきます。 その後に実際に利用 者の操作から処理を実行する箇所を確認します。 処理の流れは図 8.1です。 予め確 認しておくとよいでしょう。

}

このようにIoC Container を活用することでメインの処理 (リスト8.2) にまっ たく手を加えることなく、 データストアの変更を実現できるのです。

DDD MVC フレームワークに 8.3 組み込んでみよう

185

MVCハード

Web Server スタート Startup 設定 IServiceCollection (loC Container) IUserRepository Type: InMemoryUserRepository Singleton IUser Repository を要求 InMemoryUser Repository を返却 (インスタンスを 使いまわす ) Web Server 옷 ①アクション UserController UserApplication Serviceを要求 ⑤UserApplicationServiceを返却 インスタンスを作る) UserApplicationService Type: UserApplicationService Transient

図8.1:MVC フレームワークとloC Containerの連携イメージ

ASP.NET Core MVCはMVC フレームワークとして一般的な機能を網羅して います。 皆さんが普段お使いのプログラミング言語やフレームワークがまったく異 なるものであったとしても、代替となる機能は存在するでしょう。 適宜読み換えな がら読み進めていってください。

8.3.1 依存関係を設定する

依存関係の設定はCLI のときと同じようにスタートアップスクリプト (リスト 8.4) で設定します。 ASP.NET Core MVCでは予めスタートアップスクリプトと してStartupクラスが用意されており、サーバー起動時にこの処理が実行されま す。

リスト 8.4: ASP.NET Core MVC が提供している Startup クラス

public class Startup { public Startup (IConfiguration configuration) { } Configuration configuration;

public IConfiguration Configuration { get; }

186

8

// This method gets called by the runtime. Use this method ➡ to add services to the container.

public void Configure Services (IServiceCollection services)

{

services.AddControllersWithViews();

services.AddSpaStaticFiles (configuration =>

{

configuration. RootPath = "ClientApp/build";

});

}

(…略…)

StartupクラスのConfigureServicesメソッドはIoC Containerを利用して依 存関係を登録する箇所です。 このメソッドにリポジトリなどの依存解決の設定を 行っていきます (リスト8.5)。

リスト8.5 MVC フレームワークのスタートアップスクリプトで依存解決の設定をする

public class Startup {

(…略…)

public void Configure Services (IServiceCollection services) {

services.AddControllersWithViews();

services.AddSpaStaticFiles (configuration => { configuration. RootPath = "ClientApp/build"; });

18:

}

// リポジトリやアプリケーションサービスの依存解決を設定する services.AddSingleton <IUserRepository, InMemoryUserRepository>(); services.AddTransient<UserService>(); services.AddTransient<UserApplicationService>(); } }

リスト8.5に追加した依存関係の登録はリスト8.1で行っていた登録と同じ内容 です。 設定自体に問題はありませんが、 このままではプロダクション用としてデー タベースに接続して動作させたいとき、 この設定スクリプトに変更を加える必要が あります。 現段階では登録されているリポジトリはたったひとつなのであまり問題 にはなりませんが、システムが大きくなるにつれて比例するようにリポジトリの数 は増えてきます。それらすべてを起動のたびにいちいち設定を書き直すのは大きな 手間です。

こうした手間を省くためにデバッグ用とプロダクション用でコンフィグスクリプ トを分けるのはよいアイデアです (リスト8.6、 リスト 8.7)。

リスト8.6: テスト用の設定スクリプト

public class InMemoryModuleDependencySetup: IDependencySetup

{ public void Run(IServiceCollection services) { } SetupRepositories (services); SetupApplicationServices (services); SetupDomainServices (services); private void Setup Repositories (IServiceCollection services) {

services.AddSingleton<IUserRepository, ➡

InMemoryUserRepository>();

188

}

private void Setup Application Services (IServiceCollection services) { } services. AddTransient <UserApplicationService>(); private void Setup DomainServices (IServiceCollection services) { services. AddTransient <UserService>(); } }

リスト8.7プロダクション用の設定スクリプト

public class SqlConnection DependencySetup IDependencySetup

private readonly IConfiguration configuration;

public SqlConnection DependencySetup (IConfiguration ➡ configuration)

{

{

this.configuration = configuration;

public void Run (IServiceCollection services)

{

Setup Repositories (services);

}

Setup Application Services (services);

SetupDomainServices (services);

}

private void Setup Repositories (IService Collection services)

{

services.AddTransient<IUserRepository, SqlUserRepository>();

}

private void Setup Application Services (IService Collection → services) { services.AddTransient<UserApplicationService>(); } private void SetupDomainServices (IService Collection services) { } services.AddTransient <UserService>();

}

これらのスクリプトはプロジェクトの構成ファイルによって切り替えます。 ASP.NET Core では appsettings.json というjson 形式のファイルがその構成ファ イルにあたります (リスト8.8)。

リスト8.8 利用する設定スクリプトを構成ファイルに記述する

{ "Dependency": { "SetupName": "InMemoryModule Dependency Setup" } }

スタートアップスクリプトではリスト8.8 を読み込み、 実施する依存関係の設定 処理を切り替えます (リスト8.9、 リスト 8.10)。

190

リスト8.9 リスト8.8の設定により設定スクリプトを選定するモジュール

class DependencySetupFactory

public IDependencySetup CreateSetup (IConfiguration ➡

{

configuration)

{

var setupName = configuration ["Dependency: SetupName"]; switch (setupName)

{

case nameof (InMemory ModuleDependencySetup):

return new InMemoryModuleDependencySetup();

case nameof(SqlConnection DependencySetup):

return new SqlConnection Dependency Setup (configuration);

default:

throw new NotSupportedException (setupName + " is ➡

not registered.");

}

リスト 8.10 スタートアップスクリプトはリスト 8.9を利用する

public class Startup

{

}

}

public IConfiguration Configuration { get;

public void ConfigureServices (IService Collection

}

services)

{

// 依存関係の設定スクリプトを取得して実行

var factory = new DependencySetupFactory();

var setup factory. CreateSetup (Configuration);

setup.Run(services);

19.

services.AddControllersWithViews ();

services.AddSpaStaticFiles (configuration =>

configuration RootPath = "ClientApp/build"; });

}

(･･･略･･･)

}

8.3.2 コントローラを実装する

さぁ、依存関係の設定をしている箇所の確認が済んだところで、 いよいよコント ローラの実装の確認です。 まずはユーザ登録のデータを受け取り、ユーザを登録す る処理 (アクション) を確認しましょう。

多くのMVCフレームワークはIoC Container と連携しており、 IoC Container に登録されたオブジェクトをコントローラのコンストラクタで受け取ることができ ます。 UserApplicationService を利用したい場合、 リスト8.11のようにコンスト ラクタで受け取り、アクションから呼び出すように記述します。

リスト8.11 ユーザを作成するアクション

[Route("api/ [controller]")]

public class UserController: Controller

{

{

private readonly UserApplicationService →

userApplicationService;

// IoC Containerと連携して依存の解決が行われる

public UserController (UserApplicationService →

userApplicationService)

アシステムを組み立てる

192

{

this.userApplicationService = userApplicationService;

}

(88)

[HttpPost]

public void Post([FromBody] UserPostRequestModel request)

{

var command = new UserRegisterCommand(request.UserName); userApplicationService.Register (command);

}

}

Post アクションの引数であるUserPostRequestModel はビューから受け渡され るデータがバインドされるオブジェクトです。 このオブジェクトはアプリケーショ ンサービスが受け取るUserRegisterCommand オブジェクトとほとんど同じデー タ構造ですので、 それを使いまわすアイデアも思い浮かびますが、 フロントから引 き渡されるデータの入れ物と、アプリケーションサービスのふるまいを実行するた めのコマンドオブジェクトは用途が違うものです。 特に理由がないようであれば、 オブジェクトの使いまわしをしない方がよいでしょう。 その他の処理も確認してみましょう (リスト8.12)。

リスト 8.12: コントローラのその他の処理

Route("api/[controller]")] public class UserController Controller {

private readonly UserApplicationService userApplicationService;

193

a

public UserController (User ApplicationService ➡

userApplicationService)

this.userApplicationService = userApplicationService;

{

}

[HttpGet]

public UserIndexResponseModel Index()

{

var result = userApplicationService.GetAll(); var users = result. Users. Select(x => new → UserResponseModel(x.Id, x.Name)).ToList();

} return new UserIndexResponseModel (users);

[HttpGet("{id}")]

public UserGetResponseModel Get(string id)

{

var command = new UserGetCommand(id);

var result = userApplication Service. Get (command);

var userModel = new UserResponseModel (result.User);

return new UserGetResponseModel (userModel);

}

(…略…)

[HttpPut("{id}")]

public void Put(string id, [FromBody] UserPutRequestModel ➡

request)

{

194

var command= new UserUpdateCommand (id, request.Name);

userApplicationService.Update (command);

}

HttpDelete("{id}")]

public void Delete(string id)

{

var command = new UserDeleteCommand (id);

userApplicationService.Delete (command);

}

}

いずれのアクションも、コントローラはフロントからのデータをビジネスロジッ クが必要とする入力データへ変換する作業に集中しています。 ビジネスロジックを アプリケーションサービスに寄せるようになると、結果としてコントローラのコー ドはリスト8.11 やリスト 8.12 とほとんど同じようなコードばかりのシンプルなも のになるでしょう。

以上でCRUD 機能をもった最小限のWebアプリケーションは完成です。

COLUMN コントローラの責務

コントローラの責務は入力の変換です。 たとえばゲーム機を思い浮かべてみてく

ださい (図8.2)。

Push Signal

図8.2 コントローラの役目

57 19

ゲームのプレイヤーはコントローラのボタンを押すことでキャラクターを動かしま す。このときコントローラは「ボタンが押された」 という事実をそのままゲーム機に 送っているわけではありません。 コントローラは「ボタンが押された事実」をゲーム 機が解釈できる電気信号に変換して送信しているのです。 ゲーム機のコントローラの 責務はプレイヤーの入力をゲーム機が理解できる形に変換する作業です。

MVCパターンのコントローラもこれと同じです。 コントローラはユーザからの 入力をモデルが要求するメッセージに変換し、 モデルに伝えることが責務です。 も しもコントローラがそれ以上のことをこなしているように見受けられたのなら、 ド メインの重要な知識やロジックコントローラに漏れ出している可能性を疑うべき です。

ユニットテストを書こう 8.4 DDD

ソフトウェアを完成とするには意図したとおりに動くことを証明する必要があり ます。 プログラムが正しく動作することを証明するのにユニットテストは最高の ツールです。 百聞は一見に如かずという言葉もあるとおり、 動作することを口頭で 説明するも、正しく動作することを実証してしまう方がずっと簡単です。

この最小限のアプリケーションにもユニットテストを用意して、 完成を証明しま しょう。

8.4.1 ユーザ登録処理のユニットテスト

ユニットテストのたびにテストデータを用意することはあまり現実的ではありま せん。 ユニットテストでは実際のデータストアに接続したりといったことは基本的 に行いません。 そこで登場するのがテスト用のリポジトリです。

本書ではこれまでアプリケーションをインメモリで動作させることの重要性とそ のための努力を何度も訴えてきました。 いよいよその真価を発揮するときです。 まずはユーザ登録処理が正常に完了することを確認するユニットテストです リ

スト8.13)。 なお、 C#ではユニットテストクラスに [TestClass] や [TestMethod] といったアトリビュートを付与します。

196

リスト 8.13: ユーザ登録処理の正常テスト

[TestClass]

public class UserRegisterTest

{

[TestMethod]

public void TestSuccess MinUserName()

var userRepository = new InMemoryUserRepository

();

var userService = new UserService (userRepository);

var userApplicationService = new UserApplicationService➡ (userRepository, userService);

// 最短のユーザ名 (3文字) のユーザが正常に生成できるか

var userName = "123";

var minUserNameInputData = new UserRegisterCommand➡ (userName);

userApplicationService. Register (minUserNameInputData);

// ユーザが正しく保存されているか

var createdUserName = new UserName(userName);

var createdUser = userRepository. Find (created UserName); Assert. IsNotNull(createdUser);

}

[TestMethod] public void TestSuccessMaxUserName()

var userRepository = new InMemoryUserRepository();

var userApplicationService = new UserApplication Service➡ (userRepository, userService);

{

{

var userService = new UserService (userRepository);

// 最長のユーザ名 (20文字) のユーザが正常に生成できるか

var userName = "12345678901234567890";

var maxUserNameInputData = new UserRegister Command➡ (userName);

userApplicationService.Register (maxUserNameInputData);

// ユーザが正しく保存されているか

var createdUserName = new UserName (userName);

var maxUserNameUser = userRepository. Find (createdUserName);

Assert.IsNotNull (maxUserNameUser);

}

ユーザ登録処理で確認すべきは 「生成されたユーザが保存されているか」というこ とです。 ユーザ名には文字数に関して条件があるので境界値の検査も同時に行って います。 生成されたユーザが保存されているかを確認するためにインメモリのリポ ジトリを用いて処理を実行し、 処理が完了したのちにリポジトリに対して問い合わ せをしています。

テストしたい内容によってはリポジトリに収められた必要な情報を取得するため のメソッドが提供されていないことがあります。 そういったときにはリポジトリに 対する問い合わせを行わず、 リポジトリがデータを保管しているフィールドを公開 することで対応できます (リスト8.14)。

リスト8.14 テストで確認するためにテスト用リポジトリの内部データを公開する

public class InMemoryUserRepository: IUserRepository

// 直接のデータ保管先となる連想配列を公開している

{

public Dictionary<UserId, User> Store { get; } = new ⇒ Dictionary<UserId, User>();

(･･･略･･･)

}

}

ウェアシステムを

8

198

このオブジェクトを利用したテストコードはリポジトリに問い合わせを行わず、 リポジトリのプロパティを直接操作するように変化します (リスト8.15)。

リスト8.15: リスト8.14を利用してユーザが保存されたかを確認する

[TestMethod] public void TestSuccess MinUserName()

{

var userRepository = new InMemoryUserRepository();

var userService = new UserService (userRepository);

var userApplicationService = new UserApplicationService➡

(userRepository, userService);

// 最短のユーザ名 (3文字) のユーザが正常に生成できるか

var userName = "123";

var minUserNameInputData = new UserRegister Command (userName); userApplicationService.Register(minUserNameInputData);

// ユーザが正しく保存されているか

var createdUser = userRepository.Store.Values

FirstOrDefault(user => user.Name.Value == userName);

Assert. IsNotNull (createdUser);

}

テスト用のリポジトリがデータ保管先としているフィールドを外部から操作でき るようにすることは、きめ細かい検索を可能にし、テスト用モジュールの利便性を 向上させます。 フィールドを無暗に公開することは避けるべきですが、 通常利用さ れるのは IUserRepository であるためリスト8.14のStore プロパティを操作はでき ません。 InMemory User Repository を直接利用するのはテストコードだけですの で、 Store プロパティのように直接のデータ保管オブジェクトを公開しても問題は 起きないのです。

さて、正常系のテストを確認したのちは異常系のテストです。 ユーザ生成処理は パラメータによってはエラーを発生させることがあります。 エラーの条件をまとめ ると次のリストのとおりになります。

19

. 登録しようとしたユーザ名の長さが3文字以上20文字以下でない

・既に登録されているユーザ名である

異常系は正常系に比べて多く検査する項目があるので若干複雑になります。 ま ずはユーザ名の長さが異常なときの動作の確認テストです (リスト8.16)。

リスト8.16 ユーザ名の長さに関するエラーをテストする

[TestClass] public class User RegisterTest { (------)

[TestMethod]

public void TestInvalidUserNameLengthMin()

var userRepository = new InMemoryUserRepository();

var userService = new UserService(userRepository);

var userApplicationService = new UserApplicationService➡ (userRepository, userService);

bool exceptionOccured = false;

try

var command = new UserRegisterCommand("12");

userApplicationService.Register (command);

}

catch

exceptionOccured = true;

{

{

{

}

Assert.IsTrue (exceptionOccured);

}

200

[TestMethod]

public void TestInvalidUserNameLength Max()

{

var userRepository = new InMemoryUserRepository();

var userService = new UserService (userRepository);

var userApplicationService = new UserApplicationService➡ (userRepository, userService);

bool exceptionOccured = false; try { var command = new UserRegister Command➡ ("123456789012345678901"); } userApplicationService. Register (command); } } catch { } exceptionOccured = true; Assert. IsTrue (exception Occured);

ユーザ名が下限値よりも短いときと上限値よりも長いときのふたとおりを確認し ています。 正常系と合わせれば境界値検査が網羅されていることがわかります。 最後のテストはユーザ名が重複しているときの動作を確認するテストです (リス

+8.17).

201

リスト 8.17: ユーザ名の重複に関するエラーをテストする

[TestClass]

public class User RegisterTest

(…略…)

{

[TestMethod]

public void TestAlready Exists()

var userRepository = new InMemoryUserRepository();

var userService = new UserService (userRepository);

var userApplication Service = new UserApplicationService➡

(userRepository, userService);

var userName = "test-user";

userRepository.Save(new User(

new UserId("test-id"),

new UserName(userName)

));

bool exception Occured = false;

try

{

var command = new UserRegister Command (userName); userApplicationService. Register (command);

}

catch { exceptionOccured = true; }

Assert. IsTrue(exception Occured);

}

}

{

202

ユニットテストを作成するとそこにはどういった入力をすればよいのか、その入 力によって得られる結果はどうあるべきか、といったことが記述されます。 あまり 考えたくないことですがドキュメントの類が一切存在しないプロダクトにおいて は、ユニットテストがそのロジックのあるべき姿を語る最後の手掛かりになるで しょう。

DDD まとめ 8.5

この章ではこれまで解説してきたパターンをまとめあげ、アプリケーションを実 際にユーザーインターフェースへ組み込み、 ソフトウェアとして成り立たせる方法 を確認しました。

アプリケーションにとってユーザーインターフェースは交換可能なものです。 ユーザーインターフェースをソフトウェアの核心から分離し、 オブジェクトの責務 を明瞭にすることはソフトウェアの未来を守るに等しい行為です。

実際にユーザーインターフェースを交換するような事態は稀ですが、 ユーザーイ ンターフェースを交換可能であるということはアプリケーションが単独で実行でき るということで、つまりユニットテストを実施できるということに他なりません。

ユニットテストがそのままソフトウェアの品質向上になるわけでは必ずしもあり ませんが、 ユニットテストができるような形に仕立てることは品質向上の第一歩で す。

ソフトウェアに対する変化の要求を満たすために、開発者はリファクタリングを 余儀なくされることがあります。 そのとき、 ユニットテストが準備されていれば、 リファクタリングによってアプリケーションを破壊していないかを確認しながら、 作り変えることができるのです。

ドメインの変化をドメインオブジェクトまできっちりと伝え、システムがドメイ ンと同期するように仕向けるためにユニットテストを用意しておくことは大事な戦 略です。

203

5

まとめ

8

COLUMN 本当に稀な怪談話

「そうはいうものの、ユーザーインターフェースを交換するような事態なんて起 こらない」と高を括ってはいないでしょうか。 残念ながら実際にユーザーインター フェースを交換する羽目になった経験が筆者にはあります。

そのプロダクトは主力のサービスで、 ASP.NET Web Forms で構築されたソフト ウェアでした。 Web Forms は技術者の獲得が難しく、 より一般的なMVCに乗り換 える必要がありました。 運命だったとは信じたくないのですが、 そのお鉢はなぜか 筆者に回ってきました。

15年程の手垢にまみれたコードは筆者を恐怖に陥れました。 すべてのロジックは ユーザーインターフェースに記述されており、似たようなロジックが至るところに 記述されています。 もともと同一だったロジックはそれぞれの画面の事情にした がって出鱈目な進化を遂げていたのです。

当然のようにユニットテストはありません。 それどころかドキュメントすらも存 在しなかったのです。 結局のところ筆者にできたのは、愚直にすべてのコードを読 み解いて、 ゼロベースでコードを組み立てることでした。

204

Chapter 9 複雑な生成処理を行う 「ファクトリ」

ファクトリは作る知識に特化したオブジェクトです。

オブジェクトの生成はときに複雑な手順を必要としま す。そういった手順は、 モデルを表現するオブジェク トに無理やり実装するよりも、 オブジェクトの生成そ れ自体を独立したオブジェクトとする方がコードの意 図を明確にすることに繋がります。

道具を作ることと道具を使うことはまったく別の知識 であるのと同様に、 オブジェクト生成の責務はモデル を表現するオブジェクトには相応しくないのです。

本章で解説するファクトリはオブジェクトを生成する 責務をもったオブジェクトです。

12

11

10

14

13

9

15 APP

8

DDD 9.1

ファクトリの目的

あたりを少し見渡せば、 視界には多くの道具が飛び込んできます。 机 椅子、 紙、 ペン・・・・・・人間は道具に囲まれて暮らしています。 世の中には道具が満ち溢れていま すが、いまもなお新しい道具が増え続けています。

道具が人間の想像の赴くままに創造されている理由は、 道具の扱い方を知ってい れば内部構造に詳しくなくとも恩恵を受けることができる便利さにあるでしょう。 この便利さは大きな力です。 そしてプログラムにおいてもこれは同じです。

オブジェクト指向プログラミングにおけるクラスはさながら道具です。 メソッド の扱い方さえ知っていれば、クラスの内部構造を意識せずとも扱うことができま す。 これは開発者を大きく支援する力です。

ところで、 道具は便利なものですが、 その便利さに比例して複雑な機構をもつこ とがあります。

たとえば、コンピュータが便利な道具であることは技術者であればよくご存知の ことでしょう。 そしてその内部構造が複雑だということもまた熟知しているはずで す。 ここで争点としたいのは内部構造が複雑であることではなく、 「複雑な道具はそ の生成過程も得てして複雑である」ことです。

皆さんはコンピュータの製造過程を知っているでしょうか。

複雑な道具はその生成過程も複雑です。 ともすれば生成過程がある種の知識とな ります。 プログラムにおいてもこれは同じで、 複雑なオブジェクトはその生成過程 も複雑な処理になることがあります。 そうした処理はモデルを表現するドメインオ ブジェクトの趣旨をぼやけさせます。 かといって、 その生成をクライアントに押し 付けるのはよい方策ではありません。 生成処理自体がドメインにおいて意味をもた なかったとしても、 ドメインを表現する層の責務であることには変わりないので す。

求められることは複雑なオブジェクトの生成処理をオブジェクトとして定義する ことです。 この生成を責務とするオブジェクトのことを、道具を作る工場になぞら えて「ファクトリ」といいます。 ファクトリはオブジェクトの生成に関わる知識が まとめられたオブジェクトです。

DDD 採番処理をファクトリに 9 2 実装した例の確認

ファクトリが活躍するわかりやすい例として挙げられるものに採番処理があります。 これまでUserのインスタンスを生成する際、 その識別子はGUID (Globally Unique Identifer) を利用していました (リスト9.1)。

リスト 9.1 ユーザの識別子はコンストラクタで生成される

public class User

private readonly UserId id; private UserName name;

// ユーザを新規作成するときのコンストラクタ

public User (UserName name )

if (name == null) throw new ArgumentNullException (nameof(→

name));

// GUIDを利用して識別子を生成している

id = new UserId (Guid.NewGuid().ToString());

this.name = name;

{

// ユーザを再構築するときのコンストラクタ

}

public User (UserId id, UserName name)

if (id == null) throw new ArgumentNullException (nameof (id)); if (name == null) throw new ArgumentNullException (nameof(→ name));

{

this.id = id: this.name = name;

20

{

}

(...8...)

}

User クラスにはコンストラクタが2つあります。 引数としてUserld を渡すコン ストラクタが再構築用で、 UserIdを渡さないコンストラクタが新規作成用となっ ています。 ユーザを新規作成するときに生成しているGUIDは衝突しない識別子と して扱えるランダムな文字列ですので、 コンストラクタで生成してもユニークであ ることが保証されます。

しかし、システムによってはこの採番処理をコントロールしたいことがありま す。そういった採番処理はどのように実装するのがよいでしょうか。

伝統的な採番処理の手法にシーケンスや採番テーブルを利用したものがありま す。 User クラスの採番処理をシーケンスを利用するように書き換えてみましょう (リスト 9.2)。

リスト 9.2 採番テーブルを利用するように変更

public class User

{

private readonly UserId id; private UserName name;

public User (UserName name)

{

string seqId;

// データベースの接続設定からコネクションを作成して

var connectionString = ConfigurationManager.→

ConnectionStrings ["DefaultConnection"].ConnectionString;

using (var connection = new SqlConnection(connectionString)) using (var command = connection.CreateCommand())

{

connection.Open();

// 採番テーブルを利用し採番処理を行っている

command.CommandText = "SELECT seq = (NEXT VALUE FOR →

UserSeq)";

208

())

using (var reader = command.ExecuteReader{ if (reader.Read()) { } var rawSeqId = reader["seq"]; seqId = rawSeqId.ToString(); else { } throw new Exception();

}

id = new UserId (seqId);

this.name = name;

}

(------)

}

リスト 9.2はあまり好ましいコードではありません。 高レベルな概念であるUser にデータベースの操作という低レベルな処理が記述されてしまっています。 このよ うなコードが引き起こす弊害は目もあてられません。 User クラスをただインスタ ンス化するだけでもデータベースや採番テーブルの準備が必要です。 それはとても 面倒な作業で直感的ではありません。

可能であればテスト用に気軽にインスタンスを生成したいときは適当なIDを振 りさもなければデータベース接続して採番を行えるようにしたいところです。 こ ういったとき、 ファクトリが役に立ちます。

採番処理を切り替えるような仕組みが必要なときにはリスト 9.3のようなファク トリのインターフェースを用意します。

フクトリにしたの

209

リスト 9.3: ファクトリのインターフェース

public interface IUserFactory { } User Create (UserName name);

ファクトリに定義されているUserName を引数に取りUserのインスタンスを 返却するメソッドはUser を新規作成する際にコンストラクタの代わりとして利用 されます。

User を生成する処理はリスト 9.3を実装したクラスが取り持ちます。 リスト 9.4 はシーケンスを利用して採番処理を行うファクトリの実装クラスです。

リスト9.4 シーケンスを利用したファクトリ

public class UserFactory: IUserFactory

{ public User Create (UserName name) { string seqId;

var connectionString = ConfigurationManager.→

ConnectionStrings["DefaultConnection"].ConnectionString;

using (var connection = new SqlConnection (connectionString))

using (var command = connection.CreateCommand())

{

connection.Open(); command.CommandText = "SELECT seq = (NEXT VALUE FOR → UserSeq)"; using (var reader = command.ExecuteReader()) { if (reader.Read()) { } var rawSeqId = reader["seq"]; seqId = rawSeqId.ToString();

210

else { } throw new Exception(); } } var id = new UserId (seqId); return new User (id, name);

}

}

インスタンス生成の処理がファクトリに移設されたことでUserクラスをインス タンス化する際には必ず外部からUserldが引き渡されることになります。その変 化を受けてUserクラスのUserld を採番していたコンストラクタが不要になりま す(リスト 9.5)。

リスト 9.5 User クラスのコンストラクタはひとつになる

public class User

{

private readonly UserId id; private UserName name;

public User (UserId id, UserName name)

{

if (id == null) throw new ArgumentNullException (nameof(id)); if (name == null) throw new ArgumentNullException(nameof (name));

this.id = id;

this.name = name;

}

(･･････)

}

21

192 番処理をファクトリに実装した

これでUser クラスのコンストラクタにおいてデータベースに接続するコードを 記述しなくて済むようになります。

なお、ファクトリを利用するようになると UserApplicationService のユーザ登 録処理ではUserのインスタンスの生成をファクトリ経由で行うようになります (リスト 9.6)。

リスト 9.6 ファクトリを経由してインスタンスを生成する

public class UserApplication Service

private readonly IUserFactory userFactory;

private readonly IUserRepository userRepository;

private readonly UserService userService;

(･･･略･･･)

public void Register (UserRegister Command

command)

var userName = new UserName (command.Name);

// ファクトリによってインスタンスを生成する

var user = userFactory.Create (userName);

if (userService.Exists(user)) { } throw new CanNot RegisterUserException(user);

} } userRepository.Save(user);

Registerメソッドをテストする際にはリレーショナルデータベースに接続しな インメモリで動作させたいと考えるでしょう。 その際にはリスト 9.7に示すファ クトリを用意します。

{

{

212

リスト 9.7インメモリで動作するファクトリ

class InMemoryUserFactory: IUserFactory

{

// 現在のID

private int currentId;

public User Create (UserName name)

{ } // ユーザが生成されるたびにインクリメントする currentId++; return new User( ); new UserId(currentId.ToString()), name

このインメモリで動作するオブジェクトを依存解決の対象として設定すればテス トを行うことが可能になります。

COLUMN ファクトリの存在に気づかせる

ファクトリを準備したとき、 オブジェクトのインスタンス化はファクトリを経由 して実施されることが期待されます。 しかし、 Userクラスを見ても、ファクトリの 存在に気づくことはできません (リスト9.8)。

}

リスト 9.8 User クラスの定義を見てもファクトリの存在に気づけない

public class User { // コンストラクタがあることがわかるのみ public User (UserId id, UserName name); (･･･略･･･) }

21

ファクトリの存在に気づかせるための仕掛けとして挙げられるのは、次のような パッケージによるグループ分けです。

・SnsDomain.Models.Users.User

・SnsDomain.Models.Users.IUserFactory

後続の開発者がSnsDomain.Models.Users パッケージを俯瞰してみたとき、 User とIUserFactoryが同居していることがわかります。

9.2.1 自動採番機能の活用

採番処理といえばデータベースの機能として存在する自動採番機能を無視するこ とはできません。

たとえばSQL ServerではIDENTITY をカラムに設定するとレコードが挿入さ れた際に自動で採番が行われます (図9.1)。

Naruse 1985/9/8 Tokyo Id Name 1 Sato Birth Day Address 2000/1/1 Tokyo ld Name Birth Day Address 1 Sato 2000/1/1 Tokyo 2 Naruse 1985/9/8 Tokyo

図9.1 自動採番機能

この機能は強力です。 もしこの自動採番処理を取り入れたならば、コードにはど のような変化が現れるでしょうか。

自動採番処理はデータベースに対しての永続化を行うことでIDが割り振られま す。必然的にインスタンスが初めて作られたときにはIDが存在していないオブ ジェクトとして生成されます。 またIDを永続化の際に設定するため、セッターを用 意する必要ができます (リスト9.9)。 これらはオブジェクトを不安定にさせる要素

214

です。

リスト 9.9 オブジェクトにセッターを用意する

public class User

{

private UserName name;

public User (UserName name ) { this.name = name; }

public UserId Id { get; set; }

}

エンティティは識別子により識別されるオブジェクトです。 その識別子が永続化 を行うまで存在しないというのは不自然で強烈な制限事項です。 誤って識別子が設 定されないうちに操作してしまったら、意図しない挙動になるでしょう。 開発者は 永続化されるまで識別子が生成されないことを常に意識し、 細心の注意を払う他あ りません。

もうひとつ気になることがあります。 それはセッターの存在です。 リスト 9.9の User クラスのIdプロパティのセッターはリポジトリから操作されるということを 前提としています。 しかしクラスの定義を見ただけでは、 それをうかがい知ること が叶いません。 事情を知らない開発者が不意にIDを付け替える記述をしてしまう 可能性を残します。

いずれにせよ共通する問題は開発者に対して暗黙の了解を課すことです。 暗黙の 了解は開発者に強力な自制心を求めます。 すなわち 「やりすぎないように」と

自動採番処理を利用することに決めるといくつかの懸念事項が発生します。 しか

し、その上であえて自動採番機能によってIDを割り振ることを受け入れる選択肢 はもちろんあります。 自動採番機能を採用する場合には開発上のルールをよく周知 することが必要です。 チームの合意として受け入れられているのであれば、問題を 引き起こすことは稀でしょう。

215

2 処理をファクトリに実装したの

9.2.2 リポジトリに採番用メソッドを用意する

ファクトリとは少し外れますが、 リポジトリに採番を行うメソッドを用意するパ ターンもあります (リスト9.10)。

リスト 9.10 リポジトリに採番処理を定義する

public interface IUserRepository { User Find (UserId id); void Save (User user); UserId NextIdentity(); }

NextIdentity メソッドは採番を行い、 新しいUserld を生成します。 この採番処 理を利用するとコードはリスト 9.11のように変更されます。

リスト 9.11 採番処理を利用してユーザを登録する

public class UserApplication Service

{

private readonly IUserRepository userRepository;

(･･･略･･･)

public void Register (User Register Command command)

var userName = new UserName (command.Name);

var user = new User (

userRepository. NextIdentity(),

userName

);

(･･･略･･･)

}

}

{

リポジトリに採番処理のメソッドをもたせるのはとても気楽な選択肢です。 ファ クトリを用意するほど手間ではなく、 かといってIDが存在しない不安定なエン ティティの存在を許容するわけでもありません。

ただしリスト 9.12のように採番処理と永続化処理の具体的な技術が異なってい た場合は少し事情が異なってきます。

リスト 9.12 採番処理と永続化で利用される技術が異なる

public class UserRepository: IUserRepository

private readonly NumberingApi numberingApi;

(･･･略･･･)

// リレーショナルデータベースを利用しているが

public User Find (UserId id)

{

var connectionString = ConfigurationManager.→

ConnectionStrings ["DefaultConnection"].ConnectionString;

using (var connection = new SqlConnection (connectionString)) using (var command = connection.CreateCommand())

{

connection.Open();

@id"; command.CommandText = "SELECT * FROM users WHERE id=

command.Parameters.Add(new SqlParameter("@id", id.Value))using (var reader = command.ExecuteReader()) if (reader.Read()) { var name = reader ["name"] as string; return new User( id, new UserName (name) );

;

{

{

} else { return null; }

} // 採番処理はリレーショナルデータベースを利用していない public UserId NextIdentity() { } var response = numberingApi.Request(); return new UserId(response.NextId);

ひとつのクラス定義の中に複数の技術基盤に基づく操作が記述されています。 こ れを歪に感じる方もいるでしょう。 気にするレベルではないという意見もありま す。

このパターンはその手軽さからして受け入れられやすいものであることも確かで す。 開発チームでの合意が取れているのであればこのパターンを採用することは問 題ではありません。

筆者の個人的な感覚では、そもそもリポジトリはデータの永続化と再構築を行う オブジェクトです。 採番処理にまで手を伸ばすのは少し責務を広げ過ぎているよう に感じるため推奨していません。

DDD ファクトリとして機能する 9.3 メソッド

クラスそれ自体がファクトリとなる以外に、 メソッドがファクトリとして機能す ることもあります。 これはオブジェクトの内部データを利用してインスタンスを生 成する必要があるときに利用されます。

たとえばサークル機能を考えてみましょう。サークルはクラブとかチームのよう

なものでユーザが所属して趣味などを語り合うグループです。 サークルにはその オーナーとなるユーザがいます。 どのユーザがそのオーナーであるのかの目印とし てユーザIDをもつようにしましょう。 するとコードはリスト 9.13のようになりま す。

リスト 9.13: サークルを生成する

var circle = new Circle ( ); user.Id, // ゲッターによりユーザのIDを取得 new CircleName("my circle")

サークルのオーナーとなるユーザのIDをCircleオブジェクトへ渡すためにゲッ ターを利用することになります。 ゲッターについては既に広く知れ渡っているとお り、安直に使用してよいものではありません(このことについては第12章 「ドメイ ンのルールを守る 「集約」」 にて詳しく解説します)。

内部情報を利用しつつも公開はしないという芸当は、 とても単純な手法によって 達成可能です。 ゲッターを公開するのではなく、 メソッドでインスタンスを生成し て戻り値として返却すればよいのです (リスト 9.14)。

リスト9.14: User クラスのメソッドでCircle クラスのインスタンスを生成する

public class User

{

// 外部に公開する必要がない

private readonly UserId id;

(･･････)

// ファクトリとして機能するメソッド

public Circle CreateCircle (CircleName circleName)

return new Circle ( hid, ); circleName

{

}

このようにファクトリとして機能するメソッドを用意することでインスタンスの 内部情報を引き渡すことができます。

このふるまいが正当なものかどうかはドメインに対する捉え方によります。 ユー ザがサークルを生成することをドメインオブジェクトのふるまいとして定義するべ きであれば正当化されるでしょう。

DDD 複雑な生成処理を 4 カプセル化しよう

ポリモーフィズムの恩恵に与るためにファクトリを利用する以外に、 単純に生成 方法が複雑なインスタンスを構築する処理をまとめるためにファクトリを利用する のもよい習慣です。

本来であれば初期化はコンストラクタの役目です。 しかしコンストラクタは単純 である必要があります。 コンストラクタが単純でなくなるときはファクトリを定義 します。

「コンストラクタ内で他のオブジェクトを生成するかどうか」 はファクトリを作 る際の動機付けによい指標となります。 もしもコンストラクタが他のオブジェクト を生成するようなことがあれば、そのオブジェクトが変更される際にコンストラク タも変更しなくてはならなくなる恐れがあります。 他のオブジェクトをただインス タンス化するだけであったとしても、 それは複雑さをはらんでいるのです。

もちろんすべてのインスタンスがファクトリにより生成されるべきと主張してい るわけではありません。 生成処理が複雑でないのであれば素直にコンストラクタを 呼び出す方が好ましいです。 ここでの主張は 「ただ漫然とインスタンス化をするの ではなく、 ファクトリを導入すべきか検討する習慣を身に着けるべきである」とい うものです。

220

COLUMN

ドメイン設計を完成させるために必要な要素

ファクトリはドメインを由来とするオブジェクトではありません。 その点につい てはリポジトリもまた同様です。 であればファクトリやリポジトリはドメインとは 関係ないものであるかというと、それもまた違います。

オブジェクトの生成はドメイン由来ではありませんが、 ドメインを表現するため に必要なことです。 ドメインを表現する手助けをするファクトリやリポジトリと いった要素は、ドメインの設計を構成する要素です。

ドメインをモデルへ落とし込み、 コードでそれを表現するというドメイン設計を 完成させるために、 ドメインモデルを表現する以外の要素が存在することを認識し ておいてください。

DDD 9.5

まとめ

本章では採番処理に焦点を絞ってファクトリの有用性を解説しました。 ファクト リはオブジェクトのライフサイクルの始まりでその役割を果たします。

複雑な処理を伴うオブジェクトの生成にファクトリを使用することでコードの論 点が明確になります。 同時に、まったく同じ生成処理がそこかしこに記述されるこ とを防ぐことができます。

ファクトリによって生成処理をカプセル化することはロジックの意図を明確にし ながら、柔軟性を確保する大切なことです。

221

L



Chapter 10

データの整合性を保つ

システムにはデータの整合性を保つことが求められます。

データの整合性を保つための施策はソフトウェア開 発における重大なテーマです。

一般的に整合性を保つために利用されるのはトラン ザクションです。 本章はトランザクションをどのように

して取り扱うかを主軸に解説します。 ドメイン駆動設計に限った話ではありませんがトラン ザクションは、ソフトウェアシステムを形作る上で必 ず必要となるものです。 トランザクションの取り回し 方にどのような形があるのかをここで確認しておきま しょう。

11

12

13

10

14

9

15

8

DDD 10.1

整合性とは

システムにはデータの整合性を求められる処理が存在します。 整合性とは 「矛盾 がなく一貫性のあることズレがないこと」をいいます。

たとえば商品を注文するときの注文明細を例に考えてみましょう。 注文明細は ヘッダ部とボディ部に分かれ、 ヘッダ部には注文者の名前や住所などの情報が記載 され、ボディ部には注文した商品やその数の情報が記載されています (図10.1)。

ヘッダ部 会員番号 0000001 名前 Foo 住所 Tokyo 品番 製品名 数量 単価 合計 ボディ部 A-001-1 A Components B-001-1 B Components 10 100JPY 1,000JPY 20 150JPY 3,000 JPY

図 10.1 完全な注文明細

このとき、ヘッダ部かボディ部のどちらかが欠けても注文書は成り立ちません。 ヘッダ部がない注文明細は誰に商品を届ければよいかわかりませんし、 ボディ部が 存在しない注文明細は届ける先がわかったとしても何を届ければよいかわかりませ ん (図 10.2)。 注文明細のヘッダ部とボディ部には常に互いが存在する一貫性、 す なわち整合性が必要です。

品番 製品名 数量 単価 合計 A-001-1 A Components 10 100JPY 1,000JPY B-001-1 B Components 20 150JPY 3,000 JPY ?

図10.2 ボディ部だけの注文明細

224

もちろんプログラムが正常に動作している限りは、ヘッダ部かボディ部のどちら かが欠けるような事態に陥ることはありません。 問題が発生するのはプログラムが 不正終了してしまったときです。 たとえば注文明細を作成する過程で、 ヘッダ部を 保存した直後にプログラムが終了してしまった場合、 ボディ部が保存されず、 デー タストアにはヘッダ部だけが存在するという不正なデータが残ることになってしま います。

本章ではこういった問題を防ぐため、データの整合性を担保する方法について解 説をします。 なお、 本章が取り扱う整合性はドメイン駆動設計に直接関係するもの ではありません。 しかし、 データの整合性を保つことはソフトウェアを構築する上 で必ず必要となることです。 ソフトウェアを構築する上で避けてとおれない整合性 への立ち向かい方を確認しておきましょう。

DDD 10.2

致命的な不具合を確認する

これまで作ってきたソフトウェアには実は致命的な不具合があるとお伝えしたら 皆さんは驚くでしょうか。 残念ながら User ApplicationService には整合性を破綻 させる可能性を秘めた問題が存在しているのです。

致命的な不具合はユーザ登録処理に潜んでいます。 ユーザ登録処理のコードを改 めて確認してみましょう (リスト10.1)。

リスト 10.1: ユーザ登録処理のコード

public class UserApplicationService

(

private readonly IUserFactory userFactory;

private readonly IUserRepository userRepository;

private readonly UserService userService;

(-----)

public void Register (UserRegister Command command)

{

12 致命的な不具合を確認する

225

10

var userName = new UserName (command.Name); var user = userFactory.Create (userName);

if (userService.Exists(user))

{

throw new CanNotRegister UserException (user, →

ユーザは既に存在しています。 ");

}

userRepository.Save (user);

}

ユーザ登録処理には 「ユーザ名が重複することを許可しない」 という重大なルー ルがあります。 一見すると現在のコードはこのルールを守っているように見えま す。 しかし、ある特定の条件下ではそれが意図したとおりに機能しなくなります。

ある利用者がユーザを登録しようとしたときを仮定しましょう。 登録しようとし たユーザ名は "naruse" です。 最初の段階では "naruse" というユーザが存在しない ので、この処理は正しく動作します (図10.3)。

利用者A Register (“naruse") UserApplication Service User ID:1 Name: naruse

図 10.3 登録に成功

}

さて、ときを同じくして別の利用者がユーザ登録をします。 なんという偶然で しょう。 この利用者が登録しようとしているユーザ名は "naruse" です (図 10.4)。

226

最初の利用者がユーザ登録処理を実行したとき、 重複チェックを行ってからイン スタンスの永続化処理をリポジトリに依頼します。 この永続化を処理している最中 にもう一方のユーザ登録処理が重複チェックに差し掛かると、 まだ永続化処理が完 了していないために同名のユーザが見つからず、あろうことか重複チェックをすり 抜けてしまいます。 結果として "naruse"というユーザ名のユーザが複数登録され てしまうのです。

利用者A Register (“naruse”) UserApplicationService Register (“naruse") User User ID:1 ID: 2 Name: naruse Name: naruse 利用者B

図10.4: ユーザ名が重複してしまう

この現象を整理しましょう。 図10.5は時間軸を添えてこの問題が発生するメカ ニズムを示しています。

ユーザA ユーザA登録処理 データストア ユーザB登録処理 ユーザB "naruse"で登録 "naruse"で重複確認 OK 登錄完了 "naruse" を永続化 OK "naruse"で登録 "naruse"で重複確認 OK "naruse"を永続化 OK 重複チェックをすり抜け同一の ユーザ名で登録されてしまう ユーザAが naruse を登録しよ うとしてい るのにOK を返す 登錄完了

図 10.5 問題が発生する流れ

以上が致命的な不具合の内容です。

利用者が行儀よく順番に処理を実行してくれるのであれば問題ありませんが、 Webアプリケーションでそれを強いるのは難しいでしょう。 データの整合性を保 つために何かしらの戦略を練る必要があります。

10.3 ユニークキー制約による防衛 DDD

アプリケーション全体でユーザ名が重複しないように、 データの整合性を保つた めに取れる手段として、 ユニークキー制約が挙げられます。

ユニークキー制約はデータベースの特定のカラムがユニーク、 つまり唯一無二の ものであることを保証する機能です。 もしもユニークキー制約に違反するレコード の挿入を行おうとすると、エラーが発生します。

これはとても便利な機能です。 データの整合性を守るために積極的に利用すべき 機能です。

10.3.1 ユニークキー制約を重複確認の主体としたときの問題点

ユニークキー制約の利用はソフトウェアが破綻する危険性を排除する有力な方法 です。 しかし、使い方を誤るとコードの表現力が奪われます。 具体例を確認してみ ましょう。

ユニークキー制約さえ設定すれば、 プログラムが不正を感知し、 終了するため重 複確認をする必要がなくなります。 したがって、 ユーザ登録処理のコードをリスト 10.2 のように簡略化するアイデアが浮かびます。

リスト10.2: ユニークキー制約で重複しないことが担保され重複確認が不要になる

public class UserApplicationService

{

private readonly IUserFactory userFactory;

private readonly IUserRepository userRepository;

10

228

性を保つ

(･･･略･･･)

public void Register (User Register Command command) { var userName = new UserName (command.Name); var user = userFactory.Create (userName); } } userRepository.Save (user);

このコードはユニークキー制約によってユーザ名が重複しないことは保証されて います。 結果だけ見ればリスト10.2はデータの整合性を守るコードになっていま す。 リスト10.1 と比べてみればコードも短くなりました。 これは理解しやすいコー ドに違いありません!・ ・・・と考えたのであれば危険信号です。

ユーザの重複を確認する処理は重要なものです。 リスト10.2を見て、ユーザには

重複に関するルールがあることを読み取れるでしょうか。 いかに熟練した開発者で あっても、コードの背後にある仕組みをコードから感じ取ることは不可能です。 もうひとつ問題があります。 それはデータベースのユニークキー制約という特定 の技術基盤に依存している点です。

第7章 「柔軟性をもたらす依存関係のコントロール」でビジネスロジックが特定 の技術基盤に依存をするのは避けたいということを解説してきました。 重複しない ことを担保する方法としてリレーショナルデータベースのユニークキー制約に頼る のは、まさに特定の技術基盤に依存することを意味します。 リスト10.2はドメイン の重大なルールに関わる処理が本来記述されるべき場所以外に漏れ出してしまって いる状態にあります。

これが引き起こす問題はどのようなものでしょうか。 たとえば、重複のルールが 変わるときのことを思い浮かべてみましょう。 いまはユーザ名が直接の重複のルー ルですが、それがメールアドレスに変わったときのことを想像してください。 果た してリスト10.2のコードから、開発者はリレーショナルデータベースのテーブル の制約を変更しなくてはいけないということに気づけるでしょうか。

22

10.3.2 ユニークキー制約との付き合い方

ドメインのルールを守るための具体的な方法としてユニークキー制約に頼ること は得策とは言えません。 ではユニークキー制約はまったく使えないものなのか、と いうとそれも間違いです。

古今東西、 バグの多くは開発者の思い違いを起因にしています。 たとえば開発者 がユーザの重複に関するルールを間違えて覚えていて、 重複チェックの対象をメー ルアドレスにしたとしましょう (リスト10.3)。

リスト10.3 重複チェックの対象をメールアドレスにしてしまった

public class UserService

{

private readonly IUserRepository userRepository;

(･･････)

public bool Exists (User user)

var duplicatedUser = userRepository. Find (user.Mail);

return duplicatedUser != null;

}

}

このときユニークキー制約がユーザ名カラムに設定されていれば、 ユーザ名が重 複したときにプログラムは例外を発生させて終了してくれます。 これはシステムを 強力に保護する大いなる力です。

ユニークキー制約はルールを守る主体ではなく、 セーフティネットとして活用さ れるべき機能です。 ユニークキー制約があるからといってリスト10.2のように重 複の確認を省くことはお勧めできません。

よりソフトウェアの安全性を高めるために、 リスト10.1のコードとユニーク キー制約を併用するとよいでしょう。

{

230

DDD

10.4

トランザクションによる防衛

データの整合性を保つために利用される一般的な手段としては、 データベースの トランザクション機能が挙げられます。 トランザクションは一貫した状態を保つた めに、 相互依存的な操作の完了ないし取消を保証します。

たとえばEC (Electric Commerce: 電子商取引) サイトで利用者がポイントを 利用して商品を購入するときの処理を考えてみましょう。 システムはまず利用者が 使用しようとしたポイントを減らします。 次に注文された商品の在庫を減らそうと します。このとき、注文しようとしていた商品の在庫がなくなっていたとしたら処 理は失敗します。 結果として利用者のポイントが減りますが、 注文はなされず、 商 品の発送はされません。 おそらく近い将来カスタマーセンターにはクレームが送ら れてくるでしょう。

トランザクションはこれを解決します。 トランザクションを利用しているとき、 データベースに対する一連の操作は実際には反映されません。 処理内容を反映させ るにはコミット処理を行う必要があります。

たとえばECサイトにおけるポイント消費にあてはめてみると、 トランザクショ ンを利用した場合は利用者のポイントを即時に減らすようなことはしません。 その ため、 もし途中でプログラムが不正終了したとしても利用者が保有しているポイン

購入者 商品購入处理 ポイントを利用して商品購入リクエスト 在庫を確認する OK ポイント残高を減らす OK コミットするまでデータ 処理は確定されない 請入成功 在庫を減らす OK コミットする OK データベース

10.6: コミットによる反映

QA 4

23

トは減りません。 実際にポイントが減るタイミングは処理を反映するコミット操作 が実行されたときです (図10.6)。

10.4.1 トランザクションを取り扱うパターン

トランザクションを利用すればユーザ登録処理の問題は解決しそうです。 さっそ くコードに組み込んでみましょう。 トランザクションを扱うにはデータベースコネ クションを使いまわす必要があります。 リポジトリはデータベースコネクションを 受け取って、 それを扱うように変化します (リスト10.4)。

リスト10.4 トランザクションが開始されたコネクションを利用する

public class UserRepository: IUserRepository

// 引き渡されたデータベースのコネクション

private readonly SqlConnection connection;

public UserRepository (SqlConnection connection)

this.connection = connection;

{

}

public void Save (User user, SqlTransaction transaction = null)

using (var command = connection.CreateCommand())

{

if (transaction != null)

command.Transaction = transaction;

USING (

{

command.CommandText = @"

MERGE INTO users

}

SELECT @id AS id, @name AS name

) AS data

{

ON users.id = data.id

{

232

WHEN MATCHED THEN

UPDATE SET name = data.name

WHEN NOT MATCHED THEN

INSERT (id, name)

VALUES (data.id, data.name);

command.Parameters.Add(new SqlParameter("@id",

user.Id.Value));

command.Parameters.Add(new SqlParameter("@name",

user. Name.Value));

command.ExecuteNonQuery();

}

}

(…略…)

トランザクションの開始やコミット処理を制御するためにUser Application Service も同様に SqlConnection を受け取るようになります(リスト10.5)。

リスト10.5 コンストラクタでトランザクションを受け取る

public class UserApplicationService

// このコネクションはリポジトリが保持しているものと同じもの

private readonly SqlConnection connection;

private readonly UserService userService;

private readonly IUserFactory userFactory;

private readonly IUserRepository userRepository;

public UserApplicationService (SqlConnection connection, ➡

UserService userService, IUserFactory userFactory,

}

{

IUserRepository userRepository)

23

14 トランザクションによる防

10

トは減りません。 実際にポイントが減るタイミングは処理を反映するコミット操作 が実行されたときです (図10.6)。

10.4.1 トランザクションを取り扱うパターン

トランザクションを利用すればユーザ登録処理の問題は解決しそうです。 さっそ くコードに組み込んでみましょう。 トランザクションを扱うにはデータベースコネ クションを使いまわす必要があります。 リポジトリはデータベースコネクションを 受け取って、 それを扱うように変化します (リスト10.4)。

リスト10.4 トランザクションが開始されたコネクションを利用する

public class UserRepository: IUserRepository {

// 引き渡されたデータベースのコネクション

private readonly SqlConnection connection;

public UserRepository (SqlConnection connection)

{

this.connection = connection;

}

public void Save (User user, SqlTransaction transaction = null)

using (var command = connection.CreateCommand())

{

if (transaction != null)

{

command.Transaction = transaction;

}

command.CommandText = @"

MERGE INTO users

USING (

{

SELECT @id AS id, @name AS name

) AS data

ON users.id = data.id

232

WHEN MATCHED THEN

UPDATE SET name = data.name

WHEN NOT MATCHED THEN

INSERT (id, name)

VALUES (data.id, data.name);

command.Parameters.Add(new SqlParameter("@id",

user.Id.Value));

command.Parameters.Add(new SqlParameter("@name", ➡

user. Name.Value));

command.ExecuteNonQuery();

}

}

(…略…)

トランザクションの開始やコミット処理を制御するために UserApplication Service も同様にSqlConnection を受け取るようになります (リスト10.5)。

}

リスト10.5 コンストラクタでトランザクションを受け取る

public class UserApplicationService ( // このコネクションはリポジトリが保持しているものと同じもの private readonly SqlConnection connection; private readonly UserService userService; private readonly IUserFactory userFactory; private readonly IUserRepository userRepository; public UserApplication Service (SqlConnection connection, ➡ UserService userService, IUserFactory userFactory, → IUserRepository userRepository)

{

this.connection = connection;

this.userService = userService;

this.userFactory = userFactory;

this.userRepository = userRepository;

}

(･･･略･･･)

さぁ、準備が整いました。 ユーザ登録処理でトランザクションを開始し、 整合性 を保つように処理を書き換えてみましょう (リスト10.6)。

}

リスト10.6 トランザクションを利用するようにユーザ登録処理を書き換える

public class UserApplication Service {

private readonly SqlConnection connection;

private readonly UserService userService;

private readonly IUserFactory userFactory;

private readonly IUserRepository userRepository;

(…略…)

public void Register (User Register Command command)

{

// コネクションからトランザクションを開始

using (var transaction =

{

connection. Begin Transaction())

var userName = new UserName (command. Name);

var user = userFactory.Create(userName);

if (userService.Exists (user))

{

throw new Can Not RegisterUserException (user, ➡

ユーザは既に存在しています。");

}

userRepository.Save (user, transaction);

// 完了時にコミットを行う

transaction.Commit();

}

(･･･略･･･)

リスト10.6はトランザクションにより整合性が担保されます。 もしも同時に同 じユーザ名でユーザ登録が実行されたとしても、いずれかの処理は成功し、 もう一 方の処理は失敗するでしょう。

}

しかしながら、新たな問題も発生しています。 その問題とは SqlConnection とい うインフラストラクチャのオブジェクトに対する依存がUserApplicationService に発生してしまっていることです。

SqlConnection はリレーショナルデータベースに基づくオブジェクトです。 UserApplicationService がリレーショナルデータベースを取り扱っている限りは 違和感がありませんが、 たとえばIUserRepositoryの実体は InMemory User Repository であることもあります。 その場合にはリレーショナルデータベースを 操作するオブジェクトであるSqlConnection は有効に活用されません。

これまで幾度となく特定の技術に依存することに対する危険性を訴えてきまし た。ここにきてそれを致し方ない犠牲として諦めるわけにはいきません。 整合性を 保ちながら特定の技術基盤に依存せずに済むパターンをいくつか紹介します。

10.4.2 トランザクションスコープを利用したパターン

整合性を保つトランザクション処理はそもそもデータベースに限ったことではあ りません。

確かに整合性を維持するのは低次元な詳細である特定の技術基盤の役目です。 し かし、ビジネスロジックの都合で考えると整合性を維持する具体的な実装がデータ

}

235

ベースのトランザクションであるか、それとも分散トランザクションであるかは大 きな問題ではありません。 そもそも整合性は特定の技術基盤に根差す低次元な概念 ではなく、 高次元な概念なのです。 したがって、 ビジネスロジックに記載されるべ きは整合性を保つためのあれやこれやといった詳細な処理ではなく、 整合性が必要 とされる処理であることを明示的に主張することです。

C#には整合性が必要とされる処理であるということを主張するためにトランザ クションスコープという機能が用意されています (リスト10.7)。

リスト 10.7: トランザクションスコープを利用する

public class UserApplicationService

{

private readonly UserService userService;

private readonly IUserFactory userFactory;

private readonly IUserRepository userRepository;

public UserApplication Service (UserService

userService, IUserFactory userFactory, IUserRepository userRepository)

this.userService = userService;

this.userFactory = userFactory;

this.userRepository = userRepository;

}

{

public void Register (User Register Command command)

// トランザクションスコープを生成する

// using句のスコープ内でコネクションが開かれると自動的にトランザクションが→

開始される

using (var transaction = new TransactionScope())

{

{

var userName = new UserName (command.Name);

var user = userFactory. Create(userName);

if (userService.Exists(user))

236

{

throw new Can Not RegisterUserException (user, ➡

"ユーザは既に存在しています。 ");

}

userRepository.Save (user);

// 処理を反映する際にはコミット処理を行う

transaction.Complete ();

(･･･略･･･)

}

おそらく読者の中には 「C#以外の言語を使っている場合はどうすればよいのか」 といった当然の疑問をもった方もいるでしょう。 安心してください。 たとえばオブ ジェクト指向プログラミング言語としてメジャーなJavaでは、アスペクト指向プ ログラミング (AOP: Aspect Oriented Programming) に基づいたアプローチで 同じことを実現しています。

AOPはソースコードに変更を加えずに新たな処理を追加することを実現します。 具体例を見てみましょう。 リスト10.8のコードはUserApplicationService を

}

トランザクションスコープはあくまでもトランザクションを行う範囲を定義して います。 したがって、 実際にトランザクションを開始するような動作はしません。 ただし、このスコープの内部でデータベースのコネクションを開こうとすると、自 動的にトランザクションが開始されます。 結果的に、このスコープ内ではトランザ クションの恩恵を享受できます。

UserApplicationServiceはいま、リレーショナルデータベースという特定の技 術基盤から解放されました。 もしデータベースのトランザクション以外の技術で整 合性を担保することになったとしても、 TransactionScope がうまく動作する仕組 みを整えればそれで解決できます。 インフラストラクチャの変更を起因にUser ApplicationService を修正する必要はなくなったのです。

10.4.3 AOPを利用したパターン

237

Javaで記述したものです。

リスト 10.8 Transactional アノテーションを利用する (Javaコード) public class UserApplicationService { private final UserRepository userRepository; private final UserFactory userFactory; private final UserService userService; (------) @Transactional public void Register (User Register Command command) { UserName userName = new UserName(command.getName()); User user = userFactory.create(userName); if (userService.exists(user)) { throw new CanNotRegister UserException (user, ユーザは既に存在しています。"); } } userRepository.save(user);

@Transactionalアノテーションはトランザクションスコープと同じことを実現 します。 メソッドが正常に終了したときはコミットが実施され、 途中で例外が投げ られるとロールバックが実行されます。

}

筆者はトランザクションスコープよりもAOPを利用した、このパターンの方が 優れていると考えています。 なぜならトランザクションスコープはメソッドの処理 内容を確認しない限り、 整合性が必要とされていることに気づくことができませ ん。 アノテーションであれば、内部の詳細なコードを確認するまでもなく、そのメ ソッドで整合性が必要とされていることがわかります。

238

10.4.4 ユニットオブワークを利用したパターン

ユニットオブワークというパターンもトランザクションを取り扱うための選択肢 のひとつです。

ユニットオブワークはあるオブジェクトの変更を記録するオブジェクトです。 ユ ニットオブワークはオブジェクトの読み取り動作を行う際にインスタンスの状態を 記録します。 読み取られたオブジェクトの変更や削除はユニットオブワークに通知 しない限りデータストアへ反映されることはありません。 コミット処理が呼び出さ れると、そこまでの変更処理をデータストアに対して適用します。 このパターンを 適用すると、 永続化の対象となるオブジェクトの作成・変更・削除といった動作は すべてユニットオブワークを通じて行うようになります。

ユニットオブワークはリスト10.9に示す定義をもったオブジェクトです。

リスト10.9 ユニットオブワークの定義

public class UnitOfWork { public void Register New (object value); public void RegisterDirty (object value); public void Register Clean (object value); public void RegisterDeleted (object value); public void Commit(); }

リスト10.9のRegister から始まるメソッドはインスタンスの状態を変更記録と して保存します。 Commit メソッドが呼び出されるとそこまでの変更をまとめて データストアに適用します。

ユニットオブワークを利用する際にはリスト10.10に示すエンティティ用の基底 クラスを用意し、マーキング手段を提供します。

リスト10.10 マーキングのための手段を提供するエンティティの基底クラス

public abstract class Entity { protected void MarkNew()

239

} UnitOfWork.Current. Register New(this);

protected void MarkClean ()

UnitOfWork.Current. Register Clean (this);

{

}

protected void MarkDirty()

{

UnitOfWork.Current. RegisterDirty(this);

}

protected void MarkDeleted()

{

UnitOfWork.Current. RegisterDeleted (this);

}

エンティティはリスト10.10を継承し、データの変更時などに適宜マーキング作 業を行います (リスト10.11)。

}

リスト10.11 データの変更時にマーキングを行う

// エンティティはリスト10.10で定義した基底クラスを継承する

public class User: Entity

public User (UserName name)

{

{

if (name == null) throw new ArgumentNullException (nameof❤ (name));

Name = name;

MarkNew();

}

240

public UserName Name { get; private set; }

public void ChangeName (UserName name)

{

if (name == null) throw new ArgumentNullException (nameof➡

(name));

Name = name;

MarkDirty();

こうして集められた変更履歴はユニットオブワークのコミット操作時にまとめて 実行されます。 ユーザ登録処理はリスト10.12のように変化します。

}

リスト10.12: ユニットオプワークを利用したユーザ登録処理

public class UserApplicationService

// ユニットオブワークを保持する

private readonly UnitOfWork uow;

private readonly UserService userService;

private readonly IUserFactory userFactory;

private readonly IUserRepository userRepository;

public UserApplication Service (UnitOfWork uow, UserService → userService, IUserFactory userFactory, IUserRepository ➡ userRepository)

{

this.uow ow;

this.userService = userService;

this.userFactory = userFactory;

this.userRepository = userRepository;

{

}

}

241

public void Register (User RegisterCommand command)

var userName = new UserName (command.Name); var user = userFactory.Create(userName);

if (userService.Exists(user))

{

throw new CanNotRegisterUserException(user);

}

userRepository.Save(user);

// 作業結果の反映をユニットオプワークに伝える

uow.Commit();

}

(･･･略･･･)

}

ユニットオブワークに対するコミット処理はサンプルのように開発者が明示的に 実行する選択肢もありますが、 処理の実行後に暗黙的に実行されるようにする選択 肢もあります。 コミット処理が多くのスクリプトで実行される可能性が高いことを 考えるとむしろ暗黙的に実行される方がよいでしょう。 その際にはAOPを適用し さて、処理の実行後にコミット処理を実施するようにします。

もう1つのユニットオブワーク

また、ユニットオブワークにリポジトリを保持させて、リポジトリ自身に変更の 追跡を行わせるパターンもあります (リスト 10.13)。 このパターンでは先述したユ ニットオブワークで必要となった基底クラスを用意する必要がありません。

{

リスト10.13: リポジトリに変更の追跡を移譲したユニットオブワーク

public class UnitOfWork : IUnitOfWork

private readonly SqlConnection connection;

private readonly SqlTransaction transaction;

private UserRepository userRepository;

public UnitOfWork (SqlConnection connection, SqlTransaction transaction)

this.connection = connection;

this.transaction = transaction;

public IUserRepository UserRepository

get => userRepository ?? (userRepository <=new->

UserRepository (connection, transaction));

public void Commit()

{

transaction.Commit();

リスト 10.14 再構築したインスタンスかどうかによって処理が分かれる

ておく

}

}

public class UserRepository: IUserRepository { // Findメソッドなどで再構築したインスタンスはクローンして保持し

{

}

ユニットオブワークは各リポジトリを公開し、 クライアントはプロパティとして 公開されているリポジトリに対してオブジェクトの永続化や再構築を依頼します。 実際の変更の追跡はリポジトリ内部にて行われます (リスト10.14)。

}

{

{

243

private readonly Dictionary<UserId, User> cloned = new → Dictionary<UserId, User>();

(･･･略･･･)

public User Find (UserId id) { // ユーザを取得するコード (------)

} // 取得したユーザを保存 var cloneInstance = Clone (user); cloned.Add(id, cloneInstance); return user;

private User Clone (User user) { } return new User (user.Id, user.Name);

public void Save (User user)

{

if (cloned. TryGetValue(user.Id, out var recent))

{

SaveUpdate(recent, user);

}

else

{

SaveNew(user);

}

}

244

private void Save New (User user)

{

// UPSERT処理を行う

(･･･略...)

}

private void SaveUpdate (User recent, User { } // 変化した項目に応じてUPDATE文を組み立てて実行 (･･･略･･･) }

latest)

インスタンスの生成時にインスタンスの状態を記憶しておき、 保存の際に更新の あった部分のみを更新しています。

このユニットオブワークを利用するとUserApplicationService はリスト10.15 のように変化します。

リスト10.15 リスト10.14を利用したユーザ登録処理

public class UserApplicationService

{

private readonly IUnitOfWork uow;

private readonly UserService userService;

private readonly IUserFactory userFactory;

public UserApplicationService (IUnitOfWork uow, UserService →

userService, IUserFactory userFactory)

{

this.uow wow;

this.userService = userService;

this.userFactory = userFactory:

}

245

トランザクションによる防御

public void Register (User Register Command command)

var userName = new UserName (command.Name); var user = userFactory.Create(userName);

{

if (userService.Exists(user)) { } throw new CanNot RegisterUserException(user);

} } // ユニットオブワークが保持するリポジトリに永続化を依頼 uow.UserRepository.Save (user); uow.Commit();

プロダクション用のユニットオブワークはデータベースに依存しているので、 ト ランザクションを操作すればロールバックやコミット処理を行えますが、テスト用 のユニットオブワークで整合性を維持するにはひと手間必要です (リスト10.16)。

リスト10.16: テスト用のユニットオブワーク

public class InMemoryUnitOfWork IUnitOfWork { // インメモリのリポジトリを利用している

private InMemoryUserRepository userRepository;

public IUserRepository UserRepository

get => userRepository ?? (userRepository = new →

{

InMemoryUserRepository());

}

public void Commit()

{

246

} } userRepository?. Commit();

ユニットオブワークのCommitメソッドはリポジトリに Commitメソッドを呼 び出すようにします。 InMemoryUserRepository はリスト10.17のように変化し ます。

リスト10.17 インメモリのリポジトリでコミットなどが行えるようにする

public class InMemoryUserRepository: IUserRepository {

private readonly Dictionary<string, User> creates = ➡ new Dictionary<string, User>();

private readonly Dictionary<string, User> updates = → new Dictionary<string, User>();

private readonly Dictionary<string, User> deletes = new Dictionary<string, User>();

private Dictionary<string, User> db = new Dictionary➡ <string, User>();

private Dictionary<string, User> data => db

. Except (deletes)

. Concat(creates)

. Concat (updates)

.ToDictionary (x => x.Key, x => x.Value);

public void Save (User user)

{

var rawUserId = user.Id.Value;

var targetMap = data.ContainsKey(rawUserId) ? updates : ➡ creates;

targetMap[rawUserId] = Clone (user);

}

241

public void Remove (User user)

deletes [user.Name.Value] = Clone (user);

}

public void Commit()

{

db = data;

creates.Clear();

updates.Clear();

deletes.Clear();

}

(…略…)

}

リスト10.17のコードはテスト用のすべてのリポジトリに必要となるコードです ので、 ジェネリクスを使ったスーパークラスを実装して共通化を図ってもよいで しょう (リスト 10.18)。

リスト10.18: リスト10.17のコードを共通化する

public abstract class InMemory Repository<TKey, TEntity> where TKey IEquatable<TKey>

protected readonly Dictionary<TKey, TEntity> creates = ->

{

new Dictionary<TKey, TEntity>();

{

protected readonly Dictionary<TKey, TEntity> updates = new Dictionary<TKey, TEntity>();

protected readonly Dictionary<TKey, TEntity> deletes = -> new Dictionary<TKey, TEntity>();

protected Dictionary<TKey, TEntity> db = new Dictionary➡ <TKey, TEntity>();

248

protected Dictionary<TKey, TEntity> data => db

. Except (deletes)

. Concat (creates)

. Concat (updates)

.ToDictionary (x => x.Key, x => x.Value);

public void Save (TEntity entity)

var id = GetId(entity);

var targetMap = data.ContainsKey(id) ? updates creates; targetMap[id] = Clone (entity);

}

public void Remove (TEntity entity)

var id = GetId(entity);

{

deletes [id] = Clone (entity);

{

updates.Clear();

protected abstract TKey GetId(TEntity entity);

protected abstract TEntity Clone (TEntity entity);

}

}

public void Commit()

db = data;

creates.Clear();

deletes.Clear();

}

ところでこのユニットオブワークですが、 皆さんの中には既視感を感じる方もい るのではないでしょうか。

そうです。 C#の Entity Framework はまさにこのユニットオプワークの実装です。

{

249

COLUMN

結局どれを使うべきか

本文ではトランザクションを取りまわすいくつかのパターンを紹介しました。 多 くの選択肢は迷いを生みます。 どれを使うべきか迷いが生まれたことでしょう。そ こで参考として筆者の選択についてお話しておきましょう。

筆者は宣言的に記述できるトランザクションスコープを利用します。 トランザク ションスコープはEntity Frameworkと併用することも可能です。

C#以外ではAOPを利用します。 Java のTransactional アノテーションに相当す る機能がなかった場合は、 それに準ずる仕組みを用意します。

10.4.5 トランザクションが引き起こすロックについて

データベースのトランザクションは一貫性を保証するためにデータをロックしま す。 トランザクションを利用するにあたって、 どれほどロックされるかは常に念頭 に置く必要があります。

トランザクションが引き起こすロックは可能な限り小さくすべきです。 ロックが 広範囲に渡ると、それに比例するように処理が失敗する可能性が高まります。

ロックを狭める1つの指針として挙げられるのは、一度のトランザクションで保 存するオブジェクトを1つに限定し、さらにそのオブジェクトをなるべく小さくす ることです。

DDD 10.5

まとめ

本章ではデータの整合性を保つためのトランザクションを制御する方法について 学びました。

選択肢はいくつかあります。 今回紹介した方法はどれも目的を達成することはで きます。 もし紹介した方法が提供されていなくても、それぞれがどのようなもので あるかを知っておけば、自作することも可能です。 どの方法が現在のプロダクトに 最適なのかを考えて採用すべきものを選びましょう。

次の章ではこれまでの理解を深める復習のために新しい機能を作っていきます。

250

Chapter 11

アプリケーションを

1から組み立てる

理解を深めるためにアプリケーションを最初から組み 立てる過程を確認します。

ここまでドメイン駆動設計に登場する多くのパターン とソフトウェアとして成り立たせるために必要な要素 の解説をしてきました。 最初はその数に圧倒されたと しても、ひとつひとつ紐解いていくことで、その意味 や意図を掴み取ることができたのではないでしょう か。

ものごとを会得するためにはまず把握をし、そしてそ れを反復することが大事です。 理解をより深いものへ と変化させるために、この章ではこれまでのパターン を使って実装の練習をしてみましょう。

12

13

11

14

10

15

9

APP

7

DDD アプリケーションを 111 組み立てるフロー

この章ではこれまで登場した要素を使って、 新たな機能をアプリケーションに追 加します。 ここでは実践的な手順に沿って進めていきます。 実装を始める前にどう いった手順で進めるのか俯瞰しておきましょう。

まず最初に確認することは、どういった機能が求められているかです。 そもそも 求められているものを確認しないことには何も始められません。 要求にしたがって 必要な機能を考えます。

追加する機能が定まったら、 今度はその機能を成り立たせるために必要となる ユースケースを洗い出します。 機能を実現しようとしたとき単一のユースケースだ けでは無理であることも多く、いくつかのユースケースを必要とすることもありま す。

ユースケースが揃ったらそれらを実現するにあたって、必要となる概念とそこに 存在するルールからアプリケーションが必要とする知識を選び出し、 ドメインオブ ジェクトを準備します。

そして、ドメインオブジェクトを用いてユースケースを実現するアプリケーショ ンサービスを実装していきます。

この手順が唯一のものではありませんが、 本章はこの手順にしたがって進めま す。

DDD 11.2 題材とする機能

これまで題材にしてきたものはSNSのユーザ機能でした。 この機能だけでは ユーザ登録をしただけでその先がありません。 そこでここではユーザ同士の交流を 促すための機能として、サークル機能を作っていきましょう。

サークルは同じ趣味をもつユーザ同士で交流するために作成されるグループで す。 作成されるグループはたとえばスポーツを行うためのグループであったり、 ボードゲームで遊ぶためのグループであったりと、 多岐に渡ります。 サークルを別 の言葉で表すなら、クラブやギルド、 あるいはチームといった表現があるでしょう。

ンを1

13

11

252

11.2.1 サークル機能の分析

サークル機能を実現するにあたって必要とされるユースケースは「サークルの作 成」と「サークルへの参加」 です (図11.1)。

サークルを作成する サークルに参加する

図11.1: サークル機能のユースケース

「サークルからの脱退」 や 「サークルの削除」 といったユースケースも考えられま すが、 本章では図11.1のユースケースを実装します。

次にサークルの前提条件を確認しておきましょう。 サークルには次のルールがあ ります。

・サークル名は3文字以上20文字以下

サークル名はすべてのサークルで重複しない

・サークルに所属するユーザの最大数はサークルのオーナーとなるユーザを含め て30名まで

これらのルールを踏まえて2つのユースケースを組み立てていきます。

DDD サークルの知識やルールを 11.3 オブジェクトとして準備する

サークルに関する知識やルールが定まったところで、 それらをコードとして表現 していきます。

まずはサークルを構成する要素です。サークルはライフサイクルがあるオブジェ

11

253

3

サークルの知識やルールをオブジェクトとして準備する

クトで、つまりエンティティです。 ライフサイクルを表現するには識別子が必要で す。 識別子は値ですので値オブジェクトとして実装します (リスト11.1)。

リスト11.1: サークルの識別子となる値オブジェクト

public class CircleId

{

public CircleId(string value)

if (value == null) throw new ArgumentNullException (nameof(→ value));

{

Value = value;

}

public string Value { get; }

}

またサークルには名前を付けることができます。 サークルの名前を表す値オブ ジェクトも用意します。 サークル名に存在するルールにしたがい異常値を検知した ら例外を送出するようにします (リスト11.2)。

リスト11.2 サークルの名前を表す値オブジェクト

public class CircleName: IEquatable <CircleName>

public CircleName (string value )

if (value == null) throw new ArgumentNullException (nameof(→ value));

if (value.Length <3) throw new ArgumentException("サークル→ 名は3文字以上です。", nameof (value));

if (value.Length > 20) throw new ArgumentException ("サークル→ 名は20文字以下です。", nameof (value));

{

Value = value;

{

254

}

public string Value { get; }

public bool Equals (CircleName other)

{ } if (ReferenceEquals (null, other)) return false; if (ReferenceEquals(this, other)) return true; return string.Equals (Value, other.Value);

public override bool Equals(object obj)

if (ReferenceEquals (null, obj)) return false;

if (ReferenceEquals (this, obj)) return true;

if (obj.GetType() != this.GetType()) return false;

return Equals ((CircleName) obj);

}

public override int GetHashCode()

{

return (Value != null? Value.GetHashCode(): 0);

}

}

サークル名クラスには「サークル名は3文字以上20文字以下」というルールが記 述されています。 また 「サークル名はすべてのサークルで重複しない」 というルー ルに対応するため、 サークル名同士を比較するふるまいが定義されています。

これらの値オブジェクトを利用してライフサイクルをもったオブジェクトである サークルエンティティを用意します (リスト11.3)。

{

255

リスト11.3 サークルを表すエンティティ

public class Circle

{

public Circle (CircleId id, CircleName name, User owner, List<User> members)

{

if (id == null) throw new ArgumentNullException➡ (nameof(id));

if (name == null) throw new ArgumentNullException➡ (nameof (name));

if (owner == null) throw new ArgumentNullException➡ (nameof (owner));

if (members == null) throw new ArgumentNullException➡ (nameof(members));

Id = id;

Name = name;

Owner = owner;

Members members;

}

} public CircleId Id { get; } public CircleName Name { get; private set; } public User Owner { get; private set; } public List<User> Members { get; private set; }

サークルにはサークルのオーナーになるユーザを表す Owner と所属している ユーザの一覧を表す Members が定義されています。

次にサークルの永続化を行うために必要となるリポジトリも用意します (リスト 11.4).

256

リスト11.4 サークルのリポジトリ

public interface ICircle Repository { void Save(Circle circle); Circle Find (CircleId id); Circle Find (CircleName name); }

ユースケースのロジックを組み立てる分には、このリポジトリを実装したクラス を定義することはまだ不要です。 まずはロジックを組み立てることに集中します。 サークルを生成するファクトリも同じように準備します (リスト11.5)。

リスト11.5 サークルのファクトリ

public interface ICircleFactory { Circle Create (CircleName name, User owner}

);

またサークルはユーザ名が重複していないかを確認する必要があります。 重複に 関するふるまいをリスト11.3のCircle クラスに定義すると違和感が生じます。 こ れまでサンプルにしてきたユーザと同様に、重複を確認するふるまいをドメイン サービスとして定義しましょう (リスト11.6)。

リスト11.6 サークルの重複確認を行うドメインサービス

public class CircleService

{

private readonly ICircle Repository

circle Repository;

public CircleService (ICircle Repository circle Repository)

{

this.circleRepository = circleRepository;

}

public bool Exists (Circle circle)

257

13 サークルの知識やルールをオブジェクトとして準備する

11

{

var duplicated = circleRepository. Find (circle.Name);

return duplicated != null;

}

以上で値オブジェクトからドメインサービスまでひととおりのオブジェクトを用 意が終わり、 必要最低限の準備は整いました。 これらを取りまとめてユースケース を実現していきます。

DDD ユースケースを組み立てる 11.4

いよいよユースケースを組み立てていきましょう。 最初はサークルを作成理を実装していきます。

まずはコマンドオブジェクトを準備します (リスト11.7)。

する処

リスト11.7 サークル作成処理のコマンドオブジェクト

public class CircleCreateCommand

{

public CircleCreateCommand(string userId, string name)

{

UserId = userId;

Name = name;

}

public string UserId { get; }

public string Name { get; }

クライアントではこのコマンドオブジェクトを使ってサークルを作成するユーザ (サークルのオーナー)のIDと作成しようとしているサークルの名前を指定します。

}

}

を1から組み立てる

11

258

す。 リスト11.7を受け取って実際に処理を行うサークル作成処理はリスト11.8で

リスト11.8 アプリケーションサービスにサークル作成処理を追加する

public class CircleApplicationService

{

private readonly ICircleFactory circleFactory;

private readonly ICircle Repository circle Repository;

private readonly CircleService circleService;

private readonly IUserRepository userRepository;

public CircleApplication Service(

ICircleFactory circleFactory,

ICircle Repository circle Repository,

CircleService circleService,

IUserRepository userRepository)

this.circleFactory = circleFactory;

this.circleRepository = circle Repository;

this.circleService = circleService;

this.userRepository =

userRepository;

}

public void Create (CircleCreateCommand command)

{ using (var transaction = new TransactionScope()) { var ownerId = new UserId(command.UserId); var owner = userRepository. Find (ownerId); if (owner == null) { throw new UserNotFoundException (ownerId, ➡ "サークルのオーナーとなるユーザが見つかりませんでした。");

}

259

{

var name = new CircleName (command.Name);

var circle = circleFactory.Create(name, owner);

if (circleService.Exists(circle))

{

throw new CanNotRegister CircleException (circle, ➡ "サークルは既に存在しています。");

}

circleRepository.Save(circle);

transaction.Complete();

}

}

}

サークルを作成するためにまず最初にサークルのオーナーとなるユーザを検索し ています。 ユーザの存在を確認できたらサークルを生成し、 重複確認を行っていま す。 重複しないことの確認が取れたらリポジトリに永続化を依頼し、 処理は完了で す。この処理はトランザクションスコープによりデータの整合性が維持されていま す。

次に、このCircleApplicationService にユーザがサークルに参加するための処 理を追加してみましょう。 まずはコマンドオブジェクトの実装です (リスト 11.9)。

リスト11.9 サークル参加処理のコマンドオブジェクト

public class CircleJoinCommand

{

public CircleJoinCommand(string userId, string circleId)

{

UserId = userId;

CircleId = circleId;

}

ションを1から組み立てる

260

} public string UserId { get; } public string CircleId { get; }

サークルに参加するユーザのIDと参加先のサークルのIDを指定することで、ど のユーザがどのサークルに参加するかを指定します。

このオブジェクトを利用したサークル参加処理はリスト11.10です。

リスト11.10 アプリケーションサービスにサークル参加処理

public class CircleApplicationService {

(…略…)

を追加する

public void Join (CircleJoinCommand command)

using (var transaction = new TransactionScope())

var memberId = new UserId (command.UserId);

var member = userRepository. Find (memberId); if (member == null)

{

throw new UserNotFoundException (memberId, ➡ "ユーザが見つかりませんでした。");

{

}

var id new CircleId (command. CircleId); var circle = circle Repository.Find(id); if (circle == null)

{

throw new CircleNotFoundException (id, ➡ ”サークルが見つかりませんでした。 ");

}

{

261

// サークルのオーナーを含めて30名か確認 if (circle.Members.Count >= 29 ) { } throw new CircleFullException(id);

// メンバーを追加する

circle.Members.Add (member);

circleRepository.Save (circle);

transaction.Complete();

}

サークル参加処理ではサークルに参加しようとしているユーザを検索し、 参加先 のサークルを検索します。 そして 「サークルに所属するユーザの最大数はサークル のオーナーとなるユーザを含めて30名まで」というルールに適合しているかを確 認し、サークルのメンバーとしてユーザを追加しています。 トランザクションス コープにより整合性を維持するようになっているのはサークル作成処理と同様で す。

リスト11.10はユーザがサークルに参加するユースケースを実現している点では 評価できますが、違和感があります。 それは"if (circle.Members.Count) >= 29" という記述です。 ここに潜む違和感を紐解きましょう。

11.4.1 言葉との齟齬が引き起こす事態

サークルのルールである 「サークルに所属するユーザの最大数はサークルのオー ナーとなるユーザを含めて30名まで」はリスト11.10では"if (circle.Members. Count = 29" として実装されていますが、 言葉とコードで表現に齟齬が生まれ ています。 かたや30としているのに対し、もう一方では29と表現しているのです。

コード上の表現が29となっているのは、 Circle クラスの内部でオーナーとなる ユーザとメンバーにあたるユーザが別で管理されているからです(リスト11.11)。

}

ーションを1から組み立てる

262

リスト11.11 オーナーとメンバーが別管理になっている

public class Circle

(...98...)

{

} public User Owner { get; private set; } public List<User> Members { get; private set; }

本来であれば表現に即した30という数字をコード上でも用いるようにすべきです。 リスト11.10のコードでは、 Circle クラスの内情を知らない開発者が "if (circle. Members.Count) >= 29" を見て、 現在のコードが間違っていると考えて "if (circle.Members.Count) >= 30"に変えてしまうことすらありえます。 クラス内 の事情を外部に漏らすことは可能な限り避けるべきことです。

11.4.2 漏れ出したルールがもたらすもの

「サークルに所属するユーザの最大数はサークルのオーナーとなるユーザを含め て30名まで」というルールはドメインのルールとして重要なものです。 本来であれ ばこういったルールはドメインオブジェクトに実装されるべきです。 もしもそれに 反し、 ドメインの重要なルールをアプリケーションサービスに記述してしまうと、 同じルールが複数箇所に重複して記述されてしまいます。 こういった重複はコード を変更する必要に迫られたときに問題となります。

たとえば、サークルに勧誘するユースケースを追加したとしましょう (図11.2、 リスト11.12)。

サークルを作成する サークルに参加する サークルに勧誘する

図11.2: サークルに勧誘するユースケースを追加

263

14 ユースケースを組み立てる

リスト11.12: メンバー勧誘を行う処理

public class Circle ApplicationService

{

(---88---)

public void Invite (CircleInviteCommand command)

using (var transaction = new TransactionScope())

{

var fromUserId = new UserId(command. FromUserId);

var fromUser = userRepository. Find (fromUserId); if (fromUser == null)

{

throw new UserNotFoundException (from UserId, ➡ 招待元ユーザが見つかりませんでした。 "); }

var invitedUserId = new UserId(command. Invited UserId); var invitedUser = userRepository. Find (invitedUserId); if (invitedUser == null)

throw new UserNotFoundException (invited UserId, ➡ "招待先ユーザが見つかりませんでした。"); }

var circleId = new CircleId (command. CircleId); var circle = circle Repository. Find (circleId); if (circle == null)

{

throw new CircleNotFoundException (circleId, ➡ "サークルが見つかりませんでした。 ");

{

}

{

264

// サークルのオーナーを含めて30名か確認 if (circle.Members.Count >= 29) { } throw new CircleFullException (circleId);

var circleInvitation = new CircleInvitation (circle, fromUser, invitedUser);

circleInvitationRepository.Save (circleInvitation);

transaction.Complete();

}

ここでの問題はリスト11.10にも記述されていた "if (circle.Members.Count >= 29)" というルールが Inviteメソッドにも記述されていることです。

もしもサークルのメンバー数の上限数を変更することになったらどのようなこと が起きるでしょうか。 おそらく Circle オブジェクトのMembers プロパティがどの ように使われているかをすべて検索し、 それがメンバーの上限数に関する処理で あったら修正をする、 といった作業を漏れなく行う必要があります。 あるいは上限 数を表す数字 (この場合は29や30) によってコードを検索してもよいでしょう。 ただし、数字は他の意味でも利用されている可能性もあります。 検索した結果見つ けた29がサークルの人数を表す29なのか、それともまったく違う概念の29なの かを選り分ける作業は神経をすり減らすものです。

ルールがプロダクトのあちこちに点在してしまうと、ルールの変更に対する修正 箇所も散らばることになり、 修正作業の難易度は上昇していきます。 ソフトウェア の改修を任された開発者が、おおむね修正したものの一部修正漏れをしてしまい、 バグを引き起こす、 などといった話は失敗話としてありふれています。 Circle ApplicationService はまさにその危機に晒されています。

この問題の原因は本来1箇所でまとめて管理されるべきルールが複数個所に記述 されていることです。 そうなってしまった理由はどこにあるのかは実は単純です。 ルールに関わるコードがサービスに記述されてしまっていることです。 この問題を 解決するために必要な知識は集約という考え方です。

14 コースケースを組み立てる

}

265

}

DDD まとめ 11.5

この章ではひとつの機能を成り立たせるために開発する際の流れを意識しなが ら、ここまでに登場したパターンを実際に利用しました。 実際にソフトウェアを開 発する際にも、トップダウンで機能を洗い出し、 実装はボトムアップにドメインの 知識を表現するドメインオブジェクトを定義し、 ユースケースの実装に臨む流れを 汲むことは多いでしょう。

学んだことは実際に利用することで、 理論が実践へと昇華します。 テーマとなる 機能を決めて、実現するにはどういったユースケースが必要か、 登場する知識は何 かを考え、コードで実現する。 より理解を深めるために、この練習を繰り返すこと をお勧めします。

次の章では本章の最後に現れたロジックが点在してしまうといった問題を解決す るために 「集約」を解説します。 「集約」はドメイン駆動設計を構成する要素の中で は比較的難しい部類になります。 とはいえそう構える必要はありません。 オブジェ クト指向プログラミングでは当たり前のことを実践すると 「集約」の考え方になり ます。

レーションを1から組み立てる

11

266

Chapter 12 ドメインのルールを 守る「集約」

集約は変更の単位です。

データを変更するための単位として扱われるオブジェ

クトの集まりを集約といいます。 集約にはルートとなるオブジェクトが存在し、すべて の操作はルート越しに行われます。 そのようにして集 約内部への操作に制限がかけられ、 集約内の不変条 件は維持されます。 集約はデータの変更の単位であるため、 トランザク ションやロックとも密接に関係するものです。

12

DDD 12.1

集約とは

オブジェクト指向プログラミングでは複数のオブジェクトがまとめられ、ひとつ の意味をもったオブジェクトが構築されます。 こうしたオブジェクトのグループに は維持されるべき不変条件 (*1) が存在します。

不変条件は常に維持されることが求められますが、 オブジェクトのデータを変更 しようとする操作を無制限に受け入れてしまうと、 それは難しくなります。 オブ ジェクトの操作には秩序が必要です。

集約は不変条件を維持する単位として切り出され、 オブジェクトの操作に秩序を もたらします。

集約には境界とルートが存在します。 集約の境界は集約に何が含まれるのかを定 義するための境界です。 集約のルートは集約に含まれる特定のオブジェクトです。 外部からの集約に対する操作はすべて集約ルートを経由して行われます。 集約の

境界内に存在するオブジェクトを外部にさらけ出さないことで、 集約内の不変条件 を維持できるようにしているのです。

集約の定義だけを聞くと難しい概念のように思えますが、 実をいうと集約は既に 登場しています。 User や Circleといったオブジェクトは集約にあたるものです。

12.1.1 集約の基本的構造

集約は関連するオブジェク ト同士を線で囲う境界として 定義されます。 たとえばユー ザの集約を図で表すと図 12.1 になります。

<Aggregate Root> User Userid UserName

図12.1 ユーザ集約

ある処理の間、その真理値が真のまま変化しない述語のことです。

を守る「集約」

268

12

[*1]

集約の外部から境界の内部のオブジェクトを操作してはいけません。 集約を操作 するための直接のインターフェースとなるオブジェクトは集約ルート (AR: Aggregate Root) と呼ばれるオブジェクトに限定されます。 集約内部のオブジェ クトに対する変更は、集約ルートが責任をもって行うことで集約内部の不変条件を 保ちます。

たとえば図 12.1 で UserName を直接操作してよいのは集約ルートであるUser のみです。 ユーザ名の変更はUserオブジェクトに依頼をする形で変更をしなくて はいけません (リスト12.1)。

リスト12.1: ユーザ名の変更はUser オブジェクトに依頼する

var userName = new UserName ("NewName");

// NG

user.Name = userName;

// OK

user.ChangeName (userName);

いずれの操作もその結果に違いはありませんが、 Change Name といったメソッ ドを用意することで引き渡された値の確認 (nullチェックなど) を行えます。 つま

り、ユーザ名がないユーザなどの不正なデータの存在を防ぐことが可能です。

次にサークル集約についても確認しましょう。 ユーザ集約と同じように図で表す とサークル集約は図12.2になります。

サークル集約に含まれるサークル名などを操作してよいのは集約ルートである Circle です。 サークルのメンバーを追加する場合も同様で集約ルート越しに操作を する必要があります。

また図12.2にはユーザ集約が描かれています。 サークルにはユーザがメンバー として所属するため、 集約同士の関連が表現されています。 ユーザ集約はサークル 集約に含まれるものではないため、ユーザ集約の情報を変更するような操作はサー クル集約からは行いませんが、サークルにメンバーとしてユーザを追加するといっ た関連を操作する処理はサークル集約が行います。 第11章 「アプリケーションを1 から組み立てる」 ではサークルのメンバーを追加する処理をリスト12.2のように 行っていました。

269

Circleld CircleName <Aggregate Root> <Aggregate Root> Circle 0.. n User UserId UserName

図 12.2 サークル集約

リスト12.2: 第11章で登場したサークルにメンバーを追加するコード

circle.Members.Add(member);

これは集約のルールに違反しています。 サークル集約の内部に含まれる Members は集約ルートであるCircle オブジェクトが責任をもって操作すべきです。 そのた め、 本来であればリスト12.3のように Circle オブジェクトにメソッドを追加する ことが推奨されます。

リスト12.3 メンバーを追加するコードをエンティティに追加

public class Circle

{

private readonly CircleId id;

private User owner;

// メンバーは非公開にできる

private List<User> members;

(･･･略･･･)

270

public void Join (User member)

{

if (member == null) throw new ArgumentNullException (nameof(member));

if (members.Count >= 29) { } throw new Circle FullException(id); } members.Add (member);

}

Join メソッドはユーザをメンバーとして追加する際に上限チェックを行います。 members は非公開になったため、サークルのメンバーを追加する際にはJoin メ ソッドを呼び出す以外に方法がありません。 結果として、メンバーを追加する際に は常に上限チェックが行われ、 「サークルに所属するユーザの最大数はサークルの オーナーとなるユーザを含めて30名まで」という不変条件は常に維持されます。

リスト12.4 メンバー追加のためにCircleのメソッドを呼び出す

circle.Join (user);

直接プロパティに対してメンバーを追加していたときに比べて、 コードの読み方 が変化していることに気づくでしょうか。 リスト12.2は「サークルのメンバーに ユーザを追加する」 と具体的な処理を読み上げるようになるのに対し、リスト12.4 は 「サークルにユーザを所属させる」とより直感的なものになっています。

オブジェクト指向プログラミングではこのように、外部から内部のオブジェクト に対して直接操作するのではなく、 それを保持するオブジェクトに依頼する形を取 ります。 そうすることで直感的に、かつ不変条件を維持することができるのです。 このことは 「デメテルの法則」 としても知られています。

271

COLUMN

集約を保持するコレクションを図に表すか

サークル集約を正確に表現しようとして、 Userオブジェクトを保持するコレク ションの存在を図12.3のように記載しようと考えることもあります。

CircleName Circleld List<User> 0..n <Aggregate Root> Circle <Aggregate Root> User Userld UserName

図 12.3 User オブジェクトのコレクションについて言及したサークル集約

しかし、これは必ずしも正しいものではありません。 たとえば実際にコレクショ ンをもたず、 データストアから直接コレクションを生成することも可能です。 リスト12.5はあまり褒められたコードではないものの、そのことを示すサンプル です。

リスト12.5 データストアを直接操作してコレクションを生成する

public class Circle

private readonly CircleId id;

(----)

public List<User> Members

get {

using (var context = new MyDbContext())

{

{

{

circle.CircleMembers.Select(x => xCircleId);

var circle = context.Circles

Include (x => x.CircleMembers) ThenInclude(x => X.Circle)

.Single (x = x.Id == id.Value);

var memberIds = circle.CircleMembers.Select→

(x => x.UserId);

var members = context.Users.Where→

(x=> memberIds.Contains (x.Id));

return members.Select(x => new User (

new UserId(x.Id), new UserName (x.Name)) ).ToList();

}

}

}

集約を表す図はあくまでも集約の境界とそこに含まれるモデルが主題であり、 コードに対する正確性を問うものではありません。

}

12.1.2 オブジェクトの操作に関する基本的な

オブジェクト同士が無秩序にメソッドを呼び出し合うと、 不変条件を維持するこ とは難しくなります。 「デメテルの法則」はオブジェクト同士のメソッド呼び出しに 秩序をもたらすガイドラインです。

デメテルの法則によると、 メソッドを呼び出すオブジェクトは次の4つに限定さ れます。

オブジェクト自身 インスタンス変数

引数として渡されたオブジェクト ・直接インスタンス化したオブジェクト

たとえば車を運転するときタイヤに対して直接命令しないのと同じように、 オブ ジェクトのフィールドに直接命令をするのではなく、それを保持するオブジェクト に対して命令を行い、フィールドは保持しているオブジェクト自身が管理すべきだ ということです。

273

先述したリスト12.2の circle.Members.Add(member); といったコードは Circle オブジェクトのフィールド(インスタンス変数) である Members を操作し ているためデメテルの法則に違反しています。 それに比べてリスト12.4のcircle. Join (user) というコードはデメテルの法則に則っています。

法則はただただ盲目的にしたがえばそれでよいというものではありません。ルー ルには必ずそこに至る理由が存在します。 その理由まで把握してこそ本当の理解と いうものです。 デメテルの法則が解決したい問題を紐解いてみましょう。

リスト12.6は第11章で登場したサークルにメンバーを追加する際のメンバー上 限チェックを行っているコードです。

リスト12.6メンバーを追加する際の上限チェック

を行うコード

if (circle.Members.Count >= 29) { } throw new CircleFullException (id);

このコードはサークルに所属するメンバーの数が最大数を超えないように確認を していますが、 Circle オブジェクトのプロパティであるMembers を直接操作し、 Count メソッド (プロパティ) を呼び出しています。 これはデメテルの法則が提示 している 「メソッドを呼び出してよいオブジェクト」のいずれにもあてはまりませ ん。 まさにデメテルの法則に違反している例です。

このコードの問題はメンバーの最大数に関わるロジックが点在することを助長す ることです。 後続の開発者がメンバーの最大数に関わる処理を記述しようとしたと き、リスト12.6を参考にすると、 最大数を確認するロジックが随所に点在してしま うでしょう。そうしてできあがったアプリケーションにおいて、 将来サークルのメ ンバー数の上限に関わる改修をせざるを得なくなったとき、 いったい何箇所の修正 をすることになるのでしょうか。 想像するだけで背筋が凍ります。

ルールがあるべきところから漏れ出し、 随所にばらまかれることを見てみぬふり をすることは、自らの首を真綿で締めるような行為です。 その場限りの対応はいつ かだれかの苦しみに変わり、 その誰かが自分である可能性もあるのです。

デメテルの法則にしたがうとコードはリスト12.7のように変化します。

リスト12.7 デメテルの法則にしたがいオブジェクトにふるまいを追加する

public class Circle

{

12

ルールを守る「集約」

274

private readonly CircleId id;

// メンバー一覧は非公開にできる

private List<User> members;

(...8...)

public bool IsFull()

{

return members.Count >= 29;

}

public void Join (User user)

if(user == null) throw new ArgumentNullException→ (nameof(user));

{

if (IsFull()) { } throw new Circle FullException(id);

members.Add(user);

メンバー数が上限に達しているかはIsFullメソッドを通じて確認されます。 上限 チェックのコードはすべてこれに置き換わります (リスト12.8)。

リスト12.8 リスト12.7のIsFullメソッドを利用して上限チェックを行う

}

if (circle.IsFull()) { throw new Circle Full Exception(circleId); }

}

サークルに関わる上限メンバー数の知識はすべてIsFullメソッドに集約されてい

275

ます。 もし上限数が変更されるようであればリスト12.9のようにIsFullメソッドの 修正だけで完結します。

リスト12.9 上限数の変更

public class Circle

{

(------)

} public bool IsFull() { } // return members.Count >= 29; return members.Count >= 49;

このような形であればサークルのメンバー上限数はいくら変更しても構いませ ん。 ゲッターを避ける理由はまさにここにあります。 フィールドがゲッターを通じ て公開されていると、 本来オブジェクトに記述されるべきルールがいつ何時にどこ かで漏れ出すことを防げないのです。

デメテルの法則はソフトウェアのメンテナンス性を向上させ、 コードをより柔軟 なものへ導きます。 それは集約が成し遂げようとしていることと同じことでしょう。

12.1.3 内部データを隠蔽するために

オブジェクトの内部データは無暗やたらに公開すべきものではありません。 しか し、完全に非公開にしてしまうとリポジトリがインスタンスを永続化をしようとし たときに困ったことが発生します (リスト12.10)。

リスト12.10 リポジトリの永続化処理

public class EFUserRepository: IUserRepository { public void Save (User user) { // ゲッターを利用しデータの詰め替えをしている var userDataModel = new UserDataModel

を守る「集約」

12

276

{ } }; Id = user.Id. Value, Name = user.Name.Value context.Users.Add(userDataModel); context.SaveChanges(); (･･･略･･･)

}

EFUserRepository はUserのインスタンスを永続化する際、フレームワーク用 のデータモデルであるUserDataModel にデータを移し替えています。 UserData Model を生成する際にはUser クラスのIdやName を利用しているので、もしも User クラスのId や Name が非公開になってしまうと、このコードはコンパイルエ ラーになってしまいます。 この問題に対するアプローチにはどのようなものがある でしょうか。

最初にもっとも単純な一般的なアプローチとして挙げられるのがルールによる防 衛です。つまり、リポジトリ以外で無暗に集約の内部データを取得するようなコー ドを書かない (要するにゲッターを使わない)ようにするというものです。 これは チームで十分に認識が共有されていれば、もっともコストをかけることなく機能し ます。 その反面、こうした紳士協定は制限力がもっとも低いです。 開発者にそのつ もりがなくても、 誤って紳士協定を破ってしまうことは起こりえます。

もうひとつのアプローチは通知オブジェクトを使う方法です。 通知オブジェクト を利用する場合はまず専用のインターフェースを用意します (リスト12.11)。

リスト12.11 通知のためのインターフェース

public interface IUserNotification { void Id (UserId id); void Name (UserName name); }

次にこのインターフェースを実装した通知オブジェクトを実装します (リスト 12.12).

1. とは

277

リスト12.12 リスト12.11を実装した通知オブジェクト

public class User DataModelBuilder: IUserNotification

// 通知されたデータはインスタンス変数で保持される

private UserId id;

private UserName name;

public void Id (UserId id)

{

this.id = id;

}

public void Name (UserName name)

{

this.name = name;

}

// 通知されたデータからデータモデルを生成するメソッド

public UserDataModel Build()

return new UserDataModel

{

Id = id.value,

Name = name.Value

};

{

}

}

User クラスは通知オブジェクトのインターフェースを受け取り、 内部の情報を 通知するようにします (リスト12.13)。

リスト12.13: 通知オブジェクトを受け取るメソッドを追加する

public class User { // インスタンス変数はいずれも非公開

{

278

private readonly UserId id; private UserName name; (･･････) public void Notify (IUserNotification note) { } // 内部データを通知 note.Id (id); note.Name (name); }

このようにすることでオブジェクトの内部データを非公開にしたまま、 外部に対 して引き渡せます (リスト12.14)。

リスト12.14: 通知オブジェクトを利用してデータモデルを取得する

public class EFUserRepository: IUserRepository { public void Save (User user) { // 通知オブジェクトを引き渡しダブルディスパッチにより内部データを取得 var userDataModelBuilder = new UserDataModelBuilder(); user.Notify (userDataModel Builder); } // 通知された内部データからデータモデルを生成 var userDataModel = userDataModel Builder.Build(); // データモデルを0/R Mapperに引き渡す context.Users.Add(userDataModel); context.SaveChanges(); } (･･････)

11 集約とは

12

279

もちろんこの場合はコードの記述量が大幅に増えてしまうことが懸念事項です。 その懸念を払しょくするには、リスト12.11やリスト12.12のような通知オブジェ クトに関連するコードをひとまとめに生成する開発者用の補助ツールを用意すると よいでしょう。

COLUMN

よりきめ細やかなアクセス修飾子 (Scala)

内部データを操作できる対象の条件をコードで表現できれば、 開発者が不用意に 内部データに対してアクセスすることがなくなります。 たとえばScala ではリスト 12.15のように記述することで操作するための条件を指定できます。

リスト12.15 よりきめ細やかなアクセス制御 (Scala)

public class User ( private [IUserRepository] val id: UserId, private [IUserRepository] val name: UserName ) { }

この記述方法はアクセス限定子と呼ばれます。 private 修飾子が示すようにidや nameは基本的には非公開ですが、 □ で指定したオブジェクトに対してアクセスを 許可します。 リスト12.15のように指定すればIUserRepository の実装クラスだけ に公開する内部データを実現できるのです。

アクセス限定子はその機能もさることながら宣言的なところが素晴らしいです。 コードを見れば、暗にリポジトリ以外から内部データを操作すべきでないという主 張が読み取れます。 これは開発者に対して無暗に内部データを公開したり操作しな いように踏みとどまらせるヒントになるでしょう。

DDD 12. 2

集約をどう区切るか

集約をどのように区切るか、というのはとても難しいテーマです。 その方針とし てもっともメジャーなものは 「変更の単位」でしょう。 変更の単位が集約の境界を 引く理由となることを理解するためには、あえて違反してみるとわかりやすいです。

280

さっそく違反をしてみましょう。 現在、 サークル集約は図12.4のように区切ら れています)。

Circleld CircleName <Aggregate Root> Circle 0..n <Aggregate Root> User Userid UserName

図12.4 サークル集約 (図 12.2を再掲)

サークルとユーザは別の集約です。 集約は変更の単位ですので、 サークルを変更 するときはサークルの集約内部で納めるべきですし、 ユーザを変更するときはユー ザの集約内部の事柄だけを変更するべきです。 もしも集約のルールに違反をして、 サークル集約越しにユーザ集約へ変更を加えるとプログラムはどのようになってし まうでしょうか。

す。 リスト12.16 のコードはサークル集約からあえてユーザ集約の変更をしていま

リスト12.16 サークル集約を通じてユーザ集約のふるまいを呼び出す

public class Circle

private List<User> members;

(･･････)

{

public void ChangeMemberName (UserId id, UserName name)

{

281

12 集約をどう区切るか

(x => x.Id.Equals (id));

} var target = members.First0rDefault if (target != null) { } } target.ChangeName (name);

コードの良しあしはさておき、 このコードはサークルに所属するメンバーのユー ザ名を変更するコードです。 ここで問題となるのは変化による変更がここだけに収 まらないことです。 サークル集約越しにユーザ集約を操作することによる影響はリ ポジトリに現れます。

まずは変化が及ぶ前のコードを確認しておきましょう。 リスト12.17のコードは サークル集約の永続化処理です。

リスト12.17 サークル集約を永続化する処理

public class Circle Repository: ICircle Repository {

(･･･略･･･)

public void Save (Circle circle)

{

using (var command = connection.CreateCommand()) { command.CommandText = @" MERGE INTO circles USING ( SELECT @id AS id, @name AS name, @ownerId AS ownerId ) AS data ON circles.id = data.id WHEN MATCHED THEN UPDATE SET name = data.name, ownerId = data.ownerId WHEN NOT MATCHED THEN

282

INSERT (id, name, ownerId)

VALUES (data.id, data.name, data. ownerId);

command.Parameters.Add(new SqlParameter("@id", ➡

circle. Id.Value));

command.Parameters.Add(new SqlParameter("@name",

circle. Name.Value));

command.Parameters.Add(new SqlParameter("@ownerId", ➡

(object) circle. Owner?. Id. Value ?? DBNull.Value));

command.ExecuteNonQuery();

}

using (var command = connection.CreateCommand())

{

command.CommandText = @"

MERGE INTO userCircles

USING (

SELECT @userId AS userId, @circleId AS circleId ) AS data

ON userCircles.userId = data.userId AND userCircles.circleId = data.circleId

WHEN NOT MATCHED THEN

INSERT (userId, circleId)

VALUES (data.userId, data.circleId);

";

command.Parameters.Add(new SqlParameter("@circleId", ➡

circle. Id.Value));

command.Parameters.Add(new SqlParameter("@userId", ➡

null));

foreach (var member in circle. Members)

{

283

command.Parameters [ "@userId"].Value = member.Id.Value;

command.ExecuteNonQuery();

}

}

}

}

サークル集約は自身の内部データのみを変更するというルールであればこれは問 題がないコードです。 しかし、 今回のコードはユーザ集約のデータを変更していま す。 このままではサークル集約越しに操作をしたユーザ集約に対する変更が保存さ れません。 ユーザ集約に対する変更を許容する場合、 リポジトリのコードを変更す る必要があります (リスト12.18)。

リスト12.18: サークル集約越しに操作されたユーザ集約に対する変更をサポートする

public class Circle Repository: ICircle Repository

{

(･･･略･･･)

public void Save (Circle circle)

{

// ユーザ集約に対する更新処理を行う

using (var command = connection.CreateCommand())

{

command.CommandText = "UPDATE users SET username = →

@username WHERE id = @id";

command.Parameters.Add(new SqlParameter("@id", null); command.Parameters.Add(new SqlParameter("@username", null));

foreach (var user in circle. Members)

command.Parameters [ "@id"].Value = user.Id.Value;

{

command.Parameters [ "@username"].Value = user.Name.Value; command.ExecuteNonQuery();

284

}

}

// その後サークルの更新処理を行う

(･･･略...)

サークル集約越しにユーザの操作をサポートした結果、 サークルリポジトリのロ ジックの多くがユーザの更新処理に汚染されてしまいました。 同時に、 サークルリ ポジトリに追加されたコードとほとんど同じコードがユーザのリポジトリにも存在 しています。 やむを得ない場合を除けばコードの重複は可能であれば避けたいとこ ろです。

これらの問題は本来の変更の単位を超えて変更を行っているために発生していま す。 集約に対する変更はあくまでその集約自身に実施させ、 永続化の依頼も集約ご とに行われる必要があります。 ここまでリポジトリはどの単位で作るのかというこ とに言及していませんでしたが、こういった理由からリポジトリは変更の単位であ る集約ごとに用意します。

12.2.1 ID によるコンポジション

これまで何度か説いてきたように、そもそもできてしまうことを問題視する考え 方もあります。 つまり Circle オブジェクトはUserのインスタンスをコレクション で保持していて、 プロパティを経由してそのメソッドを呼び出すことが可能である ことこそが問題であると見做す考えです。

変更しないことを不文律として課すよりももっと有効な手段はないでしょうか。 もちろんあります。 それはとても単純なもので、つまりインスタンスをもたない 選択肢です。 インスタンスをもたなければメソッドを呼び出しようがありません。 インスタンスをもたないけれど、それを保持しているように見せかける、 そんな便 利なものがエンティティにありました。 そう、 識別子です。

サークル集約をユーザ集約を直接保持するのではなく、 識別子をインスタンスの 代わりとして保持するように修正してみましょう (リスト12.19)。

285

12 集をどう区切るか

リスト12.19: 識別子をインスタンスの代わりとして保持する

public class Circle

{

public CircleId Id { get; }

public CircleName Name { get; private set; }

// public List<User> Members { get; private set; }

public List<UserId> Members { get; private set; }

} (---88---)

このようにしておくことで、たとえMembers プロパティを公開していたとして もUser オブジェクトのメソッドを呼び出すことができなくなります。 あえて呼び 出したい場合はUserRepository に UserIdを引き渡してUser オブジェクトのイン スタンスを再構築し、 その上でメソッドを呼び出すことになります。 そのような手 順が必要になれば、少なくとも不意にメソッドを呼び出して変更してしまうことは ないでしょう。

また、これは同時にメモリの節約にも繋がります。 たとえばサークルの名前を変 更する処理を例にします (リスト12.20)。

リスト12.20: サークルの名前を変更する処理

public class CircleApplicationService

{

private readonly ICircle Repository circle Repository;

(･･･略･･･)

public void Update (CircleUpdateCommand command)

{

using (var transaction = new TransactionScope())

{

var id = new CircleId (command.Id);

// この時点でUserのインスタンスが再構築されるが

286

var circle = circleRepository.Find(id);

if (circle == null)

throw new CircleNotFoundException(id);

if (command. Name != null)

{

}

{

var name = new CircleName (command.Name);

circle.ChangeName (name);

if (circleService.Exists (circle))

{ throw new CanNot Register CircleException (circle, "サークルは既に存在しています。"); } } } } circleRepository.Save (circle); transaction.Complete(); // Userのインスタンスは使われることなく捨てられる

➡

}

サークルの名前を変更する処理ではユーザを操作するようなことはありません。 それゆえ、 Circle オブジェクトがサークルのメンバーをUserオブジェクトとして 保持している場合、 リポジトリがインスタンスを再構築しますが、 まったく利用さ れずに捨てられることとなります。 これは明らかにリソースの無駄遣いです。 User オブジェクトを保持する代わりにUserld を保持することで、 Userオブジェクトを 再構築するための処理能力も節約できますし、 インスタンスを保持するメモリも節 約できます。

287

COLUMN

IDのゲッターに対する是非

ここまでゲッターについては可能な限り排除すべきものとして説明してきたつも りです。 しかし、その対象が識別子であった場合は少し事情が変わってきます (リ スト12.21)。

リスト12.21: 識別子をゲッターで公開する

public class Circle

{

private CircleName name;

private UserId owner;

private List<UserId> members;

public Circle (CircleId id, CircleName name,

UserId owner, List<UserId> members)

{

if (id == null)

throw new ArgumentNullException (nameof(id));

if (name == null)

throw new ArgumentNullException (nameof (name)); if (owner == null)

throw new ArgumentNullException (nameof (owner)); if (members == null)

throw new ArgumentNullException (nameof (members));

Id = id;

this.name name;

this.owner owner;

this.members = members;

}

public CircleId Id { get; }

public void Notify (ICircle Notification note) {

note.Id (Id);

note.Name (name);

note.Owner (owner);

note.Members (members);

(･･･略･･･)

}

このCircle クラスは識別子をゲッターで公開しています。 理想論でいえばこの ゲッターも排除すべきですが、 識別子はエンティティを表現するためのシステマ チックな属性で、それ自体が集約の代わりとして扱える便利なものです。 一意な識 別子自体に関心が寄せられることはありますが (宅急便の追跡番号など)、 識別子に 対してビジネスルールが記述されることは多くありません。 そのようなときは識別 子を公開することで発生するデメリットよりも公開することのメリットの方が大き いこともあるでしょう。

DDD 12.3

集約の大きさと操作の単位

トランザクションはデータをロックします。 集約が大きくなればなるほどロック の範囲もそれに比例して大きくなります。

集約を不用意に大きくしてしまうと、それだけ処理が失敗する可能性を高めま す。

集約の大きさはなるべく小さく保つべきです。 もしも巨大な集約ができあがって しまったのであれば、それは今一度集約の境界線を見つめ直すチャンスです。

また複数の集約を同一トランザクションで操作することも可能な限り避けます。 複数の集約にまたがるトランザクションは、巨大な集約と同様に広範囲なデータ ロックを引き起こす可能性を高めます。

289

COLUMN 結果整合性

それでもなお、複数の集約をまたがるような処理を取り扱いたいときもありま す。 そういったときに利用できるのが結果整合性です。

トランザクション整合性は即時的な整合性ですが、 結果整合性はあるタイミング において矛盾が発生することを許容します。 もちろんそのままではシステムが破綻 してしまいますので、 最終的には整合性を保つような仕組みにより解決をします。

たとえば、これは極端な例ですが、 一日1回 cron (ジョブを自動実行するデーモ ンプロセス) にてユーザをすべて検査し、 もしも同じユーザ名のユーザがいたらそ のユーザの名前をランダムで重複しない文字列に変更してしまうといったような仕 組みです。 図12.5はひどく乱暴な処理ですが、 システム全体としての整合性は保 たれます。

ユーザ登録 naruse チェックプログラム ユーザ登録 naruse 重複を検知 ユーザ登録 naruse ユーザ登録 チェックプログラム XXXXXX 重複しない文字列に変更

図 12.5 結果整合性の一例

システムに必要な整合性を選り分けてみると、 即時的な整合性が求められるもの は思ったよりも少ないものです。 もしも、トランザクションによって問題が発生し た際には、 結果整合性について一考してみてもよいでしょう。

290

DDD 12.4

言葉との齟齬を消す

サークルには 「サークルに所属するユーザの最大数はサークルのオーナーとなる ユーザを含めて30名まで」という不変条件があります。 30といった具体的な数字 が出ていますが、 コードに出てくる数字は29です (リスト12.22)。

リスト 12.22:30 ではなく 29が現れている

public class Circle { private User owner; private List<User> members; (･･･略･･･) public bool IsFull() { return members.Count >= 29; } }

これはコードが間違っているわけではありません。 Circle にはサークルのメン バーを表す members とは別にサークルのオーナーのユーザが保持されており、 members とは別のフィールドで管理されているため、 リスト12.22 の IsFull メ ソッドでは30から引いて29という数値で比較をしています。

しかしながら、コードに問題はないものの、言葉との齟齬は誤解を招きます。 後 続の開発者がリスト12.22のコードを見て、 間違っているのではないかと考えるこ とも否めません。

コードは可能な限り言葉との齟齬がないようにすべきです。 そのためにもCircle にはメンバーを数えるメソッドを追加するとよいでしょう (リスト12.23)。

291

14 言葉との齟齬を消す

リスト12.23: サークルのオーナーとメンバーの定義

public class Circle { private User owner; private List<User> members; (------) public bool IsFull() { } return CountMembers () >= 30; public int CountMembers() { } return members.Count + 1;

DDD 12.5

まとめ

この章ではオブジェクトがもつ不変条件を守る境界として集約を学びました。 集約はシステマチックに定義できるものではありません。 そもそもドメインに過 巻く概念はそのほとんどが連なっているものです。 そこに境界線を引くことは簡単 なことではありません。

集約の境界線を引くことは、ドメインの概念を捉え、 そこにある不変条件を導き 出し、ドメインとシステムを両天秤にかけながら最適解を目指すような作業です。 どちらか一方によりすぎることのないバランスが取れた解を目指しましょう。

のルールを守る「集約」

2

292

Chapter 13

複雑な条件を表現する 「仕様」

仕様はオブジェクトの評価を行うオブジェクトです。

オブジェクトの評価はときに複雑な手順が必要となり ます。 こうした評価処理をオブジェクトのメソッドとし て定義すると、 オブジェクト本来の趣旨を見えづらく してしまうことがあります。

評価処理はオブジェクトに定義する以外に、 評価自体 をオブジェクトとして切り出すことが可能です。 そうし て切り出された条件に合致しているかどうかを見極め るオブジェクトが、 本章で解説する仕様です。

15

13

12

14

111

APP

9

DDD 13.1

仕様とは

オブジェクトの評価は単純なものであればメソッドとして定義されますが、 すべ ての評価が単純な処理であるとは限りません。 評価処理にはオブジェクトのメソッ ドとして定義されるには似つかわしくないものも存在します。

そういった複雑な評価の手順は、アプリケーションサービスに記述されてしまう ことが多いです。 しかしながら、 オブジェクトの評価はドメインの重要なルールで す。 サービスに記述されてしまうことは問題です。

この対策として挙げられるのが仕様です。 仕様はあるオブジェクトがある評価基 準に達しているかを判定するオブジェクトです。

まずは実際に複雑な評価を例にしながら、 仕様がどういったものかを確認してい きましょう。

13.1.1 複雑な評価処理を確認する

あるオブジェクトがある特定の条件にしたがっているかを評価する処理は、オブ ジェクトのメソッドとして定義されます。 これまで取り扱ってきたサークルを表す オブジェクトにも、まさに評価を行うメソッドがありました (リスト13.1)。

リスト13.1: 条件にしたがっているかを評価するふるまい

public class Circle { (･･･略･･･) public bool IsFull() { return CountMembers () >= 30; } }

これほど単純な条件であれば問題はありません。 しかし、 これよりも、もう少し 複雑であった場合はどうでしょうか。

る「仕様」

14

15

10

294

13

たとえばサークルの人数上限が、 所属しているユーザのタイプにより変動する ルールを考えてみましょう。

・ユーザにはプレミアムユーザと呼ばれるタイプが存在する

•サークルに所属するユーザの最大数はサークルのオーナーとなるユーザを含め て30名まで

• プレミアムユーザが10名以上所属しているサークルはメンバーの最大数が50 名に引き上げられる

Circle はサークルに所属するメンバーを保持していますが、 Userldのコレク ションを保持しているにすぎず、 プレミアムユーザが何名存在するかはユーザのリ ポジトリに問い合わせる必要があります。 しかし、 Circle はユーザのリポジトリを 保持していません。 そこで、 リポジトリを保持しているアプリケーションサービス 上で判定してみましょう (リスト 13.2)。

リスト 13.2 サークルのメンバー上限数は条件によって変更される

public class Circle ApplicationService

private readonly ICircle Repository circle Repository; private readonly IUserRepository userRepository;

(･･･略･･･)

{

public void Join (CircleJoinCommand command)

{

var circleId = new CircleId (command.CircleId); var circle = circleRepository. Find (circleId);

var users = userRepository. Find (circle.Members);

// サークルに所属しているプレミアムユーザの人数により上限が変わる

var premiumUserNumber = users.Count (user => user. IsPremium); var circleUpperLimit = premiumUserNumber < 10 7 30 : 50;

if (circle.CountMembers() >= circleUpperLimit)

295

{

throw new CircleFullException (circleId);

}

(---8---)

}

本来サークルが満員かどうかの確認はドメインのルールです。 これまで解説して きたとおり、サービスにドメインのルールに基づくロジックを記述することは避け なくてはいけません。 これを放置するとドメインオブジェクトは何も語らず、 ドメイ ンの重要なルールはサービスのあちらこちらに記述されるようになってしまいます。

ドメインのルールはドメインオブジェクトに定義するべきです。 Circle クラスの IsFullメソッドとして定義する道を考えてみましょう。 すると今度はCircle クラス がユーザ情報として識別子しか保持していないことが問題となります。 ユーザの識 別子からユーザ情報を取得するためには IsFullメソッドがリポジトリを受け取る必 要があります (リスト13.3)。

リスト13.3: エンティティがリポジトリを受け取る

}

public class Circle

{

// プレミアムユーザの人数を探したいが保持しているのはUserIdのコレクションだけ public List<UserId> Members { get; private set; }

(･･･略･･･)

// ユーザのリポジトリを受け取る?

public bool IsFull (IUserRepository userRepository)

{

var users = userRepository. Find (Members);

var premiumUserNumber = users.Count(user => user.IsPremium); var circleUpperLimit = premiumUserNumber < 10?30:50; return CountMembers() >= circleUpperLimit;

296

}

}

これはあまりよくない解決法です。 リポジトリはドメイン設計を完成させると いった意味ではドメインのオブジェクトですが、 ドメイン由来のものではありませ Circle はドメインモデルの表現に徹していません。

エンティティや値オブジェクトがドメインモデルの表現に専念するためには、リ ポジトリを操作することを可能な限り避ける必要があります。

13.1.2 「仕様」 による解決

エンティティや値オブジェクトにリポジトリを操作させないために取られる手段 は仕様と呼ばれるオブジェクトを利用した解決です。 サークルが満員かどうかを評 価する処理を仕様として切り出してみましょう (リスト13.4)。

リスト13.4: サークルが満員かどうかを評価する仕様

public class Circle FullSpecification {

private readonly IUserRepository userRepository;

public CircleFull Specification (IUserRepository userRepository)

{

this.userRepository = userRepository;

}

public bool IsSatisfied By (Circle circle)

var users = userRepository. Find (circle.Members);

var premiumUserNumber = users.Count(user = user.IsPremium);

var circleUpperLimit = premiumUserNumber < 10 7 30 : 50; return circle.CountMembers() = circleUpperLimit;

{

}

}

297

1. とは

仕様はオブジェクトの評価のみを行います。 複雑な評価手順をオブジェクトに埋 もれさせず切り出すことで、 その趣旨は明確になります。

仕様を利用したときのサークルメンバー追加処理はリスト 13.5です。

リスト13.5 仕様を利用する

public class Circle ApplicationService

{

private readonly ICircle Repository circle Repository;

private readonly IUserRepository userRepository;

(---88---)

public void Join (CircleJoin Command command)

var circleId = new CircleId (command.CircleId);

var circle = circleRepository. Find (circleId);

var circleFullSpecification = new CircleFullSpecification (➡

userRepository);

if (circleFullSpecification.IsSatisfiedBy(circle))

{

throw new CircleFullException (circleId);

}

(･･･略･･･)

}

}

複雑な評価手順はカプセル化され、 コードの意図は明確になっています。

■趣旨が見えづらいオブジェクト

オブジェクトの評価処理を安直にオブジェクト自身に実装すると、 オブジェクト の趣旨はぼやけます。 オブジェクトが何のために存在し、 何を為すのかが見えづら くなるのです (リスト13.6)。

{

298

リスト13.6: 評価メソッドにまみれた定義

public class Circle

{ public bool IsFull(); public bool IsPopular(); public bool IsAnniversary (DateTime today); public bool IsRecruiting(); public bool IsLocked(); public bool IsPrivate(); public void Join (User user); }

こうした評価の処理を放置しておくと、 オブジェクトに対する依存は手の施しよ うがないほど増加し、 変化に対して痛みを伴うようになります。

あるオブジェクトを評価する方法はメソッドに限ったことではありません。 仕様 のように外部のオブジェクトとして切り出すことで扱いやすくなることもあると 知っておきましょう。

13.1.3 リポジトリの使用を避ける

仕様はれっきとしたドメインオブジェクトであり、その内部で入出力を行う (リ ポジトリを使用する) ことを避ける考えもあります。 その場合はファーストクラス コレクションを利用することが選択肢に挙げられるでしょう。 ファーストクラスコ レクションはList といった汎用的な集合オブジェクトを利用するのではなく、 特化 した集合オブジェクトを用意するパターンです。

たとえばサークルのメンバー群を表現するファーストクラスコレクションはリス ト 13.7です。

リスト13.7: サークルに所属するメンバーを表すファーストクラスコレクション

public class CircleMembers

private readonly User owner;

private readonly List<User> members;

{

299

public CircleMembers (CircleId id, User owner, List<User> → members)

{ } Id = id; this.members = members;

public CircleId Id { get; }

public int CountMembers()

return members. Count() + 1;

{

}

public int CountPremium Members (bool containsOwner = true)

{ var premiumUserNumber = members. Count (member => member.➡ IsPremium); if (containsOwner) { return premiumUserNumber + (owner. Is Premium ? 1 : 0); } else { } } } return premiumUserNumber;

CircleMembers は汎用的なListと異なり、 サークルの識別子と所属するメン バーをすべて保持しています。 また独自の計算処理をメソッドとして定義できます。 このCircleMembers を利用した仕様はリスト13.8です。

300

リスト 13.8 CircleMembers を利用した仕様

public class CircleMembers FullSpecification { public bool IsSatisfied By (CircleMembers members) { var premiumUserNumber = members. CountPremiumMembers➡ (false); var circleUpperLimit = premiumUserNumber < 10 ? 30 : 50; return members.CountMembers () >= circleUpperLimit; } }

ファーストクラスコレクションを利用すると決めた場合には、 アプリケーション サービスでファーストクラスコレクションへのデータ詰め替え処理が必要になりま す (リスト 13.9)。

リスト 13.9 ファーストクラスコレクションに詰め替える

var owner = userRepository. Find (circle.Owner);

var members = userRepository. Find(circle.Members);

var circleMembers = new CircleMembers (circle.Id, owner,

members);

var circleFullSpec = new CircleMembers Full Specification();

if (circleFullSpec. IsSatisfiedBy (circleMembers)){

(･･･略...)

}

入出力をドメインオブジェクトから可能な限り排除することは重要です。 ファー ストクラスコレクションを利用した解決法は、 その方針を支える手立てになる しょう。

301

DDD 仕様とリポジトリを 132 組み合わせる

仕様は単独で取り扱う以外にもリポジトリと組み合わせて活用する手法が存在し ます。 つまり、リポジトリに仕様を引き渡して、 仕様に合致するオブジェクトを検 索する手法です。

リポジトリには検索を行うメソッドが定義されますが、 検索処理の中には重要な ルールを含むものが存在します。 こうした検索処理をリポジトリのメソッドとして 定義してしまうと、 重要なルールはリポジトリの実装クラスに記述されてしまいま す。

そういったとき、 重要なルールを仕様オブジェクトとして定義し、 リポジトリに 引き渡せば、 重要なルールがリポジトリの実装クラスに漏れ出すことを防げます。

13.2.1 お勧めサークルに見る複雑な検索処理

ユーザがサークルに参加したいと考えたとき、 自分に合ったお勧めのサークルを 検索できると便利です。 お勧めサークルの検索機能を開発することを考えてみま しょう。

お勧めサークル検索機能を作るにあたって、 まずはお勧めサークルの定義を決め なくてはいけません。 たとえば 「活気があるサークル」 や 「新しく作られたばかり のサークル」など、 考えられる条件はいくつもありますが、ひとまずは次の2つの 条件にしたがったサークルをお勧めサークルとしましょう。

・直近1か月以内に結成されたサークルである ・所属メンバー数が10名以上である

お勧めサークルの定義が決まったところで次に決めるべきことは、どこにそれを 記述するか、です。 お勧めサークルの検索を行う処理はどこに実装すべきでしょう か。

これまでユーザやサークルの検索を実質的に行ってきたのはリポジトリでした。 お勧めサークルの検索もこれと同様に、 リポジトリに定義してみましょう (リスト 13.10).

複雑

AFF

13

302

リスト13.10 リポジトリにお勧めサークルを探し出すメソッドを追加する

public interface ICircleRepository { } (88) public List<Circle> FindRecommended (DateTime now

);

FindRecommendedメソッドは引き渡された日付にしたがって、最適なサーク ルをいくつか見繕ってくれるメソッドです。 アプリケーションサービスはFind Recommended メソッドを利用して、ユーザにお勧めサークルを提案します (リス 13.11).

リスト13.11 お勧めサークルを探し出すアプリケーションサービスの処理

public class Circle ApplicationService

{ private readonly DateTime now;

(･･･略･･･)

public CircleGetRecommendResult GetRecommend (→

CircleGetRecommend Request request)

{

// リポジトリに依頼するだけ

var recommend Circles = circle Repository. Find Recommended➡

(now);

return new CircleGetRecommend Result (recommend Circles);

}

}

この処理自体は正しく動作しますが、ひとつ問題があります。 お勧めサークルを 導き出す条件がリポジトリの実装クラスに依存している点です。

お勧めサークルの条件は本来であれば重要なルールです。 インフラストラクチャ のオブジェクトであるリポジトリの実装クラスに左右されることは推奨されませ ん。

梅とリオシトリを組み合わせる

303

1

リポジトリは強力なパターンです。 しかしその強力さゆえに、 ドメインの重要な ルールをインフラストラクチャの領域に染み出させてしまうことを助長します。

13.2.2 仕様による解決法

ドメインの重要な知識はできる限りドメインのオブジェクトとして表現すべきで す。 お勧めサークルかどうかを判断する処理はまさにオブジェクトの評価であり、 仕様として定義できます (リスト13.12)。

リスト13.12: お勧めサークルかどうかを見極める仕様オブジェクト

public class Circle Recommend Specification {

public Circle Recommend Specification (DateTime executeDateTime)

{

this.executeDateTime = executeDateTime;

}

public bool IsSatisfied By (Circle circle)

if (circle.CountMembers() <10)

return false;

{

return circle.Created > executeDateTime.AddMonths (-1);

CircleRecommendedSpecificationはお勧めサークルかどうかを判定するオブ ジェクトです。 お勧めサークル検索処理はリスト13.13になります。

{

private readonly DateTime executeDateTime;

}

}

}

304

リスト 13.13: 仕様を利用しお勧めサークルを検索する

public class Circle ApplicationService

{

private readonly ICircle Repository circle Repository;

private readonly DateTime now;

(･･････)

public CircleGet RecommendResult GetRecommend (→

CircleGetRecommend Request request)

var recommend CircleSpec = new Circle RecommendSpecification➡ (now);

{

var circles = circleRepository.FindAll();

var recommend Circles = circles

.Where(recommend Circle Spec. IsSatisfiedBy)

.Take (10)

.ToList();

return new CircleGetRecommendResult (recommend Circles);

}

}

このように仕立てれば、 お勧めサークルの条件をリポジトリに記述する必要はな くなります。

また直接的に仕様のメソッドをスクリプト上で呼び出す以外にも、 リポジトリに 仕様を引き渡してメソッドを呼び出させる (ダブルディスパッチ)ことにより、 対 象となるオブジェクトを抽出させる手法もあります。 この手法を採用する場合は、 仕様のインターフェースを用意します (リスト13.14)。

305

仕様とリポジトリを組み合わせる

リスト 13.14: 仕様のインターフェースと実装クラス

public interface ISpecification<T> { } public bool IsSatisfiedBy (T value);

public class Circle Recommend Specification : ISpecification➡ <Circle>

{

(･･･略･･･)

}

リポジトリはこのインターフェースを受け取り、 結果となるセットを返却するよ うになります (リスト13.15)。

リスト13.15: リポジトリは仕様のインターフェースを

public interface ICircle Repository

受け取り結果セットを返す

{

(･･･略･･･)

public List<Circle> Find (ISpecification<Circle> specification);

}

仕様をインターフェースにすることでリポジトリには仕様ごとにメソッドを追加 定義する必要がありません。 ISpecification <Circle> を実装した新たな仕様を定 義すれば、 ICircleRepository に引き渡しての検索が可能です。

リスト13.14を利用したお勧めサークル検索処理はリスト13.16です。

306

リスト13.16 リスト 13.14を利用してお勧めサークルを探す

public class Circle ApplicationService

private readonly ICircle Repository circle Repository; private readonly DateTime now; (---88---) public CircleGet RecommendResult GetRecommend (→ CircleGetRecommend Request request) { var circleRecommend Specification = new ➡ CircleRecommendSpecification (now); // リポジトリに仕様を引き渡して抽出 (フィルタリング) var recommendCircles = circleRepository. Find (→ circleRecommend Specification) .Take (10) .ToList(); } } return new CircleGetRecommendResult (recommend Circles

{

);

このように仕様を使って表現することで、 お勧めサークルの条件はサービスに記 述されることなく、 ドメインの知識を語るオブジェクトとして存在できるのです。

13.2.3 仕様とリポジトリが織りなすパフォーマンス問題

仕様をリポジトリに引き渡す手法はルールをオブジェクトに表現しつつ、 拡張性 を高める有効な手段ですが、残念ながらデメリットが存在します。

リスト13.16で利用されている ICircleRepository の実装クラスを確認してみま しょう (リスト13.17)。

307

リスト13.17 仕様オブジェクトを受け取るリポジトリの実装

public class Circle Repository: ICircleRepository

private readonly SqlConnection connection;

(･･･略･･･) public List<Circle> Find(ISpecification<Circle> specification) using (var command = connection.CreateCommand()) { // 全件取得するクエリを発行 command.CommandText = "SELECT * FROM circles"; using (var reader = command.ExecuteReader()) { var circles = new List<Circle>(); while (reader.Read()) { 捨てられる) // インスタンスを生成して条件に合うか確認している (合わなければ → var circle = CreateInstance (reader); if (specification. IsSatisfied By (circle)) { circles.Add(circle); } } } } } return circles;

}

仕様に合致するかはオブジェクトを生成して仕様に引き渡し、 検査を行わない限 りわかりません。 結果としてこのコードは全件検索を行い、ひとつひとつのインス

{

{

1

308

タンスに対して条件に適合するか確認を行っています。 データの総数が数件であれ ば大した問題にはなりませんが、 数万件とデータが存在している場合には、ひどく 遅い処理になってしまうことがあります。

仕様をリポジトリのフィルターとして扱うときは、パフォーマンスのことを常に 考慮しておく必要があります。

13.2.4 複雑なクエリは「リードモデル」で

お勧めサークルの検索処理のように特殊な条件下にあるオブジェクトを検索した いという要求は、 便利なソフトウェアを開発していく上で必ずといっていいほど必 要になります。 そうした操作はたいていの場合は利用者の利便性のための操作であ ることが多く、パフォーマンスに関する要求も高くなりがちです。

こういった事情のあるときは仕様やリポジトリといったパターンを扱わないこと も視野に入ります。 この章の主題である仕様から離れますが、ここで一度それにつ いて確認しておきましょう。

リスト13.18 はサークルの一覧を取得し、 そのサークルのオーナーとなるユーザ の情報を取得するスクリプトです。

リスト13.18: サークル一覧を取得する処理

public class Circle ApplicationService

public CircleGetSummaries Result GetSummaries➡

(CircleGetSummaries Command command)

// 全件取得して

var all = circleRepository. FindAll();

// その後にページング

var circles = all

.Skip ((command.Page - 1) * command.Size)

.Take (command.Size);

var summaries = new List<CircleSummaryData>();

{

foreach (var circle in circles)

{

{

// サークルのオーナーを改めて検索

309

var owner = userRepository.Find(circle.Owner);

summaries.Add(new CircleSummary Data (circle. Id. Value, ➡

owner.Name.Value));

}

return new CircleGetSummaries Result (summaries);

}

(------)

}

この処理には2つの問題があります。

1つ目の問題は、冒頭でサークル集約を全件取得していることです。 この処理で はページングが行われているので、 すべてのサークルが必要なわけではありませ ん。 むしろ、ほとんどのサークルが不要です。 せっかく再構築したインスタンスの 多くは日の目を見ることなく捨てられます。

2つ目の問題はサークルに所属するユーザの検索処理が繰り返し文によって何度 も行われていることです。 リポジトリの具体的な実装が何で構成されているかはわか りませんが、もしもSQLであったのならばクエリが大量に発行されます。 本来であ ればJOIN句などを活用することで発行されるクエリはたった1回で済むはずです。 リスト13.18は正しく動作するでしょうが、最適化された状態には程遠い状態で す。 ドメインのレイヤーにあるべき知識の流出を防ぐことを考えれば、 このコード が正解であるはずなのですが、果たしてそれを理由にシステムの利用者の利便性か らくる最適化の依頼を拒否してよいものでしょうか。

そもそもシステムは何のために存在するのでしょう。 それは間違いなく利用者の 問題を解決するためです。 徹頭徹尾それは変わりません。 システムはその利用者に 対して友好的である必要があります。 もしもシステムの利用者に対する態度が友好 的でなくなれば、 そのシステムはやがて使われなくなっていくでしょう。 利用者を 無視し続けた未来にはシステムの緩やかな死が待ち受けています。

ドメインの防衛を理由に、 利用者に対して不便を強いるのは正しい道ではありま せん。 ドメインの表現を守り、 領域を保護することは大切なことですが、 アプリ ケーションの領域はプレゼンテーション (ひいてはシステムの利用者)を強く意識 する必要があります。

こういった問題は特に読み取りの際に発生します。 通常のリポジトリから読み取 りを行うよりもずっと複雑な読み取り動作をプレゼンテーションは要求することが

複

表現する「仕様」

13

310

多いです。 概要取得やページングはまさにその最たるものです。

複雑な読み取り動作においてパフォーマンスを起因とする懸念があった場合に は、局所的にドメインオブジェクトから離れることがあります。 より具体的にはリ スト13.19のようにページングしたクエリを直接実行して結果を組み立てます。

リスト13.19: 最適化のために直接クエリを実行する

public class CircleQueryService { (…略…)

public CircleGetSummaries Result GetSummaries➡

(CircleGetSummaries Command command)

{

var connection = provider.Connection;

using (var sqlCommand = connection. CreateCommand())

sqlCommand.CommandText = @"

SELECT

{

circles.id as circleId,

users.name as ownerName

FROM circles

LEFT OUTER JOIN users

ON circles.ownerId = users.id

ORDER BY circles.id

OFFSET @skip ROWS

FETCH NEXT @size ROWS ONLY

var page command. Page;

";

var size = command. Size;

sqlCommand.Parameters.Add(new SqlParameter("@skip", →

(page 1)✶ size));

sqlCommand.Parameters.Add(new SqlParameter("@size", size));

311

using (var reader = sqlCommand.ExecuteReader())

{

var summaries = new List<CircleSummary Data>(); while (reader.Read())

{

var circleId = (string) reader ["circleId"]; var ownerName (string) reader ["ownerName"]; var summary = new CircleSummaryData (circleId,

ownerName);

summaries.Add(summary);

}

return new CircleGetSummaries Result (summaries);

}

リスト13.19はSQLを用いたモジュールですが、もちろんORMなどを利用した モジュールでも構いません (リスト13.20)。

}

x+13.20: ORM (Entity Framework)

public class EFCircleQueryService {

private readonly MyDbContext context;

public EFCircleQueryService (MyDbContext context) { } this.context context;

public CircleGetSummaries Result GetSummaries➡ (CircleGetSummaries Command command)

{

}

}

312

var all =

from circle in context.Circles

join owner in context. Users

on circle.OwnerId equals owner.Id

select new { circle, owner };

var page = command.Page;

var size = command.Size;

var chunk = all

.Skip ( (page - 1) * size)

.Take (size);

var summaries = chunk

.Select(x = new CircleSummaryData (x.circle.Id,

x.owner.Name))

.ToList();

return new CircleGetSummaries Result (summaries);

}

プレゼンテーション側の要求に特化したユースケースの提供をすることは便利な システムを提供する上で必ずといってよいほど必要になります。

}

読み取り (クエリ) で要求されるデータは複雑ですが、 その動作自体は単純でド メインのロジックと呼べるものがほとんどありません。 反対に書き込み (コマンド) はドメインとしての制約が多く存在します。 このことから、 コマンドにおいてはド メインを隔離するためにドメインオブジェクトやそれに関わるものを積極的に利用 し、クエリにおいてはある程度の緩和をすることがあります。 本書で詳しくは取り 扱いませんが、この考えはCQS (Command-query separation) やCQRS (Command Query Responsibility Segregation) といった考えに基づくものです。 オブジェク トのメソッドをコマンドとクエリに大別し、それらを別個に扱うというこれらの考 えはプレゼンテーションが要求するパフォーマンスを維持しながら、システムを統 制することに寄与する考えです。

313

COLUMN 化

遅延実行による最適

リポジトリを利用しつつもパフォーマンス問題を解決する手法として遅延実行と いう手段が挙げられます。 遅延実行を実現する場合、 リポジトリに定義する検索 メ ソッドはList型ではなく、 IEnumerable型を戻り値とします (リスト13.21)。

リスト 13.21: 遅延実行を考慮したリポジトリ

public interface ICircle Repository { } IEnumerable<Circle> FindAll();

IEnumerable はコレクション操作を行える型ですが、 実際にコレクションに対 する操作を行うまでコレクションを確定しません (厳密には実装クラス次第です)。 リスト13.18の前半部分にこのリポジトリを適用したときを例にして確認してみま しょう (リスト13.22)。

リスト13.22 リスト13.18の前半部分に適用

public class Circle ApplicationService

{

// リスト 13.21のリポジトリ private readonly ICircle Repository circle Repository;

public CircleGetSummaries Result GetSummaries➡

(CircleGetSummaries Command command)

{

// この段階ではデータを取得しない

var all = circleRepository. FindAll();

// ページング処理は条件を付与しているに過ぎないためデータを取得しない

var chunk = all

.Skip ((command.Page .Take (command.Size);

1) * command. Size)

-

314

// ここではじめてコレクションが処理されるため、 条件に応じて→ データ取得がされる var summaries = chunk .Select(x=> { var owner = userRepository.Find(x.Owner); return new CircleSummaryData(x.Id.Value, owner.Name.Value); }) .ToList(); } return new CircleGetSummaries Result (summaries);

}

リスト 13.22 では最初期に FindAllメソッドを利用して全サークルのコレクショ ンを取得していますが、 この段階ではコレクションの内容を参照する必要がないた め、実際のデータ取得は実施されません。 また、 その後に続くページング処理もコ レクションを取得する際の条件を付与しているに過ぎず、 実際にデータを参照する 必要がありません。 リスト13.22で実際にデータ取得が行われるタイミングは ToList メソッドによりコレクションが確定されるときです。 このとき、 操作対象に はページングの条件処理が付与されているため、データ取得前にページングが行わ れ、 無駄なデータ取得が発生しなくなります。

このように、 実際に必要となるまで処理を実行しないことを遅延実行といいま す。 遅延実行を利用するとクエリの発行を本当に必要になるまで遅らせることがで きます。 それゆえ、ロジックの最初期段階で全件取得を行い、条件を付与して取得 範囲を狭めていく処理を組み立てやすくなります。

実際に、C#のデータ操作ライブラリであるEntityFrameworkはこの動作をサ ポートしています。 ただし、 それをあてにすることは、コードが特定の技術基盤に 依存することを意味します。 リポジトリの実装クラスが EntityFrameworkをベー スとしたものであり続ければよいですが、もし、そうでなくなったときを考えると、 悩ましい問題であることは間違いないでしょう。

31.

DDD 13.3

まとめ

オブジェクトの評価はそれ単体で知識になりえます。 仕様は評価の条件や手順を モデルにしたオブジェクトです。

オブジェクトの評価をオブジェクト自身にさせることが常に正しいとは限りませ ん。 仕様のような外部のオブジェクトに評価させる手法の方が素直なコードになる ことも多いでしょう。

本章では、仕様をリポジトリに引き渡してフィルタリングを行う手法も紹介しま した。 残念ながらこれは銀の弾丸ではなく、 パフォーマンス上の問題が付いて回り ます。

読み取り操作は単純ながら最適化が求められることも多いです。 読み取り操作に おいてはドメインという考え方を棚上げにして、クライアントが利用しやすい形で 提供することもあると覚悟しておく必要があります。

216

Chapter 14 アーキテクチャ

ドメイン駆動設計と同時に語られるアーキテクチャを 解説します。

ドメイン駆動設計はドメインと向き合いながらモデル をコードに落とし込むことで、 ドメインとコードを結 びつけるプラクティスです。 したがって、 ドメイン駆動 設計は特定のアーキテクチャを前提とすることはあり ません。 それにもかかわらず、 ドメイン駆動設計と同 時にアーキテクチャが語られることは多いです。 なぜ アーキテクチャの話が出てくるのでしょうか。

これまでドメインモデル貧血症などの例を通じて、重 大なルールが漏れ出した結果が引き起こす弊害を訴 えてきました。 ソフトウェアが利用者の役に立ち続け るものであり続けるには、継続的な改良に耐えうる構 造でなくてはなりません。 ひとつのモデルの変更がい くつものオブジェクトの変更に繋がるようでは、 改良 に二の足を踏むのも致し方ないことでしょう。

アーキテクチャはこれを解決するものです。 アーキテ クチャは知識を記述すべき箇所を示す方針です。 ドメ インのルールが流出することを予防するのと同時に 一箇所にまとめるよう促します。 ドメイン駆動設計と アーキテクチャが同時に語られる理由はまさにそこに あります。

14

DDD 14.1

アーキテクチャの役目

アーキテクチャは開発者の心を躍らせるものです。 開発者はいつだって整然とし また理論や仕組みに心惹かれるものです。

だからこそ、 そこに水を差すのは憚られるのですが、 アーキテクチャに対する態 度について論じる必要があります。 つまり、 ドメイン駆動設計にとって 「アーキテ クチャは決して主役ではない」ことについてです。

この言葉の真意を理解するために、アーキテクチャ自体を学ぶ前に、 まずはドメ イン駆動設計にとってアーキテクチャがどのような立ち位置であるかを確認してい きましょう。

14.1.1 アンチパターン: 利口なUI

システムを致命的に硬直したものに仕立てるアンチパターンのひとつが 「利口な UI (Smart UI)」 です。 利口なUIは本来であればドメインオブジェクトに記載さ れるべき重要なルールやふるまいが、 ユーザーインターフェースに記述されてし まっている状態を揶揄しています。

利口なUIはドメインを分離することが適わなかったアプリケーションに多く見 られます。 そうしたシステムは改良に対するコストが異常に高くなってしまい、 結 果としてひどく硬直したソフトウェアになってしまっています。 たとえばECサイトのシステムを例に考えてみましょう。

注文 注文履歷 確認画面 一覧画面 </> </> 注文履歷 確認画面 <1> サーバー

図 14.1: 典型的なECシステム

14

318

ECサイトでは利用者は商品をウェブサイト上から注文します。 図14.1は主に利 用者が商品を注文する際に利用するシステムの一部を表しています。

これらの画面には共通するビジネスロジックが存在します。 ひとつずつ、 システ ムの利用者の行動を追いながら確認していきましょう。

まずシステムの利用者は、注文したい商品を選択したのちに、 商品を注文するた めに"注文確認画面 " へ遷移します。 "注文確認画面” では、これから行う注文の「合 「計金額」 が表示されます。 "注文確認画面” に表示されている内容が問題なければ、 利用者は注文を確定します。

自分が注文した内容が間違いないかを確認するために、 利用者は ” 注文履歴一覧 画面” を開きます。 この画面はこれまで行った注文の概要が一覧となって表示され ています。 このとき、 注文それぞれに 「合計金額」 が表示されていると便利です。 "注文履歴一覧画面” には 「合計金額」 が表示されています。

"注文履歴一覧画面” では注文ひとつひとつの具体的な内容がわかりません。 シス テムの利用者は注文内容の詳細を確認するために”注文履歴確認画面” を開きます。 もちろん、そこにも 「合計金額」 が表示されています。

ここで紹介したいずれの画面においても 「合計金額」 が表示されています。 した がって、 「合計金額の計算」 をそれらすべての画面で行う必要があります。 「合計金 「額の計算」 処理はどこに記述されるべきか考えてみましょう。

注文 確認画面 注文履歴 一覧画面 </> <1> 注文金額計算 注文金額計算 注文履歴 確認画面 <1> サーバー 注文金額計算

図 14.2: UIに記述されるビジネスロジック

図14.2はもっとも短絡的な構成を示しています。 3つの画面それぞれで直接 「合計金額の計算」 をすることで、 各画面に 「合計金額」を表示しています。 これは多くの問題を抱えています。 たとえば、 もしも 「合計金額の計算」 処理が 変更されることになったときを考えてみてください。

319

1.1 アーキテクチャの役目

まず弊害として挙げられるのは、 「合計金額の計算」 はひとつでありながら、 その 変更が3箇所に渡ることです。 本来、 正しくロジックがまとめられていれば、 たっ また1箇所の修正で済んでいたはずなのに、 作業量が3倍となってしまいます。

また、ひとつひとつの画面は似たような画面であってもそれぞれの事情は異なり ます。 システムは成長していくものです。 年月が経つにつれ、 当初はまったく同じ であったはずの 「合計金額の計算」 は、 それぞれの画面特有の事情によって独自に 成長していくでしょう。 同じように見えるコードはわずかに異なり、慎重に修正を 加える必要ができてしまいます。

もちろんひとりの開発者がこれら3つの画面を同時期に手掛けるのであれば、わ ざわざ同じ処理をそれぞれの画面に記述するようなことはしないでしょう。 たいて いの場合、開発者はロジックをまとめることに熱心です。 3つの画面で行われる 「合計金額の計算」 がまったく同じ処理であることに気づき、 共通化を図ることがで きます。

真に問題となるのは最初時点で画面が1つしかなかったときです。 先の例でいえ ば、 最初は ”注文確認画面” しか存在せず、 後から注文履歴を確認する機能が追加さ れ、”注文履歴一覧画面”と” 注文履歴確認画面” の2つの画面を開発することに なったときです。

ロジックをまとめることだけに関心がある開発者にとって”注文確認画面” しか 存在しないということは、「合計金額の計算」 が "注文確認画面” に記述されること は肯定されます (図14.3)。 このとき同じ計算を他の箇所でも利用することが発生 したときのことが頭の片隅に過ぎることはあるでしょうが、それはそのときが来た ときに実施すればよい、 と楽観的に考えるのです。

注文 確認画面 注文金額計算 サーバー -> 注文情報

図14.3 重複が起きていない状態

開発者は 「一事が万事」 といった言葉に目を向けず、いつかリファクタリングを すべきタイミングが訪れる、という夢を信じがちです。 同時に、 正しい形は見えて いて、いかなるときであっても容易に書き換えられるという無謀な自信に満ち溢れ

320

ています。 もちろんそんなときは訪れません。 短絡的な解決を図ったコードは複雑 怪奇な進化を遂げて、いつの日かあなたの前に立ちはだかるのです。

UIは入力と表示がその責務です。 ビジネスに関わるようなロジックは可能な限 り記述されるべきではありません。 UIはできるだけ愚かであるべきです。UI が利 口になればなるほど改修の多くはコストがかさみ、 その修正は痛みを伴うものにな ります。 その痛みは開発者を怯えさせ、システムは段々と硬直していきます。

注文 注文履歷 確認画面 一覧画面 <1> </> サーバー 注文金額計算 注文金額計算 注文履歷 確認画面 <1> 注文金額計算 注文金額計算

図14.4 ビジネスロジックの集約

利口なUIを捨て、 ビジネスロジックを1箇所に集約すると図14.4 になります。 この構成であれば、 画面固有の事情が 「注文金額の計算」 に入り込む余地はありま せんし、計算に変更があったとしても1箇所の改修で済みます。 もちろん修正の難 易度もそう難しいものではないでしょう。

まずは、 いま開発しているソフトウェアがひどく単純なものであるという先入観 を捨てることから始めるべきです。 ユーザインターフェースにビジネスロジックを 記述することが肯定された段階で、豊かなドメインモデルを育てていく輝かしい道 のりは閉ざされます。

14.1.2 ドメイン駆動設計がアーキテクチャに求めること

利口なUIを避けることに決めたとしても、それを実際に実践するのはそう簡単 なことではありません。 ビジネスロジックを正しい場所に配置し続けることは、い かにその大切さを熟知している開発者であっても難しいものなのです。 それゆえ、 開発者に強い自制心を促す以外の方法を考える必要があります。 アーキテクチャは その解決策です。

14

•1 アーキテクチャの役目

321

アーキテクチャは方針です。 何がどこに記述されるべきかといった疑問に対する 解答を明確にし、ロジックが無秩序に点在することを防ぎます。 開発者はアーキテ クチャが示す方針にしたがうことで「何をどこに書くのか」 に振り回されないよう になります。 これは開発者がドメイン駆動設計の本質である 「ドメインを捉え、う まく表現する」ことに集中するために必要なことです。

ドメイン駆動設計がアーキテクチャに求めることは、ドメインオブジェクトが渦 巻くレイヤーを隔離して、ソフトウェア特有の事情からドメインオブジェクトを防 衛することです。 それを可能にするのであれば、 アーキテクチャがどのようなもの であっても構いません。

DDD 14.2 アーキテクチャの解説

次の一覧はドメイン駆動設計と同時に語られることの多いアーキテクチャです。

レイヤードアーキテクチャ ・ヘキサゴナルアーキテクチャ クリーンアーキテクチャ

本書ではこれらのアーキテクチャを解説しますが、 ドメイン駆動設計にとっては ドメインが隔離されることのみが重要であり、 必ずしもこのいずれかのアーキテク チャにしたがわなければいけないというわけではありません。 またアーキテクチャ にしたがったからといって、 それすなわちドメイン駆動設計を実践したことにはな らないということも知っておくべきことです。

重要なのは、 ドメインの本質に集中する環境を用意することです。

14.2.1 レイヤードアーキテクチャとは

レイヤードアーキテクチャはドメイン駆動設計の文脈で登場するアーキテクチャ の中で、もっとも伝統的でもっとも有名なアーキテクチャです。

レイヤードアーキテクチャはその名のとおり、 いくつかの層が積み重なる形で表 現されます。

キテクチャ

14

322

たとえば書籍 『エリック・エヴァンスのドメイン駆動設計」 では図 14.5 が提示 されています。

ユーザー インターフェース アプリ ケーション ドメイン インフラ ストラクチャ

図14.5 エリック・エヴァンスが示したレイヤードアーキテクチャ

出典 『エリック・エヴァンスのドメイン駆動設計』 (翔泳社) P.66より引用

ドメイン駆動設計の文脈で紹介されるレイヤードアーキテクチャは図14.5のと おり、4つの層で構成されたものが代表的です。 この図に倣って確認していきま しょう。 レイヤードアーキテクチャを構成する4つの層の内訳は次のとおりです。

・プレゼンテーション層 (ユーザーインターフェース層) アプリケーション層 ドメイン層 . インフラストラクチャ層

ドメイン層はこの中でもっとも重要な層です。 ソフトウェアを適用しようとして いる領域で問題解決に必要な知識を表現します。 この層を明示的にして、 ドメイン 層に本来所属すべきドメインオブジェクトの隔離を促し、 他の層へ流出しないよう にします。

323

2

アーキテクチャの解説

14

アプリケーション層はドメイン層の住人を取りまとめる層です。 この層の住人は アプリケーションサービスが挙げられます。 アプリケーションサービスはドメイン オブジェクトの直接のクライアントとなり、 ユースケースを実現するための進行役 になります。 ドメイン層の住人はドメインの表現に徹しているので、アプリケー ションとして成り立たせるためには彼らを問題解決に導く必要があります。 そのよ うな働きをするアプリケーション層は、まさにドメイン層の住人を取りまとめる存 在です。

プレゼンテーション層はユーザーインタフェースとアプリケーションを結びつけ ます。主な責務は表示と解釈です。 システムの利用者にわかるように表示を行い、 システム利用者の入力を解釈します。 具体的なアプローチにはさまざまなものがあ りますが、 それが具体的に何であるかについては問いません。 ユーザーインター フェースとアプリケーションを結びつけることさえできれば、 Webフレームワー クであってもCLIであってもよいのです。

インフラストラクチャ層は他の層を支える技術的基盤へのアクセスを提供する層 です。 アプリケーションのためのメッセージ送信や、 ドメインのための永続化を行 うモジュールが含まれます。

ここに存在する原則は依存の方向が上から下ということです。 上位のレイヤーは 自身より下位のレイヤーに依存することが許されます。 逆方向の直接的な依存は許 されません。

依存の観点で考えると、 ドメイン層からインフラストラクチャ層に依存の矢印が 伸ばされていることが奇妙に見えることでしょう。 これはドメイン層のオブジェク トがインフラストラクチャ層のオブジェクトを取り扱うことを意味していません。 図 14.5の右下に位置する白抜きの矢印を確認すれば、 汎化が含まれていることが わかります。 ちょうどリポジトリのインターフェースと実装クラスの関係がこの矢 印にあたるでしょう。

また、 「エリック・エヴァンスのドメイン駆動設計」にはレイヤー間のオブジェク ト同士の結びつきを表した図が登場します (図14.6)。

「a234 口座」 が addToUnit Of Work (a234) というメッセージを 「作業ユニッ トマネージャ」 に送っていることから、 古典的なユニットオブワークの実装 (10.4.4項) を想定していることがわかります。 昨今ではあまり利用されることの ないパターンですが、 ドメインオブジェクトがインフラストラクチャ層のオブジェ クトに依存している例として挙げられるでしょう。

324

ユーザーインタ アプリケーション ドメイン フェース インフラストラクチャ 振替 コントローラ 資金振替 サービス a123:0 a234 口座 作業ユニット マネージャ O-Rマッパー transter (a123, a234, 5100) beginTransaction() transter To (a234, 5100) credit ($100) addToUni OfWork (224) commit() debit($100) collectionの内容: a123, a234 addTo Unito Work (a123) commit() commit() update (collection) 振り込みか引き落としが失敗した場合には、 トランザクション全体が失敗する

図14.6 オブジェクト同士の結びつきを示した図

出典: 「エリック・エヴァンスのドメイン駆動設計』 (翔泳社)、 P.70の図4.1より引用

レイヤードアーキテクチャの実装サンプル

本書で解説をしながら実装してきたアプリケーションは実はレイヤードアーキテ クチャを意識して実装されたものです。 改めてレイヤードアーキテクチャの観点で コードを観察してみましょう。

最初に確認をするのはプレゼンテーション層に所属するUserControllerです (リスト14.1)。

リスト14.1 プレゼンテーション層の住人であるコントローラ

【Route("api/ [controller]")] public class UserController Controller {

private readonly UserApplicationService ➡ userApplicationService;

325

public UserController (UserApplicationService →

userApplicationService)

{

this.userApplicationService =

userApplicationService;

}

[HttpGet]

public UserIndexResponseModel Index()

{

var result = userApplicationService.GetAll();

var users = result. Users. Select(x => ➡

new UserResponseModel (x. Id, x.Name)).ToList();

return new UserIndex ResponseModel (users);

[HttpGet("{id}")]

public UserGetResponseModel Get(string id)

{

var command = new UserGetCommand(id);

}

var result = userApplication Service. Get (command);

var userModel = new UserResponseModel (result. User);

return new UserGetResponseModel (userModel);

[HttpPost]

public UserPostResponseModel Post([FromBody] ➡

UserPostRequestModel request)

{

}

var command = new UserRegister Command (request.UserName); var result = userApplicationService. Register (command);

326

} return new UserPostResponseModel (result.CreatedUserId);

[HttpPut("{id}")]

public void Put (string id, [FromBody] UserPut RequestModel ⇒ request)

{

var command= new UserUpdateCommand (id, request.Name); userApplicationService.Update (command);

}

[HttpDelete("{id}")] public void Delete(string id) { var command = new UserDeleteCommand (id); userApplicationService.Delete(command); }

}

HTTPリクエストという利用者からの入力データをアプリケーションに伝える ための変換を行っている MVC フレームワークのコントローラは、 まさに入力を解 釈してアプリケーションに結びつけるプレゼンテーション層の住人です。 アプリ ケーション層の住人であるアプリケーションサービスのクライアントにもなってい るので、 図 14.5 で示した依存の方向性が守られています。

次にアプリケーション層に所属するアプリケーションサービスを確認してみま しょう(リスト14.2)。

リスト14.2 アプリケーション層の住人であるアプリケーションサービス

public class UserApplicationService

{

private readonly IUserFactory userFactory;

private readonly IUserRepository userRepository;

private readonly UserService userService;

327

1.2 アーキテクチャの解

public UserApplication Service (IUserFactory userFactory, ➡ IUserRepository userRepository, UserService userService)

{

this.userFactory = userFactory;

this.userRepository = userRepository;

this.userService = userService;

}

public UserGetResult Get (User Get Command command)

{

var id = new UserId(command. Id); var user = userRepository. Find(id); if (user == null) {

throw new UserNotFoundException (id, "ユーザが見つかりませんでした。 ");

}

var data = new UserData (user);

return new UserGetResult(data);

}

public UserGetAllResult GetAll()

var users = userRepository. FindAll();

var userModels = users. Select (x => ➡

new UserData(x)).ToList();

} return new UserGetAllResult (userModels);

{

public UserRegisterResult Register (User Register Command →

using (var transaction = new TransactionScope()) {

var name = new UserName (command. Name);

var user = userFactory.Create(name);

if (userService.Exists(user))

{

throw new CanNot Register UserException (user, ➡ ユーザは既に存在しています。");

}

userRepository.Save(user);

transaction.Complete();

return new User RegisterResult(user.Id.Value);

}

public void Update (UserUpdateCommand command)

{ using (var transaction = new TransactionScope()) { var id = new UserId (command.Id); var user = userRepository. Find(id); if (user == null) { } throw new UserNotFoundException(id);

if (command. Name != null)

{

}

var name = new UserName (command. Name);

user. ChangeName (name);

329

if (userService.Exists(user))

throw new CanNot RegisterUserException (user, ➡

{

"ユーザは既に存在しています。");

}

userRepository.Save(user);

transaction.Complete();

}

}

public void Delete (UserDeleteCommand command)

using (var transaction = new TransactionScope())

var id = new UserId(command.Id);

userRepository. Delete(user);

}

}

アプリケーションサービスはその名に冠しているとおりアプリケーション層に所 属するオブジェクトです。 自身のレイヤーより下位に位置するドメイン層とインフ ラストラクチャ層に対して依存をしています。

{

var user = userRepository. Find(id);

if (user = null)

{

return;

}

transaction.Complete();

}

{

}

330

アプリケーション層の目的はアプリケーションサービスの目的と一致していま す。 すなわち問題を解決するためにドメインオブジェクトが実施するタスクの進行 管理を行います。 場合によっては他のサービスと協調することもあります。

このレイヤーで注意すべきはドメインのルールやふるまいを直接的に記述しては いけないことです。 ビジネスの重要なルールやふるまいはドメイン層に収められる べき事柄です。

次に確認するドメイン層はもっとも重要な層です。 ユーザのコード上の表現であ るUser クラスやドメインサービスであるUserServiceクラスはまさにこの層に所 属するオブジェクトです (リスト14.3)。

リスト14.3 ドメイン層の住人であるエンティティやドメインサービス

public class User

public User (UserId id, UserName name, UserType type)

{

{

if (id == null) throw new ArgumentNullException (nameof(id)); if (name == null) throw new ArgumentNullException(nameof→ (name));

} Id = id; Name = name; Type = type;

public UserId Id { get; }

public UserName Name { get;

public UserType Type { get;

private set; }

private set; }

public bool IsPremium=> Type= UserType.Premium;

public void ChangeName (UserName name)

{

if (name == null) throw new ArgumentNullException(nameof (name));

33

Name name;

}

public void Upgrade()

Type = UserType. Premium;

}

public void Downgrade()

Type = UserType. Normal;

}

public override string ToString()

var sb = new ObjectValueStringBuilder(nameof (Id), Id) .Append(nameof (Name), Name);

return sb.ToString();

}

public class UserService

{

private readonly IUserRepository userRepository;

public UserService (IUserRepository userRepository) { } this.userRepository = userRepository; public bool Exists (User user) { var duplicatedUser = userRepository. Find (user.Name

);

}

{

{

{

332

} } return duplicatedUser != null;

ドメインモデルに表現するコードはすべてこの層に集中します。 また、ドメイン オブジェクトをサポートする役割のあるファクトリやリポジトリのインターフェー スもこの層に含まれます。

最後に確認するインフラストラクチャ層のオブジェクトは永続化を実施するリポ ジトリです (リスト14.4)。

リスト14.4 インフラストラクチャ層の住人であるリポジトリ

public class EFUserRepository: IUserRepository {

private readonly ItdddDbContext context;

public EFUserRepository (ItdddDbContext context)

{

this.context

}

context;

id) { var target = context.Users.Find(id.Value); if (target == null) } { } return null; return ToModel (target);

public User Find (UserId

public List<User> Find (IEnumerable<UserId> ids)

{

333

var rawIds = ids.Select(x => x.Value);

var targets = context.Users

.Where(userData => rawIds.Contains(userData.Id));

return targets.Select(ToModel).ToList();

public User Find (UserName name)

var target = context.Users

FirstOrDefault(userData => userData.Name == name.Value);

if (target == null)

}

{

return null;

}

return ToModel (target);

(･･･略･･･)

インフラストラクチャ層にはリスト14.4のようにドメインオブジェクトを直接 的に支える技術的機能の他に、 アプリケーション層やプレゼンテーション層のため の技術的機能を担うオブジェクトも含まれます。

14.2.2 ヘキサゴナルアーキテクチャとは

ヘキサゴナルアーキテクチャは六角形をモチーフとした図 14.7 に代表される アーキテクチャです。 コンセプトはアプリケーションとそれ以外のインターフェー スや保存媒体は付け外しできるようにするというものです。 ヘキサゴナルアーキテ クチャが成し遂げようとしていることを説明するにあたって、 ゲーム機はよい例え です。

}

}

{

334

Web App Adapter Application Adapter DB

図14.7: ヘキサゴナルアーキテクチャ

ゲーム機にはコントローラやモニターといった利用者が直接触れることのできる インターフェースが存在します (図14.8)。 ゲームコントローラにはいわゆる純正 品がありますが、 利用者の好みによってサードパーティ製のものを差し込んでもう まく動作します。 モニターもコントローラと同じく、メーカーや液晶かプラズマか といった描画手法など細かい点が異なりますが、いずれにせよゲーム機にとっては 些細な違いです。 表示さえできればそれで十分です。

記憶媒体はどうでしょうか。 昨今のゲーム機は内蔵されたハードディスクにゲー ムデータを保存する選択肢以外に、クラウド上に保存する選択肢も用意されていま す。 ゲーム機からするとゲームデータの保存さえできるのであれば、 実際に保存さ れる媒体が何であっても構わないのです。

FO

図14.8 ゲーム機と付け外し可能なアダプタ

335

これをアプリケーションに転用するとどうなるでしょうか (図14.9)。

インターフェースはたとえばコマンドラインユーザーインターフェースやグラ フィカルユーザーインターフェースなどがあります。 最近では音声入力も発達して きてボイスユーザーインターフェースといったものもあります。 インターフェース の種類は多岐にわたりますが、 アプリケーションからしてみたら利用者の入力を伝 えてくれて、処理の結果を表示して利用者に対して伝えてくれるのであればそれが 何であっても構いません。

保存媒体にしてもそうです。 本書で幾度となく解説したとおり、 アプリケーショ ンにとって保存媒体は差し替え可能なものです。 アプリケーションが求めるのはイ ンスタンスの永続化と再構築です。 それさえこなすことができるのであれば、 具体 的な保存媒体がデータベースなのか、それとも磁気テープであるのかといったこと は些細な問題です。

</> ☑ Port BEL

図14.9 アプリケーションに置き換えた図

ヘキサゴナルアーキテクチャはまさにこのコンセプトの上に成り立っています。 アプリケーション以外のモジュールはさながらゲームのコントローラのように差し 替え可能なものです。 そのように仕立てられていれば、 インターフェースや保存媒 体が変更されるような事態が起きても、コアとなるアプリケーションにその余波は 及びません。

ヘキサゴナルアーキテクチャはアダプタがポートの形状に合えば動作することに 見立てて、ポートアンドアダプタと呼ばれることもあります。 このとき、アプリ

336

ケーションに対する入力を受けもつポートとアダプタをそれぞれプライマリポート とプライマリアダプタといいます。 反対にアプリケーションが外部に対してインタ ラクトするポートをセカンダリポートと表現し、 実装するオブジェクトをセカンダ リアダプタと呼びます。

実をいうとこれまで見てきたコードはヘキサゴナルアーキテクチャのコンセプト を達成しています。 レイヤードアーキテクチャの紹介をしているときに例示したア プリケーションサービスであるUserApplicationService を確認してみましょう (リスト14.5)。

リスト14.5 ユーザアプリケーションサービスのコード

public class UserApplicationService

private readonly IUserRepository userRepository;

private readonly UserService userService;

(･･･略･･･)

public void Update (UserUpdateCommand command)

using (var transaction = new TransactionScope()) { var id = new UserId(command.Id); var user = userRepository.Find(id); if (user == null) { } throw new UserNotFoundException(id);

if (command.Name != null)

{

var name = new UserName (command.Name);

user.ChangeName (name);

if (userService.Exists (user)) {

{

337

{

throw new CanNot RegisterUserException (user, ➡

ユーザは既に存在しています。 ");

}

}

// セカンダリポートであるIUserRepository の処理を呼び出す

// 処理は実体であるセカンダリアダプタに移る

userRepository.Save (user);

transaction.Complete();

ユーザ情報の更新であるUpdate メソッドを呼び出すクライアントはプライマリ アダプタで、 Updateメソッドはプライマリポートにあたります。 プライマリアダ プタはアプリケーションを操作するための値をプライマリポートが求めるUser UpdateCommandに変換し、 アプリケーションを呼び出します。

アプリケーションはIUserRepositoryというセカンダリポートを呼び出すこと で、具体的な実装 (セカンダリアダプタ) からインスタンスを再構築したり、 永続 化を依頼します。

先に紹介したレイヤードアーキテクチャとの違いとして挙げられるのは、イン ターフェースを利用した依存関係の整理に言及している点です。 レイヤードアーキ テクチャは層分けを言及しているに過ぎないので、 インターフェースを取り扱うかは まったく任意です。 とはいえ、 昨今のシステム開発の現場においてはレイヤードアー キテクチャでインターフェースを利用して、 依存関係の逆転を達成することは当た り前のように行われているため、両者の垣根はほとんどないように感じられます。

14.2.3 クリーンアーキテクチャとは

クリーンアーキテクチャは4つの同心円が特徴的な図によって説明されるアーキ テクチャです (図14.10)。

図14.10が示すのはビジネスルールをカプセル化したモジュールを中心に据え るというコンセプトです。 図中のEntitiesはドメイン駆動設計のエンティティを示

14

338

Devices DB Gateways The Clean Architecture Web Controllers Use Cases Entities External Interfaces Presenters Enterprise Business Rules Application Business Rules Interface Adapters Frameworks & Drivers Presenter UI Use Case Output Fort Flow of contral Use Case Interactor Controller

図14.10 クリーンアーキテクチャ

出典: 「The Clean Code Blog」 より引用

URL: https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html

しません。 クリーンアーキテクチャの文脈で語られるエンティティはビジネスルー ルをカプセル化したオブジェクトないし、データ構造と関数のセットを指すので、 どちらかといえばドメインオブジェクトに近い概念です。

クリーンアーキテクチャはユーザインターフェースやデータストアなどの詳細を 端に追いやり、 依存の方向を内側に向けることで、 詳細が抽象に依存するという依 存関係逆転の原則を達成します。

この説明を聞くと勘のよい方であれば次のことに気づくでしょう。 すなわち、ヘキ サゴナルアーキテクチャと目的としているところが同じであることです。 コンセプ トが同じであれば、具体的に違う箇所はどこなのかというのは気になるところです。

ヘキサゴナルアーキテクチャとクリーンアーキテクチャの大きな違いはその実装 の仕方が詳しく言及されているか否かです。 ヘキサゴナルアーキテクチャはポート とアダプタによりつけ外しを可能にするという方針だけがありました。 それに比べ てクリーンアーキテクチャには、コンセプトを実現する具体的な実装方針が明示さ れています。

図14.10の右下の図に着目してください。 この図こそが具体的な実装方法を表 しています。

まずは矢印を見てみましょう。 この矢印はよく見ると2種類存在しています。片 方は普通の矢印、 もう片方は白抜きの矢印。 これはそれぞれ依存と汎化を表してい

339

ます。 その観点を念頭において図を 改めて眺めてみると図14.11に示 す<I>という記号にも気づくで しょうか。 汎化の矢印が伸びている ことからもわかるとおり、 モジュー ルがインターフェースであること を示す印です。 Flow of control は プログラムを実行したときの処理 の流れを示しています。

右下の図に則り、 実際にコードを 実装してみましょう。 まずはInput Port です (リスト14.6)。

Presenter Flow of control <I> Use Case Output Port Use Case Interactor Use Case Controller Input Port

図14.11 クリーンアーキテクチャの右下の図

リスト14.6: InputPort の実装

public interface IUserGetInputPort { public void Handle (UserGetInputData inputData); }

InputPort はクライアントのためのインターフェースです。 コントローラから呼 び出されます。

InteractorはこのInputPortを実装してユースケースを実現します(リスト 14.7).

リスト14.7: Interactor の実装

public class UserGetInteractor: IUserGetInputPort

private readonly IUserRepository userRepository; private readonly IUserGetPresenter presenter;

{

public UserGetInteractor (IUserRepository userRepository, ➡ IUserGetPresenter presenter)

{

this.userRepository = userRepository;

アーキテクチャ

14

340

}

this.presenter = presenter;

public void Handle (UserGetInputData inputData)

{

var targetId = new UserId(inputData.userId);

var user = userRepository. Find (targetId);

var userData = new UserData (user.Id. Value, user. Name.Value);

var outputData = new UserUpdateOutputData (userData);

presenter. Output (outputData);

}

}

User GetInteractor はちょうどアプリケーションサービスのメソッドをそのま まクラスにしたものです。 これまでのアプリケーションサービスと異なる点は、結 果を出力する先が presenter と呼ばれるオブジェクトになっている点です。

UserGetInteractor は IUser GetInputPortを実装しているので、リスト14.8の ようなスタブを作ることが可能です。

リスト14.8 テスト用のスタブ

public class StubUserGetInteractor: IUserGetInputPort {

private readonly IUserGetPresenter presenter;

public UserGetInteractor (IUser Get Presenter presenter) { } this.presenter = presenter;

public void Handle (UserGetInputData inputData)

{

var userData = new UserData("test-id", "test-user-name"); var outputData = new UserUpdateOutputData (userData);

341

}

presenter.Output (outputData);

クライアントはIUser GetInputPort越しに Interactor を呼び出すので、 スタプ に差し替えることでテストの実施が可能です。 このようにして、 テスタビリティを 随所で確保することもクリーンアーキテクチャの重要なテーマです。

クリーンアーキテクチャのコンセプトでもっとも重要なことはビジネスルールを カプセル化したモジュールを中心に据え、 依存の方向を絶対的に制御することで す。 これはヘキサゴナルアーキテクチャのコンセプトとほとんど同じものです。

いずれにせよ、 ドメイン駆動設計の文脈上でもっとも重要なことはドメインの隔

離を促すことです。 すべての詳細がドメインに対して依存するようにすることは、 ソフトウェアの方針をもっとも重要なドメインに握らせることを可能にします。

DDD 14.3

まとめ

アーキテクチャには共通点があります。 それは、一度に多くのことを考えすぎな いこと。

人は多くのことを同時に考えることが苦手な生き物です。 複数の作業をこなすの であれば、 並行的に作業をこなすマルチタスクよりも単一の作業を複数こなすシン グルタスクを連続して行う方が作業効率はよかったりします。 アーキテクチャは方 針を示し、 各所で考える範囲を狭めることで集中を促します。

何をすべきかが明確になると、同時に考える余地も出てくるでしょう。 アーキテ クチャを採用することはより深いモデルの考察の時間を増やすことに寄与します。

本章で紹介したアーキテクチャに固執する必要はありません。 やり方はひとつで はないはずです。 ドメイン駆動設計においてアーキテクチャは主役ではありませ ん。 ドメインの隔離を促すことができるのであれば、 どのようなものを採用しても 構いません。

ソフトウェアにとってもっとも重要なことはシステム利用者の必要を満たすこと や問題の解決を実現することです。その本質に集中するために、ご自身のプロジェ クトにとって最適なアーキテクチャを選択してください。

342

14

Chapter 15

ドメイン駆動設計の とびらを開こう

今後の学習の手引きをします。

本書もついに最終章です。 ドメインの値を表現する 「値オブジェクト」から始まり、「エンティティ」や「ド メインサービス」 などのひとつひとつのパターンに フォーカスしながら確認をしてきました。 それと並行 するようにしてひとつのソフトウェアを作り上げる過 程にも触れてきました。 いまではコードをどのように 組み立てるかといった方針も見えてきたのではないで しょうか。

ところで本書の冒頭でお話したことは覚えているで しょうか。 ドメイン駆動設計はモデリング手法とその モデルをコードへ落とし込むための実践的なパターン をまとめたプラクティスです。 決して後者だけがドメイ ン駆動設計ではありません。

読者の皆さんはいまようやくドメイン駆動設計のとび らに手をかけたところです。 とびらの先に広がる世界 を歩むための旅支度をはじめましょう。

15

DDD 15.1

軽量 DDD に陥らないために

ドメイン駆動設計に登場するパターンだけを取りいれる手法は軽量DDDと呼ば れます。

軽量DDDはあくまでもコードの書き方を主題としているので、 開発者だけで完 結させることが可能で実践しやすく、 短期的にプロダクトのコードにある程度の秩 序をもたらします。 それゆえ、 費用対効果が高く感じられ、ともすればパターンを 踏襲することだけで満足してしまいます。

しかしながら、ドメイン駆動設計が目指すことは決してパターンに終始すること ではありません。 パターンを主軸にすることは、すべての問題に技術的な解決を求 めるのと何ら変わりないことです。

もっとも重要なことはドメインの本質に向き合うことです。 技術的なパターンは 絶対的な答えとして君臨するものではなく、 ドメインの本質に向き合い、 それをう まくコードで表現するためのサポート役として機能します。

常に「どのように表現するか」 や 「どのように実現するか」 といったことを考え ていると、ドメインに向き合う余裕が生まれません。 パターンは考える余裕を生み 出します。 そうしてできた余力はドメインに向けるべきです。

ドメイン駆動設計では、ドメインを実装に結びつけるモデリングの手法について も多く語られています。 本書の位置づけはパターンを題材にドメイン駆動設計を学 ぶ土台として必要な基礎的知識の解説を行うもので、 決して皆さんを軽量DDDに 導きたいわけではありません。 ドメイン駆動設計のモデリング手法すべてに触れる ことは叶いませんが、 代表的な概念だけでもここで触れておきましょう。

COLUMN

パターンの濫用とパターンを捨てるとき

トンカチを手にすると目の前のものが釘に見えて仕方なくなるのと同じように、 パターンを覚えるとそれが適用できるチャンスをとにかく探してしまいます。 もちろんトンカチを振るう対象が釘であるなら問題はないのですが、それがネジ であったなら明らかに道具を間違えています。 パターンは見るものすべてを釘に変 えてしまう魔力があります。

ドメインの表現手段としてそうすることが自然であるのであれば、パターンを捨 てることを決断することも、ときには必要です。

15

ドメイ

こう

12

344

ドメインエキスパートと

DDD 15.2

モデリングをする

友人と旅行に行く計画をして、いざ当日に彼がヘリで迎えにきたら、 あなたは きっと驚くでしょう (図 15.1)。

とあるモノやコトについて語っているときに認識がいつの間にかズレているとい うことはよくあることです。 現実では友人がヘリで迎えにくるほどの認識のズレは あまり起こりませんが、 ことシステム開発においてはそれとほとんど同じぐらい荒 唐無稽な認識のズレが起こりえます。

図 15.1 認識のズレ

たとえば「ユーザを登録する」という表現と 「ユーザを新規保存する」という表 現は結果が同じであってもそこに存在するニュアンスは異なります。 前者は直感的 であり、後者はよりシステマチックです。 この程度の表現の差異であれば開発者以 外であっても会話をしながら 「”新規保存 ” はきっと”登録する”ことをいっている のだな」 と補完を行えます。 私たち人間は会話のエキスパートであるので、 初めて 聞く単語の組み合わせであっても、自身の経験をもとにある程度の推測が可能です。

しかし、より複雑で繊細な概念を前にすると事情は変わってきます。 開発者がシ ステムに実直な言葉を使えば使うほど、それを聞かされるドメインの精通者は理解 を放棄するようになるでしょう。 「彼らの言葉は難しすぎる。 システム開発のエキス パートである彼らに任せてしまった方がよさそうだ」 といった具合にです。

こういった言葉のすれ違いから生じる理解の放棄は、最終的にドメインとコード の断絶という結果に行き着きます。 ドメインの概念が捻じ曲げられても、 断絶によ りそれに気づく機会が与えられず、訂正される機会すらも奪われます。 プロダクト

345

のコードは開発者の理解と言葉によって組み立てられ、ソフトウェアはまるで見当 違いな方向へ歩み出してしまうのです。

開発者はドメインエキスパートと呼ばれるドメインの精通者たちと会話をしなく てはなりません。 ドメインエキスパートはドメインの実践者です (図15.2) 決し てステークホルダーのことではありません。 ドメインのことを知るには彼らが所属 している世界がどんなものなのか、 彼らから見える景色がどういったものなのかを 知らなくてはなりません。 同じ労力をかけるのであればシステマチックな表現に変 換することよりも、 ドメインの概念を捻じ曲げないように共通の言葉でコミュニ ケーションをするように心がけるべきです。

図 15.2 ドメインの実践者たち

ドメインの問題を解決するソフトウェアを開発するにあたって、 ドメインと向き 合うことは避けられません。 私たち開発者は、ともすればドメインと向き合うこと よりも技術的なアプローチに傾倒しがちです。 しかしそれは間違った選択肢です。 問題を知らずして答えを導き出すことは不可能であるのと同様に、 ドメインの問題 を解決する答えを導き出すにはドメインを知る必要があるのです。 正しい答えを導 き出すためにその背景を知り、それを解決する最善策が何なのかを探し求めること はドメインに向き合うことと同義でしょう。

346

15.2.1 本当に解決すべきものを見つけよう

ドメインエキスパートとの対話はソフトウェアの方向性を決定するのに有意義で す。 これは開発者がドメインエキスパートへ迎合するよう推奨しているわけではあ りません。

ドメインエキスパートが問題としていることが実は些細なことで、 本当に解決す べき問題はまったく別のところにあることもあります。 ドメインエキスパートに迎 合しているばかりでは、その間違いに気づくことができません。 真に解決すべき問 題は開発者とドメインエキスパートが対話することによって見つけ出されるものな のです。

開発者はドメインエキスパートと協力して、 ドメインにおいて有益な概念を作り 上げなくてはなりません。 そうして作り上げられた概念がドメインモデルと呼ばれ ているものです。 ここで勘違いしてはいけないのが、 ドメインモデルはドメインエ キスパートが知っているわけではないということです。

そもそも人間は自分が欲しいものについて、 案外理解していないものです。 ソフ トウェアシステムがドメインの活動に対してどのように働きかけることができるの かについて知識のないドメインエキスパートは、自身の活動を助けるものが何であ るかわかりません (図 15.3)。 紙とペンしか触れたことがない者がデータベースの ことを理解できるはずもありませんし、 それを利用することで何ができるのかは想 像もつかないはずです。

図 15.3 想像できない世界

またドメインエキスパートが保有している知識は膨大ですが、 どの知識がシステ ムの役に立つのかといったことまではわかりません。 それを知るにはシステムに よって実現できることに関する知識が必要です。

開発者はただドメインエキスパートの言葉を聞くことに徹していてはいけませ

ートとモデリングをする

347

ド

ん。 開発者には彼らとの対話を手引きし、 システムにとって役立つ概念や知識を引 き出す使命があります。 必要とあらば開発者がドメインエキスパートに対して、 シ ステムを理解するために必要なことを教えることもあります。 会話は一方向では成 り立ちません。 ドメインエキスパートと開発者が協力しながら知識を蒸留すること で、 ドメインの概念から知識が選び抜かれ、 ドメインモデルへと昇華するのです。

残念ながら世の中にはドメインエキスパートの業務をサポートするソフトウェア を開発するプロジェクトでありながら、 ドメインエキスパートがまったく関わらな い (もしくは関われない) プロジェクトが存在します。 会議が開発者とステークホ ルダーの間で行われたり、ときにはあろうことかステークホルダー間で行われてす べてが決まることすらあります。 ソフトウェアを利用する当事者に対するインタ ビューはステークホルダーを通して行われます。 当然ながらそのような状況では、 価値あるドメインモデルが作り上げられることはなく、 できあがったソフトウェア の扱いづらさにシステムの利用者たちは陰口を惜しみません。 「新しいシステムは 本当に使えない」 と。

知識を蒸留する作業は開発者とドメインエキスパートが共同して行えるようにす べきです。 そうすることで開発者はアプリケーションが何をすべきかという表面的 なことだけではなく、 ドメインエキスパートの問題は何なのかといったことに目を 向けます。これがきっかけとなり、 開発者は無味無色なソフトウェアを開発するの ではなく、問題の解決に向けて動き出すようになります。

もしもあなたがプロダクトオーナーやステークホルダーといった立場で、プロ ジェクトを成功させたいと願うならば、ひとつアドバイスがあります。 あなたがド メインエキスパートと会話をする仲介者としてふるまうのではなく、 開発者とドメ インエキスパートの会話の機会を増やすよう働きかけてください。 ビジネスの視点 を開発者に共有し、 彼らに主体となって取り組んでもらうよう仕向ける方法として これ以上のものはありません。

15.2.2 ドメインとコードを結びつけるモデル

ソフトウェア開発の最終成果物はコードです。 モデルはドメインとコードを結び つけるために存在します。

しかしながら、ときに開発者は専門家によるモデルを押し付けられることがあり ます。 ソフトウェアとして実装することに対する配慮が欠けたおよそ実現不可能な モデルです。 この類のモデルが与えられたとき、開発者は無遠慮なモデルを参考に、 改めて技術的に実現可能なモデルへと組み替える作業を行うことになります。その ようにしてできあがったモデルは、重要な知識が欠けていることもあれば、不要な

348

知識にまみれていることもあります。

ドメインに対する気づきは対話の場ではなく、 設計や実装の段になって表れるこ ともあります。 モデルが設計と断絶していると、そうした気づきをフィードバック して、 ドメインモデルを成長させる機会を失うことになります。

ドメインとコードはモデルを通じて繋げることができます。 そしてお互いを常に 行き来することで、 ソフトウェアにとって役に立ち、なおかつドメインの知識を凝 縮したドメインモデルを手にいれることができるのです(図15.4)。

モデル コード

図15.4 モデルとコードの相互的フィードバック

DDD 15.3

ユビキタス言語

人はみな、 言葉によって意思疎通を図ります (図15.5)。 プログラミングにおけ るパターンはその代表です。 ここまでこの本を読み進めたみなさんであれば「エン ティティ」 という言葉の指すモノが何なのかをもう十分にわかるはずです。 人間は モノやコト、 概念に名前を付け、それに対する認識を共有することで、 意思の疎通 を図ることができます。

当然のことながら、 もしもひとつの概念に複数の名前が付けられていたら混乱を 引き起こします。 本来であればそんなことは避けるべきことのはずですが、 しかし ソフトウェア開発の現場においては容易に起こります。

たとえば先の例のドメインエキスパートは 「ユーザを登録する」と表現している のに、開発者は 「ユーザを新規保存する」 と表現しているような場合がまさにそう です。 同じ操作のことを表現しているのにドメインエキスパートと開発者とで表現 が異なってしまっています。

349

象

図15.5: 名前による認識の共有

開発者の頭の中は常に技術的なことでいっぱいです。 「ユーザの登録」と聞くとす ぐさまリレーショナルデータベースとSQLが頭を過り、 ユーザを登録するという 本質ではなく 「ユーザのデータをデータストアに新規保存する」 という具体的な処 理に集中してしまいます。 これは職責上、 仕方がないことで、 何ら責められるいわ れはありません。

しかしドメインエキスパートと開発者がまったく異なる言葉で会話することは、 意思疎通をする上で大変な障害になりえます。 開発者はドメインエキスパートから 価値あるドメインモデルを引き出す必要があります。 そのためにもドメインエキス パートと同じ言葉で会話をしなくてはなりません。

もちろん開発者同士であっても、 言葉の揺れは問題になります。 たとえば 「ユー ザを登録する」というユースケースに変更が加わったときのことを考えてみましょ う (リスト15.1)。

リスト15.1ユーザを登録する処理はいずこに

public class UserApplicationService

{ } public void Save New (UserSave New Command command); public void Update (User UpdateCommand command); public void Remove (UserRemoveCommand command);

ドメイン駆動設

15

350

クラスの定義を確認しても 「ユーザを登録する」 処理が見当たりません。 もちろ んプロジェクトに慣れ親しんだ開発者であれば、 UserApplicationService.Save Newメソッドが 「ユーザを登録する」 処理であることを知っているので、すぐさま このメソッドの修正に取り掛かることはできます。 しかしプロジェクトに参画した ばかりの開発者であったならば、 「ユーザを登録する」 処理に相当するメソッド名は 見当たらないので、 まずはコードを吟味することから始める必要があります。

このようなわずかな言葉の揺れが小さなストレスとなり、 それが積み重なって膨 大なコストになるのです。 言葉の変換に労力を費やすよりも、もっと本質的なこと に集中する方が有意義です。 開発者同士であっても共通の言語で会話をするに越し たことはないでしょう。

プロジェクトには認識の齟齬や翻訳にコストをかけないためにも共通言語を作る ことが求められます。 そういったプロジェクトにおける共通言語のことをユビキタ ス言語といいます。 ユビキタスは「いつでもどこでも存在する」 といった意味です。 つまり、 ユビキタス言語には、プロジェクトのいたるところで使われなくてはなら ないという意味が込められています。 ドメインエキスパートとの会話はもちろん、 開発者同士の会話においてもユビキタス言語は使われ、 そしてコードにもユビキタ ス言語は現れます。

ユビキタス言語は開発者の言葉ではなくドメインエキスパートの言葉で会話をす ることから、一見すると開発者が譲歩して彼らの言葉で語るように促しているよう に見えますが、それほど単純なものではありません。 ユビキタス言語はプロジェク トのために作られる共通言語であって、 決してドメインエキスパートの言葉をその まま扱うことではないのです。 彼らの言葉はシステムにとって扱いづらいことがあ ります。

もしも会話をするうちに言葉の定義が不正確であったり曖昧であることが発覚し たときには、 より適した表現を探すことになります。 それはドメインエキスパート 側から指摘することもあれば、ときに開発者の指摘により訂正されることもあります。 そうして双方向にユビキタス言語を改良し合うことで、開発者はドメインに対す る理解を深め、 ドメインエキスパートは開発者が欲する知識がどういったものかの 感覚を養っていくのです。

言語は文化です。 お互いの言葉をかみくだき会話を行うための言語基盤を作るこ とは、まさにお互いの文化を知るための交流です。

351

15.3.1 深い洞察を得るために

モデルに対する深い洞察を得るためにはユビキタス言語による会話が重要なファ クターとなります。

私たちは自身の母国語でない言葉で会話を行うとき翻訳を必要とします。 集中す べきはその会話の内容であるにもかかわらず、 その言葉の意味を考えることに躍起 となります。 そこにかけられる労力は大なり小なり必ず存在し、無意識的にコスト を支払っていることになります。 そのコストは同じ言語で会話をしていたのであれ ば、 存在しなかったものです。 通訳はコミュニケーションを停滞させる原因のひと つです。

ユビキタス言語が十分に浸透していない、あるいはまったく使われないプロジェ クトは常に通訳をしている状況です。 ドメインエキスパートは技術的な専門用語や システムのことを理解せず、 独自の専門用語で会話を行い、 開発者たちはその言葉 を自分たちの言葉へ翻訳することに躍起となります。 そこに支払われるコストは如 何ほどのものでしょうか。

議論の背後にあるニュアンスは刹那的なものですが、 ときにそれが重要な概念の ヒントにもなります。 ドキュメントにすら表れないそれを見逃さないために、私た ちは会話に集中する必要があります。 通訳などにかまけている暇はありません。

開発者たちはよくわからないドメインを理解しようと努力をしますが、 ドメイン エキスパートの協力を得られなかった結果として待っているのは中途半端な理解、 あるいは誤解です。 その理解や誤解は開発チームの中で共有され、最終的にはドメ インの概念とは程遠いオブジェクトとして具現化されます。 物語の結末としては大 層笑える悲劇でしょう。

こうした喜劇然とした悲劇を防ぐためにもっとも重要なことは、 双方が同じ国の 言語で会話をしていたとしても、 実は方言で会話をしていることに気づくことで す。 そこに断絶があることを認識することです。

中途半端な理解や誤解はプロジェクトが進むにつれて深刻な問題を引き起こして いきます。 同じコストを支払うのであれば通訳のコストではなく、プロジェクト共 通の言語であるユビキタス言語を策定し、維持することにコストをかけた方がずっ と有意義です。

最初はうまくいかないでしょう。 新しい言語を覚えるときと同様、 ギブスを嵌め られたような感覚になるのも当然です。 しかし、習得しさえすれば、 翻訳を常に行 いながら会話をするときよりもずっと流暢に会話できるようになるのです。

ユビキタス言語を使い会話をしていくと、 ドメインの概念を伝える際に扱いにく

ドメイン駆動設計のとびらを開こう

15

352

い用語や曖昧な言葉に気づくことがあります。 これこそが深い洞察のきっかけで す。どうして扱いにくいのか、何が曖昧なのかといったことを開発者とドメインエ キスパートで指摘し合うことによりモデルはより深い洞察をもって洗練され、 ドメ インの知識を語るようになるのです。

15.3.2 ユビキタス言語がコードの表現として使われる

ユビキタス言語はいたるところで利用されます。 つまり、会話はもちろん、ド キュメントにおいてもユビキタス言語を用いて記述を行い、最終的な成果物である コードにも利用されます。

「ユーザの名前を変更する」 という表現がドメインにとって自然な表現であれば、 「名前を変更する」 という言葉を忠実にコードで表現すべきです (リスト15.2)。

リスト 15.2 ドメインにとって自然な表現をする

public class User { } public void ChangeName (UserName name) { } (･･･略･･･)

もしも開発者が 「変更する」 という自然な表現を無視し、 実装上の仕組みである データの更新に着目してしまった場合、 コードは更新を推し出す形になります(リ スト 15.3)。

リスト 15.3 ドメインにとって不自然な技術的表現をしてしまう

public class User { public void UpdateName (UserName name) { } } (･･････)

35

結果としてUser クラスの定義の上からは「変更する」 という表現は消えてしま います。 このコードと付き合っていくには、ドメインエキスパートが 「名前の変 更"」 と表現するたびに、 開発者は意識的にコード上では 「名前の"更新"」 で表現 されているという変換を行う必要があります。 これほど見通しのよいコードであれ ば問題は起こりづらいですが、もっと深い齟齬 それこそクラス名からして異な るような場合には、 翻訳作業が困難になっていきます。

また、「名前の変更」 というユビキタス言語にしたがって表現していないと、 修正 の正当性を関係者すべてが理解できるというチャンスを失うことになります。 たと えば 「名前の変更」 におけるルールが変更になったとき、 UpdateName を変更し たことの正当性は開発者にしかわかりません。 それが 「名前の変更」 ではなく 「名 前の更新」 だからです。

コードがドメインモデルをそのまま表現できていれば、 ドメインの変化はそのま まコードへ適用できるようになります (図15.6)。 モデルをコードで表現するとき にユビキタス言語を利用することは設計とコードを結びつける大切な作業です。

ドメイン ドメインモデル ドメイン オブジェクト

図 15.6 ドメインの変化がコードへ伝わる

COLUMN

ユビキタス言語と日本語の問題

一般的にプログラムコードであるクラスの定義やメソッドの定義は英数字により 構成されます。 そこで問題になるのが英語と日本語の壁です。

本文中でも出てきた 「ユーザは名前を変更する」 という表現を正確にコードに表 すとリスト 15.4のようになるべきです。

リスト 15.4 ユーザのエンティティを日本語で記述する

public class ユーザ

{

private ユーザ名 name;

public ユーザ (ユーザ名 name)

{

354

this.name = name;

}

public void 名前を変更する (ユーザ名 name) { } if (name == null) throw new ArgumentNullException (nameof(name)); this.name = name;

リスト 15.4のコードはユビキタス言語にしたがったものですが、日本語でコー ディングするのはかなり強烈な制約です。 英数字でないとコードエディタのインテ リセンス(コード補完) の恩恵を受けることができなかったり、 そもそもプログラ ミング言語によってはマルチバイトでの記述が不可能な言語も存在します。

反対にドメインエキスパートに対して英語で会話をするよう要請するというのも 不可能です。 彼らには彼らの業務があります。 そこまでの助力を得ることは難しい でしょう。

結局のところ会話は日本語で行い、 それを英語に翻訳したものをクラス名やメ ソッド名に採用するというのが現実的な妥協案であると考えます。 もちろん、 英訳 として最適なものが何かといった問題はつきまとうことになるのですが。

DDD 15.4

境界付けられたコンテキスト

ユビキタス言語と並ぶほど大きなトピックが境界付けられたコンテキストです。 境界付けられたコンテキストはドメインの国境のようなものです。 国の境を越える と扱う言語が異なるようにドメインにも境が存在し、 その境を越えるとユビキタス 言語は変わることがあります。

ビジネスが一枚岩であることは稀です。 ユビキタス言語を策定しながらビジネス への理解を深めていくと、 同じものを指しながら言葉が少し違ったりすることや、 逆に言葉が同じでありながら意味が少し異なるといった状況に出会います。 これは

355

}

定義が揺れていることを必ずしも示しているわけではありません。 もしそのような 状況に直面したのであれば、 あなたはいま複数のコンテキストの境界に立っている 可能性があります。

たとえばこれまでサンプルにしてきたアプリケーションをベースに考えてみま しょう。 いまアプリケーションにはユーザとサークルの2つのモデルが存在しま す。 ユーザは利用者がソフトウェアを利用し始めるときに必ず登録をする、いわば システム上の分身です。 サークルは趣味を共有するなどの目的をもったグループで す。 ユーザはサークルを作ったり、任意のサークルに所属したりできます。 ここま では問題ありません。

ところでシステムを利用するときのログインはどうでしょうか。 利用者はユーザ としてログインを行うことで、システムの利用を開始します。 ログインの際にはID とパスワードが必要です。 IDについてはユーザ名を代用したりすることもできま すが、 パスワードについては専用のフィールドが必要です。 リスト15.5のコードは User クラスに新たなパスワードの属性を追加し、 認証できるようにしています。

リスト15.5:パスワードの認証ができるようにメソッドを追加する

public class User

private UserName name; private Password password;

public User(UserId id, UserName name, Password password)

{

if (id == null) throw new ArgumentNullException (nameof(id));

if (name == null) throw new ArgumentNullException→

(nameof(name));

if (password == null) throw new ArgumentNullException→ (nameof(password));

{

Id = id;

this.name = name;

this.password = password;

}

356

public UserId Id { get; }

public void Change Name (UserName name)

{

if (name == null) throw new ArgumentNullException(nameof→

(name));

this.name = name;

}

public bool Is Same Password (Password password) { return this.password.Equals (password); } }

パスワードは値オブジェクトでその実態はハッシュ化されたダイジェスト値を保 持し、ダイジェスト値同士の比較を行うことでパスワードが一致しているかの確認 を行います。 ここで問題となるのはパスワードが同じであるかを比較するメソッド をユーザというドメインモデルを表現するUser オブジェクトのふるまいとして定 義すべきかということです。

サークルを作ったり、所属したりするユーザとシステム上のユーザは同じ単語で ありながら、その背景や目的がまったく異なっています。 もともとのユーザの活動 にパスワードという概念はなかったはずです。 これは視点が変わることにより、着 目すべき内容が変わっていることを意味しています。

こうしたとき、 無理に同じオブジェクトに同居させるよう固執する必要はありま せん。 同じ名前でありながら、まったく別のオブジェクトとして定義してしまう方 が素直でしょう (リスト 15.6)。

リスト 15.6 別のオブジェクトとして定義する

namespace Core.Model.Users { public class User {

357

private UserName name;

public User (UserId id, UserName name)

{ if (id == null) throw new ArgumentNullException➡ (nameof(id));

if (name == null) throw new ArgumentNullException➡ (nameof (name));

} Id = id; this.name name;

public UserId Id { get; }

public void ChangeName (UserName name)

if (name == null) throw new ArgumentNullException (nameof➡ (name));

this.name = name;

}

{

}

namespace Authenticate. Model. Users

{

public class User

{

private Password password;

public User (UserId id, Password password)

}

{

358

if (id == null) throw new ArgumentNullException

(nameof(id));

if (password == null) throw new ArgumentNullException→ (nameof(password));

Id = id;

this.password = password;

}

public UserId Id { get; }

public bool Is Same Password (Password password)

{

return this.password.Equals(password);

}

}

同名のクラスを存在させることは不可能ですので、パッケージによって分割しま す。 Core パッケージとAuthenticate パッケージは同じドメイン上にあっても別の システムです。 これによりそれぞれのユーザはまったく別のモデルとして表現する ことが可能になります。

さらにいえばコンテキスト同士は別のシステムですので、同じデータソースを利 用していたとしても、データソースを操作する具体的な技術基盤が異なっていても 構いません。 一方ではSQLを組み立てて直接実行しているのに対して、もう片方 ではORMを利用するといったことも可能です。 こうした構成はレガシーなシステ ムと同居する際によく見られます。

システムが大規模になればなるほど、 統一したモデルを作ることは現実的でなく なってきます。 それでも無理に統一した結果としてできあがるコードは、巨大でし がらみの多いオブジェクトです。 それぞれのコンテキストの事情により複雑化した それは、変化することに強い抵抗を生むでしょう。

変化に対する摩擦を防ぐためには、モデルに対する捉え方が異なる箇所でシステ ムを分割します。 そうしてできあがったそれぞれの領域ごとに言語の統一を目指し ます。 領域を分けることは境界を引くことと同義で、 まさに境界付けられたコンテ キスト (文脈) というわけです。

359

}

DDD 15.5

コンテキストマップ

境界付けられたコンテキストにより細分化することは各コンテキストの理解のし やすさに貢献はしますが、 反対にコンテキストが連なったドメインの全体像をぼや けさせます。ソフトウェアを変化させるために特定のコンテキスト内で改修を行っ ていると、ひとつのコンテキストに集中するあまり、 それ以外のコンテキストとの 関係は見落としがちになります。

たとえばリソースの問題で節約せざるを得ないとき、 Authenticate パッケージ のモジュールを開発するチームがユーザの識別子を現在のUserIdではなく UserName に変更しようとしたときを仮定しましょう。 Authenticate パッケージ のUser はリスト 15.7のように変化します。

リスト 15.7 ユーザ名を識別子とする

namespace Authenticate.Model.Users

{

public class User

{

private Password password;

public User (UserName id, Password password)

{

if (id == null) throw new ArgumentNullException(nameof→

(id));

if (password == null) throw new ArgumentNullException→ (nameof (password));

Id = id;

this.password = password;

}

public UserName Id { get; }

のとびらを開こう

360

15

} } public bool Is Same Password (Password password) { return this.password. Equals (password); }

リスト15.7だけを見たときは問題ないように見えます。 問題はCoreパッケージ User で発生します (リスト 15.8)。

リスト 15.8 Core パッケージも変更しなくてはいけないはずが

namespace Core. Model. Users public class User { private UserName name;

// 識別子はUserIdのまま

public User (UserId id, UserName name)

{

(id));

if (id == null) throw new ArgumentNullException (nameof❤

if (name == null) throw new ArgumentNullException (nameof➡

(name));

Id = id;

this.name = name;

}

public UserId Id { get; }

// 識別子となったUserNameが変更できてしまう

public void ChangeName (UserName name)

{

36

{

if (name == null) throw new ArgumentNullException (nameof→ (name));

this.name = name;

}

}

}

Core パッケージではUserNameを識別子とする修正が行われていません。 その ため Authenticateパッケージを取り扱うチームの修正はCoreパッケージに伝わ らず、 Userの仕様が異なってしまっています。 コンテキストが分けられた結果、 そ れ以外のコンテキストに対する影響を失念していたのです。

こういった混乱を避けるために、 コンテキスト同士の関係を定義し、 ドメイン全 体を俯瞰できるようなものとしてコンテキストマップを作る必要があります (図 15.7).

Circle User User Core Authenticate

図15.7: Core パッケージとAuthenticate パッケージのコンテキストマップの一例

開発者はコンテキストマップを確認して、 モデル同士の関係性を把握しながら開 発を行っていきます。

15.5.1 テストがチームの架け橋に

システムが大きくなるにつれて、 開発チームも段々と大きくなっていきます。 す すべての開発者が均等に巨大なドメインに対峙するのは効率的でないため、チームは 分割される必要があります。 境界付けられたコンテキストはチームの輪郭になるで しょう。

362

自身のコンテキストにおいて変更が必要になったときにはコンテキストマップを 確認し、 もしも隣接するコンテキストに影響があるようであれば、該当するコンテ キストを管理するチームと交渉を行う必要があります。

場合によっては一方の管理するコンテキストのモジュールに変更を加えて提供し てもらう必要がある場合もあり、 コンテキスト同士の関係は上流と下流に分かれる こともあります。 この関係性は上流のチームに余裕があれば問題はありませんが、 たとえば他にも下流となる多くのチームを受けもち、 そこからの要望を捌ききれな かったりすると問題になります。 きば

上流チームは基本的に自分たちがクリティカルパスであることを認識しており、 下流チームの要望を叶える必要があることも認識しています。 しかし、現実問題と して作業する人員が不足していたとしたら複数のチームの要望を同時に満たすこと はとても困難です。 こうしたとき、 2つのチームを繋ぐ架け橋はテストです。

つまり、下流チームは上流チームと協力して、 期待する仕様のテストを作り上げ るべきです。 上流のチームはテストを実行することで、仮に修正による影響が意図 せず破壊をしたとしても、テストがそれを検知することで上流のチームはその例外 に気づくことができます。

理想は下流のチームが上流を意識せず集中できるようにすることです。 さもなけ れば継続的なモデルの変更を行うなど夢のまた夢なのです。

もしもあなたがプロバイダならクライアントに対して協力を要請してください。 もしもあなたがクライアントならプロバイダに対して協力を表明してください 2 つのチームを繋げるものはテストです。

DDD 15.6

ボトムアップドメイン駆動設計

ものごとに対するアプローチはトップダウンとボトムアップの2種類がありま す。 ドメイン駆動設計は果たしてどちらでしょうか。

筆者はドメイン駆動設計はボトムアップのアプローチであると捉えています。 ドメイン駆動設計においてはドメインが主役です。 何のソフトウェアを作るのか は二の次です。 実際にドメイン

判断したものが、問題を紐解 いていった結果、 見当違いであると判明することもあります。 作るものありきでな く、 まずは問題を紐解くことから始めるアプローチは、まさにボトムアップである といえます。

エキスパートが必要と

オトムアップトメイン

363

H

本書のアプローチもまたボトムアップです。 ドメイン駆動設計の構成する要素の うち、もっとも根底にあるものからひとつひとつ解説してきました。 そして、その 解説自体も、トップダウンにそれが何であるかを紹介するのではなく、 必ずそこに ある問題を提示し、紐解く作業を添えています。 本書はドメイン駆動設計のパター ンを伝えると同時に、 その実践の手本として、 新たな知識との向き合い方を伝えて いるのです。

ある知識を得るために、 前提となる知識が必要となることは多くあります。 なる ほど知識は連鎖するものです。 ボトムアップに知識を積み上げていけば、 必ずや理 解へ到達することでしょう。

DDD 15.7

まとめ

本書で解説してきたようにボトムアップにドメイン駆動設計を実践するだけでも コードは驚くほど見違えたものになります。 その先には輝かしいソフトウェアの発 展が待ち受けているでしょう。

ドメイン駆動設計の目的はドメインとコードがモデルを通して繋がり、 反復的に 改善を行っていくことです。 決してパターンに盲目的にしたがうことではありませ ん。 利用者にとって真に役立つソフトウェアを開発するためには、まずソフトウェ アの利用者のことを知ることです。 ドメインにおける問題はドメインの世界を知ら ない限り、 本当に理解することは叶いません。

この章で紹介した 「ユビキタス言語」 や 「境界付けられたコンテキスト」などの 解説は概要だけにとどめています。 なぜならそれを語るのは筆者の役目ではないか らです。

この書籍を読んでドメイン駆動設計を身近に感じ、さらなる高みを目指したいと 感じたのであれば、是非とも 「エリック・エヴァンスのドメイン駆動設計」 を手に 取ってみてください。 そこにあるのはひとりの開発者の物語です。 本書で説明しな かった多くの想いはエリック自身の言葉から受け取ってください。

あなたの目の前のとびらに鍵は存在しません。 いまこそドメイン駆動設計のとび らを開くときです。

計のとびらを開こう

15

364

D Appendix

ソリューション構成

ソリューション構成は最初に決定しなくてはいけない ことながら、 悩みどころでもあります。 本書で学んだ ことをいますぐ実践するためには、このハードルを乗 り越える必要があります。

本付録ではレイヤードアーキテクチャを例に取り、 ど のようなソリューション構成にしてそれぞれのレイ ヤーを配置していくかについて解説していきます。

APP

12

14

20

15

9

ソリューション構成を紹介します。

B

DDD ソフトウェア開発の 最初の一歩 A1

ソフトウェアを開発するにあたって、 まず最初にしなくてはいけない作業はソ リューションの構成を決めることです。 しかしながら、ソリューション構成は悩み どころです。 なぜなら、ここでの決定はそのプロダクトを手放さない限り長い付き 合いになるからです。

もちろん、 開発者はリファクタリングに対して前向きです。 しかし、プロジェク トをまたがるリファクタや、プロジェクト構成自体を変更するリファクタには抵抗 を感じることも否めません。 それゆえ、ソリューション構成を決めることは重大に 感じられてしまうのです。

こうした事情から、 開発者はソリューション構成を決定することに慎重になって います。 そこでこの付録では、 皆さんの背中を押す意味を込めて、 ソリューション 構成を決める際の考慮事項と具体的なソリューション構成について提示していきま す。

COLUMN

C#特有のプロジェクト管理用語

Visual Studio でC#を使ったプログラム開発を始めると、最初にプロジェクトと ソリューションが作られます。

プロジェクトはプログラムを作るために必要なファイルを管理するもので、 実際 のソースコードや画像などのリソースが収められます。

ソリューションはそれらのプロジェクトを束ねて管理するものです。

Javaに置き換えて説明するなら IntelliJ IDEAのプロジェクトがソリューション に相当するもので、 モジュールがプロジェクトです (Exlipseではそれぞれワーク スペースとプロジェクト)。

4つのレイヤーのパッケージ構成

本付録では第14章 「アーキテクチャ」 で紹介したレイヤードアーキテクチャを例 にパッケージ分けを考えていきます。

ここで例にするレイヤードアーキテクチャは次の4つのレイヤーで構成されてい ます。

366

プレゼンテーション アプリケーション . ドメイン インフラストラクチャ

ソリューション構成について考える前に、まずはそれぞれのパッケージ構成を確 認していきましょう。

なお、プレゼンテーションレイヤーは ASP.NET Core MVCのプロジェクトに なるのでパッケージ構成の解説は割愛します。

A.1.1 ドメインレイヤーのパッケージ構成

最初に確認するのはもっとも気になるであろうドメインレイヤーです。 このレイ ヤーでは技術的なライブラリに対する依存はしません。

図A.1はドメインレイヤーのパッケージ構成図です。

B 日 Domain Circle Circleld CircleName Models Circles ICircle Recommended Repository CircleSpecification 0 Users User Userid UserName IUser Repository IUser Factory Services User Service Shared Specifi cation

A.1: ドメインレイヤーの構成

A.1ではルートパッケージはDomainとなっていますが、 実際には境界付けら れたコンテキストの名称になるでしょう。 ドメインレイヤーのパッケージ構成は大 きく3種類に分けられます。

1つ目のDomain. Model パッケージはドメインオブジェクトが配置されます。 集約を構成するエンティティや値オブジェクトはもちろんのこと、 集約の生成を担 うファクトリやリポジトリ 仕様もここに所属します。

367

Model直下のパッケージ名が CirclesやUsers といったように複数形になってい るのは、 C#ではクラス名と名前空間 (パッケージ名) が衝突することが許されて いないため (*1)です。 C#以外のクラス名と名前空間が同じ名前でも問題が起きない プログラミング言語では単数形にすることが多いです。

ところで、ファクトリやリポジトリがエンティティや値オブジェクトといったド メインオブジェクトのパッケージに同居することに驚いたでしょうか。 パッケージ 分けをする際に、 属性に着目するとDomain. FactoriesやDomain.Repositories といったパッケージを準備することを思いつくこともあります。 しかし、それはあ まりよい考えではありません。

たとえば同じ切るものであるからといって、 カッターと包丁を同じ戸棚にしまっ ておくでしょうか。 同じすくうものであるからといって、 レードルとスコップを同 じ引き出しにしまっておくでしょうか。 属性に着目したパッケージ分けには、これ と同種のおかしさがあります。

User にはファクトリやリポジトリがあります。 ファクトリでオブジェクトは作 成され、 リポジトリでオブジェクトは再構築されます。 Userのコンストラクタは必 ずファクトリやリポジトリによって呼び出されることを想定しています。 そのこと を後続の開発者に気づかせるヒントとするために、 Userのファクトリやリポジト リはUser と同居する必要があるのです。

常にそれが正しいことではありませんが、パッケージを分ける際には属性に着目 するのでなく、意味的なまとまりを意識するとよいでしょう。

また、ファクトリやリポジトリと同じ理由で仕様もドメインオブジェクトと同居 します。 仕様が多くなってくるようになったらDomain.Model.Circles.Specification といったように Circles直下に専用パッケージを作ってもよいでしょう。

次にDomain.Service パッケージの解説です。 これはドメインサービスが配置さ れるパッケージです。

サービスオブジェクトは複数種のドメインオブジェクトを操作することがありま す。 そのため、 中立的なDomain.Serviceパッケージに配置しています。 ただし、 UserService はUserクラスと密接に関わるサービスオブジェクトですので、 Domain.Model.Usersパッケージに含める選択肢は考慮の余地があります。

残りのDomain. Shared パッケージは必ずしも必要になるわけではありません。 A.1でこのパッケージに配置されているISpecificationは他のプロジェクトで も利用できるものです。 共通プロジェクトとして括り出してしまい、 Domain パッ ケージがそれに依存する形に仕立てることも可能です。

厳密には衝突しても問題ありませんが、 修飾名が必要になってしまいます。

68

1

A.1.2 アプリケーションレイヤーのパッケージ構成

アプリケーションレイヤーのパッケージ構成は A.2です。

0 Application Circles CircleApplication Service CircleGetCommand Users CircleCreateCommand CircleGetResult UserApplicationService UserGetCommand UserCreateCommand UserGetResult

図A.2 アプリケーションレイヤーのパッケージ構成

コマンドオブジェクトなどを利用するために、 アプリケーションサービスごとに パッケージを分けています。 パッケージ内部のファイルが多くなりすぎる場合には 直下にパッケージを作って整理することを考慮します。

なお、 第14章 「アーキテクチャ」 で紹介したクリーンアーキテクチャのように ユースケースごとにクラスを分けた場合は図A.3の構成になります。

Circles Application Create CircleCreate CircleCreate CircleCreate InputPort Interactor InputDatas Get ICircleGet InputPort CircleGet Interactor CircleGet InputData CircleGet OutputData CircleDut 0 Users Create IUserCreate UserCreate UserCreate InputPort Interactor

図A.3 クリーンアーキテクチャに寄せた構成

A.1.3 インフラストラクチャレイヤーのパッケージ構成

インフラストラクチャレイヤーのパッケージ構成図は図A.4です。

EF Circles EFCircleRepository Users EFUserRepository EFUserFactory InMemory Circles InMemoryCircle Repository 目 Users InMemoryUserRepository InMemoryUserFactory

A.4 インフラストラクチャレイヤーパッケージ構成

インフラストラクチャはベースとなる技術基盤ごとにパッケージを分けています が、同一のパッケージにする選択肢もあります。

DDD A.2 ソリューション構成

各レイヤーのパッケージ構成を確認したところで、 いよいよ

ソリューション構成 について確認していきましょう。

ソリューション構成を決めていくにあたって、 方針は大きく次の3つに分かれます。

1. すべてをひとつのプロジェクトにする

2. すべてを別のプロジェクトにする

3. アプリケーションとドメインだけ同じプロジェクトにする

この中で推奨したいのは2と3ですので、 本付録ではこれら2つを掘り下げて確 認していきます。

ソリューション構成

APP

370

A.2.1 すべてを別のプロジェクトにする

すべてを別のプロジェクトにしたときのソリューション構成は図A.5です。

ソリューションエクスプローラー プローラー(Card ソリューション「Solution' (5 プロジェクト) EFInfrastructure InMemoryinfrastructure Presentation SnsApplication SnsDomain

A.5 インフラストラクチャパッケージの構成

このパッケージ構成はドメインレイヤーの再利用を考慮しています。 Sns Domain パッケージは他のプロジェクトからも参照できるので、そこに含まれるオ ブジェクトを再利用して新たなアプリケーションを作ることが可能です。

その反面、アプリケーションサービスとドメインオブジェクトが別のプロジェク トになるため、リストA.1のようにドメインオブジェクトのメソッドをpublic にし て公開する必要があります。

リスト A.1: ドメインオブジェクトのメソッドがpublicになる

public class User {

(---88---)

public void ChangeName (UserName name)

(･･･略･･･)

{

}

}

メソッドの公開範囲が広がると、 本来アプリケーションサービスで呼び出される ことを想定したメソッドがどこか他のところで呼び出せるようになります。そのた め、本来アプリケーションサービスに記述されるべきコードがプレゼンテーション レイヤーに分散してしまうこともあるでしょう。

L

37

もちろんレイヤーをまたぐデータの受け渡しをする際に、 確実にDTOに詰め替 えを行うことでそれは防げます。 しかし、 可能であればシステマチックに避けたい ところです。

A.2.2 アプリケーションとドメインだけ同じプロジェクトにする

ドメインオブジェクトのメソッドを呼び出せるクライアントはアプリケーション サービスに限定する。 そんな願いを叶えるのがアプリケーションとドメインだけ同 じプロジェクトにする選択肢です (図A.6)。

ソリューションエクスプローラー ソリューションエクスプローラーの検索 ソリューション 'Solution' (4 プロジェクト) D A KOEFInfrastructure InMemoryInfrastructure Presentation SnsApplication 2依存關係 Application ▷ Domain 4 x

A.6 アプリケーションとドメインだけ同じプロジェクトにする

この構成であればリストA.2のように internal 修飾子を使うことで、 公開範囲を 狭められます。

リスト A.2: internal 修飾子を使う

public class User { } (･･･略･･･) internal void ChangeName (UserName name) { (------) }

internal の公開範囲は同一プロジェクトです。 別のプロジェクト (図A.6でいう EFInfrastructure や In Memory Infrastructure, 及び Presentation) からはアクセ

372

スできません。

この構成であれば、 意図せぬメソッド呼び出しを防止できるでしょう。ただし、 プロジェクト内に定義されているドメインオブジェクトをそのまま再利用して別の アプリケーションを構築することはできなくなります。

A.2.3 言語機能が与える影響

プログラミング言語にはそれぞれ特色があり、 その特色がパッケージ構成に影響 を与えることがあります。

たとえばJavaではアクセス修飾子を付けないとパッケージプライベートと呼ば れる公開範囲になります。 C#のinternalは同一プロジェクトであればどこからで もアクセスできましたが、 パッケージプライベートはそれより狭い同一パッケージ に限定します。 そのため、 本付録で紹介した internal を使ったアクセス制限のアプ ローチとはまた異なったやり方になります。

またScalaには限定子と呼ばれる機能があります。 これはprivate [A] とすること で、 非公開でありながらAとその派生型からのアクセスを許可できる機能です。 こ れを活用するとC#のintemalよりもきめ細かいアクセスの制御ができます。

プログラミング言語の特性はパッケージ構成を左右します。 パッケージ構成に決 定版はありません。 本付録の例はあくまで一例です。 参考にしてもよいですし、 まったく別の構成を検討しても構いません。 いずれにせよ、なぜその構成を選択す るのかの理由付けだけは行うようにしてください。

DDD A.3

まとめ

開発者はコードに美しさを感じると同時に、 構造にも美しさを見出すことのでき る生き物です。 考え抜かれたソリューション構成には美しさが宿ります。

後続の開発者にヒントを与えたり、 意図せぬ呼び出しの危険性を減らすために、 プログラミング言語と相談しながらソリューション構成を決めることは、開発者の 楽しみのひとつです。

コードを配置する場所とその理由を自問自答しながら、最適なソリューションの 構成を導き出すよう心がけていくことをお勧めします。

参考文献

「エリック エヴァンスのドメイン駆動設計』 (翔泳社) 「実践ドメイン駆動設計』 (翔泳社) 『Clean Architecture 達人に学ぶソフトウェアの構造と設計』 (アスキードワンゴ)

INDEX

あ

アーキテクチャ

アクセス修飾子 值

アルファベット

AOP

値オブジェクト

ASP.NET

237

185

Aspect Oriented Programming

010, 015, 016, 018, 028,049,086

237

027

アプリケーションサービス

010, 113, 114, 144, 153 った代入 040

C#

CLI

Segregation

180, 181

Command Query Responsibility

アンチパターン

313

Command-query separation

依存

依存關係。 159, 168, 172, 186 依存関係逆転の原則 165

Commit メソッド

313

CQRS

239

イテレーティブ

祈り信者のテスト理論

313

Data Transfer Object

313

インスタンス

Dependency Injection パターン

122

175

か

317

003

122,280 016,018

会計システム 下位レベル カプセル化 可変

165, 166

220

049

凝集度

144, 147

309

クエリ

017,021, 152

クラス

322, 338

クリーンアーキテクチャ

318

軽量DDD

160, 161

結果整合性

344

ゲッター

祈り

インスタンス生成の処理

034,086

インスタンスの永続化処理 インスタンス変数

Dependency Inversion Principle)

インターフェース

165

インフラストラクチャ

DTO

122

Entity Framework

Globally Unique Identifer - 207

180

315

交換

033

107,219

100

更新

022

コマンドオブジェクト

099

132

コマンドラインインターフェース

180, 181

211

コミット処理

227 コレクション

273

コンストラクタ コンテキスト

092, 152

233

インフラストラクチャレイヤー

永統化

GUI

loC Container

GUID

207, 208

エラー

IoC Container パターン

184

エリック・エヴァンスのドメイン 駆動設計 001

169, 175

エンティティ

コンテキストマップ

MVC フレームワーク

NoSQL データベース 077,091

094

108,227

185

コントローラ

010, 047, 049, 058,086

272

175

オーバーライド

Service Locator パターン

078

null

オブジェクト自身

169, 170

290

356

360

SQL

094

Webアプリケーション 194

コンテナ

370

034

191,195

コントロール コンパイラ

043, 133

159, 168

オブジェクト同士の依存 オブジェクトの生成

Web GUI

180

039

コンパイルエラー

176

273

コンポジション

285

102

さ

サークル機能

253

オブジェクトリレーショナルマッ バー 104

160

206

127

サークル集約 サービス 再構築

採番処理

識別子

281

066, 155

053, 207

109

207

374

ドメインサービス

010, 065,066, 091

メソッドのシグネチャ

ドメインサービスの濫用 ドメインの概念

ドメインの概念+DomainServic

ドメインの概念 + Service ドメインのルール

モジュール

082

ドメインモデル

入庫

161,165

文字列型

082

モチベーション

028

267 モデリング

004

モデル

345

ドメインレイヤー

トランザクション

自動採番機能 重複確認 214 260 集約 010, 268 出庫 仕樣 080 010, 293, 297, 302, 304 上位レベル 165, 166 上限チェック 271 状態 156 シングルトン 182 シングルトンパターン 182 スーパークラス 248 スタートアップスクリプト 整合性 183 224, 235 セーフティネット 052 セッター 107,215 属性 027 ソフトウェア開発 009,366 ソフトウェアシステム ソリューション構成 179 370 た 退会处理 代入 134 040 遅延实行 314 致命的な不具合 225 抽象 166 直接インスタンス化したオブジェ クト 273 ディープコピー 102 データストア 086,091 データストレージ 106 データ転送用オブジェクト 122 データの整合性 223 データベースコネクション 233 テスト 098 テストの維持 173 テスト用のリポジトリ 100 デバッグ用 188 デメテルの法則 274 同一性 055 等価性 023 ドキュメント性 060 ドメイン 003 ドメインエキスパート 345 ドメインオブジェクト

367

漏れ出したルール

トランザクション処理

トランザクションスコープ

トランザクションの開始

な

231

は

バグ

パターン

263

235

235

ユーザID

233

ユーザーインターフェース ユーザ登録処理

226, 234

パッケージ

080

ユーザエンティティ

ユーザ作成処理

ユーザ情報取得処理 ユーザ退会処理

ユーザ登録処理

075,090

ユーザ情報更新処理

136, 142

120, 127

148, 150

パフォーマンス問題

パラメータ

041

引数として渡されたオブジェクト

表現力

ファクトリ

不正な値

物流拠点のふるまい 物流システム

不要条件

不要

メソッド

070

082

036

005

035

010

152

138, 149

ユーザの重複

ユーザ名

ファクトリの存在

不自然なふるまい

ふるまい

307

138

ユーザ登録処理

131

039

ユースケース

010, 205, 206

073, 115, 258

273

輸送ドメインサービス ユニークキー制約

067

不変のメリット

プロダクション用

分散トランザクション 236

ヘキサゴナルアーキテクチャ

037

213

ユニットオブワーク ユニットテスト

228, 230

ユビキタス言語

239, 241

180, 195

349,355

039

079

002, 079

ライフサイクル リードモデル

047,058

019

271 リポジトリ 010,085,086,087,

プログラミング 016,019

021

033,056, 156

309

091,092,096

リレーショナルデータベース

076,089,091

ボトムアップドメイン駆動設計

ポリモーフィズム

007, 048, 087, 115

188

130

180

073

030

ルールの流出

322, 334

例外

ドメイン駆動設計

001

135

133

レイヤードアーキテクチャ

363

218

ま

レベル

322, 325

ロールバック

ロック

766

246

289

196

ルール

220

081

375

D Profile D

長崎県立 2.5.15 長崎國書館

著者プロフィール

成瀬 允宣 (なるせまさのぶ)

岐阜県出身。 ブログラマ。 プログラミングにはじめて触れたのは25歳のとき。 業務システム開発からキャリアをはじめ、 ゲーム、 Web と業種を変えながらも アプリケーション開発全般に従事。 好きな原則はDRY原則。 趣味は車輪の再開発。

装丁本文デザイン 大下 賢一郎 装丁写真 iStock.com:Imam Fathoni DTP 株式会社シンクス 編集協力 佐藤 弘文 検証協力 村上 俊一

ドメイン駆動設計入門 ボトムアップでわかる! ドメイン駆動設計の基本

2020年 2月13日 初版第1刷発行

2020年 3月10日 初版第2刷発行

著者 成瀬宣 (なるせ・まさのぶ) 発行人 佐々木 幹夫 発行所 印刷製本 株式会社翔泳社 (https://www.shoeisha.co.jp) 株式会社シナノ

©2020 MASANOBU NARUSE

※本書は著作権法上の保護を受けています。 本書の一部または全部について(ソフトウェアおよびプログラムを含む)、株式 会社翔泳社から文書による許諾を得ずに、いかなる方法においても無断で複写、複製することは禁じられています。 ※本書へのお問い合わせについては、ページに記載の内容をお読みください。 ※落丁・乱丁の場合はお取替えいたします。 03-5362-3705 までご連絡ください。

ISBN978-4-7981-5072-7 Printed in Japan

翔泳社の

ドメイン駆動設計の関連書 大好評

発売中!

エリック・エヴァンスの

ドメイン駆動設計

ソフトウェア

エリック・エヴァンスの ドメイン駆動設計

エリック・エヴァンス [著]

ユーサ要求の問題解決に フォーカスした設計パターン

牧野祐子、 和智右桂 [訳] 今関剛 [監訳]

定価:本体5,200円+税 ISBN: 978-4-7981-2196-3

実践ドメイン駆動設計

する

実践ドメイン駆動設計

経験が常に正しいとは 限らない。

ヴァーン・ヴァーノン [著]

高木正弘[訳] 定価:本体5,200円+税 ISBN: 978-4-7981-3161-

本書購入特典の情報はこちらから!

https://www.shoeisha.co.jp/book/present/9784798150727/

無料 翔泳社IDにぜひ登録を!!

SHOEISHA ID

会員限定の読者付録 (一部書籍を除く) の ほか お得な情報やプレゼントのご案内な ど、さまざまな特典をご利用いただけます。 [翔泳社の本 登録 Q 検索

https://www.shoelsha.co.jp/book/id/