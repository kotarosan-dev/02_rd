---
name: ddd-tactical-pattern-catalog
description: ドメイン駆動設計（DDD）の戦術的パターンカタログ。値オブジェクト、エンティティ、リポジトリ、サービス、集約、仕様など、DDDの主要な構成要素を段階的に整理し、設計判断の指針を提供する。
---

# DDDパターンカタログ：戦術的パターンの実践ガイド

## 概要

ドメイン駆動設計（DDD）の戦術的パターンを体系的に整理したカタログ。「知識を表現するパターン」「アプリケーションを実現するパターン」「発展的なパターン」の三層に分類し、各パターンの目的・構造・適用判断の指針を提供する。

## 使用場面（When to Use）

- 新規システムの設計においてドメインロジックの構造を決定するとき
- 既存システムのリファクタリングでビジネスロジックの責務を再配置するとき
- チーム内でDDDパターンの共通理解を確立するとき
- コードレビューにおいて設計判断の妥当性を評価するとき
- レガシーコードへのDDD段階的導入の計画を立てるとき

## 層1：知識を表現するパターン

### 値オブジェクト（Value Object）

**目的**: ドメインの概念を「値」として表現し、ビジネスルールをオブジェクト内に閉じ込める

**特性**:
- 不変（Immutable）: 一度生成されたら変更不可
- 等価性による比較: IDではなく、保持する値の組み合わせで同一性を判定
- 交換可能: 変更したい場合は新しいインスタンスを生成

**適用判断**:
| 条件 | 値オブジェクト | プリミティブ型 |
|------|--------------|--------------|
| バリデーションルールがある | 使う | 使わない |
| ドメイン固有の振る舞いがある | 使う | 使わない |
| 同じ意味の値が複数箇所で使われる | 使う | 使わない |
| 単なるフラグやカウンタ | 使わない | 使う |

**典型例**: ユーザー名、メールアドレス、金額、住所、電話番号

**設計のポイント**:
- コンストラクタでバリデーションを実行（不正な値のインスタンスを許さない）
- setterを公開しない（不変性の保証）
- 振る舞い（メソッド）をオブジェクトに持たせる（例：Money.add(Money)）

### エンティティ（Entity）

**目的**: ライフサイクルを持ち、同一性（Identity）で識別されるドメインオブジェクトを表現する

**特性**:
- 同一性による比較: 属性が変わってもIDが同じなら同一オブジェクト
- 可変（Mutable）: 属性は変更可能だがIDは不変
- ライフサイクルを持つ: 生成・変更・削除のライフサイクルが存在

**値オブジェクトとの判断基準**:
| 質問 | エンティティ | 値オブジェクト |
|------|------------|--------------|
| 属性が同じでも区別する必要がある？ | Yes | No |
| ライフサイクルを通じて追跡が必要？ | Yes | No |
| 属性が時間とともに変化する？ | Yes | No |

**典型例**: ユーザー、注文、商品、従業員

**設計のポイント**:
- IDの生成戦略を明確にする（UUID、DB採番、ドメイン固有ルール）
- 属性の変更は意味のあるメソッド名で表現する（setName()ではなくchangeName()）
- 不変条件（invariant）をエンティティ内で保証する

### ドメインサービス（Domain Service）

**目的**: 特定のエンティティや値オブジェクトに属さないドメインロジックを表現する

**適用判断**:
- 「この処理はどのオブジェクトに置くべきか」の答えが見つからないとき
- 複数のドメインオブジェクトにまたがるロジック
- エンティティに置くと不自然な処理

**典型例**: ユーザー名の重複チェック、送金処理（口座A→口座B）、マッチングロジック

**注意**:
- ドメインサービスの濫用は「ドメインモデル貧血症」を招く
- まずエンティティ・値オブジェクトに置けないか検討し、最後の手段としてドメインサービスを使う
- ドメインサービスは状態を持たない（ステートレス）

## 層2：アプリケーションを実現するパターン

### リポジトリ（Repository）

**目的**: ドメインオブジェクトの永続化と再構築の責務を分離する

**構造**:
```
[アプリケーションサービス] → [リポジトリインターフェース]
                                    ↑ 実装
                         [DBリポジトリ] / [インメモリリポジトリ]
```

**基本メソッド**:
| メソッド | 責務 |
|---------|------|
| find(id) | IDによるオブジェクトの取得 |
| save(entity) | オブジェクトの永続化（新規・更新） |
| delete(entity) | オブジェクトの削除 |

**設計のポイント**:
- インターフェースはドメイン層に定義、実装はインフラ層に配置
- コレクションのように振る舞う（永続化の詳細を漏らさない）
- テスト用にインメモリ実装を用意する
- 1集約につき1リポジトリが原則

### アプリケーションサービス（Application Service）

**目的**: ユースケースを実現し、ドメインオブジェクトのオーケストレーションを行う

**責務**:
- ドメインオブジェクトの取得（リポジトリ経由）
- ドメインオブジェクトへの操作の委譲
- ドメインオブジェクトの永続化（リポジトリ経由）
- トランザクション管理

**設計のポイント**:
- ビジネスロジックを書かない（ドメインオブジェクトに委譲）
- DTOを入出力に使い、ドメインオブジェクトを外部に公開しない
- 薄く保つ（fat serviceはドメインモデル貧血症のサイン）

### ファクトリ（Factory）

**目的**: 複雑なオブジェクトの生成ロジックを分離する

**適用判断**:
- オブジェクトの生成過程が複雑な場合
- 生成に他のオブジェクトやサービスが必要な場合
- コンストラクタだけでは表現しきれない生成ルールがある場合

**注意**: 生成が単純な場合はコンストラクタで十分。ファクトリの過剰な使用は複雑さを増す

## 層3：発展的なパターン

### 集約（Aggregate）

**目的**: データの整合性を保つためのトランザクション境界を定義する

**構造**:
```
[集約ルート（Aggregate Root）]
    ├── [エンティティA]
    ├── [エンティティB]
    └── [値オブジェクトC]
```

**ルール**:
1. 外部からのアクセスは集約ルートを通じてのみ行う
2. 集約内の不変条件はトランザクション内で常に保証される
3. 他の集約への参照はIDのみで保持する（直接参照しない）
4. 1つのトランザクションで変更する集約は1つだけ

**集約の境界設計チェックリスト**:
- [ ] この集約は小さいか？（大きすぎないか）
- [ ] 集約内のすべてのデータは同時に整合性を保つ必要があるか？
- [ ] 集約ルートを通じたアクセスが自然か？
- [ ] ロック競合が問題にならない粒度か？

### 仕様（Specification）

**目的**: 複雑なビジネスルール（条件判定）をオブジェクトとして表現する

**適用場面**:
- 検索条件が複雑で、リポジトリのメソッドが増殖する場合
- 同じ条件判定がバリデーションとフィルタリングの両方で使われる場合
- 条件の組み合わせ（AND/OR/NOT）が必要な場合

**典型例**: 「プレミアム会員で、過去30日以内に購入があり、特定地域に住んでいる」

## 依存関係のコントロール

### 依存関係逆転の原則（DIP）

**原則**: 上位モジュール（ドメイン層）は下位モジュール（インフラ層）に依存しない。両者は抽象（インターフェース）に依存する。

**レイヤー構成**:
```
[プレゼンテーション層]  → UIやAPI
       ↓
[アプリケーション層]    → ユースケース
       ↓
[ドメイン層]           → ビジネスロジック（中心）
       ↑
[インフラ層]           → DB、外部API、フレームワーク
```

**ポイント**: ドメイン層が最も安定した層であり、他のどの層にも依存しない

## 段階的導入ガイド

### Phase 1: 値オブジェクト導入（低リスク・高効果）
1. 既存コードでプリミティブ型が使われているドメイン概念を列挙
2. バリデーションルールが存在するものを優先的に値オブジェクト化
3. 値オブジェクトのユニットテストを記述

### Phase 2: リポジトリ分離（テスタビリティ向上）
1. データアクセスが直接記述されている箇所を特定
2. リポジトリインターフェースを定義
3. 既存のデータアクセスコードを実装クラスに移行
4. インメモリ実装を追加しテストを記述

### Phase 3: ドメインサービス・アプリケーションサービス整理
1. サービスクラス内のビジネスロジックをドメインオブジェクトに移動
2. アプリケーションサービスをオーケストレーションに特化
3. DTOによる入出力の分離

### Phase 4: 集約の境界設計
1. エンティティ間の整合性要件を分析
2. 集約の境界を決定（小さく保つ）
3. 集約間の参照をIDベースに変更

## 注意点

- DDDの戦術的パターンは「手段」であり「目的」ではない。ドメインの理解が先にある
- すべてのプロジェクトにDDDが必要なわけではない。ドメインの複雑さが十分にある場合に効果を発揮する
- 戦略的パターン（ユビキタス言語、境界づけられたコンテキスト）はこのカタログの範囲外だが、DDDの神髄はそちらにある
- チーム全体でパターンの理解を共有することが、導入成功の前提条件となる
