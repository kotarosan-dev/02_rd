bject riented

SELECTION

Patterns of Enterprise Application Architecture

エンタープライズアプリケーション

アーキテクチャパターン

頑強なシステムを実現するためのレイヤ化アプローチ

マーチン・ファウラー 著 長瀬嘉秀 監訳 株式会社テクノロジックアート 訳

長崎県立長崎図書館 TEL 095-826-5257 1116230542

SHOEISHA

SE



Object

SELECTIO

riented

Patterns of Enterprise Application Archit エンタープライズアプリケーシ アーキテクチャパタ

頑強なシステムを実現するためのレイヤ化アプローチ

マーチン・ファウラー 長瀬真秀 株式会社テクノロジックアート

本書内容に関するお問い合わせについて

このたびは社の書をお買い上げいただき、誠にありがとうございます。 弊社では、読者の皆様からのお 問い合わせに適切に対応させていただくため、以下のガイドラインへのご協力をお願い致しております。 下記 項目をお読みいただき、手順に従ってお問い合わせください。

ご質問される前に

弊社Webサイトの「正」や「出版物Q&A」をご確認ください。 これまでに判明した正義や追加情報 過去の お問い合わせへの回答(FAQ) お問い合わせ方法などが掲載されています。 正調表 http://www.neshop.com/book/errata/

出版物 Q&A

http://www.weshop.com/book/qa/

ご質問方法

Webサイトの専用フォームサイト(http://www.seshop.com/book/qa/) をご利用ください。 お電話や電子 メールによるお問い合わせについては、原則としてお受けしておりません。

※質問専用シートのお取り寄せについて

WEBサイトにアクセスする手段をお持ちでない方は、ご氏名、ご送付先 (ご住所/郵便番号/ 電話番号または FAX番号 電子メールアドレス) および 「質問専用シート送付希望」と明記のうえ、 電子メール (qatorm@shoeisha.com) FAX、郵便 (80円切手をご同封願います)のいずれかにて “編集部読者サポート係” までお申し込みください。 お申し込みの手段によって、折り返し質問シートをお送りいたします。 シートに必 れなく記入し、 "編集部読者サポート係までFAXまたは郵便にてご返送ください。

回答について

ご質問いただいた手段によってご返事申し上げます。 ご質問の内容によっては、回答に数日ないし それ以上の期間を要する場合があります。

ご質問に際してのご注意

本書の対象を越えるもの、 記述個所を特定されないもの、また読者固有の環境に起因するご質問等にはお答 えできませんので、予めご了承ください。

郵便物送付先および FAX番号

送付先住所: 〒 160-0006 東京都新宿区舟町5

FAX番号: 03-5362-3818

(株)翔泳社出版局編集部読者サポート係

本書に記載されたURL等は予告なく変更される場合があります。

本書の出版にあたってはにつとめましたが、著者、訳者、監訳者 出版社などのいずれも、本書の内容に対してなん 証するものではなく、内容やサンブルに基づくいかなる運用結果に関してもいっさいの責任を負いません。 ※掲載されているサンプルプログラムやスクリプト、および実行結果を記した画面イメージなどは、特定の設定に基づいた きれる一弾です。

されている会社名、製品名はそれぞれ各社の商標および登録商標です。

およびは割愛させていただいております。

Patterns of Enterprise Application Architecture by Martin Fowler

Copyright©2003 by Pearson Education, Inc.

Japanese translation rights arranged with Pearson Education, Inc. through Japan UNI Agency, Inc., Tokyo.

デニス・ウィリアム・ファウラー(1922 - 2000) 捧げる



日本の読

短い滞在期間ではありますが、 日本への訪問をいつも楽しんでいます。 特に、ソフ ア開発に携わる日本の方々のあいだで私の仕事が広く認められ、 役立っていると実感 とができて、とても嬉しく思います。 今回、 私の最新の書籍がとうとう日本でも出版 と聞いて喜びにたえません。 本書の日本での刊行に尽力してくださったすべての方々 を読んでくださる読者の方々にお礼を申し上げます。

マーチンファ



監訳

本書の原著 (英語) が2002年に発行されたときには衝撃が走るほど米国のオブジ 指向業界にインパクトを与えた。 オブジェクト指向だけにとどまらず、アーキテクチ

て J2EE や.NET といったミドルウェアを利用している開発者にも注目されている。 本書の内容はシステム分析による作業と実装作業のギャップを埋める方法であり、 悩んでいた技術である。 このノウハウをマーチン・ファウラー氏がパターンとしてま げた。ファウラー氏は、UML からエクストリームプログラミングまで幅広い活動を いる。このため、本書の著者は様々な方面から集まっている。 まさに、バランスの ファウラー氏ならではの人選である。

ファウラー氏と私は、2000年の日本での講演のアテンドを担当した頃からのつき ある。 ファウラー氏とは UML によるモデリング、パターン、アジャイルプロセスにつ 多くの議論を行ってきた。 これからも彼 (または彼の所属している Thought Works は共同作業をすることもあるであろう。

本書の翻訳にあたって、 日本での発売出版社が変更になったり、 翻訳会社にお手伝 願いしたりと多くの時間を費やしてしまった。 日本語版の出版が遅くなってしまった。 ついて、 誠に申し訳なく思っている。

最後に、 本書を全体的にチェックした武田知子氏、テクニカルなレビューを行った 氏、 坂本武志氏、 藤川幸一氏に感謝する。 また、 株式会社翔泳社の佐藤善昭氏をはじ るスタッフの人たちには、難しい編集作業をしていただいた。 本書によりシステム開発 みが少しでも減るように願っている。

2005年

長瀬



1999年の春、私はシカゴに飛んだ。規模は小さいが成長著しいアプリケーション開 Thought Works社でのプロジェクトについて打ち合わせをするためだ。 そのプロジェ は、最近よくある野心的なエンタープライズアプリケーションプロジェクトで、バッ ドリーシングシステムだった。 基本的に、リース契約後に生じるすべての事例を処理 めのもので、請求書の送付、 リース物件の更新処理、 リース料を期日までに支払わない 追跡 物件を予定より前に返却してきた場合の処理などを行う。 これだけであれば、 ど面倒なものには聞こえないのだが、 実際には、リース契約の内容は契約ごとに異な ろしいぐらいに複雑だ。 ビジネスロジック」 がロジックパターンにあてはまることに たにない。 このロジックはビジネスを成功させようとする人によって作られたもので ビジネスではわずかな条件の変化でも契約の獲得が大きく左右されることがあるから たがって、契約を勝ち取るたびにそのシステムはさらに複雑なものになっていくことに

このような状況は私のやる気を奮い立たせた。 複雑な事情を踏まえ、 さまざまな問題 ムーズに処理できるシステムを構築するのはやりがいのある仕事だからだ。 実際、複雑 ジックをより扱いやすいものにすることには意義がある。 複雑なビジネス処理に対応し 正なドメインモデルを開発するのは、非常に困難ではあるが、 とてもやりがいのあるこ ある。

しかし、問題はこれだけではなかった。 このドメインモデルではデータベースとの連 必須で、その他多くのプロジェクト同様、リレーショナルデータベースが使用されていた また、このモデルをユーザインタフェースに接続して、中のソフトウェアをリモートアプリ ションから利用できるようにすることと、サードパーティのパッケージとこのソフトウェ 統合させる必要もあった。 これらすべてを新しい技術であるJ2EE を使って処理するわけ その時点では、世界中のどこにもこの技術を実践的に導入している事例はなかった。

この技術そのものは新しいものだったが、 私たちにはそれなりの経験があった。 私自身 この種のプロジェクトを C++, Smalltalk, CORBA などで長年手掛けてお

Thought Workers 社の社員の多くは Forte に関する経験が豊富だった。 私たちの頭の中に はキーとなるアーキテクチャ構想がすでにあり、後は、 それらをどうやってJ2EE に適用す るかを考えればいいだけだった。 あれから3年経った今、振り返ると、 設計は決して完全な ものではないが、その時点では立派に機能していたのだ。

本書の目的は、このような状況に対処することである。 長年に渡って数多くのエンタープ ライズアプリケーションプロジェクトを見てきたが、 これらのプロジェクトの多くには、エ ンタープライズアプリケーションが抱える複雑性への対処に一定の効果を上げている共通し た設計構想が含まれている。 本書は、これらの設計構想をパターンとしてとらえるための出 発点となるものだ。

本書は2部構成になっており、 第1部 「概論」の各章では、エンタープライズアプリケー ションを設計する上で重要なトピックの数々を紹介している。 これらの章では、エンタープ ライズアプリケーションのアーキテクチャに関するさまざまな問題とその解決策を解説して いる。 第2部では、その解決策について詳細に解説し、 パターン化してまとめている。 これ らのパターンはあくまでも参考資料であり、すべてのパターンを順番に読む必要はない。 本 書の正しい使い方は、 まず、 第1部 「概論」 の各章を最初から最後まで順番に読み、本書が 対象としている内容の概略を理解し、興味または必要に応じて第2部の 「パターン」 に進む という方法である。 つまり、本書は、短い概論と長いリファレンスを一冊にまとめたものだ と考えてもらえればいい。

本書の内容は、エンタープライズアプリケーション設計についてである。 エンタープライ ズアプリケーションとは、膨大で、ときに複雑なデータの表示処理 格納と、それらの データを使ったビジネスプロセスのサポートまたは自動化を行うためのものだ。 紹介してい る例には、予約システム、財務システム、サプライチェーンシステム、その他最新のビジネ ス環境で使用される多くのシステムが含まれている。 エンタープライズアプリケーションに は固有の課題と解決策があり、 組み込みシステムや制御システム、電気通信、 またはデスク トップ生産性ソフトウェアとは異なっている。 これらの分野の業務をしている人にとっては、 本書はあまり役に立たないかもしれない (エンタープライズアプリケーションがどんなもの なのか感じをつかみたいという場合は別だが)。 ソフトウェアアーキテクチャ全般に関する 本としては、 [POSAJを推奨したい。

エンタープライズアプリケーションの構築過程では、さまざまなアーキテクチャ面の課題 がある。 本書は、決してそれらすべてを網羅しているわけではない。 ソフトウェア構築にお いては、私はイテレーティブ開発論者である。 イテレーティブ開発の根底には、 顧客にとっ て有効と思われるものが得られたら、たとえ完全でなくてもソフトウェアを配信するという 考え方がある。 本を書くことと、 ソフトウェアを作成することには多くの違いがあるが、こ の考え方に限っては両者は共通していると思っている。 言い換えれば、 つまり、 本書は完全 なものではないが、エンタープライズアプリケーションアーキテクチャに不可欠なアドバイ

スの数々が書き込まれている (と私は信じている)。 本書で紹介している主な項目 おりである。

■エンタープライズアプリケーションのレイヤ化

■ドメイン (ビジネス) ロジックの構築

■Web ユーザインタフェースの構築

■インメモリモジュール (特にオブジェクト)とリレーショナルデータベー ンク

■ステートレス環境におけるセッションステートの扱い

■配布の原則

本書では触れていない項目も多い。 妥当性の整理、 メッセージングと非同期通信 セキュリティ、エラー処理、 クラスタリング、アプリケーション統合、 アーキテクチ ファクタリング、リッチクライアントユーザインタフェースの構築など、書きたいこ くらでもある。 ただし、 紙面と時間の制約、 それに着想力不足から、これらの項目に では触れることができなかった。 今はただ、いくつかのパターンが近い将来実現する 祈るばかりである。 続編でこれらの項目を解説するという手もあるが、もしかしたら かがこれらの空白を埋めるような本を書いてくれるかもしれない。

この中でも、メッセージベースの通信は、 特に重要な項目であると言えるだろう。 アプリケーションを統合して使う場合、 非同期メッセージベース通信を使うケースが からだ。 1つのアプリケーション内でのこれらの使用についても語ることはたくさん ろう。

本書は、特定のソフトウェアプラットフォームを前提にしたものではない。 私が初 れらのパターンに出会ったのは、80年代後半から90年代初頭のことで、 Smalltalk、 CORBA などで作業をしていたときだ。 90年代後半になると、 Java を使った作業の 格段と大きくなり、これらのパターンが初期のJava/CORBA システムやJ2EE ベー のにもスムーズに適用できることを発見する。 最近になって、 Microsoft 社のNET トフォームでの作業もするようになったが、ここでもパターンは適用できることがわか Thought Works の仲間からは、 主に彼らのForte での経験を教わった。 エンタープラ アプリケーションで使われた、あるいは使われるであろう仕様の中で、すべてのプラ フォームで通用するという汎用性を保証することはできないが、少なくとも今までのとこ これらのパターンは汎用性に優れていることを実証している

ほとんどのパターンで例としてコードを紹介している。 使用する言語には、ほとんど 者にとって読みやすく理解しやすいと思われるものを選択した。 本書では Java を選択し

C, C++ を読める人であれば Java は読めるわけで、 しかも C++ よりはるかに簡単だから だ。 つまり、ほとんどのC++プログラマは Java を読めるが、その逆は必ずしもそうでは ないわけだ。 私はかなりのオブジェクト指向主義者なので、必然的にオブジェクト指向言語 を使うことになる。 その結果、ほとんどのコード例はJava で書かれている。 本書の執筆中 に、Microsoft はNET 環境の安定化に着手し始め、 そこで使われている C# 言語は、ほと んどのプロパティが Javaと共通である。 そこで、コード例のいくつかをC#でも書いてみ たが、これには多少のリスクがあった。なぜなら、 開発者は.NET での経験が浅く、これを 使うという発想そのものが時期尚早だからだ。 いずれもCをベースにした言語なので、 いず れか1つを読めれば、たとえその言語やプラットフォームに精通していなくても、両方を読 むことができるはずだ。 私の狙いは、最も多くのソフトウェア開発者が読めると思われる言 語を使用することだった。 たとえ、それが彼らのメインのまたは好みの言語ではないとして もだ。 (Smalltalk Delphi、 Visual Basic、 Perl、 Python Ruby COBOL などの言語を 好んで使っている開発者には前もって謝罪しておく。 Java や C# よりもっと優れた言語が あるという意見も当然あるだろう。 1つだけ言えるのは、私も同感だということだ!)

紹介している例は、あくまでもパターン内のアイデアを紹介・説明するためのものである。 実践ですぐに利用できる解決策ではない。 すべてのケースにおいて、 実践で使うにはかなり の修正を必要とすることだろう。 つまり、 パターンは出発点としては有効だが、必ずしもそ れがそのまま適用できるというものではないということだ。

|本書の対象読者

本書は、エンタープライズアプリケーションの構築に携わるプログラマ、設計者、および アーキテクトのなかでも、 そのアーキテクチャに関する問題をより深く理解し、それらの問 題についてより効果的にコミュニケーションしたいと思っている人を対象に書かれている

本書の読者は、大きく2つのグループに分かれる。 独自のソフトウェアを構築しようとし ているニーズ的には比較的低い人達、 そしてツールを使う、 よりニーズの高い人達だ。 比較 的ニーズの低い人達にとって、 本書で紹介するパターンは出発点として利用できることだろ う。 多くの分野で、パターンが提供する以上のものが必要となるだろうが、より優位に作業 を始められるようになるはずだ。 ツールユーザにとって、 本書は水面下で何が起こっている かを把握し、ツールがサポートするパターンの選択などに役立つこととなるはずだ。 ただし、 たとえば、 オブジェクトリレーショナルマッピングツールで、 どのように対応付けるかは読 者自身が決定を下さなくてはならない。 パターンを読めば、何を選択するべきかの指針にな るはずだ。

第3のグループとして、独自のソフトウェアを構築しようとしている人で高いニーズを

持っている人達もあるかもしれない。 まず言えることは、 使用するツールをよく知 ことだ。 過去に、フレームワークを構築するのに膨大な時間を要したプロジェクトを か見てきたが、もちろんプロジェクトそのものの目的はそれではない。それでも納 という場合は、構わないが。 ただし、覚えておいてほしいのは、 本書で紹介している 例は、理解しやすいように簡略化されたものであり、実践で生じるさまざまなニーズ させるには、相当な作業を要するということだ。

パターンは、再現性のある問題に対する共通解決策なので、いくつかのパターンは 見たことがあるという人がいても不思議ではない。 エンタープライズアプリケーショ 作業を続けていれば、いずれはほとんどのパターンに遭遇することになるだろう。 本 か新しいことを書いたつもりはない。 反対に、 本書は (業界内における) 古くからの まとめたものであると言えるだろう。 この分野は初めてという人には、本書は、これ クニックを学ぶのに役立つだろう。 これらのテクニックに精通している人には、本書 人とのコミュニケーションやそれらの人達に教えるのに役立つものとなれば幸いだ。 ボキャブラリを構築するのもパターンの重要な部分だ。 たとえば、このクラスはリ ファサードだと言ったときに、設計者がその意味をわかるようにした方がいいからだ

謝辞

本書に書かれている内容は、長年に渡って多くの人達といろいろな形で共同作業し ら学んだものである。 多くの人がさまざまな形で貢献してくれている。 中には、誰 言ったかは覚えていないことも含まれているが、 思い出せる限り、この場を借りてそ に対し謝意を述べたいと思う。

まずは、同僚の貢献者から始めよう。 David Rice は、 Thought Works での同僚 書の10分の1は彼の貢献によるものと言える。 締め切りに間に合わせるためによく 深夜にインスタントメッセージをやり取りしたが (彼は、その間、クライアントのサ もしていた)、 その中で彼は「本を書くことがいかに大変で面白いことかがわかった 告白したぐらいだ。

Matt Foemmel は、 Thought Works の同僚で、 エアコンがないところでは文章を書 を嫌がったが、コード部分で大きく貢献してくれた (本書に対する簡潔明瞭な批評 サービスレイヤでは、この分野に強い Randy Stafford の貢献が大きかった。 Ed Hieatt と Rob Mee の貢献にも謝意を表したい。 これは、 Rob がレビューしている段階 るギャップに気付いたところから始まる。 彼は、私のお気に入りのレビューアになった に不足しているものに気付くだけでなく、 どう修正するかでも助けてくれたからだ。

いつものことだが、 本書のレビューをしてくれた次の優秀なレビューア達には、言葉

言い尽くせない恩義を感じている。

John Brewer Kyle Brown Jens Coldewey Rob Mee Gerard Meszaros Dirk Riehle Randy Stafford John Crupi Leonard Fenster Alan Knight David Siegel Kai Yu

Thought Works の内線一覧表を載せてもいいぐらい、 多くの同僚達が設計や経験などを 語ってくれたおかげでこのプロジェクトは実現したようなものだ。 多くのパターンを思いつ くのに至ったのも、社内の優秀な設計者との会話があったからで、謝意は会社全体に対して 表するのが適切だろう。

Kyle Brown Rachel Reinitz、 それに Bobby Woolf は、ノースカロライナにて惜しみ なく時間を割いて詳細なレビューをしてくれた。 彼らの徹底したレビューによって、 さまざ まな知恵が注入された。 特に、 Kyle との長電話は楽しかっただけでなく、ここではすべて を挙げられないぐらいの貢献度があった。

2000年初頭、 Alan Knight と Kai Yu を交えてJava One について話をしたのが本書の 出発点となっている。 彼らおよび後にその会話の内容やアイデアを整理するのを手伝ってく れた Josh Mackenzie、 Rebecca Parsons, Dave Rice に感謝したい。 .NET という新しい 世界を知るのをサポートしてくれたJim Newkirk にも謝意を表したい。

この分野の業務に携わる人達との会話と共同作業から、 とても多くのことを学習させても らった。 特に、 Gemstone での Foodsmart サンプルシステムの構築に協力してくれた Colleen Roe、 David Muirhead Randy Stafford に謝意を表したい。 また、 Bruce Eckel がホストした Crested Butte ワークショップでの会話も大いに役立っている。 ここ数年間、 あのイベントに参加していた人達にも、ここで謝意を表したい。 Joshua Kerievsky は、 レ ビューそのものには余り多くの時間は割けなかったにもかかわらず、パターンコンサルタン トとして貢献してくれ

いつものように、 UIUC リーディンググループの徹底したオーディオレビューには、大い に助けてもらった。次の方々に謝意を表する。 Ariel Gertzenstein、 Bosko Zivaljevic, Brad Jones. Brian Foote, Brian Marick, Federico Balaguer, Joseph Yoder, John Brant、Mike Hewner, Ralph Johnson、Weerasak Witthawaskul。

Dragos Manolescu は、 元UIUC ヒットマンで現在は自身のグループを持っており、今 回も色々なフィードバックをしてくれた。 次の方々にも謝意を表する。 Muhammad Anan、 Brian Doyle, Emad Ghosheh, Glenn Graessle, Daniel Hein, Prabhaharan

まえがき

Kumarakulasingam, Joe Quint, John Reinke, Kevin Reynolds, Sr Srinivasan, Tirumala Vaddiraju

Kent Beck は、覚えきれないほどの優れたアイデアを提供してくれた。 思い出 スペシャルケースの名前を思いついてくれたことだ。 Jim Odell は、 私をコンサルテ と教育の世界に引きずり込んだ張本人で、この謝辞から外すわけにはいかない。

本書は、 執筆過程において、 下書きをWebにアップしていた。 この際、多くの人 メールで問題点を指摘してくれたり、質問したり、 代替案などを提案してくれた。 これ 次の方々が含まれる。 Michael Banks、 Mark Bernstein, Graham Berrisford、 Beskow、 Bryan Boreham, Sean Broadley, Peris Brodsky、 Paul Campbell Co Chen, John Coakley, Bob Corrick, Pascal Costanza、 Andy Czerwonka A Diehl、 Daniel Drasin, Juan Gomez Duaso、 Don Dwiggins、 Peter Foreman、 R Freeman Peter Gassmann, Jason Gorman Dan Green、 Lars Gregori、 Hansen, Tobin Harris, Russel Healey, Christian Heller, Richard Henderson Hermenean, Carsten Heyl, Akira Hirasawa, Eric Kaun, Kirk Knoernsc Jesper Ladegaard, Chris Lopez, Paolo Marino, Jeremy Miller, Ivan Mitr Thomas Neumann, Judy Obee, Paolo Parovel, Trevor Pinkney, Tomas Rest Joel Rieder, Matthew Roberts, Stefan Roock, Ken Rosha, Andy Schne Alexandre Semenov, Stan Silvert, Geoff Soutter, Volker Termath, Christo Thames, Volker Turau, Knut Wannheden, Marc Wallace. Stefan Wenig. Wiemerslage, Mark Windholtz, Michael Yoon

ほかにも、名前も知らない、あるいは失念してしまった方々から多くの意見を頂いてい その方々にもこの場を借りて感謝したい。

最後に、最大の感謝を妻の Cindy に捧げる。 彼女がいてくれたからこそ、本書を書 げることができたのだ。

マーチン ファウ

2002年

マサチューセッツ州メルローズ

http://martinfowler.



目次

日本の読者の皆様へ。

監訳者まえがき

まえがき

本書の対象読者.

謝辞.

はじめに

アーキテクチャ..

エンタープライズアプリケーション.

エンタープライズアプリケーションの種類

パフォーマンスに関する考察

パターン

パターンの構造

本書のパターンの限界

第1部 概論

第1章

レイヤ化

1.1 エンタープライズアプリケーションのレイヤの発展

3つの主なレイヤ.........

1.2

1.3

レイヤの実行場所の選択.

第2章 ドメインロジックの構築

2.1

選択..

・・・・・・・・・・・・

2.2 サービスレイヤ

第3章 リレーショナルデータベースへのマッピング

3.1 アーキテクチャに関するパターン

3.2 振る舞いに関する問題...

3.3 データの読み込み..

3.4

構造的なマッピングに関するパターン..................

3.4.1 関係のマッピング

3.4.2 继承

3.5 マッピングの構築.

3.5.1 2重のマッピング

3.6

メタデータの使用.

3.7 データベース接続。

3.8 その他の要点.

3.9 参考文献,

第4章 Web プレゼンテーション

4.1 ビューに関するパターン...

入力コントローラに関するパターン

参考文献。

4.2

4.3

第5章 並行性 5.1 並行性の問題. 5.2 実行コンテキスト、 5.3 分離性および不変性. 5.4 軽い並行性制御および重い並行性制御・ 5.4.1 一貫性のない読み込みの防止 ..065 ...066 ...067 ...068 .069 .071 5.4.2 デッドロック 072 .073 5.5 トランザクション 074 5.5.1 ACID 5.5.2 トランザクション可能なリソース 074 5.5.3 即応性に対するトランザクション分離性の制限 075 5.5.4 ビジネストランザクションとシステムトランザクション 077 5.6 オフライン並行性制御のためのパターン。 .080 5.7 アプリケーションサーバの並行性。 .....081 .083 5.8 参考文献、 第6章 セッションステート ..085

6.1 ステートレス性の価値..

6.2 セッションステート

62.1 セッションステートを格納する方法

7章 分散ストラテジー

.085

.087

088

7.1 分散オブジェクトの誘惑

7.2 リモートインタフェースとローカルインタフェース.

...093

7.3 分散が必要な場所.

7.4 分散境界の扱い。

7.5 分散用インタフェース...

..093

..094

第8章 まとめ .101 8.1 ドメインレイヤからの開始. 102 8.2 データソースレイヤに進む。 103 8.2.1 トランザクションスクリプト用のデータソース 103 8.22 データソース 「テーブルモジュール」 8.2.3 ドメインモデル用のデータソース 8.3 プレゼンテーションレイヤ 8.4 技術上のアドバイス。 8.4.1 Java と J2EE 8.4.2 NET 104 104 .105 106 .106 108 108 109 109 8.4.3 ストアドプロシージャ 8.4.4 Webサービス 8.5 その他のレイヤ化スキーム、

9 ドメインロジックパターン 9.1 トランザクションスクリプト 9.1.1 動作方法. 9.12 使用するタイミング .115 115 115 117

096

097

098

第2部 パターン

xvili

次

9.1.3 Revenue Recognition の問題

9.2

9.1.4 例: Revenue Recognition (Java)

ドメインモデル..

9.2.1 動作方法

9.2.2 使用するタイミング

9.2.3 参考文献

9.2.4

例: Revenue Recognition (Java)

9.3 テーブルモジュール.

9.3.1 動作方法

9.3.2 使用するタイミング

9.3.3 例:テーブルモジュールでのRevenue Recognition (C#)

9.4 サービスレイヤ..

9.4.1 動作方法

9.4.1.1 ビジネスロジックの種類

9.4.1.2 実装バリエーション

9.4.1.3 リモートにするべきか否か

9.4.1.4 サービスと操作の特定

9.4.2 使用するタイミング

9.4.3 参考文献

9.4.4 例: Revenue Recognition (Java)

第10章 データソースのアーキテクチャに関するパターン

10.1 テーブルデータゲートウェイ.

10.1.1 動作方法

10.1.2 使用するタイミング

10.1.3 参考文献

10.1.4

10.1.5

10.2

: Person Gateway (C#)

: ADO.NET データセット (C#) の使用

行データゲートウェイ、

10.2.1 動作方法

10.22 使用するタイミング

10.2.3 例: Person レコード (Java)

10.2.4 例: ドメインオブジェクト用のデータホルダー (Java)

10.3

アクティブレコード....

10.3.1 動作方法

10.3.2 使用するタイミング

10.3.3 例 シンプルなPerson (Java)

10.4 データマッパー

10.4.1 動作方法

10.4.1.1 find メソッドの処理

10.4.1.2 ドメインフィールドへのデータのマッピング

10.4.1.3 メタデータベースのマッピング

10.4.2 使用するタイミング

10.4.3

シンプルなデータマッパー (Java)

10.4.4 例 findメソッドの分離 (Java)

10.4.5 例: 空のオブジェクトの作成 (Java)

11 オブジェクトリレーショナル振る舞いパターン 11.1 ユニットオブワーク

19

19

198

11.1.1 動作方法

11.12 使用するタイミング

203

ユニットオブワーク (Java)

11.13 例: オブジェクト登録を備えた.209 11. 一意マッピング... 209 1121 動作方法 210 112.1.1 キーの選択 210 11.2.12 明示的あるいは汎用 210 11213 マッピングの数 211 112.1.4 どこに配置するか 212 11.22 使用するタイミング 1123 例 一章マッピングのためのメソッド (Java) 213 .213 11.3 レイジーロード 214 11.3.1 動作方法 217 11.32 使用するタイミング 1133 例: レイジーイニシャライズ (Java) 217 217 11.3.4 例:仮想プロキシー (Java) 11.35 バリューホルダーの使用 (Java) 219 221 11.3.6 例: ゴーストの使用 (C#)

第12章 オブジェクトリレーショナル構造パターン

12.1 一意フィールド.

12.1.1 動作方法

12.1.1.1 キーの選択

.....231

.231

12.1.12 オブジェクトにおける一意フィールドの表記方法

12.1.13 新規キーの取得

231

231

12.12 使用するタイミング

12.13 参考文献

12.14 例: 整数型キー (C#)

12.15 例:キーテーブルの使用 (Java)

12.1.6 例: 複合キーの使用 (Java)

12.16] キークラス

12.162 読み込み

12.1.6.3 挿入

12.1.6.4 更新と削除

12.2 外部キーマッピング。

233

234

236

236

240

241

248

12.2.1 動作方法

238

12.22 使用するタイミング

251

.254

12.2.3 例: 単一値参照 (Java)

122.4 例: 複数テーブルの検索 (Java)

12.2.5 例 参照のコレクション (C#)

12.3 関連テーブルマッピング

12.3.1 動作方法

.266

12.32 使用するタイミング

12.3.3 例: Employee とSkill (C#)

12.3.4 例: ダイレクト SQLの使用 (Java)

236

243

254

257

12.3.5 例: 複数のEmployee に対する1つのクエリーの使用 (Java)

258

261

263

267

267

268

12.4 依存マッピング.

272

12.4.1 動作方法

12.4.2 使用するタイミング

276

12.4.3 例: Album と Track (Java)

282

282

283

284

204

次

XX

12.5 組込バリュー

12.5.1 動作方法

12.5.2 使用するタイミング

12.6

12.5.3 参考文献、

12.5.4 例: バリューオブジェクトの例 (Java)

シリアライズLOB.

12.6.1 動作方法

12.6.2 使用するタイミング

12.6.3 例: XML による Department 階層構造の直列化 (Java)

12.7

シングルテーブル継承..

・・・・・・・・

12.7.1 動作方法

12.7.2 使用するタイミング

12.7.3 例: Playerのためのシングルテーブル (C#)

12.7.4 データベースからのオブジェクトの読み込み

12.7.1 オブジェクトの更新

12.7.4.2 オブジェクトの挿入

12.8

12.7.4.3 オブジェクトの削除

クラステーブル継承

12.8.1 動作方法

12.8.2 使用するタイミング

12.8.3 参考文献 -

12.8.4 例: Player とそのKin (仲間) (C#)

12.8.4.1 オブジェクトの読み込み

12.8.4.2 オブジェクトの更新

12.8.4.3 オブジェクトの挿入

12.8.4.4 オブジェクトの削除

12.9 具象テーブル継承

12.9.1 動作方法

12.9.2 使用するタイミング

12.9.3 例: 具象Player (C#)

12.9.3.1 データベースからのオブジェクトの読み込み

129.32 オブジェクトの更新

12.9.3.3 オブジェクトの挿入

12.9.34 オブジェクトの削除

12.10 継承マッパー

12.10.1 動作方法

12.10.2 使用するタイミング

第13章 オブジェクトリレーショナルメタデータマッピングパターン

13.1 メタデータマッピング. 13.1.1 動作方法 13.1.2 使用するタイミング 13.1.3 例: メタデータとリフレクションの使用 (Java) 13.1.3.1 メタデータの保持 13.1.3.2 ID による検索 13.1.3.3 データベースへの書き込み 13.1.3.4 複数のオブジェクトの検索 13.2 クエリーオブジェクト。 33

13.2.1 動作方法

33

13.3 リポジトリ. 13.22 使用するタイミング 13.2.3 参考文献 132.4 例:シンプルなクエリーオブジェクト (Java) 13.3.1 動作方法 1332 使用するタイミング 340 340 341 .345 346 347 13.3.3 参考文献 13.3.4 Person が持つ扶養家族の検索 (Java) 348 348 13.3.5 リポジトリストラテジーのスワッピング (Java) 349

第14章 Web プレゼンテーションパターン

14.1 モデルビューコントローラ

.351

351

14.1.1 動作方法

14.12 使用するタイミング

.351

14.2 ページコントローラ..

353

1421 動作方法

354

14.22 使用するタイミング

142.4 例:JSPをハンドラとして使用する (Java)

14.3 フロントコントローラ.

354

356

356

142.3 例: サーブレットコントローラとJSPビューによるシンプルな表示 (Java)

14.25 例 裏にコードを持ったページハンドラ (C#)

14.3.1 動作方法、

14.3.2 使用するタイミング

14.3.3 参考文献、

359

362

.366

14.3.4 例: シンプルな表示 (Java)

14.4 テンプレートビュー。

14.4.1 動作方法

367

14.4.1.1 マークの埋め込み

14.4.12 ヘルパーオブジェクト

14.4.1.3 条件付き表示

14.4.14 イテレーション

14.4.15 処理の時期

369

14.4.1.6 スクリプトの利用

14.4.2 使用するタイミング

368

369

377

373

374

14.4.3 例:独立コントローラを持ったビューとしてのJSPの利用 (Java)

375

375

14.4.4 ASP.NET サーバページ (C#)

14.5 トランスフォームビュー

14.5.1 動作方法

14.6.1 動作方法

14.6.2 使用するタイミング

373

381

ツーステージ XSLT (XSLT)

14.6.3

14.6.4 例: JSPおよびカスタムタグ (Java)

403

-106

376

377

377

14.5.2 使用するタイミング

378

384

14.6 ツーステップビュー

384

385

14.5.3 例: シンプルな変換 (Java)

...

386

.388

389

395

14.7 アプリケーションコントローラ..

392

14.7.1 動作方法

398

14.72 使用するタイミング

14.73 参考文献

.403

405

次

xxii

14.7.4 例: 状態モデルアプリケーションコントローラ (Java)

第15

章 分散パターン 15.1 リモートファサード、 15.1.1 動作方法 15.1.1.1 リモートファサードとセッションファサード 15.1.1.2 サービスレイヤ 15.1.2 使用するタイミング 15.1.3 例: リモートファサードとしてのJava セッション Bean の使用 (Java) 15.1.4 例: Webサービス (C#) 15.2 データ変換オブジェクト.. 15.2.1 動作方法 15.2.1.1 データ変換オブジェクトの直列化 15.2.1.2 ドメインオブジェクトからのデータ変換オブジェクトの組み立 15.2.2 使用するタイミング 15.2.3 参考文献 15.2.4 Album についての情報の転送 (Java) 15.2.5 例: XMLを使用する直列化 (Java)

16章 オフライン並行性パターン

16.1 軽オフラインロック

16.1.1 動作方法

16.1.2 使用するタイミング

16.1.3 例: データマッパーによるドメインレイヤ (Java)

16.2

重オフラインロック

16.2.1 動作方法

16.2.2 使用するタイミング

16.3

16.2.3 例: シンプルなロックマネージャー (Java)

ロック

16.3.1 動作方法

16.3.2 使用するタイミング

16.3.3 例: 共有軽オフラインロック (Java)

16.3.4 例: 共有重オフラインロック (Java)

16.3.5 例: ルート怪オフラインロック (Java) 暗黙ロック.

16.4

16.4.1 動作方法

16.4.2 使用するタイミング

16.4.3 例: 暗黙重オフラインロック (Java)

第17

章 セッションステートパターン 17.1 クライアントセッションステート 17.1.1 動作方法 17.2 17.3 17.1.2 使用するタイミング サーバセッションステート 17.2.1 動作方法 17.2.2 使用するタイミング データベースセッションステート 17.3.1 動作方法 17.3.2 使用するタイミング

第18章 ベースパターン

..489

1813 例: 固有のメッセージングサービスへのゲートウェイ (Java)

..489

490

18.1 ゲートウェイ..

18.1.1 動作方法

18.1.2 使用するタイミング

18.2 マッパー

18.21 動作方法

496

491

496

497

1822 使用するタイミング

18.3 レイヤスーパータイプ

.492

1831 動作方法

497

497

1832 使用するタイミング

18.3.3 例: ドメインオブジェクト (Java)

18.4 セパレートインタフェース

184.1 動作方法、

18.42 使用するタイミング

レジストリ

498

18.9.1 動作方法

498

499

500

501

18.5

18.5.1 動作方法

1852 使用するタイミング

1853 例: シングルトンレジストリ (Java)

185.4 スレッドセーフレジストリ (Java)

18.6 バリューオブジェクト.

18.6.1 動作方法

.502

502

18.7 マネー.

18.92 使用するタイミング

18.11 レコードセット....

504

505

507

18.62 使用するタイミング

18.62.1 名前の衝突

18.7.1 動作方法

18.72 使用するタイミング

18.7.3

Money クラス (Java)

18.8 スペシャルケース..

18.8.1 動作方法

18.82 使用するタイミング

18.8.3 参考文献

1884

508

: シンプルなNull オブジェクト (C#)

508

510

18.9 プラグイン。

510

519

519

520

18.9.3

521

ID生成プログラム (Java)

18.10 サービススタブ

18.10.1 動作方法

18.10.2 使用するタイミング

18.11.1 動作方法

18.11.1.1 明示的なインタフェース

18112 使用するタイミング

参考文献.

..535

索引

..541

510

511

513

519

513

518

521

522

523

18.10.3 売上税サービス (Java)

.526

526

527

527

.530

531

531

532

XXIV

コンピュータシステムを構築するには、 十分な理解が必要である。 システムが複雑 ばなるほど、ソフトウェア構築の負荷は飛躍的に大きくなる。 どんな職務にあっても、 ちは失敗と成功の両方から学ぶことでしか、 向上することはできない。 本書はそのよ 調のいくつかをまとめたものだ。 本書の読者が、かつての私のような苦労をしなくて 則が得られ、 他の人に効果的な意思伝達ができるようになることを願っている。 ここでは、本書の目的を示し、本書の考え方の背後にあるものを説明したい。

アーキテクチャ

ソフトウェア業界では、 言葉を拡大解釈して、微妙に矛盾した無数の意味を持たせる が好まれる。 最も被害を受けている言葉の1つが 「アーキテクチャ (architecture)」 る。 私はどうしてもこの言葉から重要そうな響きを感じてしまう。 いかにも重要な話を いると思わせるために使用されているような気がするのだ。 だが、 嫌味を言うのはこの いにしておこう。

アーキテクチャは、多くの人が定義しようとして、なかなか同意に至らない用語で この用語には誰もが認める2つの要素がある。 1つは、システムから個々のパーツへと までもブレークダウンできるということ、もう1つは、簡単には変更できない決定事項 いうことである。 また、 次第に理解されてきたことだが、 システムのアーキテクチャの 方は1つだけでなく、 1つのシステムには複数のアーキテクチャがあり、 アーキテクチ とって重要なことはシステムの存続期間の中で変わることがある。

Ralph Johnson はメーリングリストに実に素晴らしい投稿を行うことがある。 私が本 草稿を書き終えたときにも、アーキテクチャに関して投稿していた。 彼はその中で、アー クチャとは主観的要素であり、プロジェクト内の熟練開発者がシステム設計に関して共通 解していることにすぎないと述べている。 この共通理解はふつう、システムの主要なコン

ネントはどれで、それらのコンポーネントはどのように相互作用するかということに関するも のである。 また、 開発者が早く確認したいと願っている決定事項に関しての共通理解でもある。 この決定事項は後で変更するのは難しいと考えられているからだ。 ここで主観性が問題になる のは、思っていたよりも変更が容易であるとわかったら、 それはもはやアーキテクチャではな いからである。 つまりアーキテクチャとは、何であれ重要な要素なのである。

本書で私が示したいのは、エンタープライズアプリケーションの主要なパーツと、 早めに 確認したい決定事項に関する私なりの知見である。 私が最も気に入っているアーキテクチャ パターンは、第1章で説明するレイヤに関するパターンである。 したがって本書は、エン タープライズアプリケーションをレイヤに分割する方法と、これらのレイヤを互いに連携さ せる方法についての書籍になる。 重要なエンタープライズアプリケーションの多くは特定の 形式のレイヤ化アーキテクチャを使用するが、場合によってはパイプやフィルタなど他の手 法が有効なこともある。 本書ではそのような場合についての説明は避け、最も広範囲に役立 レイヤ化アーキテクチャに焦点を絞ることにする。

本書に紹介するパターンのいくつかは、パーツについての重要な決定を表しているという 点でアーキテクチャ的である。 一方、どちらかというと設計に関連し、アーキテクチャを理 解するために役立つパターンもある。 何がアーキテクチャ的で何がアーキテクチャ的でない かはとても主観的なことので、これら2つを区別することはやめておこう。

エンタープライズアプリケーション

多くの人がコンピュータソフトウェアを作成し、 私たちはそれらをすべてソフトウェア開 発と呼んでいる。 しかし、ソフトウェアにもいろいろなものがあり、それぞれ目的も違えば 複雑さの度合いも違う。 電気通信業界の友人と話をしたときに気づいたのは、エンタープラ イズアプリケーションは電気通信ソフトウェアよりもある意味で扱いやすいということだ。 厄介なマルチスレッドの問題は存在せず、ハードウェアとソフトウェアの統合も不要である。 しかしとても難しい面もある。 エンタープライズアプリケーションでは、複雑なデータに対 処しなければならない場合が多い。 しかも論理的とはいいがたいビジネスルールに従いなが らである。あらゆる種類のソフトウェアに適した技法やパターンもあるにはあるが、たいて いは特定の種類のソフトウェアにだけ適している場合が多い。

私は主にエンタープライズアプリケーションに関わってきたので、本書で紹介するパター ンはすべてエンタープライズアプリケーションに関するものである。 「エンタープライズア 「プリケーション」という用語が何を意味するか、 明確に定義することはできないにしても、 私なりにその意味するところを示すことはできる (エンタープライズアプリケーションを指 す他の用語には「情報システム」 とか、 長期間データを格納するアプリケーションであれば

02

「データ処理システム」 がある)。

エンタープライズアプリケーションには、 給与計算、 診療記録、 出荷管理、コスト 信用調査、保険、サプライチェーン、会計、 顧客サービス、 外国為替取引などが含ま 一方、 自動車用燃料噴射、 ワープロ、エレベータ制御、 化学プラント制御、 電話交換、 コンパイラ、 ゲームはエンタープライズアプリケーションには含まれない。

エンタープライズアプリケーションは、通常永続データを伴う。 「永続」というのは ログラムが実行されていない間もそのデータが必要だからである。 しかもたいていは 保存しなければならない。 その間にこのデータを使用するプログラムには多くの変更 れる。 データを作成したハードウェアよりも長い期間、 そのデータが存在することが OS やコンパイラよりも長く存在することさえある。 その間、 古い情報を失うことなく い情報を格納するために、 データ構造に多くの変更が行われる。 抜本的な変更のために たく新しい業務アプリケーションをインストールするときでも、 データを新しいアプリ ションに移行して使用できなければいけないのである。

世の中には通常たくさんのデータがあるので (平均的なシステムでも1GBを超える タがあり、 数千万のレコードに体系化されている)、 これを管理することがシステムの な役割になる。 古いシステムではIBM の VSAMISAM などのインデックス付きの イル構造が使われていたが、 最新のシステムではデータベース (主にリレーショナルデ ベース)を使用することが多い。 これらのデータベースの設計と入力は、それ自体が 専門分野である。

通常、 多くのユーザが同時にデータにアクセスする。 同時にアクセスするユーザ数 に満たないシステムも多いが、 インターネットに公開される Web ベースのシステム ユーザ数は大幅に増加する。 ユーザ数がどんなに多くても、全員がシステムに適切にア スできなければいけない。 また、ユーザ数が少ない場合でも、 2人のユーザが同時に データに、エラーを引き起こさないようにアクセスできなければならない。 トランザク ン管理ツールを使えばこの問題にはある程度対処できるとしても、アプリケーション がこの問題を考慮せずにいることはほとんど不可能である。

通常、多くのデータがある場合は、データを処理するために多くのユーザインタフェー 画面がある。 何百もの異なる画面があることは珍しくない。 エンタープライズアプリ シションのユーザには、定期的に利用しないユーザもいれば常時利用するユーザもいるが 術的な知識を持たない人が多い。 このため、ユーザの多様な目的に合わせてさまざまな でデータを表示できなければいけない。 システムには多くのバッチ処理が存在すること るが、ユーザとの相互作用に重きを置くユースケースのことばかり考えていると、バッ 理を忘れがちになる。

エンタープライズアプリケーションが孤立して存在することはほとんどない。 通常は の周辺に点在する他のエンタープライズアプリケーションと統合する必要がある。 シス

が異なれば使用される技術も異なり、さらにCOBOL データファイル、 CORBA、 メッセー ジングシステムなど協調メカニズムも異なるだろう。 企業では、共通の通信技術を使用して さまざまなシステムを統合しようとすることが多い。 そうするともちろん作業を完了できず、 複数の異なる統合計画が並存することになる。ビジネスパートナーとビジネスを統合させよ うとすると、さらに事態は悪化する。

企業が試合のための技術を1つにしたとしても、ビジネスプロセスの相違と、データの概 念の不一致に突き当たる。 企業の部門によっては、 現在契約中の人だけを顧客と考えるとこ ろもあれば、かつて契約を締結していたけれど今は契約していない人も顧客と考えるところ もある。 製品の売り上げを重視し、 サービスの売り上げは重視しない部門もある。 これらの 違いは容易に区別できるように思うかもしれないが、 何百ものレコードがあり、 その各 フィールドが微妙に異なる意味を持つ場合は、極めて大きな問題となる。 たとえ、 各フィー ルドが何を意味するかを熟知している社員がいたとしてもだ(もちろん、 これらのデータは すべて予告なしに変更される)。 結果として、 構文的にも意味的にも異なるあらゆる種類の フォーマットで、データの読み込み、変更、 書き込みが行われなければいけない。

「ビジネスロジック」 という問題がある。 奇妙な用語である。 ビジネスロジックよりも論 理的でないことはほとんどないからだ。 たとえば、 OS を構築するときは、すべてが論理的 でなければいけない。 しかし、ビジネスルールというものがあり、これを変更するには多大 な政治的努力が必要だ。 驚くべき方法で相互作用する計画性のない一連の奇妙な状況に対処 しなければならない。 もちろん、そのルールを採用するにはそれなりの理由があるだろう。 たとえば、営業マンが顧客の会計期間に合わせて通常より2日遅い決済を行うように交渉し、 その結果200~300万ドルの利益を得るといったことがある。 このような1回限りの特殊 事例が多々あり、これがビジネスソフトウェアの構築をとても困難にする複雑なビジネスイ ロジック (非論理)につながっている。 このような状況では、ビジネスロジックをできる限 り効率よく組織化しなければいけない。 ロジックは時間とともに変化するということだけが、 唯一確実なことだからである。

「エンタープライズアプリケーション」という用語は、 大規模システムを意味すると考え る人もいる。エンタープライズアプリケーションは企業に多くのメリットを提供するが、だ からといってすべてのエンタープライズアプリケーションが大規模なわけではない。 小規模 システムは重要ではないと思い込んでいる人も多いが、小規模システムにもある程度の利点 はある。たとえば、小規模システムがダウンしても、大規模システムほど深刻な損害にはな らない。 しかし、このような考え方のせいで、小規模プロジェクトの多くでは累積効果が正 しく評価されていないように思える。 小規模プロジェクトは見掛け以上の価値を持つことが 多いので、小規模プロジェクトの改善が可能であれば、 その累積効果は企業にとって極めて 重要である。 アーキテクチャとプロセスを単純化して大規模なプロジェクトを小規模に変え ることが最善の策なのである。

エンタープライズアプリケーションの種類

エンタープライズアプリケーションの設計方法とそこで採用するパターンについて検 るときに重要なのは、エンタープライズアプリケーションはそれぞれ異なり、問題が異 ば実行方法も異なると認識することである。 私は人が「いつもこうする」と言うのを聞 警戒心が働く。 私にとって設計に関する課題と関心)の大半は、 代替案をいくつか考 おくことであり、1つの代替案を採用することのトレードオフを判断することである。 案の範囲は広いが、ここでは3つの要点を述べることにしよう。

B2C (business to customer) のオンライン小売業を考えてみよう。 この小売業 Web ページで商品を閲覧し、 気に入ったものが見つかればショッピングカートに入れ、 する。このようなシステムでは多数のユーザを扱うことが必須であるため、リソースを 的に使用するだけでなく、 多くの負荷に耐えられるようにハードウェアを追加できるだ 拡張性を持たせておくことが必要となる。 このようなアプリケーション用のドメインロ クは、受注、比較的単純な価格計算と出荷計算、 出荷の通知など、 とてもわかりやすい 単にアクセスできるようにしたいので、広く使用されているブラウザーで表示できるよ 一般的な Web プレゼンテーションにする。 データソースには注文を記録するデータベー 含まれ、 在庫情報や配送情報を入手するために在庫管理システムとやりとりすることもあ

このB2C 小売業のシステムと、 リース契約処理を自動化するシステムを対比してみ ある意味で、このシステムの方がB2C 小売業のシステムよりもシンプルである。 それ ユーザの数が少ないからである (一度に使用するユーザは100人ほど)。 しかし、ビジ ロジックはリース契約処理システムの方が複雑である。 月々のリース料の計算、期限前 品や支払遅延などのイベントの扱い、 リース予約が入ったときのデータの妥当性確認など すべて複雑な処理である。 なぜ処理が複雑になるかというと、リース業界の競争の多く 去の取引の小さなバリエーションとして行われるからである。 このような複雑なビジネ メインは、規則があまりにも任意であるため、 大変な難題となる。

また、このようなシステムではUI (ユーザインタフェース) も複雑になる。 少なく 複雑な画面が入り組んだ HTML インタフェースが必要になる。 このようなシステム ユーザがHTMLのフロントエンドよりも洗練されたプレゼンテーションを望むという 要求を持つことが多いので、リッチクライアントのインタフェースが必要になる。 ま ユーザ同士の複雑な相互作用は、 複雑なトランザクションの振る舞いにつながる。 たとえ リースの予約には1、2時間かかることがあり、 その間ユーザの論理的なトランザクシ は継続される。 また、 200 ものテーブルと資産評価や価格決定のパッケージへの接続を 複雑なデータベーススキーマさえある。

3つめの例は、小規模な会社のシンプルな経費管理システムである。 このシステムの ザは少数で、ロジックもシンプルなので、 HTML プレゼンテーションを用いて社内の

場所から容易にシステムへアクセスすることができる。 データソースはデータベースにある 少数のテーブルだけである。 一見シンプルに見えるが、このようなシステムにも難題がある。 それは極めて短期間で構築しなければいけないことだ。 また、ユーザの要求が増えるにつれ てシステムが大規模になっていくことも考えておく必要がある。 払い戻し小切手の計算をし たり、それを給与計算システムに提供したり、税額の計算をしたり、 CFO (財務最高責任者) への報告書を作成したり、 Web の航空券予約サービスヘリンクしたり、などといったこと を行う必要が生じるたびに、システムを拡張していかなければならないのである。 他の2つ の例で述べたシステムのいずれかのアーキテクチャを使用しようとすると、このシステムの 開発が遅くなる。 システムがビジネスにとってメリットになる場合は (すべてのエンタープ ライズアプリケーションがそうなるべきだが)、 メリットの獲得が遅れるとコストが発生す る。 だからといって、 将来の成長を妨げるような決定は誰も行いたくないだろう。 しかし、 ここでシステムに下手に柔軟性を加えても、柔軟性を持たせるために追加された複雑性に よって、 実際には将来的にシステムを発展させることが難しくなり、 配置を遅らせることに なるので、なかなかメリットが得られない。 このようなシステムは、小規模ではあってもほ とんどの企業が多用しているので、不適切なアーキテクチャの累積効果は深刻である。

これら3つのエンタープライズアプリケーションの例には、それぞれ異なる問題がある。 このため3つの例すべてに適切な1つのアーキテクチャを見つけることはできない。 アーキ テクチャの選択とは、それぞれのシステム固有の問題を理解し、 その理解に従って適切な設 計を選択しなければならないことを意味する。 これが、本書で企業のニーズに対して1つの 解決策を提示しない理由である。 その代わり、選択肢や代替案として役立つ多くのパターン を提示したい。 特定のパターンを選択した場合でも、要求に合わせて修正しなければならな いことがある。 熟考なくしてエンタープライズソフトウェアを構築することはできない。 ソ フトウェア構築に対するあらゆる書籍の役割は、決定を下すのに役立つ情報を提供すること である。

この考え方は、パターンとツールの両方に当てはまる。 アプリケーションを開発するため にできるだけ小規模なツールを選ぶことは当然だが、 目的ごとに最適なツールは何かを判断 しなければいけない。 アプリケーションの種類ごとに適切なツールを使用するように注意し てほしい。 ツールを適切に使用しないと、 支援ではなく妨げになる場合があるからだ。

パフォーマンスに関する考察

アーキテクチャ上の決定の多くはパフォーマンスに関するものである。パフォーマンスの 問題の大半に対しては、システムを起動させ、実行して測定し、その結果を基にして規則正 しい最適化処理を行うことが好ましい。 しかし、最適化では解決できない形でパフォーマン

スに影響を及ぼすアーキテクチャ上の決定もある。 容易に解決できる場合でも、プロジ トに関わる人は早い段階でこの決定について悩む。

本書のような書籍でパフォーマンスについて説明することは難しい。 その理由は、パブ マンスに関するアドバイスは、現実のシステム構成でパフォーマンスの測定を行ってみる は、当てにならないからである。 パフォーマンスを考慮したために、設計の採用/不採用 われるのを目にすることがとても多い。 しかも、 実際のアプリケーション設定でパフォー スを測定してみると、そうした考慮が無意味だったことが判明したりするのである。

本書では、リモートコールを最小限にすることなどの指針をいくつか紹介する。この モートコールについての指針は、パフォーマンスについての優れたアドバイスとされて ものである。 それでも、実際にアプリケーションで測定して、 すべてのアドバイスが適 ものかどうかを確認したほうがよい。 同じく、 本書で提示するコードの例は、わかりや するためにパフォーマンスを犠牲にしている場合がある。 もう一度言うが、 最適化を行 きかどうかは、個々の環境によって異なる。 パフォーマンスの最適化を行う場合は常に、 適化の前後で測定を行ってみるべきである。 この測定を行わなければコードを読むこと しい。

測定に関して重要なことがある。 システム構成に重要な変更を行うと、 パフォーマンス 白紙の状態に戻ってしまう。 このため、 仮想マシン、ハードウェア、データベースまた の他のものをバージョンアップする場合は、再度パフォーマンスの最適化を行い、効果が るかどうかを確認しなければいけない。 多くの場合、 システム構成を新しくするとさまざ な変化が発生する。パフォーマンスを改善するために過去に行った最適化が、 新しい環境 パフォーマンスを損なう場合もありうるのだ。

パフォーマンスに関するもう1つの問題は、 多くの用語が一貫性なく使用されている である。 最も被害を受けているのは 「拡張性 (scalability)」 という言葉であり、さまざま ことを表すために定期的に使用されている。 ここで、私が使う用語の定義を示そう。

レスポンス時間は、システムが外部からのリクエストの処理に要する時間である。 ボタ を押すなどの UI アクションやサーバ API 呼び出しがそのようなリクエストの例だ。

レスポンス性は、システムがリクエスト処理に対し、 どれだけ早くレスポンスを返すか 表す。 システムのレスポンス性が低いとユーザは欲求不満になるので、レスポンス性は多 のシステムにとって重要である。 全体のリクエストが完了するまでシステムが待っている 合は、レスポンス時間とレスポンス性は同じである。 しかし、完了する前にリクエストを け取ったという反応を返すのであれば、レスポンス性は優れている。 たとえば、ファイル コピーしている間に進行状況を表すバーを表示させると、レスポンス時間は改善されないが ユーザインタフェースのレスポンス性は改善される。

待ち時間は、実行すべき作業が存在しなくても、 いずれかのレスポンスを得るために必 な最小時間である。一般に、この待ち時間はリモートシステムでは重要な問題である。 プ

グラムに対し何も実行しないよう要求し、 その要求が完了したら知らせるようにした場合、 プログラムをノートパソコン上で実行しているのであれば即座にレスポンスが返ってくるべ きである。 しかし、プログラムがリモートコンピュータ上で実行されている場合は、リクエ ストとレスポンスの間に、 ネットワークを通過する時間が数秒間必要だろう。 アプリケー ションの開発者が待ち時間を改善するためにできることはない。 また、 待ち時間はリモート コールを最小化すべき理由でもある。

スループットは、所定の時間内にどのくらいのことを行えるかを表した数字である。 ファ イルのコピー時間を決める場合は、スループットは1秒当たりのバイト数で測定される。 エ ンタープライズアプリケーションの標準的な単位はtps (1秒当たりのトランザクション処 理件数)だが、問題は、これが個々のトランザクションの複雑性によって決まってくること である。 特定のシステムに対しては、共通のトランザクションを選ぶ必要がある。

私の用語一覧では、パフォーマンスは、スループットかレスポンス時間のどちらかを意味 する (状況に応じて読み分けてほしい)。 ある技法によってスループットが改善されてもレ スポンス時間が低下する場合、パフォーマンスについて説明するのは難しい。 このような場 合は、より正確な用語を使うべきである。 ユーザから見ればレスポンス時間よりもレスポン ス性の方が重要なので、レスポンス時間やスループットの改善に手間を掛けるより、 レスポ ンス性を改善したほうがパフォーマンスを向上できる。

負荷は、システムがどのくらいストレスを受けているかを表す。 負荷はたとえば現在接続 しているユーザ数で測定される。この概念はふつうレスポンス時間などの測定に関して使わ れる。 あるリクエストのレスポンス時間は、10人のユーザがいた場合は0.5秒で、20人の ユーザでは2秒になる、 といった言い方をする。

負荷感度は、レスポンス時間が負荷によってどのように異なるかを表す。 たとえば、シス テムAのレスポンス時間は10~20人のユーザでは0.5秒になり、 システムBのレスポン ス時間は10人のユーザでは0.2秒、20人のユーザでは2秒になるとする。 この場合、シス テムAは、システムBよりも負荷感度は低い。 また、劣化という用語を使用して、 システ ムAよりもシステムBの方が劣化すると言う。

効率性は、リソースごとに分割されたパフォーマンスである。 2つの CPU で30tpsにな るシステムは、同じ4つの CPU で40tps になるシステムより効率がよい。 システムの容量は、実効性のある最大限のスループットまたは負荷を表す。 パフォーマン

スが許容範囲のしきい値を割り込む地点、または最大絶対値を意味する。

拡張性は、リソース (通常、 ハードウェア) の追加がパフォーマンスにどう影響するかを 示す基準である。 システムに拡張性があれば、 ハードウェアを追加すると、 それに比例して パフォーマンスが改善される。 たとえば、サーバの台数を2倍にすると、 スループットが2 倍になる。 垂直方向の拡張性すなわちスケールアップは、メモリの増設など1台のサーバに パワーを追加することを指し、 水平方向の拡張性すなわちスケールアウトは、サーバを追加

することを指す。

ここで問題なのは、 設計に関する決定がこれらすべてのパフォーマンス要因に均しく するのではないということである。 たとえば、 1台のサーバで実行している2つのソ ウェアシステムがあるとする。 Camel というシステムの容量が40tps であるのに対 Swordfish というシステムの容量は20tps である。 どちらのパフォーマンスが優れて か。 どちらの方が拡張性があるか。 このデータだけでは、拡張性についての質問に答え とはできない。 唯一言えるのは、 Camel の方が1台のサーバでは効率的だということ る。 もう1台のサーバを追加すると、 Swordfish は 35tps を処理し、 Camel は 50tps 理することになったとしよう。 Camel の方は容量に優れ、 Swordfish の方はスケール トに優れていることになる。 サーバを追加し続けると、 Swordfish の容量は追加のサー たり 15tps増加し、 Camel の容量は10tps 増加する。 このデータを考慮すると、 サーバ 台未満であれば Camel の方が効率的だが、 Swordfish の方が水平方向の拡張性に優れ ることがわかる。

エンタープライズアプリケーションを構築するときは、ハードウェアの容量や効率性 なく、 拡張性を構築することに意味があると考える場合が多い。 拡張性があれば、必要 じてパフォーマンスを向上させることができる。 また、拡張性を持たせることは容易であ 設計者は、ハードウェアを購入する方が実際には安い場合でも、 現在のハードウェアプ トフォームの容量を改善するために複雑な作業を行うことが多い。 Camel のコス Swordfishよりも高く、 そのコストがサーバ2台を追加するコストと同じである場 40tps だけが必要なら、 Swordfish の方が安くなる。 ソフトウェアを適切に実行させる には優れたハードウェアに依存するしかないことに対しての不満が広まっている。 私 Word の最新版を実行するためだけにノートパソコンをアップグレードしなければならな という不満なら大いに同感である。 しかし、 新しいハードウェアの方が、 非力なシステム ソフトウェアを実行するよりも安く済むことが多い。 同様に、システムに拡張性があるの ら、サーバを追加する方がプログラマを増やすよりも安く済むことが多いのである。

パターン

パターンには長い歴史があり、ここでその歴史を繰り返し語りたくはない。 しかし本書は パターンに対する私なりの知見と、パターンを設計記述手法として価値あるものにする方 を提供するための本である。

広く認められているパターンの定義はないが、 出発点として、 多くの熱狂的パターン主 者を鼓舞してきた Christopher Alexander の定義を採り上げよう。 「各パターンは、環境の 中で繰り返し起こる問題であり、その問題に対する解決策の核心となるものである。この

決策は、毎回違った形で何百万回でも使用できる」 [Alexander et al.)。 Alexander は建築 士なのでここでは建築物について述べているが、 ソフトウェアに関してもその定義はとても よく当てはまる。 パターンが焦点を当てるのは特定の解決策であり、繰り返し発生する1つ 以上の問題に対して共通かつ効果的に対処するためのものである。 別の見方では、パターン はアドバイスの塊であり、パターンを作成するにはいくつものアドバイスを比較的独立した 塊に分割する。こうすることで、パターンを参照し、個別に検討することができる。

パターンの重要な点は、それが実践に根差していることである。 人の行動を考察し、 物事 の動き方を観察し、 「解決策の核心」 を探すことでパターンを発見する。 容易なプロセスで はないが、優れたパターンを発見すればとても役立つ。 私にとってはリファレンス書籍を作 ることができるという点で有用である。 本書やパターンに関する他の書籍を全部読み、 それ が役立つかを判断する必要はない。 必要なのは、 書籍を読んで、何がパターンで、パターン が解決するのはどんな問題か、 パターンは問題をどのように解決するか、 などについての感 覚を十分に持つことである。 すべての詳細を知る必要はないが、問題にぶつかった場合に、 本書からパターンを探せるようになる必要がある。 そのときにそのパターンを徹底的に理解 すればよいのである。

パターンが必要になったときには、 その状況にパターンをどう適用するかを考えなければ ならない。 パターンに関して重要な点は、やみくもに解決策を適用するだけではいけないと いうことである。 これはパターンツールを使用しても悲惨な失敗を招く理由である。 パター ンは常に「生焼け」 であり、 常に実際のプロジェクトというオーブンで完成させなければな らない。 私がパターンを使用するときは、常にところどころ微調整する。 何度も同じ解決策 を目にしているようでも、 厳密には同じではないのである。

各パターンは比較的独立しているが、 分離してはいない。 あるパターンが他のパターンに 関係したり、別のパターンがあってはじめて存在するパターンがあったりする場合がある。 たとえばクラステーブル継承が存在するのは、通常、 ドメインモデルが設計に使われている 場合だけである。 パターンの間の境界は曖昧だが、本書では、各パターンをできる限り独立 した状態にしようとした。 ユニットオブワークの使用と誰かが言ったら、 その部分だけを調 べれば本書をすべて読まなくても適用方法を理解してもらえると思う。

エンタープライズアプリケーションに熟練した設計者であれば、本書に載っているパター ンの多くに見覚えがあるだろう。 「まえがき」 にも書いたが、 あまり失望しないでほしい。 パターンはオリジナルな考え方ではなく、 各分野で起こっていることについて観察した結果 に過ぎない。 そのため、パターンについて書く私たちのような物書きは、パターンを 「発明 する」とは言わず、 「発見する」 と言う。 私たちの役割は、共通の解決策の指摘、 解決策の 核心の考察、その結果として生じるパターンの記述を行うことである。 熟練の設計者にとっ てパターンの価値は、新しい考え方を示すのではなく、自らの考え方を伝達できるようにな ることである。 あなたやあなたの同僚がリモートファサードとは何かを知っていれば、 「こ

のクラスはリモートファサードだよ」 と言うだけで多くのことを伝えられる。 また、新 「データ変換オブジェクトを使ってこれを行ってくれないか」 と言えば、彼は本書を読 調べることができるだろう。 パターンは設計についての語彙を創造することになる。こ め、名前の付け方は大事な問題である。

これら多くのパターンがエンタープライズアプリケーション用であるのに対し、基 ターンの章 (第 18 章) にあるパターンは、より一般的かつ局所的である。 このパター 含めた理由は、エンタープライズアプリケーションのパターンを論じるときに参照する。 である。

パターンの構造

パターンを書く者は、パターンの形式を選択しなければならない。 [Alexander et [Gang of Four] [POSA] などの古典的なパターン書籍に基づく場合もあれば、 独自の を作り上げる場合もある。 私は GOFのような細かい形式は使いたくないが、リファレ を充実させる項目が必要である。 そこで、本書で使う項目を以下に挙げることにしよう。

1つ目の項目は、パターン名である。 パターン名はとても重要だが、 それは、設計者が 率的にやり取りするための語彙を作成することがパターンの目的の一部だからである。 えば、私の Web サーバはフロントコントローラとトランスフォームビューで構築されて ると言えば、これらのパターンについて知っている人なら、この Web サーバのアーキテ チャについてとても正確な考え方を持つことになる。

次は目的とスケッチという、互いに関連する項目である。 目的とは2、3行からなるパタ ンの要約である。 スケッチとはパターンのビジュアル表現で、 UML ダイアグラムである とが多いが、常にそうだとは限らない。 これらの項目はパターンがどのようなものである を示し、これらの項目によって速やかにパターンを思い出すことができる。 すでに 「パタ ンがある」 場合、 パターン名を知らなくても解決策がわかっているので、 そのパターンが のようなものかを知るためには目的とスケッチを見るだけでよい。

さらに次の項目では、そのパターンの使用を動機付ける問題を記述する。 パターンが解 できるのはその問題だけではないが、この問題はそのパターンを使用する動機となる最も きいものである。

動作方法では、解決策を説明する。 ここでは、実装の問題と、 私が目にしたさまざまな リエーションについて説明する。 特定のプラットフォームにはなるべく依存しないように ている。プラットフォームに固有の部分は字下げしてあるので見つけやすく、読み飛ばす ともできるだろう。 必要と思われるところにはUML ダイアグラムを挿入してある。

使用するタイミングでは、パターンをいつ使用すべきかを説明する。 別の解決策と比較 てこの解決策を選択することのトレードオフについて説明する。 本書の多くのパターンは

ページコントローラやフロントコントローラなどのように、選択肢の1つにすぎない。 常に 適切なパターンが選択されるとは限らないので、私はパターンを発見すると、常に「これを 使用しないのはどのようなときか」と自問することにしている。 この問いかけにより、他の 選択肢となるパターンを見つけることができるのである。

参考文献では、そのパターンについて解説している他の書籍を紹介する。 完全な文献リス トではもちろんない。 私はパターンを理解するのに必要な箇所だけを参照しているので、私 が記述した内容の理解に直接役立たないものは取り上げず、 また私が読んだことのないもの も除外してある。 さらに、 見つけにくい文献や、いずれなくなる恐れのある Web リンクも 記載していない。

各パターンには1つ以上の例を挙げてある。 いずれも、 使用するパターンのシンプルな例 であり、 JavaやC#のコードを使用している。 これらの言語を選択した理由は、 専門のプ ログラマの間でおそらくもっとも使用人口の多い言語だからである。 ここで重要なのは、例 とパターンは同一ではないということである。 実際にパターンを使用するときは、この例と まったく同じようになることはないので、マクロか何かのようにとらえないでいただきたい。 例はできるだけシンプルに示しているので、最も明快な形のパターンを見ることができる。 実際にパターンを使用するときに重要視しなければならないさまざまな問題は、ここでは 扱っていない。 しかし、それらの問題は環境に固有の問題であり、これが常にパターンを微 調整しなければいけない理由である。

そのため、核となるメッセージはできるだけ明確にしながら、 各例をシンプルにしたので ある。私が本書の例として選択したのは、 本番システムで必要となる各種のアイデアとパ ターンとがどう関連するかを示す例ではなく、シンプルで明確な例である。 単純化すればい いというものではないが、現実的な周辺問題がパターンの要点を理解しにくくすることも確 かである。

また、各例をシンプルにしたのは、関連した連続的な例ではなく独立した例を目指したた めでもある。 独立した例はそれだけで理解しやすいが、 どのように複数の例を1つにまとめ るかについての指針には欠ける。 関連した例は物事がどうまとめられているかを示すことは できるが、その例に関わるパターンすべてを理解せずにどれか1つのパターンを理解するこ とは難しい。互いに関連していながら個別に理解可能な例を作れなくはないが、少なくとも 私にとっては難題である。 だから独立した例を選択することにした。

例で使用するコードは、考え方をわかりやすくすることに焦点を当てて記述する。 その結 果、特にエラー処理 (この領域ではパターンを開発したことがないので私はあまり注意して いない)などのいくつかの処理を犠牲にすることになる。 純粋にパターンを説明するために コードを記述しているのであって、 特定のビジネス問題をモデル化する方法を示しているの ではない。

こうした理由で、私のWebサイトからコードをダウンロードしてもらうわけにはいかな

かった。 本書に記載するコードの例は、基本的な考えを単純化して見せるためのもので、 のまま本番の設定に役立つというようなものではないからだ。

すべてのパターンに上記の項目すべてを記述しているわけではない。 良い例や動機付 思い浮かばない場合は省略した。

本書のパターンの限界

「まえがき」に書いたように、パターンを集めただけでは、エンタープライズアプリケ ションの包括的なガイドとはならない。 本書に関する私の判断基準は、 パターンの収集が 全かどうかではなく、それらが役立つかどうかである。 パターンという分野は、1冊の書 はもちろん1人の仕事にも大きすぎる。

本書のパターンはすべて現場で目にしたパターンだが、私は派生的に起こる問題や相互 係のすべてを完全に理解しているわけではない。 本書は、私の最新の理解を反映し、その 解は本書を書き進むにつれ発展してきた。 本書が印刷された後も継続して発展させたい 願っている。 ソフトウェア開発においては、 何事も常に変化するからだ。

パターンの使用を検討するときは、そこが終点ではなく出発点だということを忘れては けない。いかなる著者も、ソフトウェアプロジェクトのすべてのバリエーションに精通す ことはできない。 私がこれらのパターンを紹介するのは、読者に出発点を提供するためで り、私や私の周囲の人が悪戦苦闘したことから得た教訓を読者に読みとっていただくため ある。どうかこれらの教訓を踏まえた上で、読者の方々それぞれの課題に挑んでいただき い。 どのパターンも完全ではなく、それぞれのシステムの環境に合わせて完成させることに 責任と喜びを持って取り組んでいただきたい。



第

概



レイヤ化は、ソフトウェア設計者が複雑なソフトウェアのシステムを分割するために する一般的な技法である。 コンピュータの構造で言えば、OS のシステムコールのある グラミング言語のレイヤの下にデバイスドライバとCPU の命令群のレイヤがあり、さ その下にチップ内のロジックゲートのレイヤがある。 ネットワークでは、FTPのレイ 下に TCP があり、その下にIP があり、さらにその下にはイーサネットがある。

レイヤの観点からシステムを考えた場合、ソフトウェアのサブシステムは、レイヤの 重なったものとして思い描くことができる。 そこでは、各レイヤはその下のレイヤに依 る。上位のレイヤは下位のレイヤで定義されたさまざまなサービスを使用するが、下位 イヤは上位のレイヤを意識しない。さらに、各レイヤは上位のレイヤから下位のレイヤ ぺいすることが多いので、レイヤ4はレイヤ3を利用し、レイヤ3はレイヤ2を利用 が、レイヤキはレイヤ2を意識することはない (レイヤ化アーキテクチャのレイヤすべ このように互いに不透明なわけではないが、多くは不透明である)。 システムをレイヤに分割することには次のように重要なメリットがいくつかある。

他のレイヤをよく知らなくても、1つのレイヤを全体として考えることができ たとえば、 イーサネットの動作方法を知らなくても、 TCP の上にある サービスを構築する方法を理解できる。

同じ基本サービスの代替実装でレイヤを置き換えることができる。 たとえ FTP サービスは、イーサネット, PPP、 またはケーブル会社が変わっても、 実行にはない。

レイヤの依存を最小限にできる。 たとえば、ケーブル会社がIP を動作さ 物理的な伝送システムを変更しても、FTPサービスを修正する必要はない。

レイヤは標準化に適している。 TCP と IPは、レイヤの動作方法を定義して るので標準である。

■レイヤを構築すれば、 多くの高水準のサービスがそのレイヤを使用できる。 こ のため、 TCP/IP は FTP、 telnet, SSH、 HTTP によって使用される。 TCP/IP がなければ、高水準のプロトコルは独自の低水準のプロトコルを作成 しなければいけない。

レイヤ化は重要な技法だが、以下のような弱点もある。

■レイヤは一部の物事をカプセル化してしまう。その結果、 連鎖的な変更が起こ る場合がある。 レイヤ化されたエンタープライズアプリケーションにおける典 型的な例は、UI(ユーザインタフェース) 上で表示すべきフィールドの追加で ある。このフィールドはデータベースに存在する必要があり、したがってUIか データベースまでのすべてのレイヤにそのフィールドを追加しなければいけ ない。

■レイヤを追加するとパフォーマンスを損ねる場合がある。 一般的には、レイヤ ごとに表示を変換する必要がある。 しかし、 基盤となる機能をカプセル化する と、 そのようなパフォーマンスの損失を補う以上の効率性をもたらすことが多 い。 トランザクションを制御するレイヤは最適化することができ、 その結果す べての機能を高速にすることができる。

しかし、レイヤ化アーキテクチャにおいて最も難しいのは、必要なレイヤと、各レイヤが 行うべき内容を決定することである。

1.1 エンタープライズアプリケーションのレイヤの発展

私は初期のバッチシステム開発には乗り遅れた世代だが、 その頃はレイヤについて誰もあ まり考えていなかったと思う。 何らかのファイル形式 (ISAM、 VSAM など) を操作する プログラムを作成すれば、それがアプリケーションになり、レイヤを適用する必要はなかっ たのだ。

レイヤの概念は90年代のクライアント/サーバシステムの発展とともに明確になった。 クライアント/サーバシステムは2レイヤのシステムであった。 クライアントはUIとその 他のアプリケーションコードを保持し、 通常サーバはリレーショナルデータベースであった。 一般的なクライアントツールはVB、 Powerbuilder, Delphi だった。 これらのツールは SQL を認識する UI ウィジェットを持っていたので、データ量の多いアプリケーションを容 易に構築することができた。 デザイン領域にコントロールをドラッグすることで画面を構築

し、 プロパティシートを使ってそのコントロールをデータベースに接続することができ である。

アプリケーションが表示とリレーショナルデータのシンプルな更新だけを行う場合、 イアント/サーバシステムは適切に動作した。 問題は、ビジネスルール、 妥当性、 計算 のドメインロジックを伴ったときである。 通常はクライアント側でこれらを作成するか の際ロジックをUI画面に直接組み込むというやっかいな方法が採用される。 ドメイ ジックが複雑になればなるほど、 コードの扱いが難しくなる。 さらに、 画面にロジック み込むことでコードが重複しやすくなる。 そのため、 シンプルな変更を行う場合でも、 の画面に散らばる同様のコードを見つけて変更しなければいけないことになる。

この問題の解決案として、 ドメインロジックをストアドプロシージャとしてデータベ に格納することが挙げられる。 しかし、 ストアドプロシージャには弱点があり、 その構 メカニズムには限度があるため、 再びやっかいなコードの作成につながってしまう。 さら リレーショナルデータベースを好む人が多いのは SQL が標準であるためデータベース ダーを変更しやすいからであるが、ストアドプロシージャだけは各データベースベンダ 有のものなので、ベンダー変更に際しての選択肢がなくなってしまうという問題もある 際にデータベースベンダーを変更する人はほとんどいないのに、なぜか多くの人は移植 いコストをかけずにベンダーを変更できる選択肢を持ちたがるのだ)。

クライアント/サーバが人気を博したのと同じ頃、 オブジェクト指向も注目を集めてい オブジェクトコミュニティは、 「3レイヤのシステムに移行する」ことでドメインロジッ 関する問題を解決した。 3レイヤシステムには、 UI用のプレゼンテーションレイヤ、 インロジック用のドメインレイヤ、データソースのレイヤがある。 これによって、 すべ 複雑なドメインロジックをUIから、 オブジェクトによって適切に構造化できるレイヤ すことができたのである。

だが、オブジェクト指向は主流にならなかった。 多くのシステムはまだあまりにシンプ だった少なくとも開発時は。 3レイヤの手法には多くのメリットがあったが、問題が ンプルなものであれば、クライアント/サーバシステム用のツールを使用することで解決 きた。 クライアント/サーバシステム用のツールは、 3レイヤの構成で使用するには扱い くく、まったく使えないこともあった。

その後、Web の登場によって激震が走った。 急に誰も彼もが Web ブラウザーでクラス アント/サーバアプリケーションを展開することを望みだした。 しかし、ビジネスロジッ がすべてリッチクライアントに埋め込まれている場合は、すべてのビジネスロジックを 直して Web インタフェースを持たせなければならない。 適切に設計された3レイヤシス ムなら、 新しいプレゼンテーションレイヤを加えるだけでこれを行うことができる。 そして Java の登場によってオブジェクト指向言語が堂々と主流を占めるようになった。 Web ペ ジ構築用に登場したツールは、 SQL に拘束されることが少ないので、 3つ目のレイヤで使

やすいのである。

レイヤ化について語るとき、 レイヤ (layer) とティア (tier) がよく混同される。 この2 つの用語は同義語として使用されることが多いが、 多くの人はティアを物理的に区別される ものととらえている。 クライアント/サーバシステムは、 2ティアシステムとして説明され ることが多い。 クライアントはデスクトップであり、サーバはサーバであり、両者の区別は 物理的なものだからだ。 本書では、異なるマシンでレイヤを実行する必要がないことを強調 するためにレイヤという用語を使用している。 ドメインロジックのレイヤはデスクトップか データベースサーバのどちらかで実行されることが多い。 この状況ではノードは2つだが、 レイヤは3つである。 ローカルのデータベースであれば、1つのノートパソコンで3つのレ イヤすべてを実行できるが、それらはあくまで3つの異なるレイヤである。

1.2 3つの主なレイヤ

本書では、プレゼンテーション、ドメイン、 データソースという3つの主要なレイヤから なるアーキテクチャに焦点を絞る (これらの呼び名は[Brown et al.]に従っている)。 表 1.1 にこれらのレイヤを要約する。

表 1.1 3つのレイヤ

レイヤ 役制 プレゼンテーションレイヤ ドメインレイヤ データソースレイヤ サービスの提供、情報の表示 (たとえば Windows や HTML の場合 なら、ユーザのリクエスト (マウスのクリック、 キーボードの押下)、 HTTPリクエスト、 コマンドライン呼び出し、 バッチ API を処理する) システムそのものであるロジック データベース、メッセージングシステム、 トランザクションモニタ、 その他のパッケージとの通信

プレゼンテーションロジックは、ユーザとソフトウェアとの相互作用を扱う。 このロジッ クは、コマンドラインやテキストベースのメニューシステムと同じくらいシンプルな場合も あるが、現在はリッチクライアントのグラフィック UIやHTML ベースのブラウザー UI になる傾向が強い (本書では、 HTML ブラウザーではなく、 Windows や Swing などの ファットクライアントのUIを意味する用語としてリッチクライアントを使う)。 プレゼン テーションレイヤは、主にユーザに情報を表示したり、ユーザからのコマンドをドメインや データソースでの動作に変換したりする。

データソースロジックは、他のシステムとの通信を行い、 アプリケーションのためにタス クを実行する。 トランザクションモニタ、他のアプリケーション、メッセージングシステム

などと通信する。 エンタープライズアプリケーションの多くでは、データソースロジック 永続的なデータを格納するデータベースであることが多い。

残るドメインロジックは、ビジネスロジックとも呼ばれる。 現在作業中のドメインに対し アプリケーションが行うべき作業である。 入力データと格納データに基づく計算、 プレモ テーションから送信されたデータの妥当性確認、プレゼンテーションレイヤから受信したコ ンドに応じてどのデータソースロジックを呼び出すかの決定などが、この作業に含まれる。

レイヤの配置において、 ドメインレイヤがプレゼンテーションレイヤからデータソース イヤを完全に隠ぺいするように配置されている場合がある。 しかし、もっと多いのは、フ ゼンテーションからデータストアに直接アクセスする場合である。 これはあまり美しい方 ではないが、実際には適切に動作することが多い。 プレゼンテーションレイヤはユーザか のコマンドを解読し、データソースを使ってデータベースレイヤから関連データを抽出する そして、ドメインロジックにそのデータを操作させ、画面に表示させる。

1つのアプリケーションには、この3つの分野ごとに複数のパッケージが存在すること 多い。 リッチクライアントのインタフェースを利用するエンドユーザだけでなく、コマン ラインを利用するユーザも操作できるように設計されたアプリケーションには、2つの ゼンテーションがある。 1つはリッチクライアントのインタフェース用、 もう1つはコマ ドライン用のプレゼンテーションである。 さまざまなデータベースに対して複数のデー ソースコンポーネントが存在するが、これは特に、既存のパッケージと通信するためである。 ドメインは互いに関連のない領域に分割される可能性がある。 データソースパッケージは 定のドメインパッケージにしか使用されないということもある。

ここまではユーザを中心に説明してきた。 そこで、ソフトウェアを動かす人間がいない きに何が起こるかという疑問が湧いてくる。 おそらく、 それは Web サービスのような新 い流行のものか、 またはバッチ処理のような日常的で実用的なものだろう。 後者の場合 ユーザはグライアントプログラムである。 この点で、プレゼンテーションレイヤとデー ソースレイヤには多くの類似点があるように見える。 どちらも外部との接続に関するレイ だからだ。 これは、 Alistair Cockburn のヘキサゴナルアーキテクチャ (Hexagona Architecture 六角形のアーキテクチャ) パターン [wiki]の背後にあるロジックである。 キサゴナルアーキテクチャは、外部システムへのインタフェースで囲まれた核としてシス ムを視覚化したものである。 ヘキサゴナルアーキテクチャでは、外部にあるものは基本的 すべて外側のインタフェースであり、したがってこれは対称的なビューであって、私の言 非対称のレイヤ化スキーマではない。

しかし、私はこの非対称性こそ有用だと思っている。 他へのサービスとして提供するイ タフェースと、他のサービスを使用することとの間には、歴然とした違いがあるからだ。 心に触れていえば、これこそが私の言うプレゼンテーションとデータソースとの違いなので ある。プレゼンテーションは、他者に対してシステムが提供するサービスの外部インタ

フェースである。この場合、 提供する相手が複雑な人間であるか、または単純なリモートプ ログラムであるかは問わない。 データソースは、サービスを提供するものへのインタフェー スである。 クライアントが異なるとサービスの考え方が変わるので、これらを分けて考える ことは有用であると私は考える。

どのエンタープライズアプリケーションにもプレゼンテーション、ドメイン、 データソー スという3つのレイヤとそれぞれの役割があることを見てきたが、これらのレイヤをどう分 けるかは、アプリケーションがどれだけ複雑であるかによって違ってくる。 データベースか らデータを抽出し、 Web ページに表示するというシンプルなスクリプトなら、すべて1つ の手続きに収まるだろう。 3つのレイヤに分けるとしても、各レイヤの振る舞いをそれぞれ サブルーチンとするだけで十分だろう。 システムがもっと複雑になれば、3つのレイヤを 個々のクラスに分割する。さらに複雑になった場合は、 クラスをいくつかのパッケージに分 割する。 私の一般的なアドバイスは、 「状況に応じて最も適切な分割の仕方を選択すること、 ただし最低限サブルーチンレベルの分割は行ったほうがよい」 というものである。

分割だけでなく、 依存性についても確かなルールがある。 ドメインとデータソースはプレ ゼンテーションに依存してはいけない、言い換えると、 ドメインコードやデータソースコー ドからプレゼンテーションコード内のサブルーチンを呼び出してはならない、というものだ。 このルールによって、 同じ土台の上で別のプレゼンテーションに置き換えやすくなり、深刻 な問題を派生させずにプレゼンテーションを修正できるようになる。 ドメインとデータソー スとの関係はより複雑で、データソースのアーキテクチャパターンによって異なる。

ドメインロジックの扱いで最も難しいのは、人々が思っているように、 何がドメインロ ジックで何が他のロジックかを見極めることだろう。 私が好きな非公式のテストは、Web アプリケーションにコマンドラインインタフェースを追加するときのように、まったく異な るレイヤをアプリケーションに追加することを想像するというものである。 この追加を行う ときに機能を複製する必要があれば、 それはドメインロジックがプレゼンテーションの中に はみ出していることを示している。 同様に、リレーショナルデータベースをXML ファイル で置き換えるために、ロジックを複製する必要があるかどうか考えてみるとよい。

その良い例として、 製品一覧を表示するシステムを考えてみよう。 この一覧では、前月よ りも販売が10パーセント増となったすべての製品が赤い字で表示される。 これを実現する ため、開発者は当月の売り上げと前月の売り上げを比較するロジックをプレゼンテーション レイヤに配置し、 前月と当月の差異が10パーセント以上ある場合は赤で強調する。

しかし、ここで問題なのは、ドメインロジックがプレゼンテーションに入り込んでいるこ とである。 レイヤを適切に分離するためには、売り上げが増加しているかどうかを示すメ ソッドがドメインレイヤ上に必要である。 このメソッドが2ヶ月の売り上げを比較し、 論理 値を返す。 プレゼンテーションレイヤは、この論理メソッドを呼び出して、真であれば製品 名を赤で強調する。 こうすれば、 強調表示すべきものがあるかどうかを判断する部分と、 ど

のように強調表示するかを選択する部分とにプロセスを分割できる。

分割の仕方に関して、私は教条的すぎないだろうかという不安もある。 本書の原稿を読 でもらったとき、 Alan Knight はこう言った。 「これをUIに押しつけるのは、地獄への やかな下り坂の第一歩なのか、純粋な教条主義者だけが反対する完全に合理的な行動なのか 悩んでいる」。 私たちが不安になるのは、 どちらもあり得るからである。

1.3 | レイヤの実行場所の選択

本書の大半は、論理的なレイヤについての説明である。 つまり、システムをいくつかに 割して、 システムの異なる部分間の結合を減らすことの説明である。 レイヤ間の分割は、 べてのレイヤが1台の物理的なマシンで実行されていたとしても役立つことである。 しかし システムの物理的な構造によって違いがもたらされる場所がある。

多くのISアプリケーションにとって、 クライアントであるデスクトップマシンとサー のどちらで処理を実行すべきかは大きな問題である。

最もシンプルなのは、サーバですべてを実行することである。 Web ブラウザーを使用 HTML フロントエンドは、 これを実行するための優れた方法である。 サーバ側で実行 ることの最大の利点は、サーバは限られた範囲内にあるので、アップグレードと修正が容 に行えることである。 無数のデスクトップマシンに配備したり、 サーバと同期を取ったり ることをあれこれ悩む必要はない。 他のデスクトップソフトウェアとの互換性についても 配する必要はない。

クライアント側で実行することの利点は、 レスポンス性や切断時の操作である。 サーバー 実行するロジックには、クライアントからサーバへの往復が必要である。 ユーザが何か操 して即座のフィードバックを求めるとき、この往復は障害になる。 ネットワーク接続も必要 である。 ネットワークなんてどこにでもあるかもしれないが、私が本書を書いている時点で は、高度9000メートルの上空にはない。 いずれどんな場所でもネットワークが使えるよう になるとしても、無線の受信範囲が無限大に広がるまで待てず、 今すぐに作業を行いたい ユーザもいるのである。 切断時の操作については別の問題があるが、残念ながら本書では れる余裕がない。

さて、これらを基にレイヤごとの選択肢を考えてみる。 データソースは、常にサーバでた け実行される。例外は、 切断時にも操作を行いたいときに、 サーバの機能を適切かつ強力な クライアントに複製する場合である。 この場合、 切断されたクライアントからデータソース に対して加えられた変更は、 サーバと同期させる必要がある。 すでに述べたとおり、これら の問題は別の機会または別の執筆者に委ねることにしよう。

プレゼンテーションを実行する場所は、 UI の種類によって決まることが多い。 リッチグ

ライアントの実行は、クライアントでプレゼンテーションを実行するのとほとんど同義であ る。Webインタフェースはたいていサーバ上で実行される。 いくつか例外があり、 稀にで はあるが、たとえばクライアントソフトウェアを遠隔操作したり (Unix の X サーバなど)、 デスクトップで Web サーバを実行したりすることがある。

B2C システムを構築する場合は、 選択肢はない。 誰かが TRS-80 でオンラインショッピ ングを行いたいと思っているときに、 それを拒否するわけにはいかないだろう。 このような 場合は、サーバですべての処理を行い、ブラウザーで扱える HTML を提供する。 HTML を使用すると、すべての意思決定にクライアントからサーバへの往復が必要となり、これに よってレスポンス性が損なわれる。 ブラウザーのスクリプトやダウンロード可能なアブレッ トである程度遅延を緩和できるとしても、そのためにブラウザーの互換性が減少し、 他の頭 痛の種が生じるかもしれない。 HTML が純粋なほど、精神衛生上は楽である。

IS 部門が一台一台愛情込めてデスクトップを手作りしたとしても、精神的な安らぎは大 きな魅力である。 クライアントを最新の状態に保つことと、他のソフトウェアとの互換性に よるエラーを回避することは、シンプルなリッチクライアントシステムも抱える問題である。

リッチクライアントのプレゼンテーションをユーザが望むのは、ユーザが実行するには複 雑すぎるタスクがあり、 使いやすいアプリケーションにするためには、 Web GUI が提供す る以上の機能を必要とするからである。 しかし、 ユーザは Web フロントエンドを使いやす くする方法に徐々に慣れ、リッチクライアントのプレゼンテーションの必要性は少なくなっ てきている。 今のところ私としては、できるだけ Web プレゼンテーションを使用し、 他に 選択肢がないときだけリッチクライアントを使用することを勧めたい。

最後にドメインロジックが残っている。 ビジネスロジックは、すべてサーバで実行するこ とも、すべてクライアントで実行することも、サーバとクライアントに分割して実行するこ ともできる。 繰り返しになるが、すべてサーバで実行することが、 保守を容易にするための 最善の選択である。 クライアントへの移行が必要になるのは、レスポンス性か切断時の操作 を優先するときである。

クライアントでロジックの一部を実行する必要がある場合は、クライアントでそのロジッ クすべてを実行すること (少なくともロジックを一箇所に存在させるようにすること)を考 えてみよう。 これはリッチクライアントには適している。 クライアントマシンで Web サー バを実行しても、切断時の動作に対処する方法にはなるが、レスポンス性の向上には役立た ない。このような場合は、 トランザクションスクリプトかドメインモデルのどちらかを使用 して、プレゼンテーションから分離したモジュールにドメインロジックを保持することがで きる。クライアントにすべてのドメインロジックを持ち込むと、バージョンアップと保守の 作業が増えるという問題がある。

デスクトップとサーバの両方に分割すると、どこにロジックがあるのかわからなくなるの で、クライアントにとってもサーバにとっても最悪の事態となる。 このような分割を行うの

は、クライアントで実行すべきドメインロジックが少ししかないときである。 この場合 訣は、このロジックをシステムの他の部分に依存しない内蔵モジュールに隔離すること る。この方法で、クライアントまたはサーバのモジュールを実行できる。 ややこしい操作 必要とするが、 目的を成し遂げるための優れた方法ではある。

処理ノードを一度選択すると、1つのノードで動かすにせよ、クラスタ内の複数のノー で動かすにせよ、単一プロセスですべてのコードを保持する必要がある。 絶対に必要な場 を除いて、 レイヤを別々のプロセスに分離してはいけない。 別々のプロセスに分離する リモートファサードやデータ変換オブジェクトのような処理を追加する必要があるので、 フォーマンスが低下し、 複雑性も大きくなる。

このような処理を Jens Coldewey が複雑性のブースター (complexity booster) と でいることを覚えておくとよい。 複雑性のブースターには、分散、明示的なマルチスレッ 化、 パラダイムの食い違い (オブジェクトかリレーショナルか)、 マルチプラットフォー の開発、 (1秒当たり 100 トランザクション以上といったような) 極めて高いパフォーマ ス要求などがある。これらのコストはすべて高い。 どうしても避けられない場合も無論 が、開発と保守の両面でコストがかさむことを忘れてはいけない。



ドメインロジック

ドメインロジックの構築について、 私はこれをトランザクションスクリプト ドメイン デル、テーブルモジュールという3つの主要なパターンに分類している。

ドメインロジックを格納するための最もシンプルな手法は、 トランザクションスクリプ である。 トランザクションスクリプトは、本質的にはプレゼンテーションからの入力を取 するための手続きであり、妥当性確認と計算によって入力を処理し、 データベースにデー を格納し、他のシステムの操作を呼び出す。 そして、 多くのデータを使ってプレゼンテー ションに応答し、さらに計算を行ってその応答を体系的に書式化する。 ユーザが望んでいる アクションのための手続きを1つずつ構築するのが基本である。 そのため、このパターン アクション用のスクリプト、 またはビジネストランザクションとして考えることができる 単一のインラインコードである必要はなく、 いくつかのサブルーチンに分割され、これらの サブルーチンは異なるトランザクションスクリプト間で共有することができる。 しかし、 のパターンは各アクションの手続きにより起動するので、たとえば小売システムなら チェックアウト ショッピングカートへの追加、配送状況の表示のために、それぞれトラン ザクションスクリプトがあるだろう。

トランザクションスクリプトには以下のような長所がある。

■開発者なら大半の人が理解できるシンプルな手続き型モデルである。

■行データゲートウェイやテーブルデータゲートウェイを使用するシンプルなデー タソースレイヤと適切に連携する。

■トランザクションの境界を設定する方法がはっきりしている。 トランザクショ ンをオープンして開始し、それをクローズして終了する。 ツールを使えば容易 にバックグラウンドで処理できる。

残念ながら短所も多い。 ドメインロジックが複雑になると、 短所が見えてくる。 いくつか

のトランザクションが同じ動作を行う必要があるので、 コードが重複することが多い。 その 重複の一部は共通のサブルーチンを抜き出すことで対処できるが、多くは削除するのも発見 するのも難しい。 結局は、 明確な構造を持たないルーチンの絡まり合いのようなアプリケー ションができあがることになる。

もちろん複雑なロジックはオブジェクトが関わるところであり、 オブジェクト指向ではこ の問題をドメインモデルで対処する。 ドメインモデルでは、少なくとも概要レベルで、 主に ドメイン内の名詞について体系化したモデルを構築する。 このため、たとえば賃貸システム なら、賃貸借契約、 資産などのクラスがあるだろう。 妥当性確認や計算のためのロジックは ドメインモデルに配置されるので、出荷オブジェクトには、配送料を計算するためのロジッ クが含まれるだろう。 さらに請求書計算のルーチンもあるだろうが、このような手続きはド メインモデルのメソッドに速やかに委譲される。

トランザクションスクリプトではなくドメインモデルを使用することは、 オブジェクト指 向のユーザが言うところのパラダイムシフトのエッセンスである。 1つのルーチンがユーザ アクションのすべてのロジックを持つのではなく、 各オブジェクトが自身に関連する部分の ロジックを担当する。 ドメインモデルに慣れていないユーザは、振る舞いがどこで行われて いるかを見つけるために各オブジェクトを探し回らなければならないので、 ドメインモデル の使い方を学ぶ際にフラストレーションを感じることが多い。

この2つのパターンの本質的な違いを、シンプルな例を使って理解するのは難しい。 それ でも私は、パターンの説明をする際に、シンプルなドメインロジックを両方のパターンで構 築し、それらの相違を把握しようとしたことがある。 違いを見つけるための最も容易な方法 は、それぞれのパターンに従ってシーケンス図を描いてみることだ (図2.1 と図 2.2)。 ここ での重要な問題は、 製品 (Product によって、所定の契約 (Contract) の収益を認識する ためのアルゴリズムが異なることである (詳細は第9章を参照)。 計算メソッドは、その契 約がどの製品のものであるかを決定し、正しいアルゴリズムを適用してから、計算結果を把 握するための収益認識 (Revenue Recognition) オブジェクトを作成しなければいけない (話を単純にするために、データベースの相互作用の問題はここでは考えない)。

28

Recognition Service calculate Recognitions (contractID) Data Gateway findContract (contractID) get data *insert revenue recognition contract result set

図 2.1- ートランザクションスクリプトによる収益認識の計算

calculate Recognitions Contract Product Recognition Strategy calculate Recognitions (Contract) calculate Recognitions (Contract) Revenue Recognition new

図 2.2 ードメインモデルによる収益認識の計算

図2.1では、トランザクションスクリプトのメソッドがすべての作業を行う。 基礎となる オブジェクトはテーブルデータゲートウェイで、これはトランザクションスクリプトにデー タを渡すだけである。

これに対し、 図2.2には複数のオブジェクトが存在し、 Recognition Strategy (認識スト ラテジー) オブジェクトが結果を作成するまで、各オブジェクトは振る舞いの一部を別の ブジェクトへ転送している。

ドメインモデルが持つ価値は、いったん慣れてしまえば、ロジックが複雑になっても十分 に体系化された方法で対処できる多くの技法があることである。 収益認識の計算のアルゴリ ズムが増えても、 新しい Recognition Strategy オブジェクトを追加することでこのアルゴ リズムを追加できる。 トランザクションスクリプトの場合は、スクリプトの条件分岐ロジッ クを追加して、 アルゴリズムを追加することになる。 私のようにオブジェクトに傾倒してい る者なら、かなりシンプルなケースでもドメインモデルの方を選びたくなるだろう。

ドメインモデルのコストは、それを使用するときの複雑性とデータソースレイヤの複雑性

から生じる。 リッチなオブジェクトモデルを使用したことのない新規のユーザが、 リッチな ドメインモデルに慣れるまでには時間がかかる。 開発者でさえこのパターンを使用するプロ ジェクトで数カ月間作業してみてはじめてパラダイムシフトを経験することが多い。 けれど もいったんドメインモデルを使うことに慣れてしまえば、もう離れられなくなり、 その代 わり将来の仕事は楽になる。 こうして、私のようなオブジェクトしか好きになれない偏屈者 ができるわけだ。 しかし中には、このパラダイムシフトを経験しない開発者も少ないながら いるようである。

パラダイムシフトを経験できたとしても、データベースへのマッピングがまだ残っている。 ドメインモデルがリッチになるにつれ、リレーショナルデータベースへのマッピングは複雑 になる(ふつうはデータマッパーを使用する)。 洗練されたデータソースレイヤは、固定費 のようなものだ。優れたレイヤを得るには多額の経費(購入する場合)、または時間(構築 する場合) がかかるが、レイヤが取得できれば多くのことを行える。

ドメインロジックを構築するための3つ目の選択肢は、テーブルモジュールである。 テー ブルモジュールとドメインモデルは、一見するとどちらも Contract (契約)、 Product (製 品) Revenue Recognition (収益認識) のクラスを持っているので、似ているように見え る。大きな違いは、ドメインモデルには契約ごとに Contract のインスタンスがあるのに対 し、テーブルモジュールには1つのインスタンスしかないことである。 テーブルモジュール は、レコードセットに対処するように設計されている。 このため、テーブルモジュールとい う Contract のクライアントは、データベースに最初にクエリーを発行して、 レコードセッ トを作成する。また、Contract オブジェクトを作成し、レコードセットを引数として渡す。 こうして、クライアントは契約に関する操作を呼び出していろいろなことが行えるようにな る(図2.3)。 個別の契約に対して何かを行いたい場合は、ID を渡さなければいけない。

テーブルモジュールはさまざまな意味でトランザクションスクリプトとドメインモデルの 中間に位置する。 直線的手続きではなく、テーブルを中心にドメインロジックを構築するこ とで、 構造がわかりやすく、 重複の発見と除去が容易になる。 しかし、精度の高いロジック 構造を得るためにドメインモデルが用いる多くの技法 (継承やストラテジー、その他のオプ ジェクト指向パターン)は使用できない。

new (theDataSet) Contract calculate Recognitions (contractID) | new (theDataSet) Product new (theDataSet) Revenue getProductType (productID) Recognition insert

図 2.3 テーブルモジュールによる収益認識の計算

テーブルモジュールの最大の長所は、他のアーキテクチャにうまく適合することであ 多くのGUI環境は、レコードセットにまとめられた SQL クエリーの結果に従って動作す ように構築されている。 テーブルモジュールはレコードセット上で動作するので、 クエリ の実行、テーブルモジュールの結果の操作、表示用の操作データのGUI への送信などを 易に行うことができる。 また、 さらに詳細な妥当性確認と計算を行うために、テーブル ジュールを使用することもできる。 多くのプラットフォーム、 特に Microsoft の Co と.NET は、 この開発スタイルを採用している。

21 |選択

この3つのパターンからどうやって選ぶか。 これは容易な選択ではなく、ドメインロジ クがどれだけ複雑かによって異なる。 図 2.4 は PowerPoint のプレゼンテーションでよく る類のあまり科学的ではないグラフで、 座標軸にまったく数値が示されていないのが残念 が、それでも3つのパターンに関する私の見解を視覚化するには役立つ。 ドメインモデル シンプルなドメインロジックに対して使用するには魅力的ではない。 このパターンを理解 るのは難しくデータソースも複雑なので、 開発に多くの努力が必要になり、しかもその りが小さいからである。 しかし他の手法には、ドメインロジックが複雑になると機能を迫 するのが飛躍的に難しくなるという難点がある。

機能追加の 劳力 トランザクションスクリプト/ テーブル モジュール ドメインモデル

ドメインロジックの複雑性

図24 ドメインロジックの各形式の複雑性と労力の関係

肝心なのはもちろん、自分のアプリケーションがx軸のどこに位置するかを見極めること である。これを見極めるためには、ドメインロジックの複雑性が7.42 を超えたら、 ドメイ ンモデルを使用すべきだ。 しかし残念なことに、ドメインロジックの複雑性を測定する方法 は誰も知らないのである。 そこで実際には、 初期の要求分析を行える熟練した人を見つけ、 その人に判定してもらわなければならない。

この図の曲線にはいくつかの修正要因がある。 ドメインモデルを熟知したプロジェクト チームなら、このパターンの使い方を習得するための初期コストはかからない。 データソー スの複雑性について言えば、他の手法ほどコストは削減できない。 それでも私は、優秀なプ ロジェクトチームにはドメインモデルを使用するように勧めることが多い。

テーブルモジュールの魅力は、共通のレコードセット構造を環境がサポートしているかど うかによって違ってくる。レコードセット用の多くのツールが動作する.NET や Visual Studio のような環境であれば、テーブルモジュールはとても魅力的である。 .NET 環境でト ランザクションスクリプトを使用する理由はない。 しかし、レコードセット用の特別なツー ルがないときは、わざわざテーブルモジュールは使用しないだろう。

一度行った決定はまったく変えられないわけではないとしても、変更するのはなかなか難 しいものだ。このため、どのような決定を行うかについては前もって十分に思案しなければ

2

ならない。 間違った決定を行ったことに気付いた場合、またはトランザクションスクリプ で始めた場合は、ドメインモデルの方向へためらわずにリファクタリングしてほしい。 し し、データソースレイヤを単純化できなければ、 トランザクションスクリプトの方へ移行 るのはあまり意味がない。

これら3つのパターンは相互に排他的な選択肢ではない。 実際にドメインロジックの にトランザクションスクリプトを使用し、それ以外にテーブルモジュールまたはドメイン デルを使用することは珍しくない。

2.2 サービスレイヤ

ドメインロジックを扱うときの共通の手法は、 ドメインレイヤを2つに分割することで る。サービスレイヤは、ドメインモデルまたはテーブルモジュールの上に配置する。 サー スレイヤはふつうドメインモデルかテーブルモジュールとともに使用する。 トランザクシ ンスクリプトだけを使用するドメインレイヤは、レイヤを分割するほど複雑ではないからだ プレゼンテーションロジックは、アプリケーションの API の役割を果たすサービスレイ だけを通してドメインとやりとりする。

サービスレイヤは明確な API を提供するだけでなく、 トランザクションの制御やセキ リティの確保のために最適な場所である。 これは、 サービスレイヤに各メソッドを置いて ランザクションとセキュリティの特性を記述するシンプルなモデルである。 個別のプロ ティファイルを使用するのが共通の選択肢だが、 .NET の属性はコードで直接記述するこ ができる。

サービスレイヤでは、どの程度の振る舞いをそこに加えるかを決めることが重要である 最小限にする場合は、サービスレイヤをファサードにする。 これにより、 実際の振る舞いに すべて下位のオブジェクトにあり、サービスレイヤは下位のオブジェクトにファサードへの 呼び出しを転送するだけになる。 この場合、 サービスレイヤはユースケース中心の配置に るので、 使いやすい API を提供できる。 また、 トランザクションラッパーとセキュリテ チェックを追加するのにも便利である。

これに対して、多くのビジネスロジックはサービスレイヤ内のトランザクションスクリプ トに置かれる。 下位のドメインオブジェクトはとてもシンプルである。 それがドメインモデ ルであれば、データベースと一対一の関係になるので、 アクティブレコードなどのシンプル なデータソースレイヤを使用することができる。

これらの選択肢の中間には、コントローラーエンティティという振る舞いの組み合わせが ある。この名前は、 [Jacobson et al.jに大きな影響を受けた共通的なプラクティスに由来し ている。ここでの要点は、 トランザクションスクリプト内に配置される1つのトランザク

ションまたはユースケースに特有のロジックを持つことである。 そのロジックは通常コント ローラまたはサービスと呼ばれる。 これらは、後で説明するモデルビューコントローラやア プリケーションコントローラの入力コントローラとは異なるコントローラなので、ユース ケースコントローラと呼ぶことにする。 複数のユースケースで使用される振る舞いは、 ドメ インオブジェクトに移り、 エンティティと呼ばれる。

コントローラーエンティティ手法は一般的だが、私はあまり好きではない。 ユースケース コントローラは、トランザクションスクリプトと同じように、コードの重複を促進する傾向 がある。私の考えでは、いったんドメインモデルを使用すると決めたらそれを貫き、このモ デルを中心にすべてを進めるべきである。 唯一の例外は、 行データゲートウェイとともにト ランザクションスクリプトを使用する設計から始めた場合である。 重複する振る舞いを行 データゲートウェイに移行することには意味があり、これによりアクティブレコードを使用 するシンプルなドメインモデルになる。 しかし、 私ならこのように始めたりはしない。 この ように行うのは、欠陥のある設計を改善する場合だけである。

私はビジネスロジックを含むサービスオブジェクトを持つべきでないと言っているのでは ない。 サービスオブジェクトの固定レイヤを必ずしも作成しなくてもよいと言っているので ある。 手続き型サービスオブジェクトはロジックを抽出するのに役立つこともあるが、 私個 人はアーキテクチャレイヤとしてではなく、必要なときにだけ使用することが多い。

私が気に入っている方法は、サービスレイヤが必要な場合でも、 できる限り薄いレイヤに することである。私のいつもの方法では、本来ならサービスレイヤは1つもいらないという 前提で、アプリケーションに必要だと思われる場合にだけ追加する。 ただし、 常に大量のロ ジックとともにサービスレイヤを使用する優れた設計者はたくさんいるので、私のこの方法 は無視してもらって結構である。 Randy Stafford はリッチなサービスレイヤを使用して多 くの成功を収めているので、 彼にはサービスレイヤのパターンを本書のために書いてくれる ように依頼した。

34

リレーショナルデータベースへのマッ

データソースレイヤの役割は、アプリケーションが動作するために必要なさまざまなイ フラと通信することである。 その際に発生する問題の大部分はデータベースとのやり取り ある。 現在のシステムの大半において、 データベースとはリレーショナルデータベースの とを指す。 メインフレームのISAM ファイルや VSAM ファイルなど、旧式の格納フォ マットのデータもまだ多く残っているとはいえ、 今日システム構築に携わる人の苦労の種 なっているのはリレーショナルデータベースの扱いである。

リレーショナルデータベースが成功した最大の理由は、データベースと通信する際の標 言語となったSQL の存在である。 SQL には、面倒で複雑なベンダー固有の拡張も多い 基本的な構文は共通的かつ汎用的である。

3.1 アーキテクチャに関するパターン

最初に取り上げるパターンは、ドメインロジックがデータベースとやり取りするため アーキテクチャに関するパターンである。 ここで行う選択は設計全般に影響し、 やり直し 難しいので注意が必要である。 逆に、この選択はドメインロジックの設計の仕方によって きく影響されるものでもある。

エンタープライズソフトウェアでは SQL が広範囲で使われているが、その使用には落 し穴がある。 多くのアプリケーション開発者はSQL を十分理解していない。その結果、 果的なクエリーとコマンドを定義できないという問題が生じる。 SQL をプログラミング 語に組み込む技法はいろいろあるが、いずれもあまり優れたものではない。 アプリケーシ ン開発言語に適合したメカニズムを使用してデータにアクセスした方がましである。 DB (データベース管理者) はテーブルにアクセスする SQL を好むが、 その方が最善のチュー ング方法やインデックスの配置方法を理解しやすいからである。

PersonGateway lastname firstname numberOfDependents insert update delete find (id) | findForCompany(companyID)

図3.1クエリーから返された行ごとに1つのインスタンスを持つ行データゲートウェイ

これらの理由から、ドメインロジックと SQL アクセスを分離し、 異なるクラスに配置す ることが賢明である。これらのクラスを組織化する適切な方法は、 データベースのテーブル 構造に基づいて、データベーステーブルごとに1つのクラスを持つようにすることである。 これらのクラスはそのテーブルに対しゲートウェイを形成する。 アプリケーションの他の部 分は SQL について知る必要はなく、 データベースにアクセスする SQL はすべて容易に見 つけられる。 データベースを専門とする開発者には、 何を行うべきかは明確である。

ゲートウェイを使用できる主な方法は2つある。 最も明白な方法は、 クエリーから返され た行ごとにインスタンスを持つことである (図3.1)。 この行データゲートウェイは、データ に関するオブジェクト指向の考え方に自然に適合する手法である。

多くの環境では、レコードセット、つまりデータベースのテーブルの性質を持つ、テーブ ルと行で構成された包括的なデータ構造が提供される。 また、レコードセットは包括的な データ構造なので、アプリケーションの多くの部分にレコードセットを使用できる。 GUI ツールがレコードセットと連携するコントロールを持つことはとても一般的である。 レコー ドセットを使用する場合は、データベースの各テーブルに対して1つのクラスがあればよい。 テーブルデータゲートウェイ (図3.2参照) は、データベースを検索してレコードセットを

返すメソッドを提供する。

PersonGateway Find (id): RecordSet findWithLastName (String): RecordSet Update (id, lastname, firstname, numberOfDependents) | Insert (lastname, firstname, numberOfDependents) Delete (id)

テーブルごとに1つのインスタンスを所持するテーブルデータゲートウェイ

36

図3.2

私はシンプルなアプリケーションにもゲートウェイパターンの1つを使用することが い。 私のRuby と Python のスクリプトを見れば、それがわかるだろう。 SQLとドメイ ロジックの明確な分離がとても役立つと私は思っている。

テーブルデータゲートウェイがレコードセットと見事に適合しているので、 テーブル ジュールを使用している場合、 テーブルデータゲートウェイを選択すべきなのは明らかで る。 また、 テーブルデータゲートウェイはストアドプロシージャの構築について考える 使用できるパターンでもある。 多くの設計者は、明示的なSQLではなく、ストアドプ シージャですべてのデータベースのアクセスを行うことを好む。 この場合、 ストアドプ シージャのコレクションをテーブル用のテーブルデータゲートウェイの定義と考えること できる。私の方法では、カプセル化されたストアドプロシージャ呼び出しのメカニズムを 持するために、メモリ上のテーブルデータゲートウェイでストアドプロシージャへの呼び しをラップする。

ドメインモデルを使用している場合は、さらにいくつかの選択肢がある。 もちろんドメ ンモデルと一緒に、 行データゲートウェイまたはテーブルデータゲートウェイを使用する とができる。 しかし、私個人の好みとしては、この方法は間接的すぎるか十分でないかの ちらかだ。

シンプルなアプリケーションでは、ドメインモデルの構造は複雑ではない。 実際、その 造はデータベースの構造と厳密に一致し、 データベーステーブルごとに1つのドメインク スがある。 このようなドメインオブジェクトは、 適度に複雑なビジネスロジックだけを持 ていることが多い。 この場合、 各ドメインオブジェクトがデータベースからの読み込みと 存を行い、 アクティブレコードになることには意味がある (図 3.3 参照)。 アクティブレコ ドについての別の考え方は、特に複数のトランザクションスクリプトに繰り返し現れるコー ドがある場合、 行データゲートウェイから開始して、 クラスにドメインロジックを追加する ことである。

Customer load (ResultSet) delete insert update checkCredit sendBills Customer Table

3.3 アクティブレコードでは、 Customer ドメインオブジェクトがデータベーステーブルとの通信方法を知って いる。

このような状況では、ゲートウェイの余分な間接化は意味がない。 ドメインロジックが複 雑になり、豊富なドメインモデルに移行するにつれ、 アクティブレコードのシンプルな手法 は崩壊し始める。 小さいクラスにドメインロジックを組み込むので、テーブルとドメインク ラスとの一対一の組み合わせは失敗し始める。 リレーショナルデータベースは継承に対応し ないので、ストラテジー [Gang of Four]や他の素晴らしいオブジェクト指向のパターンを 使用することが困難になる。 ドメインロジックが面倒になると、 常にデータベースに通信し なくてもテストできるようにしたくなる。

ドメインモデルが豊富になると、これらの圧力すべてによって間接化が強要される。 この 場合、 ゲートウェイで問題の一部を解決できるが、データベースのスキーマと結合している ドメインモデルが残っている。結果として、ゲートウェイのフィールドからドメインオプ ジェクトのフィールドに変換されるので、ドメインオブジェクトは複雑になる。

これに対するより優れた方法は、 ドメインオブジェクトとデータベーステーブルとのマッ ビングを間接参照のレイヤに行わせ、 データベースからドメインモデルを完全に分離させる ことである。 データマッパー (図 3.4 参照) は、データベースとドメインモデル間の読み込 みと保存のすべてに対処し、 両方の変更を独立して行うことができる。 データベースを対応 付けるアーキテクチャの中でデータマッパーは最も複雑だが、 そのメリットは2つのレイヤ を完全に分離することである。

ゲートウェイをドメインモデル用の主な永続メカニズムとして使用することはお勧めでき ない。 ドメインロジックがシンプルで、 クラスとテーブル間に密接な対応がある場合は、 ア クティブレコードがシンプルな方法である。 さらに複雑な場合は、 データマッパーが必要に なる。

これらのパターンは、完全に相互排他的というわけではない。ここでは、メモリ上のデー タをデータベース内に保存する方法として、 主な水続メカニズムを考えている。 このため、 これらのパターンの1つを選択することになるだろう。 これらを混用しても、混乱を招く結 果に終わるだけなので避けたいところだ。 データマッパーを主な水続メカニズムとして使用 していても、外部インタフェースとして扱われているテーブルまたはサービスをラップする ためにゲートウェイデータを使用するだろう。

Customer checkCredit sendBills CustomerMapper create load save Customer Table

3.4 ードメインオブジェクトとデータベースを分離するデータマッパー

38

第3章 リレーショナルデータベースへのマッピング

ここでの考え方とパターン自体における考え方の説明では、私は 「テーブル」という用 を使用することが多い。 しかし、これらの技法の多くは、ビュー、 ストアドプロシージャで カプセル化したクエリー、一般的によく使用される動的なクエリーにも同様に適用できる 残念なことに、テーブル、 クエリー、 ストアドプロシージャに対して幅広く使用される用書 はないので、テーブルのデータ構造を意味する「テーブル」 を使用する。 私はビューを仮想 テーブルとして考えることが多い。 この仮想テーブルは、 SQL がビューを考える方法でも ある。テーブルの検索と同様にビューを検索するためには、この仮装テーブルで使用される 構文と同じ構文が使用される。

ビューとクエリーに対する更新は明らかに複雑である。 その理由は、常にビューを直接更 新できるわけではなく、 その基盤となるテーブルを操作しなければいけないからである。 こ の場合、ビューとクエリーを適切なパターンでカプセル化することは、 1箇所で更新ロジッ クを実装するための優れた方法であり、 その結果シンプルで信頼性のあるビューを使用でき るようになる。

この方法でビューとクエリーを使用することについての問題の1つは、ビューを形成する 方法を理解していない開発者を驚かせる矛盾が生じてしまうことである。 ビューやクエリー の形成方法を知らない開発者は2つの異なる構造で更新を実行するので、基盤となる同じ テーブルが更新され、 最初の更新を2度目の更新で上書きすることになる。 更新ロジックが 適切な妥当性を確認するので、このような矛盾したデータを取得することはないが、 開発者 は驚くことになるだろう。

また、最も複雑なドメインモデルの永続化のための最もシンプルな方法も説明すべきだろ う。オブジェクトを扱い始めて間もないころ、 多くの人がオブジェクトとリレーショナル データベースとの間には根本的な「インピーダンスミスマッチ」 があると気付いた。 この ため、オブジェクト指向データベースに関する多くの取り組みが行われ、 ディスク記憶装置 にオブジェクト指向のパラダイムがもたらされた。 オブジェクト指向データベースに関して は、マッピングの心配をする必要はない。 相互に関連したオブジェクトの大規模な構造に対 処し、データベースはオブジェクトをディスクから出し入れするタイミングを割り出す。 ま た、トランザクションを使用して、更新をひとつに集めることができ、 データ格納の共有が 可能になる。 プログラマにとって、これはディスク記憶装置が透過的に支援する無限のトラ ンザクションメモリのように感じられる。

オブジェクト指向データベースの主な長所は、生産性の向上である。 対照試験は行ってい ないが、事例を観察した結果、プログラミング労力 (保守に要する費用) の約3分の1はリ レーショナルデータベースのマッピングに費やされる。

しかし、多くのプロジェクトはオブジェクト指向データベースを使用しない。 その主な理 山はリスクである。 リレーショナルデータベースは、長い歴史のある大手のベンダーが支援 する、広く理解された実績ある技術である。 SQL は、 あらゆる種類のツールに比較的標準

のインタフェースを提供する (パフォーマンスに関して私が唯一言えるのは、リレーショナ ルシステムのパフォーマンスとオブジェクト指向のパフォーマンスを比較する決定的なデー タは見たことがないということである)。

オブジェクト指向データベースを使用できなくても、 ドメインモデルがある場合は、 O/R (オブジェクト/リレーショナル) マッピングツールの購入を真剣に考えるべきである。 本書 のパターンは、データマッパーを構築する方法を多く説明しているが、それでも複雑な取り 組みである。 ツールベンダーは長年この問題に取り組んでいて、 手動で合理的に行われる処 理よりも商用のO/Rマッピングツールの方が洗練されている。 ツールは安くはないので、 レイヤの作成と保守にかかるコストを考慮して価格を比較しなければいけない。

リレーショナルデータベースを扱えるオブジェクト指向データベース形式のレイヤを提供 するという動きがある。 Java において JDOは素晴らしいが、それがどのように機能するか を説明するのは早すぎる。 本書の中で結論を出せるだけのJDO の経験が私にはない。

しかし、 ツールを購入したとしても、パターンを理解しておく方がよい。 適切な O/R マッピングツールによって、 データベースへのマッピングにおけるさまざまな選択肢を使用 でき、パターンは異なる選択を使用するタイミングを理解するために役立つ。 ツールがすべ ての労力をなくしてくれると思い込んではいけない。 ツールは大部分の作業を行うが、 O/R マッピングツールの使用と調整には、少ない量ではあるが重要な作業を行う必要がある。

32 振る舞いに関する問題

O/Rマッピングについて話をする際は、一般的に構造的な側面(テーブルとオブジェク トを関連付ける方法) に焦点が当てられる。 しかし、これを実行する際に最も困難なのは、 アーキテクチャと振る舞いに関する側面である。 アーキテクチャに関する主な手法はすでに 説明した。 次に考えるべきことは、振る舞いに関する問題である。

振る舞いに関する問題は、さまざまなオブジェクトをデータベースに読み込ませる方法と 保存させる方法である。 一見、大した問題ではないように思える。 たとえば、顧客オブジェ クトは、このタスクを行う読み込みメソッドと保存メソッドを持つことができる。 実際、 ア クティブレコードでは、このメソッドを持つという方法を採用すべきである。

メモリにオブジェクト群を読み込んで修正する場合、 修正したオブジェクトを記録し、 そ れらすべてをデータベースに書き戻さなければいけない。 2、3のレコードを読み込むだけ であれば、これは容易である。 しかし、多くのオブジェクトを読み込むほど行うべきことが 多くなる。これは特に、 行の作成や修正を行う場合に、参照する行を修正する前に作成され た行のキーが必要になるからである。 これは、解決するには少し扱いにくい問題である。

オブジェクトを読み込んで修正する際は、 処理するデータベースが一貫性のある状態であ

0

るようにしなければいけない。 いくつかのオブジェクトを読み込んだ場合は、 オブジェク を処理している間に他のプロセスが同じオブジェクトを読み込んで変更することがないよ に、 必ず読み込みを分離させることが重要である。分離させないと、 オブジェクトに関し 互いに矛盾した無効なデータを持つことになる。 これは、並行性の問題であり、 解決すべ ではあるがとても扱いにくい問題である。 これについては第5章で詳しく説明する。

これらの問題を解決するために不可欠なパターンはユニットオブワークである。 ユニッ オブワークは、 少しでも修正されたすべてのオブジェクトとともに、データベースから読み 込んだすべてのオブジェクトを記録する。 また、 データベースへの更新方法にも対処する プログラマは、明示的に保存メソッドを呼び出すアプリケーションプログラマの代わりに コミットする処理単位を告げる。 そして、 この処理単位はすべてのデータベースに対する 切な振る舞いを順序付け、1箇所にすべての複雑なコミット処理を配置する。 データベース との振る舞いの相互作用がうまくいかなくなった場合は、 ユニットオブワークが必須のパ ターンになる。

ユニットオブワークについては、データベースマッピングのコントローラとしての役割を 果たすオブジェクトとして考えることである。 ユニットオブワークがなければ、ドメインレ イヤは一般的にコントローラとしての役割を果たし、 データベースへの読み込みと書き込み を行うタイミングを決定する。 ユニットオブワークは、データベースのマッピングコント ローラの振る舞いを1つのオブジェクトへ抜き出すことによって生じる。

オブジェクトを読み込む際は、 同じオブジェクトを2度読み込まないように注意しなけれ ばいけない。 2度読み込むと、1つのデータベース行に対応するオブジェクトがメモリ上に 2つ存在することになる。 両方を更新すると、 すべてがとてもわかりにくくなる。 これに対 処するために、一意マッピングで読み込んだ各行の記録を保持する必要がある。 データを読 み込むごとに、 最初に一意マッピングをチェックして、 すでにデータを持っていないかを確 認する。 データがすでに読み込まれている場合は、そのデータに対する2つ目の参照を返す ことができる。 こうすれば、どの更新も適切に調整される。 メリットとして、 一意マッピン グはデータベースのキャッシュを持つので、 データベース呼び出しを回避することができる だろう。 しかし、一意マッピングの主な目的は、 パフォーマンスの改善ではなく、正確な一 意性を維持することである。

ドメインモデルを使用している場合、注文オブジェクトの読み込みが関連する顧客オブ ジェクトを読み込むというように、リンクされたオブジェクトが一緒に読み込まれるような 配置にすることが多い。 しかし、 多くのオブジェクトが連結している場合、 どのオブジェク トの読み込みも膨大なオブジェクトのグラフをデータベースから抜き出すことになる。この 無駄を回避するために、抽出するデータは減らすが、 その後の必要に応じて、データを抜き 出すためのドアを開けておく必要がある。 レイジーロードはオブジェクト参照用のプレース ホルダーがあることを期待する。 このテーマに関しては多少のバリエーションがあるが、 そ

のバリエーションすべてがオブジェクト参照を修正し、 実際のオブジェクトを指す代わりに、 プレースホルダーであるというマークを付けている。 リンクをたどろうとする場合にだけ、 実際のオブジェクトがデータベースから呼び出される。 適切な場面でレイジーロードを使用 すると、各呼び出しによってデータベースから過不足のないデータ抽出を行える。

3.3 データの読み込み

データの読み込み時には、メソッドを find メソッドとして考えることを私は好む。このメ ソッドは、メソッドの構造を持つインタフェースでSQLのselect 文をラップする。 find (id) や findForCustomer (customer) などのメソッドがその例だろう。 select 文に23の異 なる句がある場合、 これらのメソッドはとても扱いにくいが、 幸いそのような例は稀である。

find メソッドを置く場所は、使用するインタフェースのパターンに依存する。 データベー スとの相互作用を行うクラスがテーブルベース (データベースのテーブルごとにクラスのイ ンスタンスを1つ持つ) であれば、 find メソッドと挿入や更新を組み合わせることができる。 相互作用クラスが行ベース (データベースの行ごとに相互作用クラスを1つ持つ)の場合、 この方法は利用できない。

行ベースのクラスではfind 操作を静的にすることができるが、データベースを替えるこ とができなくなる。 これは、サービススタブのテスト目的のためにデータベースを交換でき ないことを意味する。 この問題を回避するための最善の手法は、個別の find オブジェクト を持つことである。 各 find クラスには、SQLクエリーをカプセル化する多くのメソッドが ある。 クエリーを実行すると、 find オブジェクトは適切な行ベースのオブジェクトのコレク ションを返す。

find メソッドに関して注意すべきことは、 オブジェクトではなく、 データベースで動作す ることである。 たとえば、クラブにいるすべての人を検索するために、データベースに対し クエリーを発行する場合、メモリ上のクラブに追加した人のオブジェクトがクエリーに よって参照されることはない。結果として、通常、最初にクエリーを発行することが賢明で ある。

データの読み込み時にパフォーマンスの問題が浮上することが多い。 これに対しては、経 験則による方法がいくつかある。

まず、1度に複数の行の取得を行うようにした方がよい。 特に、 複数の行を取得するため に同じテーブルに繰り返しクエリーを発行してはいけない。 少なすぎるデータよりも多すぎ るデータを取得する方が常に適切な場合が多い (悲観的な並行性制御によって多すぎる行を ロックしてしまうことには注意しなければいけない)。 このため、 ドメインモデルにおいて 主キーで特定可能な50人を取得しなければならない場合、 200人を取得するようなクエ

2

リーを構築し、そこから必要な50人を分離させるための何かのロジックを実行すればよい 通常、50の個別のクエリーを発行するよりも、 不必要な行を戻す1つのクエリーを使用 る方が適切である。

何度もデータベースを参照することを回避する別の方法は、 ジョインを使用し、1つの エリーで複数のテーブルを取得できるようにすることである。 その結果返されるレコード セットは奇妙に見えるかもしれないが、 高速化が可能になる。 この場合、 複数のジョイン テーブルからのデータがあるゲートウェイを使用するか、 1つの呼び出しでいくつかのド インオブジェクトを読み込むデータマッパーを使用することになるだろう。

しかし、 ジョインを使用している場合、 クエリーごとに3つか4つのジョインに対応する ようにデータベースが最適化されていることに注意すべきである。 それ以上のジョインを行 うと、キャッシュされたビューでこの多くを復元できるが、 パフォーマンスが損なわれる。 データベースでは多くの最適化を行うことができる。 これらの処理には、共通して参照さ れるデータのクラスタ化、インデックスの慎重な使用、 データベースのメモリキャッシュ機 能などがある。 これらは本書の範囲外だが、優れたDBAなら守備範囲内である。

すべての場合において、 独自のデータベースとデータを使用してアプリケーションのプロ ファイルを取得する必要がある。 一般的な原則を考え方の指針とすることができるが、 状況 によって、常に独自のバリエーションがある。 データベースシステムとアプリケーション サーバは、キャッシュのスキーマを洗練することが多い。 また、アプリケーションに起こる ことを予測する方法はない。 私は経験則を使用するたびに、 驚くべき例外を知らされるので、 パフォーマンスの調査と調整の時間は別に設けることにしている。

3.4 構造的なマッピングに関するパターン

一般的なオブジェクトとリレーショナルデータベースのマッピングに関する話題は、 メモ リ上のオブジェクトとデータベーステーブルとのマッピング時に使用する構造的なマッピン グに関するパターンであることが多い。 これらのパターンは、 通常、 テーブルデータゲート ウェイには関連していないが、 行データゲートウェイまたはアクティブレコードを使用する 場合は、いくつかのパターンが必要になるだろう。 おそらく、 データマッパーに対しては、 すべてのパターンを使用する必要がある。

3.4.1 関係のマッピング

ここでの中心的課題は、 オブジェクトとリレーショナルデータベースがリンクに対処する 方法の違いであり、 2つの問題が生じる。1つ目の問題は、表現の相違である。 オブジェク トは、メモリ管理環境が実行時のメモリアドレスによって保持される参照を格納することで

リンクに対処する。 リレーショナルデータベースは、他のテーブルにキーを形成することで リンクに対処する。 2つ目の問題は、オブジェクトが1つのフィールドからの複数の参照を 処理するために容易にコレクションを使用できるのに対し、 正規化はすべての関連リンクを 単一の値にすることを強要する。 これは、オブジェクトとテーブル間のデータ構造の逆転に つながる。 注文オブジェクトは、注文を参照する必要のない明細オブジェクトのコレクショ ンを自然に持っている。 しかし、 テーブル構造はその逆で、注文は複数値フィールドを持つ ことができないので、明細が注文への外部キーの参照を持たなければいけない。

この表現の問題に対処する方法は、各オブジェクトのリレーショナルな一意性を一意 フィールドとしてオブジェクトに保持し、 オブジェクト参照とリレーショナルキーとの間を 双方向にマッピングするために、これらの値を参照することである。 単調なプロセスだが、 基本的な技法を理解すれば困難ではない。 ディスクからオブジェクトを読み込む際は、一意 マッピングをリレーショナルキーからオブジェクトへの照合テーブルとして使用する。 テー ブルの外部キーに出会うたびに、 外部キーマッピング (図3.5 参照) を使用して適切な相互 のオブジェクト参照をつなげる。 一意マッピングにキーがなければ、 データベースを使用し て取得するか、 レイジーロードを使用する必要がある。 オブジェクトを保存するごとに、 適 切なキーを使用して行に保存する。 相互のオブジェクト参照は、 対象オブジェクトのID フィールドに置き換えられる。

これを基盤に、コレクション管理には、 複雑な外部キーマッピング (図 3.6 参照) が必要 になる。 オブジェクトにコレクションがある場合は、他のクエリーを発行して、ソースオブ ジェクトのIDにリンクするすべての行を検索する必要がある (または、レイジーロードを 使用してクエリーを回避することができる)。 クエリーから返されたオブジェクトがそれぞ れ作成され、コレクションに追加される。 コレクションの保存には、各オブジェクトを保存 し、ソースオブジェクトのための外部キーを確実に持つことが必要になる。 特に、追加され たオブジェクトを発見したり、 コレクションから削除したりしなければいけない場合は乱雑 になる。これは要領を得れば繰り返すことができるようになる。 これがメタデータベースの ような形式の手法が大規模なシステムに採用される理由である(これについては後で説明す る)。コレクションオブジェクトがコレクションのオーナの範囲外では使用されない場合、 依存マッピングを使用してマッピングを単純化できる。

Album title: String "table» Albums ID: Int title: varchar artistID: int Artist name: String * ID: int "table" Artists name: varchar

図 3.5 外部キーマッピングを使用した単一値フィールドのマッピング

Album 1 Track title: String * title: String «<table> ID: int Albums title: varchar "<table> ID: int Tracks albumID: int title: varchar

図3.6 外部キーマッピングを使用したコレクションフィールドのマッピング

別の例では、両端にコレクションを持つ多対多の関係が使用される。 たとえば、ある人は 多くのスキルを持ち、各スキルは使用する人が誰だかわかっているとする。 リレーショナル データベースは、この関係に直接対処することはできないので、 関連テーブルマッピング (図 3.7 参照) を使用し、 多対多の関連に対処するために新規のリレーショナルテーブルを 作成する。

ID Employee * -table- -table- Employees skill-employees employeeID skillID ID Skill "table" Skills

図3.7 関連テーブルマッピングを使用した多対多の関連のマッピング

コレクションを扱う際の共通の認識は、コレクション内の順番への依存である。 オブジェ クト指向言語では、リストや配列などの順番の付いたコレクションを使用することが一般的 である。実際、順番の付いたコレクションの使用によってテストが容易になる場合が多い。 それでも、リレーショナルデータベースへの保存時に任意の順番の付いたコレクションを維 持することはとても困難である。 この理由から、コレクションを格納する際には順番の付い ていない集合の使用を考慮した方がよい。 他の選択肢としては、とても資源を消費するが、 コレクションクエリーの実行時は常に、ソートの順序を決定することである。

参照整合性が更新を複雑にしてしまう場合もある。 最新のシステムでは、トランザクショ ンが終了するまで参照整合性の照合を保留することができる。 この機能があれば使用すべき である。 この機能がなければ、データベースは書き込みごとに照合を行う。 この場合、適切 な順序で更新を行うように注意しなければいけない。 これを行う方法は本書の範囲外だが、 更新のトポロジカルソートを行うことが1つの技法である。 他の技法としては、 どの順で どのテーブルに書き込みを行うかを直接書くことである。 そうすることで、 トランザクショ ンの過度のロールバックを生じさせるデータベース上のデッドロック問題を減少できる場合 がある。

一意フィールドは、外部キーとなる相互のオブジェクト参照に使用されるが、 すべての オブジェクトの関係がこのように永続化される必要はない。 日付範囲や貨幣オブジェクト などの小さなバリューオブジェクトは、データベースにそれ自体のテーブルとして作成さ れるべきではない。代わりに、バリューオブジェクトのすべてのフィールドを取得し、組 込バリューとしてリンクされたオブジェクトに組み込む。 バリューオブジェクトには値の セマンティクスがあるので、読み込みを行うごとに適切に作成することができ、 一意マッ ピングで無駄な時間を使う必要はない。 また、書き込みを行うことも、オブジェクトを逆

参照し、そのフィールドを所有しているテーブルに分割すればよいので、容易である。

オブジェクトのクラスタ全体を取得し、 シリアライズ LOB のようにテーブルに1つの として保存することで、大規模にこれを行うことができる。 LOB は、 「Large OBject: きいオブジェクト」 の略語であり、 バイナリ (BLOB) にも、 テキスト (CLOB Character Large Object) にもなる。 オブジェクトの一群を XML文書として直列化す ことは、階層的オブジェクト構造の代替になる明確な方法である。 これを行うことで、 の読み込みでリンクされた小さなオブジェクトの集まりすべてを取得できる。 データベー は相互に強く関連した小さいオブジェクトの扱いに慣れていないことが多く、小さいデー ベース呼び出しに多くの時間を費やす。 組織表や部品表などの階層的構造で、シリアライズ LOBは多くのデータベースラウンドトリップ (データのつながりが巡回すること)を節 できる。

シリアライズ LOB の短所は、 何が起こっているかをSQL が認識していないので、デー タ構造に対し移植可能なクエリーを作成できないことである。 再度述べるが、 XML はここ での救援方法となるだろう。 今のところ非標準的であるものの、 SQL 呼び出し内のXPat クエリー表現の組み込みができるようになるだろう。 結果として、シリアライズ LOB は 格納された構造の部分の検索を避けたい場合に使用することが最善である。

通常、 シリアライズ LOB は、アプリケーションの一部を構成するオブジェクトの比較的 分離した集まりにとって最適である。 使用しすぎると、データベースはただのトランザク ション可能なファイルシステムになってしまう。

3.4.2 | 継承

先に述べた階層では、リレーショナルシステムが昔から苦手とするパーツツリーなどの複 合階層について説明した。 リレーショナル問題を引き起こす他の種類の階層化には、継承に よってリンクされたクラス階層がある。 SQL には継承を行うための標準的な方法がないの で、マッピングを遂行する。 継承構造には、基本的に3つの選択肢がある。 シングルテーブ ル継承 (図3.8 参照) では、階層にあるすべてのクラスに対し1つのテーブルがある。 具象 テーブル継承 (図 3.9 参照) では、具象クラスごとに1つのテーブルがある。 クラステーブ ル継承 (図3.10 参照) では、 階層にあるクラスごとに1つのテーブルがある。

Footballer club name Player Cricketer batting average name club «<table> Players batting average bowling average type Bowler bowling average

図 3.8 一階層にあるすべてのクラスを格納するために1つのテーブルを使用するシングルテーブル継承

club Footballer name Player Cricketer "table"> Footballers name club "table" Cricketers batting average name Bowler bowling average batting average "table" Bowlers name batting average bowling average

3.9 一階層にある各具象クラスを格納するために1つのテーブルを使用する具象テーブル継承

048

第3章 リレーショナルデータベースへのマッピング

club name Player club «<table> Footballers Footballer Cricketer batting average "table» Cricketers batting average -table" Bowlers bowling average Bowler bowling average "<table> name Players

図3.10 一階層にあるクラスごとに1つのテーブルを使用するクラステーブル継承

すべてはデータ構造の重複とアクセス速度とのトレードオフである。 クラステーブル継承 は、クラスとテーブルとの最もシンプルな関係だが、1つのオブジェクトをロードするため に複数のジョインが必要になる。 これにより、通常、 パフォーマンスが低下する。 具象テー ブル継承は、このジョインを回避し、1つのテーブルから1つのオブジェクトを抽出するこ とを可能にするが、 変更に対して脆弱である。 スーパークラスへの変更に関しては、すべて のテーブル (とマッピングコード) を修正しなければいけない。 階層自体を修正すれば、さ らに大きな変更が発生するだろう。 また、 スーパークラスのテーブルがないので、スーパー クラスのテーブルでのロック競合は減少するが、 キーの管理が困難になり、 参照整合性の妨 げになる。 シングルテーブル継承の最大の短所は、いくつかのデータベースでは無駄なス ベースができることである。 各行はすべての可能な部分型に対応する列を持つ必要があり、 これにより空の列ができてしまう。 しかし、 多くのデータベースでは、無駄なテーブルのス ベースを見事に圧縮できる。 シングルテーブル継承はその大きさのために別の問題が発生し、 アクセスする際の障害になる。 しかし、大きなメリットは、すべての要素を同じところに配 置できることである。 これにより修正が容易になり、 ジョインを回避することができる。

この3つの選択肢は、相互排他的ではなく、1つの階層にパターンを混合できる。 たとえ ば、シングルテーブル継承でいくつかのクラスをまとめることができ、 いくつかの例外的な 状況にはクラステーブル継承を使用できる。 当然、 パターンを混合すると複雑性は増す。

この問題に関する明確な成功法はない。 他のすべてのパターンと同様に、それぞれの状況 と趣向を考慮する必要がある。 私はこの場合、容易に行うことができ、多くのリファクタリ

ングに対して弾力性があるシングルテーブル継承を最初に選択することが多い。 また、 関係 のない無駄な行に関する避けられない問題を解決する必要があれば、他の2つを使用する傾 向がある。 また、 DBA に相談することが最善である場合が多い。 彼らは、データベースに 最も有用であるこの種のアクセス方法に関して適切なアドバイスをしてくれる

パターンに関して説明したすべての例には、単一の継承を使用する。 多重継承は、 今日、 流行ではなくなってきていて、 多くの言語はこれを徐々に回避しているが、それでも Java や.NET などでインタフェースを使用する際にO/Rマッピングに関する問題が発生する。 本書のパターンはこのテーマを具体的に扱わないが、3つの継承パターンの変形を使用する ことで、 多重継承に本質的に対処する。 シングルテーブル継承は、 すべてのスーパークラス とインタフェースを1つの大きなテーブルに入れ、 クラステーブル継承は、インタフェース スーパークラスごとに個別のテーブルを作成する。 そして、具象テーブル継承は、各具象 テーブル内にすべてのインタフェースとスーパークラスを含む。

3.5 マッピングの構築

リレーショナルデータベースへのマッピングを行う際、必然的に以下の3つの状況に直面 する。

■スキーマを自分で選択する。

変更できない既存のスキーマへのマッピングを行わなければいけない。

■既存のスキーマへのマッピングを行わなければいけないが、このための変更に は交渉の余地がある。

最もシンプルなのは、自分でスキーマを作成し、ドメインロジックの複雑性を普通よりも 少なくして、トランザクションスクリプトの設計またはテーブルモジュールの設計を行える ようにすることである。 この場合、従来のデータベース設計技法を用いたデータのテーブル を設計できる。 行データゲートウェイまたはテーブルデータゲートウェイを使用して、 ドメ インロジックからSQL を分離する。

ドメインモデルを使用している場合は、データベース設計のような設計に注意する必要が ある。この場合、ドメインロジックを適切に簡略化できるように、データベースを無視して ドメインモデルを構築する。 データベース設計をオブジェクトのデータを永続化する方法と して扱う。 データマッパーは最も柔軟性を提供するが、複雑である。 ドメインモデルと同じ データベース設計が意味を成す場合は、代わりにアクティブレコードを考慮するだろう。

最初にモデルを構築することは妥当な方法だが、これは短いイテレーティブなサイクル内

にだけ適用される。 データベースを使用しないドメインモデルの構築に6ヶ月を費やし、 了後に永続化を決定することは高いリスクを伴う。 長い期間をかけた設計には、重大な フォーマンスの問題があり、 修正するためには膨大なリファクタリングが必要になる。 そ かわり、 6週間を越さない程度の期間で、 データベースをイテレーションごとに構築する これを行うことで、 データベースの相互作用がどのくらい効果的であるかについての迅速 継続的なフィードバックを得ることができる。 特定のタスク内で、最初にドメインモデル ついて考えるべきだが、 使用するデータベース内にドメインモデルの各要素を統合する必 がある。

スキーマがすでにある場合、 選択は似ているが、プロセスは少し異なる。 シンプルなド インロジックでは、データベースを持つ行データゲートウェイまたはテーブルデータゲー ウェイのクラスを構築し、その上にドメインロジックをレイヤ化する。 複雑なドメイン ジックでは、 データベース設計に適合する可能性がほとんどないドメインモデルが必要であ る。このため、徐々にドメインモデルを構築し、既存のデータベース内へデータを永続化 るためにデータマッパーを含める。

3.5.1 2重のマッピング

2つ以上のソースから同じようなデータが戻される状況を目にすることがある。 コピーア ンドペーストするので、 同じデータを保持するが、 少しだけスキーマの異なる複数のデー ベースがあるためだろう(この状況の場合、 苛立ちの度合いは相違の割合に反比例する) 他の可能性としては、異なるメカニズムを使用していることと、データベースの場合もあれ ばメッセージの場合もあるデータを格納していることがあげられる。 XML メッセージ CICS トランザクション、リレーショナルテーブルから同様のデータを抽出しようとした ともあるだろう。

最もシンプルな選択肢は、複数のマッピングレイヤ (データソースごとに1つ)を持つこ とである。 しかし、データが酷似している場合は、 多くの重複を引き起こすことにつながる。 この状況では、2ステップマッピング案を検討する。 1ステップ目は、メモリ上のスキーマ から論理的なデータソーススキーマにデータを変換する。 論理的なデータ格納スキーマは、 データソースフォーマット間で類似性を最大限に高めるように設計され、 2ステップ目で相 違を含める。

追加のステップは、 多くの共通性がある場合にだけ有効なので、 類似性はあるが異なる物 理的なデータを格納する場合は追加のステップを使用すべきである。 論理的なデータ格納か ら物理的なデータ格納へのマッピングをゲートウェイとして処理し、マッピング技法を使用 してアプリケーションロジックから論理的なデータ格納にマッピングを行う。

3.6 メタデータの使用

本書では、ほとんどの例に手書きのコードを使用する。 シンプルで繰り返されるマッピン グを使用すると、シンプルで繰り返されるコードを作ることにつながる。 同じコードの繰り 返しがあるということは、設計に間違いがあることを意味する。 共通の振る舞いを継承や委 譲で抜き出すことによって多くのことを行える (有効で正当なオブジェクト指向のプラク ティス) が、 メタデータマッピングを使用する洗練された手法も存在する。

メタデータマッピングは、データベースの列をオブジェクトのフィールドにマッピングす る方法を詳述したメタファイルへマッピングを集約することに基づいている。 メタデータが あれば、コードの生成か自己反映的なプログラミングのどちらかを使用して同じコードの繰 り返しを回避することができる。

メタデータの使用によって、少ないメタデータから多くの表現力を得られる。 1行のメタ データは以下のようになる。

<field name = customer targetClass = *Customer, dbColumn = "custID", targetTable *customers lowerBound = "1" upperBound = "1" setter = "loadCustomer />

このメタデータからコードの読み込みと書き込みの定義、任意のジョインの自動生成、 す べてのSQL の実行、 関係の多重度の強制、 参照整合性がある場合における書き込み順序の 計算のような手の込んだ処理の実行を行える。これが、商用のOR マッピングツールがメ タデータを使用することが多い理由である。

メタデータマッピングを使用する際は、メモリ上のオブジェクトを用いてクエリーを構築 するために必要な基盤がある。 クエリーオブジェクトでメモリ上のオブジェクトとデータに 関するクエリーを構築することができ、 開発者は SQLやリレーショナルスキーマの詳細を 把握する必要はない。 クエリーオブジェクトは、メタデータマッピングを使用して、 適切な SQL ヘオブジェクトフィールドに基づく表現を変換できる。

ここまで行えば、データベースをビューから大幅に隠ぺいするリポジトリを形成できる。 データベースへのクエリーは、リポジトリに対するクエリーオブジェクトとして作成でき、 開発者はオブジェクトがメモリから検索されたのか、データベースから検索されたのかはわ からない。 リポジトリは、豊富なドメインモデルシステムとともに使用すると効率的である。

メタデータには多くのメリットがあるが、本書では、最初に理解しやすいので、手書きの 例に焦点を当てる。 パターンの使用法を理解し、アプリケーション用のパターンを手書きで きるようになれば、メタデータを使用する方法を解釈し、処理を容易にすることもできるだ ろう。

2

3.7 データベース接続

多くのデータベースインタフェースは、アプリケーションコードとデータベースとのリン クとしての役割を果たすデータベース接続オブジェクトに依存する。 一般的に、接続はデー タベースに対してコマンドを実行する前にオープンにしなければいけない。 実際、 コマン| を作成し、実行するためには明示的な接続が必要な場合が多い。 コマンドの実行時は常にこ れと同じ接続をオープンする必要がある。 クエリーはレコードセットを返す。 いくつかのイ ンタフェースは、 切断されたレコードセットを提供するが、これは接続を閉じた後に処理さ れるものだ。 レコードセットが処理される間、 接続をオープンにしたままにしなければいけ ない 接続されたレコードセットだけを提供するインタフェースもある。 トランザクション 内で実行している場合は、トランザクションは必ず特定の接続で行い、 実行中の接続はオー プンにしたままでなければいけない。

多くの環境では、接続の作成にかかるコストは高いので、 接続プールを作成する方がよい。 この状況では、開発者は接続の作成と終了を行うのではなく、 プールから接続を要求し、 終 了時に解放する。今日、多くのプラットフォームでプールを提供するので、自分で行わなけ ればいけないことは稀である。 自分で行わなければいけない場合は、最初に、プールが実際 にパフォーマンスに役立つかどうかを確かめてほしい。 新しい接続の生成速度が速くなって いるなら、プールする必要はない。

プールを提供する環境では、新しい接続を作成するようなインタフェースの裏側にプール を置くことが多い。 このため、最新の接続なのか、プールから割り当てられた接続なのかは わからない。 しかし、プールの選択の可否は適切にカプセル化されているので、 特に問題は ない。 同様に、接続の終了は、実際にクローズしたのではなく、他のユーザが使用できるよ うにプールに返しているだけかもしれない。 本書では「オープン」と「クローズ」 という言 い方をするが、プールからの 「取得」 とプールへの 「解放」と言い換えることができる。

作成のコストが高いかどうかに関わらず、 接続には管理が必要である。 管理するリソース は高価なので、 使用が終了したらすぐにクローズしなければいけない。 さらに、 トランザク ションを使用している場合は、一般的に、 特定のトランザクション内にあるすべてのコマン ドが同じ接続で実行されるようにする必要がある。

最も一般的な対処法は、プールまたは接続マネージャへの呼び出しを使用して、 明示的に 接続を取得し、 行いたいデータベースコマンドごとにその接続を提供することである。 接続 を終了したらすぐにクローズしなければいけない。 この方法では、2、3の問題が生じるの で、必要であれば接続し、 終了時には忘れずにクローズすべきだ。

必要なところで必ず接続されるようにするためには、2つの選択肢がある。 1つ目は、 接 続を明示的な引数として渡すことである。これに関する問題は、呼び出しスタックの5レ イヤ下にある他のメソッドに渡されることだけを目的として、 あらゆる種類のメソッド呼び

出しに接続が追加されることである。 当然、 これはレジストリを使用すべき状況である。 同 じ接続を複数のスレッドで使用する必要はないので、スレッドスコープのレジストリが必要 になる。

忘れっぽい人は、明示的にクローズすることは適さない。 必要な場合に終了することをす ぐ忘れてしまう。 また、 トランザクション内で実行している場合もあるので、 コマンドごと に接続をクローズすることもできない。 通常、 クローズするとトランザクションのロール バックを引き起こす。

接続と同じように、メモリは未使用時に解放する必要があるリソースである。 今日、最新 の環境は、 自動メモリ管理とガベージコレクタを提供するので、 接続がクローズされたこと を確実にする1つの方法は、ガベージコレクタを使用することである。 この手法では、接続 自体、 または、 その接続を参照するあるオブジェクトが、ガベージコレクション中に接続を クローズする。この優れた点は、 メモリと同じ管理方式を使用することと、 使いやすいこと だ。 問題は、ガベージコレクタが実際にメモリを再要求する場合にだけ接続がクローズする ことであり、接続が最後の参照を失ってからかなり後にクローズが行われる場合がある。 結 果として、接続がクローズされる前にしばらくの間、 未参照接続が残ることになる。 これが 問題かどうかは、それぞれの環境に依存する。

総合的に見ると、ガベージコレクションを使用することは推奨しない。 明示的にクローズ するなどの他の手段を使用する方が適切である。 通常の手段が失敗した場合は、ガベージコ レクションが優れたバックアップとなる。 結局は、接続を永遠に残すよりも最終的に接続を クローズさせる方がよい。

接続はトランザクションと強く結び付いているので、優れた管理方法は、トランザクショ コンと接続を関連付けることである。 トランザクションの開始時に接続をオープンし、コミッ トまたはロールバック時に接続をクローズする。 トランザクションがどの接続を使用してい るかわかっているので、読者は接続を完全に無視し、トランザクションに対処できる。 トラ ンザクションの完了は目に見える効果なので忘れずにコミットし、 仮に忘れたとしても見分 けることが容易である。 ユニットオブワークによって、 トランザクションと接続の両方を管 理することに自然に適合できる。

不変データの読み込みなど、トランザクション以外の処理を行う場合は、 コマンドごとに 新しい接続を使用する。 プールは、一時的な接続の作成に関する問題に対処する。

切断されたレコードセットを使用している場合は、レコードセットにデータを加えるため に接続をオープンし、レコードセットデータを処理している間にクローズすることができる。 そして、データの処理を終了すると、 新しい接続やトランザクションをオープンしてデータ を書き込むことができる。 これを行う場合、レコードセットが処理されている間にデータが 変更されているか注意する必要がある。 これに関しては、並行性制御とともに取り上げる。

接続管理の詳細は、データベースの相互作用ソフトウェアの機能なので、 使用するストラ

テジーは、環境ごとに決定される場合が多い。

3.8 | その他の要点

. from という形式で あるコードでは、他のコードが列名を使用するのに対し、 select select 文を使用している。 select を使用すると、ある種のデータベースドライバでは、 新しい列が追加されるか、 列が並び換えられた場合にコードが壊れるという深刻な問題が発 生する。 これは、最新の環境では起こらないが、列の並び換えはコードを破壊するので、列 から情報を取得するために位置インデックスを使用している場合は、 select を使用する ことは賢明ではない。 列名インデックスを selectとともに使用することは問題ない。 実 際、列名インデックスは読みやすい。 しかし、 SQL 呼び出しに要する時間はほとんど同じ でも、列名インデックスだと遅くなるだろう。 通常どおり、 測定が必要だ。 ⋅

列番号インデックスを使用する場合は、 列が並び換えられても同期が取れなくなることが ないように、 必ず結果群 (result set) へのアクセスをSQL文の近くで行うことが必要であ る。このため、テーブルデータゲートウェイを使用している場合、 ゲートウェイで検索操作 を実行するコードごとに結果群が用いられるので、列名インデックスを使うべきである。 結 果として、 通常、 使用する構造をマッピングするデータベースごとにシンプルな、 作成、読 み出し、更新、削除 (create, read, update, delete) テストケースを作成することが必要 だ。 これは、 SQL とコードとの同期が取れなくなった際の状況の把握に役立つ。

毎回コンパイルしなければいけない動的なSQLではなく、 事前にコンパイルできる静的 な SQL を使用するために労力を費やすのは常に価値がある。 多くのプラットフォームには、 SQL を事前にコンパイルするためのメカニズムがある。 優れた経験的な方法は、 SQL クエ リーをまとめるために、文字列の連結を使用しないようにすることである。

多くの環境には、 複数の SQLクエリーを1つのデータベースバッチ呼び出しにまとめる 機能がある。 例には使用していないが、 本番稼動するコードで使用すべき確実な戦術である。 実行方法は、 プラットフォームによって異なる。

これらの例の接続に関しては、レジストリである 「DB」 オブジェクトへの呼び出しだけ を想定している。 接続を得る方法は環境に依存するので、環境に合わせて、 行う必要がある 処理を置き換える。 並行性に関する以外のパターンにはトランザクションを結び付けていな い。 再度説明するが、それぞれの環境に必要な処理を投入する必要がある。

3.9 参考文献

オブジェクトリレーショナルマッピングは多くの人にとって避けられない話題なので、こ の題材に関する文書は多くある。 しかし意外なことに、 一貫した、 完全な、 最新の書籍がな い。この理由から、本書の多くをこの扱い難く興味深い題材に割り当てた。

データベースのマッピングに関する素晴らしい点は、 拝借して利用できる多くの考え方が あることである。 最も有益なライブラリは、 [Brown and Whitenack]、 [Ambler)、 [Yoder]、 [Keller and Coldewey] である。 本書のパターンを補足するために、ぜひこれらの内容を参 照していただきたい。

56

第3章 リレーショナルデータベースへのマッピング

Web プレゼンテーシ

ここ数年間のエンタープライズアプリケーションにおける最大の変化の1つは、Webブ ラウザーベースのユーザインタフェースの発展である。 Web ブラウザーベースのユーザイ ンタフェースには、クライアントソフトウェアをインストールする必要がない、 共通のUI 手法である、 世界中へのアクセスが容易に行えるなど、 多くのメリットがある。

Web アプリケーションの作成は、サーバソフトウェア自体から開始する。 通常、 Web ア プリケーションを作成する場合は、 どのURLがどのプログラムで処理されるかを示すよう な構成ファイルがある。 多くの場合、1 つの Web サーバは、 さまざまなプログラムに対処 することができる。 これらのプログラムは、動的であり、 適切なディレクトリに配置するこ とでサーバに追加することができる。 Web サーバは、リクエストのURLを解釈し、 制御を Web サーバのプログラムに渡すことを行う。 Web サーバにおけるプログラムの構造化には、 スクリプトとしての構造化と、 サーバページとしての構造化という2つの主な方法がある。

スクリプト形式はプログラムであり、 通常、 HTTP 呼び出しを処理するための機能また は方法がある。 例として、 CGI スクリプトや Java サーブレットがある。 プログラムテキス トはプログラムが行えるほとんどのことを行うことができ、 スクリプトはサブルーチンに分 割され、他のサービスを作成および使用することができる。 また、文字列である HTTP リ クエストオブジェクトを調査することで Web ページからデータを取得する。 環境によって は、リクエスト文字列の正規表現を検索してデータの取得を行う場合もある (Perl を使用す るとこれを容易に行えるので、 CGI スクリプトにおいて一般的な選択肢になっている)。 Java サーブレットなどの他のプラットフォームは、この解析をプログラマのために行うの で、プログラマはキーワードインタフェースを用いてリクエストからの情報にアクセスでき る。これは、扱うべき正規表現が少ないことを意味する。 Web サーバの出力は、他の文字 列、 つまりレスポンスであり、 スクリプトはこの文字列に対して言語における一般的なスト リーム操作を使用して書き込みを行える。

ストリームコマンドによる HTML レスポンスの作成は、プログラマには不自然である。

また、別の方法でHTML ページを作成することに満足しているプログラマ以外の人にはほ ぼ不可能である。 これは、テキストページを返すことを中心にプログラムが構造化される サーバページの考え方につながる。 HTML の復帰ページを書き込み、 HTML スクリプト レットのコードに挿入して、ある時点で実行する。 この手法の例としては、PHP、 ASP、 JSP などがある。

サーバページ手法は、 「アルバム#1234の詳細を示せ」 など、レスポンスの処理が少ない 場合に有効である。 クラシックとジャズでアルバムの表示形式が異なる場合などのように、 入力に基づいた決定を行わなければいけない場合は、 混乱が生じる。

スクリプトはリクエストの解釈に最も効果があり、サーバベージはレスポンスの書式化に 最も効果があるので、リクエストの解釈のためにスクリプトを使用し、 レスポンスの書式化 にサーバページを使用するというように選択が分かれている。 実際には、この区別は、モデ ルビューコントローラパターンを使用するユーザインタフェースで最初に表面化する古い考 え方である。この考え方と、プレゼンテーション以外のロジックが抜き出される必要がある という不可欠な概念を組み合わせることで、モデルビューコントローラパターンの概念に適 合する。

モデルビューコントローラは、広く参照されるパターンだが、誤解されがちである。 実際、 Webアプリケーションが登場する以前は、 モデルビューコントローラの多くのプレゼン テーションは適切なものではなかった。 この混乱の主な理由は、「コントローラ」という言 葉の使用であった。 コントローラは、多くの異なるコンテキストで使用される。 また普通は、 モデルビューコントローラで使用されるのとは異なる意味で使用されるようである。そのた め私は、モデルビューコントローラのコントローラには「入力コントローラ」という用語を 使用することを好んでいる。

リクエストは、リクエストから情報を抜き取る入力コントローラに送信されてくる。 そし て、ビジネスロジックを適切なモデルオブジェクトに送る。 モデルオブジェクトは、データ ソースと通信し、レスポンス用の情報の収集だけでなく、 リクエストによって指示されたす べてを行う。 終了すると、入力コントローラに制御を返す。 入力コントローラは、結果を確 認し、レスポンスを表示するために必要なビューを決定する。 そして、 レスポンスデータと ともに制御をビューに渡す。 入力コントローラをビューへ渡すことは、 常に直線的な呼び出 しであるとは限らない。 むしろ、 入力コントローラとビューに共有されるある形式の HTTP セッションオブジェクトに、決まった場所に配置されたデータとともに転送される ことが多い。

View

get data

some Model objects

http request

carry out domain logic

create with domain data

get data

choose view

Controller

add data for view (link to model)

generate response

forward

handle http request

forward to view

Web Server

http request

http response

□ 4.1

モデル、ビュー 入力コントローラの役割が Web サーバで連携する方法の概略図。 コントローラはリクエストを処理し、 ドメインロジックをモデルに実 行させ、モデルに基づくレスポンスをビューに作成させる。

モデルビューコントローラを適用する第1の、 そして最も重要な理由は、モデルをWeb プレゼンテーションから完全に分離することが確実にできるからである。 モデルをWebプ レゼンテーションから分離することで、別のプレゼンテーションを後から追加することが容 易になるだけでなく、プレゼンテーションを修正することも容易になる。 処理を別々のトラ ンザクションスクリプトやドメインモデルオブジェクトに置くと、テストを行うことも容易 になる。これは、ビューとしてサーバページを使用している場合、 特に重要である。

ここで、「コントローラ」という言葉の2つ目の使い方が出てくる。 多くのユーザインタ フェースの設計は、アプリケーションコントローラオブジェクトの中間レイヤによってプレ ゼンテーションオブジェクトとドメインオブジェクトを分離する。 アプリケーションコント ローラの目的はアプリケーションのフローを処理することであり、 どの順番でどの画面を表 示するかを決定する。プレゼンテーションレイヤの一部として表示することもあれば、プレ ゼンテーションレイヤとドメインレイヤとを仲介する分離したレイヤとして考えることもで きる。 アプリケーションコントローラは、特定のプレゼンテーションに関係なく書き込まれ る。この場合、アプリケーションコントローラは、プレゼンテーション間で再度使用できる。 異なるプレゼンテーションに異なるフローを持たせることが最善である場合が多いが、 同じ 基本フローと遷移を用いた異なるプレゼンテーションがある場合にこれは有効である。

すべてのシステムにアプリケーションコントローラが必要なわけではない。 システムに画 面の順序とその間の遷移に関する多くのロジックがある場合、 アプリケーションコントロー ラは有用である。 また、ドメイン上でページとアクションがシンプルにマッピングしていな い場合にも役立つ。 しかし、 任意の順序で画面を見ることが多い場合は、おそらくアプリ ケーションコントローラの必要性はほとんどない。 判断基準としては、画面フローをマシン が管理しているのであればアプリケーションコントローラが必要で、ユーザが管理している のであれば必要ないと考えるべきである。

4.1 ビューに関するパターン

ビューに関しては、トランスフォームビュー、テンプレートビュー、 ツーステップビュー という3つのパターンが考えられる。 この3つのパターンにより2種類の選択が生じる。 1 つは、トランスフォームビューとテンプレートビューのどちらを使用するかという選択、も う1つは、これらのパターンのいずれかが、シングルステージビューとツーステップビュー のどちらを使用するかという選択である。 トランスフォームビューとテンプレートビューの 基本パターンはシングルステージビューである。 ツーステップビューは、 どちらにも適用で きるバリエーションである。

テンプレートビューとトランスフォームビューとの選択から始めよう。 テンプレートビュー

を使用すると、 ページの構造にプレゼンテーションを書き込むことができ、 ページにマーク を付けて動的な内容が必要となるところを示すことができる。 人気の高いプラットフォーム の多くがこのパターンに基づいている。これらのプラットフォームは、完全なプログラミン グ言語をページに入れることができるサーバページ技術 (ASP、 JSP、PHP) であることか 多い。 このサーバページ技術は、 多くの能力や柔軟性を提供する。 残念なことに、これは 持することが困難なとても複雑なコードにもつながる。 結果として、サーバページ技術を使 用するのであれば、 多くの場合ヘルパーオブジェクトを使用して、 ページ構造から切り離し てプログラミングロジックを保持することを守らなければいけない。

トランスフォームビューはプログラムの変換方式を使用する。 通常の例は XSLT である。 これは、 XML フォーマット、 または容易にそれに変換できるドメインデータを扱っている のであれば、とても有効である。 入力コントローラは、 適切な XSLT スタイルシートを選 別し、モデルから収集された XML に適用する。

ビューとして手続き型スクリプトを使用しているのであれば、 トランスフォームビューか テンプレートビューのどちらか一方の方式、 またはこの2つの興味深い組み合わせでコード を作成することができる。 私は、ほとんどのスクリプトが主な形式としてこの2つのパター ンのいずれかに従っていることに気付いた。

2つ目の選択は、シングルステージビュー (図 4.2 参照) にするか、ツーステップビュー を使用するかということである。 ほとんどの場合、シングルステージビューには、アプリ ケーションの画面ごとに1つのビューコンポーネントがある。 ビューは、ドメイン指向デー タを受け取り、そのデータをHTML に変換する。 「ほとんどの場合」 と説明した理由は、 同じような論理的な画面がビューを共有する場合があるからである。 そうであったとしても、 画面ごとに1つのビューとして考えることがほとんどである。

ツーステップビュー (図 4.3 参照) は、このプロセスを2つの段階に分割し、 ドメイン データから論理的な画面を作成してから、 HTML に変換する。 画面ごとに1つの第1段階 ビューがあるが、全体のアプリケーションの第2段階ビューは1つだけしかない。

ツーステップビューのメリットは、 1箇所で使用する HTML を決定することである。サ イトのすべての画面を修正するために変更するオブジェクトは1つだけなので、 HTML へ の広範囲の変更が容易になる。 当然、論理的なプレゼンテーションが同じ状態の場合にだけ そのメリットを得ることができるので、異なる画面が同じ基本レイアウトを使用するサイト を用いることが最も効果的である。 設計が極めて集中するサイトは、優れた論理的な画面構 造を作り出すことができないだろう。

"create" Order HTML 1-1+1 Customer Data Order Data Customer View Order View -create- Customer HTML

図4.2 シングルステージビュー Customer Logical Screen -create- Customer First Stage Order First Stage Customer Data 441 Order Logical Screen "create" Order Data H "create Customer HTML 4.3 ツーステップビュー Second Stage "create" Order HTML

062

第4章 Webプレゼンテーション

ツーステップビューは、 同じ基本的な予約システムを使用する複数の航空会社など、複 のフロントエンドの顧客にサービスが使用されている Web アプリケーションを使用する』 合に効率的である。 論理的な画面の限度内で、異なる第2段階を使用することによって、 ロントエンドごとにさまざまな外見にすることができる。 同様の方法で、 ツーステップ ビューを使用し、通常の Web ブラウザーと、 パームトップに対し別々の第2段階を用い 異なる出力デバイスに対処できる。 再度説明するが、 同じ論理的な画面はUIが共通の2 で使用することが限度であり、ブラウザーと携帯電話などのようにUIがまったく異なる 合は不可能だろう。

4.2 | 入力コントローラに関するパターン

入力コントローラには2つのパターンがある。 Web サイトのページごとの入力コントロー ラオブジェクトが最も一般的である。 最もシンプルな場合、 このページコントローラは、 サーバページ自体になり、ビューと入力コントローラの役割を併せ持つ。 多くの実装では、 入力コントローラを別々のオブジェクトに分離すると、 処理が容易になる。 入力コントロー ラは、適切なモデルを生成して処理を行い、 結果を返すためにビューのインスタンスを作成 して結果を返すことができる。 多くの場合、 ページコントローラとビューとは完全に一対 の関係ではない。 ボタンやリンクであったりする1つのアクションごとにページコントロー ラがあるというのが正しい考え方である。 アクションはページに対応することが多いが、 状 況に応じて2、3の異なるページに行くリンクなどの場合は、ページに対応しないことがある。

入力コントローラには、 HTTP リクエストの処理と行うべきことの決定という2つの責 任があり、 この責任を分離することは意味がある場合が多い。 サーバページはリクエストを 処理することができ、別々のヘルパーオブジェクトを委譲して、行うことを決定する。 フロ ントコントローラは、すべてのリクエストを処理する1つのオブジェクトだけを持つことで この分離を推進する。 この1つのオブジェクトは、 URL を解釈して、 処理するリクエスト の種類を考え、別々のオブジェクトを作成してリクエストを処理する。 この方法は、 1つの オブジェクト内で処理するすべてのHTTP に焦点を当て、サイトのアクション構造を変更 する際は、常にWeb サーバを再構成する必要を回避できる。

4.3 | 参考文献

Web サーバ技術に関する書籍のほとんどは、優れたサーバ設計の解説に1、2章を割いて いる。とは言っても、技術的な説明に埋没しがちなものが多い。 [Brown et al.]の第9章に は、 Java Web デザインに関する素晴らしい解説がある。 より多くのパターンに関する最良 の情報源は[Alur et all である。 これらのパターンの多くは、 Java 以外で使用することがで きる。 私は、入力コントローラとアプリケーションコントローラを切り離すことに関する用 語を [Knight and Dai]から使わせていただいた。

第4章 Webプレゼンテーション

(by Martin Fowler. David Rice)

並行性は、ソフトウェア開発において最も扱いにくい部分である。 複数のプロセスやス レッドが同じデータを処理するときは常に並行性が問題になる。 並行性を説明することは簡 単ではない。 トラブルを引き起こす場合を考えるのが難しいからだ。 何かを見落とすことは どんな場合にも起こりうるだろう。それに、並行性はテストするのが容易ではない。 ソフト ウェア開発の基礎段階でさまざまな自動化テストを行うのは簡単である。 しかし、 並行性か ら生じるトラブルを防ぐためのテストを実行するのはとても難しい。

皮肉なことに、エンタープライズアプリケーション開発において、 並行性を使用すること がなく、そのことを問題にしていないソフトウェア開発部門もある。 エンタープライズ系の 開発者が並行性をあまり気にしない理由は、 トランザクション管理にある。 トランザクショ ンが提供するフレームワークは、エンタープライズアプリケーションのなかで最も扱いにく い並行性の側面の多くを吸収している。 データ処理をトランザクション内で行っている限り、 特に問題は発生しないのである。

しかし残念ながら、トランザクションによって並行性の問題を完全に無視できるわけでは ない。それは、システムとの相互作用の多くを1つのデータベーストランザクション内に配 置することはできないからだ。 つまり、データが複数のトランザクションにまたがる場合は、 並行性の管理が必要である。 このように複数のデータベーストランザクション間で処理され るデータの並行性を制御することを、私はオフライン並行性と呼んでいる。

エンタープライズ系開発者にとって並行性が問題となるもう一つの分野は、アプリケー ションサーバである。 アプリケーションサーバは、1つのアプリケーションサーバシステム 内で複数のスレッドをサポートしている。 これは比較的単純なケースなので、本書では多く 説明しない。 適切なサーバプラットフォームを使用することで対応できる問題である。

これらの問題を理解するには、並行性についての一般的な概念を理解しておく必要がある。 そこで本章では、まずこれらの問題について見ていくことにしよう。 ただし本章では、ソフ

トウェア開発における並行性の処理については説明しない。 それだけで本が一冊書けてしま うからだ。 本章では、あくまでもエンタープライズアプリケーション開発における並行性に ついてだけ採り上げる。 その後で、 オフライン並行性を処理するパターンを紹介し、 アプリ ケーションサーバの並行性についても簡単に解説したい。

本章では概念を説明するために、 主に読者に馴染みのあると思われる分野の例を使ってい る。つまり、ソースコードに対する変更を調整するために開発チームが用いるソースコード 管理システムの例を使用して説明する。 この例を使用するのは、単に馴染みがあるというだ けでなく、比較的理解しやすいからだ。 エンタープライズアプリケーションの開発をするた めには、ソースコード管理システムに関する知識が必要である。

5.1 並行性の問題

まず、並行性の本質的な問題について説明しよう。 なぜ本質的かというと、それらは並行 性制御システムが避けようとしている基本的な問題だからだ。 しかし、これらだけが並行性 の問題のすべてではない。 制御メカニズムが、トラブルを解決しようとしてかえって新たな トラブルを生じさせることも多いからだ。 ただ、これら本質的な問題にこそ並行性制御の重 要なポイントがある。

最もわかりやすい例が更新結果が失われることだろう。 たとえば、 Martin がファイルを 編集して checkConcurrency メソッドを変更するとしよう。 この作業は数分で終えること ができる。 しかし同時に David も同じファイル内の updateImportant Parameter メソッド を編集しているとしよう。 David は Martin よりも後に作業を始めたのだが、 Martin より も作業が早く終わったとする。 ここで不幸が生じる。 Martin がファイルを開いた時点では、 David の更新は反映されていない。 そのため、 Martin がファイルの編集を終えたとき、そ の前に David が更新したファイルに上書きすることになり、 David による更新は無に帰し てしまう。

一貫性のない読み込みという例もある。 読み込んだ2つの情報は間違っていないが、正し いものではないという場合である。 たとえば、 Martin が、 locking と multiphase の2つの サブパッケージを含む並行性パッケージの中にクラスがいくつあるか調べているとする。 locking パッケージを見ると、そこには7つのクラスがある。 このとき Roy から電話がか かってきて、難しい質問を聞かれたとしよう。 Martin が電話に答えている間に、 David が 4 フェーズロックコード内のバグを修正し、7つのクラスがあった locking パッケージに2 つ、5つのクラスがあった multiphase パッケージに3つのクラスを追加する。 Martin が 電話を終えて multiphase パッケージを見ると、そこには8つのクラスがある。 したがって Martin の計算ではクラスの数は7+8の15になる。

これは正しい数ではない。 David が修正を加える前のクラスの数は7+5の12で、 修正 の数は9+8の17である。 どちらもその時点では正しい数である。 しかし、 15という数に どの時点でも正しい数ではない。 Martin は一貫していないデータを読み込んだわけだ。 こ のような問題のことを 「一貫性のない読み込み」 と呼ぶ。

これらの問題は正確さ (または安全性)を脅かし、2人が同時に同じデータで作業しなけ れば起こらなかったかもしれない不正確な振る舞いを引き起こす。 ただし、 正確さだけが重 要であれば、それほど深刻な問題ではない。 同じデータで2人が同時に作業できないように するだけで解決する。 しかし、 それで正確さを確保できるとしても、並行して何かを行うこ とはできない。 並行性プログラミングの重要な条件として、 正確さだけでは十分でなく、即 応性も必要である。 アクティビティをいくつ並行して処理できるかということも大事だ。 エ ラーの重要度や頻度、データの並行処理の必要性にもよるが、 即応性を重視して正確さを犠 牲にすることもある。

これらは並行性に関する問題のすべてではないが、基本的なものだ。 これらを解決するた めに、私たちはいろいろな制御メカニズムを使用する。 しかし残念ながら、 どんな問題にも 対応できる策は存在しない。 基本的な問題に比べればそれほど深刻ではないが、 解決策から 新たな問題が生じることもある。 そこで、 ここから重要なポイントが浮かび上がる。 問題が 許容できるのであれば、どんな形式の並行性制御もいらないということだ。 とても稀なケー スだが、そのような場合がないわけではない。

5.2 |実行コンテキスト

システム内で処理が行われるときは、常に何らかのコンテキスト内、 それも複数のコンテ キスト内で行われる。 実行コンテキストに関しては標準的な用語がないので、ここでいくつ か定義をしておこう。

外部との相互作用という観点から見れば、リクエストとセッションが2つの重要なコンテ キストである。 リクエストとは、ソフトウェアが動作する世界の外側からの呼び出しのこと であり、ソフトウェアはこれに対してレスポンスを返す。 リクエストの処理の大半はサーバ 内で行われ、クライアントはレスポンスが返ってくるのを待つ。 プロトコルによっては、レ スポンスがくる前にクライアントがリクエストを中断できるものもあるが、これは稀なケー スである。 クライアントが別のリクエストを発行し、 その前に送信したリクエストに割り込 む場合の方が多い。 たとえば、クライアントがOrder (注文) した後に、 その Order を キャンセルする別のOrder を送るといった場合である。 クライアント側から見れば2つの リクエストは明らかに関連しているが、プロトコルによっては、サーバはその関連性を意識 していない。

セッションとは、クライアントとサーバが一定時間内に相互作用することである。 セッ ションは1つのリクエストだけで構成されることもあるが、ユーザからは一貫した論理シー ケンスに見える一連のリクエストから構成されていることが多い。 一般に、 セッションは ユーザのログインで始まり、クエリーやビジネストランザクションの発行などといったさま ざまな処理を行う。 セッションの最後にユーザはログアウトする。 または、 ユーザが別の処 理を始めると、システムはそれをログアウトしたと解釈する。

エンタープライズアプリケーションで使用されるサーバソフトウェアは、リクエストと セッションの両方を、クライアントからサーバへという角度と、 クライアントを別のシステ ムへという角度から見る。 そのため、クライアントからのHTTP セッションと各種データ ベースのセッションなど、複数のセッションが同時に進行することになる。

OS から見た重要な2つの用語がプロセスとスレッドである。 プロセスは重量級の実行コ ンテキストであり、 プロセスで扱う内部データを分離する。 スレッドは軽量級のアクティブ エージェントであり、1つのプロセス内で複数のスレッドが動作することができる。 1つの プロセス内で複数のリクエストに対応でき、リソースを効率的に使用できるスレッドの方が 好まれている。 しかし、 スレッドはメモリを共有するのが一般的で、 これが並行性の問題を 引き起こす。 しかし、環境によっては、メモリを共有しない分離されたスレッドを使用でき、 スレッドがどのデータにアクセスするかを制御できる場合もある。

実行時の難点は、望ましい順序にそれらが並ばないことである。 理論的には、各セッショ ンはその存続期間中、 プロセスとは排他的な関係にある。 プロセスはそれぞれが適切に分離 されるため、並行性におけるコンフリクトは少なくなるはずである。 しかし、今のところそ のような用途に使えるサーバツールはない。 このようなツールに近いものとしては、 初期の Perl Web システムでよく使われていた、リクエストごとに新しいプロセスを開始するとい うモードがあった。 しかし、 プロセスを開始するには多くのリソースが必要なため、最近で はあまり使われなくなり、1つのプロセスで1つのリクエストだけを処理するシステムが一 般的である。 おかげで並行性についての悩みが軽減されたことになる。

データベースの場合は、トランザクションという重要なコンテキストがある。 トランザク ションは、クライアントからの複数のリクエストをあたかも1つのリクエストであるかのよ うに扱う。 トランザクションは、アプリケーションからデータベースシステムトランザク ション)、またはユーザからアプリケーション(ビジネストランザクション) の間で行われ る。これらについては、後で詳しく説明する。

5.3 分離性および不変性

並行性の問題は今に始まったことではなく、ソフトウェアに携わる人たちがこれまでさま

ざまな解決策を考えてきた。 エンタープライズアプリケーションの場合は、 分離性と不 という2つの問題をいかに解決するかが特に重要である。

並行性の問題は、プロセスやスレッドなど複数のアクティブエージェントが同じデータ 同時にアクセスしたときに発生する。その1つの対処法が分離で、データを区切ってそ 1つのアクティブエージェントしかアクセスできないようにする方法である。 OS のメモ 内ではプロセスは、次のような方法で処理されている。 つまり、 OS は1つのプロセスに しメモリを排他的に割り当て、そのプロセスがリンクしているデータの読み書きを実行で るようにしている。 このような例としては、現在普及している多くのアプリケーション製 でもファイルがロックされるのを読者は経験したことがあるだろう。 たとえば、 Martin あるファイルを開いているときは、そのファイルは他の人は開けられなくなる。 開けた場 でも、 Martin が作業を始める前のファイルのコピーを読み取り専用で開くだけで変更す ことはできず、 Martin が加えている変更もそのファイルでは見ることができないのと同 である。

分離は、エラーを起こりにくくするという意味でもとても重要な技法である。 常に並行 に注意していなければならない技法を使用したために、問題が起こっている場合がとても い。 分離を行えば、プログラムが分離された領域内に挿入される。この領域内では並行性 ついて懸念する必要がない。 つまり、優れた並行性設計とは、 このような領域を作成する 法を模索して、 できる限り多くのプログラミングをいずれかの領域で行えるようにするこ である。

並行性の問題は、 共有しているデータが修正できる場合にしか発生しない。 つまり、 不要 データを認知することが、 並行性によるコンフリクトを回避する方法の1つとなる。 だが 多くのシステムではデータの修正を主な目的としているため、すべてのデータを不変なもの にすることはなかなかできない。 そこで、 不変データ、 または不変であると認知したデー を特定することで、そのデータの並行性を考慮しなくても安心して共有できるようになる 別の方法としては、データを読み込むだけのアプリケーションを分離して、そのアプリケー ションにデータソースのコピーを使用させることで、 並行性の制御の懸念をなくすること できる。

5.4 軽い並行性制御および重い並行性制御

では、変更できても分離できないデータの場合はどうなるのだろうか。 並行性制御には大 きく分けて軽い制御と重い制御の2つの形態がある。

Martin と David の両者が Customer というファイルを同時に編集しようとした場合を 想定しよう。 軽ロックでは両者ともファイルのコピーを作成し、自由に編集することができ

るので、 David が先に編集を終えた場合、 彼は自分の作業を問題なくチェックインできる。 並行性制御が機能し始めるのは、 Martin が変更をコミットしようとしたときだ。 この時点 で、ソースコード管理システムが、 Martin が加えた変更と David の変更とのコンフリクト を検出して、 Martin によるコミットは拒否され、 その状況の処理は Martin の判断に任せ られる。一方の重ロックでは、最初にファイルをチェックアウトした人以外は編集が行えな くなる。 つまり、 先に Martin がファイルをチェックアウトした場合、 David は、 Martin が修正を終えて変更をコミットするまで、 そのファイルでの作業はできないことになる。

簡単に表現すると、 軽ロックではコンフリクトが検出され、 重ロックではコンフリクトが 発生しないようになる。 実際のソースコード管理システムでは両方のタイプを使うことがで きるが、現時点では、ほとんどのソースコード開発者は、 軽ロックの方を好んで使用してい る(「軽ロックは実際にはロックではない」 という合理的な意見も多いようだが、 用語とし て便利なうえ広く受け入れられているため、 ここではそれらの意見は考慮の対象外とさせて いただく)。

この2つの手法にはそれぞれ長所と短所がある。 重ロックの場合は、並行性が低下する。 たとえば、 Martin が作業している間ファイルはロックされるため、他の人は彼が終了する まで待たなくてはならない。 重いソースコード管理メカニズムを使った環境で作業をしたこ とがあれば、これがいかに不満に感じられるかがわかるだろう。 だが企業データの場合は、 この方が適していることが多いのだ。 誰かがデータを編集している間は、他の人は見ること ができないようにした方が混乱を生じさせないからだ。

軽ロックでは、 ロックが実際に機能するのはコミットする段階だけなので、ストレスを感 じることなく作業を進めることができるだろう。 問題は、コンフリクトが生じた場合の対処 の仕方である。 基本的に、 David のコミット後にコミットしようとしたすべての人は、 David がチェックインしたバージョンのファイルをチェックアウトし、 自分が加えた変更を David が加えた変更と一緒にしてから、 新しいバージョンにチェックインする必要がある。 ソースコードではこの方法は、それほど難しくはない。 多くの場合、ソースコード管理シス テムが自動的に結合を行う。 自動的な結合を行わない場合でも、ツールを使えば簡単に違い を見つけることができる。 しかしビジネスデータの場合は、簡単に自動結合できるわけでは ないため、たいていは変更をすべて破棄して最初からやり直すことになる。

軽い手法と重い手法のどちらの並行性制御でロックを選択するかは、 コンフリクトの頻度 と重要性に左右される。 コンフリクトの頻度がとても低い場合や、 たとえ発生した場合でも その影響が大きくないのであれば、 軽ロックを使用すべきである。 より高い並行性を維持で 一般的に実装も簡単だからである。 一方で、 コンフリクトがユーザに与える影響が大き い場合は、軽い手法ではなく重い手法を使用する必要がある。

しかし、いずれの手法も万全と言えるものではない。 これらを使用することで生じる問題 は、最初に解決しようとしていた並行性の基本的な問題と同じくらい、トラブルの原因にな

りかねない。 詳細については並行性に関する専門書に委ねることにするが、以下にいくつ の留意すべき点を挙げておこう。

5.4.1 一貫性のない読み込みの防止

次のような状況を想定してみよう。 Martin が Order クラスを呼び出す Customer ク スを編集し、同時に David が Order クラスを編集し、 インタフェースを変更する。そして 先に David がコンパイルしてチェックインし、 続いて Martin がコンパイルしてチェック ンする。 Martin が気付かない間に Order クラスが変更されているので、 すでにこの時点 共有コードは壊れている。 ソースコード管理システムの中には、このような一貫性のない み込みを察知できるものもあるが、そうでない場合は、チェックインする前にファイルを 新しておくなどの方法で、 手動で一貫性を実現させる必要がある。

本質的には、これは一貫性のない読み込みの問題であるが、更新を喪失してしまうことから 並行性の問題点であると考える人が多いため、 見落とされる場合が多い。 重ロックは、読み 書きのロックという従来からの方法でこの問題に対処する。 データを読み込むには読み込み (または共有) ロックが、 書き込むには書き込み (または排他的) ロックが必要になる。 時に複数のユーザが読み込みロックを行うことができるが、 誰かが読み込みロックを実行 た時点で他の人は書き込みロックを行えなくなる。 逆に誰かが書き込みロックを行った時 他の人はいずれのロックも行えなくなる。 このようにこのシステムでは、 重ロックに よって一貫性のない読み込みが回避されている。

軽ロックでは、データのバージョンを示す何らかのマークによってコンフリクトを検出す る。ここで言うマークとは、タイムスタンプまたはカウンタなどである。 喪失した更新を 出するため、システムは更新されたデータのバージョンマークと共有データのバージョン マークをチェックし、もしそれらが同一だった場合は、 更新が許可されバージョンマークも 更新される。

一貫性のない読み込みの検出も基本的には同様の動作を行うが、この場合、読み込まれた データすべてのビットのバージョンマークが共有データのバージョンマークと比較され、少 しでも違うとコンフリクトが発生していると判断される。

読み込まれるデータすべてのビットへのアクセスを制御すると、 コンフリクトやあまり重 要でないデータの待機などといった問題が起こる場合が多い。 このような不要な負荷は、使 用したデータとほとんど使用しないデータを分離することで軽減させることができる。 製品 の選択リストの場合は、 データの変更を開始した後に新しい製品がリストに加えられてもあ まり影響はないが、たとえば請求書を書こうとして料金一覧をまとめているときに、この 覧に変更が加えられた場合は重大である。 この判断が難しいところは、用途を注意深く分析 しなくてはならないという点だ。 また、顧客の住所の郵便番号は特に重要ではないかもしれ

ないが、税金の計算を割り出す時など所在地に基づいて行うときには、住所の並行性は制御 しなければならない。 このように何を制御するべきかを判断するのは、 どの並行性制御を採 用するにしても手間を必要とするのである

一貫性のない読み込みへの対処法として一時的読み込みを使用する方法もある。 この手法 では、読み込まれた各データにタイムスタンプか不変ラベルを付け、 データベースは、その タイムスタンプの日時かラベルを基準にデータを返す。 データベースシステムでこの方法を 使うことは稀だが、ソースコード管理システムにはしばしば使われる。 この手法の問題は、 データソースが完全な変更の一時履歴を提供しなくてはならないため、処理に時間とスペー スが必要になるという点にある。 ソースコードでは問題ではないかもしれないが、 データ ベースではより複雑で負荷の高いものとなってしまう。 ドメインロジック内の特定の領域で は、この機能を必要とする場合もある。 実際の手順については、 [Snodgrass]と[Fowler TP]を参照してほしい。

5.4.2 | デッドロック

重い技法特有の問題にデッドロックというものがある。 たとえば、 Martin が Customer ファイルを、 David が Order ファイルをそれぞれ編集し始めたとしよう。 途中で、 David は自分の作業を完了するには Customer ファイルも編集しなくてはならないことに気付く が、 Martin がロックしているため待たなければならない。 その後、 Martin も Order ファ イルを編集する必要があることに気付くが、 その時点では David がロックしている。この 状態がデッドロックだ。 一方が終了しない限り両方とも先に進めなくなった状態をいう。 こ の例だけを見れば、デッドロックは簡単に回避できるように見えるかもしれないが、さらに 大勢の人が関わる場合には、かなり扱いにくい状態になるのは明白である。

デッドロックへの対処方法としてはいくつかの技法が考えられる。 1つにはデッドロック を検出するソフトウェアを使用する方法である。 この場合 「犠牲」 になる人を選択し、 その 人の変更を破棄して作業を終了させてロックを解除し、 他の人が先に進めるようにする。 デッドロックの検出はとても難しく、 「犠牲者」にとっては非情なものである。 同様の手法 に、すべてのロックに制限時間を設定するというものがある。この手法では、制限時間に達 した時点でロックが解除されるため、それまでの作業が犠牲になる可能性もある。 タイムア ウトはデッドロック検出よりも簡単に実装できるが、もし誰かがロックした状態を維持して いる場合には、デッドロックが生じていなくても他の誰かが犠牲になることもある。

タイムアウトと検出はデッドロックが起こったときの対処法だが、 他にもデッドロックそ のものが起こらないようにする手法もある。 デッドロックは、基本的にすでにロックされて いる人が、さらに他のデータも処理しようとした際に(または、読み込みロックから書き込 みロックに変更しようとした場合に) 生じる。 つまり、デッドロックを防止する方法の1つ

として、作業を開始した時点で強制的にすべてのロックを取得するようにして、それ以上 ロックは行えないようにしておくという方法がある。

全員に順番でロックを取得させる方法を指定できる。 たとえば、ファイルを常にアルフ ベット順にロックするようにすることも可能である。 この場合、 David が Order ファイ のロックを取得した時点では、 Customer ファイルのロックはアルファベット順では Ord ファイルより前になるため取得できない。 この時点で、 David は潜在的犠牲者となる。

また、 David がすでに持っているロックを Martin が取得しようとしたときに、 Mart が自動的に犠牲候補になるように設定することもできる。 多少荒っぽい技法ではあるが、 単に実装でき十分有効な手法である場合が多い。

より慎重に行いたい場合は、複数の手法を同時に使うことができる。 たとえば、最初に べてのロックを全員に強制的に与えておき、 何かが起こったときのために、さらに時間制 を加えるという方法である。 念には念を入れている方法であるが、この慎重さは賢明だと える。デッドロックは、簡単にその影響が拡大してしまう恐れがある面倒な問題だからで る。

万全のデッドロックメカニズムを実行していると思っていても、予期せぬ出来事が次々 起こることもある。 エンタープライズアプリケーション開発では、できるだけシンプルか 慎重な手法を使用することを推奨する。 場合によっては誰かが犠牲になることがあっても デッドロック対策を怠ったときに起こり得る事態に比べれば、はるかに良い方法である。

5.5 トランザクション

エンタープライズアプリケーションで並行性を処理する最も有効なツールは、 トランザク ションである。 「トランザクション」 という言葉からは、 金銭や商品の交換を連想すること が多い。 ATMで暗証番号を入力して現金を引き出すのも、 有料道路で通行料を支払うのも、 スーパーでビールを買うのもすべてトランザクションである。

このような金銭取り扱いの例から、この用語の的確な定義を引き出すことができる。 第1 に、トランザクションは開始時点と終了時点が明確に定義された一連の連続した動作である。 ATMでのトランザクションはカードを挿入した時点で始まり、 現金が引き出されたか残高 不足が判明した時点で終了する。 第2に、関係するリソースがトランザクションの開始時点 と終了時点で一貫していることである。 ビールを買った人は、財布の中身は少し減ったが、 その分ビールを手に入れている。 つまり、 彼にとっての資産価値の合計は変わっていないわ けである。 販売する側も同様で、無料でビールを配っていたら商売は成り立たない。

さらに各トランザクションは、必ずオール・オア・ナッシング (全か無か)で完了する。 銀行は、 実際にATMから現金が引き落とされない限り、 引き落とし額を口座の残高から差

し引くことはない。 人という要素が介在する場合は、このトランザクション中の最後のプロ バティ (残高の更新) が忘れられることも起こりうるが、ソフトウェアなら確実に行うこと ができる。

5.5.1 | ACID

ソフトウェアトランザクションは、以下の用語の頭文字を使用した ACID プロパティとい う用語で表現されることが多い。

原子性 (Atomicity) : トランザクションの中で実行される一連のアクションの 各ステップは必ず完了しなくてはいけない。 完了しない場合はすべてが開始前 の状態に戻る。 トランザクションには、 部分成立という概念は存在しない。 た とえば、 Martin が自分の預金口座から小切手口座にいくらか移動しようとした とき、預金口座からお金を引き出した後にサーバがクラッシュした場合、 シス テムは最初からお金が引き出されていないかのように振舞う。 コミットした場 合は預金口座からの引き出しと小切手口座への記入の両方が実行され、 ロール バックした場合はどちらも実行されない。 必ず両方かまたは無かのいずれかで ある。

■一貫性 (Consistency): トランザクションの開始時点から終了時点まで、 シス テムのリソースは必ず一貫した正常な状態でなくてはならない。

■分離性 (Isolation):個々のトランザクションの結果は、そのトランザクション が問題なくコミットされるまで、 その他のオープンなトランザクションから見 えてはならない。

■耐久性 (Durability) : コミットされたトランザクションの結果は、永続的であ る必要がある。言い換えれば、「どのような種類のクラッシュが起こっても存続 しなければならない」。

5.5.2 | トランザクション可能なリソース

エンタープライズアプリケーションにおけるトランザクションは、データベースに関する ことが多い。 しかし他にも、メッセージキュー、 プリンタ、 ATM などトランザクションを 使って制御できるリソースは数多くある。このことからもトランザクションを技術的に論じ る場合、「トランザクション可能なリソース」 という言葉が使われる。 「トランザクション可 「能な」とは、トランザクションを使って並行性を制御できるということである。 「トランザ クション可能なリソース」 では多少無理があり、 呼びにくいので、ここでは通例として

「データベース」という言い方をするが、これはトランザクション可能なあらゆるリソー を指していると考えていただきたい。

現在のトランザクションシステムは、スループットを最大限に高めるためトランザクシ ンが、 できる限り短時間に実行されるように設計されている。 そのため、複数のリクエス を含むようなトランザクションは避けたほうがよい。 複数のリクエストを含むトランザ ションは、一般的にロングトランザクション (疎結合トランザクション) と呼ばれている。 このことから、 トランザクションをリクエストの先頭から開始し、その末尾で完了させ 手法が一般に使用されている。 リクエストトランザクションはシンプルなわかりやすいモ ルであり、 多くの環境でメソッドをトランザクション可能なものとしてタグ付けするだけ 容易に指定することができる。

このバリエーションの1つに、トランザクションのオープンをできるだけ遅らせるとい 方法がある。 この遅延トランザクションでは、すべての読み込みをトランザクション以外の 部分で行い、更新するときにだけトランザクションをオープンする。 この方法は、トラン クションに要する時間を最小限に抑えることができる。 トランザクションのオープンから 初の書き込みまでに時間差があると、 即応性は向上するかもしれないが、 トランザクション が始まるまで並行性の制御ができないため、 一貫性のない読み込みが生じる可能性がある よほど明確な意図があり、 複数のリクエストにまたがるビジネストランザクション (次項を 参照)があるのでない限り、 そのような構成にするメリットはあまりない。

トランザクションを使用する場合は、 何がロックされるかを明確にしておくことが必要だ。 多くのデータベースアクションでは、 トランザクションシステムによって関連する行がロ クされるため、複数のトランザクションから同じテーブルにアクセスできるようになる。た だし、 トランザクションによってテーブル内の多くの行がロックされると、 データベースカ 処理できる以上のロックが存在することになり、テーブル全体がロックされてしまうことに なる (その他のトランザクションがロックアウトされる)。 このロックエスカレーションは 並行性に大きく影響することから、ドメインのレイヤスーパータイプレベルには、 データ用 の 「オブジェクト」 テーブルを置くべきではない。 テーブルは、 ロックエスカレーションを 引き起こす最有力候補となり、テーブルがロックされるとその他すべての人がデータベース から締め出されてしまうことになる。

5.5.3 | 即応性に対するトランザクション分離性の制限

通常は、トランザクションの完全な保護を制限して、 即応性を向上させる手法を使用して いる。この手法は、 特に分離レベルを定義するときに適用されている。 完全な分離レベルを 使用する場合には、トランザクションを直列化して使用することも考えられる。 トランザク ションを並行して実行し、 トランザクションを連続して実行したときとまったく同じ結果が

得られる場合、 直列化可能となる。 つまり、 先に紹介した Martin がファイル数を数えた例 では、直列化可能なレベルでは、彼のトランザクションがDavid のトランザクションが始 まる前 (12) か後 (17) に完了したときと同じ結果が必ず得られることになる。 直列化可能 なレベルでは、この場合のようにいずれの結果が得られるかは保証できないが、少なくとも 正しい数を得ることは保証されるわけだ。

ほとんどのトランザクションシステムは、分離性を4つのレベルで定義している SQL標 準を採用している。 直列化可能なレベルは最も強力なレベルであり、 それ以下の各レベルで は、特定の一貫性のない読み込みが起こることを容認している。 David がファイルを修正し ているときに Martin がファイル数を数える例を使って、各レベルを解説することにしよう。 locking と multiphase の2つのパッケージが存在している。 David が更新する前は locking パッケージ内には7つのファイルが、 multiphase パッケージ内には5つのファイ ルがあったが、David が修正を加えた結果、 locking パッケージ内のファイル数は9 multiphase パッケージ内のファイル数は8になってしまった。 Martin は、 まず locking バッケージのファイル数を確認し、 その後 David が両方のパッケージを更新した後に multiphase パッケージのファイル数をチェックする。

分離レベルが直列化可能な場合、 Martin の答えは12か17 になることが保証される。 い ずれも更新前と更新後のファイル数という意味で正しい数字だ。 このように、直列化可能な レベルの分離では同じシナリオで常に同じ結果が得られるとは保証できないが、更新前か更 新後いずれかの正確な数を得ることは可能である。

直列化可能なレベルのすぐ下の分離レベルが繰り返し可能な読み込みであり、ここでは幻 像が発生する可能性がある。 コレクションにいくつかの要素を追加したにも関わらず、 読み 込む側がその一部しか見えないときに、 幻像が発生している。 この例では、 Martin が locking パッケージを見たときファイル数は7である。 しかし Martin が multiphase バッ ケージを見るのは、 David が自分のトランザクションをコミットした後であり、このとき multiphase パッケージのファイル数は8になっている。 Martin は、 計 15 ファイルという 誤った答えを得ることになる。 幻像は、 Martin のトランザクション例のように一部だけが 有効でその他は無効な場合に発生するものであり、データを挿入した結果として発生する。

もう1つ下の分離レベルが繰り返し不可能な読み込みを発生させるコミットされた読み 込みである。 Martin は実際に個々のファイルを見ているわけではなく、 全体の数を見てい るとしよう。

繰り返し不可能な読み込みでは、 locking では7という数が読み込まれる。 David がトラ ンザクションをコミットすると、 multiphase では8という数が読み込まれる。 繰り返し不 可能な読み込みと呼ぶのは、 David がコミットした後に Martin が locking パッケージを再 度読み込めば、 新しいファイル数である9が得られるはずであり、 Martin が最初に読み 取った7という数は、 David の更新後には繰り返すことができないからだ。 データベース側

6

から見れば、幻像読み込みよりも繰り返し不可能な読み込みの方が検出しやすい。 そのた 繰り返し可能な読み込みはコミットされた読み込みレベルよりも精度は高くなるが、 即 は低くなる。

最も低い分離レベルは、 不確定な読み込みが生じるコミットされていない読み込みであ コミットされていない読み込みレベルでは、他のトランザクションが実際にはまだコミッ していないデータも読むことができる。 このことは、2種類のエラーの原因となり得 Martin が locking パッケージを見たとき、 David は最初のファイルを追加したが、 2つ のファイルはまだ追加していなかったとしよう。 この場合 Martin は、 locking パッケー 内に8つのファイルを見ることになる。これが1つ目のエラーだ。2つ目のエラーは、も David がファイルを追加した後にトランザクションをロールバックしたときに生じる。こ 場合 Martin は、存在していないファイルを見たことになってしまう。

5.1は、各分離レベルで発生する読み込みエラーを示している。

精度を確保したい場合は、 常に直列化可能な分離レベルを使用するべきである。 直列化 能なレベルの短所は、システムの即応性が著しく低下してしまうことにある。 場合によっ は、スループットを高めるために直列化機能を低下させる必要もある。 どのようなリスク 取るか、またエラー排除とパフォーマンス向上のどちらを優先するかはすべて開発者の判断 次第である。

すべてのトランザクションで同じ分離レベルを使う必要はないため、 即応性と正確性の ランスを維持するためにどのレベルを設定するかは個々のトランザクションごとに判断す 必要がある。

表 5.1 分離レベルと各レベルで生じる一貫性のない読み込みエラー

分離レベル 不確定な読み込み コミットされていない読み込み 発生する コミットされた読み込み 繰り返し可能な読み込み 繰り返し不可能な読み込み 発生する 幻像読み込み 発生する 発生しない 発生する 発生しない 発生しない 発生する 発生する 直列化可能な読み込み 発生しない 発生しない 発生しない

5.5.4 | ビジネストランザクションとシステムトランザクション

ここまで説明してきた内容の大部分は他の人も説明していることだが、 システムトランザ クションと呼ばれているもの、 つまり RDBMS システムとトランザクションモニタによって てサポートされているトランザクションについてである。 データベーストランザクションと は、開始と終了の命令によって区切られている一連のSQL コマンドグループである。 トラ ンザクション内の4番目のステートメントが整合性の制約に違反している場合、 データベー スはその前の3つのステートメントで実行した内容をロールバックし、 呼び出し元にトラン

バー サクション用能な すると ただし 泡のシプラパトランザクションを総合しにビジネストラン

ションをサポートしているとは言えない。 ビジネスアプリケーションは、システムト クションとビジネストランザクションの間を結合する別の何かを提供しなければなら

原子性と耐久性は、ビジネストランザクションでも最も簡単にサポートできる AC ロバティだ。 これらは、ユーザが 「保存」を選択したときにシステムトランザクション ビジネストランザクションのコミットフェーズを実行することでサポートできる。 セッ ンが加えられたすべての変更をレコードセットにコミットする前に、まずシステムトラ クションがオープンになる。 システムトランザクションによって、変更が1つのユニッ してコミットされ永続的なものになることが保証される。 唯一扱いにくい部分は、ビジ トランザクションが存続している間は、正確な変更セットを維持するという点である。 リケーションがドメインモデルを使用している場合は、 ユニットオブワークによって 正確に記録できる。 トランザクションスクリプト内にビジネスロジックを配置するには 動で変更を記録する必要があるが、トランザクションスクリプトを使用するということ自 そのビジネストランザクションが比較的シンプルなものであることを意味しているので れが問題になる可能性は少ない。

ビジネストランザクションで使用するときに扱いにくい ACID プロパティが、 分離 分離性が確保されていないと、一貫性が失われてしまう。 一貫性チェックでは、ビジネ ランザクションがレコードセットを無効な状態のままにしないように指示する。 1つの ンザクション内で一貫性を維持するためにアプリケーションに課せられる責任は、使用 るすべてのビジネスルールを適用するということである。 複数のトランザクションにお アプリケーションの責任は、1つのセッションが、レコードセットをユーザの作業が失 るような無効な状態のままにして、別のセッションが読み込み中のデータを変更しない。 にすることである。

更新を無効にしてしまうというわかりやすい問題だけでなく、 一貫性のない読み込み するわかりにくい問題も潜んでいる。 データが複数のシステムトランザクションで読み れている場合、その一貫性は保証されなくなり、 異なる読み込みにより一貫性を失ってし い程度によってはメモリ内のデータがアプリケーションエラーを引き起こしてしまうこ にもつながりかねない。

ビジネストランザクションは、セッションととても密接な関係にある。 ユーザから見れば 各セッションはビジネストランザクションが連なったものとなりデータを単に読み込ん いるだけの場合を除く)、 このことから、 すべてのビジネストランザクションはシングル ライアントセッション内で実行されるということを前提にしている。1つのビジネストラ ザクションに対して複数のセッションを持つようなシステムを設計することはできるが、 乱を招くのでするべきではないだろう。

ザクションが失敗したことを通知する。4つすべてのステートメントが問題なく完了した場 合は、1つずつではなくすべてが同時にその他のユーザから見えるようになる。 RDBMS シ ステムとアプリケーションサーバトランザクションマネージャーは、もはや一般的であり、 当然のものと考えられている。これらはとても有効であるため、アプリケーション開発者は これらを熟知している。

だがシステムトランザクションは、ビジネスシステムを使うユーザにとっては意味のない ものである。たとえば、オンラインバンキングにおけるユーザのトランザクションは、ログ イン、口座の選択、 支払いの設定、 そして最後に確定して支払うというステップから構成さ れている。 このステップはビジネストランザクションと呼ばれ、 システムトランザクション で必要とされたのと同様に、ビジネストランザクションでも ACID プロパティが必要にな る。 ユーザが支払いをする前にキャンセルした場合、 その前の画面で行った変更はすべて キャンセルされるべきであり、 支払いの指定をしただけで残高が見えるべきではなく、あく までもOK ボタンを押して実際に支払われた後でだけ見えるようにすべきである。

ビジネストランザクションのACID プロパティをサポートするには、ビジネストランザ クション全体を1つのシステムトランザクション内で実行させるというのが最も明解な解答 である。しかし、状況によっては、複数のリクエストが完了しないと処理できないビジネス トランザクションもあり、 この場合、ロングシステムトランザクション内で1つの結果を実 装するために、1つのシステムトランザクションを使用する。 ほとんどのトランザクション システムでは、ロングトランザクションは効率的に動作しない。

これは、決してロングトランザクションを使うべきではないと言っているわけではない。 データベースで並行性の必要性がそれほど求められていない場合は、使用することが可能で ある。 むしろ、このようなケースでは使用することを勧める。 ロングトランザクションを使 用すると、多くの面倒な問題を回避できる。 ただし、 ロングトランザクションではデータ ベースがボトルネックとなるため、アプリケーションは拡張性のあるものにはならない。さ らに、ロングトランザクションからショートトランザクションへのリファクタリングは、複 雑であり十分理解されていない部分でもある。

このような理由から、多くのエンタープライズアプリケーションではロングトランザク ションの危険を冒すことができない傾向がある。 この場合、ビジネストランザクションを一 連のショートトランザクションに分割する。 つまり、 システムトランザクション間でのビジ ネストランザクションのACID プロパティに対応するため、独自のデバイスを使用する必 要がある。 このような状態をオフライン並行性と呼んでいるが、この構成でもシステムトラ ンザクションは数多く存在している。 ビジネストランザクションがデータベースなどのトラ ンザクション可能なリソースと相互作用するときは必ず、 相互作用がシステムトランザク ション内で順番どおりに実行され、リソースの整合性を維持している。 ただし後に解説する ように、 一連のシステムトランザクションを結合しただけでは、適切にビジネストランザク

ションをサポートしているとは言えない。 ビジネスアプリケーションは、システムトラ クションとビジネストランザクションの間を結合する別の何かを提供しなければならな

原子性と耐久性は、ビジネストランザクションでも最も簡単にサポートできる ACI ロパティだ。 これらは、ユーザが 「保存」を選択したときにシステムトランザクション ビジネストランザクションのコミットフェーズを実行することでサポートできる。 セッ ンが加えられたすべての変更をレコードセットにコミットする前に、まずシステムトラ クションがオープンになる。 システムトランザクションによって、変更が1つのユニッ してコミットされ永続的なものになることが保証される。 唯一扱いにくい部分は、ビジ トランザクションが存続している間は、正確な変更セットを維持するという点である。 リケーションがドメインモデルを使用している場合は、ユニットオブワークによって変 正確に記録できる。 トランザクションスクリプト内にビジネスロジックを配置するには、 動で変更を記録する必要があるが、 トランザクションスクリプトを使用するということ自 そのビジネストランザクションが比較的シンプルなものであることを意味しているので、 れが問題になる可能性は少ない。

ビジネストランザクションで使用するときに扱いにくい ACID プロパティが、 分離性 分離性が確保されていないと、一貫性が失われてしまう。 一貫性チェックでは、 ビジネス ランザクションがレコードセットを無効な状態のままにしないように指示する。 1つのト ンザクション内で一貫性を維持するためにアプリケーションに課せられる責任は、 使用で るすべてのビジネスルールを適用するということである。 複数のトランザクションにおけ アプリケーションの責任は、1つのセッションが、レコードセットをユーザの作業が失わ るような無効な状態のままにして、別のセッションが読み込み中のデータを変更しないよ にすることである。

更新を無効にしてしまうというわかりやすい問題だけでなく、一貫性のない読み込みに するわかりにくい問題も潜んでいる。 データが複数のシステムトランザクションで読み込 れている場合、その一貫性は保証されなくなり、異なる読み込みにより一貫性を失ってし い、程度によってはメモリ内のデータがアプリケーションエラーを引き起こしてしまうこ にもつながりかねない。

ビジネストランザクションは、セッションととても密接な関係にある。 ユーザから見れば、 各セッションはビジネストランザクションが連なったものとなり (データを単に読み込ん いるだけの場合を除く)、 このことから、すべてのビジネストランザクションはシングル ライアントセッション内で実行されるということを前提にしている。 1つのビジネストラン ザクションに対して複数のセッションを持つようなシステムを設計することはできるが、 乱を招くのでするべきではないだろう。

5.6 オフライン並行性制御のためのパターン

並行性の問題は、可能な限りトランザクションシステムに対処させるべきである。 システ ムトランザクションまで含めた並行性制御を扱うのは、並行性を自分で処理しなければなら ないので、 泥水の中に突き落とされるようなものだ。 その泥水の中には、仮想のサメや仮想 の毒クラゲ、 仮想のピラニアなど、 あまり近付きたくない生き物がいっぱい生息していて嫌 な環境だ。

残念なことに、 ビジネストランザクションとシステムトランザクションの不一致によって、 その泥水の中を歩いていかなければならない状況に追い込まれることもある。 ここで解説す るパターンは、システムトランザクションを含む並行性制御に有効と思われるいくつかの技 法を盛り込んでいる。

これらの技法は、あくまでも必要な場合に限り使うべきだということを覚えておいてほし い。 すべてのビジネストランザクションを1つのリクエスト内に含めることができ、かつシ ステムトランザクションに一致する場合は、 そうするべきである。 拡張性を気にせずロング トランザクションを使いたいのであれば、なおさら使うべきである。 並行性制御をトランザ クションソフトウェアに任せれば、多くの問題を回避することができる。 これらの技法は、 回避ができないときに限り使うべきものである。 並行性が抱える複雑さを踏まえた上でもう 一度念を押しておくが、これらのパターンはあくまでも出発点であり、決してゴールではな い。 間違いなく有効なものである一方で、並行性のすべての病を完治させることはできない のである。

最初にオフライン並行性問題に対応するものとして選んだのは、 軽オフラインロックだ。 基本的に、軽い並行性制御をビジネストランザクション全体で使用するというものである。 これを最初に選んだのは、プログラムの手法としては簡単で、最適な即応性を提供してくれ るからだ。 軽オフラインロックの限界は、ビジネストランザクションが失敗しそうだという ことが、コミットしようとした段階で初めてわかるという点だろう。 状況によっては、この 遅れが許し難いものになる場合もある。 たとえば、ユーザが何時間もかけてリースに関する 詳細を入力したにも関わらず、 多くの障害があったのでは、ユーザのシステムに対する信頼 は失われるだろう。 代替案としては重オフラインロックがある。 このパターンでは、トラブ ルは早い段階で知ることができるが、 プログラミングが大変なだけでなく即応性も低下する ので、あまり勧められない。

いずれの手法でも、すべてのオブジェクトのロックを管理する必要がないため、 複雑性は 大幅に軽減されることになる。 緩ロックでは、オブジェクトグループの並行性をまとめて管 理することができる。 アプリケーション開発者の作業を楽にできるという意味では、 ロック を直接管理しなくても済む暗黙ロックを使用するという方法もある。 これは単に作業を軽減 させるだけでなく、うっかり忘れるという人的なバグも回避することができる (これらのバ

第5章 並行性

グは見つけるのが大変である)。

並行性についてよく言われるのは、 要件がすべて揃った時点で、 純粋に技術的観点から 定するというものであるが、 私はこれに賛同しかねる。 軽い手法か重い手法のどちらで するかは、システム全体におけるユーザ体験に影響してくる。 重オフラインロックによ ンテリジェントな設計では、システムのユーザのドメインについて膨大な量の入力が必 なるし、 しかも優れたロックにするには、 ドメインに関する知識が必要となる。

並行性の扱いは、プログラミングタスクの中でも最も難しいとされているものの1つ 確信をもって並行性コードをテストするのは大変困難な作業となる。 並行性のバグは再 るのが難しく、とても追跡しにくい。 ここで解説しているパターンは現時点では問題なく 作しているが、この分野は特に難しい分野だと言える。

この道を通る必要がある場合は、できる限り経験者のサポートを得られるようにする である。 最低限、 本章の最後で紹介している書籍は読んでおくべきだろう。

5.7 アプリケーションサーバの並行性

ここまでは、 主に共有データに対する複数セッションでの並行性について話してきた。 もう1つ別の形態の並行性もある。 アプリケーションサーバにおけるプロセスの並行性が サーバはどのようにして複数のリクエストを同時に処理し、 またサーバ上のアプリケーシ ン設計にどのように影響するのだろうか。 ここまで説明してきた並行性と大きく異なるのは アプリケーションサーバにおける並行性ではトランザクションが絡んでいないことだ。 つ り、これらを考えるときトランザクションの制御は切り離すことができる。

ロックと同期ブロックを伴う明示的なマルチスレッドプログラミングは、とても複雑な のとなる。 簡単には見つからない欠陥が突然出てくることがあるため (並行性のバグはほ んど再現不可能なものである)、 99%正常に動作しているシステムでも、突発的に不具合 生じる可能性があることになる。 ソフトウェアの使用やデバッグはとてつもないストレス 伴うので、 私は同期やロックを明示的に処理する必要性を可能な限り避けることにしている アプリケーション開発者はこれらの明示的な並行性メカニズムと対峙するような状況に陥 べきではない。

最も簡単にこれを処理する方法は、1つのセッションに1つのプロセスの手法だ。 この場 合、各セッションは、それぞれ独自のプロセス内で実行されることになる。この手法の最 のメリットは、各プロセスの状態が完全に分離されていることにある。 つまり、アプリケー ション開発者は、 マルチスレッド処理について心配する必要は一切ない。 メモリの分離とい う点でも、各リクエストが新しいプロセスを開始する、 またはリクエスト間に1つのプロセ スが待機中の1つのセッションと結び付いているのはとても効率的であると言える。 初期の

Webシステムの多くでは、各リクエストに対して新たな Perl プロセスが開始されていた。

この1つのセッションに対して1つのプロセスという手法の問題点は、プロセスがいわば 浪費家として例えられ多くのリソースを使うという点にある。 より効率的にしたければ、 そ れぞれのプロセスが同時に処理するリクエストを1つに限定しながら、別のセッションから の複数のリクエストを順次処理できるように、プロセスをプールさせることである。1つの リクエストに1つのプロセスをプールする手法では、より少ないプロセスで所定のセッショ ン数をサポートできる。 分離性の点でもほとんど問題がない。 理由は、 厄介なマルチスレッ ドに対処する必要があまりないからである。 1つのセッションに1つのプロセスの手法でリ クエストを処理する場合の最大の問題点は、リクエストを処理するために使用したリソース を、リクエストが終了した時点で解放しなくてはならないという点である。 現行のApache mod-perl ではこの仕組みが使用され、 多くの大規模かつ重要なトランザクション処理シス テムでも使われている。

1つのリクエストに1つのプロセスの手法でも、一定の負荷に対処するためには多くのプ ロセスを必要とする。 1つのプロセスで複数のスレッドを実行するようにすれば、スルー プットをさらに向上させることができる。 1つのリクエストに1つのスレッドの手法では、 各リクエストは、1つのプロセス内の1つのスレッドで処理されることになる。 スレッドが 使用するサーバリソースはプロセスよりもはるかに少ないため、少ないハードウェアリソー スでより多くのリクエストを扱うことができ、 サーバもより効率的になる。 一方1つのリク エストに1つのスレッドの手法の問題点は、 スレッド間に分離性がないため、どのデータに も任意のスレッドからアクセスできてしまうという点である。

私の見解では、1つのリクエストに1つのプロセスの手法について説明したいことがたく さんある。 1つのリクエストに1つのスレッドの手法と比べれば、効率という点では劣るが、 拡張性という点では同程度である。 強固性も向上する。 つまり1つのスレッドが壊れるとプ ロセス全体がダウンするため、1つのリクエストに1つのプロセスの手法では、壊れたス レッドの影響を制限することができる。 特に、経験の浅いチームでは、スレッド処理での頭 痛の種 (バグ修正に要する時間とコストも含む) を減らせれば、ハードウェアのコストが多 アップすることよりも有効であるだろう。 1つのリクエストに対して1つのスレッドと、 1つのリクエストに対して1つのプロセスの相対コストを算出するため、 開発中のアプリ ケーションのパフォーマンステストを行っているという例は、ごくわずかしかない。

環境によっては、1つのスレッドに割り当てられるデータを分離する場所を中間に設定し ている場合もある。 COMでは、シングルスレッドアパートメント (STA: singlethreaded apartment) によってこのような設定を行っている。 J2EE も Enterprise Jave Beans も同様である (将来的には分離する可能性がある)。 使用しているプラットフォーム で似たような設定を行うことができる場合は、(これが何を意味しているかはさておいて) 一挙両得である。

1つのリクエストに対して1つのスレッドの手法を使用する場合に最も重要なことは プリケーション開発者がマルチスレッドを気にしなくて済む場所に、分離された領域を し、そこで処理を行うことである。 一般的な方法としては、スレッドがリクエストの処 開始する際に、新たなオブジェクトを作成するようにし、 オブジェクトが他のスレッド 見える場所 (たとえば静的変数内など) に置かれないようにするという方法がある。 こ よって他のスレッドから参照できなくなるため、 オブジェクトは分離されることになる。

開発者の多くは、 新しいオブジェクトを作成することにあまり積極的ではない。 オブ クトの作成が、プロセスに負荷をかけるという定説が頭にあるからだ。 結果、 彼らは ジェクトをプールする手法を使用することが多い。 このブールの手法の問題点は、プー れているオブジェクトへのアクセスを何らかの方法で同期させなくてはならない点であ 一方で、 オブジェクトの作成に要するコストは、 仮想マシンとメモリ管理ストラテジー きく依存するものである。 最近の環境では、 オブジェクトの作成はとても速く行えるよ なっている [Peckish] (たとえば、 Martin の600MhzP3とJava 1.3で1秒間にいく Java Date オブジェクトを作成できるか想像してみてほしい)。 新しいオブジェクトを ションごとに作成すれば、並行性関連の多くのバグを回避できると同時に拡張性も向上する

この戦術は多くのケースで利用できるが、 開発者が避けなくてはならない領域は他に る。1つは静的クラスベースの変数、 またはグローバル変数だ。 これらを使用するために 同期が必要となるからである。 これは、シングルトンの場合でも当てはまる。

ある種のグローバルメモリが必要な場合は、レジストリの使用を勧める。このパターン は、静的変数に見えるものでも、実際にはスレッド特化のストレージを使用するように実 できる。

セッションのためのオブジェクトを作成でき、比較的安全なゾーンを作ることができた しても、オブジェクトによっては作成の負担が大きくなり、別の方法で処理しなくてはな ないものもある (最も一般的なものとしては、データベース接続がこれに相当する)。こ 場合、 オブジェクトを明示的プール内に置き、 接続が必要なときに取得し、 終了したら返 ようにするとよい。 その場合、 これらの動作は同期している必要がある。

5.8

| 参考文献

本章で解説している内容は本来とても複雑なものであり、ここでは表面に触れたに過ぎ い。 さらに深く掘り下げたい場合は、 [Bernstein and Newcomer)、 [Lea)、 [Schmidt al] などから始めることを勧める。



セッション

並行性についての説明で、ビジネストランザクションとシステムトランザクションの についても触れた (第5章、 P77)。 この違いは並行性だけでなく、ビジネストランザ ション内部で使用されたが汎用データベースレコードにコミットする前のデータをどう格 するかにも影響してくることになる。

ビジネストランザクションとシステムトランザクションのそもそもの違いは、ステート スセッション対ステートフルセッションの違いにある。 この件に関しては多くの人が説明 ているが、 私の見解では、基本的な問題はステートレスとステートフルサーバシステムの 術的な問題の中に見え隠れする程度である。 まず考える必要があるのは、いくつかのセ ションの中には本質的にステートレスなものがあること、さらに状態をどう扱うかを決定 るということである。

6.1 | ステートレス性の価値

ステートレスサーバとは何を意味しているのだろうか。 オブジェクトであることの意義 もちろん、それらが状態(データ)と振る舞いを組み合わせたものであるという点にある 本来ステートレスオブジェクトとは、フィールドを持たないオブジェクトのことを指す。 のようなオブジェクトは実在し、 時折見受けることもあるが、 お目にかかることはあまり い。 私の見解では、ステートレスオブジェクトは悪しき設計と言ってもいいだろう。

しかし、 分散エンタープライズアプリケーションにおけるステートレスについて述べる場 合、一般的に言われているステートレスサーバとはリクエスト間に状態を保持していないオ ブジェクトのことであるが、このようなオブジェクトはフィールドを持っていることもある。 ただし、ステートレスサーバ上のメソッドを呼び出しても、フィールドの値は定義されて ない。

たとえば、 書籍に関する情報を含む Web ページを返すオブジェクトなどは、ステートレ

スサーバオブジェクトであると言えるだろう。 最初に URL にアクセスして呼び出すが、こ こでのオブジェクトはASP ドキュメントやサーブレットの可能性がある。 このとき、サー バは URL内に提示したISBN 番号を使ってHTTPレスポンスを生成することになる。 相 作業の場合には、サーバオブジェクトはHTMLを生成する前に、 書籍の ISBN Title (タイトル) Price (価格) などの情報をデータベースから取得した時点でフィールドに一 時保管する場合もあり、またはユーザに表示するレビューについてのビジネスロジックを動 作させる場合もある。 ただし、 HTML が生成されると、これらの値は意味のないものにな り、次の ISBN はまったく別のものとなる。 サーバオブジェクトは、誤りを避けるために再 び初期化して古い値を消去することになる。

仮に、 特定のクライアントIPアドレスがアクセスしたすべての ISBN を記録しておく場 合を考えてみよう。 サーバオブジェクトが保持するリスト内にこれらの ISBN を記録するが、 リストはリクエストの間も保持されていなければならないので、サーバオブジェクトはス テートフルなものになる。 ステートレスからステートフルへのシフトは、 「レス」 と 「フル」 という文言を変えればいいというような簡単なものではない。 多くの人にとって、 ステート フルサーバは頭痛の種以外何ものでもない。 なぜだろうか。

最大の問題はサーバのリソースである。 ステートフルサーバオブジェクトは、ユーザが Webページを閲覧している間、 すべての状態を維持しておく必要があるのに対して、ス テートレスサーバオブジェクトは、他のセッションからの別のリクエストも処理することが できる。 以下の例はあり得ないことかもしれないが、概要を理解するには役立つ例である。 書籍について調べたいユーザが100人いて、 1冊の書籍に対するリクエストの処理時間には 1秒だった場合を考えてみる。 各ユーザは10秒ごとにリクエストを出し、 すべてのリクエ ストが完全に同じように動作する。 ステートフルサーバオブジェクトでユーザのリクエスト を追跡するには、ユーザ1人あたり1つのサーバオブジェクトが必要となる。 つまり 100 個のオブジェクトが必要になるわけだ。しかし、これらのオブジェクトは、 全体の9割の時 間帯は何の動作も行わず待機しているだけである。 一方、 ISBN を追跡せずにステートレス サーバオブジェクトを使用すると、 10個のオブジェクトがフル稼働しつづけるのである。

つまり、メソッド呼び出しの間に状態がなければ、どのオブジェクトがリクエストに応じ るかは関係なくなるが、状態を格納する場合は、 常に同じオブジェクトを使う必要がある。 ステートレスの場合はオブジェクトをプールできるので、より少ないオブジェクトでより多 くのユーザに対応できる。 待機中のユーザが多ければ多いほど、ステートレスサーバの利用 価値は高くなる。このことから、 ステートレスサーバがトラフィックの多い Web サイトで は有効だということが容易に想像できる。 ステートレスは、 HTTP がステートレスプロト コルであることからも Web には十分適している

では、すべてをステートレスにするべきなのだろうか。 可能な場合はそうするべきだ。 問 題は、クライアントとの相互作用の多くが本質的にステートフルであるという点にある。 た

とえば、何千というeコマースアプリケーションで使われているショッピングカートシ ムを見てみよう。 ユーザの相互作用には、複数の書籍を閲覧し、 その中から実際に購入 商品を選択することが含まれる。 ショッピングカートの内容は、ユーザのセッションが するまで保持されている必要がある。 つまりステートフルなビジネストランザクションに るので、 セッションもステートフルなものになることを意味している。 単に書籍を閲覧す だけで何も購入しない場合はステートレスだが、 購入する場合はステートフルになる。 りこの例では、本を買う金がある限り、 状態を避けることはできない。 そこでその対処 考えてみると、実はステートレスサーバでステートフルセッションを使用するという素晴 しい方法もあるが、 この興味深い方法を取り入れるべきかどうかには疑問が残る。

6.2 | セッションステート

ショッピングカートの中身はセッションステートになっている。 つまり、カート内のデ タは特定のセッションだけに関連したものになっている。 状態はビジネストランザクショ 内にあるため、 他のセッションとビジネストランザクションとは分離されている (さらに うと、各ビジネストランザクションは1つのセッション内でだけ実行され、各セッション 同時に1つのビジネストランザクションしか処理しないということが前提である)。 セ ションステートと、私がレコードデータと呼んでいるものは同じものではない。 レコー データは、データベースに長期間保持されるデータのことで、 すべてのセッションから見 ている。セッションステートがレコードデータとなるには、 コミットされる必要がある。

セッションステートはビジネストランザクション内にあるので、 トランザクションで一 的に考えられている ACID (原子性、 一貫性、 分離性、耐久性) などのプロパティの多く 持っていることにもなるが、現状ではこの因果関係が必ずしも理解されているとは言えない。

興味深い関連性として一貫性への影響を挙げることができる。 顧客が保険ポリシーを編集 しているとき、 ポリシーの現行の状態が顧客によっては規定に合わない可能性もある。 顧 が値を変更すると、 それがリクエストとしてシステムに送られ、 システムは無効値であると 応答する。 これらの値はセッションステートの一部となるわけだが、 有効な値とはならない。 セッションステートではこのような状況が生じる場合が多く、処理中は妥当性確認ルールと 合致せず、ビジネストランザクションがコミットされた場合にだけ合致するのである。

セッションステートで最も懸念される問題が、 分離性の処理である。 多くの人が関わって いるので、顧客がポリシーを編集している間は何が起こってもおかしくない。 最も分かりや すい例を挙げると、2人が同時にポリシーを編集している場合である。 ここでの問題は、直 接変更するということだけではない。 たとえば、ポリシーそのものと Customer (顧客) レ コードという2つのレコードがあるとすると、ポリシーには、 Customer (顧客) レコード

Zip Code (郵便番号) に依存するリスク値がある。 顧客がポリシーの編集を開始して10 分後に何らかの操作でCustomer (顧客) レコードをオープンし、 Zip Code (郵便番号)が 見える状態になったとする。 そこでその10分の間に他の誰かが Zip Code (郵便番号) とり スク値を変更したとしたら、 一貫性のない読み込みが起こることとなる。 このような場合の 対処法については、第5章を参照してほしい。

セッションで保持されているすべてのデータが、 セッションステートとしてカウントされ るわけではない。 セッションは、 実際にはリクエスト間には必要のないデータも、 パフォー マンスを向上させるためにキャッシュして格納していることもある。 キャッシュは振る舞い に影響を与えずに削除できるので、 適切な振る舞いのためにリクエスト間に格納される必要 があるセッションステートとは異なるものである。

621 | セッションステートを格納する方法

格納する必要があるとわかったセッションステートは、どのように格納すればいいのだろ うか。考えられる選択肢を、基本的な3つに分けてみよう。

クライアントセッションステートでは、データをクライアント上に格納する。 これを行う 方法はいくつかある。 つまり、 Web プレゼンテーションのためにデータをURLにエンコー ドするクッキーを使用する、 Web フォームのいくつかの隠しフィールドにデータを直列化 する、リッチクライアント上のオブジェクト内にデータを保持するなどである。

サーバセッションステートは、リクエストの間にメモリにデータを保持させるというシン プルな方法である。 ただし、直列化されたオブジェクトのようなより耐久性の優れた場所に、 セッションステートを格納するメカニズムを保持している。 オブジェクトは、アプリケー ションサーバのローカルファイルシステムに格納したり、共有データソース内に配置したり することもできるが、 その場所は、 キーとしてセッションIDを持つシンプルなデータベー ステーブルや、 直列化されたオブジェクトが値になるデータベーステーブルになる可能性が ある。

データベースセッションステートもサーバサイドストレージだが、ここでは、データを テーブルとフィールドに分割し、より永続性の優れたデータを格納する方法を取り上げて説 明する。

どの選択肢を使うかを決めるにあたっては、考慮すべき点がいくつかある。 まず、 クライ アントとサーバ間で必要なバンド幅について考える。 クライアントセッションステートでは、 すべてのリクエストによってセッションデータが回線を通じて転送される必要があるが、 フィールドが数個しかない場合は問題にならないとしても、データ量が多くなれば転送量も 多くなる。 あるアプリケーションではデータ量は1メガバイト程度かもしれないし、私たち のチームのようにシェークスピアの戯曲3作にも匹敵する量になることもある。 私たちは転

8 8

送に XML を使用していて、 決して最適なデータ伝送形式であるとは言えないが、それ 大量のデータを処理できる。

もちろん、プレゼンテーションで見せなければならないデータを転送する場合もある クライアントセッションステートでは、すべてのリクエストにおいて、たとえクライア 側で表示する必要がなくても、 サーバが使用するデータはすべて転送されなくてはならな つまり、格納する必要があるセッションステートの量が極端に少なくない限りは、 クラー ントセッションステートを使うべきではない。 その上セキュリティと整合性にも注意す 要がある。 データを暗号化していない限り、悪意のあるユーザがセッションデータを改 する可能性もある。

セッションデータは分離される必要がある。 ほとんどの場合、 あるセッションで行わ いることが別のセッションの実行に影響を与えてはいけないからである。たとえば、飛 の予約を入れたとしても、それが確定されるまでは他のユーザに影響を及ぼすべきではない セッションデータであることの意味には、 セッション外からは一切見えないということも るが、これはデータベースセッションステートを使用するときは厄介なものになる。 その 由は、セッションデータをデータベース内に存在するレコードデータから分離しなくては けないからである。

ユーザの数が多いときは、クラスタ化してスループットを向上させることも考慮すべき あり、セッションを移行させる必要があるかどうかも考えた方がよいだろう。 セッション 行によってセッションをサーバからサーバへと移行することができ、1つのサーバで1つ リクエストを、別のサーバで別のリクエストを処理できるようにする。 これの反対に位置 るのが、 特定のセッションのためのすべてのリクエストを1つのサーバで処理するサーバ フィニティだ。 サーバ移行は、サーバ間のバランスも保つことができ、 特にセッションが い場合は有効であるが、サーバセッションステートを使用する場合は少し厄介なものになる 理由は、セッションを処理するマシンだけが状態を容易に見つけられることが多いからで る。これを解決する方法として、データベースセッションステートとサーバセッション テートの中間に位置させる方法がある。

サーバアフィニティは一見すると気付かないかもしれないが、これは大きな問題になる 能性もある。 サーバアフィニティを保証しようとすると、クラスタリングシステムは、呼 出しがどのセッションの一部なのかをまったく検査できなくなる。 そのため、アフィニテ が強くなり、1つのクライアントからのすべての呼び出しが同じアプリケーションサーバ 送信される。 これはクライアントのIPアドレスで判断される場合が多いが、クライアン がプロキシーを介していると、 複数のクライアントが同じIPアドレスを使っていることに なり、すべて特定のサーバに集中してしまうことになる。この状況は、1つのサーバで処理 するほとんどのトラフィックがAOL (アメリカオンライン) で使用するIPアドレスをまと めたものだった場合などは、もっと深刻な問題となるだろう。

の Zip Code (郵便番号) に依存するリスク値がある。 顧客がポリシーの編集を開始して10 分後に何らかの操作でCustomer (顧客) レコードをオープンし、 Zip Code (郵便番号)が 見える状態になったとする。 そこでその10分の間に他の誰かがZip Code (郵便番号) とり スク値を変更したとしたら、一貫性のない読み込みが起こることとなる。 このような場合の 対処法については、第5章を参照してほしい。

セッションで保持されているすべてのデータが、セッションステートとしてカウントされ るわけではない。セッションは、実際にはリクエスト間には必要のないデータも、パフォー マンスを向上させるためにキャッシュして格納していることもある。 キャッシュは振る舞い に影響を与えずに削除できるので、 適切な振る舞いのためにリクエスト間に格納される必要 があるセッションステートとは異なるものである。

621 セッションステートを格納する方法

格納する必要があるとわかったセッションステートは、 どのように格納すればいいのだろ うか。考えられる選択肢を、基本的な3つに分けてみよう。

クライアントセッションステートでは、データをクライアント上に格納する。 これを行う 方法はいくつかある。つまり、Web プレゼンテーションのためにデータをURLにエンコー ドするクッキーを使用する、 Web フォームのいくつかの隠しフィールドにデータを直列化 する、リッチクライアント上のオブジェクト内にデータを保持するなどである。

サーバセッションステートは、リクエストの間にメモリにデータを保持させるというシン プルな方法である。ただし、直列化されたオブジェクトのようなより耐久性の優れた場所に、 セッションステートを格納するメカニズムを保持している。 オブジェクトは、アプリケー ションサーバのローカルファイルシステムに格納したり、共有データソース内に配置したり することもできるが、 その場所は、キーとしてセッションIDを持つシンプルなデータベー ステーブルや、 直列化されたオブジェクトが値になるデータベーステーブルになる可能性が ある。

データベースセッションステートもサーバサイドストレージだが、ここでは、データを テーブルとフィールドに分割し、より永続性の優れたデータを格納する方法を取り上げて説 明する。

どの選択肢を使うかを決めるにあたっては、考慮すべき点がいくつかある。 まず、 クライ アントとサーバ間で必要なバンド幅について考える。 クライアントセッションステートでは、 すべてのリクエストによってセッションデータが回線を通じて転送される必要があるが、 フィールドが数個しかない場合は問題にならないとしても、データ量が多くなれば転送量も 多くなる。 あるアプリケーションではデータ量は1メガバイト程度かもしれないし、 私たち のチームのようにシェークスピアの戯曲3作にも匹敵する量になることもある。私たちは転

ションステート

第6章

送に XML を使用していて、 決して最適なデータ伝送形式であるとは言えないが、それ 大量のデータを処理できる。

もちろん、プレゼンテーションで見せなければならないデータを転送する場合もある クライアントセッションステートでは、すべてのリクエストにおいて、 たとえクライア 側で表示する必要がなくても、 サーバが使用するデータはすべて転送されなくてはならな つまり、 格納する必要があるセッションステートの量が極端に少なくない限りは、 クラ ントセッションステートを使うべきではない。 その上セキュリティと整合性にも注意す 要がある。 データを暗号化していない限り、悪意のあるユーザがセッションデータを改 する可能性もある。

セッションデータは分離される必要がある。 ほとんどの場合、 あるセッションで行わ いることが別のセッションの実行に影響を与えてはいけないからである。 たとえば、飛 の予約を入れたとしても、それが確定されるまでは他のユーザに影響を及ぼすべきではない セッションデータであることの意味には、セッション外からは一切見えないということ るが、これはデータベースセッションステートを使用するときは厄介なものになる。 その 由は、セッションデータをデータベース内に存在するレコードデータから分離しなくては けないからである。

ユーザの数が多いときは、 クラスタ化してスループットを向上させることも考慮すべき あり、セッションを移行させる必要があるかどうかも考えた方がよいだろう。 セッション 行によってセッションをサーバからサーバへと移行することができ、 1つのサーバで1つ リクエストを、別のサーバで別のリクエストを処理できるようにする。 これの反対に位置 るのが、特定のセッションのためのすべてのリクエストを1つのサーバで処理するサーバ フィニティだ。サーバ移行は、サーバ間のバランスも保つことができ、 特にセッションが い場合は有効であるが、サーバセッションステートを使用する場合は少し厄介なものになる 理由は、セッションを処理するマシンだけが状態を容易に見つけられることが多いからで る。これを解決する方法として、 データベースセッションステートとサーバセッション テートの中間に位置させる方法がある。

サーバアフィニティは一見すると気付かないかもしれないが、これは大きな問題になる 能性もある。 サーバアフィニティを保証しようとすると、 クラスタリングシステムは、呼び 出しがどのセッションの一部なのかをまったく検査できなくなる。 そのため、アフィニティ が強くなり、1つのクライアントからのすべての呼び出しが同じアプリケーションサーバに 送信される。 これはクライアントのIPアドレスで判断される場合が多いが、クライアント がプロキシーを介していると、 複数のクライアントが同じIPアドレスを使っていることに なり、すべて特定のサーバに集中してしまうことになる。 この状況は、1つのサーバで処理 するほとんどのトラフィックがAOL (アメリカオンライン) で使用するIPアドレスをまと めたものだった場合などは、もっと深刻な問題となるだろう。

サーバでセッションステートを使う場合は、 すぐに使用できる形式である必要がある。 サーバセッションステートの場合、セッションステートはサーバが保持していてクライアン トセッションステートもサーバ内部にあるため、 希望する形式で配置しておく必要があるこ とが多い。 一方データベースセッションステートの場合、データベースまでアクセスし、取 得する必要がある (さらに何らかの変換が必要になる場合もある)。 つまり、 それぞれの手 法は、それぞれ異なる方式でシステムに応答する必要があるため、データのサイズや複雑さ もここでは影響してくることになる。

一般向け小売システムを運営している場合、各セッションは大量のデータを扱わないが、 多くの待機中のユーザを持つことになる。 そのため、パフォーマンスを考慮するとデータ ベースセッションステートが適切ということになる。 一方リースシステムでは、膨大な量の データをリクエストごとにデータベースへ挿入あるいはデータベースから抽出するという面 倒なリスクを抱えなければならないため、この場合はサーバセッションステートの方がより 良いパフォーマンスを実現できる。

多くのシステムにとって最大の悩みの種といえば、ユーザがセッションをキャンセルして 「なかったことにしてくれ」と言ったときの対処法である。 これは、 特にB2C アプリケー ションでは厄介な問題となる。その理由は、ユーザは 「なかったことにしてくれ」とも言わ ずにいなくなってしまい、そのまま帰ってこないからだ。 このケースで有効なのが、ユーザ を容易に忘れることができるクライアントセッションステートである。 別の手法では、 一定 の時間が経過した時点でキャンセルするようにシステムを設定して、 キャンセルされたと分 かった時点でセッションステートを破棄できるようにしておく必要がある。 適切に実装され たサーバセッションステートでは、 自動タイムアウトを使ってこの機能を実行できる。

ユーザがキャンセルしたときのことだけではなく、 システムが逆にキャンセルしなければ ならないような状態のときも考えておく必要がある。 つまり、 クライアントがクラッシュし たり、サーバがダウンしたり、ネットワーク接続が切断したりしてしまうような場合だ。 データベースセッションステートではこれら3つのケースに適切に対処することができる。 サーバセッションステートは、セッションオブジェクトが不揮発性のメディアに格納されて いるか、またはそのメディアがどこにあるかによって存続できるかどうかが決まる。 クライ アントセッションステートはクライアントがクラッシュした場合は存続できないが、 その他 の障害では存続できるようにしなければならない。

また、これらのパターンに必要な開発労力も忘れてはならない。 開発リソースから考える と最も簡単なのはサーバセッションステートである。 リクエストの間にセッションステート を保存する必要がない場合には、極めて容易である。 しかしデータベースセッションステー トとクライアントセッションステートでは、データベースから変換するコードやセッション オブジェクトが使用するフォームにフォーマットを転送するコードを含んでいるので、 これ らの対処の作業を必要とすることから、 サーバセッションステートのように容易には多くの

機能を構築することはできない。 特に、 データが複雑な場合はなおさらである。 一見すると、 すでにデータベーステーブルへのマッピングが済んでいる場合は、データベースセッション ステートは複雑なものに見えないかもしれないが、他の目的でのデータベースの使用をセッ ションデータから分離する場合には、 より以上の開発労力が必要となる。

これら3つの手法は、 相互に排他的なものではない。 2つまたは3つの手法を組み合わせ て、セッションステートの異なる部分を格納することもできる。 ただし、 通常はこのように 組み合わせることで作業はより複雑になっていく。 状態のどの部分が、 システムのどの部分 に送られるのかが確実にわかってはいないからである。 それでも、クライアントセッション ステート以外のパターンを使用する場合は、他の状態が別のパターンを使って保持されてい たとしても、少なくともクライアントセッションステート内のセッション識別子は保持して おくべきである。

私はサーバセッションステートを好んでいる。 サーバのクラッシュに耐えられるようにメ メントがリモートで格納されている場合などは特に好ましい。 また、 クライアントセッショ ンステートも、セッションIDとセッションデータが極度に少量の場合にも好んで使用する。 しかし、データベースセッションステートは、フェイルオーバーとクラスタリングが不要な 場合で、さらにリモートでメメントを格納できず、 セッション間の分離が重要視されていな い場合でなければ、 使用したいとは思わない。



分散ストラ

オブジェクトという概念が現れてしばらく経つが、 最初から開発者はオブジェクトを分間 したがっていたように思える。 ただし、 オブジェクトに限らず分散させるということには 多くの人が気付かない落とし穴が潜んでいる [Waldo et alļ。 特に、 ベンダーが配布する小 麗なパンフレットに頼るような場合には注意が必要である。 本章では、このいくつかの厳し い教訓について紹介する。 それは、 私の顧客の多くが苦労して身につけた教訓である。

7.1 分散オブジェクトの誘惑

デザインレビューの際に、 年に数回、繰り返し目にするプレゼンテーションがある。 新し いなんとかというシステムのシステム設計者が、 誇らしげに新しい分散オブジェクトシステ ムのプランを説明する。 ここでは仮に、ある種の受発注システムとしよう。 その設計図は、 図7-1 のようなものだ。 Cutomer (顧客)、 Order (注文)、 Product (製品)、 Delivery (配送) の各リモートオブジェクトがそれぞれ個別に用意されている。 各オブジェクトは個 別のコンポーネントになっていて、 各コンポーネントは個別の処理ノード上に配置してある。

「なぜこうなっているのですか」と質問してみると、その設計者は少しけげんそうな顔を して、「もちろん、パフォーマンスを考慮したからですよ」 と答える。 「各コンポーネントを 別々のボックスで実行できるので、 あるコンポーネントに処理が集中する場合は、 ボックス を追加することでアプリケーションへの負荷を分散できるのです。」 この時点で、私を見る 彼の目は奇異になり、あたかも私が分散オブジェクトについて何も知らないのではないかと いう顔をする。

このような場合、 私は妙なジレンマに陥る。 「このような設計ではだめだ!」 と叫んで部 屋から追い出されるべきだろうか。 または顧客の理解を得るべく懇々と説得すべきだろうか。 商売上は絶対に後者を選択するべきだが、 顧客が自画自賛している設計を諦めさせるのは想 像以上に骨の折れる仕事でもある。

分畝ストラテジー

40 Invoice Customer Order Delivery

図7.1 異なるノードに別々のコンポーネントを置くことによるアプリケーションの分散

ここまで読み続けてくれた読者は、私が分散設計をまったく評価しない理由を知りたいは ずだ。多くのツールベンダーによれば、分散オブジェクトの良い点はいくつものオブジェク トを好きなように処理ノードに配置できることにある。 また、 ツールベンダーが提供する強 力なミドルウェアでは透過性も提供され、 透過性によりプロセス内、 またはプロセス間で、 オブジェクト同士で呼び出し合うことができるようになる。 この際、 呼び出される側が同じ プロセス内にあるのか、 別のプロセスあるいはマシンにあるのかを知っている必要はない。

透過性は有益で、分散オブジェクト内では多くのものを透過させることができるが、バ フォーマンスは例外である。 この設計者は、パフォーマンスを高めるためにオブジェクトを 分散しているが、彼の設計はパフォーマンスを低下させるか、システムの設計および導入を とても難しくするか、または多くの場合その両方の問題を引き起こすこととなる。

72 | リモートインタフェースとローカルインタフェース

クラスモデルによる分散がうまく動作しない主な原因は、 使用するコンピュータに基本的 に大きく関係している。プロセス内の手続き呼び出しはとても高速で行われるが、2つの別 個のプロセス間での手続き呼び出しの処理速度は大幅に低下する。そのプロセスが別のマシ ンで実行されている場合は、さらに大幅に低下する (ネットワークの形態によって低下幅は

結果として、リモートで使用されるオブジェクト用のインタフェースは、同じプロセス内

094

でローカルで使用されるオブジェクト用のインタフェースとは違うものにする必要があ ローカルインタフェースは、細かい粒度のインタフェースであるほど優れたものであ したがって、 Address クラスがある場合、 優れたインタフェースでは、都市の取得、 取得、 都市の設定、 州の設定などのように、それぞれ個別のメソッドを持つ。 このような かい粒度のインタフェースが優れているのは、多くの小さな部品で構成され、 さまざまな 法でそれらが組み合わされオーバーライドすることで、 将来的に拡張できる設計という 的オブジェクト指向原則に従っているからである。

ただし、この細かい粒度のインタフェースはリモートでは効率が悪くなってしまう。 ソッドの呼び出しが遅い場合は、都市、 州、 郵便番号の取得または更新を3つではなく」 の呼び出しで行いたいはずであり、結果としてインタフェースの粒度は粗くなり、 柔軟性や 張性ではなく、 呼び出しを最小限に抑えるために設計されたものとなる。 ここでは、住所の 細の取得や、住所の詳細の更新など、至るところにインタフェースが必要となる。 プログラ するにはかなり難しいものではあるが、 パフォーマンスから見ると必要なものである。

当然、ベンダーは、彼らのミドルウェアではリモートコールにもローカルコールにもオ バーヘッドはないと言うだろう。 ローカルコールの場合は、 ローカルコールの速度で処理 れることになるが、 リモートコールになると速度は低下する。 つまり、リモートコールに する代償は、必要なときにだけ払えばよいということになる。 これはある程度当てはまる。 とで、リモートで使用される可能性があるオブジェクトは粗い粒度のインタフェースを持 必要があり、 リモートでは使われないオブジェクトは細かい粒度のインタフェースを持つ 要があるという基本構造は変わらない。 2つのオブジェクトが通信するとき、 必ずどちら 使うかを選択しなくてはならない。 オブジェクトが別のプロセス内に行く可能性がある場合 は、粗い粒度のインタフェースを使う必要があり、 難易度の高いプログラミングモデルが 求される。 言うまでもなく、 代償は必要なときにだけ払えばよいので、プロセス間での共同 作業はできるだけ少なくする必要があるということになる。

このことから、シングルプロセスの世界で設計したクラスのグループに対して、 CORBA などをあてがうだけで分散モデルにすることはできない。 分散設計はもっと複雑なものだか らだ。 クラスをベースにした分散ストラテジーでは、リモートコールが頻繁に発生するシス テムになり、 その結果粗い粒度のインタフェースが必要となる。 最終的には、すべてのリ モート可能なクラスに粗い粒度のインタフェースを持たせたとしても、膨大な数のリモート コールを発生させ、 おまけに修正するのも難しいシステムになる。

以上のことから、私が唱える 「分散オブジェクト設計の第一法則」にたどり着く。つまり、 オブジェクトを分散してはいけないのである。

では、複数のプロセッサを効率的に使うにはどうすればよいのだろうか。 ほとんどの場合、 クラスタリングを使うことである (図7.2 参照)。 すべてのクラスを1つのプロセスに入れ、 そのプロセスの複数のコピーをそれぞれのノード上で実行する。 この方法では、各プロセス

はローカルコールを使うので処理が高速になる。 プロセス内のすべてのクラスで細かい粒度 のインタフェースを使うようにし、 プログラミングモデルをシンプルにして、 より保守しや すくすることもできる。

oa1: Order Application 40 ga2: Order Application oa3: Order Application oa4: Order Application

72 同じアプリケーションのコピーを別々のノードに配置したクラスタリング

73 分散が必要な場所

分散境界を最小限に抑え、可能な限りクラスタリングを介してノードを使うようにしたい。 しかしこの手法にもそれなりの制限が存在する。 つまり、 プロセスを分離しなければならな い場所が存在することである。鋭い人であれば、追い詰められたネズミの行動のように奮闘 し、できる限りこれらの問題を解決しようと試みるだろうが、すべてを解決することはでき ない。

明確に分離できるのは、従来のクライアントとビジネスソフトウェアのサーバ である。ユーザのデスクトップにあるPCのノードは、データの共有リポジト リのものとは異なる。 それらは別々のマシンなので、通信するプロセスは別に 用意する必要がある。 クライアントとサーバの分離は、 このプロセス間分離の 典型的なものである。

第7章 分 ストラテジー

■2つ目の分離としてよく見られるのが、サーバベースアプリケーションソフト ウェア (アプリケーションサーバ)とデータベース間においてである。 もちろ

96

ん、この分離は必ずしもする必要がない。 ストアドプロシージャのようなも を使って、すべてのアプリケーションソフトウェアをデータベースプロセス で実行させることもできる。 ただし、この方法はあまり実践的ではないため やはり別々のプロセスを持たせる必要がある。 これらのプロセスを同じマシ 上で実行させることは可能だが、別々のプロセスが発生した際は、ほとんど コストをリモートコールの方に向ける必要がある。 幸いなことに、 SQL は モートインタフェースとして設計されているので、コストを最小限に抑える うに配分できる。

■プロセスの分離は、 Web システム内や Web サーバとアプリケーションサー の間でも起こることがある。 すべてが同等の場合、 Web サーバとアプリケー ションサーバを1つのプロセス内で実行するのが好ましいが、 常にこれらが 等であるとは限らない。

ベンダーの違いにより分離させなければならないこともある。 ソフトウェア パッケージを使っている場合、大抵は自身のプロセス内で実行されるので、 散が生じる。 ただし、優秀なパッケージであれば、粗い粒度のインタフェース を持っているはずだ。

■最終的には、どうしてもアプリケーションサーバソフトウェアを分離せざるを えないような場合もある。 これを本能的に回避する手段をとることは理解でき るが、それでもどうしようもない場合もある。 このような場合は、覚悟を決め ソフトウェアをリモートの粗い粒度のコンポーネントに分割するしかない。

Colleen Roe 氏の忘れがたい言葉を借りると、 ここで最も重要なテーマは「オブジェクト 分散では可能な限り倹約する」 ということだろう。 可能であるなら、覚悟を決めて手放すこ とだ。

7.4

| 分散境界の扱い

システムを設計するときは分散境界をできる限り制限しなければならないが、 分散境界が 存在する以上はそれらを考慮する必要があり、 すべてのリモートコールはインターネット経 山で運ばれることになる。 システム内のあらゆる個所が、 その形を変えてリモートコールを 最小限に抑えようとするが、このコストはある程度計算できるものである。

一方、1つのプロセス内では粗い粒度のオブジェクトを使った設計もできる。 このとき重 要なのは、 粗い粒度のオブジェクトを分散境界に配置させ、細かい粒度のオブジェクト向け のリモートインタフェースとして使用するということである。 粗い粒度のオブジェクトは、

権限を委任する以外は特に何もしないので、細かい粒度のオブジェクト用のファサードとし て機能する。 このファサードは分散が目的なので、 その名前もリモートファサードになる。

リモートファサードを使えば、 粗い粒度のインタフェースがもたらすさまざまな問題を最 小限に抑えることができる。 この方法では、リモートサービスを本当に必要としているオブ ジェクトだけが粗い粒度のメソッドを使うことになり、このような代償を払わなければなら ないことは開発者にも明らかである。 透過性にはメリットがあるが、 潜在的なリモートコー ルに関しては透過性が求められていない。

ただし、粗い粒度のインタフェースを単なるファサードとして使うことで、同じプロセス 内で実行中だとわかっていればいつでも細かい粒度のオブジェクトが利用できることにな る。こうすれば、分散ポリシー全体がより明示的なものとなる。 リモートファサードと密接 な関係にあるのがデータ変換オブジェクトである。 粗い粒度のメソッドが必要なだけでなく、 粗い粒度のオブジェクトを転送する必要もある。 アドレスを催促する場合、その情報は1つ のブロックで送信される必要がある。 通常は、ドメインオブジェクトそのものは送信できな い。 これは Web内でドメインオブジェクトが細かい粒度のローカル相互オブジェクト参 照と結び付いているからであり、そこでクライアントが必要なすべてのデータを取り出し、 特定の転送用オブジェクトにバンドルさせる。 データ変換オブジェクトという呼び名の由来 はここにある (エンタープライズ Java コミュニティの人たちの多くは、 これをバリューオ ブジェクトと呼んでいるが、それでは別の意味でのバリューオブジェクトと区別できない)。 データ変換オブジェクトは回線の両側にあるので、それが回線上で共有されていないものを 参照しないようにしておくことが重要になる。 つまり、 データ変換オブジェクトは、別の データ変換オブジェクトか、文字列のような基本的なオブジェクトしか参照しないようにし ておくのが一般的なのである。

分散の別の手法として、プロセス間でオブジェクトを移行させる仲介役を設けるという方 法が考えられる。 つまり、レイジーロードの仕組みを使い、 データベースからレイジーに (ダラダラと) 読み込む代わりに、 回線上ではオブジェクトを移動させる。 この方法の難し い点は、最終的に多くのリモートコールが発生しないようにすることである。 実際にアプリ ケーションでこの方法を取り入れた例は見たことがないが、 O/Rマッピングツール (例: TOPLink) の中にはこの機能を備えているものもあり、高い評価を得ているようだ。

7.5 分散用インタフェース

従来、分散コンポーネント用のインタフェースは、グローバル手続きかオブジェクト上の メソッドを伴うリモート手続き呼び出しをベースにしたものだった。 しかし、ここ数年は、 XML over HTTP をベースにしたインタフェースも出現してきた。この種のインタフェー

98

スとしては SOAP が最も一般的になりつつあるが、これについては多くの人がすでに もの経験を積んでいる。

XML ベースの HTTP 通信は便利で、 その理由はいくつかある。 まず、 1回の往復だ で構造化された形式の大量のデータを容易に送ることができる。 リモートコールの数はで るだけ減らしたいので、この点は都合がいい。 XMLは多くのプラットフォームで現在 回っているパーサーの共通フォーマットとして使われているため、 まったく異なるプラッ フォームで構築されたシステム間での通信が可能になり、 HTTP も今では国際仕様とし 定着している。 XML は、 回線上のどこで何が起こっているかを簡単に見られるテキスト あると言ってもよい。 HTTP はまた、セキュリティまたは政治上の理由で他のポートが きにくい場合でも、 簡単にファイアウォールを通過することができる。

事実、オブジェクト指向のクラスのインタフェースとメソッドも値は持っている。 転送 れたすべてのデータを XML 構造と文字列に移動することで、リモートコールには相当な 荷がかかる。 確かにアプリケーションは、XML ベースのインタフェースをリモートコー に置き換えれば、パフォーマンスが劇的に向上する。 回線の両側が同じバイナリ構造を持 ていた場合、 XML インタフェースには多くの頭字語以外にあまり得るものがない。 同じ ラットフォームで構築された2つのシステムがある場合は、そのプラットフォームに備わ ているリモートコール構造を使うべきである。 逆に異なるプラットフォーム間で互いに通信 したいときは、Web サービスが便利である。 より直接的な手法がない場合に限り、XM Web サービスを使うというのが私のスタンスだ。

もちろん、 HTTP インタフェースをオブジェクト指向インタフェース上に覆いかぶせ 両方の利点を採用するという方法もある。 Web サーバへのすべての呼び出しを、 その下屋 のオブジェクト指向インタフェースへの呼び出しに変換する。 ある意味では、これは両方の 利点を採用するということになるが、 Web サーバとリモートオブジェクト指向インタ フェース用の機構が必要となるため、 複雑性は増すことになる。 したがって、 HTTP とリ モートオブジェクト指向 APIが必要な場合か、セキュリティやトランザクション処理用の リモートオブジェクト指向 API の設備の方が非リモートオブジェクトを使うよりも問題を 簡単に処理できる場合に限り、 この方法を使うべきである。

ここでは、 同期 RPC ベースインタフェースを前提に話を進めてきたが、必ずしもこれが 分散システムを扱う最高の手段であるとは思っていない。 最近では、 私はメッセージベース の手法、つまり本質的に非同期なものを好むようになりつつある。 メッセージベース用のパ ターンについて掘り下げていくと、それだけで一冊の本になるので、 本書ではこれ以上述べ ないことにする。 いずれそのような本が出版されることを願いつつ、今のところ私にできる ことは、非同期メッセージベース手法について調べて見るよう勧めることである。 特に、 現 在まで公開されている例のほとんどが同期であっても、 Web サービスを使うのが最も有効 だと思っている。



ここまでの章では、システムの一側面をとらえて扱うためのさまざまなオプションにつ て説明してきたが、 本章ではそれらのことを踏まえ、エンタープライズアプリケーション 設計する際にどのパターンを使うべきかという難問に答えていくことにする。

本章で述べるアドバイスは、 多くの点で前章までに述べてきたことの反復である。 正直 言うと本章が必要かどうか悩んだのだが、 今までの内容をまとめることで、本書で紹介して いるパターンが目指しているものの概略だけでも把握できるのではないかと考えて付け加える ることにした。

私は、自分でアドバイスできる限界をはっきり意識している。 「ロード・オブ・ザ・リン グ」の中で、フロドも 「エルフ達に相談しに行っても、良いとも悪いとも言ってくれない」 と言っていた。 私は底知れぬ知識を持っているわけではないが、 エルフ達の対応は理解でき る。 アドバイスは押しつけがましい危険な贈り物になることが多いからである。 本書を読ん でプロジェクトの設計上の判断を下そうとしている人は、そのプロジェクトに関して私より、 もはるかによく理解しているはずだ。 賢者の大きな悩みの一つは、 会議や電子メールなどで、 設計やプロセスの判断に関するアドバイスを求められることである。 たった5分の説明を聞 いて的確なアドバイスをするのは不可能である。 本章は、読者が置かれている苦しい状況を 考慮せずに書かれたものだ。

したがって、 本章は、 あるがままのものとして読んでいただきたい。 私はすべての解答を 知っているわけではなく、読者の質問を開くこともできない。 ここに書かれている内容は、 読者のアイデアを引き出すためのものであり、決してそのアイデアに代わるものではない。 最終的な決断を下しプロジェクトを進めていくのは読者自身である。

幸い、たとえ決断を下したとしても、永遠に不変のものではない。 アーキテクチャのリ ファクタリングを行うのは困難で、 全体のコストがどのくらいになるかもわからないが、 決 して不可能なことではない。 現時点で読者に提供できる唯一のアドバイスは、たとえエクス トリームプログラミング [Beck XP]に関する話が好きではなくても、 3つの技術上の実践

常時結合[Fowler CI]、 テスト駆動開発[Beck TDD]、 およびリファクタリング [Fowler Refactoring]については納得いくまで検討すべきであるということだ。 決して万能の解 決策ではないが、考え直しを迫られた局面においては大いに役立つものである。 そして、 よ ほど運が良いか、 私が今まで会ったこともないほどの才能の持ち主でない限り、いずれは考 え直しを迫られることになる。

8.1 | ドメインレイヤからの開始

プロセスの出発点は、どのドメインロジック手法で行くかを決定することである。 有力候

補は3つあり、 トランザクションスクリプト テーブルモジュール、 ドメインモデルである。 第2章でも述べたように、これら3つのパターンからどれを用いるか決めるのに最も強い 影響を与えるのは、ドメインロジックの複雑性である。 複雑性の量も質も、現時点ではどの ような尺度を使用しても測り難い。 しかし、決定に影響を及ぼす要因はほかにもある。 特に データベースとの複雑な接続の難しさが挙げられよう。

3つのパターンの中で最もシンプルなのは、トランザクションスクリプトである。 これは、 依然として多くの人が慣れ親しんでいる手続き型モデルといえる。 各システムトランザク ションは、理解しやすいスクリプト内に正しくカプセル化されていて、リレーショナルデー タベース上での構築も簡単に行える。このパターンの最大の欠点は、複雑なビジネスロジッ クをうまく扱えない点にある。 特に、重複コードが起こりやすいという問題がある。 つまり、 価格を表示する基本的な構造にショッピングカートがついた程度のシンプルなカタログアプ リケーションであれば、 トランザクションスクリプトでも十分ニーズを満たすが、 ロジック がさらに複雑になっていくと難易度は飛躍的に増大する。

対極に位置するのがドメインモデルである。 私のようなガチガチのオブジェクト主義者は、 これ以外の方法でアプリケーションを設計することはない。 アプリケーションがトランザク ションスクリプトで書けてしまうほどシンプルなものであるなら、 悩む必要はない。 また、 私の経験では、本当に複雑なドメインロジックの扱いに関しては、優れたドメインモデルの 右に出るものはない。 ドメインモデルでの作業に慣れてくれば、シンプルな問題にも簡単に 対処できるようになるというものだ。

しかし、ドメインモデルにも欠点はある。 中でも最も厄介なのが、その使い方を覚えるの がとても難しいという点だろう。 オブジェクト主義者は、 オブジェクトのことをよく理解し ていない人を見下す傾向が強いが、ドメインモデルを適切に設計するには相応のスキルが必 要であり、これが不足していると悲惨な結果になるのはまちがいない。 ドメインモデルが抱 える2つ目のハードルは、リレーショナルデータベースとの接続が難しいということである。 もちろん熱狂的なオブジェクト主義者であれば、この問題もオブジェクトデータベースを巧

第8章 まとめ

みに操って難なく処理する。 しかし主に非技術的な理由から、 オブジェクトデータベース エンタープライズアプリケーションで使うのは有効な選択ではない。 結果的にリレーショッ ルデータベース接続が繁雑になるからだ。 認めざるを得ないことだが、 オブジェクトモデ とリレーショナルモデルはうまく適合しない。 その結果が、 ここで紹介するO/Rマッピン グパターンの大半の複雑さなのである。

テーブルモジュールは、上記2つの対極にあるパターンのちょうど中間に位置する。 ドメ インロジックの扱いに関しては、明らかにトランザクションスクリプトよりは優れている また、ドメインモデルのように複雑なドメインロジックを扱うことはできないが、リレー ショナルデータベースやその他多くのものともうまく適合する。 すべてを見通せるレコード セットの周囲に多くのツールが揃っている.NET のような環境がある場合、 テーブルモ ジュールはうまく機能する。 リレーショナルデータベースの力を活かしつつ、ドメインロ ジックを合理的に分離することである。

このとき使用するツールもアーキテクチャに影響する。 アーキテクチャを基準にツールを 選択できる場合もあり、理論的にはそうするべきだが、 アーキテクチャの方をツールに合わ せなくてはならないことの方が多い。 上記3つのパターンの中でも、 適合するツールを持っ ている場合は、テーブルモジュールが群を抜いている。 特に、 プラットフォームそのものが レコードセットとの相性が良い.NET 環境では最適な選択肢となる。

第2章のドメインロジックに関する説明を読んだ方であればすでに理解されていると思う が、最も重要な決定事項なので、繰り返しておく価値はあるだろう。 ここからは1つ下の階 層のデータベースレイヤに進むことになるが、これから先の決定はドメインレイヤで何を選 択するかによって変わってくる。

8.2 | データソースレイヤに進む

ドメインレイヤを選択したら、 次にデータソースに接続する方法を考える。 ここから先の 決定は、選択したドメインレイヤによって異なるので選択肢ごとに分けて紹介する。

8.21 | トランザクションスクリプト用のデータソース

最もシンプルなトランザクションスクリプトであっても独自のデータベースロジックが含 まれている。 しかし、 どんなシンプルなものであっても、私はこれを避ける。 データベース を分離すると、2つの範囲に区切られて境界線がわかりやすくなるので、私は最もシンプル と思われるアプリケーションでも分離する。 選択できるデータベースパターンには、行デー タゲートウェイとテーブルデータゲートウェイの2つがある。

どちらを選択するかは、実装されているプラットフォームとアプリケーションが最終的に 配置される場所によって決まる。 行データゲートウェイでは、各レコードは明示的なインタ フェースを持つオブジェクトに読み込まれる。 テーブルデータゲートウェイの場合は、 デー タを取得するために必ずしもすべてのアクセッサーのコードを必要としないので、記述する コードは少なくて済むが、最終的にはるかに暗黙的なインタフェースを多用することになる。 そしてこのインタフェースは、整然と並べられたマッピングにすぎないレコードセット構造 へのアクセスに依存する。

ただし、最終的な決定は、使用しているプラットフォームに依存する。 レコードセットと 適合するツール、 特に、 UIツールやトランザクション可能な切断されたレコードセットなど が数多く提供されているプラットフォームを使っている場合は、 テーブルデータゲートウェイ が最有力となる。

通常、コンテキスト内では、 その他のO/Rマッピングパターンは一切必要としない。 メ モリ内構造がデータベース構造と適切にマッピングされるので、構造的マッピングに関して 留意する必要はほとんどない。 ユニットオブワークの検討もよいが、更新管理はスクリプト 内で行うほうが簡単である。 並行性に関してはほとんど心配する必要はない。 それは、スク リプトがシステムトランザクションとほぼ同等のものとなることが多いからである。 した がって、スクリプト全体を1つのトランザクション内にラップする。 一般的な例外として、 ある要求がデータを編集用に抽出し、次の要求が変更を保存しようとするケースがあるが、 この場合軽オフラインロックが常に最適な選択肢となる。 実装を簡素化できるだけでなく、 ユーザが予測する通りの結果が得られ、さまざまなものがロックされたままセッションがハ ングしてしまうという問題も回避できる。

8.2.2 | データソース 「テーブルモジュール」

テーブルモジュールを選択する最大の理由は、優れたレコードセットフレームワークの存 在にある。このケースでは、レコードセットと適合するデータベースマッピングパターンが 必要なので、テーブルデータゲートウェイを選択する以外ない。これら2つのパターンは、 まるで一体型のようにスムーズに適合する。

このパターンでは、データソース側には追加すべきものは他に何もない。 最適なケースで は、レコードセットにある種の並行性制御メカニズムが組み込まれていて、事実上ユニット オブワークになることもあり、余計なストレスを減らせるようになる。

8.23 | ドメインモデル用のデータソース

面白くなるのはここからだ。 いろいろな点から見て、 ドメインモデルの最大の弱点はデー

04

第8章 まとめ

タベースとの接続が複雑なことである。 複雑さの度合いは、パターンの複雑さによって違 てくる。

データベースに隣接する20~30のクラスで構成されているような、比較的シンプル ドメインモデルの場合、 アクティブレコードが適切である。 もう少し切り離したい場合に テーブルデータゲートウェイか行データゲートウェイのいずれかを使うこともできる。 い れの方法でも、切り離すかどうかは大きな問題ではない。

もう少し複雑になった場合は、 データマッパーについても検討する必要があるだろう。 の手法は、ドメインモデルをできる限り他のレイヤに依存しないものにすることを約束する。 一方で、データマッパーは最も実装が複雑なものの1つでもある。 優秀なチームを抱えて るか、マッピングを簡素化する何らかの知識がない限り、できるだけマッピングツールを入 手することを勧める。

データマッパーを選択した時点で、O/Rマッピングセクションのほとんどのパターンが 場してくる。 特に、並行性制御の中心的役割を果たすユニットオブワークを強く推奨したい

8.3 プレゼンテーションレイヤ

多くの意味で、プレゼンテーションは下層レイヤの選択に依存する度合いが小さい。 最初 に決めるべきことは、リッチクライアントインタフェースとHTML ブラウザーインタ フェースのどちらを使うかである。 リッチクライアントは、 見栄えがよいUI を提供するが、 クライアントの制御と導入にそれなりの労力が必要である。 私は、リッチクライアントであ る必要がないのであれば、 HTML ブラウザーを使う。 通常、 リッチクライアントのプログ ラミングにはより多くの労力が必要だが、これは技術的に複雑だからと言うよりは、より洗 練されたものにするためである。

本書ではリッチクライアントを使ったパターンを1つも紹介していない。 したがって、 こ のパターンを使う場合、 本書はあまり役立たないだろう。

HTML インタフェースを選択した場合は、 まず、 アプリケーションをどのような構造に するかを決める必要がある。 ここでは、 モデルビューコントローラを設計の基盤として使う ことを勧める。 そうすれば、決定事項はあと2つ、コントローラとビューだけになる。

これらの選択は、 使用しているツールによって決まることがある。 Visual Studio を使って いる場合は、ページコントローラとテンプレートビューを使うのが最も簡単な方法である。 Java を使っている場合は、 Web フレームワークの選択も考慮する必要がある。 現時点で最も 人気があるのは Struts だが、 この場合はフロントコントローラとテンプレートビューになる。

自由に選択するなら、サイトがドキュメント指向で特に静的ページと動的ページが混在す る場合は、ページコントローラを推奨したい。一方、 より複雑な遷移やUI を含む場合は、

フロントコントローラということになる。

ビューに関しては、テンプレートビューとトランスフォームビューのどちらを選ぶかは、 開発チームがサーバページと XSLT のどちらを使ってプログラミングしているかで異なる。 現時点では、テンプレートビューの方が優勢である。 ただし私はトランスフォームビューが 持つテスト機能の方が好きである。 1つの共通サイトを複数のルック&フィールで表示させ たい場合は、ツーステップビューも検討するべきである。

下位レイヤとの通信方法は、それらがどの種類のレイヤか、 また、常に同じプロセス内に いるかどうかによって異なる。 私は、できる限りすべてを1つのプロセス内で実行するよう にしている。こうしておけば、プロセス間の遅い呼び出しについて心配する必要がない。 こ れができない場合は、ドメインレイヤをリモートファサードでラップし、 データ変換オブ ジェクトを使ってWeb サーバと通信するべきである。

8.4 技術上のアドバイス

本書では、 多くの異なるプラットフォーム間でプロジェクトを進める場合の共通した経験 を述べるように心がけている。 Forte, CORBA, Smalltalk などでの経験は、 Java や.NET における開発にも十分活かせるものである。 ここでJava と .NET 環境にこだわるのは、こ れらが将来にかけてエンタープライズアプリケーション開発の共通プラットフォームになる 可能性が高いからである(ただし、個人的には Python や Ruby などの動的に入力されるス クリプティング言語を検討したいし、競争も必要だと思う)。

ここからは、今まで述べてきたアドバイスを2つのプラットフォームに適用してみよう。 しかし期間限定のものになってしまう恐れがある。 技術はこれらのパターンよりもはるかに 速く変化しているので、 本書が2002年初頭、 景気回復の兆しが見え始めたと言われた頃に 書かれたものであることを頭に入れておいてほしい。

8.4.1 | Java J2EE

現在Java の世界では、 EJB (Enterprise Java Beans) にどれほどの価値があるかとい うことが大きな論争の的となっている。 The Who が解散コンサートを開いたときのように、 EJB 2.0 仕様はいくつもの改訂を経てやっと登場するに至った。 しかし、 EJB ベンダーが何 を言うかはさておき、優れたJ2EE アプリケーションを構築するのに必ずしもEJB が必要 なわけではない。 POJO (plain old Java objects: 標準の古いJava オブジェクト)と JDBC だけでも十分機能するものを構築できる。

J2EE での設計の選択肢は、使用しているパターンによって違い、ここでもドメインロ ジックがその中心を担っている。

何らかの形態のゲートウェイの上でトランザクションスクリプトを使っている場合、現時 での EJB における一般的な手法は、 セッション Bean をトランザクションスクリプトとして エンティティ Bean を行データゲートウェイとして使うというものである。 ドメインロジック が適度なサイズの場合は、 適切なアーキテクチャである。 ただし、 Bean を使った手法の1 の問題点は、必要なくなったと判断しても簡単にはEJBサーバを切り離せないという点にあ り、その結果、余計なライセンス使用料を取られてしまうこともある。 EJB を使わない手 としては、行データゲートウェイかテーブルデータゲートウェイのいずれかの上でPOJOを トランザクションスクリプトとして使う方法がある。 JDBC 2.0 の行セットの容量が大きい場 合、レコードセットとして使えるので、 テーブルデータゲートウェイということになる。

ドメインモデルを使っている場合、 エンティティ Bean を使うのが現行では定説となって いる。 使用しているドメインモデルが比較的シンプルでデータベースとも相性が良い場合、 十分納得の行く手法であり、 エンティティ Bean は、 アクティブレコードになる。 ここでも、 エンティティ Bean をセッション Bean でラップして、リモートファサードとして機能させ るという手法は有効である (CMP (Container Managed Persistance) をデータマッパー として考えるという方法もある)。 ただし、 ドメインモデルがより複雑な場合は、 EJB 構造 とは完全に独立させ、ドメインロジックの記述、 実行およびテストを、 EJBコンテナと切り 離して行えるようにした方がよい。 私なら、このモデルではPOJOをドメインモデルとして 使い、 セッション Bean でラップしてリモートファサードとして機能させるだろう。 また、 EJB を使わない場合は、アプリケーション全体を Web サーバ上で実行させ、プレゼンテー ションとドメイン間でリモートコールが発生しないようにする。 また、 POJO ドメインモデ ルを使う場合は、 POJO をデータマッパーとして使う (O/Rマッピングツールを使うか、 何かしら自分で用意する)。

いずれのコンテキストにおいても、エンティティ Bean を使う場合は、リモートインタ フェースを採用するべきではない。 私にとっては、 エンティティ Bean にリモートインタ フェースを与えること自体理解できないことである。 エンティティ Bean は、 ドメインモデ ルとして、 または行データゲートウェイとして使われるが、いずれのケースでも細かい粒度 のインタフェースが必要になる。 リモートインタフェースは必ず粗い粒度のものである必要 があるので、 エンティティ Bean はローカルだけで使うべきである (例外として、 [Alur et al. J の Composite Entity パターンがありエンティティ Bean を別に使っているが、私とし てはあまり有効なものとは思えない)。

現時点では、テーブルモジュールは Java の世界ではあまり一般的ではない。 JDBC 行 セット用のツールがもっと増えれば面白いと思う。 そのときは、 パターンも有効な手法とな るはずである。 このケースではPOJO が最適な手法だが、 テーブルモジュールをセッション Bean でラップしてリモートファサードとして使い、 レコードセットを返させるという方法 もある。

8.4.2 | .NET

.NET Visual Studio など、 Microsoft のアプリケーション開発環境の歴史を辿ってみる と、大半がテーブルモジュールをパターンとして使っていることに気付く。 このことからも 言えることだが、 オブジェクト主義者は Microsoft 愛好者がオブジェクトを使わないと結論 付けてしまいがちである。 しかし、テーブルモジュールには、 トランザクションスクリプト とドメインモデルの妥協点のようなものが含まれ、 偏在するデータセットをレコードセット として活かせる優秀なツールが数多く含まれている。

つまり、このプラットフォームではテーブルモジュールがデフォルトの選択肢となる。 ご シンプルなケースを除き、トランザクションスクリプトを使うことには意味を見出せない。 たとえシンプルなケースでもデータセットに対して作用し、 データセットを返すようにする べきである。

これは、決してドメインモデルが使えないと言っているわけではない。 事実、 .NET でも その他のオブジェクト指向環境同様、 簡単にドメインモデルを構築することができる。 ただ し、テーブルモジュールのときのように役立つツールが少ないので、ドメインモデルへのシ フトが必要だと感じる以前に複雑性を解決していく方が先決である。

NET といえば Web サービスというような考え方が浸透しているようだが、 私だったら アプリケーション内で Web サービスは使わない。 Java のときと同じように、アプリケー ション同士が統合できるプレゼンテーションとして使う。 .NET アプリケーションでは、 Web サーバとドメインロジックを切り離す理由も特にないので、 リモートファサードはこ ここではあまり有効なものとはならない。

8.4.3 | ストアドプロシージャ

ストアドプロシージャについてはさまざまな議論がある。 データベースと同じプロセス内 で実行されるので、 足を引っ張るリモートコールが減ることから、最も高速な手段であると 言われる。 ただし、ほとんどのストアドプロシージャ環境では、 実際に使用するストアドプ ロシージャ用に優れた構造メカニズムが提供されることはなく、 特定のデータベースペン ダーに依存せざるをえなくなることが多い (これらの問題をうまく回避しているのが、 デー タベースプロセス内でJavaアプリケーションを実行できるようにしている Oracle の手法 である。 これはドメインロジックレイヤ全体をデータベース内に置くのと同じことになる。 特定ベンダーに依存せざるをえないという点では同じだが、少なくとも移植コストは削減で きる)。

モジュール性と移植性からみて、ほとんどの人はビジネスロジックではストアドプロシー ジャを使うことは避けている。 私も、 パフォーマンス面で大幅な改善でも見られない限り、 ストアドプロシージャを使用しないようにしているが、改善はよく行われているのも事実で

108

ある。 パフォーマンス面での改善があれば、喜んでメソッドをドメインレイヤからストア プロシージャに移す。 ただし、明らかにパフォーマンスに問題のある部分だけに抑え、 アー キテクチャそのものではなく、 最適化手順として扱う (ストアドプロシージャの扱いに関し ては、 [Nilsson]がより広い視野から掘り下げた議論を展開している)。

ストアドプロシージャは、テーブルデータゲートウェイの中でデータベースへのアクセス を制御するものとして使うのが一般的な使用法であるが、これを扱う方法に関して私は特に 意見はない。 今まで見てきたものの中にも、 どちらにするかを決定する理由は見つからない。 いずれの場合でも、 同じパターンでのデータベースアクセスは切り離すべきだろう。 ストア ドプロシージャを介したものでも、より一般的な SQL を介したものであってもである。

8.4.4 | Web サービス

この本の執筆時点での識者の一般的見解は、 今後 Web サービスを再利用できるようにな るので、システム統合ビジネスはいずれ成り立たなくなるということだ。 しかし、これらの パターンに対して Web サービスの役割は決して大きいものではない。 Web サービスとはア プリケーションを統合したものであり、アプリケーションの構築そのものではないからであ る。 1つのアプリケーションを複数のWebサービスに分解し、 互いに交信し合うような状 態にすることは、本当に必要な場合を除いてするべきではない。 アプリケーションを構築し、 それぞれの部分を Web サービスとして公開するべきであり、 Web サービスをリモートファ サードとして扱う。 Web サービスの構築は簡単だと言われているが、 それらの言葉に惑わ されて「分散オブジェクト設計の第一法則」 (第7章) を忘れないように気をつけてほしい。 てい

これまで公開された例のほとんどは XML RPC のような同期 Web サービスを使っるが、私には非同期でメッセージベースの方が好ましい。 本書ではそのようなパターンは紹 介していないが (本書は本題だけですでにかなりのボリュームになっているので)、数年の うちに非同期メッセージング用のパターンが紹介されることを期待したい。(訳注】

8.5 | その他のレイヤ化スキーム

ここでは3つの主なレイヤを中心に話を進めているが、これ以外のレイヤ化方法も存在す る。 アーキテクチャに関する他の書籍にもレイヤ化スキームが紹介されていて、それぞれに 価値がある。 できればこれらのスキームにも目を通し、ここで紹介しているものと比較して みてほしい。 読者が実際に携わっているアプリケーションには、そちらの方が適切であるこ

【注】このパターンに関しては、 「Enterprise Integration Patterns」 を参照のこと。

ともある。

その1番手は、私がBrown モデルと呼んでいるもので、 [Brown et al.] で紹介されてい る(表 8.1 参照)。 このモデルでは、プレゼンテーション、 コントローラ/メディエータ、 ド メイン、 データマッピング、データソースの5つのレイヤを使っている。 基本的に、3つの 基本レイヤの間に中間レイヤが配置された構成である。 コントローラ/メディエータは、プ レゼンテーションとドメインの間を、データマッピングは、 ドメインとデータソースレイヤ の間を取り次ぐものである。

中間レイヤは便利な場合もあるが、常に便利というわけではないので、本書ではパターン として紹介している。アプリケーションコントローラはプレゼンテーションとドメインの間 を、そしてデータマッパーはデータソースとドメインの間をそれぞれ取り次ぐものである。 本書では、アプリケーションコントローラはプレゼンテーションの章 (第14章) で、 デー タマッパーはデータソースの章 (第10章) でそれぞれ紹介している。

便利な場合が多いが常に便利とは限らない中間レイヤは、設計におけるオプション的なも のに思える。 つまり、3つの基本レイヤを軸にし、 どれかが複雑になり過ぎたときに中間レ イヤを追加して機能を分散させるという手法である。

J2EE用の優れたレイヤ化スキームは、 CoreJ2EE パターンでも紹介されている [Alur et al] (表 8.2参照)。 ここでは、 クライアント、プレゼンテーション、ビジネス、 統合、 リ ソースの各レイヤが使われている。 この中でビジネスレイヤと統合レイヤは、シンプルに一 致するものがある。 リソースレイヤは、 統合レイヤが接続した先の外部サービスによって構 成されている。 一番大きな違いは、プレゼンテーションレイヤが、クライアント側で実行す る部分(クライアント) と、サーバ側で実行する部分 (プレゼンテーション) に分かれてい る点にある。 これは便利な場合もあるが、 常に必要であるとは限らない。

表 8.1 ・Brown レイヤ

Brown プレゼンテーション コントローラ/メディエータ ドメイン データマッピング データソース Fowler プレゼンテーション プレゼンテーション (アプリケーションコントローラ) ドメイン データソース (データマッパー) データソース

10

表 8.2 Core J2EE レイヤ

Core クライアント J2EE Fowler クライアント側で実行されるプレゼンテーション (例:リッチク ライアントシステム) プレゼンテーション サーバ側で実行されるプレゼンテーション (例: HTTP ハンドラ サーバページ) ビジネス 統合 リソース ドメイン データソース データソースが通信する外部リソース

Microsoft の DNA 設計者Kirtland]は、プレゼンテーション、ビジネス、データアクセ スという3つのレイヤを定義しているが、これらはほぼそのまま本書で紹介している3つの レイヤと一致する(表 8.3 参照)。 最も大きな違いは、 データアクセスレイヤからのデータ の渡され方にある。 Microsoft DNA では、 データアクセスレイヤから発行されたSQLク エリーの結果となるレコードセット上ですべてのレイヤが作動するようになっている。 この 状態では明らかに結合され、 ビジネスとプレゼンテーションの両方のレイヤがデータベース について知っていることになる。

私の見方では、DNAにおけるレコードセットはレイヤ間でのデータ変換オブジェクトの ような役割を果たしているように見える。 ビジネスレイヤは、プレゼンテーションレイヤ上 に移動する途中でレコードセットを修正できるだけでなく、 稀なケースだが、 新たなものを 作成することもできる。 この通信形態はいろいろな意味で扱いにくいが、プレゼンテーショ ンがデータを認識している GUI制御を利用できるという大きな利点もある。 このデータに は、ビジネスレイヤが修正したものも含まれるのである。

このケースでは、ドメインレイヤはテーブルモジュール形式の構造を持ち、 データソース レイヤはテーブルデータゲートウェイを使う。

[Marinescu]も5つのレイヤを使っている (表 8.4参照)。 ここでは、プレゼンテーション が2つのレイヤに分割されているが、アプリケーションコントローラの分離を反映している。 ドメインもドメインモデル上で構築されたサービスレイヤで分割されているが、 ドメインレ イヤを2つに分割するという一般的なアイデアを反映したものである。 これは、 ドメインモ デルのように EJB の制限から強いられる一般的な手法である (P125 参照)。

表 8.3 Microsoft DNA レイヤ

Microsoft DNA Fowler プレゼンテーション ビジネス データアクセス プレゼンテーション ドメイン データソース

表 8.4 ・Marinescu レイヤ

Marinescu Fowler プレゼンテーション アプリケーション プレゼンテーション プレゼンテーション (アプリケーションコントローラ) サービス ドメイン サービスレイヤ) ドメイン 永統 ドメイン ドメインモデル) データソース

サービスレイヤをドメインレイヤから切り離すという考え方は、ワークフローロジックを 純粋なドメインロジックから分離するという考えに基づいている。 サービスレイヤには特定 の場合だけ使用するロジックや、 メッセージングなど他のインフラと通信するためのロジッ クが含まれている。 サービスとドメインを別々のレイヤにするかどうかについては、いろい ろな意見がある。 私は必須のものというより、 場合によっては便利なものと考えているが、 私が尊敬する設計者はこの意見に賛同していない。

[Nilsson] は最も複雑なレイヤ化スキームの1つを使っている (表 8.5 参照)。 Nilsson はス トアドプロシージャを多用し、 パフォーマンス目的でその中にドメインロジックを入れ込ん でいるので、このスキームへのマッピングはかなり複雑なものになる。 ストアドプロシー ジャ内にドメインロジックを入れると、アプリケーションの維持が大幅に困難になるので、 私にとってはこの手法は難しく感じられる。 ただし、 ある特定の状況においては最適化手法 として有効である。 Nilsson のストアドプロシージャレイヤには、データソースとドメイン ロジックの両方が含まれている。

また、[Marinescu]同様、 Nilsson もドメインロジック用にアプリケーションとドメイン の別々のレイヤを使っている。 小規模なシステムではドメインレイヤを省略するように指示 しているが、これはドメインモデルの価値が小規模システムでは低くなるという私の考え方 に共通するものがある。

表 8.5 ･Nilsson レイヤ

Nilsson コンシューマ コンシューマヘルパー アプリケーション ドメイン 永続アクセス パブリックストアドプロシージャ プライベートストアドプロシージャ Fowler プレゼンテーション プレゼンテーション (アプリケーションコントローラ) ドメイン サービスレイヤ) ドメイン ドメインモデル) データソース データソース (ドメインを含む場合もある) データソース (ドメインを含む場合もある)

112

第8章 まとめ

第2部

パターン



ドメインロジックバラ

9.1 | トランザクションスクリプト

ビジネスロジックを一連の手続きで構築して、その各手順でプレゼンテーションからの 1つの要求を処理する。

RecognitionService

recognized Revenue (contractNumber: long, asOf: Date): Money calculateRevenueRecognitions (contractNumber long): void

ビジネスアプリケーションの大半は、一連のトランザクションとして考えることができる。 トランザクションには、ある特定の方法で体系化した情報を表示するものや変更するものが ある。クライアントシステムとサーバシステム間の相互作用には、 一定量のロジックが含ま れている。 ロジックには、データベース内の情報を表示するシンプルなものから、いくつも の妥当性の確認と計算の手順を含むものもある。

トランザクションスクリプトは、主にロジックを1つの手続きにまとめてデータベースを 直接呼び出すか、 薄いデータベースラッパーを介して呼び出す。 各トランザクションには独 自のトランザクションスクリプトがあるが、 共通のサブタスクはサブ手続きに分割できる。

9.1.1 動作方法

トランザクションスクリプトでは、ドメインロジックはシステムで実行するトランザク ションで主に構築される。 たとえばホテルの部屋を予約するというニーズがある場合、 ホテ ルの部屋を予約する手続きには、 空室をチェックするロジック、宿泊費を計算するロジック、

そしてデータベースを更新するロジックが含まれることになる。

シンプルな場合には、ロジックをどのように体系化するのかまでは必要ない。もちろん、 どのようなプログラムでも、 ある程度合理的なモジュールとしてコードを構成する必要があ る。 トランザクションが特に複雑なものでなければ、プログラムのコード化は決して難しい ことではないはずだ。 プログラムのコード化では、他のトランザクションの動作を気にする 必要がないというメリットがある。 入力データを取得し、 データベースに問い合わせて変更 を行い、さらに結果をデータベースに保存するというのが、 実行するタスクになる。

また、トランザクションスクリプトをどこに置くかは、レイヤをどのように体系化するか によって異なる。 サーバページ、 CGI スクリプト、 または分散セッションオブジェクトのい ずれの中にでも置くことができる。 私はできる限りトランザクションスクリプトを分離させ ることを好んでいる。少なくともトランザクションスクリプトを個別のサブルーチン内に置 プレゼンテーションやデータソースを処理するトランザクションスクリプトとは異なる クラスに置くことにしている。 さらに、 トランザクションスクリプトからプレゼンテーショ コンロジックを呼び出さないようにする。 これでコードの修正も、トランザクションスクリプ トのテストも簡単に行えるようになる。

トランザクションスクリプトを複数のクラスに体系化する方法は2つある。 最も一般的な 方法は、 複数のトランザクションスクリプトを1つのクラスに入れ、 各クラスが関連するト ランザクションスクリプトの対象エリアを定義する方法である。 この方法は最も簡単で一般 的な手法である。 もう1つの方法は、トランザクションスクリプトごとに独自のクラスを持 たせ(図9.1)、「コマンドパターン」 [Gang of Four] を使うというものだ。 この場合、トラ ンザクションスクリプトロジックに適合する実行メソッドを指定するために、コマンドの スーパータイプを定義することになる。この手法のメリットは、スクリプトのインスタンス を実行時にオブジェクトとして扱える点であるが、 トランザクションスクリプトを使ってド メインロジックを体系化するようなシステムでは、このメリットを活かす必要性はほとんど ない。もちろん多くの言語では、クラスを完全に無視してグローバル関数だけを使うことも できる。 しかし、新たなオブジェクトをインスタンス化することでスレッドの問題が解決で きる場合もある。 データの分離が簡単になるからだ。

6

第9章 ドメイン

run () TransactionScript Recognized RevenueTS CalculateRevenue RecognitionsTS new (contract number: long, asOf: date) run () new (contract number: long) run ()

図 9.1 トランザクションスクリプトのコマンドの使用

私がトランザクションスクリプトという用語を使っているのは、ほとんどの場合、デー タベーストランザクションごとに1つのトランザクションスクリプトを使用しているから である。 これは必ずしも 100%確実なルールではないが、それに近いものであることは間 違いない。

9.1.2 使用するタイミング

トランザクションスクリプトの素晴らしい点はシンプルさにある。 このようなロジックの 体系化は、ごくわずかなロジックを使ったアプリケーションでは一般的であり、 パフォーマ ンスの面でもその解釈の面でも、オーバーヘッドはほとんどない。

しかし、ビジネスロジックが複雑になるにつれて、優れた設計を維持するのは大変になる。

特に注意すべきことは、 トランザクション間での重複の問題である。 1つのトランザクションを処理することが重要事項となるので、共通するどのコードも重 複しやすい状況になる。

きめ細かにファクタリングすると問題の多くは軽減できるが、より複雑なビジネスドメイ ンでは、ドメインモデルの構築が必要となる。 ドメインモデルでは、豊富なオプションを 使ってコードを形成できるので、読みやすさが増すと同時に重複も減らすことができる。

パターンを切り替えるレベルを定めるのは容易ではない。 特に特定のパターンの場合はな おさらだ。 トランザクションスクリプト設計からドメインモデル設計にリファクタリングす ることはできるが、 実際には思っている以上に難しい変更となる。 したがって、 初期段階で の対応が最良の対処方法である。

しかし、 頑固なオブジェクト指向主義者であっても、トランザクションスクリプトをすべ て除外するべきではない。 シンプルな問題は数多く存在するし、シンプルな解決策の方が素 早く対策を講じられるからである。

9.1.3 | RevenueRecognition の問題

トランザクションスクリプトを含め、 ドメインロジックを説明するパターンでは、例とし て同じ問題を扱うことにする。 問題のステートメントを繰り返し入力しなくてすむように、 以降のパターンでは省略してある。

ビジネスシステムでよく見られる問題に、 Revenue Recognition (収益認識) の問題があ る。 帳簿に収入を計上する際に起こる問題である。 コーヒーを1杯売るのなら、 簡単なこと である。 コーヒーを渡し代金を得る。 そしてすぐに帳簿に計上する。 しかし、 多くの場合は もっと複雑である。 たとえば、 開発者である私のもとに、 顧客がその年の依頼料を支払いに 来たとする。 多額の報酬をこの時点で受領しても、実際のサービスは1年を通じて行われる のですぐに帳簿に計上できない場合がある。1つの手法として、 支払われた額の1/12 を各 月の報酬として計上するという方法がある。 こうすれば、本書を刊行したときに私のプログ ラミングスキルが大したことないのがわかって、顧客の方から Contract (契約) を取り下 げたときにも対処することができる。

RevenueRecognition のルールは、 多種多様でしかも定石がない。 法規や業界基準および 会社のポリシーなどによって定められている場合がある。 収益の追跡は、かなり難しく複雑 な問題となる。

ここで複雑性について掘り下げていくつもりはない。 そのかわり、ワープロ、 データベース、 それに表計算という3種類のProduct (製品) を販売している会社を想定してみることにする。 その会社のルールでは、ワープロは Contract (契約) にサインした時点で、すべての収益を直 ちに計上することができる。 表計算の場合は、 その時点で1/3、60日で 1/3 90日で 1/3、 データベースの場合はその時点で1/3、30日で1/3、60日で1/3をそれぞれ計上できるよう になっている。 これらのルールはあくまでも私の勝手な想定で、 どこかで使われているものを ベースにしているわけではない。 実際のルールはもっと合理的なはずである。

Product type Revenue Recognition Contract date signed 1 revenue 1 * amount date ContractにRevenue Recognition が設定され ている場合、 Contractの収益はその RevenueRecognitionの合計額と一致しな くてはならない。

図9.2 一簡略化された Revenue Recognition 用の概念モデル。 Contract ごとに複数の収益認識を持ち、 さまざまな 収益を認識する時間を示している。

第9章 ドメインロジック

9.1.4 | 例: Revenue Recognition (Java)

この例では、2つのトランザクションスクリプトを使用する 1つは、Contract のため の RevenueRecognition を計算するためのものであり、もう1つは、 Contract による収益 の何割が特定日までに認識できるかを示すものである。 データベース構造には、 Product 用、 Contract 用 RevenueRecognition 用の3つのテーブルがある。

CREATE TABLE products (ID int primary key, name varchar, type varchar) CREATE TABLE contracts (ID int primary key, product int, revenue decimal, dateSigned date)

CREATE TABLE revenueRecognitions (contract int, amount decimal, recognizedon date, PRIMARY KEY (contract, recognizedon))

1つ目のスクリプトは、特定日までに認識できる額を算出するものだ。これは2つの段階 で行うことができる。 まず、 Revenue Recognitions テーブル内の適切な行を選択し、次に 額の合計を算出する。

多くのトランザクションスクリプト設計では、データベース上で直接動作するスクリプト を使用し、 SQL コードを手続きに入れている。 ここでは、簡単なテーブルデータゲート ウェイを使ってSQLクエリーをラップしている。 また、 例はとてもシンプルであるため、 テーブルごとに1つずつゲートウェイを使用するのではなく、全体で1つのゲートウェイを 使用している。 ゲートウェイ上に適切な find メソッドを定義することができる。

class Gateway...

public ResultSet find Recognitions For (long contractID, MfDate asof) throws SQLException { PreparedStatement stmt = db.prepareStatement (find Recognitions Statement); stmt.setLong (1, contractID); stmt.setDate(2, asof.toSqlDate()); ResultSet result = stmt.executeQuery(); return result;

}

private static final String findRecognitions Statement = "SELECT amount " + FROM revenueRecognitions " + " WHERE contract = ? AND recognizedon <= ?"; private Connection db;

ここでスクリプトを使い、 ゲートウェイから渡された結果セットを基に合計を計算する。

class RecognitionService...

public Money recognized Revenue (long contractNumber, MfDate asof) { Money result = Money.dollars (0); try { ResultSet rs = db.find Recognitions For (contractNumber, asof); while (rs.next()) { } result result.add (Money.dollars (rs.getBigDecimal ("amount"))); return result; } catch (SQLException e) (throw new ApplicationException (e); }

このようなシンプルな計算であれば、メモリ上のスクリプトの代わりに、 金額を合計する 集合関数を使う SQL文の呼び出しを使うこともできる。

既存の Contract (契約) における Revenue Recognition (収益認識) の計算でも、似た ような分割を使っている。 サービス上のスクリプトがビジネスロジックを実行しているので ある。

class RecognitionService...

public void calculate Revenue Recognitions (long contractNumber) { try {

ResultSet contracts = db.findContract (contractNumber); contracts.next();

Money totalRevenue Money.dollars

(contracts.getBigDecimal ("revenue"));

MfDate recognitionDate = new MfDate (contracts.getDate ("dateSigned"));

String type contracts.getString("type");

if (type.equals("S")) {

Money allocation = total Revenue. allocate (3); db.insert Recognition

(contractNumber, allocation [0], recognitionDate); db.insertRecognition

(contractNumber, allocation [1],

recognitionDate.addDays (60));

db.insert Recognition

120

第9章 ドメインロジックパターン

(contract Number, allocation [2], recognitionDate.addDays (90)); } else if (type.equals("W")) { db.insert Recognition (contractNumber, total Revenue, recognitionDate); } else if (type.equals ("D")) { Money] allocation = total Revenue.allocate (3); db.insert Recognition (contract Number, allocation [0], recognitionDatedb.insert Recognition (contract Number, allocation [1], db.insert Recognition recognitionDate.addDays (30)); (contractNumber, allocation [2], recognitionDate.addDays (60)); } catch (SQLException e) (throw new ApplicationException (e

} ); }

ここでは、マネーを使って割り当てを実行していることに注目してほしい。金額を3つに 分割すると、額が合わなくなる可能性が高くなる。

テーブルデータゲートウェイではSQL もサポートしている。 まずは、 Contract 用の find テーブルについてである。

class Gateway...

public ResultSet find Contract (long contractID) } throws SQLException { PreparedStatement stmt = db.prepareStatement (findContractStatement); stmt.setLong (1, contractID); ResultSet result = stmt.executeQuery(); return result;

private static final String findContractStatement = "SELECT " + "FROM contracts c, products p " + "WHERE ID = ? AND c.product = p.ID";

次に、挿入用のラッパーについてである。

);

}

class Gateway...

public void insert Recognition (long contractID, Money amount, MfDate asof) throws SQLException {

PreparedStatement stmt = db.prepareStatement

(insert RecognitionStatement);

stmt.setLong (1, contractID);

stmt.setBigDecimal (2, amount.amount());

stmt.setDate(3, asof.tosqlDate()); stmt.executeUpdate();

}

private static final String insert RecognitionStatement = *INSERT INTO revenueRecognitions VALUES (?, ?, ?)";

Java システムでは、認識サービスは通常のクラスかセッション Bean となる。 これをドメインモデルで紹介している例と比べたとき、読者から見ると、この例の方がは るかにシンプルなものだと思うはずである。 すぐには想像がつかないかもしれないが、仮に ルールがもっと複雑になるとどうなるのか。 一般に使われる Revenue Recognition ルール は、実際にはもっと複雑でProduct ごとに違いがあるだけでなく、 日付によっても異なる (4月15日以前のContract の場合はあるルールが適応され、 それ以降の場合は別のルール が適応されるなどである)。 ルールが複雑になると、 トランザクションスクリプトでは、 貫した設計を維持できなくなってしまう。 そのため、私のようなオブジェクト指向主義者は、 このような状況でドメインモデルを好んで使うのである。 -

9.2 ドメインモデル

振る舞いとデータの両方を一体化させたドメインのオブジェクトモデル。

Contract recognized Revenue (date) calculateRecognitions * 1 Product calculate Recognitions (contract) 1 Recognition Strategy Complete Recognition Strategy

ビジネスロジックにおける最悪の場合とは、 そのロジックがとても複雑になっている場合 である。 ルールやロジックは、多くの異なる事例やさまざまな傾向の振る舞いを記述してい るが、このような複雑性に対処できるようにオブジェクは設計されている。 ドメインモデル は、相互に関連するオブジェクトが絡み合った関係を作成する。 各オブジェクトは、 企業の ような大きなオブジェクトも、1行だけのOrder (注文) フォームのような小さなオブジェ クトも、それぞれ意味がある個体を成す。

9.21 動作方法

アプリケーションでのドメインモデルの使用は、 対象となるビジネスエリアをモデル化し たオブジェクトのレイヤ全体を挿入するということである。 ビジネスにおけるデータをモデ ル化するオブジェクトもあれば、 ビジネスで使用するルールを把握するオブジェクトもある。 ほとんどの場合、データとプロセスを結合し、 対象となるデータと接近しているプロセスを クラスタ化する。

オブジェクト指向ドメインモデルは、データベースモデルと似ているように見える場合が ある。 しかしここには大きな違いがある。 ドメインモデルではデータとプロセスが一体化さ れ、複数値属性や複雑に絡み合う関係があり、さらに継承が使われるのである。

その結果、 ドメインモデルには2つの形式があることがわかる。 シンプルなドメインモデ ルは、見た目はデータベース設計とよく似ていて、ほとんどがデータベーステーブルごとに 1つのドメインオブジェクトを持つ形式になっている。 一方、豊富なドメインモデルは見た 目もデータベース設計とは異なり、継承、 ストラテジー その他の[Gang of Four] パターン や、さらには相互に関連する小さなオブジェクトが複雑に絡み合う構造を持っている。 豊富 なドメインモデルは、複雑なロジックを扱うのには適しているが、データベースにマッピン グするのは難しい。 シンプルなドメインモデルではアクティブレコードを利用できるが、 豊 富なドメインモデルではデータマッパーが必要となる。

ビジネスの振る舞いは頻繁に変更されるものなので、 レイヤを簡単に修正、 構築、テスト できるということは重要である。 そのため、ドメインモデルとシステム内の他のレイヤとの 結合は最小限に抑えることになる。 多くのレイヤ化パターンでも示されているように、 ドメ インモデルとシステム内のその他の部分の依存性はできる限り少なくしておくべきである。

ドメインモデルは、いくつかの異なる領域で使用することができる。 最もシンプルなス コープはシングルユーザアプリケーションである。 アプリケーションでは、オブジェクトグ ラフ全体がファイルから読み取られ、 メモリ内に読み込まれる。 デスクトップアプリケー ションであればこの方法も良いが、 多層のISアプリケーションでは一般的ではない。 単に オブジェクトの数が多すぎるからである。 すべてのオブジェクトをメモリに入れると、 メモ リ消費量が多くなると同時に時間もとてもかかる。 オブジェクト指向データベースが優れて いるところは、メモリとディスク間でオブジェクトを移動しているときに、 オブジェクトを メモリに入れる作業を行っているかのような印象を与える点である。

オブジェクト指向データベースがない場合は、 各自で実行する必要がある。 セッションで は、関連するすべてのオブジェクトのオブジェクトグラフが使われる。 このオブジェクトグ ラフは、確実にすべてのオブジェクトを含むわけではなく、 またすべてのクラスを含むこと も普通はない。 したがって、 一連の Contract は、 作業セット内の Contract によって参照 する Product だけを対象にしている。 Contract と RevenueRecognition オブジェクトに関 する計算を実行する場合は、 Product オブジェクトは対象にならない場合がある。 何をメモ リに入れるかはデータベースマッピングオブジェクトによって決まる。

サーバの呼び出しの間に同じオブジェクトグラフが必要な場合、サーバステートをどこか に保存する必要がある。 この点についてはサーバステートの保存についての項目(第6章) で述べている。

ドメインロジックを使用する場合に気をつけることは、 ドメインオブジェクトの拡大であ る。 Order を処理する画面を構築する際、 Order の振る舞いの中には、画面のためだけに 必要なものを含んでしまうことに注意すべきである。 Order の中に入れてしまうと、 Order クラスが肥大化してしまうリスクを背負い込むことになる。 特定の状況でしか使わないもの で膨らんでしまうので、 何らかの責任が一般的か否かを検討する。 一般的な場合、その責任

は Order クラスに置かれ、そうでない場合、責任は特定用途向けのクラスに置かれること になる。 特定用途向けのクラスは、トランザクションスクリプトまたはプレゼンテーション 自体の場合がある。

特定の状況での振る舞いを別にすると、 重複の問題が発生する可能性がある。 Order とは 違う振る舞いは目に付きにくく、 気付かずに重複させてしまうことがある。 重複により、 複 雑性を増すだけでなく一貫性も失われる。 しかし、肥大化は思ったほど頻繁には起こらない。 起こっても、比較的簡単に見つけることができ、 修復も難しいものではない。 特定の状況で の振る舞いを別にしないことを推奨する。 通常のオブジェクトにすべての特定の状況での振 る舞いを入れ、肥大化が問題となった場合は、 それを修復すればよいのである。

Java での実装

J2EE でのドメインモデルの開発に関しては、 常に熱い議論が起こる。 J2EEの 解説書や教材の多くでは、 エンティティ Bean を使ってドメインモデルを開発する ように推奨しているが、この手法には深刻な問題がある。 少なくとも現行の (バー ジョン 2.0) 仕様は問題である。

エンティティ Bean は、 CMP (Container Managed Persistence:コンテナ管 理の永続化機構) を使用する場合、 大変便利である。 エンティティ Bean を CMP なしで使うのはほとんど意味がないと言ってよい。 しかし、 CMP はオブジェクト リレーショナルマッピングが制限された形態のものであり、 豊富なドメインモデル で必要なパターンの多くはサポートできないというのが現実である。

エンティティ Bean は、 再入可能ではない。 つまり、 あるエンティティ Bean か ら別のオブジェクトを呼び出した場合、 そのオブジェクトが最初のエンティティ Bean を呼び出すことはできないということである。 豊富なドメインモデルでは、 この再入可能性をよく使うので、これがないと不利になる。 再入可能な振る舞い を見つけにくいというのも悪条件である。 このことから、 あるエンティティ Bean から別のエンティティ Bean を呼び出すべきではないという人もいる。 呼び出しを しないと再入可能性の問題は回避できるが、ドメインモデルを使うメリットは大い に損なわれる。

ドメインモデルは、細かいインタフェースを持つ細かいオブジェクトを使うべき である。 エンティティ Bean は、リモート呼び出し可能な場合もある (バージョン 2.0より前のバージョンはそうであった)。 細かいインタフェースを使ってリモー トオブジェクトを取得すると、 パフォーマンスは劣化する。 ドメインモデルでは、 エンティティ Bean に対してローカルインタフェースだけを使用して、簡単に問題 を回避できる。

エンティティ Bean を使うには、コンテナおよび接続されているデータベースが

必要である。 これにより構築に要する時間が長くなるだけでなく、 テストはデー タベースに対して行う必要があるので、テストに要する時間も長くなる。 さらに エンティティ Bean はデバッグしにくい

通常のJava オブジェクトを使うという方法もある。 この方法には多くの人が驚 くようだが、 EJBコンテナ内では通常のJava オブジェクトを使えないと思ってい る人が意外にも多いのには驚かされる。 Java オブジェクトの影が薄い理由は、名 称が悪いことだ。 そこで、2000年に講演の原稿をまとめているときに、 Rebecca Parsons Josh Mackenzie と私で考え出したのがPOJO (plain old Java objects 「POJO ドメインモデル」は簡単に統合でき、 構築も簡単で、 テスト も EJBコンテナの外で行え、 しかもEJB に依存していない (これが、 EJB ベン ダーがこのEJB 形態を推奨しない理由かもしれない)。

私の見解では、比較的ニーズの低いドメインロジックを使用する場合、 エン ティティ Bean をドメインモデルとして使うことは可能である。 この場合、 データ ベースとシンプルな関係にあるドメインモデルを構築できる。 継承、 ストラテジー、 使いやすいパターンを持つより豊富なドメインロジックがある場合、 POJO ドメ インモデルとデータマッパーや商用ツール、 あるいは自作のレイヤを使う方が賢明 である。

EJB を使う上での最大の悩みは、扱うのがとても複雑なドメインモデルを探す ことと、実装環境の詳細からできるだけ独立させておくことである。 EJB により、 読者はドメインモデルについて考えざるを得ない。 つまり、 ドメインとEJB 環境 について配慮する必要があるのだ。

9.2.2 使用するタイミング

ドメインモデルの使用法が大きな課題であるために難しいのであれば、いつ使用すべきか という問題も単純で漠然としたアドバイスにしかならないため、 答えるのが難しい。 すべて はシステム内の振る舞いの複雑性による。 妥当性確認、 計算、 派生などを含め、複雑で頻繁 に変更されるビジネスルールを使っている場合、 オブジェクトモデルで対処することがある。 一方で、 簡単な非ヌルチェックと2つの合計を計算する場合、 トランザクションスクリプト の方が適切である。

開発チームが、 ドメインオブジェクトを扱うスキルがあるか否かも重要な要素となってく る。ドメインモデルの設計と使用方法を学習するのは有意義なことで、 オブジェクト使用の パラダイムシフトに関して多くの論文が執筆されることになった。 ドメインモデルに慣れる までには相当の訓練と学習を必要とするが、一旦慣れると、よほどシンプルなケースでない 限りトランザクションスクリプトに戻ろうとするユーザはいないことがわかる。

6

ドメインモデルを使う場合、 データベースの相互作用で私がまず選択するのがデータ マッパーである。これで、 ドメインモデルがデータベースに依存していない状態を維持でき あるため、ドメインモデルとデータベースのスキーマが異なる場合に最適な手法になる。

ドメインモデルを使う際は、 サービスレイヤの使用を検討し、 ドメインモデルが固有の API を取得できるようにする。

9.2.3 | 参考文献

オブジェクト指向設計に関するほとんどの書籍でドメインモデルについて触れている。 オ ブジェクト指向開発として参照されるのは、大半がドメインモデルの使用法についてだから である。

オブジェクト指向設計の入門書的なものを探しているのなら、 [Larman]を推奨する。 ド メインモデルの例を探しているのなら、 [Fowler AP]が参考になるだろう。 [Hay] にもリ レーショナルコンテキストの優れた例が紹介されている。 優れたドメインモデルを構築する には、オブジェクトに関する概念的な考え方を理解しておく必要がある。 これについては、 [Martin and Odell]を勧める。 豊富なドメインモデルやその他のオブジェクト指向システム

で見られるパターンを理解するには、必ず[Gang of Gour]を読んでおくべきである。

Eric Evans も、最近では、ドメインモデルの構築に関する書籍 Evans)を執筆中だ 【訳注】。 私は本書執筆中のためまだ初期段階の原稿しか見ていないが、内容はかなり充実しているよ うである。

9.2.4 | 例: RevenueRecognition (Java)

ドメインモデルを説明する際の最大の悩みの1つは、読者が理解できるようにシンプルな 例を示すことである。 しかし、シンプルさのためにドメインモデルの力が隠れてしまうこと がある。 その力を評価できるのは、 複雑なドメインを扱ったときである。

しかし、紹介する例ではドメインモデルを使用する理由を正しく評価できなくても、 大体 どんなものかは伝えられるだろう。 したがって、 トランザクションスクリプトで使用したと きと同じ、 Revenue Recognition の例を使うことにする。

この簡単な例 (図9.3) では、 すべてのクラスに振る舞いとデータの両方が含まれている のにまず気付くだろう。 シンプルな Revenue Recognition クラスでさえ、 オブジェクト値 が特定日に認識されるかどうかがわかる簡単なメソッドを含んでいる。

【注】2003年に 「Domain-Driven Design」 という書名で刊行された。

class RevenueRecognition...

private Money amount; private MfDate date; public RevenueRecognition (Money amount, MfDate date) } this.amount = amount; this.date = date; public Money getAmount() { } return amount; boolean isRecognizableBy (MfDate asOf) { return asof after (date) || asof.equals (date); }

{

どれだけの収益が特定日に認識できるかの計算では、 Contract と RevenueRecognition の両方のクラスが使用される。

class Contract...

();

private List revenueRecognitions = new ArrayList (); public Money recognized Revenue (MfDate asof) { Money result = Money dollars (0); Iterator it = revenueRecognitions.iterator(); while (it.hasNext()) { ) RevenueRecognition r = (RevenueRecognition) it.nextif (r.isRecognizableBy (asOf)) result = result.add(r.getAmount()); return result; }

ドメインモデルで共通して見られるのは、複数のクラスが最もシンプルなタスクでも相互 作用する方法である。 この方法では、 オブジェクト指向プログラムで膨大な時間を掛けてク ラスからクラスへと探し続けなくてはならないというストレスを引き起こすことがある。た だし、これには多くのメリットがある。 特定の日までに何かを認識できるかどうかという決 定がより複雑になったとき、 または他のオブジェクトがその決定を知る必要が出てきたとき に、価値が生まれる。 知る必要があるオブジェクトに振る舞いを含めておけば、重複を防ぐ ことができ、異なるオブジェクト間での結合も軽減する。

28

第9章 ドメインロジックパターン

revenue whenSigned Contract recognized Revenue (date): Money calculateRecognitions 1 * RevenueRecognition amount: Money date * 1 Product |calculate Recognitions (Contract) * 1 RecognitionStrategy calculateRevenue Recognitions (Contract) isRecognizableBy (date) CompleteRecognitionStrategy calculateRevenue Recognitions (Contract) Three WayRecognitionStrategy firstRecognitionOffset secondRecognitionOffset calculateRevenueRecognitions (Contract)

図 9.3 ドメインモデル用クラス例のクラス図

これら RevenueRecognition オブジェクトの計算と作成を見ると、 多くの小さなオブジェ クトという考えがさらに見えてくる。この場合、計算と作成は顧客で始まり、 Product を通 じてストラテジー階層へと渡される。 このストラテジーパターン [Gang of Four] はよく知ら れているオブジェクト指向パターンで、複数の操作を小さなクラス階層で組み合わせること ができる。 Product の各インスタンスは RecognitionStrategy の1つのインスタンスと繋 がっていて、 Revenue Recognition を計算するのに使用するアルゴリズムを決定する。 2つ の異なるケースのために、2つの RecognitionStrategy のサブクラスが用意されている。 コードの構造は次のようになる。

class Contract....

private Product product; private Money revenue;

FonStrategy

(int firstRecognitionOffset, int second RecognitionOffset)

(

this.firstRecognitionoffset = firstRecognitionoffset; this.secondRecognitionOffset = secondRecognitionOffset;

void calculate Revenue Recognitions (Contract contract) { Money [] allocation = contract.getRevenue().allocate (3); contract.addRevenue Recognition (new Revenue Recognition

(allocation [0], contract.getWhenSigned())); contract.addRevenue Recognition (new Revenue Recognition (allocation [1], contract.getWhenSigned().addDays (firstRecognitionOffset)));

contract.addRevenue Recognition (new Revenue Recognition (allocation [2], contract.getWhenSigned ().addDays (secondRecognitionoffset)));

ストラテジーの大きな価値は、アプリケーションを拡張できるプラグポイントを、 整理さ れた状態で提供するという点である。 新たな Revenue Recognition アルゴリズムを追加す るということは、新たなサブクラスを作成し、 calculateRevenueRecognitions メソッド をオーバーライドすることになる。 アプリケーションのアルゴリズムの振る舞いを拡張する 際、 簡単に行えるようにするものである。

Product を作成したら、該当するストラテジーオブジェクトに接続させればよい。接続は テストコードの中で行っている。

class Tester...

private Product word = Product.newWordProcessor ("Thinking Word"); private Product calc = Product.newspreadsheet ("Thinking Calc"); private Product db = Product.newDatabase("Thinking DB");

一度すべてをセットアップしてしまえば、認識される収益の計算では Strategy サブクラ スに関する知識は必要なくなる。

class Contract...

public void calculateRecognitions() { ) product.calculate RevenueRecognitions (this);

}

private MfDate whenSigned; private Long id; public Contract (Product product, Money revenue, MfDate whenSigned) ( this.product product; this.revenue revenue; this. whenSigned = whenSigned;

class Product...

private String name; private RecognitionStrategy recognitionStrategy; public Product (String name, RecognitionStrategy recognitionStrategy) ( this.name name; this.recognitionStrategy recognition Strategy;

} public static Product newWordProcessor (String name) { } return new Product (name, new CompleteRecognitionStrategy()); public static Product newSpreadsheet (String name) { } return new Product (name, new ThreewayRecognitionStrategy (60, 90)); public static Product newDatabase (String name) { return new Product (name, new ThreewayRecognitionStrategy (30, 60));

ecognitionStrategy...

ct void calculateRevenue Recognitions (Contract contract);

mpleteRecognition Strategy...

calculate Revenue Recognitions (Contract contract) { ntract.addRevenue Recognition (new Revenue Recognition ontract.getRevenue (), contract.getWhenSigned()));

ThreewayRecognitionStrategy...

rivate int first RecognitionOffset; rivate int secondRecognitionOffset; public ThreewayRecognitionStrategy

(int firstRecognitionOffset, int secondRecognitionOffset)

this.firstRecognitionOffset = firstRecognitionOffset; this.secondRecognitionOffset = secondRecognitionOffset;

}

void calculate Revenue Recognitions (Contract contract) { Money [] allocation = contract.getRevenue().allocate (3); contract.addRevenue Recognition (new Revenue Recognition

(allocation[0], contract.getWhenSigned())); contract.addRevenue Recognition (new Revenue Recognition (allocation [1], contract.getWhenSigned ().addDays (firstRecognitionOffset)));

contract.addRevenue Recognition (new Revenue Recognition

(allocation [2], contract.getWhen Signed ().addDays (secondRecognitionOffset)));

ストラテジーの大きな価値は、アプリケーションを拡張できるプラグポイントを、 整理さ れた状態で提供するという点である。 新たな Revenue Recognition アルゴリズムを追加す るということは、新たなサブクラスを作成し、 calculateRevenueRecognitions メソッド をオーバーライドすることになる。 アプリケーションのアルゴリズムの振る舞いを拡張する 際、 簡単に行えるようにするものである。

Product を作成したら、 該当するストラテジーオブジェクトに接続させればよい。 接続は テストコードの中で行っている。

class Tester...

private Product word = Product.newWordProcessor ("Thinking Word"); private Product calc = Product.newspreadsheet ("Thinking Calc"); private Product db = Product.newDatabase ("Thinking DB");

一度すべてをセットアップしてしまえば、認識される収益の計算では Strategy サブクラ スに関する知識は必要なくなる。

class Contract...

public void calculate Recognitions () { ) product.calculate RevenueRecognitions (this);

private MfDate whenSigned;

9 ドメインロジックパターン

private Long id; public Contract (Product product, Money revenue, MfDate whenSigned) ( } this.product product; this.revenue = revenue; this. whenSigned whenSigned;

class Product...

private String name;

private RecognitionStrategy recognitionStrategy;

public Product (String name, RecognitionStrategy recognitionStrategy) ( this.name name;

this.recognitionStrategy = recognitionStrategy;

public static Product newWord Processor (String name) {

return new Product (name, new CompleteRecognitionStrategy());

}

public static Product newSpreadsheet (String name) { return new Product (name, new ThreeWayRecognitionStrategy (60, 90));

}

public static Product newDatabase (String name) { return new Product (name, new ThreeWay RecognitionStrategy (30, 60));

class Recognition Strategy...

abstract void calculate Revenue Recognitions (Contract contract);

class CompleteRecognition Strategy...

void calculate Revenue Recognitions (Contract contract) { contract.addRevenue Recognition (new Revenue Recognition (contract.getRevenue (), contract.getWhenSigned ()));

class ThreewayRecognitionStrategy...

private int first RecognitionOffset; private int secondRecognitionOffset; public ThreewayRecognitionStrategy

130

(int firstRecognitionOffset, int secondRecognitionOffset)

(

this.firstRecognitionoffset = firstRecognitionOffset; this.secondRecognitionOffset = secondRecognitionOffset;

}

void calculate Revenue Recognitions (Contract contract) { Money [] allocation = contract.getRevenue() allocate (3); contract.addRevenue Recognition (new Revenue Recognition

(allocation [0], contract.getWhenSigned())); contract.addRevenue Recognition (new Revenue Recognition (allocation [1], contract.getWhenSigned ().addDays (firstRecognitionOffset)));

contract.addRevenue Recognition (new Revenue Recognition (allocation [2], contract.getWhenSigned ().addDays (secondRecognitionoffset)));

ストラテジーの大きな価値は、アプリケーションを拡張できるプラグポイントを、整理さ れた状態で提供するという点である。 新たな Revenue Recognition アルゴリズムを追加す るということは、 新たなサブクラスを作成し、 calculateRevenueRecognitions メソッド をオーバーライドすることになる。 アプリケーションのアルゴリズムの振る舞いを拡張する 際、 簡単に行えるようにするものである。

Product を作成したら、 該当するストラテジーオブジェクトに接続させればよい。 接続は テストコードの中で行っている。

class Tester...

private Product word = Product.newWordProcessor ("Thinking Word"); private Product calc = Product.newspreadsheet ("Thinking Calc"); private Product db = Product.newDatabase ("Thinking DB");

一度すべてをセットアップしてしまえば、認識される収益の計算では Strategy サブクラ スに関する知識は必要なくなる。

class Contract...

public void calculateRecognitions() ( product.calculateRevenue Recognitions (this);

}

class Product...

void calculateRevenue Recognitions (Contract contract) { recognitionStrategy.calculate Revenue Recognitions (contract); }

オブジェクトからオブジェクトへと連続的に連携するオブジェクト指向の習性により、 振 る舞いは処理に最も適しているオブジェクトへと移動するが、これにより条件分岐を持つ振 る舞いの多くも解決することができる。 この計算式には条件分岐が含まれていないことがわ かる。 決定パスの設定は、適切なストラテジーでProduct を作成する際に行う。 すべてが このように結合されると、アルゴリズムは単純にパスに従うようになる。 類似の複数の条件 分岐がある場合、ドメインモデルはとても適していると言える。 類似条件がオブジェクト構 造自体に抜き出されるからである。 これにより、 複雑性はアルゴリズムからオブジェクト間 の関係に移行することになる。 ロジックが似ているほど、システムの異なる部分で使用され る同じネットワークの関係が明らかになる。 どのような収益認識用のアルゴリズムも、この 特定のオブジェクトネットワークに従うことができる。

例では、オブジェクトがデータベースからどのように取得され作成されるかについて一切 触れていないが、それにはいくつかの理由がある。 まず、 ドメインモデルをデータベースに マッピングするのは通常難しいので、ここでは例を紹介しない。 次に、 多くの点でドメイン モデルでは、上位レイヤやドメインモデルで作業するユーザからデータベースを隠すことに 意義がある。 したがって、ここでデータベースを隠すことは、 このような環境でプログラム することを表している

1 32

第9章 ドメインロジックパターン

9.3 テーブルモジュール

データベーステーブルかビューのすべての行に関するビジネスロジックを扱うシングル インスタンス。

Contract Calculate Recognitions (ID) Product GetProductType (ID) Revenue Recognition Insert (ID, amount, date) RecognizedRevenue (contractID, date)

オブジェクト指向の鍵となるメッセージの1つは、メッセージを使用する振る舞いとデー タをバンドルしているという点にある。 従来のオブジェクト指向の手法は、ドメインモデル のように、 一意性を持つオブジェクトをベースにしている。 つまり、 Employee (従業員) クラスがある場合、クラスのどんなインスタンスも特定の Employee と一致するのである。 ある Employee を参照すると、 操作の実行、 関係の追跡、 そのEmployee についてのデー タの収集を行うことができるので、 この仕組みは便利なものとなる。

ドメインモデルが抱える問題の1つに、リレーショナルデータベースとのインタフェース がある。 この手法ではたいていリレーショナルデータベースを無視している。その結果、 データベースからのデータの出し入れに相当なプログラミングが必要となる場合があり、 2 つの異なるデータ表現を変換することになる。

テーブルモジュールは、データベース内のテーブル1つにつき1つのクラスを持つドメイ ンロジックを構築し、クラスの1つのインスタンスにはデータに対して動作する各種の手続 きが含まれる。 ドメインモデルとの主な違いは、 多くの Order がある場合、 ドメインモデ ルでは1つのOrder に1つのOrder オブジェクトが使われるが、テーブルモジュールでは、 1つのオブジェクトですべてのOrder を扱うという点である。

9.3.1 動作方法

テーブルモジュールのメリットは、データと振る舞いを1つのパッケージにできると同時 に、リレーショナルデータベースのメリットを活かせるという点にある。 表面的にはテーブ ルモジュールはほとんどオブジェクトと同様に見える。 最大の違いは、作業対象となるオブ ジェクトに対する一意性の概念がないという点である。 つまり、 ある Employee の住所 (address) を取得したい場合、 anEmployeeModule.getAddress (long employeeID) と いったメソッドを使うことになる。 特定の Employee に対して処理を行う場合は、常に何 らかの一意性のある参照を渡す必要がある。 この一意性のある参照はデータベース内で使用 されているプライマリキーであることが多い。

テーブルモジュールはテーブル指向のバッキングデータ構造で使用する。 テーブル形式の データは、 通常 SQL 呼び出しの結果であり、 SQL テーブルに似たレコードセット内に格納さ れる。 テーブルモジュールでは、データに対して動作する明示的なメソッドベースのインタ フェースを利用できる。 振る舞いとテーブルのグループ化により、カプセル化の多くのメリッ トが得られる。 カプセル化では、振る舞いが作業対象のデータに近くなるからである。

有効な作業を行うために、複数のテーブルモジュールからの振る舞いが必要になることも ある。 多くの場合、 複数のテーブルモジュールが、 同じレコードセットを操作することにな る (図9.4)。

テーブルモジュールの最も明確な例は、データベース内のテーブルごとに1つずつこの テーブルモジュールを使うことである。 しかし、 データベース内で凝ったクエリーやビュー を使っている場合は、 複数のテーブルモジュールを使うこともできる。

new (theDataSet) Contract calculateRecognitions (contractID)| new (the DataSet) Product |new (theDataSet) | getProductType (productID) * insert Revenue Recognition

一複数のテーブルモジュールを1つのレコードセットと協調することができる。

34

第9章 ドメインロジックパターン

図9.4

テーブルモジュールは、インスタンスの場合もあれば、静的メソッドが集まったものの場 合もある。 インスタンスのメリットは、 クエリーの結果など既存のレコードセットでテーブ ルモジュールを初期化できる点である。 その後、 インスタンスを使ってレコードセット内の 行を操作できる。 インスタンスは継承の使用も可能にするので、 通常のContract に振る舞 いを追加して急ぎの Contract モジュールを作成することもできる。

テーブルモジュールでは、 クエリーをファクトリメソッドとして含むことができる。 テーブルデータゲートウェイを使うという方法もあるが、この場合、 設計内に余計なテー ブルデータゲートウェイクラスとメカニズムが含まれてしまうことになる。 一方、異なる データソースからのデータに対して1つのテーブルモジュールを使えるというメリットも ある。 データソースに対して異なるテーブルデータゲートウェイが使われるからである。

テーブルデータゲートウェイを使用する場合、 アプリケーションはまずテーブルデータゲー トウェイを使ってレコードセット内のデータをまとめる。 次に、レコードセットを引数にした テーブルモジュールを作成する。 複数のテーブルモジュールからの振る舞いが必要な場合も、 同じレコードセットから作成することができる。 作成したテーブルモジュールは、レコード セット上でビジネスロジックを実行し、修正されたレコードセットをプレゼンテーションに渡 して表示したり、 テーブルを認識するウィジェットで編集したりできるようにする。

presentation request data record set update (modified record set) table data gateway find record set select database table module apply domain logic (record set) validate (modified record set) update (modified record set) update

図 9.5 テーブルモジュールの周りのレイヤに対する一般的な相互作用

ウィジェットは、レコードセットがリレーショナルデータベースから直接来たのか、 テー ブルモジュールが途中でデータを操作したのかは判断できない。 GUI での修正後、 データ セットは妥当性確認のためにテーブルモジュールに戻ってから、 データベースに保存される。 このスタイルのメリットの1つに、データベースに行かなくてもメモリ内にレコードセット を作成してテーブルモジュールをテストできるという点がある。

パターン名にテーブルが使われているように、データベース内の1つのテーブルに対して 1つのテーブルモジュールを使用する。 これは最初の概算ではあるが、 厳密には完全に正し いというわけではない。一般に使用されるビューやその他のクエリーでもテーブルモジュー ルは便利なものとなる。 実際、 テーブルモジュールの構造は、データベース内のテーブル構 造よりも、 ビューやクエリーなども含めたアプリケーションで認識される仮想テーブルに依 存したものとなっている

9.3.2 使用するタイミング

テーブルモジュールは、ほとんどがテーブル指向のデータをベースにしたものなので、レ コードセットを使ってテーブル形式のデータにアクセスしている場合に使うのは理にかなっ ていると言える。 また、データ構造がコードのほぼ中心に位置しているので、 データ構造へ のアクセス方法もできるだけシンプルなものにするべきである。

ただし、テーブルモジュールでは、複雑なロジックを構築する際にオブジェクトが持つ強 力なパワーは得られない。 インスタンス間での直接的な関係を築くことはできず、 ポリモー フィズムもうまく機能しない。 つまり、複雑なドメインロジックでは、ドメインモデルの方 が適しているということになる。 複雑なロジックを扱えるドメインモデルの機能性を取るか、 基盤となるテーブル指向のデータ構造と簡単に統合できるテーブルモジュールの統合性を取 るか、という問題になる。

ドメインモデル内のオブジェクトとデータベーステーブルが比較的類似している場合、 ア クティブレコードを使うドメインモデルの方が適しているだろう。 ドメインモデルとアク ティブレコードの組み合わせよりもテーブルモジュールの方が適しているのは、アプリケー ションのその他の部分が、共通のテーブル指向のデータ構造をベースにしている場合である。 Java 環境でテーブルモジュールをほとんど見かけないのはこのためである。 しかし、 行 セットがもっと広範に使われるようになれば、この状況も変わるかもしれない。

これまで目にしたこのパターンを使った最も有名な例は、 Microsoft COM の設計である。 COM (およびNET) では、レコードセットがアプリケーション内のデータの主要なリポジ トリになっている。レコードセットはUIに渡すことができ、 データを認識するウィジェッ トによって情報が表示される。 MicrosoftのADO ライブラリは、リレーショナルデータに レコードセットとしてアクセスしやすいメカニズムを提供している。この状況でテーブルモ

36

ジュールを使えば、 テーブル形式のデータに対する各種の要素の操作性を失うことなく、 上 手く体系化された方法でビジネスロジックをアプリケーションに組み入れることができる。

9.3.3 例: テーブルモジュールでの RevenueRecognition (C#)

ここで再びこれまでのドメインモデリングパターンで使用した RevenueRecognition の 例が登場する。 今回はテーブルモジュールを使用する。 簡単に復習しておこう。 ここでの課 問題は、Product の種類によってルールが異なる場合での Order の RevenueRecognition を 行うことである。この例では、ワープロ、 表計算、 データベースのProduct ごとに異なる ルールが定義されている。

テーブルモジュールは、ある種のデータスキーマをベースにしていて、 通常これはリレー ショナルデータモデルである (将来は、 XML モデルが似たような方法で使用されるように なるかもしれない)。 ここでは、図9.6 のリレーショナルスキーマを使用する。

このデータを処理するクラスは、どれもほとんど同じ形式になっていて、 テーブルごとに 1つのテーブルモジュールクラスが用意されている。 .NET アーキテクチャでは、データ セットオブジェクトは、データベース構造をメモリ上で表すものとなる。 つまり、 データ セット上で動作するクラスを作成するというのは理にかなっている。 各テーブルモジュール クラスはデータテーブルのデータメンバを持っている。 これは、 データセット内のテーブル に相当する.NET システムクラスである。 テーブル読み取り機能は、すべてのテーブルモ ジュールに共通しているのでレイヤスーパータイプでも使われている。

class TableModule...

protected DataTable table; protected TableModule (Dataset ds, String tableName) { } table = ds. Tables (tableName];

サブクラスコンストラクタは、正しいテーブル名でスーパークラスコンストラクタを呼び 出す。

class Contract...

public Contract (Dataset ds): base (ds,

"Contracts")

{

-table- -table- Contracts Products 1 "table" Revenue Recognitions ID: Number ID: Number Name: String whenSigned: Date Amount: Number * ID: Number Type: String amount: Number date: Date

図9.6 RevenueRecognition 用データベーススキーマ

これで、テーブルモジュールのコンストラクタにデータセットを渡すだけで新しいテーブ ルモジュールが作成できるようになる。

contract = new Contract (dataset);

ADO.NET のガイドラインによると、 データセットを作成するコードはテーブルモ ジュールから隔離される。

便利なのは、所定のプライマリキーでデータテーブル内の特定行に行ける C# インデク サーである。

class Contract...

public DataRow this [long key] { get { String filter = String.Format("ID = return table.Select (filter) [0]; } } (0), key);

機能の最初の部分では、 Contract の Revenue Recognition を計算し、 これにより RevenueRecognitions テーブルを更新する。 認識される額は、 Product の種類によって違 う。この振る舞いは、主にContracts テーブルからのデータを使っているので、 Contract クラスにメソッドを追加する。

class Contract...

public void Calculate Recognitions (long contractID) { DataRow contractRow = this [contractID]; Decimal amount = (Decimal) contractRow ["amount"]; RevenueRecognition rr = new RevenueRecognition (table.DataSet);

1 38

第9章 ドメインロジックパターン

Product prod = new Product (table. DataSet);

long prodID = GetProductId (contractID);

if (prod. Get Product Type (prodID) == ProductType.WP) { rr. Insert (contractID, amount, GetWhenSigned (contractID)); (DateTime)

} else if (prod. Get Product Type (prodID) == ProductType.SS) Decimal allocation = allocate (amount, 3); rr. Insert (contractID, allocation [0], (DateTime)

GetWhenSigned (contractID));

rr. Insert (contractID, allocation [1], (DateTime) GetWhenSigned (contractID). AddDays (60));

rr. Insert (contractID, allocation [2], (DateTime) GetWhenSigned (contractID). AddDays (90));

} else if (prod. Get Product Type (prodID) == ProductType.DB) { Decimal allocation = allocate (amount, 3);

rr. Insert (contractID, allocation [0], (DateTime)

GetWhenSigned (contractID));

rr. Insert (contractID, allocation [1], (DateTime) GetWhenSigned (contractID).AddDays (30));

rr. Insert (contractID, allocation [2], (DateTime) GetWhenSigned (contractID).AddDays (60));

} else throw new Exception("invalid product id");

}

private Decimal() allocate (Decimal amount, int by) ( Decimal lowResult = amount / by; lowResult Decimal. Round (lowResult, 2); Decimal highResult = lowResult + 0.01m; Decimal [] results = new Decimal [by]; int remainder = (int) amount % by; for (int i = 0; i < remainder; i++) results[i] = highResultfor (int i = remainder; i < by; i++) results [i] = lowResultreturn results;

通常はマネーを使うが、 バリエーションを持たせるために、ここでは Decimal を使った を示している。 割り当てメソッドは、マネーで使用しているものと似ている。

例実行するには、他のクラス上で定義されているいくつかの振る舞いが必要となる。 Product (製品) はタイプを知らせる必要があるが、 Product (製品) 用の enum と照合 テーブルを使って対処できる。

public enum ProductType (WP, SS, DB);

; ;

{

class Product...

public ProductType GetProductType (long id) { } String typeCode = (String) this[id] ["type"]; return (ProductType) Enum. Parse (typeof (ProductType), typeCode

GetProduct Type は、データテーブル内のデータをカプセル化している。 カプセル化をす べてのデータ列に対してするのか、それとも Contract の金額のように直接アクセスするか については、議論が分かれる。 一般的にカプセル化が推奨されているが、ここではシステム のさまざまな部分からデータセットに直接アクセスするという環境を前提にしているため適 さないので使用しない。 データセットがUI上に移動する際には、 カプセル化は行わない。 したがって、列アクセス機能は、文字列の Product 種類への変更などの追加機能が必要で ない限り、合理的ではない。

もう1つここで触れておきたいことがある。 それは、ここでは型指定されていないデータ セットを使っているという点だ。 多くのプラットフォームで一般的だからである。 当 然、.NET のしっかりと型指定されたデータセットを使うべきだと言う意見もある。 もう1つ追加する振る舞いは、 新たな Revenue Recognition レコードの挿入である。

class RevenueRecognition...

public long Insert (long contractID, Decimal amount, DateTime date) { } DataRow newRow = table. NewRow(); long id = GetNextID (); newRow["ID"] = id: newRow [ "contractID"] = contractID; newRow["amount"] = amount; newRow["date"] = String.Format("{0:s}", date); table.Rows.Add(newRow); return id;

このメソッドでもデータ行のカプセル化を少なくし、コードの繰り返しではなくメソッド を持たせている。

2つ目の機能は、所定の日付での Contract (契約) の RevenueRecognition を合計すると いうものである。これは RevenueRecognitions テーブルを使うので、 RevenueRecognition クラスでメソッドを定義している。

);

ドメインロジックパターン

0

class Revenue Recognition...

public Decimal Recognized Revenue (long contractID, DateTime asOf) { String filter = String.Format("ContractID = {0} AND date <= #(1:d) %", contractID, as0f); DataRow rows = table. Select (filter); Decimal result = 0m; foreach (DataRow row in rows) { result + (Decimal) row["amount"]; } return result;

上記の一部では、場所を示す項を定義し、操作するデータテーブルのサブセットを選択で きる ADO.NET の機能を効果的に活用している。 実際、 さらに掘り下げて集合関数を使う こともできる。

class Revenue Recognition...

public Decimal Recognized Revenue2 (long contractID, DateTime asof) { String filter = String.Format("ContractID = (0) AND date <#(1:d) % 23", contractID, as0f); String compute Expression = "sum (amount)"; Object sum = table.Compute (computeExpression, filter); return (sum is System. DBNull) ? 0 (Decimal) sum;

サービスレイヤ

(by Randy Stafford)

サービスのレイヤとアプリケーションの境界を定義する。 サービスは利用できる操作 セットを設定し、各操作に対するアプリケーションのレスポンスを調整するものである。

Data Loaders User Interfaces Service Layer Domain Model Data Source Layer RecognitionService Integration Gateways

エンタープライズアプリケーションでは、格納しているデータや実装しているロジックに 対して異なる種類のインタフェースを必要とする。 たとえば、データローダー、ユーザイン タフェース、 統合ゲートウェイなどである。 目的は異なるが、 インタフェースは、データへ のアクセスと操作やビジネスロジックの呼び出しにおいてアプリケーションと共通した相互 作用を必要とする場合がある。 この相互作用は、 複数のリソースにまたがるトランザクショ ンやアクションに対する複数のレスポンスの調整など複雑なものになることもある。 相互作 用ロジックを各インタフェース内で個別にエンコードした場合、 多くの重複が生じてしまう。

サービスレイヤは、アプリケーションの境界 Cockburn PloPJと利用できる操作セットを クライアントレイヤとのインタフェースという観点から定義している。 サービスレイヤはア プリケーションのビジネスロジックをカプセル化し、 トランザクションを制御し、 操作の実 装におけるレスポンスを調整する。

42

ドメインロジックパターン

9.4

9.4.1 動作方法

サービスレイヤは、上述の特性を侵害することなく、いくつかの異なる方法で実装するこ とができる。 実装方法の違いは、 サービスレイヤインタフェースに対する責任の割り当ては 現れている。 各種の実装方法を紹介する前に、 少し背景を紹介する。

9.4.1.1 ビジネスロジックの種類

トランザクションスクリプトやドメインモデル同様、 サービスレイヤもビジネスロジック を構成するパターンの1つである。 私も含めて設計者の多くは、 「ビジネスロジック」 を2種 類に分類する傾向がある。1つは、純粋に問題ドメイン (Contract の Revenue Recognition を算出するストラテジーなど)を扱う「ドメインロジック」 で、もう1つは、アプリケー ションの責任[Cockburn UC] (Revenue Recognition 計算における Contract 管理者への通 知やアプリケーションの統合など) を扱う 「アプリケーションロジック」 である。 アプリ ケーションロジックは「ワークフローロジック」と呼ばれることもあるが、 「ワークフロー」 の解釈については人によって意見が分かれる。

ドメインモデルは、ドメインロジックの重複を避けるという点と従来の設計パターンを 使って複雑性を管理するという点で、トランザクションスクリプトよりも好ましいとされる。 しかし、アプリケーションロジックを純粋なドメインオブジェクトクラスに入れることは、 いくつかの好ましくない事態を招くことにもなる。 まず、 ドメインオブジェクトクラスがア プリケーション固有のロジックを実装し、 アプリケーション固有のパッケージに依存すると、 アプリケーション間での再利用の可能性が低下する。 次に、両方の種類のロジックを同じク ラス内に混在させると、必要とされるワークフローツールなどへのアプリケーションロジッ クの再実装が難しくなる。 これらの理由から、 サービスレイヤでは多様な種類のビジネスロ ジックを個別のレイヤに組み込み、レイヤ化の通常のメリットを引き出し、 純粋なドメイン オブジェクトクラスをアプリケーション間で再利用できるようにする。

9.4.1.2実装バリエーション

2つの基本的な実装バリエーションには、ドメインファサード的手法と操作スクリプト手 法がある。 ドメインファサード手法では、 サービスレイヤはドメインモデル上の薄いファ サードのセットとして実装される。 ファサードを実装するクラスにはビジネスロジックは一 切実装されていない。 ビジネスロジックはすべてドメインモデルによって実装される。 薄い ファサードは、境界およびクライアントレイヤがアプリケーションと相互作用を行うための 操作群を設定する。 それがサービスレイヤの特徴である。

操作スクリプト手法では、 サービスレイヤはアプリケーションロジックを直接実装してい るが、 ドメインロジック用のカプセル化されたドメインオブジェクトクラスの委譲する厚い クラスのセットとして実装される。 サービスレイヤのクライアントが利用できる操作はスク

リプトとして実装され、関連するロジックの対象エリアを定義するクラスに一部の操作が体 系化される。 各クラスはアプリケーション 「サービス」 を形成するが、これは名前の最後に 「サービス」が付く種類のサービスでは一般的なものである。 サービスレイヤはこれらのア プリケーションサービスクラスによって構成され、 レイヤスーパータイプを拡張する。 さら に一定のルールや共通な振る舞いを抽出する。

9.4.1.3 リモートにするべきか否か

サービスレイヤクラスのインタフェースは、クライアントレイヤが利用できるアプリケー ション操作セットを宣言するので、 粗い粒度になっている。 インタフェースの粒度から見る と、サービスレイヤクラスはリモート呼び出しに適したものになる。

しかし、リモート呼び出しにはオブジェクトの分散を扱うという犠牲が伴う。 サービスレ イヤのメソッドシグネチャをデータ変換オブジェクトで扱えるようにするには、相当な追加 作業が必要となるため、 作業工数を軽視できない。 特に、複雑なドメインモデルと複雑な更 新ユースケース用の高度な編集 UIがある場合はなおさらである。 この作業は、 重要で困難 でもある。 おそらくオブジェクトリレーショナルマッピングの次にコストが掛かる困難な作 業であると言える。 分散オブジェクトデザインの第一法則 (P95 参照) を忘れないでほしい。

まず、ローカルで呼び出すことができ、 メソッドシグネチャがドメインオブジェクト内で 処理できるサービスレイヤから始めることを推奨する。 リモート性は (本当に) 必要になっ た時点で、 リモートファサードをサービスレイヤ上に置くか、 サービスレイヤオブジェクト にリモートインタフェースを実装することにより付加する。 アプリケーションが Web ペー スのUI か Web サービスベースの統合ゲートウェイを備えている場合、ビジネスロジック をサーバページや Web サービスとは切り離されたプロセスで実行しなくてはならないとい う決まりがあるわけではない。 事実、 同じ場所に配置する方法で始めれば、 拡張性を犠牲に することなく、開発労力と実行時のレスポンス時間を短縮することができる。

9.4.1.4 サービスと操作の特定

サービスレイヤ境界で必要な操作の特定はいたって簡単である。これらは、 サービスレイ ヤクライアントのニーズによって決定されるが、最も重要なもの (最初のものでもある)は ユーザインタフェースになる。 ユーザインタフェースは、アクタがアプリケーションで実行 したいユースケースをサポートするように設計されているので、 サービスレイヤ操作の特定 はユースケースモデルとアプリケーション固有のユーザインタフェースから始めるべきであ る。

残念だが実情は、エンタープライズアプリケーションのユースケースの多くは、ドメイン オブジェクトに対する退屈な 「CRUD」 (create, read、 update delete) ユースケースで ある。つまり、ドメインオブジェクトを作成し、集まったものを読み取り、更新するという

ことである。 私の経験では、ほとんどの場合、 CRUD ユースケースとサービスレイヤ操作 の間には1対1で一致するものが必ず存在する。

こうしたユースケースを実行するというアプリケーションの責任は重要である。 妥当性確 認は別にしても、アプリケーションにおけるドメインオブジェクトの作成、更新、削除は、 他のユーザや他の統合アプリケーションの通知をさらに必要とする。 サービスレイヤ操作に よって確実に調整、 実行しなくてはならない。

サービスレイヤの抽象化を特定して、 関連する操作をグループ化するのが簡単であればよ いのだが、このエリアにおける厳格な規定はない。 単なる曖昧なヒューリスティックスに過 ぎない。 とても小さなアプリケーションでは、アプリケーションそのものの名前を持つ1つ の抽象化だけで十分な場合がある。 私の経験では、大きなアプリケーションはいくつかの 「サブシステム」 に分割され、 それぞれがアーキテクチャレイヤの階層を垂直方向に切り 取ったものを含んでいる。 この場合、1つのサブシステムに1つの抽象化を持たせ、名前も サブシステムにちなんだものにするのが好ましい。 その他の可能性としては、ドメインモデ ル内の主なパーティションがサブシステムのパーティションと異なる場合は、 反映した抽象 化 (例: ContractsService、 ProductsService) や、 主だったアプリケーションの振る舞 いの名前にちなんだ抽象化などがある。

Java での実装

ドメインファサード手法と操作スクリプト手法のいずれの場合でも、サービスレ イヤクラスはPOJO またはステートレスセッション Bean として実装することが できる。ここでのトレードオフは、テストの容易性とトランザクション制御の容 易性になる。 POJO は、 実行するために EJB コンテナ内に配置する必要がないの でテストするのは簡単であるが、 POJO サービスレイヤを分散コンテナ管理トラン ザクションサービスに組み込むのは困難である。 特に、 サービス間での呼び出し 内では大変難しい。 一方のEJB は、 コンテナ管理分散トランザクション用の基本 的な能力は備えているが、 テストや実行ではコンテナ内に導入しなくてはならな い。 どちらでも好きな方を選択すればいい。

私なら、 サービスレイヤをJ2EE で適用する際は、 EJB 2.0 ステートレスセッ ション Bean によりローカルインタフェースを使用する、 または、 操作スクリプト 手法により POJO ドメインオブジェクトクラスに委譲させる。 EJB により提供さ れる分散コンテナ管理トランザクションがあるので、 ステートレスセッション Bean を使ってサービスレイヤを実装するのは、とても便利なものとなる。 また、 EJB 2.0 で登場したローカルインタフェースにより、 サービスレイヤで厄介なオブ ジェクトの分散問題を避けて価値あるトランザクションサービスを実行できる。

Java に関連して1つ触れておきたいことがある。 サービスレイヤとJ2EE バ

ターンの文献 [Alur et al.) と [Marinescu] で紹介されているセッションファサード のパターンとの違いである。 セッションファサードは、エンティティ Bean 上での リモート呼び出しが多すぎることによるパフォーマンス低下の回避をベースにし ている。 したがって、 ファサードエンティティ Bean をセッション Bean と記述し ている。一方のサービスレイヤは、規定の条件を抜き出すことで重複を避けて再利 用性を高めることをベースにしている。 それは、 高度なアーキテクチャパターン である。 サービスレイヤに影響を与えた Applicaation Boundary パターン [Cockburn PloP] は、 EJBよりも3年も前に登場している。 セッションファサード も本来はサービスレイヤと同類かもしれないが、 現在の名前や用途や提示の仕方が 示しているように、同じものではない。

9.4.2 使用するタイミング

サービスレイヤのメリットは、 多様なクライアントが利用できるアプリケーションの共通の 操作セットを定義する点、および各操作でのアプリケーションのレスポンスを調整するという 点である。 レスポンスには、複数のトランザクションリソースにまたがって、 しっかりと処理 される必要があるアプリケーションロジックも含まれる。 つまり、ビジネスロジックで複数の 種類のクライアントを使用したアプリケーションと複数のトランザクションリソースを含む ユースケースでの複雑なレスポンスでは、サービスレイヤをコンテナ管理トランザクションと 一緒に含むのは理にかなったことである。 非分散アーキテクチャでも同様である。

いつ使うべきでないかは、いとも簡単に答えられる。 アプリケーションのビジネスロジッ クが、(ユーザインタフェースなど) 1種類のクライアントしか持たず、ユースケースのレス ポンスにマルチトランザクションリソースが関連していない場合は、サービスレイヤは不要 である。この場合、ページコントローラを使って、 トランザクションの手動制御やレスポン スが必要な場合の調整やデータソースレイヤへの直接委譲などを行うことができる。

しかし、違う種類のクライアントやユースケースのレスポンスにおける別のトランザク ションリソースの考えが出てきたら、最初からサービスレイヤで設計した方が効率的である。

9.4.3 参考文献

サービスレイヤに関してはそれほど多くの先例があったわけではないが、 生みの親は Alistair Cockburn の Application Boundary パターン [Cockburn PloPJである。 リモー ト可能なサービスに関しては、 [Alpert, et al.jで分散システムにおけるファサードの役割に ついて紹介している。 これを、 [Alur et al. J と [Marinescu]のセッションファサードのブレ ゼンテーションと比較検討してみると面白い。 サービスレイヤ操作内で調整する必要がある

アプリケーションの責任に関しては、ユースケースを振る舞いの Contract として Cockburn が解説している [Cockburn UC]が大変役立つ。 初期段階におけるバックグラウ ンドのリファレンスは、 Fusion 方法論による 「システム操作」 [Coleman et al.] の認識で ある。

9.4.4 | 例: Revenue Recognition (Java)

ここではトランザクションスクリプトとドメインモデルのパターンと同じ Revenue Recognition 例を引き続き使って、 サービスレイヤを使用してどのようにしてアプリケー ションロジックを記述し、サービスレイヤ操作でのドメインロジックを委譲するかを紹介す る。ここでは操作スクリプト手法を使用し、 まずはPOJO を、次に EJB でサービスレイヤ を実装する。

デモンストレーションを作るにあたって、 シナリオを拡大していくつかのアプリケーショ コンロジックを含めている。 アプリケーションのユースケースの場合を考えてみよう。 Contract の Revenue Recognition が計算された際に、アプリケーションがそのイベントの 通知を電子メールで指定されたContract 管理者に送り、 メッセージ指向のミドルウェアを 使ってメッセージを発行し、 その他の統合アプリケーションに通知するという形で応答する 必要がある。

まずトランザクションスクリプトの例の RecognitionService クラスを変更してレイヤ スーパータイプを拡張し、いくつかのゲートウェイを使ってアプリケーションロジックを実 行する。 クラス図は図 9.7 のようになる。 RecognitionService はサービスレイヤアプリケー ションサービスの POJO 実装となり、 メソッドはアプリケーションの境界で利用できる2 つの操作を表している。

RecognitionService クラスのメソッドは操作のアプリケーションロジックを記述し、 ド メインロジックのためのドメインオブジェクトクラス (ドメインモデルの例からの)を委譲 する。

public class ApplicationService ( protected Email Gateway get Email Gateway() { } //return an instance of EmailGateway protected IntegrationGateway get IntegrationGateway () { //return an instance of IntegrationGateway } } public interface EmailGateway (

void sendEmailMessage (String toAddress, String subject,

+sendEmailMessage(in toAddress: String, in subject: String, in body: String): void

"interface" EmailGateway

+publishRevenueRecognitionCalculation(in contract: Contract): void

<<interface" IntegrationGateway

"uses"

+getintegationGateway(): IntegrationGateway

"uses"

RecognitionService

+getEmailGateway(): EmailGateway

ApplicationService

+calculateRevenue Recognitions (in contractNumber: long): void +recognized Revenue(in contractNumber: long, in asOf: Date): Money

Recognition Service POJO クラスダイアグラム

9.7

String body)

public interface IntegrationGateway {

void publishRevenue RecognitionCalculation (Contract contract);

public class RecognitionService

extends ApplicationService {

public void calculate Revenue Recognitions (long

}

contract Number) (

Contract contract = Contract.readForUpdate (contractNumber); contract.calculateRecognitions (); getEmailGateway().sendEmail Message (

contract.getAdministrator EmailAddress(), "RE: Contract %23" + contract Number,

contract" has had revenue recognitions calculated."); getIntegrationGateway () .publishRevenue RecognitionCalculation (contract);

public Money recognized Revenue (long contract Number, Date asOf) ( return Contract.read(contractNumber).recognized Revenue (asOf); } }

例には詳細が含まれていない。 Contract クラスがデータソースレイヤから詳細の番号で Contract を読み取る静的メソッドが実装されているというだけで十分である。 メソッドの1 つは読み取った Contract を更新することを意図した名前を持ち、 下層のデータマッパーが 読み取ったオブジェクトをたとえばユニットオブワークで登録できるようになっている。

トランザクション制御に関する詳細もこの例では省略する。 calculateRevenue Recognitions()メソッドは、本質的にはトランザクション的なものである。 それは、実行中に永続 的 Contract オブジェクトがRevenue Recognition の追加により修正され、 メッセージが メッセージ指向のミドルウェア内のキューに入れられ、 電子メールメッセージが送信される ことになるからである。 これらのレスポンスは、必ず正確に処理される必要がある。 Contract の変更が永続的なものにならなかった場合、 電子メールの送信や他のアプリケー ションへのメッセージの発行は行わないからである。

J2EE ブラットフォームでは、トランザクションリソースを使うステートレスセッション Bean としてアプリケーションサービス (およびゲートウェイ) を実装することで、 EJBコ ンテナに分散トランザクションを管理させることができる。 図9.8 は、 EJB 2.0 ローカルイ ンタフェースと「ビジネスインタフェース」 言語を使う RecognitionService の実装のク

}

}

-interface"

RecognitionService

+calculateRevenue Recognitions(in contractNumber: long): void +recognized Revenue(in contractNumber: long, in asOf: Date): Money

"interface" RecognitionServiceBean

RecognitionServiceBeanImpl

+calculateRevenue Recognitions (in contractNumber: long): void

+recognizedRevenue (in contractNumber: long, in asOf: Date): Money

図 9.8

RecognitionService EJB クラスダイアグラム

第9章 ドメインロジックパターン

"interface" javax.ejb.EJBLocalObject

"interface"

javax.ejb.SessionBean

ApplicationServiceBeanImpl

+getEmailService(): EmailService

+getIntegationService(): IntegrationService

ラスダイアグラムを示している。 この実装でもレイヤスーパータイプが使われているが、こ れは EJB ではアプリケーション固有メソッドに加え、 bean 実装クラスメソッドのデフォル ト実装が必要だからである。 EmailGateway と IntegrationGateway インタフェースもそれ ぞれのステートレスセッション Bean に対して「ビジネスインタフェース」であると想定す れば、 分散トランザクションの制御は calculateRevenueRecognitions と sendEmailMessage、 それに publishRevenueRecognitionCalculation メソッドをトラン ザクション可能なものとして宣言すれば得られることになる。 POJO 例からの RecognitionService はそのままRecognitionServiceBeanImp1 になる。

この例で重要なのは、サービスレイヤが操作のトランザクションのレスポンスを調整する のに操作スクリプトとドメインオブジェクトクラスの両方を使っている点である。 calculateRevenue Recognitions メソッドは、アプリケーションのユースケースで必要な レスポンスのアプリケーションロジックを記述しているが、 ドメインロジックはドメインオ ブジェクトクラスに委譲している。 ここでは、 サービスレイヤの操作スクリプト内での重複 ロジックを防ぐためのいくつかの技法も示している。 責任は、委譲を通じて再利用できるよ うに別々のオブジェクト (ゲートウェイなど) に組み込まれている。 レイヤスーパータイプ

は、こうしたその他のオブジェクトへのアクセスを簡単なものにしている。

中には、オブザーバーパターン [Gang of Four] を使った方がより洗練された状態で操作ス クリプトを実装できるという人もいるかもしれないが、ステートレスでマルチスレッドな サービスレイヤへのオブザーバーの実装は難しいものとなる。 私の考えでは、操作スクリプ トのオープンコードは、読みやすくシンプルである。

また、アプリケーションロジックの責任は、 Contract.calculateRevenueRecognitions () のようなドメインオブジェクトメソッド内や、データソースレイヤ内に実装できる ので、個別にサービスレイヤを設ける必要はないという意見もあるようである。 しかし、こ のような責任の配置はいくつかの理由からあまり好ましいものだとは思わない。 まず、ドメ インオブジェクトクラスはアプリケーション固有のロジックに実装されると (そしてアプリ ケーション固有のゲートウェイに依存する場合)、 アプリケーション間での再利用性が低下 する。これらはアプリケーションが関心のある問題ドメインの一部をモデル化するべきであ り、アプリケーションのすべてのユースケース責任を意味しているわけではない。次に、 ア プリケーションロジックをその目的だけのために (データソースレイヤではない) 「上位」 レイヤにカプセル化した場合、 レイヤの実装の変更(たとえば、ワークフローエンジンを使 用するなど) を助長することになる。

エンタープライズアプリケーションにおけるロジックレイヤの体系化バターンである サービスレイヤは、スクリプティングとドメインオブジェクトクラスを組み合わせ、両方 の適切な部分を活用できるようにしている。 サービスレイヤの実装においては、さまざま なバリエーションがある。 たとえば、ドメインファサードや操作スクリプト、 POJO か

セッション Bean、 または、 それら両方の組み合わせである。 サービスレイヤは、ローカル 呼び出し、リモート呼び出し、 またはその両方に対応するように設計できる。 最も重要な のは、このようなバリエーションに関係なく、パターンがアプリケーションのビジネスロ ジックのカプセル化実装の基礎になり、ロジックを各種クライアントから一貫して呼び出 せるという点である。

データソースのアーキテクチャに関するパタ

10.1 テーブルデータゲートウェイ

データベーステーブルに対して「ゲートウェイ」の役割を果たすオブジェクト。 1つの インスタンスがテーブル内のすべての行を処理する。

PersonGateway Find (id) Record Set findWithLastName(String): RecordSet Update (id, lastname, firstname, numberOfDependents) Insert (lastname, firstname, numberOfDependents) Delete (id)

アプリケーションロジックとSQL を組み合わせる場合、 さまざまな問題が引き起こされ る可能性がある。 数多くの開発者は SQL に不慣れであり、たとえ慣れていたとしても、正 しく記述できるとは限らない。 データベース管理者は、データベースの調整方法と拡張方法 を把握するため、 SQL を簡単に見つけ出せなければならない。

テーブルデータゲートウェイは、1つのテーブルまたはビューにアクセス (選択、挿入、 更新、削除) するための SQL をすべて保持している。 他のコードはそれぞれのメソッドを 呼び出すことで、データベースとの相互作用を行う。

10.1.1 動作方法

テーブルデータゲートウェイは、データベースからデータを取得するための数種類の find メソッドと、 update, insert, delete の各メソッドから構成されるシンプルなインタ フェースを備えている。 各メソッドは入力引数をSQL 呼び出しにマッピングし、 データ ベース接続に対してそのSQL を実行する。 テーブルデータゲートウェイは、データの受け

渡しがその役割であるためステートレスである。

テーブルデータゲートウェイの特殊な点は、クエリーからの情報を返す方法にある。 シン プルなID を利用した検索 (find-by-ID) クエリーでさえ、 複数のデータ項目を返すことが できる。 複数の項目を返すことが可能な環境においては、単一の行に対してもクエリーを発 行することができる。 多くの言語では単一の値だけを返すが、ほとんどのクエリーは複数の 行を返す。

1つの選択肢としては、マッピングのようなシンプルなデータ構造を返すという方法が考 えられる。 しかし、 マッピングは有効ではあるが、 データベースから取り出したレコード セットのデータを強制的にマッピングにコピーしてしまう。 マッピングを使ってデータを渡 すことは、コンパイル時のチェックを無効にしてしまう上、明示的なインタフェースではな いため、ユーザがマッピングの内容の綴りを間違えることでバグにつながる可能性があると、 私は考えている。 より良い選択肢として、 データ変換オブジェクトの使用がある。 これも作 成が必要なオブジェクトではあるが、さまざまな場所で使用することができる。

SQLクエリーによって取り出されるレコードセットを返すことで、 上記2つの選択肢で 必要になる労力を省くことが可能になる。 理論上、 メモリ上のオブジェクトがSQL インタ フェースについて一切知る必要がないため、クエリーを発行する方法は概念的にはわかりに くい。 また、 独自のコードでレコードセットを簡単に作成できない場合、 データベースを ファイルに置き換えることが難しくなってしまう可能性もある。 ただし、 .NET などレコー ドセットを幅広く使用する多くの環境では、これはとても有効な手法である。 そのため、 テーブルデータゲートウェイはテーブルモジュールにとても適している。 すべての更新が テーブルデータゲートウェイを介して行われる場合、 返されるデータは、実際のテーブルで はなくビューに基づいたものになるため、コードとデータベース間の結合が緩和される。

ドメインモデルを使用する場合は、テーブルデータゲートウェイによって適切なドメイン オブジェクトを返すことができる。この場合の問題点は、ドメインオブジェクトとゲート ウェイの間に双方向の依存性が構成されてしまうことである。 双方がとても密接に結び付い ているため、私はいつもこの方法をあまり使用したくないと思ってしまう。

テーブルデータゲートウェイを使用する場合のほとんどは、データベースのテーブルごと にテーブルデータゲートウェイを使用することになるだろう。 しかし、 とてもシンプルな ケースに対しては、単一のテーブルデータゲートウェイで、 テーブルのすべてのメソッドを 処理することができる。さらに、ビューに対して、 あるいはデータベースにビューとして保 持されていないクエリーに対して、 テーブルデータゲートウェイを使用することも可能であ る。ビューベースのテーブルデータゲートウェイは更新することができず、更新の振る舞い を行わないことが明らかな場合がある。 しかし、基盤となるテーブルの更新が可能であれば、 テーブルデータゲートウェイ上での更新操作の裏側でその更新をカプセル化するという技法 は、とても有効である。

5 4

10.1.2 使用するタイミング

行データゲートウェイと同様に、テーブルデータゲートウェイについては、まずゲート ウェイの手法を使用するかどうかを判断し、 次にどの手法に移行するかを判断する。

テーブルデータゲートウェイは、 データベーステーブルまたはレコードタイプとのマッピ ングに優れているという点で、最もシンプルなデータベースインタフェースパターンである。 また、データソースへの的確なアクセスロジックを自然にカプセル化することができる。 私 がテーブルデータゲートウェイを使用する場合、 必ずドメインモデルとともに使用している のは、データマッパーがドメインモデルとデータベースとの分離を、より確実に実現するこ とに気付いたからである。

テーブルデータゲートウェイは、特にテーブルモジュールに最適であり、テーブルモ ジュールが動作するレコードセットデータ構造を作成する。 私はテーブルモジュールに対し て、テーブルデータゲートウェイ以外のデータベースのマッピング手法は思い付かない。

行データゲートウェイと同様に、 テーブルデータゲートウェイはトランザクションスクリ プトにとても適している。 どちらを選択するかは、それらが複数の行のデータをどう処理す るかに左右される。 データ変換オブジェクトの使用を好む人は少なくないが、 同じデータ変 換オブジェクトが他のどこかで使用されていない限り、 あまり意味がないように思える。 そ のため、私としては結果群がトランザクションスクリプトの処理に適している場合には、 テーブルデータゲートウェイを好んで使用している。

テーブルデータゲートウェイを介して、 データマッパーをデータベースと通信させること も、とても興味深い手法である。 すべてが手動でコード化されている場合には役に立たない が、テーブルデータゲートウェイにメタデータを使用したいけれど、ドメインオブジェクト への実際のマッピングには手動コーディングを好むという場合には、とても有効である。

テーブルデータゲートウェイを使用してデータベースのアクセスをカプセル化するメリッ

トの1つとして、同じインタフェースが、 SQL によってデータベースを処理する場合にも、 ストアドプロシージャを使用する場合にも機能する点が挙げられる。 実際、 ストアドプロ シージャ自体がテーブルデータゲートウェイとして体系化される場合も多い。 このように、 insert および update ストアドプロシージャは、 実際のテーブル構造をカプセル化し、 find プロシージャはビューを返すことができる。 これによって基盤となるテーブル構造を隠ぺい できる。

10.1.3 | 参考文献

[Alur et al.jではデータアクセスオブジェクトパターンについて紹介しているが、これは テーブルデータゲートウェイのことである。 query メソッドを使用してデータ変換オブジェ クトのコレクションを返す方法を示している。このパターンを常にテーブルの基盤として見

ているかどうかは明らかではないが、目的および解説はテーブルデータゲートウェイまたは 行データゲートウェイが前提となっていると思われる。

私も異なる名称を使用したことがあるが、それはパターンを、 より一般的なゲートウェイ の概念の1つを特定の方法で使用した形態と考えたからであり、 パターン名にその考えを反 映させたかったためである。 また、 データアクセスオブジェクトという用語および短縮形で ある DAOに対して、 Microsoft は独自の定義を採用している。

10.1.4 例: PersonGateway (C#)

テーブルデータゲートウェイは、 Windows の世界では使用されるデータベースアクセス の手法であるため、 C#で例を紹介することには意味がある。 ただし、 典型的なテーブル データゲートウェイは、 ADO.NET データセットを使用せず、 代わりにデータリーダー (データベースレコードのインタフェースとなるカーソル) を使用しているため、 .NET 環 境にはまったく適応しないことは強調しておかなければならない。 データリーダーは、メモ リに処理のすべてを置かず、大量の情報を処理する場合の優れた選択肢である。

この例では、データベースの person テーブルに接続された PersonGatewayクラスを使 使用している。 Person Gateway クラスにはFind コードが含まれていて、 ADO.NET のデー タリーダーを返し、 返されるデータにアクセスする。

class PersonGateway...

public IDataReader FindAll() {

String sql = "SELECT * FROM person";

return new OleDbCommand(sql, DB.Connection) ExecuteReader();

}

public IDataReader FindWithLast Name (String lastName) { String sql = "SELECT * FROM person WHERE lastname = ?"; IDbCommand comm = new OleDbCommand(sql, DB.Connection); comm. Parameters.Add(new OleDbParameter ("lastname", lastName)); return comm.ExecuteReader();

}

public IDataReader FindWhere (String whereClause) { String sql = String.Format("select * from person where {0}", whereClause); return new OleDbCommand(sql, DB.Connection) EcecuteReader();

}

ほとんどの場合、リーダーを使用して行の集合を取得しようとする。しかし、稀に行に適 したメソッドによって、個々のデータ行を取得したい場合もある。

56

第1章 データソースのアーキテクチャに関するパターン

class PersonGateway...

public Object[] Find Row (long key) { String sql = "SELECT * FROM person WHERE id = ?"; IDbCommand comm = new OleDbCommand (sql, DB.Connection); comm. Parameters.Add(new OleDbParameter ("key", key)); IDataReader reader = comm. ExecuteReader(); reader.Read(); Object result = new Object [reader. FieldCount]; reader.GetValues (result); reader.Close(); return result; }

Update および Insert メソッドは必要なデータを引数として取得し、 適切な SQL ルーチ ンを呼び出す。

class PersonGateway...

public void Update (long key, String lastname, String firstname, long numberOfDependents) { String sql = @" UPDATE person SET lastname = ?, firstname = ?, numberOfDependents = ? WHERE id = ?"; IDbCommand comm = new OleDbCommand (sql, DB.Connection); comm. Parameters.Add(new OleDbParameter ("last", lastname)); comm. Parameters.Add(new OleDbParameter ("first", firstname)); comm. Parameters.Add(new OleDbParameter ("numDep",

numberofDependents));

comm. Parameters.Add(new OleDbParameter ("key", key)); comm. ExecuteNonQuery();

class PersonGateway...

public long Insert (String lastName, String firstName, long number of Dependents) ( String sql = "INSERT INTO person VALUES (?, ?, ?, ?)"; long key = GetNextID(); IDbCommand comm = new OleDbCommand (sql, DB.Connection); comm. Parameters.Add(new OleDbParameter ("key", key)); comm. Parameters.Add(new OleDbParameter ("last", lastName));

comm.Parameters.Add(new OleDbParameter ("first", firstName)); comm.Parameters.Add(new OleDbParameter ("numDep",

number of Dependents));

comm.ExecuteNonQuery(); return key;

Delete メソッドではキーだけを必要とする。

class PersonGateway...

public void Delete (long key) { String sql = "DELETE FROM person WHERE id = ?"; IDbCommand comm= new OleDbCommand (sql, DB.Connection); comm.Parameters.Add(new OleDbParameter comm.ExecuteNonQuery(); ("key", key));

10.1.5 例: ADO.NET データセット (C#)の使用

汎用なテーブルデータゲートウェイは、SQL文のラッパーに過ぎないため、どのような 種類のプラットフォーム上でも動作する。 NET では、データセットをより頻繁に使用する が、テーブルデータゲートウェイも異なる形式で使用できる。

データセットは、データを読み込んだり、 データを更新したりするためのデータアダプ ターを必要とする。 find メソッドでは、データセットとアダプター用のホルダーを定義する ことが重要である。 その後、ゲートウェイはホルダーを使ってデータセットとアダプターを 保存する。 振る舞いの多くは汎用であり、スーパークラスで実行される。

ホルダーは、テーブル名ごとにデータセットとアダプターをインデックス化する。

class DataSetHolder...

public DataSet Data = new Dataset(); private Hashtable DataAdapters = new Hashtable();

ゲートウェイはホルダーを保存し、 クライアントへデータセットを公開する。

class DataGateway...

public DataSetHolder Holder; public DataSet Data {

1 5 8

に関するパターン

第1章 データソースのアーキテクチャ

get { return Holder.Data; } }

ゲートウェイは既存のホルダー上でも動作するが、 新しいホルダーを作成することもでき る。

class DataGateway... protected DataGateway () ( } Holder = new DataSet Holder(); protected DataGateway (DataSetHolder holder) ( } this. Holder = holder; DataGateway DataSetHolder * tablename PersonGateway 1 DataAdapter DataSet

図 10.1 データセット指向ゲートウェイ、およびサポートするデータホルダーのクラス図

若干異なった find の振る舞いを行うこともできる。 データセットはテーブル指向データ のためのコンテナであり、 複数のテーブルのデータを保持することができる。 そのため、 データをデータセットに読み込むことを勧める。

class DataGateway...

public void LoadAll() { String commandstring = String.Format("SELECT {0}", TableName); Holder. Fill Data (commandstring, TableName); * FROM

public void LoadWhere (String where Clause) { String commandString = String.Format("SELECT * FROM (0) where (1)", TableName, where Clause); Holder. FillData (commandString, TableName);

abstract public String TableName (get; }

class PersonGateway... public override String TableName { get (return "person"; }

class DataSetHolder...

public void FillData (String query, String tableName) {

if (DataAdapters. Contains (tableName)) throw new MutlipleLoadException(); OleDbDataAdapter da = new OleDbDataAdapter (query, DB.Connection); OleDbCommandBuilder builder = new OleDbCommandBuilder (dada.Fill(Data, tableName); DataAdapters.Add(tableName, da); }

}

データを更新するには、クライアントコードでデータセットを直接処理する。

person.LoadAll();

);

person [key] ["lastname"] = "Odell";

person. Holder. Update();

}

ゲートウェイは、特定の行へと容易に行けるようにするためのインデクサーを持つことが できる。

class DataGateway...

public DataRow this [long key] { get { String filter = String.Format("id = (0)", key); return Table. Select (filter) [0]; }

6 0

1章 データソースのアーキテクチャに関するパターン

} public override DataTable Table ( } get return Data. Tables [TableName]; }

Update メソッドは、ホルダー上での更新動作のトリガーとなる。

class DataSetHolder....

public void Update () ( } foreach (String table in DataAdapters.Keys) ((OleDbDataAdapter) DataAdapters [table]). Update (Data, table); public DataTable this (String tableName] ( get (return Data.Tables[tableName]; } }

挿入もまったく同様の方法で行うことが可能である。 データセットを取得し、 データテー ブルに新しい行を挿入し、各列に入力する。 ただし、 Update メソッドは1度の呼び出しで 挿入を実行することができる。

class DataGateway...

public long Insert (String lastName, String firstname, int numberOfDependents) { long key new PersonGatewayDS().GetNextID(); DataRow newRow = Table.NewRow(); newRow["id"] = key; newRow["lastName"] = lastName; newRow["firstName"] = firstname; newRow("number of Dependents"] = numberOf Dependents; Table.Rows.Add(newRow); return key;

|102|行データゲートウェイ

データソース内の1つのレコードに対してゲートウェイの役割を果たすオブジェクト。 行ごとに1つのインスタンスが存在する。

find (id) PersonFinder findWithLastName (String) PersonGateway lastname firstname numbeOfDependents insert update delete

メモリ上のオブジェクトにデータベースアクセスコードを組み込むことで、 いくつかの弱 点が生じることもある。 まず、 メモリ上のオブジェクトが独自のビジネスロジックを持つ場 合、データベース操作コードの追加によって複雑性が増す。 メモリ上のオブジェクトがデー タベースと結び付いている場合、 すべてのデータベースアクセスのため、テストの実行ス ピードが遅くなり、テストにとても手間がかかる。 さらにそれぞれの SQL 上の小さな相違 によっても、複数のデータベースにアクセスする必要が生じる場合もある。

行データゲートウェイは、レコード構造内のレコードそのもののように見えるが、 通常の プログラミング言語のメカニズムを使用してアクセス可能なオブジェクトを提供する。 デー タソースアクセスの詳細はすべてインタフェースの裏側に隠ぺいされる。

10.21 | 動作方法

行データゲートウェイは、1つのデータベース行などの、1つのレコードを完全に模倣す るオブジェクトとしての役割を果たす。 オブジェクト内で、 データベースの各列は1つの フィールドとなる。行データゲートウェイは、データソースタイプからメモリ上のタイプへ のあらゆる変換を行うが、この変換は極めてシンプルである。 パターンは行に関するデータ を保持するため、クライアントは行データゲートウェイに直接アクセスできるようになる。 ゲートウェイは、データの各行への優れたインタフェースとしての役割を果たす。この手法 は、特にトランザクションスクリプトに最適である。

62

第10章 データソースのアーキテクチャに関するパターン

行データゲートウェイを使用する場合、このパターンを生成する find (検索) 動作をどこ に置くのかという問題に直面する。 静的な find メソッドを使用することは可能だが、 ポリ モーフィズムを排除するため、異なるデータソースに対しては別の find メソッドに置き換 えたいと考えるかもしれない。 この場合、 独立したFind オブジェクトを持つことはできる が、リレーショナルデータベースの各テーブルが、1つの Find クラスと結果に対する1つ の Gateway クラスを保持するようになる (図 10.2)。

行データゲートウェイとアクティブレコード間の相違点を説明することは難しい場合が多 い。 最も重要なポイントは、 何らかのドメインロジックが存在するかどうかである。 もし存 在するならアクティブレコードである。 行データゲートウェイには、データベースアクセス ロジックだけが含まれていて、 ドメインロジックは含まれていない。

その他のテーブル形式のカプセル化と同様、 行データゲートウェイは、テーブルだけでな くビューやクエリーとともに使用できる。 更新の場合、 基盤となるテーブルの更新が必要と なるため、動作はさらに複雑になることが多い。 また、同じテーブルに対して2つの行デー タゲートウェイを実行する場合、更新される2つ目の行データゲートウェイは最初の変更の 結果を取り消すことになる。これを防止するための一般的な方法はなく、 開発者は仮想的な 行データゲートウェイがいかに形成されるかを認識しておくだけである。 更新可能なビュー でも同様の問題が起こる可能性があるが、もちろん更新操作を実行しないという選択もある。

行データゲートウェイには記述が面倒という傾向があるが、 メタデータマッピングに基 づいてコード生成を実行する場合には優れた選択肢になる。 この方法を使用することに よって、すべてのデータベースアクセスコードを、 自動化されたビルドプロセスで自動的 に構築できる。

10.2.2 使用するタイミング

以下の2つのステップによって、 行データゲートウェイを使用するかどうかを判断する場 合が多い。1つ目のステップでゲートウェイを使用するかどうかを判断し、 2つ目のステップ では行データゲートウェイとテーブルデータゲートウェイのどちらを使用するかを決定する。

私は、トランザクションスクリプトを使用する場合に、 行データゲートウェイを使用する 頻度が最も高い。 この場合、 行データゲートウェイでデータベースアクセスコードを適切に 抜き出し、別のトランザクションスクリプトで容易に再使用できるようにする。

私は、ドメインモデルを使用する場合には行データゲートウェイを使用しない。 シンプル なマッピングを実行する場合には、 コードレイヤを追加しなくても、 アクティブレコードが 同じ役割を果たす。 マッピングが複雑な場合には、 データマッパーが適している。 理由は、 ドメインオブジェクトはデータベースのレイアウトを知る必要がなく、 データマッパーがド メインオブジェクトからデータ構造を分離することに優れているからである。 もちろん、

た場合には、ビジネスロジック内のデータ、 行データゲートウェイ内のデータ、データベー るが、 ドメインロジックは変更したくないという場合に有効である。 しかし、 大規模に行っ 用することもできる。 これは、 行データゲートウェイを使用してデータベース構造を変更す データベース構造からドメインオブジェクトを隠ぺいするために行データゲートウェイを使

Person

Database

"[for each record] new

select from person where id=1

record set

<------

Person Finder

図 10.2 行ベースの行データベースゲートウェイによる検索操作の相互作用

find (1)

new

client

ス内のデータ (極めて大量のデータ) の3種類のデータが表示される。 この理由から私は、 データベース構造をミラー化する行データゲートウェイを使用する。

面白いことにこれまで私は、 行データゲートウェイをデータマッパーとともに使用すること はとても有効であると考えてきた。 作業が増えると思われるかもしれないが、 データマッパー が手動で実行され、 行データゲートウェイがメタデータから自動的に生成される場合は、この 組み合わせは効果的である。

トランザクションスクリプトを行データゲートウェイとともに使用する場合、 複数のスク リプトで繰り返されるビジネスロジックこそが、 行データゲートウェイに必要なロジックで あることがわかるだろう。 ロジックを移動することによって、 行データゲートウェイは段階 的にアクティブレコードへと変化し、ビジネスロジックの重複を軽減する効果をもたらす。

10.2.3 例: Person レコード (Java)

以下に行データゲートウェイの例を示す。 これはシンプルな Person テーブルである。

create table people (ID int primary key, lastname varchar, firstname varchar, number_of_dependents int)

PersonGateway は、 テーブル用のゲートウェイで、データフィールドとアクセッサーか ら始まっている。

class PersonGateway...

private String lastName;

private String firstName;

private int numberOf Dependents;

public string getLastName () ( } return lastName; public void setLastName (String lastName) { } this lastName= lastName; public String getFirstName(){ return firstName; ) public void setFirstName (String firstName){ this.firstName = firstName; ) public int getNumber Of Dependents () ()

return numberOfDependents;

第1章 データソースのアーキテクチャに関するパターン

}

public void set Number Of Dependents (int number of Dependents) ( this.numberOfDependents = numberOfDependents;

Gateway クラス自体が更新と挿入を処理する。

class PersonGateway...

private static final String updateStatementString =

*UPDATE people +

SET lastname = ?, firstname = ?, number_of_dependents = ? " + WHERE id = ?";

public void update() {

PreparedStatement updateStatement = null;

try {

updateStatement = DB.prepare (updateStatement String); updateStatement.setString (1, lastName); updateStatement.setString (2, firstName);

updateStatement.setInt(3, number of Dependents); updateStatement.setInt (4, getID().intValue()); updateStatement.execute();

} catch (Exception e) {

throw new ApplicationException(e);

} finally (DB.cleanUp (updateStatement);

}

}

private static final String insertStatement String =

"INSERT INTO people VALUES (?, ?, ?, ?)"; public Long insert() { PreparedStatement insertStatement = null; try { insert Statement = DB.prepare (insertStatement StringsetID (findNext DatabaseId()); insert Statement.setInt (1, getID().intValue()); insert Statement.setString (2, lastName); insertStatement.setString (3, firstName); insertStatement.setInt (4, number of Dependents); insertStatement.execute(); Registry.addPerson (this); return getID();

);

} catch (SQLException e) {

166

} throw new ApplicationException(e); } finally { DB.cleanUp (insert Statement); }

データベースから複数のPerson を取得するために、独立したPerson Finder を使用する。 このPerson Finder をゲートウェイとともに使用することで、 新しい Gateway オブジェク トが作成される。

class PersonFinder...

private final static String findStatementString = "SELECT id, lastname, firstname, number_of_dependents FROM people " + " WHERE id = ?"; public PersonGateway find (Long id) { } PersonGateway result = (PersonGateway) Registry.getPerson (if (result != null) return result; PreparedStatement findStatement = null; ResultSet rs = null; try { findStatement = DB.prepare (findStatement String); findStatement.setLong (1, id. longValue()); rs findStatement.executeQuery(); rs.next(); result = PersonGateway.load(rs); return result; } catch (SQLException e) { throw new ApplicationException(e); } finally (DB.cleanUp (findStatement, rs); } public PersonGateway find (long id) ( } return find (new Long (id));

class PersonGateway...

public static PersonGateway load (ResultSet rs) throws SQLException { Long id new Long (rs.getLong(1)); PersonGateway result = (PersonGateway) Registry.getPerson (id); if (result != null) return result; String lastNameArg = rs.getString(2);

+

id);

String firstNameArg = rs.getString (3);

int numDependentsArg = rs.getInt(4);

result = new PersonGateway (id, lastNameArg,

firstNameArg, numDependentsArg);

Registry.addPerson (result);

return result;

いくつかの条件に従って複数のPerson を検索するには、該当する find メソッドを提供 する。

class PersonFinder...

+ private static final String find ResponsibleStatement = "SELECT id, lastname, firstname, number_of_dependents "FROM people * +

"WHERE number_of_dependents > 0";

public List find Responsibles () {

List result = new ArrayList();

PreparedStatement stmt = null;

ResultSet rs = null;

try {

stmt =DB.prepare (find ResponsibleStatement);

rs stmt.executeQuery();

while (rs.next()) {

result.add(PersonGateway. load (rs));

}

return result;

}

} catch (SQLException e) {

throw new ApplicationException(e);

} finally (DB.cleanUp (stmt, rs);

)

)

find メソッドはレジストリを使用して、 一意マッピングを保持することで、 トランザク ションスクリプトからこのゲートウェイを使用することができる。

PersonFinder finder = new PersonFinder (); Iterator people finder.findResponsibles () .iterator(); StringBuffer result = new StringBuffer(); while (people.hasNext()) {

6 8

,

第10章 データソースのアーキテクチャに関するパターン

PersonGateway each = (PersonGateway) people.next();

result.append(each.getLastName());

result.append("");

result.append(each.getFirstName());

result.append("");

result.append (String.valueOf (each.getNumberOfDependents ()));

result.append("

return result.toString();

}

10.2.4 例: ドメインオブジェクト用のデータホルダー (Java)

私はトランザクションスクリプトでは、主に行データゲートウェイを使用する。 ドメイン モデルから行データゲートウェイを使用したい場合、ドメインオブジェクトはゲートウェイ からデータを取得する必要がある。 データをドメインオブジェクトにコピーする代わりに、 行データゲートウェイをドメインオブジェクト用のデータホルダーとして使用することがで きる。

class Person...

private PersonGateway data; public Person (PersonGateway data) { this.data = data; }

その後、 ドメインロジックのアクセッサーは、データ

のゲートウェイに委譲される。

class Person...

public int getNumberOfDependents() { return data.getNumberOf Dependents(); }

ドメインロジックはget メソッドを使用して、 ゲートウェイからデータを取得する。

class Person... public Money getExemption () { Money baseExemption = Money dollars (1500);

Money dependentExemption = Money dollars (750); return baseExemption.add(dependent Exemption.multiply this.getNumber Of Dependents()));

第10章 データソースのアーキテクチャに関するパターン

}

10.3 | アクティブレコード

データベーステーブルまたはビューの行をラップし、 データベースアクセスをカプセル 化してデータにドメインロジックを追加するオブジェクト。

Person lastName firstName numberOfDependents insert update delete getExemption isFlaggedForAudit getTaxableEarnings

オブジェクトはデータと振る舞いの両方を持つ。 データの大部分は永続データであり、 データベースに保存されなければならない。 アクティブレコードはこれを使ってデータアク セスロジックをドメインオブジェクトに配置する。 すべてのユーザがデータベースからデー タを読み込み、 データベースへデータを書き込む方法を把握できるようになる。

10.3.1 動作方法

アクティブレコードの本質はドメインモデルであり、 アクティブレコード内のクラスは、 基盤となるデータベースレコード構造とほぼ一致している。 それぞれのアクティブレコード はデータベースへの保存や読み込みを行い、またデータに適用されるドメインロジックとし ての役割も果たす。 ドメインロジックは、アプリケーション内のドメインロジックの場合も あるが、一部のドメインロジックがアクティブレコード内のカンマおよびデータ指向のコー ドとともに、 トランザクションスクリプトに保持される場合もある。

アクティブレコードのデータ構造は、データベースのデータ構造と完全に一致している必

70

要がある (つまり、 クラス内の1つのフィールドはテーブル内の各列と一致する)。 SQLイ ンタフェースからデータを取得する方法を、 フィールドに入力しておく (この時点では、い かなる変換も行ってはいけない)。 外部キーマッピングが気になるかもしれないが、外部 キーはそのままにしておいても構わない。 ビューを介した更新はかなり困難ではあるが、ア クティブレコードとともにビューまたはテーブルを使用することができる。 特に、ビューは レポートを目的としている場合には有効である。

アクティブレコードのクラスは、以下の処理を行うメソッドを持っている。

SQL の結果群の行からアクティブレコードのインスタンスを

構築する。

■後でテーブルへの挿入を行うため、 新しいインスタンスを構築する。

■ 静的な find メソッドを使用して、 共通のSQLクエリーをラップし、 アクティ ブレコードオブジェクトを返す。

■データベースを更新し、 更新したデータベースにアクティブレコードのデータ を挿入する。

■フィールドを取得し、 設定する。

■ビジネスロジックの一部を実装する。

get メソッドと set メソッドでは、 SQL 指向タイプからより優れたメモリ上のタイプへの 変換などの、より高度な操作を行うことも可能である。 また、 関連テーブルを要求する場合、 このデータ構造で一意フィールドを使用しなくても、 (照合によって) get メソッドは適切な アクティブレコードを返す。

このパターンでは、 クラスは便利な存在ではあるが、リレーショナルデータベースがある という事実を隠してしまう。結果としてアクティブレコードを使用する場合には、 通常、 そ の他のオブジェクトリレーショナルマッピングパターンを目にすることはほとんどなくなる。

アクティブレコードは行データゲートウェイにとても類似している。 最大の相違は、行 データゲートウェイにはデータベースアクセスだけが含まれ、 アクティブレコードにはデー タソースとドメインロジックの両方が含まれる点である。もっとも、ほとんどのソフトウェ ア境界のように、 両方の間に完全な境界線を設定することは難しくまた意味もない。

アクティブレコードとデータベースとが密接に結合しているため、パターンでは静的な findメソッドを使用することが多い。 しかし、 行データゲートウェイの項でも述べたとおり、 find メソッドを独立したクラスに分離できないという訳ではなく、テストでは分離した方が 有効である。

他のテーブル形式パターンと同様、 アクティブレコードは、テーブルだけでなくビューや クエリーとともに使用できる。

10.3.2 使用するタイミング

アクティブレコードは作成、読み込み、更新、削除など、それほど複雑ではないドメイン ロジックに対しては優れた選択肢である。 構造内では、1つのレコードに基づいた派生操作 や妥当性確認を効果的に行える。

ドメインモデルの初期設計で最初に判断するべき選択は、アクティブレコードかデータ マッパーのいずれを使用するかである。 アクティブレコードの最大のメリットは、 シンプル な構造である。 アクティブレコードの構築は容易であり、 また理解もしやすい。 最大の問題 は、アクティブレコードが有効であるのが、アクティブレコードオブジェクトがデータベー ステーブルと直接対応している (同一構造スキーム) 場合だけという点である。

ビジネスロジックが複雑な場合には、 オブジェクトの直接的な関係、 コレクション、 継承 などを使用したいとまず考えるだろう。 しかし、これらの部品は簡単にはアクティブレコー ドにマッピングできず、 また、断片的に追加すると状況はより複雑になる。 以上の理由から、 データマッパーの使用を考えるようになる。

アクティブレコードに関する別の問題点として、 オブジェクト設計とデータベース設計と が結合しているので、プロジェクトが進行するにつれて、それぞれの設計分析が困難になっ てしまうことがある。

トランザクションスクリプトを使用したがコードの複製が面倒になり、 トランザクション スクリプトで行われる多くのスクリプトやテーブルの更新に困難を感じるようになった場合 には、アクティブレコードは考慮すべき優れたパターンである。 この場合には、アクティブ レコードの作成を段階的に開始した後、 ゆっくりとその振る舞いを分析することができる。 この方法はゲートウェイとしてテーブルをラップするために役立つことが多く、 次に振る舞 いの移動を開始してテーブルがアクティブレコードへと発展する際に役立つ。

10.3.3 例: シンプルな Person (Java)

これはアクティブレコードの構造がどのように動作するかを示すシンプルな例である。 ま ずは、基本的な Person クラスから始まる。

class Person...

private String lastName; private String firstName; private int numberOf Dependents;

また、スーパークラスには一意フィールドも存在している。 データベースはまったく同じ 構造に設定されている

7 2

第10章 データソースのアーキテクチャに関するパターン

create table people (ID int primary key, lastname varchar, firstname varchar, number_of_dependents int)

オブジェクトを読み込むために、 Person クラスは find メソッドとしての役割を果たし、 また読み込みも実行する。 この例では、 Person クラス上で静的メソッドを使用している。

class Person...

private final static String findStatement String =

"SELECT id, lastname, firstname, number_of_dependents" "FROM people" +

" WHERE id = ?";

public static Person find (Long id) {

Person result = (Person) Registry.getPerson (id);

if (result = null) return result;

PreparedStatement findStatement = null; ResultSet rs = null;

try {

findStatement = DB.prepare (findStatementString); findStatement.setLong (1, id. longValue());

rs findStatement.executeQuery();

rs.next();

result load (rs);

return result;

} catch (SQLException e) {

throw new ApplicationException(e);

} finally (DB.cleanUp (findStatement, rs);

public static Person find (long id) {

return find (new Long (id));

public static Person load (ResultSet rs) throws SQLException ( Long id = new Long (rs.getLong (1)); Person result = (Person) Registry.getPerson (id); if (result != null) return result; String lastNameArg = rs.getString(2); String firstNameArg = rs.getString(3); int numDependents Arg = rs.getInt(4); result = new Person (id, lastNameArg, firstNameArg, numDependentsArg); Registry.addPerson (result); return result;

}

}

}

オブジェクトの更新には、シンプルなインスタンスメソッドを使用している。

class Person...

private final static String updateStatementString "UPDATE people" +

= ?" +

=

⚫ SET lastname = ?, firstname = ?, number_of_dependents WHERE id = ?";

public void update() {

PreparedStatement updateStatement = null;

try {

updateStatement = DB.prepare (updateStatementString); updateStatement.setString (1, lastName);

updateStatement.setString (2, firstName);

updateStatement.setInt(3, numberOfDependents);

updateStatement.setInt (4, getID().intValue()); updateStatement.execute();

} catch (Exception e) {

throw new ApplicationException(e);

} finally {

DB.cleanUp (updateStatement);

}

挿入もまた極めてシンプルである。

class Person...

private final static String insertStatementString "INSERT INTO people VALUES (?, ?, ?, ?)"; public Long insert() { PreparedStatement insertStatement = null; try { = insertStatement DB.prepare (insert Statement String); setID (findNext DatabaseId()); insertStatement.setInt (1, getID (). intValue()); insertStatement.setString (2, lastName); insertStatement.setString (3, firstName); insertStatement.setInt (4, numberOfDependents); insertStatement.execute(); Registry.addPerson (this); return getID(); {

} catch (Exception e)

第10章 データソースのアーキテクチャに関するパターン

throw new ApplicationException(e} finally { DB.cleanUp (insertStatement); }

);

控除の計算などのビジネスロジックは、 Person クラスに直接置かれている。

class Person...

public Money getExemption () ( Money baseExemption = Money dollars (1500); Money dependentExemption = Money dollars (750); return baseExemption. add (dependent Exemption.multiply. this.getNumberOf Dependents()));

)

10.4 | データマッパー

オブジェクト、データベース、およびマッパー自体の独立性を保ちつつ、オブジェクト とデータベース間でデータを移動するマッパーのレイヤ

Person PersonMapper lastName firstName insert numberOfDependents update getExemption delete isFlaggedForAudit getTaxableEarnings

データの構造化に対して、 オブジェクトとリレーショナルデータベースは異なるメカニズ ムを持っている。 コレクションや継承など、 オブジェクトの部品の多くはリレーショナル データベースにはない。 多くのビジネスロジックを持ったオブジェクトモデルを構築する場 合、これらのメカニズムを使用して、データとそのデータに適用される振る舞いを適切に体 系化することは重要である。 体系化することによって、 さまざまなスキーマも整理すること ができ、 オブジェクトスキーマとリレーショナルスキーマを混同することがなくなる。

2つのスキーマ間でデータを変換する必要があり、 データ変換はそれ自体が状況を複雑化 する原因である。 メモリ上のオブジェクトがリレーショナルデータベース構造を知っている

場合、1つのオブジェクトの変換が他のオブジェクトにも波及する傾向がある。

データマッパーは、メモリ上のオブジェクトをデータベースから分離するソフトウェアの レイヤである。 データマッパーの役割は、オブジェクトとリレーショナルデータベースの間 でデータを変換することであり、 両方の独立性も保つことでもある。 データマッパーを使用 すれば、メモリ上のオブジェクトはデータベースが存在するかどうかさえも知る必要はなく、 SQL インタフェースコードを使用したり、 データベーススキーマの知識を保持したりする 必要も一切ない (データベーススキーマは、使用するオブジェクトについて何も知らない)。 データマッパーはマッパーの一種であるため、 それ自体がドメインレイヤにとっては未知の 存在である。

10.4.1 動作方法

ドメインとデータソースの分離はデータマッパーの主要な機能であるが、実現するために は、説明しなければならない細かな問題が数多く存在する。 また、 マッピングレイヤの構築 にもさまざまな方法がある。 双方を分離するための必要事項についての概要を紹介すること が目的であるため、 解説する内容も多岐に渡っている。

まずは、基本的なデータマッパーから始めよう。 データマッパーは最もシンプルなスタイ ルのレイヤであり、 あまり価値があるようには思えないかもしれない。 このシンプルなデー タベースマッピングの例では、通常データマッパー以外のパターンはよりシンプルで、より 優れたものになっている。 本格的にデータマッパーを使用するなら、より複雑なケースが必 要になるだろう。 しかし、こうした基本的なレベルから解説を始めることで、 基本理念の解 説が容易となる。

最もシンプルなケースでは、 Person クラスと Person Mapper クラスを構築する。 デー タベースから Person を読み込むため、クライアントはマッパーのfind メソッドを呼び出す 図10.3)。 マッパーは一意マッピングを使用して、 その Person がすでに読み込まれている かどうかを判断し、読み込まれていなければ読み込む。

図 10.4 に、更新操作を示す。 クライアントはマッパーに対して、 ドメインオブジェクト の保存を要求する。 マッパーはドメインオブジェクトからデータを取得し、 データベースへ と戻す。

テストのため、あるいは1つのドメインレイヤが別のデータベースとともに動作するよう に、データマッパーのレイヤ全体を置き換えることができる。

シンプルなデータマッパーでは、データベーステーブルをフィールド単位で、対応するメ モリ上のクラスにマッピングするだけである。 もちろん、 常にシンプルというわけではない。 複数のフィールドに変化するクラス、 複数のテーブルを持つクラス、 継承を持つクラスを処 理し、一度これらのクラスを整理した後に、 オブジェクトと連結させようとする場合には、

第10章 データソースのアーキテクチャに関するパターン

7 6

マッパーにさまざまなストラテジーが必要となる。 本書で紹介するさまざまなオブジェクト リレーショナルマッピングパターンはすべて、このストラテジーに関するものである。 デー タマッパーによるこうしたパターンの配置は、 体系化するために別の選択肢を使用するより も容易である。

挿入や更新を行う場合、 データベースマッピングレイヤは、 どのオブジェクトが変化し、 どのオブジェクトが新たに作成され、 どのオブジェクトが破壊されたかを知っておく必要が ある。 さらにはすべての作業負荷が、 トランザクションに関するフレームワークに適応して いなければならない。 ユニットオブワークパターンは、こうした体系化を行うための優れた 方法である。

図 10.3 には、 find メソッドへの1つのリクエストが、1つのSQL クエリー内に結果を返 す方法を示している。 この図の方法が常に正しいとは限らない。 複数の Order Line (注文 品目) を持った典型的な Order の読み込みには、 Order Line の読み込みも含まれる可能性 がある。 通常クライアントからのリクエストは、マッパーの設計者が1回に返す量を決める ことで、読み込むオブジェクトの量を調整することができるようになる。 重要な点は最小限 のデータベースクエリーを設定することである。 実現するには一般的に、データの最適な抽 出方法を選択するため、 find メソッドはクライアントがオブジェクトをどのように使用する かを詳しく知る必要がある。

この例は、1つのクエリーからドメインオブジェクトの複数クラスを読み込むケースに発 展することができる。 Order および Order Line を読み込みたいのならば、 Orders テーブ ルとOrder Lines テーブルとのジョインを行う1つのクエリーを発行したほうが迅速に行 える。 次に、この結果群を使用して、 Order と Order Line インスタンスを読み込む (P261-262 参照)。

find (1)

martin

person mapper

new

get(1)

null

図10.31つのデータベースでのデータの検索

map

database

select from people where id=1

result set

get lots of data

第1章 データソースのアーキテクチャに関するパターン

result set

martin Person

オブジェクトは相互に関連付けられているため、ある時点でデータの抽出を中止しなけれ ばならない。そうでない場合は、1つのリクエストによってデータベース全体を抜き出すこ とになってしまう。 マッピングレイヤは、レイジーロードと呼ばれる技法によって、 メモリ 上のオブジェクトへの影響を最小限に抑えながら、抽出に関する問題に対応する。解説して きたとおり、 メモリ上のオブジェクトはマッピングレイヤを完全に無視することはできない。 マッピングレイヤは、 find メソッドや別のいくつかのメカニズムについても知っておく必要 がある。

アプリケーションは、1つまたは複数のデータマッパーを持つことができる。 マッパーを ハードコーディングする場合、各ドメインクラスまたはドメイン階層構造のルートに、 1つ のマッパーを使用することが最も有効である。 メタデータマッパーを使用する場合には、 1 つの Mapper クラスで対応することもできる。 後者の場合、問題になるのは find メソッド である。 大規模なアプリケーションの場合、1つのマッパーに多くのfindメソッドを持たせ ることは難しいため、 メソッドを各ドメインクラスまたはドメイン階層構造のルートごとに 分割する方が意味がある。 小規模な Find クラスを数多く持つことになるが、 開発者にとっ て、必要な find メソッドの検索は難しいことではない。

- あらゆるデータベース検索の振る舞いと同様、 find メソッドがデータベースから読み込ま れるオブジェクトの一意性を維持するためには、一意マッピングを使用する必要がある。 意マッピングのレジストリを使用することも、あるいは各find メソッドに一意マッピングを 保持させることも可能である (1セッションのクラスごとに1つのfind メソッドだけが存 在する場合)。

martin: Person person mapper database id=1 update (martin) get lots of data 図 10.4 データの更新 update person set.... where id = 1

10.4.1.1 find メソッドの処理

オブジェクトを処理するためには、データベースからオブジェクトを読み込む必要がある。 一般的に、プレゼンテーションレイヤはいくつかの初期オブジェクトを読み込むことで初期 化を行う。次に、制御はドメインレイヤに移動し、コードは主にオブジェクト間の関連を使 用してそのオブジェクトの間を移動する。 この方法は、 メモリへの読み込みが必要なすべて のオブジェクトをドメインレイヤが持っているか、あるいは必要な時点で追加オブジェクト を読み込むレイジーロードを使用している場合には効果的である。

データマッパーでfind メソッドを呼び出すためにドメインオブジェクトを必要とする場 合がある。 しかし私は、優れたレイジーロードを使用した、 ドメインオブジェクトを一切必 要としない方法があることに気付いている。 ただしよりシンプルなアプリケーションの場合、 関連性とレイジーロードを使用して、 すべてを管理することに意味がない場合がある。 それ でもなお、ドメインオブジェクトの依存性をデータマッパーに追加したいとは考えないであ ろう。

このジレンマは、セパレートインタフェースを使用することによって解決できる。 ドメイ ンコードが必要とする任意の find メソッドを、 ドメインパッケージに配置できるインタ フェースクラスに追加するのである。

10.4.1.2 ドメインフィールドへのデータのマッピング

マッパーはドメインオブジェクトのフィールドにアクセスする必要がある。 しかし、マッ バーをドメインロジックに対して動作させたくないため、サポートする public メソッドが 必要となるので、このマッピングは問題になる場合が多い。 (フィールドをパブリックにす るといった大罪は問題にしないことにしよう)。 この問題の回答は、 簡単には見つけられな い。 Java の同一パッケージのように、ドメインオブジェクトの近くにマッパーをパッケー ジングするといった、低いレベルの可視性を使用することは可能である。 しかし、 ドメイン オブジェクトを知っているシステムの別の部分にマッパーを知らせたくないため、依存性の 問題がより重大になってくる。 言語の可視性の規則を回避するためにリフレクションを使用 することができる。 速度は遅くなるが、この速度の遅さはSQL 呼び出しに要する時間と比 較した場合、 丸め誤差とすることができる。 あるいは public メソッドを使用することもで きるが public メソッドがデータベースの読み込みというコンテキストの外部で使用される 場合、例外を実行するためには、ステータスフィールドによる保護が必要となる。この場合 には、通常のget メソッドや set メソッドが間違わないような名前を付けておく。

問題となるのは、オブジェクトをいつ作成するかという点である。 実際には、2つの選択 肢が考えられる。1つ目の方法は rich constructor によってオブジェクトを作成する方法で あり、この場合、少なくとも必須データとともにオブジェクトが作成される。もう1つの方 法は、空のオブジェクトを作成し、そこに必須データを配置する方法である。 私は前者を好

むが、その理由は最初から完成度の高いオブジェクトを作成できるからである。 さらに不変 フィールドが存在する場合、 その値を変更するメソッドを提供しないことで、強制的に変更 させないというメリットもある。

rich constructor の問題は、循環参照に注意しなければならないという点である。 相互に 参照し合う2つのオブジェクトがある場合、 いずれか1つを読み込もうとするともう1つを 読み込むことになり、 その結果再び最初の1つを読み込むことになり、最終的にスタックス ベースが不足してしまうのである。 こうした状況を回避するには特定の case コー ードが必要と なるため、レイジーロードが使用される場合が多い。 この特定の case コードの記述は困難な 作業であり、 できれば避ける方が望ましい。 記述作業を避けるためには、空のオブジェクト を作成する。 引数なしの constructor を使って空白のオブジェクトを作成し、その空のオブ ジェクトを即座に一意マッピングに挿入するのである。 この方法によって循環が存在する場 合でも、一意マッピングがオブジェクトを返し、 再帰的な読み込みを中止することができる。 空のオブジェクトを使用するということは、 オブジェクトを読み込む際に、完全に不変で

あるいくつかの値にも set メソッドが必要になる。 命名規則と、いくつかのステータス チェックによる保護を組み合わせることで、 この問題を解決できる。 また、 データ読み込み にはリフレクションも使用することができる。

10.4.1.3 メタデータベースのマッピング

決定すべき判断の1つとして、ドメインオブジェクトのフィールドをデータベース列に マッピングする方法に関する情報の保存が挙げられる。 そのための最もシンプルかつ最善 (多くの場合) の方法とは、 明示的なコードを使用して、 ドメインオブジェクトごとに Mapper クラスを要求することである。 マッパーは引数を介してマッピングを行い、 フィー ルド (通常は定数文字列) にデータベースアクセス用のSQL を保存させる。 その他の方法 としてはメタデータマッピングが挙げられる、 クラスまたは独立したファイルにメタデータ をデータとして保存するという方法である。 メタデータのメリットとは、コード生成または リフレクティブプログラミングを使用することで、データを介してマッパーのすべての変数 を操作でき、ソースコードを必要としない点である。

10.4.2 使用するタイミング

データマッパーを使用する最も一般的な状況は、 データベーススキーマとオブジェクトモ デルを個別に発展させたい場合である。 その最も一般的なケースがドメインモデルである。 データマッパーの第一のメリットはドメインモデルに対して動作する場合、設計、構築、 テ ストプロセスのいずれにおいても、データベースを無視できる点にある。 すべての通信は マッパーによって行われるため、 ドメインオブジェクトはデータベース構造については一切

関知していない。

ドメインオブジェクトがデータベースにどのように保存されているかを理解していなくて も、ドメインオブジェクトを理解し対処できるため、この状況はコード内で役に立つ。 ドメ インモデルおよびデータベースを変更することなく、 修正を行うことができるのである。 マッピングが複雑な場合、 特に既存の関連データベースに関してとても有効である。

もちろんアクティブレコードでは取得できない別のレイヤの分の代償が必要になるため、 これらのパターンを使用するかどうかはビジネスロジックの複雑性に左右される。 ビジネス ロジックがとてもシンプルなら、ドメインモデルもデータマッパーも必要ないかもしれない。 ビジネスロジックの複雑性によって、 ドメインモデルやさらにはデータマッパーが必要かど うか決まる。

私は、ドメインモデルを使用することなくデータマッパーを選ぶことはないだろう。 しか し、データマッパーなしでドメインモデルを使用できるだろうか。 ドメインモデルがシンプ ルで、そのドメインモデルの設計者がデータベースを制御できているなら、 アクティブレ コードを使用して、ドメインオブジェクトがデータベースに直接アクセスすることも十分考 えられる。

直接アクセスすることによって、ここで解説したマッパーの振る舞いがドメインオブジェ クト自体に効果的に動作するようになる。 状況がより複雑な場合、 データベースの振る舞い を独立したレイヤにリファクタリングすることを勧める。

完全な機能を備えたデータベースマッパーレイヤを構築する必要がないことは覚えておく べきである。 このレイヤは構築するには極めて複雑である上、 代用可能な製品も存在してい る。 通常の場合、自身で構築するよりは、データベースマッピングレイヤを購入することを 勧めたい。

10.4.3 例 シンプルなデータマッパー (Java)

解説するのはデータマッパーの極めてシンプルな使用例であり、 目的は基本構造を伝える ことにある。この例は、同一の People テーブルを持つPerson である。

class Person...

private String lastName; private String firstName; private int number of Dependents;

データテーブルスキーマは、以下のとおりである。

第10章 データソースのアーキテクチャに関するパターン

82

create table people (ID int primary key, lastname varchar, firstname varchar, number_of_dependents int)

Person Mapper クラスが find メソッドと一意マッピングを実装するという、 シンプルな ケースを使用している。 ただし、 共通の振る舞いをどこで引き出せるかを示すため、 抽象 マッパーであるレイヤスーパータイプを追加した。 読み込みには、 オブジェクトがすでに一意 マッピングに含まれていることのチェックと、データベースからのデータの抽出も含まれて いる。

find メソッドの振る舞いは Person Mapper 内で開始される。 Person Mapper は、 ID で 検索するための抽象的な find メソッドの呼び出しをラップする。

class PersonMapper...

protected String findStatement () (

return "SELECT" + COLUMNS +

FROM people" +

"WHERE id = ?";

public static final String COLUMNS = firstname, number_of_dependents "; public Person find (Long id) {

id, lastname,

return (Person) abstractFind(id);

public Person find (long id) {

return find (new Long (id));

}

class AbstractMapper...

protected Map loadedMap = new HashMap(); abstract protected String findStatement (); protected DomainObject abstract Find (Long id) { DomainObject result = (DomainObject) loaded Map.get(idif (result != null) return result; PreparedStatement findStatement = null; try ( findStatement = DB.prepare (findStatement ()); findStatement.setLong (1, id. longValue()); ResultSet rs = findStatement.executeQuery(); rs.next(); result load (rs);

);

}

}

"

return result; }catch(SQLException e){ throw new ApplicationException(e); } finally { DB.cleanUp (findStatement);

find メソッドはloadメソッドを呼び出し、 load メソッドは AbstractMapper と Person Mapper とに分割されている。 AbstractMapper はID をチェックし、 ID をデータ から抽出し、 一意マッピングに新たなオブジェクトを登録する。

class AbstractMapper...

protected DomainObject load (ResultSet rs) throws SQLException { Long id = new Long (rs.getLong (1)); if (loadedMap.containsKey (id)) return (DomainObject) loadedMap.get(id); DomainObject result = doLoad (id, rs); loadedMap.put (id, result); return result; } abstract protected DomainObject doLoad (Long id, ResultSet rs) throws SQLException;

class PersonMapper...

protected DomainObject doLoad (Long id, ResultSet rs) throws SQLException { String lastNameArg = rs.getString(2); String firstNameArg = rs.getString(3); int numDependentsArg = rs.getInt(4); return new Person(id, lastNameArg, firstNameArg, numDependentsArg);

一意マッピングが2回チェックされている点に注目してほしい (1回目は abstractFind、 2回目はload によって行われる)。 このような方法を採るには理由がある。

オブジェクトがすでに存在している場合は、データベースのアクセスを省略できるため、 find メソッドによってマッピングをチェックしている (常に、 私はこの方法で不要なアクセ スを回避している)。 ただし、 一意マッピングで解決できるとは限らないクエリーが存在す

84

}

第10章 データソースのアーキテクチャに関するパターン

るかもしれないので、 load メソッドにおいても同様のチェックを行わなければならない。 た とえば、 姓 (last name) と検索パターンとが一致するすべてのPerson を検索するとしよ う。この場合、その複数のPerson がすべて読み込まれているかどうかは分からないため、 データベースにアクセスして、 クエリーを発行する必要がある。

class PersonMapper...

private static String findLast Name Statement =

"SELECT " + COLUMNS +

" FROM people" + " WHERE UPPER (lastname) LIKE UPPER(?)" +

" ORDER BY lastname";

public List findByLast Name (String name) {

PreparedStatement stmt = null;

ResultSet rs = null;

try {

stmt = DB.prepare (findLast NameStatement); stmt.setString (1, name);

rs = stmt.executeQuery();

return loadAll(rs);

} catch (SQLException e) {

throw new ApplicationException(e);

} finally (

DB.cleanUp (stmt, rs);

}

class AbstractMapper...

protected List loadAll (ResultSet rs) throws SQLException {

List result = new ArrayList();

while (rs.next())

result.add(1oad(rs));

return result;

しかし、その結果として、 結果群にはすでに読み込まれている複数のPerson に対応する 行も含まれる可能性もある。 このような重複がないかどうかをチェックするために、一意 マッピングをもう一度チェックする必要がある。

この方法で必要な find メソッドを各サブクラスに記述することによって、いくつかの基

本コードが繰り返し含まれてしまうが、 繰り返しは一般的なメソッドを使用することで解決 できる。

class AbstractMapper...

public List findMany (Statement Source source) PreparedStatement stmt = null; ResultSet rs = null; try { stmt DB.prepare (source.sql()); for (int i=0; i<source.parameters()stmt.setObject (i+1, source.parametersrs stmt.executeQuery(); return loadAll(rs); } catch (SQLException e) { throw new ApplicationException(e); } finally { DB.cleanUp (stmt, rs); }

{

.length; i++)

() [i]);

このコードを機能させるには、 SQL 文字列とパラメータの双方の読み込みをあらかじめ 準備されたステートメントにラップするインタフェースが必要となる。

interface Statement Source...

String sql(); Object[] parameters();

次に、内部クラスとして適切に実装することで動作が機能するようになる。

class PersonMapper...

public List findByLastName2 (String pattern) ( } return findMany (new FindByLast Name (pattern)); static class FindByLastName implements Statement Source ( private String lastName; public FindByLast Name (String lastName) { ) this.lastName = lastName;

186

第1章 データソースのアーキテクチャに関するパターン

} public String sql() { return "SELECT" COLUMNS + " FROM people " + " WHERE UPPER (lastname) LIKE UPPER (?)" + } " ORDER BY lastname"; public Object[] parameters() ( Object[] result = (lastName); return result;

上記のような方法は、繰り返されるステートメント呼び出しコードが存在する他の部分に も応用できる。 以下に示す例は、 内容が一目でわかるように極めてシンプルな構造になって いる。 繰り返される単純な大量のコードを記述する場合、 上記の方法を検討すべきだろう。 update メソッドでのJDBCコードは、このサブタイプ固有のものである。

class PersonMapper...

private static final String updateStatementString = "UPDATE people " +

"SET lastname = ?, firstname = ?, number_of_dependents = ? "WHERE id = ?";

public void update (Person subject) {

PreparedStatement updateStatement = null;

try {

updateStatement = DB.prepare (updateStatement String); updateStatement.setString (1, subject.getLastName()); updateStatement.setString (2, subject.getFirstName()); updateStatement.setInt (3, subject.getNumberOf Dependents()); updateStatement.setInt (4, subject.getID (). intValue()); updateStatement.execute();

} catch (Exception e) {

throw new ApplicationException(e);

} finally (

DB.cleanUp (updateStatement);

insert メソッドでは、一部のコードをレイヤスーパータイプに組み込むことができる。

+

class AbstractMapper...

第10章 データソースのアーキテクチャに関するパターン

public Long insert (DomainObject subject) { PreparedStatement insertStatement = null; try { insertStatement = DB. prepare (insertStatement()); subject.setID (find Next DatabaseId()); insertStatement.setInt(1, subject.getID (). intValue()); do Insert (subject, insertStatement); insertStatement.execute(); loadedMap.put(subject.getID(), subject); return subject.getID(); } catch (SQLException e) { throw new ApplicationException(e); } finally { } } DB.cleanUp (insertStatement);

abstract protected String insertStatement ();

abstract protected void doInsert (DomainObject subject, PreparedStatement insertStatement) throws SQLException;

class PersonMapper...

protected String insertStatement () ( } ( return "INSERT INTO people VALUES (?, ?, ?, ?)"; protected void doInsert ( DomainObject abstract Subject, PreparedStatement stmt) throws SQLException Person subject = (Person) abstractSubject; stmt.setString (2, subject.getLastName()); stmt.setString (3, subject.getFirstName()); stmt.setInt (4, subject.getNumber Of Dependents());

10.4.4 find X (Java)

ドメインオブジェクトがfindメソッドの振る舞いを呼び出せるようにするには、セバ レートインタフェースを使って、 findインタフェースをマッパーから分離する (図 10.5)。 find インタフェースを、ドメインレイヤから見える独立したパッケージに配置することは

188

可能であり、 この例ではドメインレイヤ自身に配置する。

最も汎用な find メソッドの1つは、特定の代理 ID に応じてオブジェクトを検索するも のである。処理の大部分は汎用であり、 適切なレイヤスーパータイプによって処理すること ができる。この場合には、ID について知っているドメインオブジェクトのレイヤスーパー タイプが必要になる。

検索のためのインタフェースは、 find インタフェース内に存在する。 通常は、どんなタイ プが返されるかを知る必要があるため、汎化しないことが望まれる。

domain DomainObject id: Long Artist Album «interface" ArtistFinder find (id) mapper AbstractMapper + insert + update #abstractFind # load #doLoad ArtistMapper find (id) #doLoad

図 10.5 ドメインパッケージでの find インタフェースの定義

interface ArtistFinder...

Artist find (Long id); Artist find (long id);

最適なのは、 find インタフェースをレジストリに保持される find メソッドとともに、 ド メインパッケージ内で宣言することである。 この例では、 Mapper クラスによって find イ ンタフェースを実装している。

class ArtistMapper implements Artist Finder...

public Artist find (Long id) { } return (Artist) abstract Find (id); public Artist find (long id) { } return find(new Long (id));

find メソッドの大部分は、一意マッピングをチェックしてオブジェクトがすでにメモリ上 にあるかどうかをチェックする、マッパーのレイヤスーパータイプを使用して動作する。 レ イヤスーパータイプが存在しない場合は、 ArtistMapper によって読み込まれるあらかじめ 準備されたステートメントを実行して、それを完了する。

第1章 データソースのアーキテクチャに関するパターン

class AbstractMapper...

abstract protected String findStatement ();

protected Map loadedMap = new HashMap();

protected DomainObject abstractFind (Long id) {

DomainObject result = (DomainObject) loadedMap.get(id);

if (result = null) return result;

PreparedStatement stmt = null;

ResultSet rs = null;

try {

stmt = DB.prepare (findstatement ());

stmt.setLong (1, id.longValue());

rs = stmt.executeQuery();

result = load(rs);

rs.next();

return result;

} catch (SQLException e) {

throw new ApplicationException(e);

} finally {cleanUp (stmt, rs);

)

class Artist Mapper...

protected String findStatement () { } return "SELECT " + COLUMN_LIST + "FROM artists art WHERE ID = ?"; public static String COLUMN_LIST = "art.ID, art.name";

この振る舞いの find の部分では、既存のオブジェクトまたは新しいオブジェクトを取得 する。一方、 load の部分は、 データベースのデータを新しいオブジェクトに配置する。

class AbstractMapper...

protected DomainObject load (ResultSet rs) throws SQLException (

Long id = new Long (rs.getLong ("id"));

if (loadedMap.containsKey (id)) return (DomainObject)

loadedMap.get(id);

DomainObject result = doLoad (id, rs);

loadedMap.put(id, result);

return result;

}

abstract protected DomainObject doLoad (Long id, ResultSet rs) throws SQLException;

class ArtistMapper...

protected DomainObject doLoad (Long id, ResultSet rs) throws SQLException {

String name = rs.getString("name");

Artist result = new Artist (id, name);

return result;

)

このload メソッドも一意マッピングをチェックしている点に注目してほしい。 例では重 複してしまっているが、 load メソッドを、チェックをまだ終えていない他の find メソッド から呼び出すことができる。 スキームですべてのサブクラスがするべきことは、 doLoad メ ソッドを作成して必要な実際のデータを読み込み、 findStatement メソッドからあらかじ め用意された適切なステートメントを返すことである。

また、クエリーを基盤にした検索を実行することもできる。 たとえば、 Track (曲目)と Album (アルバム) のデータベースがあり、 指定された Album のすべての Track を検索 する find メソッドが必要だとしよう。 このインタフェースは再びfindメソッドを定義する。

interface TrackFinder...

Track find (Long id); Track find(long id); List findForAlbum (Long albumID);

これはクラスに限定されたfind メソッドであるため、レイヤスーパータイプではなく、 TrackMapper クラスのような特定のクラスに実装される。 あらゆる find メソッド同様に、 実装には2種類のメソッドが存在している。 1つはあらかじめ準備されたステートメントを 設定し、もう1つはあらかじめ準備されたステートメントの呼び出しをラッピングし結果を 解釈する。

class TrackMapper...

public static final String findForAlbumStatement = "SELECT ID, seg, albumID, title " + "FROM tracks" +

"WHERE albumID = ? ORDER BY seq";

public List findForAlbum (Long albumID){

PreparedStatement stmt = null;

ResultSet rs = null;

try {

stmt = DB.prepare (findForAlbumStatement); stmt.setLong (1, albumID.longValue());

rs = stmt.executeQuery();

List result = new ArrayList();

while (rs.next()) result.add(load (rs));

return result;

}catch(SQLException e){

throw new ApplicationException(e);

} finally {cleanUp (stmt, rs);

}

このfindメソッドは、 結果群の各行ごとにloadメソッドを呼び出す。 メソッドは、 メモ リ上のオブジェクトの作成と、データを伴ったオブジェクトの読み込みを担当している。 前 の例と同様、すでに何かが読み込まれているかどうかをチェックするための一意マッピング のチェックなど、一部分はレイヤスーパータイプで処理することが可能である。

92

第1章 データソースのアーキテクチャに関するパターン

10.4.5 例: 空のオブジェクトの作成 (Java)

オブジェクトの読み込みには、2種類の手法がある。1つはコンストラクタを使って完全 なオブジェクトを作成する方法であり、 前述の例ではこの方法を使用している。 結果は以下 のような読み込みコードになる。

class AbstractMapper...

protected DomainObject load (ResultSet rs) throws SQLException { } Long id = new Long (rs.getLong(1)); if (loadedMap.containsKey(id)) return (DomainObject) loadedMap.get(id); DomainObject result = doLoad (id, rs); loadedMap.put (id, result); return result; abstract protected DomainObject doLoad (Long id, ResultSet rs) throws SQLException;

class PersonMapper...

protected DomainObject doLoad (Long id, ResultSet rs) throws SQLException { String lastNameArg = rs.getString (2); String firstNameArg = rs.getString(3); int numDependentsArg = rs.getInt(4); return new Person(id, lastNameArg, firstNameArg, numDependentsArg);

}

もう1つの手法は空のオブジェクトを作成し、 set メソッドによって後に読み込む方法で ある。

class AbstractMapper...

protected DomainObjectEL load (ResultSet rs) throws SQLException { Long id new Long (rs.getLong (1)); if (loadedMap.containsKey(id)) return (DomainObjectEL) loadedMap.get(id); DomainObjectEL result = createDomainObject(); result.setID (id); loadedMap.put (id, result);

doLoad (result, rs);

return result;

}

abstract protected DomainObjectEL createDomainObject(); abstract protected void doLoad (DomainObjectEL obj, ResultSet rs) throws SQLException;

class PersonMapper...

protected DomainObjectEL createDomainObject() { } return new Person(); protected void doLoad (DomainObjectEL obj, ResultSet rs) throws SQLException { Person person = (Person) obj; person. dbLoadLast Name (rs.getString(2)); person.setFirstName (rs.getString(3)); person.setNumberOfDependents (rs.getInt(4)); }

set メソッドの使用を制御したいため、 異なる種類のドメインオブジェクトレイヤスー パータイプを使用している点に注目してほしい。 Person の姓 (last name) を不変フィール ドにする場合を解説する。 例では、一度読み込まれた後にフィールドの値を変更したくない ため、ドメインオブジェクトにステータスフィールドを追加している。

class DomainObjectEL...

private int state = LOADING; private static final int LOADING = 0; private static final int ACTIVE = 1; public void beActive () { state ACTIVE; )

その後、読み込み時にその値をチェックすることが可能となる。

class Person...

public void dbLoadLast Name (String lastName) ( assertStateIsLoading(); this.lastName = lastName;

第10章 データソースのアーキテクチャに関するパターン

class DomainObjectEL...

void assertStateIsLoading() ( ) Assert is True (state == LOADING);

適切ではないと感じるのは、 Person クラスのほとんどのクライアントが使用できないイ ンタフェース内に、 メソッドを持っているという点である。 これはフィールドを設定するた めのリフレクションを使用するマッパーに対する引数であり、 Java の保護メカニズムは完 全に使用できなくなる。

ステータスベースの保護は問題とならないだろうか。 残念ながら、私にもわからない。 一 方では、複数のユーザによって、間違ったタイミングでupdate メソッドを呼び出すことで バグが引き起こされる。 しかしこのバグは、 メカニズムのコストに釣り合うほど深刻なもの だろうか。 現時点では、私はいずれについても明確な意見は持っていない。



オブジェクトリレーショナル振る舞いパタ

11.1 ユニットオブワーク

ビジネストランザクションの影響を受けるオブジェクトのリストを保持しつつ、 変更点 の書き込みと並行性の問題の解決を調整する。

UnitOfWork registerNew (object) register Dirty (object) registerClean (object) register Deleted(object) commit()

データベースに対してデータの挿入と抽出を行うとき、 変更点を記録しておくことは重要 である。 そうしないと、データはデータベースに反映されない。 同時に、 作成した新しいオ ブジェクトは挿入し、削除するオブジェクトはすべて消去しておく必要がある。

オブジェクトモデルが変化するごとにデータベースを変更することは可能だが、そうする ととても小規模なデータベースの呼び出しばかりになってしまい、処理速度が低下してしま う。 さらに、 トランザクションをすべての相互作用に対してオープンにしておかなければな らないので、ビジネストランザクションが複数のリクエストにまたがっている場合は実際的 ではない。 一貫性のない読み込みを回避できるように、読み込んだオブジェクトの変更点を 記録しなければならない場合、 さらに状況は難しくなる。

ユニットオブワークは、データベースに影響を与えるビジネストランザクション中に行わ れるすべての作業を記録する。 その結果、作業終了時には、データベースを変更するために 行うべきあらゆる作業が明らかになるのである。

11.1.1 動作方法

データベースへの対処が必要となる明確な原因は、 新しいオブジェクトの作成や、 既存オ ブジェクトの更新や削除といった変更である。 ユニットオブワークは、それらの変更の結果 を記録するオブジェクトである。 データベースに影響を与えることを行うときは、まずユ ニットオブワークを作成して変更を記録する。 オブジェクトの作成、変更、削除を行うたび にユニットオブワークに通知する。 また、すでに読み込んだオブジェクトについても通知す るため、ビジネストランザクション中にデータベース上の一切のオブジェクトに変更がない ことを検証することで、一貫性のない読み込みをチェックすることができる。

ユニットオブワークの特長は、 コミットするときに何をすべきかを自ら決定する点である。 ユニットオブワークは、トランザクションをオープンし、 あらゆる並行性チェックを行い (重オフラインロックまたは軽オフラインロックを使用)、 データベースの変更を書き込む。 アプリケーションのプログラマは、データベース更新のためのメソッドを明示的に呼び出さ ないので、何が変更されたかを記録する必要はなく、参照整合性が処理の順番にどう影響す るかを心配する必要もない。

もちろん、こうした機能を有効にするには、 記録対象となるオブジェクトがどれであるか をユニットオブワークが知っている必要がある。 そのためには呼び出しを使用するか、 オブ ジェクトからユニットオブワークに指示を出すようにする。

caller registration (呼び出し元登録) では (図11.1)、 オブジェクトのユーザは変更が あった場合、ユニットオブワークを使用してオブジェクトを登録する必要がある。 登録され ていないオブジェクトは、 コミット時に書き込まれないからである。

登録を忘れてトラブルを起こす可能性もあるが、書き込みたくない変更をメモリ上で行え るという柔軟性も持っている。 ただ私としては、余計な混乱を招く可能性があることは指摘 しておきたい。混乱を招かないためには、明示的なコピーを作成する方法をお勧めする。

第1章 オブジェクトリレーショナル振る舞いパターン

client new (ID) customer set credit limit save update database unit of work select register dirty (customer) commit

図 11.1 一呼び出し元による変更されたオブジェクトの登録

object registration (オブジェクト登録) では (図 11.2), 呼び出し元に負荷はかからな い。 オブジェクトメソッドに registration (登録) メソッドを配置するからである。 データ ベースからオブジェクトを読み込むときは、オブジェクトを確定したオブジェクトとして登 録し、 set メソッドはオブジェクトを不確定なものとして登録する。 このスキームが機能す るためには、ユニットオブワークをオブジェクトに渡すか、 既知の場所に配置しておく必要 がある。

client new customer select database unit of work register clean set credit limit register dirty commit update save

図 11.2 受け取り先オブジェクトのオブジェクト自体による登録

ユニットオブワークの受け渡しは面倒だが、何らかのセッションオブジェクト内に置いて おくことには特に問題はない。

オブジェクト登録にしても、覚えておかなければならないことがある。 オブジェクトの開 発者は、登録のための呼び出しを、 適切な場所に追加しておかなければならない。 こうした ことは習慣化できるものだが、忘れるとかなり難しいバグとなるので注意してほしい。

適切な呼び出しを生成するのはコード生成の仕事だが、これは、生成されるコードと生成 されないコードが明確に分かれている場合に実行可能である。 この問題はとりわけアスペク ト指向プログラミングに当てはまるものである。私はこの問題を解決するために、オブジェ クトファイルの後処理 (ポストプロセッシング) という方法を思いついた。 この例では、ポ ストプロセッサはすべてのJava .class ファイルをチェックし、 メソッドを探して、 バイト

第1章 オブジェクトリレーショナル振る舞いパターン

コードに登録呼び出しを挿入している。 こうした凝った方法は洗練されていないように感 られるかもしれないが、データベースコードを通常のコードから分離するのである。 アス クト指向プログラミングはソースコードを使って処理をもっときちんと行う。 ツールが次第 に一般的となって来たため、 今後はこうした手法がますます使用されるだろうと私は予想し ている。

私が知っている他の技法としては、 TOPLink 製品のユニットオブワークコントローラ (図 11.3 参照) が挙げられる。 ユニットオブワークコントローラでは、ユニットオブワーク がデータベースからのあらゆる読み込み処理をし、 確定したオブジェクトが読み込まれたと きにそれを登録する。 ユニットオブワークは、 オブジェクトを不確定なものとしてマーキン グするのではなく、読み込み時にコピーを取得し、コミット時にオブジェクトと照合するの である。これによってコミット処理にオーバーヘッドが生じるが、 実際に変更されたフィー ルドだけを更新でき、ドメインオブジェクト内での登録呼び出しは回避できる。 こうしたハ イブリッドな手法によって、 変更されたオブジェクトだけコピーを取得するようにする。 登 録は必要だが、 選択的に更新することができるため、 更新以上に読み込みが多い場合には、 コピーによるオーバーヘッドを大幅に軽減できる。

オブジェクト作成時には、 呼び出し元登録を考慮すべきであるが、 一時的なオブジェクト を作成する人にとっては、 特別目新しいことではない。 その最も良い例がドメインオブジェ クトのテストである。 この場合、 データベース書き込みがない分テストの実行速度が高速化 される。 呼び出し元登録でこのメリットを実現できる。 しかしこの他にも、ユニットオブ ワークによる登録を行わない一時コンストラクタを提供したり、 コミットには何も関知しな スペシャルケースのユニットオブワークを提供したりするといった解決方法もある。

また、ユニットオブワークの有効なもう1つの領域は、データベースが参照整合性を行う 際の更新の順番である。 SQL 呼び出しごとではなく、 トランザクションがコミットする時 点でデータベースが、 確実に参照整合性をチェックし、更新の順番を気にしなくてもよくな る。 ほとんどのデータベースでこの処理を行うことができるので、できる限りこの方法を使 用することを勧める。 使用できない場合には、 ユニットオブワークこそが、 こうした更新の 順序を整理するには最適である。 小規模なシステムでは、 依存性外部キーに基づいたテーブ ルへの詳細な書き込み順を含んだ明示的なコードによってこの処理を実行できる。一方、 大規模アプリケーションでは、メタデータを使用して、 データベースへの書き込み順序を決 めることを勧める。 この手順は本書が扱う範囲ではないので、 商用ツールを参考にすること。 自分自身でメタデータを使用しなければならない場合、 そのパズルの鍵はトポロジカルソー トであると私は認識している。

同様のテクニックを使って、 デッドロックの最小化もできる。 すべてのトランザクション が同じ順番でテーブルを編集して、 デッドロックのリスクはかなり軽減される。 ユニットオ ブワークは、テーブル書き込みの決まった順序を保持するには最適な場所であり、常に同じ

client new customer select database unit of work register clean set credit limit register dirty commit save update ----

図 11.2 受け取り先オブジェクトのオブジェクト自体による登録

ユニットオブワークの受け渡しは面倒だが、何らかのセッションオブジェクト内に置いて おくことには特に問題はない。

オブジェクト登録にしても、覚えておかなければならないことがある。 オブジェクトの開 発者は、登録のための呼び出しを、 適切な場所に追加しておかなければならない。 こうした ことは習慣化できるものだが、忘れるとかなり難しいバグとなるので注意してほしい。

適切な呼び出しを生成するのはコード生成の仕事だが、これは、生成されるコードと生成 されないコードが明確に分かれている場合に実行可能である。 この問題はとりわけアスペク ト指向プログラミングに当てはまるものである。 私はこの問題を解決するために、オブジェ クトファイルの後処理(ポストプロセッシング) という方法を思いついた。 この例では、ポ ストプロセッサはすべてのJava .class ファイルをチェックし、 メソッドを探して、 バイト

第1章 オブジェクトリレーショナル振る舞いパターン

200

コードに登録呼び出しを挿入している。こうした凝った方法は洗練されていないように られるかもしれないが、データベースコードを通常のコードから分離するのである。 アス クト指向プログラミングはソースコードを使って処理をもっときちんと行う。 ツールが次 に一般的となって来たため、今後はこうした手法がますます使用されるだろうと私は予想 ている

私が知っている他の技法としては、 TOPLink 製品のユニットオブワークコントロー (図 11.3 参照) が挙げられる。 ユニットオブワークコントローラでは、ユニットオブワーイ がデータベースからのあらゆる読み込み処理をし、 確定したオブジェクトが読み込まれた きにそれを登録する。 ユニットオブワークは、 オブジェクトを不確定なものとしてマーキン グするのではなく、読み込み時にコピーを取得し、 コミット時にオブジェクトと照合するの である。これによってコミット処理にオーバーヘッドが生じるが、 実際に変更されたフィー ルドだけを更新でき、 ドメインオブジェクト内での登録呼び出しは回避できる。 こうしたパ イブリッドな手法によって、変更されたオブジェクトだけコピーを取得するようにする。 登 録は必要だが、 選択的に更新することができるため、 更新以上に読み込みが多い場合には、 コピーによるオーバーヘッドを大幅に軽減できる。

オブジェクト作成時には、 呼び出し元登録を考慮すべきであるが、 一時的なオブジェクト を作成する人にとっては、 特別目新しいことではない。 その最も良い例がドメインオブジェ クトのテストである。 この場合、 データベース書き込みがない分テストの実行速度が高速化 される。 呼び出し元登録でこのメリットを実現できる。 しかしこの他にも、 ユニットオブ ワークによる登録を行わない一時コンストラクタを提供したり、コミットには何も関知しな スペシャルケースのユニットオブワークを提供したりするといった解決方法もある。

また、ユニットオブワークの有効なもう1つの領域は、 データベースが参照整合性を行う 際の更新の順番である。 SQL 呼び出しごとではなく、トランザクションがコミットする時 点でデータベースが、確実に参照整合性をチェックし、更新の順番を気にしなくてもよくな る。 ほとんどのデータベースでこの処理を行うことができるので、できる限りこの方法を使 用することを勧める。 使用できない場合には、ユニットオブワークこそが、 こうした更新の 順序を整理するには最適である。 小規模なシステムでは、 依存性外部キーに基づいたテーブ ルへの詳細な書き込み順序を含んだ明示的なコードによってこの処理を実行できる。 一方、 大規模アプリケーションでは、メタデータを使用して、 データベースへの書き込み順序を決 めることを勧める。 この手順は本書が扱う範囲ではないので、 商用ツールを参考にすること。 自分自身でメタデータを使用しなければならない場合、 そのパズルの鍵はトポロジカルソー

トであると私は認識している。

同様のテクニックを使って、 デッドロックの最小化もできる。 すべてのトランザクション が同じ順番でテーブルを編集して、 デッドロックのリスクはかなり軽減される。 ユニットオ ブワークは、テーブル書き込みの決まった順序を保持するには最適な場所であり、常に同じ

順番でテーブルにアクセスできる。

第1章 オブジェクトリレーショナル振る舞いパターン

オブジェクトは現行のユニットオブワークを見つけられなくてはならない。もっとも有効 な手段は、スレッドスコープされているレジストリを使う方法である。 もう1つの方法は、 メソッド呼び出しあるいはオブジェクトの作成時に、 ユニットオブワークが必要なオブジェ クトに渡す方法である。 いずれの場合も、複数のスレッドがユニットオブワークに同時にア クセスできないようにしておく (この点がかなり面倒である)。

client new customer set credit limit load select database unit of work load (customer) commit differences to (customer clone) ! [customer changed] update new customer clone

図 11.3 データベースアクセスのためのコントローラとしてのユニットオブワークの使用

ユニットオブワークでは、バッチ更新の処理が重視されている。 batch update (バッチ 更新)の基本的な考え方は、1つのリモート呼び出しで処理できるように複数の SQL コマ ンドを1つのユニットとして送信することである。 更新、 挿入および削除が立て続けに送信 される場合、とくに重要になる。 違う環境ではバッチ更新に対して、異なるレベルのサポー トが提供される。 JDBC には、 個々のステートメントをバッチ化する機能が用意されている。

202

また、こうした機能を持たない場合、 複数の SQL 文から構成される文字列を作成し、1つ のステートメントとして送ることで、同じ動作を行うことができるようになる。 [Nilsson]で は Microsoft プラットフォーム用のサンプルを紹介している。 しかし、実際に行う場合、

ステートメントのプリコンパイルに支障をきたすことがないかどうかを確認しておこう。

ユニットオブワークは、データベースだけでなく、 あらゆるトランザクションリソースに 使用できるため、メッセージキューやトランザクション監視との関係を変えることもできる。

.NET の実装

.NET では、ユニットオブワークがないデータセットによって処理されるため、 従来のパターンとは少し異なるパターンとなる。 私がこれまでに出会ったほとん どのユニットオブワークは、 オブジェクトへの変更を登録し記録している。 .NET はデータをデータベースからデータセットに読み込む。 データセットとは、デー タベースのテーブル、行、列のように配置された一連のオブジェクトであり基本 的に、1つまたは複数の SQLクエリーのメモリ上のミラーイメージである。 各 データ行は、バージョン(カレント、オリジナル、 内容) 状態 (未変更、追加、 削除、修正) という概念を持っていて、 データセットによるデータベース構造の模 倣と、この概念によってデータベースへの簡単な変更の書き込みが可能になる。

11.12 使用するタイミング

ユニットオブワークの基本動作は、処理されたさまざまなオブジェクトを記録することで、 メモリ上のデータとデータベースを同期するのに、どのオブジェクトが必要であるかを知る ことができる。 すべての作業をシステムトランザクション内で行うことができるとしたら、 注意すべき唯一のオブジェクトは変更を加えたオブジェクトということになる。 ユニットオ ブワークはそのための最も有効な方法の1つだが、他の選択肢もある。

最もシンプルな選択肢は、変更を行った時点でオブジェクトを明示的に保存する方法で ある。この場合の問題点は、 作業中に3箇所で1つのオブジェクトに変更を加えている場 合、それぞれに3回の呼び出しを行わなければならないので、 最後に1回の呼び出しを行 う場合よりもデータベースの呼び出し回数が予想以上に増えてしまうことである。 複数の データベース呼び出しを避ける方法は、すべての更新を最後に行うことだ。 そのためには、 変更が加えられたすべてのオブジェクトを記録しておく必要がある。 記録にはコード中の変 数を使うこともできるが、 変数の数が一定以上に増えると、 管理不能となってしまう。 トラ ンザクションスクリプトでは変数は有効に機能する場合が多いが、 ドメインモデルではとて も難しい。

オブジェクトを変数として保持する代わりに、 オブジェクトごとに不確定フラグを使用し、

第1章 オブジェクトリレーショナル振る舞いパターン

オブジェクトに変更があった時点で、フラグを設定するという方法も考えられる。 その場合、 トランザクションの最後にすべての不確定なオブジェクトを見つけて書き出す必要がある。 この技法の使い勝手は、 不確定なオブジェクトを簡単に見出せる構造になっているかどうか に拠る。 すべてのオブジェクトが1つの階層構造に収まっていれば、その階層を縦断して、 変更されたすべてのオブジェクトを書き出すことができるが、 ドメインモデルのような一般 的なオブジェクトネットワークにおいては、 縦断は容易ではない。

ユニットオブワークの最大の強みは、すべての情報を1箇所に保存する点である。 使い始 めると、後は変更の順序についてほとんど記憶する必要はない。 またユニットオブワークは、 軽オフラインロックや重オフラインロックを使用している、 複数のシステムトランザクショ ンにわたるビジネストランザクションの処理といった、 より複雑な状況に適した確実なプ ラットフォームでもある。

11.1.3 例 オブジェクト登録を備えたユニットオブワーク (Java)

(by David Rice)

特定するビジネストランザクションに対するすべての変更を記録し、その後指示があった 時点でデータベースにそれらをコミットするユニットオブワークを解説する。このドメイン レイヤはレイヤスーパータイプ、 ドメインオブジェクトを持ち、 ユニットオブワークと相互 作用する。 変更セットの保存には、3つのリスト (新規、 不確定、 削除 ドメインオブジェク ト) を使用する。

class UnitOfWork...

private List newObjects = new ArrayList(); private List dirtyObjects = new ArrayList(); private List removed objects = new ArrayList();

登録メソッドは、リストの状態を保持し、ID が null (設定なし) でないことや、 不確定 なオブジェクトが新規として登録されていないことをチェックするような基本的なアサー ションを実行する。

class UnitOfWork...

public void register New (DomainObject obj) {

Assert.notNull("id not null, obj.getId()); Assert.isTrue("object not dirty", !dirtyObjects.contains(obj)); Assert.isTrue("object not removed", removedObjects.contains (obj));

204

Assert.isTrue("object not already registered new",

newObjects.contains (obj));

newObjects.add(obj);

}

public void register Dirty (DomainObject obj) { Assert.notNull("id not null", obj.getId()); Assert.isTrue("object not removed",

! removedObjects.contains (obj));

if (!dirtyObjects.contains (obj) &&

!newObjects.contains (obj))

{ dirtyObjects.add(obj);

}

public void register Removed (DomainObject obj) { Assert.notNull("id not null", obj.getId());

if (newObjects.remove(obj)) dirtyObjects.remove(obj);

return;

if (!removedobjects.contains (obj)){

removedObjects.add(obj);

}

public void registerClean (DomainObject obj) {

Assert. notNull("id not null", obj.getId());

}

registerClean () は何も処理しない点に注目してほしい。 通例では、ユニットオブワーク 内に一意マッピングを配置する。 同じオブジェクトの複数コピーが未定義の振る舞いとなる こともあるため、一意マッピングはドメインオブジェクトの状態をメモリ上に格納する場合 には必要不可欠である。 一意マッピングが配置される場合、 registerClean () は登録された オブジェクトをそこに格納する。 同様に registerNew () は新規オブジェクトをマッピング に置き、 registerRemoved() は削除されたオブジェクトをマッピングから取り除く。 一意 マッピングがない場合は、 ユニットオブワークに registerClean () を含まないという選択 肢もあるが、 私は、 不確定リストから変更オブジェクトを削除するといったメソッドの実装 を目にしたことがある。 しかし変更の部分的なロールバックは常に扱い難いものである。 変 更セットの状態を修正する場合には、とくに注意が必要である。

commit() は各オブジェクトのデータマッパーを検索し、 適切なマッピングメソッドを実 行する。 updateDirty () と deleteRemoved() は示されていないが insertNew() のように振 る舞う。

}

}

class UnitOfWork...

public void commit() {

insertNew();

updateDirty();

deleteRemoved();

private void insertNew() { for Iterator objects = newObjects.iterator(); objects.hasNext();) ( ) DomainObject obj = (DomainObject) objects.next(); MapperRegistry.getMapper (obj.getClass()).insert(obj);

すでに読み込まれ、コミット時に一貫性のない読み込みエラーをチェックしたいオブジェ クトの記録は、ユニットオブワークには含まれていない。 こうした処理は、 軽オフライン ロックで実行されることになる。

次に、オブジェクト登録を始める。 まずは、各ドメインオブジェクトが、 現在のビジネス トランザクションを担当するユニットオブワークを見つけることである。 すべてのドメイン モデルがユニットオブワークを必要とするため、パラメータとしてそれを渡す方法は合理的 ではない場合が多い。 各ビジネストランザクションが1つのスレッド内で実行される場合、 java.lang.ThreadLocal クラスを使ってユニットオブワークを現在実行中のスレッドに関 連付ける。 シンプルにするため、 ユニットオブワーククラスで静的メソッドを使用して、こ の機能を追加する。 ビジネストランザクション実行スレッドに関連付けられた何らかのセッ ションオブジェクトがすでにある場合、 管理オーバーヘッドが生じる別のスレッドマッピン グを追加するよりは、セッションオブジェクトに現行のユニットオブワークを配置する方が 得策である。 また、ユニットオブワークは論理上セッションに属している。

class UnitOfWork...

private static ThreadLocal current = new ThreadLocalpublic static void newCurrent(){ setCurrent (new UnitOfWork ()); } public static void setCurrent (UnitOfWork uow) { } current.set (uow); public static UnitOfWork getCurrent() { return (UnitOfWork) current.get(); }

();

)

206

これで現行のユニットオブワークを使用して、 抽象ドメインオブジェクト自体を登録する ためのマーキングメソッドを提供できる。

class DomainObject....

protected void markNew () {

UnitofWork.getCurrent().register New (this);

protected void markClean () {

UnitOfWork.getCurrent().registerClean (this);

}

protected void markDirty () (

Unitofwork.getCurrent().registerDirty (this);

protected void markRemoved() {

}

UnitOfWork.getCurrent().registerRemoved (this);

}

具象ドメインオブジェクトは、必要に応じて、忘れずに新規および不確定とマーキングす る必要がある。

class Album...

public static Album create (String name) {

Album obj = new Album (IdGenerator.nextId(), name);

obj.markNew();

return obj;

public void setTitle (String title) {

this.title = title;

markDirty();

}

削除オブジェクトの登録が、 抽象ドメインオブジェクト上のremove() メソッドによって 処理されるとは限らない。 また、 registerClean() を実装している場合、 データマッパーは 新たに読み込まれたオブジェクトを確定したものとして登録する必要がある。

)

最後に、必要に応じてユニットオブワークを登録しコミットする。 この処理は、明示的に も暗黙的にも実行できる。 明示的なユニットオブワーク管理の例を以下に示す。

)

class EditAlbumScript...

第1章 オブジェクトリレーショナル振る舞いパターン

public static void updateTitle (Long albumId, String title) { UnitOfWork.newCurrent(); Mapper mapper = MapperRegistry.getMapper (Album.class); Album album= (Album) mapper.find(albumId); album.setTitle(title); UnitOfWork.getCurrent().commit(); )

単調で繰り返しの多いコーディングを避けたい場合には、どんなにシンプルなアプリケー ションよりも、暗黙的なユニットオブワーク管理がよい。 具象サブタイプに対してユニット オブワークを登録し、 コミットするサーブレットレイヤスーパータイプを以下に示す。 サブ タイプは doGet() をオーバーライドするのではなく、 handleGet () を実装する。 handleGet () の内部で実行されるすべてのコードには、ともに動作するユニットオブワーク を持つことになる。

class UnitOfWorkServlet...

final protected void doGet (HttpServletRequest request,

HttpServletResponse response) throws ServletException, IOException {

try(

UnitOfWork.newCurrent();

handleGet (request, response);

UnitOfWork.getCurrent().commit();

} finally {

UnitOfWork.setCurrent(null);

}

)

abstract void handleGet (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException;

上記のサーブレットサンプルは、システムトランザクション制御をスキップしている点で、 やや単純化されている。 フロントコントローラを使用する場合、 doGet() ではなく、コマン ドにユニットオブワークをラップするため、 あらゆる実行コンテキストで、 同様のラップが 実行できる。

208

11.2 一意マッピング

読み込まれたすべてのオブジェクトを1つのマッピングに保存することで、各オブジェ クトが確実に一度だけ読み込まれるようにする。 オブジェクトを参照する場合には、 マッピングを使って参照する。

find (1) finder found = get (1) => identity map database [found not null] found [found is null found = select where id = 1

古い格言に、 「時計を2つ持つものは決して時間を知るすべを知らない」というのがある。 2つの時計が合っていないと、データベースからのオブジェクトの読み込みにおいては、さ らに大きな混乱を招くだろう。 注意を怠れば、 同じデータベースレコードから2つの異なる オブジェクトにデータを読み込んでしまうこともあるからだ。 その後、 双方を更新すると、 データベースにそれぞれの変更が書き込まれるという奇妙な結果が生じてしまう。

こうした状況はパフォーマンスにも影響する。 同じデータを2回以上読み込むことで、リ モート呼び出しに負荷がかかる。 つまり、 同じデータを2回読み込まないことで、正確さを 確保でき、アプリケーションの処理速度も向上するのである。

一意マッピングは、1つのビジネストランザクションにおいて、 データベースから読み込 まれたすべてのオブジェクトを記録する。 オブジェクトが必要になったときには、 まずは一 意マッピングを確認してオブジェクトがすでに読み込み済みであるかどうかを判断できるの である。

11.21 動作方法

一意マッピングの基本的な考え方は、データベースから取得されたオブジェクトを含む一 連のマッピングを用意することである。 シンプルなケースでは、同じ形式のスキーマによっ て、データベーステーブルごとに1つのマッピングを持つようにする。 データベースからオ ブジェクトを読み込む場合、 まずはマッピングをチェックする。 その中に読み込もうとして いるオブジェクトがある場合、 一意マッピングはそれを返す。 ない場合はデータベースに移

動し、オブジェクトを読み込むと同時に、今後のためにマッピングにも格納する。

注意しなければいけないのは、実装の選択肢である。 また、 一意マッピングは並行性管理 によって相互作用するため、 軽オフラインロックについても考慮しなくていけない。

11.2.1.1 キーの選択

最初に考慮すべきは、マッピングのキーである。 まず考えられる選択肢は、対応するデー タベーステーブルのプライマリキーである。 キーが1つの列で不変である場合は、 うまくい く。 代理プライマリキーは、マッピングのキーとして使用することもできるため、この手法 にとても適している。キーはシンプルなデータタイプとなるため、比較する場合も有効に機 能する。

11.2.1.2 明示的あるいは汎用

一意マッピングは、明示的あるいは汎用のいずれかを選択しなければならない。 明示的な 一意マッピングは、必要とするオブジェクト固有のメソッド (例: findPerson (1))を使用 してアクセスされる。 一方、 汎用マッピングは、 あらゆるオブジェクトに対して1つのメ ソッドを使用し、必要とするオブジェクトの種類をパラメータで指定する (例: find("Person*, 1))。 明確なメリットは、 汎用で再使用可能なオブジェクトを使用して汎 用マッピングをサポートできる点である。 あらゆる種類のオブジェクトに機能し、 新しい マッピングの追加時にも更新する必要がない再使用可能なレジストリをたやすく構築できる。

しかし、私の好みは明示的な一意マッピングである。 まず第一に、厳密にタイプ化された 言語によるコンパイル時チェック機能を持っている。 さらに、明示的なインタフェースのあ らゆるメリットを持っている。 どのマッピングが使用可能であり、 何と呼ばれているかを簡 単に知ることができる。この場合、 新しいマッピングを追加するごとにメソッドが追加され るが、明示的であることのメリットに比べればたいした問題ではない。

選択を左右するのはキーのタイプである。 すべてのオブジェクトが同じタイプのキーを持 つ場合は、汎用マッピングを使用する。 キーのタイプこそが、1つのキーオブジェクトの裏 側にさまざまな種類のデータベースキーをカプセル化するための最適な引数になる (詳しく は一意フィールド参照)。

11.2.1.3 マッピングの数

クラスごとに1つのマッピングを使用するか、セッション全体に1つのマッピングを使用 するかを決定する必要がある。 データベース固有のキーを持っている場合は、セッションを 対象とした1つのマッピングが機能する(この点のトレードオフについては一意フィールド の解説を参照)。 1つの一意マッピングを持つ場合のメリットとしては、参照先を1つに限 定し、継承についての面倒な決定が不要となる点が挙げられる。

210

複数のマッピングを持つ場合は、クラスごとに1つのマッピングか、 テーブルごとに1つ のマッピングを使用することになるが、 データベーススキーマとオブジェクトモデルが同じ場 合には有効である。 両方が異なるようであれば、オブジェクトはマッピングの複雑さを知る必

要がないため、テーブルよりもオブジェクトをマッピングのベースにする方が簡単である。

継承という難しい問題がある。 Vehicle (乗り物) のサブタイプとしてのCar (自動車) を使用する場合、1つのマッピングを持つだろうか、それとも別々のマッピングを持つだろ うか。 マッピングを分離、 参照するときは、 すべてのマッピングを照合しなければならない ので、ポリモーフィズムによる参照はより複雑になってしまう。 こうした理由から、私は 氷ツリーごとに1つのマッピングを使用する方法を好む。 その場合は、継承ツリーにまた がった一意のキーを使用するが、具象テーブル継承を使用する場合、 より面倒になると思う。

1つのマッピングのメリットは、データベースを追加しても、新しいマッピングを追加す る必要がない点である。 ただし、 データマッパーにマッピングを結び付けることは、それほ ど大きな作業負荷ではないが。

11.2.1.4 どこに配置するか

一意マッピングはできる限り見つけやすい場所に置く必要がある。 また、それらはプロセ スコンテキストに結び付けることがある。 各セッションは他のあらゆるセッションのインス タンスとは分離した独自のインスタンスを持つようにしておく。 つまり、一意マッピングは セッション固有のオブジェクトに配置する必要があるということである。 ユニットオブワー クを使用する場合、 ユニットオブワークがデータベースに挿入またはデータベースから抽出 するデータを記録するためにも最も適した場所であるため、 一意マッピングにとっても明ら かに最良の配置場所である。 一方、ユニットオブワークを使用しない場合は、 セッションと 結び付いたレジストリが最良の場所となる。

ここで記述したように、セッションに対して1つの一意マッピングを使用することが多い。 そうでない場合は、マッピングに対するトランザクション上の保護を提供する必要があるが、 どんな開発者にもより多くの作業が要求される。 しかし、2、3の例外もある。その1つは、 たとえレコードデータにリレーショナルデータベースを使用しても、 オブジェクトデータ ベースをトランザクション上のキャッシュとして使用している場合である。 私はこの方法だ けを使用した場合のパフォーマンスの調査を目にしたことはないが、 注目に値するものはい くつもある。 事実、 私が尊敬する多くの人が、パフォーマンスの改善の手段として、このト ランザクション上のキャッシュに注目している。

もう1つの例外は、どんな場合でも読み込みだけしかできない読み取り専用オブジェクト である。 オブジェクトが絶対に修正できないとしたら、 セッションにまたがって共有された としても、心配する必要はまったくない。パフォーマンス重視のシステムにおいては、すべ ての読み取り専用データを一度に読み込み、 プロセス中ずっと使用可能な状態にしておくと

よいのである。 その場合、 読み取り専用の一意マッピングをプロセスコンテキストに保持し、 更新可能な一意マッピングはセッションコンテキストに保持しておく。 この方法は、 完全な 読み取り専用ではないが、更新される可能性のほとんどない (万が一、 そうした更新が発生 したときには、プロセスワイドの一意マッピングを消去して、サーバを切り離しても惜しく ないような) オブジェクトにも適用できる。

ただ1つの一意マッピングを使う状況であっても、 読み取り専用ラインと更新可能ライン の2つに分割しておくことである。 両方のマッピングをチェックするインタフェースを提供 することで、クライアントは両方の違いを意識しなくてもすむようになるからである。

11.22 使用するタイミング

一般的に、一意マッピングはデータベースから抽出され、修正されたオブジェクトの管理 に使用される。 主な理由は、2つのメモリ上のオブジェクトが1つのデータベースレコード に対応しているという状態を回避するためである。 2つのレコードを並行して修正した結果、 データマッピングが混乱することもある。

一意マッピングのもう1つのメリットとしては、 データベース読み込みのキャッシュとし て機能する点が挙げられる。 何らかのデータが必要になるたびに、その都度データベースに アクセスする必要がなくなるのである。

不変オブジェクトに対しては、 一意マッピングは必要ないかもしれない。 オブジェクトが 変更できない場合、 修正の間違いについては心配ない。 バリューオブジェクトは不変である ため、それらに対しては一意マッピングは不要である。 また一意マッピングにはいくつかの メリットがあり、中でも一番重要なものは、キャッシュによるパフォーマンス上のメリット である。 その他にも、 Java において問題となっている、 をオーバーライドできないため に発生する、間違った形式の等価テストの使用を回避することにも役立つ点を挙げることが できる。

依存マッピングには一意マッピングは必要ない。 依存オブジェクトの持続性は親によって 制御されるため、一意性を維持するためのマッピングは必要ないのである。 しかし、マッピ ングは必要なくても、データベースキーを介してオブジェクトにアクセスする必要がある場 合には、一意マッピングの提供が求められる。 その場合マッピングは単なるインデックスで あるが、それをマッピングと見なすかどうかについては議論の余地がある。

一意マッピングは、1つのセッション内での更新競合の回避について役立つが、 セッショ ンにまたがる競合の処理においてはまったく効果がない。 これは込み入った問題であり、 詳 しくは軽オフラインロックおよび重オフラインロックの項で解説する。

第1章 オブジェ

21 2

11.2.3 例: 一意マッピングのためのメソッド (Java)

それぞれの一意マッピングごとに、マッピングフィールドとアクセッサーを使用する。

private Map people = new HashMap(); public static void addPerson (Person arg) { soleInstance.people.put(arg.getID(), arg); } public static Person getPerson (Long key) { return (Person) soleInstance.people.get(key); } public static Person getPerson (long key) { } return getPerson (new Long (key));

Java の弱点の1つとして、 long がオブジェクトではないため、マッピングのインデック スとして使用できないという点がある。 ただ、 インデックスでは計算を一切行わないため、 実際にはそれほど困ることではない。 唯一問題となるのは、リテラルとともにオブジェクト を抽出したい場合である。 プロダクションコードにおいてはほとんど必要なくても、テスト コードでは頻繁に必要とされることがある。 そのため私自身もテストを容易にするために、 long を使用した get メソッドを含めたことがある。

11.3 レイジーロード

必要なすべてのデータは含まないが、その取得方法を知っているオブジェクト。

get orders return orders customer [orders not loaded] load orders database

データベースからメモリにデータを読み込む場合、 対象となるオブジェクトを読み込むと 同時に、関連したオブジェクトも読み込むように設計しておくことは有用である。 すべての オブジェクトを明示的に読み込む必要がなくなる分、 オブジェクトを使用する開発者にとっ て読み込みが容易になるからである。

しかし、こうした考え方を論理的に突き詰めると、1つのオブジェクトの読み込みが無数 の関連オブジェクトの読み込みに影響する可能性もあり、必要なオブジェクトがほんの2つ か3つという場合には、パフォーマンス上に問題が生じてしまう。

レイジーロードは、こうした読み込みプロセスをとりあえず中断し、 オブジェクト構造に おけるマークをそのままにすることで、データが必要な場合には、使用するときだけ読み込 むことができるようになる。 つまり、ある作業を怠けていたとして、 作業が本当に不要で あったことが判明した時点で、 結局は得をすることになるのである。

11.3.1 動作方法

レイジーロードを実装するには以下の4つの方法がある。 それはレイジーイニシャライズ、 仮想プロキシー バリューホルダーおよびゴーストである。

レイジーイニシャライズ [Beck Patterns) は、最もシンプルな手法である。 基本的な考 え方は、フィールドへのアクセスごとにチェックを行い、 null (設定なし) かどうかを確認 するというものである。その場合は、フィールドを返す前にフィールドの値を計算する。可 能にするには、フィールド自身を確実にカプセル化しておく、 つまり、 クラス内のものも含 めて、フィールドへのすべてのアクセスがget メソッドを介して行われるようにする必要が ある。

null 値がフィールドの正規の値でない限り、 null 値を使ってまだ読み込まれていない フィールドを示す方法が有効である。 その場合、 フィールドがまだ読み込まれていないこと を示すために何か他の処理を行うか、 あるいは、 null 値に対してはスペシャルケースを使用 する必要がある。

レイジーイニシャライズの使用はシンプルだが、オブジェクトとデータベース間の依存が 強くなる傾向がある。 こうした理由から、レイジーイニシャライズはアクティブレコード、 テーブルデータゲートウェイ、 行データゲートウェイにとても適している。 データマッパー を使用する場合、インダイレクションの追加レイヤが必要となるが、 それを入手するために は仮想プロキシー [Gang of Four] を使用する。 仮想プロキシーは、フィールドに必須なオブ ジェクトのように見えるが何も含んでいない。 メソッドの1つが呼び出されたときだけデー タベースから正しいオブジェクトを読み込む。

仮想プロキシーのメリットとは、まるでそこにあるべきオブジェクトのように見える点で ある。 一方、欠点は、 オブジェクトではないためにとても難しい一意性の問題を引き起こし

214

やすい点である。さらに、同様なオブジェクトに対しても、複数の仮想プロキシーを使用す ることができる点である。 すべてのプロキシーは異なるオブジェクト ID を持つが、 同じ概 念上のオブジェクトを表しているのである。 少なくとも、 equality (等価) メソッドをオー バーライドする必要があり、 identity (識別) メソッドの代わりに、忘れずに使用する必要 がある。 これを怠ると、 とても追跡しにくいバグが生じるこになる。

ある環境においては、大量の仮想プロキシー (プロキシー化するクラスごとに1つずつ) を作成しなければならない状況に追い込まれることもある。 通常、動的にタイプされた言語 においてはこうした状況を回避できるが、静的にタイプされた言語において、状況が最悪の 状態となることがある。 ブラットフォームに、 Java のプロキシーのような便利な機能が用 意されている場合でも、不具合が生じる可能性がある。

リストのようなコレクションクラスに対してだけ仮想プロキシーを使用する場合には、こ うした問題もとくに表面化することはない。 コレクションクラスはバリューオブジェクトで あるため、 一意性は問題にならない。 また、 バーチャルコレクションを記述する必要のある Collection (コレクション) クラスはそれほど多くない。

ドメインクラスの場合、 バリューホルダーを使用することで、 こうした問題を回避できる。 この概念 (私は最初、 Smalltalk で出会った) は、他のいくつかのオブジェクトをラップす るオブジェクトであると言えよう。 基盤となるオブジェクトを取得するには、バリューホル ダーに対して値を要求するのだが、データベースからデータを取得するのは、最初のアクセ スにおいてだけである。 バリューホルダーの欠点は、クラスがその存在を知っていなくては いけないことと、強力なタイプ化の明示性が失われる点である。 一意性の問題を回避するに は、その所有クラスを超えてバリューホルダーの受け渡しをしないようにすることである。

ゴーストは不完全な状態のオブジェクトである。 データベースからオブジェクトを読み込 む場合、 オブジェクトには、それ自身のIDだけが含まれている。 フィールドにアクセスし ようとするときに、 完全な状態を読み込むのである。 ゴーストとは、すべてのフィールドが まとめてレイジーイニシャライズされるオブジェクトあるいは、オブジェクト自身が独自の 仮想プロキシーとなる仮想プロキシーと考えることができる。 もちろん、すべてのデータを 一挙に読み込む必要はなく、 一緒に使用されるグループにまとめられることである。 ゴース

トを使用する場合、即座に一意マッピングに挿入することはできるので、一意性を確保し、 データ読み込み時の循環参照によって生じるあらゆる問題を回避するのである。

仮想プロキシー ゴーストは、完全にデータが欠けているというわけではない。すぐに入 手できて頻繁に使用されるデータがある場合は、プロキシーまたはゴーストの読み込み時に 読み込むことは有効である (これは 「軽オブジェクト」 と呼ばれることもある)。

継承は、レイジーロードに問題を引き起こす場合が多い。 ゴーストを使用する場合、 どん なタイプのゴーストを作成するかを知っておく必要があるが、正しく読み込みを行わないと、 わからないことがあるのだ。 仮想プロキシーは、静的にタイプされた言語の場合にも同様の

問題がおこる。

もう1つレイジーロードで気をつけなくてはいけないことは、必要以上にデータベースア クセスを発生させてしまう点である。 このような「リプルローディング」の例として、複数 のレイジーロードを1つのコレクションにまとめた後、それらを1つのレイジーロードと見 なす場合が挙げられる。 この場合、すべてをまとめて読み込む代わり、 オブジェクトごとに 毎回データベースにアクセスすることになる。 私は、リプルローディングがアプリケーショ ンのパフォーマンスを損なう例を目にしたことがある。 これを回避する1つの方法としては、 レイジーロードのコレクションを用意しないというのではなく、 コレクション自身をレイ ジーロードにする代わりに、読み込む時点で、すべてのコンテンツを読み込む方法が考えら れる。この方法の限界は、コレクションがとても大きい場合 (たとえば、 世界中のIPアド レスなど) である。 これらはオブジェクトモデルの関連性を介してリンクされることはない ため、それほど頻繁にはありえないが、そうした状況になった場合には、 バリューリストハ ンドラ [Alur et al] が必要となるだろう。

アスペクト指向プログラミングにおいて、レイジーロードは有効な選択肢である。 独立し たアスペクトにレイジーロードの振る舞いを追加することによって、 レイジーロードストラ テジーを個別に変更するだけでなく、レイジーロードの問題解決からドメイン開発者を開放 できる。私は、レイジーロードを透過的な方法で実装する、プロジェクト後処理 Java バイ トコードを目にしたこともある。

異なるユースケースが、 異なるレイジー性を使用して適切に動作している状況を目にする ことも多い。 オブジェクトグラフのサブセットを必要とするものもあれば、別のサブセット を必要とするものもある。 最大の効率性を得るには、正しいユースケースに正しいサブグラ フを読み込むことである。

そのための方法としては、異なるユースケースごとに、個別のデータベース相互作用オブ ジェクトを使用するという方法が挙げられる。 データマッパーを使用する場合、即座に明細を 読み込むマッパーと、後に読み込みを行うマッパーの2種類の Order マッパーオブジェクト を使用する方法である。 アプリケーションコードは、ユースケースに応じて適切なマッパーを 選択する。 バリエーションとしては、同じ基本ローダーオブジェクトを使用するが、読み込み パターンの決定は、どのように行うかと言うストラテジーオブジェクトに従う方法もある。 こ ちらの方がより洗練されているが、振る舞いの抽出では優れた方法であるとは限らない。

理論的にはさまざまなレイジー性が求められるが、必要なのは完全な読み込みか、リスト の識別のために十分な読み込みの2種類である。 それ以上追加すると複雑性が増すだけで、 効果は相殺されてしまう。

第1章 オブジェク

21 6

ナル振る舞いパターン

11.3.2 使用するタイミング

レイジーロードをいつ使用するかは、オブジェクトの読み込み時にデータベースからどれ くらいの量を引き出すか、 また、 それを必要とするデータベース呼び出しが既にあるかに よって決まってくる。 残りのオブジェクトと同じ行にあるフィールドに対するレイジーロー ドはほとんど意味をもたない。 なぜなら、 データフィールドがとても大きい場合でも、 1回 の呼び出しで追加データを元に戻すのに、ほとんど負荷はかからないからである(例:シリ アライズ LOB)。 つまり、 レイジーロードを考慮するのは、フィールドがアクセスの追加 データベース呼び出しを必要とする場合である。

パフォーマンスという点では、 どの時点でデータを元に戻したいかが判断の決め手となる。 一度の呼び出しで必要な要素をすべて取り込み、 所定の場所に配置することをユーザーイン タフェースへの1回の操作で行えるとしたら、とても有効なことである。 追加呼び出しを含 んで呼び出そうとしているデータが、メインオブジェクトの使用中には使用されていないと きこそ、レイジーロードを使用するのである。

レイジーロードの追加は、プログラムが若干複雑になるため、私としては本当に必要なと き以外はあまり使いたくない。

11.3.3 例: レイジーイニシャライズ (Java)

以下のコードは、レイジーイニシャライズの基本を示している。

class Supplier...

public List if (products == null) products = Product.findFor Supplier (getID()); return products;

getProducts() {

このように、 Product フィールドの最初のアクセスで、データはデータベースから読み込 まれる。

11.3.4 例 仮想プロキシー (Java)

仮想プロキシーのキーポイントは、 使用するクラスのように見えるが、シンプルなラッ バーを持つクラスを提供するのである。 つまり、サプライヤーのためのProduct リストは、 リストフィールドによって保持されることになる。

}

class SupplierVL...

第1章 オブジェ

private List products;

このようなリストプロキシーの作成に関して最も複雑なことは、アクセス時にだけ作成さ れる基礎的なリストを提供できる設定を行うことである。 それには、インスタンスの作成時 に、リストを作成するために必要なコードを仮想リストへと渡さなければならない。 Java で それを実現する最良の方法は、読み込みの振る舞いにインタフェースを定義することである。

public interface Virtual List Loader { List load(); }

これによって、適切なマッパーメソッドを呼び出すローダーによって仮想リストをインス タンス化できるようになる。

class SupplierMapper...

public static class ProductLoader implements VirtualList Loader ( private Long id; public ProductLoader (Long id) { } this.id = id; public List load() { return ProductMapper.create().findForSupplier (id);

load メソッドが実行している間、リストフィールドに ProductLoader を割り当てる。

class SupplierMapper...

protected DomainObject doLoad (Long id, ResultSet rs) throws SQLException { String nameArg = rs.getString(2): SupplierVL result = new Supplier VL (id, nameArg); result.setProducts (new VirtualList (new Product Loader (id))); return result; )

218

仮想リストのソースリスト自体はカプセル化され、最初の参照時にローダーを評価する。

class VirtualList...

private List source; private Virtual List Loader loader; public VirtualList (Virtual List Loader loader) ( this.loader = loader; } private List getSource() { if (source == null) source = loader.load(); return source; }

委譲を行う list メソッドは、 その後ソースリストに実装される。

class VirtualList....

public int size() { return getSource().size(); } public boolean isEmpty() { } return getSource().isEmpty(); .. and so on for rest of list methods // ...

このようにドメインクラスは、 Mapper クラスがレイジーロードをどのように行うかは一 切知ることはなく、 事実レイジーロードがあるかどうかさえも関知しないのである。

11.3.5 例: バリューホルダーの使用 (Java)

バリューホルダーは、汎用レイジーロードとして使用できる。 例では、 Product フィール ドがバリューホルダーとしてタイプ化されているため、ドメインタイプは何が進行中である かわかる。 しかし、 get メソッドによってサブライヤーのクライアントからこれを隠すことが できる。

class SupplierVH...

private ValueHolder products; public List getProducts() {

第1章 オブジェ

return (List) products.getValue(); )

バリューホルダー自身は、レイジーロードの振る舞いを行う。 アクセスされた時点でバ リューホルダーがレイジーロードの振る舞いを行うための値を読み込むため、 コードが渡さ れる必要がある。 そのためローダーインタフェースを定義する。

ナル振る舞いパターン

class ValueHolder...

private Object value; private ValueLoader loader; public ValueHolder (ValueLoader loader) { } this.loader loader; public Object getValue() { } if (value = null) value = loader.load(return value; public interface ValueLoader ( Object load(); }

);

マッパーは、ローダーの実装を作成し、サプライヤーオブジェクトに挿入することで、バ リューホルダーを設定する。

class SupplierMapper...

protected DomainObject doLoad (Long id, ResultSet rs) throws ) SQLException { String nameArg = rs.getString(2); SupplierVH result = new SupplierVH (id, nameArg); result.setProducts (new ValueHolder (new ProductLoader (id))); return result; public static class ProductLoader implements ValueLoader { private Long id; public ProductLoader (Long id) { } this.id = id; public Object load() { return ProductMapper.create().findForSupplier (id);

2 2 0

11.3.6 例: ゴーストの使用 (C#)

オブジェクトをゴーストにするロジックを、 レイヤスーパータイプに組み込むことができ る。結果として、ゴーストを使用する場合、 それはあらゆるところに現れる。 そこで、ゴー ストに関する検証を、 まずはドメインオブジェクトレイヤスーパータイプから開始する。 各 ドメインオブジェクトは、それがゴーストであるかどうかを認知している。

class Domain Object...

LoadStatus Status; public DomainObject (1ong key) { } this.Key = key; public Boolean IsGhost ( } get {return Status == LoadStatus. GHOST; } public Boolean IsLoaded { get { return Status == LoadStatus.LOADED; } } public void MarkLoading () { Debug.Assert (IsGhost); } Status = LoadStatus.LOADING; public void MarkLoaded() { } Debug.Assert (Status == LoadStatus.LOADING); Status = LoadStatus.LOADED; enum LoadStatus (GHOST, LOADING, LOADED};

ドメインオブジェクトには、ゴースト、 読み込み中および読み込み済みの3つの状態があ る。私は、読み取り専用プロパティと明示的なステータス変更メソッドで、ステータス情報 をラップする方法を好んで用いてい

ゴーストの最も煩わしい点は、オブジェクトがゴーストである場合、 読み込みのトリガと なるためすべてのアクセス関数を修正する必要がある点である。

class Employee...

public String Name ( get ( Load(); return _name; }

set ( Load(); _name = value; } } String_name;

class Domain Object...

protected void Load() { if (IsGhost) DataSource.Load (this); }

覚えるのは難しいが、バイトコードの後処理をするアスペクト指向プログラミングにとっ ては典型的なターゲットである。

読み込みが機能するためには、ドメインオブジェクトは該当するマッパーを呼び出す必要 がある。 しかし、私の経験からするとドメインコードは、マッパーコードを確認できないこ ともある。 こうしたある特定したものに依存しないためにも、レジストリとセパレートイン タフェースの組み合わせを使うことである(図11.4)。 私は、 データソース操作のためにド メインにレジストリを定義する。

class DataSource...

public static void Load (DomainObject obj) ( instance.Load(obj); }

データソースのインスタンスは、インタフェースを使って定義される。

class DataSource...

public interface IDataSource {

void Load (DomainObject obj);

}

222

domain

data source

Load (DomainObject)

-interface- IDataSource

MapperRegistry

Load (DomainObject)

Load (DomainObject) Init (IDataSource)

DomainObject

class

DataSource

0..1

Mapper

+ Load (DomainObject)

+ AbstractFind(key)

#Load

#doLoadLine

図 11.4ゴーストの読み込みに含まれるクラス

Employee

EmployeeMapper

#doLoadLine

+ Find (key)

データソースレイヤに定義されたマッパーのレジストリは、 Data Source (データソース) インタフェースを実装する。 この場合私は、マッパーをドメインタイプによってインデック ス化されたディクショナリに配置してきた。 Load メソッドは、正しいマッパーを検出して 適切なドメインオブジェクトを読み込むように指示する。

class MapperRegistry : IDataSource...

public void Load (DomainObject obj) { Mapper (obj.GetType()).Load(obj); public static Mapper Mapper (Type type) { return (Mapper) instance.mappers [type]; } IDictionary mappers = new Hashtable();

上記のコードは、ドメインオブジェクトとデータソースとの相互作用を示している。 デー タソースロジックはデータマッパーを使用する。 マッパーの更新ロジックは、ゴーストがな い場合と同様である。 この例では、振る舞いが一連の検索および読み込みの振る舞いの中で 行われている。

具象 Mapper クラスは、 抽象メソッドで結果をダウンキャストする独自の Find メソッド を持っている。

class EmployeeMapper...

public Employee Find (long key) { } return (Employee) AbstractFind (key);

class Mapper...

public DomainObject AbstractFind (long key) } DomainObject result; result = (DomainObject) loadedMap [key]; if (result == null){ } result = CreateGhost (key); loadedMap.Add(key, result); return result; IDictionary loadedMap = new Hashtable();

(

ショナル振る舞いパターン

public abstract DomainObject CreateGhost (long key);

class EmployeeMapper...

public override DomainObject CreateGhost (long key) { return new Employee (key); )

この例からわかるように、 Find メソッドはオブジェクトをGhost (ゴースト) 状態で返 す。データは、ドメインオブジェクト上のプロパティへのアクセスが読み込みのトリガとな るまで、 データベースから取り出せない。

class Mapper...

public void Load (DomainObject obj) { } if (! obj.IsGhost) return; IDbCommand comm= new OleDbCommand (findstatement(), DB.connection); comm.Parameters.Add(new OleDbParameter ("key", obj.Key)); IDataReader reader = comm.ExecuteReader(); reader.Read(); LoadLine (reader, obj); reader.Close(); protected abstract String findStatement (); public void LoadLine (IDataReader reader, DomainObject obj) { if (obj.IsGhost) ( obj.MarkLoading(); doLoadLine (reader, obj):

obj. MarkLoaded();

}

protected abstract void doLoadLine (IDataReader reader, DomainObject obj);

例ではレイヤスーパータイプは、すべての抽象的な振る舞いを処理した後、 特定の動作を 行うサブクラスの抽象メソッドを呼び出す。 今回の例ではデータリーダーを使用したが、こ れはさまざまなプラットフォームにおいて最も一般的なカーソルベースの手法である。 また データセットにも拡張できるようにしているが、 .NET のほとんどのケースでより適してい ると思われる。

Employee オブジェクトでは、シンプルな値のName (名前)、 他のオブジェクト参照の

Department (部署)、 そしてコレクションのケースを示す Timesheet Record (タイム シートレコード)のリストといった3つのプロパティを包含し、サブクラスのフックメソッ ドの実装において同時に読み込まれる。

class EmployeeMapper...

protected override void doLoadLine (IDataReader reader, DomainObject obj) { Employee employee Employee) obj: employee.Name = (String) reader["name"]; Department Mapper depMapper =

(DepartmentMapper) MapperRegistry. Mapper (typeof (Department)); employee.Department = depMapper.Find((int) reader ["departmentID"]);

loadTimeRecords (employee);

}

Name の値は、 データリーダーの現行カーソルから列を読み取ることで簡単に読み込まれ る。 Dapartment は、 Dapartment の Mapper オブジェクトのFindメソッドを使って読 み込まれる。 最終的には、ゴーストのプロパティを設定し、アクセスされた時点で Dapartment のデータだけが読み込まれる。

コレクションは最も複雑なケースである。 リプルローディングを回避するには、 すべての Time Record (タイムレコード)を1度のクエリーで読み込むことが重要である。 そのた めにはGhost (ゴースト)リストとして機能する特別なリストの実装が必要となる。このリ ストは、オブジェクトを包むラッパーであり、すべての振る舞いを委譲する。 ゴーストが行 う唯一のことは、リストへのアクセスを読み込みのトリガにすることである。

class DomainList...

IList data { } get { } Load(): return _data; set {_data = value; } IList_data = new ArrayList(); public int Count { get (return data.Count;) )

ジェクトリレーショナル振る舞いパターン

DomainList クラスは、ドメインオブジェクトで使用され、 ドメインレイヤの一部である。 読み込みには SQL コマンドへのアクセスが必要であるが、 私はマッピングレイヤではなく 委譲を使って読み込み機能を定義している。

class DomainList....

public void Load () (

if (IsGhost) {

MarkLoading ();

RunLoader (this);

MarkLoaded();

}

public delegate void Loader (DomainList list);

}

public Loader RunLoader;

委譲を、1つの機能に対するセパレートインタフェースの特定のバリエーションと考える。 実際に、1つの機能を備えたインタフェースを宣言することは、委譲を実行する有効な選択 肢の1つである。

ローダー自身は、読み込みの SQL を指定するプロパティと、タイムレコードをマッピン グするマッパーを持っている。 Employee オブジェクトを読み込むとき、 Employee (従業 貝) のマッパーはローダーを設定する。

class EmployeeMapper...

void loadTimeRecords (Employee employee){ ListLoader loader = new ListLoader(); loader Sql = TimeRecordMapper.FIND_FOR_EMPLOYEE_SQL; loader.SqlParams. Add (employee. Key); loader Mapper = MapperRegistry.Mapper (typeof (TimeRecord)); loader. Attach ((DomainList) employee. Time Records);

class ListLoader...

public String Sql; public IList SqlParams = new ArrayList(); public Mapper Mapper;

Name

オブジェクトリレーショナル振る舞いパターン

Employee

emp: Employee

DataSource

Mapper Registry

Mapper

database

load

[isGhost] Load (emp)

図 11.5 ゴーストの読み込みシーケンス

-load various properties

Load (emp)

IDataSource

Mapper(emp.GetType)

SELECT...

Load (emp)

WHERE ID = emp.Key

domain data source IList DomainList 1 Mapper 1 "delegate" 1 RunLoader Loader (DomainList) "delegate> Load ListLoader Sql: String SqlParams: IList + Load (DomainList) + Attach (DomainList)

図 11.6 ･Ghost リストのクラス 現時点では、UMLモデル内で委譲を示す標準的な規格はない。以下に示すのは 私の現行の手法である。

委譲の割り当ての構文は複雑であるため、 私はローダーに Attach メソッドを使用するこ とにしている。

class ListLoader...

public void Attach (DomainList list) (

list. RunLoader = new DomainList.Loader (Load);

)

Employee が読み込まれると、 Time Record コレクションは、アクセスメソッドがロー ダーにトリガを発動するまで Ghost 状態となり、 ローダーがクエリーを発行しリストへ記 入する。

class ListLoader...

public void Load (DomainList list) {

list. IsLoaded = true;

IDbCommand comm= new OleDbCommand (Sql, DB.connection); foreach (Object param in SqlParams)

comm.Parameters.Add(new OleDbParameter (param.ToString(), param)); IDataReader reader = comm.ExecuteReader();

「ナル振る舞いパターン

while (reader.Read()) {

DomainObject obj = GhostForLine (reader);

list.Add(obj);

Mapper.LoadLine (reader, obj):

)

reader.Close();

private DomainObject GhostForLine (IDataReader reader) { return Mapper.AbstractFind ((System.Int32) reader [Mapper.KeyColumnName));

}

このように Ghost リストを使用することは、リブルローディングを軽減する上で重要で ある。 しかし、他のケースでもリプルローディングは生じるため完全にゼロにすることはで きない。 例では、より洗練されたマッピングを使用して1つのクエリーで Employee の データとともに Department のデータを読み込むようにしてある。 このように常にコレク ション内のすべての要素をまとめて読み込むことは、 混乱を回避する手助けとなるのである。

オブジェクトリレーショナル構造パタ

12.1 一意フィールド

データベースID フィールドをオブジェクトに保存することで、メモリ上のオブジェク トとデータベース行との一意性を維持する。

Person id:long

リレーショナルデータベースは、キー (特にプライマリキー) によって個々の行を識別す る。 しかし、 オブジェクトシステムでは、内部に正しいID が確保されるため (C++の場合 はローメモリの場所)、 メモリ上のオブジェクトはキーを必要としない。 この場合、 データ ベースからの読み込みにはまったく問題はないが、データを書き戻すためにはデータベース とメモリ上のオブジェクトシステムとを結び付ける必要がある

一意フィールドは大変シンプルであり、リレーショナルデータベーステーブルのプライマ リキーをオブジェクトのフィールドに格納するだけである。

121.1 動作方法

一意フィールドの基本概念は、 とてもシンプルだがさまざまな問題がある。

12.1.1.1 キーの選択

最初の問題は、データベース内でどの種類のキーを選ぶかである。もちろん、必ずこのよ うな選択が問題となるとは限らない。 すでに独自のキー構造を持つ既存のデータベースが対 象となる場合が多いからである。 データベースコミュニティには問題に関する議論や題材が 多くあり、 オブジェクトへのマッピングによっては、決定までに何らかの懸案事項が追加さ

れることもある。

最初の懸案事項は、意味のあるキーと意味のないキーのどちらを使うかである。 意味のあ るキーとは、個人を識別するための米国社会保障番号のようなもので 【訳注】、一方意味のない キーとは、データベースが作り出す無作為の数値であり、使用することを前提としていない。 意味のあるキーで注意すべきことは、理論上はキーとして問題がなくても、 実はそうでない 点である。 キーが完全に機能するためにはキーが一意でなければいけないので、正しく機能 するためには不変でなければならない。 しかし、割り当てられた番号は一意かつ不変である はずだが、人為的ミスによってどちらにも当てはまらなくなってしまうことが多い。 たとえ ば、私の妻の社会保障番号をタイプミスした場合、 生成されるレコードは一意でも不変でも なくなる (ミスを修正しなければの話だ)。 データベースは一意性の問題を検出するが、 私 のデータがシステムへ取り込まれた後であり、もちろん問題が発生するのはミスが検出され た後からである。結果として、意味のあるキーは信頼を失う結果となる。 小規模なシステム や安定したケースでは、 有効な場合もあるかもしれないが、普通は、 意味のないキーを使用 する方が賢明である。

次は、単純キーと複合キーのどちらを使うかである。 単純キーは1つのデータベース フィールドだけを使用し、 複合キーは複数のフィールドを使用する。 複合キーのメリットは、 あるテーブルが他のテーブルのコンテキスト内で有効である場合に使用しやすい点にある。 たとえば、 Order および Line Item (明細) などはわかりやすい例であり、 注文番号と連番 の組み合わせは明らかにそれに当たる。 複合キーはわかりやすいというメリットがある一方 で、単純キーの均一性にはさまざまなメリットがある。 あらゆる設定で単純キーを使用する 場合、 すべてのキー操作に同じコードを使用できるが、 複合キーでは、具象クラスで1つず つ特定の処理を行う必要がある (コード生成では問題とはならない)。 また、 複合キーは意 味を与えるため、一意性、 特に不変性に関するルールには注意しなくてはいけない。

キー型も選択しなければならない。 キーに対して頻繁に行われる操作は、 等価チェックで あるため、等価チェックの操作が速い型が求められる。 その他の重要な操作として次のキー の取得が挙げられるが、 大抵の場合は長整数型が最も無難な選択となる。 文字列型も有効だ が等価チェックは遅くなりインクリメントにやや負荷がかかり、そのため DBAのパフォー マンスも当然影響を受ける。

(キーに日付や時刻を使用する場合は注意が必要である。 これらは意味を持つだけでなく、 移植性や一貫性に影響を与えることがある。 この点で日付は特殊である。 理由は、日付デー タが格納される際の小数点以下の秒精度が異なるために非同期となりやすく、ID の問題に つながるからである)。

【注】 米国では、全国民に社会保障番号が付与され、あらゆる局面で国民番号として使用されている。

32

テーブルに対して一意キー、 またはデータベース全体での一意キーの使用も可能である。 テーブル一意キーはテーブルにおいて一意であり、 あらゆるケースでのキーとなる。一方、 データベース一意キーは、データベースすべてのテーブル全体の行において一意である。 普 通はテーブル一意キーで十分だが、データベースキーの方が簡単に使用できる場合が多く、 1つの一意マッピングを使用できるようになる。 現在の数値に変化がなければ、 新しいキー のための数値を使い果たすことは稀である。 これに不安がある場合、キーの領域をコンパク トにするシンプルなデータベーススクリプトで、 削除されたオブジェクトからキーを再生す ることもできる。 ただし、 スクリプトを実行するには、アプリケーションをオフラインにす る必要がある。 しかし、 64 ビットキーを使用する場合 (私はこれを推奨する)、 このような ことは必要ではない。

テーブル→意キーを使用する場合は、継承に注意しなければならない。 具象テーブル継承 またはクラステーブル継承を使用する場合、各テーブルではなく、 階層構造に一意キーを使 うと作業をはるかに簡素化することができる。 また、 継承グラフー意の場合も私はあえて テーブル一意を使用することにしている。

キーのサイズは、 特にインデックス付きの場合、パフォーマンスに影響を与える。 その度 合いは、データベースシステムやどのくらいの行数を管理しているかによって違うが、 おお まかに確認しておくことを勧める。

12.1.1.2 オブジェクトにおける一意フィールドの表記方法

最もシンプルな形式の一意フィールドは、データベース型のキーのフィールドである。 シ ンプルな整数型キーを使用している場合、 整数型フィールドが有効である。

複合キーはもう少し複雑で、最善の対処法はキークラスを作成することである。 汎用キー クラスは、キーの要素として一連のオブジェクトを格納できる。 キーオブジェクトにとって キーの振る舞いは等価的である。 また、データベースにマッピングする時にキーの一部分を 取得する場合にも有効である。

すべてのキーに対して同じ基本構造を使用する場合、 キー操作をレイヤスーパータイプで 行う。 多くの場合、 有効なデフォルトの振る舞いはレイヤスーパータイプに配置し、例外的 なケースに対する振る舞いは特定のサブタイプに配置するのである。

キーオブジェクトの汎用リスト上で1つのキークラスを持つと、 キーの各部分に対し明示 的なフィールドの各ドメインクラスのキークラスを持つこととなる。 私は通常、 明示的な方 を好むが、 今回のケースでは有効かどうかは判断できない。 この場合、 結局小さなクラスを 数多く持つことになる。 その場合の第1のメリットは、ユーザがキーの要素を間違った順序 で入力してもエラーを回避できることであるが、それが大きな問題とは思えない。

異なるデータベースインスタンス間でデータをインポートする場合、覚えておく必要があ るのは、異なるデータベース間でキーを分離するための手法を用意しない限り、キーの衝突

が発生することである。 この問題は、インポート時におけるキーの書き換えによって解決で きるが、処理はとても煩雑になりやすい。

12.1.1.3 新規キーの取得

オブジェクトを作成するには、キーが必要である。 単純なことのように思われるが、 新規 キーの取得でもさまざまな問題が生じることがある。 3つの基本的な方法は、 データベース による自動生成、 GUID の使用および独自生成である。

この中では、 自動生成手法が最も容易である。 データベースにデータを挿入するたびに、 データベースが一意のプライマリキーを生成するため何も行う必要がない。 簡単だが必ずし もすべてのデータベースに採用されている訳ではない。 このようにすると、 オブジェクトリ レーショナルマッピングに問題が発生するデータベースも少なくない。

最も一般的な自動生成方法は、 自動生成フィールドを宣言することである。 自動生成 フィールドは、行が挿入されるごとに新しい値が1ずつ増える。この手法の問題点は、どん な値がキーとして作成されるかを容易に決定できない点にある。 Order といくつかの Line Item を挿入したい場合、 Line Item の外部キーに値を入力するには、 新しい Order のキー が必要となる。また、トランザクション内のすべてを保存するには、 トランザクションのコ ミット前にキーが必要となる。 残念ながら、 データベースからはこのような情報が得られな いため、関連オブジェクトを挿入したいテーブルでは自動生成を使用できない。

自動生成の代替手法は、 Oracle がシーケンスに使用しているデータベースカウンタであ る。Oracle のシーケンスは、シーケンスを参照する select 文を送信して機能する。 送信後、 データベースは次のシーケンス値から成るSQL レコードセットを返す。 シーケンスを任意 の整数ずつ増分するように設定して複数のキーを一度に取得することができる。 シーケンス クエリーは、独立したトランザクションにおいて自動的に実行されるため、シーケンスへの アクセスは、同時に挿入を行う他のトランザクションをロックすることはない。 このような データベースカウンタは私たちのニーズに合うが、 非標準機能でありすべてのデータベース で使用できるとは限らない。

GUID (Globally Unique IDentifier) とは、1台のマシンで生成される数値で、 あらゆる マシン上において一意であることが保証される。 プラットフォームには、 GUID を生成する APIが用意されている。 アルゴリズムは、イーサネットカードアドレス、 ナノ秒単位の時間 帯 チップID番号他にも応用することができる。 重要なのは、 数値が完全一意であり、安 全なキーとなる点である。 GUID の唯一の短所は、得られるキー文字列が長くなることであ る。ウィンドウやSQL 式にキー入力が必要な時、 長いキーの場合、入力読み込みが大変で、 パフォーマンス上の問題 (特にインデックスが存在する場合) も発生する。

これ以外に考えられる方法としては、自分自身で作成することである。 小規模システムの 基本は、 SQL の max 関数を使用したテーブルスキャンによってテーブルでの最大のキーを

見つけ、キーを追加して使用することである。 データの挿入が頻繁でない場合には有効であ るが、残念ながら、 処理中はテーブル全体が読み込みロックされてしまう。そのため、 同一 テーブル上で更新と同時に挿入を行うときには、パフォーマンスは極めて低下するのである。 さらにトランザクションを互いに完全に分離しておく必要がある。 完全に分離していないと 複数のトランザクションが同じID値を取得してしまうからである。

また、追加するアプローチとしては、独立したキーテーブルの使用である。このテーブル は2つの列から構成されていて、一方の列は名前に、もう一方は次に使用可能な値に使わ れる。 データベースの一意キーを使用する場合、テーブルには1行だけ含まれる。一方、 テーブルの一意キーを使用する場合、 データベースのテーブルごとに1行が含まれる。 キーテーブルを使用する場合は、その1行を読み込み、 値を増やした上で行に書き戻すだ けでよい。 キーテーブルを更新する場合、 数字を追加することで一度に複数のキーを取得で きる。これによりデータベースの呼び出しにかかる負荷が削減され、キーテーブルでの競合 は回避される。

キーテーブルを使用する場合、 キーテーブルへのアクセスが、挿入先のテーブルを更新す るトランザクションから独立したトランザクションで行われるように設計することをお勧め する。 たとえば、 Order テーブルに Order を挿入するとしよう。 それには、(更新を行うた め) 書き込みロックによってキーテーブルのOrder 行をロックする必要がある。このロッ ク状態は私が関わるトランザクション全体に継続し、キーを求める他のユーザをすべてロッ クする。これは、テーブルの一意キーの場合、 Order テーブルへの挿入を行うすべてのユー ザに影響し、 データベースの一意キーの場合、 あらゆる場所で挿入を行うすべてのユーザに 影響する。

独立したトランザクションでキーテーブルへのアクセスを行うことで、必要な行がロック されトランザクションも短縮される。この方法の短所は、注文への挿入をロールバックする 場合、キーテーブルから取得したキーが、 どのユーザのものでもなくなってしまう点である。 ただし、幸い発生頻度が低いため大きな問題とはならない。 分離したトランザクションを使 用してメモリ上のオブジェクトを作成するとすぐにID を取得することができるようになる。 ビジネストランザクションをコミットするためにトランザクションをオープンする前に行う ことが多い。

キーテーブルを使用するかどうかは、データベースの一意キーとテーブルの一意キーの選 択にも影響する。 テーブルの一意キーを使用する場合、 データベースにテーブルを追加する たびに、キーテーブルに行を追加しなければならない。 これは手間のかかる作業だが、その 行での競合を避ける効果がある。 キーテーブルアクセスを異なるトランザクションに保持す る場合、 競合はそれほど大きな問題にはならない。 一度の呼び出しで複数のキーを取得する 場合にも特に問題にならない。 しかし、 キーテーブルの更新を分離したトランザクションと して設定できない場合、データベースの一意キーを使用する強い理由となる。

テスト目的のサービススタブの構築が容易となるため、 新しいキーを取得するためのコー ドを、独立したクラスに分離することをお勧めする。

121.2 使用するタイミング

メモリ上のオブジェクトとデータベース行の間にマッピングがある場合は一意フィールド を使用する。 ドメインモデルまたは行データゲートウェイを使用するときには、これが一般 的である。 しかしトランザクションスクリプト テーブルモジュール、テーブルデータゲー トウェイを使用する場合は、このようなマッピングは必要ない。

値のセマンティックスを持つ小さなオブジェクトの場合(独自のテーブルを持たない Money (貨幣) やDate Range (日付範囲) オブジェクトなど)、 組込バリューの使用を勧 める。 リレーショナルデータベース内でクエリーを発行する必要のないオブジェクトの複雑 なグラフの場合、シリアライズ LOBへの書き込みが容易であり高速なパフォーマンスを提 供できる。

一意フィールドの代替案としては、 一意マッピングによる対応が挙げられ、 メモリ上のオ ブジェクトに一意フィールドを格納したくないシステムで使用できる。 一意マッピングはオ ブジェクトのためのキーを与えるか、逆にキーのためのオブジェクトを与えるかのいずれか で参照を行う必要がある。 オブジェクトにキーを格納するほうが容易なのに、 私はこの方法 をあまり目にすることはない。

121.3|参考文献

[Marinescu)は、キー生成のためのいくつかの技法を解説している。

121.4 例: 整数型キー (C#)

一意フィールドの最もシンプルな形式は、データベースにおける整数型フィールドであり、 メモリ上のオブジェクトの整数型フィールドにマッピングされる。

class DomainObject...

public const long PLACEHOLDER_ID = -1; public long Id = PLACEHOLDER_ID: public Boolean isNew() { return Id == PLACEHOLDER_ID; }

メモリ上には作成されるがデータベースに保存されないオブジェクトは、キーの値を持つ ことはない。 .NET オブジェクトの場合、 .NET 値はnull (設定なし) でないプレースホ

2 36

ルダー値である。

キーは、 検索と挿入の2つの用途で重要である。 検索の場合、 .NET では where 旬の中 でキーを使用するクエリーを作成し、データセットに複数の行を読み込んでから、 検索操作 によって特定の行を選択する。

class CricketerMapper...

public Cricketer Find (long id) ( return (Cricketer) AbstractFind (id); )

class Mapper...

protected DomainObject AbstractFind (long id) { } DataRow row = FindRow (id); return (row == null) ? null Find(row); protected DataRow FindRow (long id) { } String filter = String.Format("id = {0}", id); DataRow [] results = table.select (filter); return (results.Length == 0) ? null : results [0]public DomainObject Find (DataRow row) ( } DomainObject result = CreateDomainObject(); Load(result, row); return result; abstract protected DomainObject CreateDomainObject

;

();

この振る舞いの大部分はレイヤスーパータイプによりできるが、ダウンキャストをカプセ ル化するためだけでも、具象クラスに find メソッドを定義しなければならない場合が多い。 当然だが、コンパイル時にタイピングをしないプログラミング言語においては、このような ことは必要でない。

シンプルな整数型一意フィールドによって、挿入の振る舞いもまたレイヤスーパータイプ で保持される。

class Mapper...

public virtual long Insert (DomainObject arg) DataRow row = table.NewRow(); arg.Id = GetNextID ();

(

row [id] = arg.Id;

Save (arg, row);

table.Rows.Add(row);

return arg.Id;

基本的には、挿入は新しい行を作成することと、その行のための次のキーを使用すること である。キーを取得した後は、 新しい行にメモリ上のオブジェクトのデータを保存する。

121.5 例: キーテーブルの使用 (Java)

(by Matt Foemmel, Martin Fowler) 使用するデータベースがデータベースカウンタをサポートし、 SQL に依存するのであれ ばカウンタを使用すべきである。 データベースへ依存しない場合であっても、考慮する価値 はある。 キー生成コードが問題なくカプセル化されている限り、 いつでも移植可能なアルゴ リズムへと変更できるからである。 キーがすでにある場合はカウンタを使用し、 ない場合は 独自に作成するストラテジー [Gang of Four] を採用することである。

ここでは、難しい方法でカウンタを使用すると仮定しよう。 最初に必要となるのは、デー タベースのキーテーブルである。

CREATE TABLE keys (name varchar primary key, nextID int) INSERT INTO keys VALUES ('orders', 1)

テーブルには、データベース内の各カウンタに対応する行が1行ずつ含まれている。ここ では、キーの初期値は1に設定している。 データベースのデータを事前ローディングする場

合は、カウンタを最適値に設定する必要がある。 データベースの一意キーが必要な場合、 1 行だけ必要であり、テーブルの一意キーが必要な場合、テーブルごとに1行が必要となる。

すべてのキー生成コードを独自のクラスにラップする。 これで1つ以上のアプリケーショ ンにおいて幅広く使用できるようになり、 独自のトランザクションにキー予約を登録するこ とが容易となる。

ここでは、一度にデータベースからいくつのキーを取り出すかという情報に加えて、 独自 のデータベースとの接続によってキー生成コードを構築している。

class KeyGenerator...

private Connection conn;

private String keyName;

238

}

private long nextId; private long maxId; private int incrementBy; public KeyGenerator (Connection conn, String keyName, int incrementBy) ( this.conn = conn; this.keyName = keyName; this.increment By = incrementBy; nextId = maxId = 0; try ( conn.setAutoCommit (false); } catch (SQLException exc) { throw new ApplicationException("Unable to turn off autocommit", exc);

選択および更新操作を間違いなく1つのトランザクションで行うため、 自動コミットが動

作しないようにする必要がある。 新しいキーを要求する場合、 生成コードはデータベースにアクセスするのではなく、 キャッシュされているキーがあるかどうかを確認する。

class KeyGenerator...

public synchronized Long nextKey() if (nextId == maxId) { } reserveIds(); return new Long (nextId++); }

{

キャッシュされているキーが得られない場合は、 データベースにアクセスする。

class KeyGenerator...

private void reservelds() ( PreparedStatement stmt = null; ResultSet rs = null; long newNextId; try ( stmt = conn.prepareStatement ("SELECT nextID FROM keys WHERE name = ? FOR UPDATE");

stmt.setString (1, keyName); rs = stmt.executeQuery();

rs.next();

newNextId=rs.getLong (1);

}

catch (SQLException exc) (

throw new ApplicationException("Unable to generate ids", exc);

}

finally (

DB.cleanUp (stmt, rs);

}

long newMaxId = newNextId + incrementBy;

stmt = null;

try{

stmt = conn.prepareStatement ( "UPDATE keys SET nextID = ?

WHERE name = ?");

stmt.setLong (1, newMaxId);

stmt.setString (2, keyName);

stmt.executeUpdate();

conn.commit();

nextId = newNextId;

maxId = newMaxId;

catch (SQLException exc) {

} throw new ApplicationException("Unable to generate ids", exc);

finally {

DB.cleanUp (stmt);

}

この例では、 SELECT... FOR UPDATE を使って、 データベースに対してキーテーブルの 書き込みロックを保持するように指示している。これはOracle 独自のステートメントであ り、他のデータベースを使用している場合には、効果は変わる。 選択時に書き込みロックが できないと、 割り込みがあった場合にトランザクションが失敗するという危険性がある。 こ の場合は、 新しいキーセットを取得するまで、 安全に reservelds を実行する。

12.1.6 例: 複合キーの使用 (Java)

シンプルな整数型キーの使用は、 簡単で優れた解決法ではあるが、他のタイプまたは複合 キーが必要となる場合も多い。

240

}

12.1.6.1キークラス

他の方法が必要となった場合には、すぐにキークラスの作成を検討することは有効である。 キークラスは複数のキーの要素を格納するため、2つのキーが等しいかどうかを判断できな ければならない。

class Key...

private Object[] fields; public boolean equals (Object obj) ( if (!(obj instanceof Key)) return false; Key otherKey = (Key) obj; if (this.fields.length != otherKey.fields.length) return false; for (int i = 0; i < fields.length; i++) if (!this.fields [i].equals (otherKey.fields[i])) return false; return true; }

最も基本的なキーの作成方法は、配列パラメータによる方法である。

class Key... public Key (Object() fields) { } checkKeyNotNull (fields); this.fields = fields; private void checkKeyNotNull (Object [] fields) { if (fields == null) throw new IllegalArgumentException("Cannot have a null key"); for (int i = 0; i < fields.length; i++) if (fields[i] == null) throw new IllegalArgumentException ("Cannot have a null element of key");

一般的に、 ある要素によってキーを作成する場合、 使いやすいコンストラクタを追加する ことができる。 該当するキーは、アプリケーションが持つキーの種類に依存する。

class Key...

public Key (long arg) { this.fields = new Object [1]; this.fields[0] = new Long (arg); }

public Key (Object field) ( } if (field == null) throw new IllegalArgumentException ("Cannot have a null key"); this.fields new Object [1]; this.fields[0] = field; public Key (Object arg1, Object arg2) { this.fields new Object [2]; this.fields[0] = arg1; this.fields [1] = arg2; checkKeyNotNull(fields);

使いやすいメソッドは、積極的に追加すべきである。 結局使いやすいキーは、すべての ユーザにとって最も重要なのである。

同様に、キーの一部を取得するアクセッサー機能を追加することができる。 アプリケー ションでは、マッピングの際にこれを行う必要がある。

class Key...

public Object value (int i) {

return fields[i];

public Object value() {

checkSingleKey();

}

return fields[0];

}

private void checkSingleKey() {

if (fields.length > 1)

throw new IllegalStateException ("Cannot take value on

composite key");

}

public long longValue() {

checkSingleKey();

return longValue(0);

}

public long longValue (int i) ( if (!(fields[i] instanceof Long)) throw new IllegalStateException("Cannot take longValue on non long key"); return ((Long) fields ([i]). longValue();

オブジェクトリレーショナル構造パターン

242

この例では、 Orders テーブルおよび Line Items テーブルに対してマッピングしている。 Orders テーブルは、シンプルな整数型プライマリキーを持ち、 Line Items テーブルのプラ イマリキーは、 Orders テーブルのプライマリキーと連続した番号の組み合わせとなる。

CREATE TABLE orders (ID int primary key, customer varchar) CREATE TABLE line_items (orderID int, seq int, amount int, product varchar, primary key (orderID, seq))

ドメインオブジェクトのレイヤスーパータイプは、キーフィールドを持つ必要がある。

class DomainObjectWithKey...

private Key key; protected DomainObjectWithKey (Key ID) ) this.key = ID; protected DomainObjectWithKey() { } public Key getKey ( ) } return key; public void setKey (Key key) { this.key = key: }

{

12.1.6.2 読み込み

他の例と同様、私は、 振る舞いを(データベースの正しい行へアクセスする) find メソッ ドと、その行のデータをドメインオブジェクトに読み込む) load メソッドに分割している。 いずれの役割も、キーオブジェクトによって影響を受ける。

ここに示す例と、 (シンプルな整数型キーを使用した) その他の例との最大の違いは、よ り複雑なキーを持つクラスによってオーバーライドされる振る舞いの特定の部分を分析でき る点である。 例の場合、 ほとんどのテーブルは、シンプルな整数型キーを使用することを前 提としている。 しかし、一部ではその他のキーも使用されているため、デフォルトのケース をシンプルな整数型として、 その振る舞いをマッパーレイヤスーパータイプに組み込んでい る。 Order クラスは、このようなシンプルなケースの1つである。 find メソッドの振る舞 いのコードは以下のとおりになる。

class OrderMapper...

public Order find (Key key) ( } return (Order) abstractFind (key); public Order find (Long id) { } return find (new Key(id)); protected String findStatementString() { } return "SELECT id, customer FROM orders WHERE id = ?";

class AbstractMapper...

abstract protected String findStatementString();

protected Map loadedMap = new HashMap();

public DomainObjectWithKey abstract Find (Key key) ( DomainObjectWithKey result = (DomainObjectWithKey) loadedMap.get(if (result = null) return result; ResultSet rs = null; PreparedStatement findStatement = try { findStatement = DB. prepare (findStatementString()); loadFindStatement (key, findStatement); rs findStatement.executeQuery(); rs.next(); if (rs.isAfterLast ()) return null; result load (rs); return result; } catch (SQLException e) { throw new ApplicationException(e); } finally { DB.cleanUp (findStatement, rs); } }

key);

// hook method for keys that aren't simple integral protected void loadFindStatement (Key key, PreparedStatement finder) throws SQLException {

null;

finder.setLong (1, key.longValue());

}

ここでは find 文の構造部分を抽出しているが、これはあらかじめ用意されたステートメ ントに異なるパラメータを渡す必要があるためである。 Line Items は、 複合キーであるた め、このメソッドをオーバーライドする。

第1章 オブジェクトリレーショナル構造パターン

class LineItemMapper...

public LineItem find (long orderID, long seg) ( Key key = new Key (new Long (orderID), new Long (seq)); return (LineItem) abstractFind (key);

}

public LineItem find (Key key){ return (LineItem) abstractFind(key);

protected String findStatementString() {

return

"SELECT orderID, seq, amount, product + "FROM line_items " +

"WHERE (orderID = ?) AND (seq = ?)";

// hook methods overridden for the composite key protected void loadFindStatement (Key key, PreparedStatement finder) throws SQLException {

finder.setLong (1, orderID (key));

finder.setLong (2, sequence Number (key));

//helpers to extract appropriate values from line item's key private static long orderID (Key key) {

return key. long Value (0);

private static long sequenceNumber (Key key) {

return key.longValue(1);

このサブクラスは find メソッド用のインタフェースを定義し、 find 文に SQL 文字列を提 供するだけでなく、 2つのパラメータをSQL 文に送るため、 フックメソッドをオーバーラ イドする必要がある。 ここでも私は、 キー情報の一部を抽出するために、2つのヘルパーメ ソッドを記述している。これはキーからの数値インデックスを持った明示的なアクセッサー を追加するよりも明確なコードの記述に役立つ。 ただし、 インデックスにはリスクがある。

load メソッドの振る舞いも同様の構造をしている。 シンプルな整数型キーに対しては、 レイヤスーパータイプのデフォルトの振る舞いを用意し、複雑なケースではオーバーライド を実行する。 このケースでは、 Order のload メソッドの振る舞いは以下のとおりである。

protected DomainObjectWithKey load (ResultSet rs) throws SQLException {

}

}

class AbstractMapper...

}

}

)

Key key createKey(rs);

if (loadedMap.containsKey (key)) return

(DomainObjectWithKey) loadedMap.get(key);

DomainObjectWithKey result = doLoad (key, rs);

loadedMap.put (key, result);

return result;

第1章 オブジェクトリレーショナル構造パターン

abstract protected DomainObjectWithKey doLoad (Key id,

ResultSet rs) throws SQLException;

// hook method for keys that aren't simple integral protected Key createKey (ResultSet rs) throws SQLException ( return new Key (rs.getLong (1));

class OrderMapper...

protected DomainObjectWithKey doLoad (Key key, ResultSet rs) throws SQLException { String customer = rs.getString("customer"); Order result = new Order (key, customer); MapperRegistry.lineItem().loadAllLineItems For (result); return result; }

LineItem は、2つのフィールドに基づいたキーを作成するため、フックメソッドをオー バーライドする必要がある。

class LineItemMapper...

protected DomainObjectWithKey doLoad (Key key, ResultSet rs) throws SQLException { } Order theOrder MapperRegistry.order().find (order ID (key)); return doLoad (key, rs, theOrder); protected DomainObjectWithKey doLoad (Key key, ResultSet rs, Order order) throws SQLException ( LineItem result; int amount = rs.getInt("amount"); String product = rs.getString("product"); result new LineItem (key, amount, product); order.addLineItem (result); //links to the order return result;

}

}

246

}

//overrides the default case protected Key createKey (ResultSet rs) throws SQLException { Key key = new Key (new Long (rs.getLong ("order ID")), new Long (rs.getLong ("seq"))); return key; }

また、 LineItem は、 Order に対して LineItem を読み込むときに使用される独立した load メソッドを持っている。

class LineItemMapper...

public void loadAllLineItems For (Order arg) ( PreparedStatement stmt = null; ResultSet rs = null; try ( stmt = DB. prepare (findForOrderString); stmt.setLong (1, arg.getKey().longValue()); rs = stmt.executeQuery(); while (rs.next()) load (rs, arg); } catch (SQLException e) { throw new ApplicationException(e); } finally { DB.cleanUp (stmt, rs); }

private final static String findForOrderString =

"SELECT orderID, seq, amount, product " +

"FROM line items" +

"WHERE orderID = ?";

protected DomainObjectWithKey load (ResultSet rs, Order order) throws SQLException (

Key key createKey(rs);

if (loadedMap.containsKey (key)) return

}

(DomainObjectWithKey) loadedMap.get(key);

DomainObjectWithKey result = doLoad (key, rs, order); loadedMap.put (key, result);

return result;

Order オブジェクトは、作成後まで Order の一意マッピングに挿入されないので、あら かじめ空のオブジェクトを作成し一意フィールドに挿入しておく。

12.1.6.3挿入

読み込みの場合と同様、挿入もシンプルな整数型キーに対してのデフォルトのアクション と、より複雑なキーにアクションをオーバーライドするフックメソッドを持つ。 マッパー スーパータイプでは、 挿入操作を行うテンプレートメソッドとインタフェースの機能を提供 する。

class AbstractMapper...

public Key insert (DomainObjectWithKey subject) { try{ return performInsert(subject, findNext DatabaseKeyObject() ); } catch (SQLException e) { throw new ApplicationException(e); }

} protected Key performInsert (DomainObjectWithKey subject, Key key) throws SQLException { ) subject.setKey (key); PreparedStatement stmt = DB.prepare (insertStatementString()); insertKey (subject, stmt); insertData (subject, stmt); stmt.execute(); loadedMap.put(subject.getKey(), subject); return subject.getKey(); abstract protected String insertStatementString();

class OrderMapper...

protected String insertStatementString() { return "INSERT INTO orders VALUES (?,?)*; }

このオブジェクトからのデータは、オブジェクトの基本データとキーのデータとを分離す る2つのメソッドを介し insert 文へ送られる。 私がこの方法を使用する理由は、 Order な どデフォルトのシンプルな整数型キーを使うクラスに対して機能するキーに、デフォルトの 実装を提供できるからである。

第1章 オブジェクトリレー

アル構造パターン

class AbstractMapper...

protected void insert Key (DomainObjectWithKey subject, ( PreparedStatement stmt) throws SQLException stmt.setLong (1, subject.getKey().longValue());

}

insert 文の残りデータは特定のサブクラスにあるため、 振る舞いはスーパークラスにおい ては抽象的である。

class AbstractMapper...

abstract protected void insert Data (DomainObjectWithKey

subject, PreparedStatement stmt) throws SQLException;

class OrderMapper...

protected void insert Data (DomainObjectWithKey abstract Subject, PreparedStatement stmt) ( try { Order subject = (Order) abstract Subject; stmt.setString (2, subject.getCustomer()); } catch (SQLException e) { throw new ApplicationException(e); }

LineItem は、メソッドの両方をオーバーライドしてキーに2つの値を取り出す。

class LineItemMapper... protected String insert StatementString() { } return "INSERT INTO line items VALUES (?, ?, ?, ?)"; protected void insertKey (DomainObjectWithKey subject, PreparedStatement stmt) throws SQLException ( stmt.setLong (1, order ID (subject.getKey())); stmt.setLong (2, sequenceNumber (subject.getKey()));

また、残りのデータに対しては、 insert 文独自の実装を提供する。

class LineItemMapper...

protected void insert Data (DomainObjectWithKey subject, PreparedStatement stmt) throws SQLException } LineItem item= (LineItem) subject; stmt.setInt(3, item.getAmount () ); stmt.setString(4, item.getProduct ()); }

このように、 insert 文にデータ読み込みを配置することが有効なのは、ほとんどのクラス がキーとして同一フィールドを使用している場合だけである。 キー処理により多くのバリ エーションがある場合、 情報の挿入を1つのコマンドとした方が容易な場合もある。

また、次のデータベースキーを作成して、デフォルトのケースとオーバーライドされる ケースとに分離することもできる。 デフォルトのケースには、すでに解説したキーテーブル スキームを使用できる。 しかし、 Line Items に対して使用する場合には問題が生じる。 そ れは Line Items のキーは、 複合キーの一部として Order のキーを使用するが、 LineItem クラスから Order クラスへの参照がないため、 正しい Order の提供なしで、 LineItem 自 身をデータベースに挿入できないためである。 そのため、サポートされていない操作の例外 をスーパークラスメソッドに実装するという手法を必ず採用しなければならない。

class LineItemMapper...

public Key insert (DomainObjectWithKey subject) { throw new UnsupportedOperationException "Must supply an order when inserting a } public Key insert (LineItem item, Order order) { try{ Key key = new Key (order.getKey().value(), getNext SequenceNumber (order)); return performInsert (item, key); } catch (SQLException e) { ) throw new ApplicationException(e);

line item");

ノル構造パターン

もちろん、 LineItem から Order へのバックリンクを用意し、効率的に双方向を関連付け て事態は回避できる。 しかし、私がこの方法を選択しないのは、リンクがない場合にどう行 うべきかを説明するためである。

Order を提供することで、キーのOrder の取得が容易になる。 次は、 LineItem に対す るシーケンス番号の作成である。 シーケンス番号を検索するには、 Order に対して次にどの シーケンス番号が使用可能であるかを確認する必要がある。 そのため、 SQL の max クエ リーを発行するか、あるいはメモリ上のOrder に含まれる LineItem を参照する必要があ る。この例では、後者の方法を取り上げる。

class LineItemMapper...

private Long getNext Sequence Number (Order order) ( loadAllLineItems For (order); Iterator it = order.getItems().iterator(); LineItem candidate = (LineItem) it.next(); while (it.hasNext()) { } LineItem thisItem = (LineItem) it.next(); if(thisItem.getKey() == null) continue; if (sequenceNumber (this Item)> sequenceNumber (candidate)) candidate = thisItem;

return new Long (sequenceNumber (candidate) + 1);

private static long sequenceNumber (LineItem li) { return sequenceNumber (1i.getKey());

//comparator doesn't work well here due to unsaved null keys protected String keyTableRow() {

}

throw new Unsupported OperationException();

}

Collections.max メソッドを使用すると、 アルゴリズムはさらに有効となるはずだが、 少なくとも1つの null (設定なし) キーを持つだけなので、このメソッドは失敗に終わるだ ろう。

12.1.6.4 更新と削除

今まで解説したとおり、 更新および削除は安全性には影響を与えない。 繰り返しになるが、 予測される一般的ケースに対しては抽象メソッドを使用し、 特定のケースにおいてはオー バーライドメソッドを使用している。

}

更新の動作は以下のとおりである。

class AbstractMapper...

public void update (DomainObjectWithKey subject) {

PreparedStatement stmt = null;

try {

stmt =DB.prepare (updateStatementString());

loadUpdateStatement (subject, stmt);

第1章 オブジェクトリレーショナル構造パターン

stmt.execute();

} catch (SQLException e) {

throw new ApplicationException(e);

) finally (

DB.cleanUp (stmt);

)

}

abstract protected String updateStatementString(); abstract protected void loadUpdateStatement (DomainObjectWithKey subject, PreparedStatement stmt) throws SQLException;

class OrderMapper...

protected void loadUpdateStatement (DomainObjectWithKey subject, PreparedStatement stmt) throws SQLException } Order order (Order) subject; stmt.setString (1, order.getCustomer()); stmt.setLong (2, order.getKey().longValue()); protected String updateStatementString() { } return "UPDATE orders SET customer = ? WHERE id = ?";

class LineItemMapper...

protected String updateStatementString() { ) return "UPDATE line items "SET amount = ?, product = ?" "WHERE orderId = ? AND seq = ?"; protected void loadUpdateStatement (DomainObjectWithKey subject, PreparedStatement stmt) throws SQLException stmt.setLong (3, order ID (subject.getKey()));

25 2

stmt.setLong (4, sequenceNumber (subject.getKey())); LineItem li = (LineItem) subject; stmt.setInt(1, li.getAmount ()); stmt.setString (2, li.get Product ());

削除の動作は以下のとおりである。

class AbstractMapper...

public void delete (DomainObjectWithKey subject) (

PreparedStatement stmt = null;

try (

stmt =DB.prepare (deleteStatement String()); loadDeleteStatement (subject, stmt);

stmt.execute();

} catch (SQLException e) {

throw new ApplicationException(e);

} finally {

DB.cleanUp (stmt);

}

abstract protected String deleteStatementString(); protected void loadDeleteStatement (DomainObjectWithKey subject. PreparedStatement stmt) throws SQLException

[

stmt.setLong (1, subject.getKey().longValue());

class OrderMapper...

protected String deleteStatementString() (

return "DELETE FROM orders WHERE id = ?";

}

class LineItemMapper...

protected String deleteStatementString() { } return "DELETE FROM line items WHERE orderid = ? AND seq = protected void loadDeleteStatement (DomainObjectWithKey subject, PreparedStatement stmt) throws SQLException ( stmt.setLong (1, order ID(subject.getKey())); stmt.setLong (2, sequenceNumber (subject.getKey()));

?";

}

}

12.2 外部キーマッピング

オブジェクト間の関係を、テーブル間の外部キー参照にマッピングする。

Album Artist title: String * name: String ID: int -table- Albums title: varchar artistID: int -table" Artists ID: int name: varchar

オブジェクトは、 オブジェクト参照によって直接相互に参照し合う。 シンプルなオブジェ クト指向システムも、 さまざまな方法で相互に関連付けられた一連のオブジェクトを含んで いる。これらのオブジェクトをデータベースに保存するには、 参照を保存することが不可欠 である。しかし、参照に含まれるデータは、実行中のプログラムの特定のインスタンスに固 有であるため、そのままのデータ値を保存することはできない。 その上、 オブジェクトは他 のオブジェクトへの参照のコレクションを容易に保持できるのである。 このような構造は、 リレーショナルデータベースの標準形式に反している。

外部キーマッピングは、オブジェクト参照をデータベースの外部キーにマッピングして いる。

12.21 動作方法

上述の問題に明確な鍵となるのが、一意フィールドである。 それぞれのオブジェクトには、 データベーステーブルからのデータベースキーが含まれる。 2つのオブジェクトの関連性に よってリンクしている場合、データベースの外部キーによって置き換えることができる。つ まり、 12.1に示すように、 データベースに Album を保存する場合、 Album がリンクさ れる Artist の ID は、 Album レコードに保存される。

254

ID = 1234 Album title = "Kind of Blue" Artist |ID=5678 name = "Miles Davis" "table" row from Albums ID=1234 artistID=5678 title = "Kind of Blue* -table" crow from Artists ID=5678 name = "Miles Davis"

図 12.1 外部キーへのコレクションのマッピング

これはシンプルなケースである。 オブジェクトのコレクションを持つと、さらに複雑な ケースが発生する。 データベースにコレクションは保存できないため、 参照項目を変える必 要がある。 そのため、 図12.2および12.3に示すように、 Album の Track というコレク ションで Album の外部キーを Track レコードに配置する。 複雑さが発生するのは、 更新 を行う時点である。 更新とは、 Album 内のコレクションに対して Track の追加や削除がで きるのである。 その際、 どのような方法で、 データベースに含むべき変更部分を指示できる だろうか。 基本的には、 (1) 削除と挿入、 (2) バックポインタの追加、 (3) コレクションの 差分表示という3つのオプションから選択できる。

:Album ID = 1234 title = "Kind of Blue" "table" row from Albums ID = 1234 title = "Kind of Blue" :Track ID = 3333 title="So What" -table- crow from Tracks ID=3333 albumID=1234 title="So What"

12.2 外部キーへのコレクションのマッピング

削除と挿入の場合、 Album にリンクされているデータベース内のすべての Track を削除 した後、 Album上に現在あるすべてのTrack を挿入する。一見すると、この方法はとても

大胆で危険なもののように思えるかもしれない。 特に Track をまったく変更していない場合 などはそう思うだろう。 しかし、 ロジックは実装が容易であり、他の方法と比較してもとて も有効に機能する。 短所は、この方法を使用できるのはTrack が依存マッピングである場合 だけ、つまり Track が Album に所有されていて外部への参照はできないということである。

バックポインタの追加は、 Track から Album へのリンクを配置することであり、 効果的 に関係に双方向性を持たせられる。 これはオブジェクトモデルを変更するが、もう一方で、 単一値フィールドに対してもシンプルに更新を行うことができる。

いずれのオプションも効果的と思われない場合は差分表示を実行するが、ここでは次の2 つの方法を検討する。 データベースの現在の状況による差分表示と、 最初に読み取った内容 による差分表示である。 データベースの差分表示では、データベースからのコレクションの 再読み込み、およびその後読み込んだコレクションと Album 中のコレクションとの比較を 行う。 データベース上のAlbum にないすべての要素は完全に削除される。 一方、 Album 内のディスク上にないすべての要素は、確実に追加する項目である。 その後アプリケーショ ンのロジックに移りそれぞれに項目の処理を決定する。

最初に読み込んだ内容を差分表示するためには、 読み込んだ内容を保持するが、 この方法 には、新たなデータベースの読み込みを回避できるというメリットがある。 また、軽オフラ インロックを使用しているデータベースには、差分表示を行わなければならない場合がある。

通常、コレクションに追加されるすべての要素は、新しいオブジェクトであるかどうか最

初の時点でチェックする必要がある。 チェックを行うには、それがキーを持っているかを確 認し、持っていない場合はデータベースに追加する。 このステップはユニットオブワークに よって大幅に簡素化できるのである。 理由は、 この方法では新しいオブジェクトが、 自動的 に最初に挿入されるからである。

Album 1 Track title: String * title: String ID: int -table- Albums title: varchar ID: int -table" Tracks albumID: int title: varchar

図 12.3 複数値参照のクラスおよびテーブル

いずれの場合も、次にデータベース中のリンクされた行を検出し、 外部キーが現行の Album を指し示すように更新を行う。

56

削除する場合、 Track が他の Album に移動されたのか、 Track の Album があるか、 ま たTrackが一緒に削除されたのかどうかを把握しておく必要がある。 他の Album に移動 されている場合、移動先の Album の更新と同時に更新されなければならない。 Album が ない場合、 外部キーを null (設定なし) にする。 また Track が削除されている場合、何ら かの削除を実行する時点で外部キーも削除すべきである。 バックリンクが強制的に行われる 場合、削除の処理は極めて容易であり、ここに示すように、 すべての Track が Album 上 にあるようになる。これにより、 コレクションから何が削除された項目かを考える必要がな くなる。 つまり、 追加先の Album を処理する時点で更新されるからである。

リンクが不変で Album の Track が変更できない場合、追加は必ず挿入を消去は必ず 削除を意味する。 すべてがさらにシンプルになる。

ここで注意すべきは、リンクの循環である。 たとえば、 Order を読み込む必要があるとす る。 Order は、 (読み込みの対象である) Customer (顧客) へのリンクを持っている。 Customer は、1セットの (読み込みの対象である) Payment (支払い) データを持ち、各 Payment データは、 支払い対象となる Order データを持っている。 この場合、読み込もう としているオリジナルの Order データが含まれていることもある。 したがって、 再び Order を読み込むことになる (こうして段落の先頭へと再び戻ることになる)。

このような循環を避けるために、オブジェクトの作成方法を要約する2つのオプションを 使用する。 勧めるのは、完全に形成されたオブジェクトを提供するデータを作成メソッドに 含める方法である。 この場合、 循環を断ち切るポイントにレイジーロードを配置する。 ポイ ントを間違った場合、 スタックオーバーフローが発生するが、十分なテストが行われている 場合にはこの負荷を管理することもできる。

もう1つの選択肢は、空のオブジェクトを作成し即座に一意マッピングに挿入する方法で ある。この場合、 再び循環元に戻った時点で、 オブジェクトはすでに読み込まれているため、 その循環は終了する。 作成するオブジェクトはこの時点では完全に形成されてはいないが、 ロードの手順が完了するまでには完成されるのである。 正しい読み込みを行うためだけにレ イジーロードを使用するかどうかという決定を行う必要がなくなる。

12.2.2 使用するタイミング

外部キーマッピングは、クラス間のすべての関係に対して使用できる。 使用できないケー スで最も一般的なのは、 多対多の関係である。 外部キーは単一値であり、 標準形式では単一 フィールドに複数の外部キーを格納できないのである。 その代わり関連テーブルマッピング を使用する。

バックポインタのないコレクションフィールドを持つ場合、多くの側面から依存マッピン グを使用するかどうかを考慮すべきである。 この場合、コレクションの処理を簡略化できる。

関連オブジェクトがバリューオブジェクトの場合は、 組込みバリューを使用する。

1223 例:单一值参照(Java)

これは最もシンプルなケースであり、 Album は Artist に対する単一参照を持つ。

class Artist...

private String name; public Artist (Long ID, String name) } super (ID); this.name name; public String getName() { return name; public void setName (String name) { this.name name; }

{

class Album...

private String title; private Artist artist; public Album (Long ID, String title, } super (ID); this.title = title; this. artist = artist; public String getTitle() { } return title; public void setTitle(String title) { this.title title; public Artist getArtist () { } return artist; public void setArtist (Artist artist) ( this. artist artist;

Artist artist) {

図 12.4 に、 Album の読み込み方法を示す。 Album Mapper は、 特定の Album を読み込

258

オブジェクトリレーショナル構造パターン

む指示が出されると、 データベースにクエリーを発行し、 結果群を引き出す。 次に結果群の 各外部キーフィールドに対するクエリーを実行し、 オブジェクトを検索する。 これで検索さ れた適切なオブジェクトを持つ Album を完成できるようになる。 Artist オブジェクトがす でにメモリ上にある場合、キャッシュからフェッチされる。 メモリ上にない場合は、同様の 方法でデータベースから読み込まれる。

Album Mapper database find (1) select from albums where ID=1 album result set result set get artist id new (anArtist) '3' find('3') artist artist mapper Album

図 12.4 単一値フィールドの読み込みシーケンス

この検索操作は、 抽象的な振る舞いを使用して一意マッピングを操作する。

class AlbumMapper...

public Album find (Long id) { ) return (Album) abstractFind(id); protected String findStatement () { } return "SELECT ID, title, artistID FROM albums WHERE ID = ?":

class AbstractMapper...

Map.get(id);

abstract protected String findStatement(); protected DomainObject abstract Find (Long id) } DomainObject result = (DomainObject) loaded if (result = null) return result; PreparedStatement stmt = null; ResultSet rs = null; try { stmt DB.prepare (findStatement()); stmt.setLong (1, id.longValue()); rs stmt.executeQuery(); rs.next(); result load (rs); return result; } catch (SQLException e) { throw new ApplicationException(e); } finally (cleanUp (stmt, rs); } private Map loaded Map = new HashMap();

この検索操作は読み込み操作を呼び出し、 Album にデータを読み込む。

class AbstractMapper...

protected DomainObject load (ResultSet rs) throws SQLException { } Long id = new Long (rs.getLong(1)); if (loadedMap.containsKey(id)) return (DomainObject) loadedMap.get(id); DomainObject result = doLoad(id, rs); doRegister (id, result); return result; protected void doRegister (Long id, DomainObject result) { Assert.isFalse (loadedMap.containsKey(id)); } loadedMap.put (id, result);

abstract protected DomainObject doLoad (Long id, ResultSet rs) throws SQLException;

class AlbumMapper...

{

protected DomainObject doLoad (Long id, ResultSet rs) throws SQLException { String title = rs.getString (2); long artistID = rs.getLong (3);

オブジェクトリレーショナル構造バ

Artist artist = MapperRegistry.artist().find(artistID); Album result = new Album (id, title, artist); return result;

Album を更新する場合、 外部キーの値はリンクされている Artist オブジェクトから抽出 される。

class AbstractMapper...

abstract public void update (DomainObject arg);

class AlbumMapper...

public void update (DomainObject arg){ PreparedStatement statement = null;

try (

statement = DB.prepare (

"UPDATE albums SET title = ?, artistID = ? WHERE id = ?"); statement.setLong(3, arg.getID ().longValue());

Album album = (Album) arg;

statement.setString(1, album.getTitle());

statement.setLong (2, album.getArtist().getID().longValue()); statement.execute();

} catch (SQLException e) {

throw new ApplicationException(e);

} finally (

cleanUp (statement);

)

12.2.4 例: 複数テーブルの検索 (Java)

1つのテーブルに対して1つのクエリーを発行することは概念的にわかりやすいが、 SQL はリモートコールから構成されていて、その上リモートコールの速度が遅いため効率的では ない。 したがって、1つのクエリーによって複数のテーブルからデータを収集する方法は、 検討する価値が十分ある。 上記の例を修正することで、1つのクエリーを発行し、1つの SQL 呼び出しによって Album 情報と Artist 情報の両方を取得することができるようにな る。 最初の変更箇所は、 SQL の find 文の部分である。

class AlbumMapper...

public Album find (Long id) {

return (Album) abstractFind(id);

}

protected String findStatement () { return "SELECT a. ID, a.title, a.artistID, r.name "FROM albums a, artists r " + "WHERE ID = ? AND a.artistID = r.ID"; " +

次に、 Album 情報と Artist 情報の両方を読み込む別のloadメソッドを使用する。

class AlbumMapper...

protected DomainObject doLoad (Long id, ResultSet rs) throws SQLException {

String title = rs.getString (2); long artistID = rs.getLong (3); Artist Mapper artistMapper = MapperRegistry.artist(); Artist artist; if (artistMapper.isLoaded (artistID)) artist else artistMapper. find (artistID); artist loadArtist (artistID, rs); Album result = new Album (id, title, artist); return result;

}

private Artist loadArtist (long id, ResultSet rs) throws SQLException {

String name = rs.getString (4); Artist result = new Artist (new Long (id), name); MapperRegistry.artist().register (result.getID(), result); return result;

SQL の結果を Artist オブジェクトにマッピングするメソッドを配置することができる。 一方で、 Artist を読み込むクラスであるため、 Artist のマッパーに配置する方法も有効な 手段である。 さらにload メソッドはSQL と緊密に結合しているため SQL クエリーととも に配置される。 ここでは後者を採用した。

)

オブジェクトリレ

62

12.2.5 例: 参照のコレクション(C#)

参照のコレクションのケースは、コレクションを構成するフィールドがある場合に発生す る。 Team と Player を例に挙げて、 Player を依存マッピングすることはできない場合を仮 定する (図 12.5)。

Team 1 Player

12.5 複数の Player がいる Tearn

class Team...

public String Name; public IList Players ( } get (return ArrayList. ReadOnly (players Data); } set (playersData = new ArrayList (value); } public void AddPlayer (Player arg) { } players Data. Add (arg); private IList playersData = new ArrayList();

データベースにおいて、 上記の例は Team に対する外部キーを持つ Player レコードに よって処理される (図12.6)。

-table" Team ID: long

-table-

Player

ID: long

teamID: long

12.6 複数の Player がいる Team のデータベース構造

class TeamMapper... public Team Find (long id) { return (Team) AbstractFind(id); }

class AbstractMapper...

protected DomainObject AbstractFind (long id) { } Assert. True (id != DomainObject. PLACEHOLDER_ID); DataRow row = FindRow(id); return (row == null) ? null: Load (row); protected DataRow FindRow (long id) { } String filter = String.Format("id = (0)", id); DataRow] results = table. Select (filter); return (results. Length == 0) ? null results[0]; protected DataTable table ( } get (return dsh. Data. Tables [TableName]; } public DataSetHolder dsh; abstract protected String TableName (get;)

class TeamMapper...

protected override String TableName { get (return "Teams";} }

データセットホルダーは使用中のデータセットを保持するクラスであり、 データベースに 更新するアダプターも持っている。

class DataSetHolder... public DataSet Data = new DataSet(); private Hashtable DataAdapters = new Hashtable();

この例では、データセットホルダーがいくつかのクエリーによって配置されていると仮定 する。 find メソッドは、 load メソッドを呼び出し新しいオブジェクトにデータを読み込む。

class AbstractMapper... protected DomainObject Load (DataRow row) { long id (int) row ["id"]; if (identityMap[id] != null) return (DomainObject) identityMap[id]; else { DomainObject result = CreateDomainObject(); result. Id = id;

第1章 オブジェクトリレーショナル構造パターン

264

} identityMap. Add (result.Id, result); doLoad (result, row); return result;

}

abstract protected DomainObject CreateDomainObject(); private IDictionary identityMap = new Hashtable(); abstract protected void doLoad (DomainObject obj, DataRow row);

class TeamMapper...

protected override void doLoad (DomainObject obj, DataRow row) { Team team = (Team) obj; } team.Name = (String) row["name"]; team. Players = MapperRegistry. Player. FindForTeam (team.Id);

Player を取得するためには、 Player マッパーで特定の find コードを実行する必要がある。

class PlayerMapper...

public IList FindForTeam (long id) { String filter = String.Format("teamID = (0)", id); DataRow rows = table. Select (filter); IList result = new ArrayList(); foreach (DataRow row in rows) { } result. Add (Load (row)); return result;

更新する場合、 Teamは独自のデータを保存し、 データをPlayer テーブルに保存するよ うに Player マッパーに委譲する。

class AbstractMapper...

public virtual void Update (DomainObject arg) { ) Save (arg, FindRow (arg. Id)); abstract protected void Save (DomainObject arg, DataRow row

class TeamMapper...

);

row){

protected override void Save (DomainObject obj, DataRow Team team = (Team) obj; row["name"] = team.Name; savePlayers (team); private void save Players (Team team) { } foreach (Player p in team.Players) } ( MapperRegistry.Player.LinkTeam (p, team.Id);

class PlayerMapper...

public void LinkTeam (Player player, long teamID){ DataRow row = FindRow (player.Id); row["teamID"] = teamID; }

更新コードは、 Player から Team に対しても従うため、 構造はシンプルなものになって いる。 Team 間で Player を移動する場合、 両方の Team を更新するだけでよく、複雑な差 分を表示して Player を整理する必要はない。 この例を、 読み込みコードを自習する際の教 材にしてほしい。そのため、解答は示さないことにする。

123 関連テーブルマッピング

リンクされたテーブルへの外部キーを持つテーブルとして、関連を保存する。

ID Employee * -table- Employees -table- skill-employees employeeID ID skillID Skill -table- Skills

オブジェクトは、コレクションをフィールド値として使用することで、複数値フィールド

6 6

オブジェクトリレーショナル構造パターン

を容易に扱うことができるようになる。 リレーショナルデータベースはこのような機能を 持っていないため、単一値フィールドに制限されている。 1対多の関係をマッピングする場 合、外部キーマッピングを使用してこの処理を実現できる。 つまり基本的に関連の単一値端 に対して外部キーを使用するのである。 しかし、 外部キーを保持するための単一値端がない ため、 多対多の関係ではこのような処理を行うことができない。

この状況に対する解決策は、リレーショナルデータを好む人が長年使用してきた従来の方 法、 つまり、 関連を記録するための特別なテーブルを作成することである。 次に、関連テー ブルマッピングを使って、 複数値フィールドをリンクテーブルに追加する。

12.3.1 動作方法

関連テーブルマッピングの基本的な考えは、 関連の格納にリンクテーブルを使用すること である。 このテーブルは、互いにリンクされる2つのテーブルの外部キーID だけを持ち、 それぞれペアとなっている関連オブジェクトごとに1行を持つ。

リンクテーブルには、 メモリ上に対応するオブジェクトはないため、リンクテーブルが ID を持つことはなく、 またプライマリキーは関連付けられるテーブルの2つのプライマリ キーを組み合わせたものである。

一言で言うと、リンクテーブルからデータを読み出すには、2つのクエリーを発行する。 ここでは Employee (従業員) のSkill (スキル) を読み込む場合を考えてみよう。この場合、 概念上は少なくとも2段階でクエリーを発行する。 最初に skillsEmployees テーブルに対 するクエリーを発行し、 求める Employee とリンクしているすべての行を検索する。 次に リンクテーブルの各行の関連 ID に対応する Skill オブジェクトを見つけ出す。

情報がメモリ上にある場合、スキームは問題なく機能する。 情報がメモリにない場合は、 リンクテーブル内にある各Skill に1つのクエリーを発行するためクエリーにコストがかか る。それを回避するには、 Skill テーブルとリンクテーブルとのジョインを行う。 結果、 マッピングは多少複雑にはなるものの、1つのクエリーによってすべてのデータを取得する ことができる。

リンクデータの更新には、 多値フィールドの更新と同じような操作が必要だが、幸い依存 マッピングでリンクテーブルを扱うことができるため、それほど面倒ではない。 リンクテー ブルを参照するテーブルは他にはないため、必要に応じて自由にリンクの作成および削除を 行うことができる。

12.3.2 使用するタイミング

関連テーブルマッピングの標準的なケースは多対多の関連である。 その理由は、他の現実

的な代替案がないためである。

関連テーブルマッピングは、 その他の関連の形式に対しても使用できる。 しかし、 外部 キーマッピングよりも複雑でジョインが追加されるため、 あまり勧められない。 たとえいく つかの状況で関連テーブルマッピングが関連を単純にするのに適していても、スキーマを制 御できないデータベースが関連してくる場合がある。 2つの既存テーブルのリンクが必要な ときに、テーブルに対して列を追加することができない場合もある。 その場合は、 新しい テーブルを作成して関連テーブルマッピングを使用する。 必要でないときであっても、 既存 のスキーマが関連テーブルを使用する場合もある。 その場合は、 データベーススキーマを簡 素化するより関連テーブルマッピングを使用した方が簡単な場合が多い。

リレーショナルデータベースの設計において、 お互いのつながりについての情報を含む関 連テーブルを持つことが多い。 たとえば、ある人物の会社における雇用に関する情報を格納 する人/会社 (Person/Company) 関連テーブルなどがその例である。 この場合、 人/会社 (Person/Company) 関係テーブルは、ドメインオブジェクトに対応する。

12.3.3 例: Employee Skill (C#)

これはスケッチのモデルを使用したシンプルな例である。 ここでは、 Skill のコレクショ ンを持ったEmployee クラスを挙げて、 コレクションに含まれる各 Skill を複数の Employee に対応させている。

class Employee...

public IList Skills ( } get { return ArrayList.ReadOnly (skillsData)set {skillsData = new ArrayList (value); } public void Addskill (Skill arg)( skillsData.Add(arg); ) public void RemoveSkill (Skill arg) ( } skillsData.Remove (arg); private IList skillsData = new ArrayList();

;}

データベースから Employee を読み込むには、 EmployeeMapper を使って Skill を抽出 する。 それぞれのEmployee Mapper クラスは、 Employee オブジェクトを作成する Find メソッドを持っている。 すべてのマッパーは、共通サービスを抽出する Abstract Mapper クラスのサブクラスとなる。

268

class EmployeeMapper...

public Employee Find (long id) { } return (Employee) Abstract Find(id);

class AbstractMapper...

protected DomainObject Abstract Find (long id) { Assert. True (id != DomainObject. PLACEHOLDER_ID); DataRow row = FindRow(id); ) return (row == null) ? null Load (row); protected DataRow Find Row (long id) { } String filter = String.Format("id = (0)", id); DataRow] results = table. Select (filter); return (results. Length == 0) ? null results [0]; protected DataTable table { } get (return dsh. Data. Tables (TableName]; } public DataSet Holder dsh; abstract protected String TableName (get;)

class EmployeeMapper...

protected override String TableName ( get (return "Employees";) }

データセットホルダーは、 ADO.NET データセットとデータベースに保存するための関 アダプターを含むシンプルなオブジェクトである。

class DataSetHolder...

public DataSet Data = new DataSet();

private Hashtable DataAdapters = new Hashtable();

この例をわかりやすくするため、ここではデータセットは必要なデータとともにすでに読 み込まれていることを前提としている。

Find メソッドはLoad メソッドを呼び出して、 Employee のデータを読み込む。

class AbstractMapper...

protected DomainObject Load (DataRow row) { } long id (int) row ["id"]; if (identityMap[id] != null) return (DomainObject) identityMap[id]; else { } DomainObject result = CreateDomainObject(); result. Id = id; identityMap. Add (result. Id, result); doLoad (result, row); return result; abstract protected DomainObject CreateDomainObject();

private IDictionary identityMap = new Hashtable();

abstract protected void doLoad (DomainObject obj, DataRow row);

class EmployeeMapper...

protected override void doLoad (DomainObject obj, DataRow rowEmployee emp (Employee) obj; emp. Name (String) row["name"]; loadSkills (emp);

Skill(スキル) の読み込みは分離したメソッドで実行するためとてもぎこちない。

class EmployeeMapper...

private IList loadSkills (Employee emp) { DataRow rows = skillLinkRows (emp); IList result = new ArrayList(); foreach (DataRow row in rows) { ) long skillID = (int) row["skillID"]; emp.AddSkill (Mapper Registry. Skill. Find (skillID)); return result; private DataRow [] skillLinkRows (Employee emp) ( String filter = String.Format("employeeID = {0}", emp.Id); return skillLinkTable. Select (filter);

270

オブジェクトリレーショナル構造パターン

) {

private DataTable skillLinkTable (

}

get (return dsh. Data. Tables["skill Employees"]; }

Skill 情報の変更は、 Abstract Mapper 上で Update メソッドを用いて行う必要がある。

class AbstractMapper...

public virtual void Update (DomainObject arg) {

}

Save (arg, Find Row (arg. Id));

abstract protected void Save (DomainObject arg, DataRow row);

Update メソッドは、サブクラスでSave メソッドを呼び出す。

class EmployeeMapper...

protected override void Save (DomainObject obj, DataRow row) (

Employee emp = (Employee) obj;

row["name"] = emp. Name;

saveSkills (emp);

}

ここでも私は、 Skill の保存用に、分離したメソッドを作成している。

class EmployeeMapper... private void save Skills (Employee emp) { deleteSkills (emp); foreach (Skill s in emp. Skills) ( DataRow row = skillLinkTable.NewRow(); row["employeeID"] = emp. Id; row["skillID"] = s.Id; skillLinkTable.Rows.Add(row); ) ) private void deleteSkills (Employee emp) { DataRow skillRows = skillLinkRows (emp); foreach (DataRow r in skillRows) r.Delete();

ここに示すロジックは、既存のリンクテーブル行をすべて削除し新しい行を作成するとい うシンプルなものである。これによって、 どの行が追加されどの行が削除されたかを確認す る手間を省略できる。

123.4例 ダイレクト SQL の使用 (Java)

私が ADO.NET が素晴らしいと考える点の1つは、 クエリーの最小化についての詳細内 容に触れることなくオブジェクトリレーショナルマッピングの基本についてわかりやすく解 説できるという点である。 他のリレーショナルマッピングスキームの場合、 SQL に類似し ているためクエリーの最小化も考えなければならない。

データベースに直接アクセスする場合、 クエリーの最小化は重要である。 最初のバージョ ンでは2つのクエリーを発行して、 Employee と Skill を抽出する。 この方法はわかりやす いが最適ではないので、もう少し加えたい。

以下にテーブルのDDL を示す。

create table employees (ID int primary key, firstname varchar, lastname varchar)

create table skills (ID int primary key, name varchar) create table employeeSkills (employee ID int, skillID int, primary key (employeeID, skillID))

1人のEmployee を読み込む場合、 私も同様の手法を使用する。 Employee Mapper は、 レイヤスーパータイプの抽象的な find メソッドに対しシンプルなラッパーを定義する。

class EmployeeMapper...

public Employee find (long key) ( } return find (new Long (key)); public Employee find (Long key) { return (Employee) abstractFind (key); } protected String findStatement () { return } "SELECT " + COLUMN_LIST + FROM employees" + * WHERE ID = ?";

public static final String COLUMN_LIST = ID, lastname, firstname

class AbstractMapper...

protected DomainObject abstract Find (Long id) {

DomainObject result = (DomainObject) loadedMap.get(id); if (result = null) return result;

PreparedStatement stmt = null;

ResultSet rs = null;

try {

stmt =DB.prepare (findStatement()); stmt.setLong (1, id.longValue());

rs stmt.executeQuery();

rs.next();

result load (rs);

return result;

} catch (SQLException e) {

throw new ApplicationException(e);

} finally (DB.clean Up (stmt, rs);

}

abstract protected String findStatement();

}

protected Map loadedMap = new HashMap();

次に、 find メソッドはload メソッドを呼び出す。 Employee のデータが Employee Mapper に読み込まれる一方、 抽象的なload メソッドはID 読み込みを処理する。

class AbstractMapper...

protected DomainObject load (ResultSet rs) throws SQLException { Long id new Long (rs.getLong(1)); return load (id, rs);

public DomainObject load (Long id, ResultSet rs) throws SQLException { if (hasLoaded(id)) return (DomainObject) loaded Map.get(id); DomainObject result = doLoad (id, rs); loadedMap.put (id, result); return result;

}

abstract protected DomainObject doLoad (Long id, ResultSet rs) throws SQLException;

class EmployeeMapper...

}

protected DomainObject doLoad (Long id, ResultSet rs) throws SQLException {

Employee result = new Employee (id); result.setFirstName (rs.getString("firstname")); result.setLastName (rs.getString("lastname")); result.setSkills (loadSkills (id)); return result;

}

Employee は、 Skill を読み込むために別のクエリーを発行する必要があるが、ここでは1 つのクエリーですべてのSkill を簡単に読み込むことができる。 SkillMapper を呼び出し特 定のSkill のデータを読み込む。

class EmployeeMapper...

protected List loadSkills (Long employeeID) {

PreparedStatement stmt = null;

ResultSet rs = null;

try {

List result = new ArrayList();

stmt DB.prepare (findSkills Statement);

ーショナル構造バターン

stmt.setObject (1, employeeID);

rs stmt.executeQuery();

while (rs.next()) {

Long skillId = new Long (rs.getLong(1));

result.add((Skill) MapperRegistry.skill().loadRow (skillId, rs));

return result;

} catch (SQLException e) {

throw new ApplicationException(e);

} finally (DB.cleanUp (stmt, rs);

private static final String findSkills Statement = SELECT skill.ID, +SkillMapper. COLUMN_LIST +

FROM skills skill, employeeSkills es "+

class SkillMapper...

}

WHERE es. employeeID = ? AND skill.ID = es.skillID";

}

}

public static final String COLUMN_LIST = " skill.name skillName

class AbstractMapper...

274

protected DomainObject loadRow (Long id, ResultSet rs) throws SQLException { return load (id, rs);

}

class SkillMapper...

protected DomainObject doLoad (Long id, ResultSet rs) throws SQLException { Skill result = new Skill (id); result.setName (rs.getString("skillName")); return result; )

AbstractMapper もまた、 Employee の検索に役立つ。

class EmployeeMapper...

public List findAll() { } return findAll (findAllStatement); private static final String findAllStatement = " "SELECT + COLUMN_LIST + " FROM employees employee" + ORDER BY employee.lastname";

class AbstractMapper...

protected List findAll (String sql) ( PreparedStatement stmt = null; ResultSet rs = null; try { List result = new ArrayList(); stmt =DB.prepare (sql); rs stmt.executeQuery(); while (rs.next()) result.add(load (rs)); return result; ) catch (SQLException e) { throw new ApplicationException(e) finally (DB.cleanUp (stmt, rs); }

);

これらの機能は、とてもシンプルでわかりやすい。 しかし、 クエリーの数についての問題 がある。 各Employee には読み込みのために、 2つのクエリーが必要になるという問題であ る。 1つのクエリーで多数の Employee に対する基本的な Employee データを読み込むこ とはできるが、加えてSkill の読み込みには Employeel 人あたり1つのクエリーが必要に なる。そのため、100人分の Employee を読み込むためには101 個のクエリーが必要とな るのである。

12.3.5 例: 複数の Employee に対する1つのクエリーの使用 (Java)

1つのクエリーで、 多数の Employee をそのSkill とともに呼び戻すことができる。 この 例は、より複雑な複数テーブルクエリーの最適化の優れた例である。 毎回ではなく必要な場 合にだけ、 この方法を使うことも優れている理由である。 重要性の低いクエリーよりも、 速 度の遅いクエリーの高速化に多くの労力を注ぐことを勧める

最初にあげるケースは、 基本データを保持する同一のクエリーで1人のEmployee の Skill を抽出するというシンプルなものである。 3つのテーブルにまたがってジョインを行う SQL 文を使用する。

class EmployeeMapper...

protected String findStatement ()

{ } return "SELECT " + COLUMN_LIST + * FROM employees employee, skills skill, employeeskills es" + WHERE employee. ID= esemployeeID AND skill.ID = es.skillID AND employee.ID = ?"; public static final String COLUMN_LIST = "employee.ID, employee.lastname, employee.firstname, es.skillID, esemployeeID, skill. ID skillID, SkillMapper.COLUMN_LIST;

スーパークラスのabstractFind メソッドとload メソッドは、前述した例と同じである ためここでは省略する。 EmployeeMapper は、複数のデータ行を使用するため別にデータ を読み込む。

class EmployeeMapper...

protected DomainObject doLoad (Long id, ResultSet rs) throws SQLException( Employee result = (Employee) loadRow(id, rs);

276

loadSkill Data (result, rs); while (rs.next()) { } Assert.isTrue (rowIs For Same Employee (id, rs)); loadSkill Data (result, rs); return result;

protected DomainObject loadRow (Long id, ResultSet rs) throws SQLException ( Employee result = new Employee (id); result.setFirstName result.setLastName (rs.getString("firstname")); (rs.getString("lastname")); return result;

private boolean rowIs For Same Employee (Long id, ResultSet rs) throws SQLException { return id.equals (new Long (rs.getLong (1)));

}

private void loadSkill Data (Employee person, ResultSet rs) throws SQLException { } Long skillID = new Long (rs.getLong ("skill ID")); person.addSkill ((Skill)MapperRegistry.skill().loadRow(skillID, rs));

この場合、 Employee Mapper の loadメソッドが、 残りの結果群を調べてデータを読み 込む。

1人の Employee のデータを読み込む場合は、 シンプルである。 しかし、この複数テーブ ルクエリーの有効性は、 多数の Employee を読み込むときに発揮される。 特にその結果群 を Employee でグループ化したくない場合には、 読み込み権の取得が難しくなる。 ここで は、関連テーブル自体に焦点をあてた結果群を通して、 同時に Employee と Skill を読み込 むヘルパークラスを導入してい

SQL と特定の Loader クラスへの呼び出しから始める。

class EmployeeMapper...

public List findAll() {

return findAll (findAll Statement);

private static final String findAllStatement =

}

"SELECT + COLUMN_LIST +

"FROM employees employee, skills skill, employeeSkills es" " WHERE employee.ID = es.employeeID AND skill.ID = es.skillID"

}

}

* ORDER BY employee.lastname"; protected List findAll(String sql) ( AssociationTableLoader loader = new AssociationTableLoader (this, new skillAdder()); return loader.run(findAllStatement);

}

class AssociationTableLoader...

private AbstractMapper sourceMapper;

private Adder target Adder;

public AssociationTableLoader (AbstractMapper primaryMapper, Adder targetAdder) (

this.sourceMapper = primaryMapper;

this.targetAdder = targetAdder;

}

skillAdder について、ここでは気にする必要はない。 後の解説で少しずつ明らかになっ てくる。 現時点では、マッパーへの参照を持つ Loaderクラスを構築し、 次にクエリーに よって読み込みを実行するように指示している点に少しだけ注意してほしい。 これがメソッ ドオブジェクトの標準的な構造である。 メソッドオブジェクト [Beck Patterns] とは、複雑 なメソッドを独自のオブジェクトに変換する方法である。 最大のメリットは、パラメータを 介して値を受け渡すのではなく、値をフィールドに配置する点である。 メソッドオブジェク トを使用する一般的な方法では、まずメソッドオブジェクトを作成し、 実行して、役割が終 わった後は削除する。

読み込みの振る舞いは、3段階で行われる。

class AssociationTableLoader...

protected List run (String sql) { loadData (sql); addAll NewObjectsToIdentityMap(); return formResult(); }

loadData メソッドは、 SQL 呼び出しを形成し、 実行して、 結果群をループさせる。 これ はメソッドオブジェクトであり、 結果群はフィールドに配置されているため受け渡す必要は ない。

第1章 オブジェクトリレーショナル構造パターン

class AssociationTableLoader...

private ResultSet rs = null; private void loadData (String sql) ( PreparedStatement stmt = null; try { stmt =DB.prepare (sql); rs = stmt.executeQuery(); while (rs.next()) loadRow(); } catch (SQLException e) ( throw new ApplicationException(} finally (DB.clean Up (stmt, rs); } }

e);

loadRow メソッドは、 結果群の1つの行からデータを読み込む。 この部分は少し複雑で ある。

class AssociationTableLoader...

private List resultIds = new ArrayList(); private Map inProgress = new HashMap(); private void loadRow() throws SQLException { Long ID = new Long (rs.getLong (1)); if (!resultIds.contains (ID)) resultIds.add(ID); if (!sourceMapper. hasLoaded (ID)) { if (!inProgress.keySet().contains(ID)) inProgress. put (ID, sourceMapper.load Row (ID, rs)); targetAdder.add( (DomainObject) inProgress.get(ID), rs); )

class AbstractMapper...

boolean has Loaded (Long id) { return loadedMap.containsKey(id);

Loader クラスは、 結果群にあるすべての順序を維持するため、 Employee の出力リスト は最初の表示と同じ順序となる。 そのため、私はIDリストを表示されたとおりの順番にし ている。 ID を取得した後、私はそれが完全にマッパーに読み込まれているかどうかを確認

する(通常は以前のクエリーを使用する)。 読み込まれていない場合は、私のデータを読み 込み、それを進行中のリストとして保持する。 複数の行を1つにまとめ Employee のデー タを収集するためのリストが必要になる。 私の場合、これらの行を1行ずつ連続してヒット する必要がない。

このコードの最も複雑な部分は、読み込む Skill を Employee のSkill リストに追加できる ようにしつつ、 Employee と Skill に依存しないようにLoaderクラスの汎用性を保証するこ とである。これを実現するため、私は仕掛けを検討して、 内部インタフェース (Adder) を 検索した。

class AssociationTableLoader...

public static interface Adder { } void add (DomainObject host, ResultSet rs) throws SQLException;

オリジナルの呼び出し側は、 Employee および Skill の特定のニーズに、 Loader クラス をバインドするインタフェースを実装する必要がある。

class EmployeeMapper... private static class SkillAdder implements AssociationTableLoader. Adder { public void add (DomainObject host, ResultSet rs) throws SQLException { Employee emp (Employee) host; Long skillId = new Long (rs.getLong ("skillId")); emp.addSkill((Skill) MapperRegistry.skill().loadRow(skillId, rs));

インタフェースには、関数ポインタまたはクロージャを持った言語が最初から備わってい るので、クラスおよびインタフェースでは、少なくともこのジョブを実行させることはでき (この場合、内部的である必要はないが、狭いスコープを提供することに役立つ)。

読者の予想どおり、私はスーパークラス上でload メソッドとloadRow メソッドを定義し、 load メソッドを呼び出すためloadRow を実装している。 この方法を使用した理由は、読み込 み動作によって結果群が転送されないようにしたいと考えたからである。 load メソッドは、オ ブジェクトを読み込むために必要なことはすべて行うが、 loadRow メソッドは、カーソルの位 置を変更することなく行からデータを読み込むことができる。 多くの場合これら2つのメソッ ドは同じ動作をするが、 Employee Mapper の場合、2つのメソッドは異なった動作を行う。

現時点では、すべてのデータは結果群の形式となっている。 私の手元には2つのコレク ションがある。 1つは、結果群の中にあった Employee ID が、 最初に表示されたときのと

0

おりの順序で並んでいるリストであり、もう1つはEmployee Mapper の一意マッピング でまだ表示されていない新しいオブジェクトのリストである。 次のステップは、 新規オブジェクトを一意マッピングに配置する方法である。

class AssociationTableLoader...

private void addAllNewObjectsToIdentityMap() ( for (Iterator it = inProgress.values().iterator(); it.hasNext();) sourceMapper.putAsLoaded ((DomainObject) it.next());

class AbstractMapper...

void putAsLoaded (DomainObject obj) { loadedMap.put (obj.getID(), obj); )

最後のステップは、マッパーからID を参照し、 結果リストを構築することである。

class AssociationTableLoader...

private List formResult() { List result = new ArrayList(); for (Iterator it = resultIds.iterator(); it.hasNext();) { } Long id = (Long) it.next(); result.add(sourceMapper.lookUp (id)); return result; )

class AbstractMapper...

protected DomainObject lookUp (Long id) { return (DomainObject) loadedMap.get(id); }

このようなコードは、平均的な読み込みコードよりも複雑だがクエリーの数を削減するこ とに役立つ。複雑なのでデータベースのインタラクションが少ない場合には、使用を控える べきだ。 しかし、 データマッパーが、 ドメインレイヤに複雑さを意識させることなくクエ リーを提供するときは適している。

124 依存マッピング

任意のクラスに対して、子クラスへのデータマッピングを実行させる。

{ordered} Track Album * title Album Mapper

他のオブジェクトとのつながりで表示されるオブジェクトもある。 Album (アルバム) の Track (曲目)は、ベースとなるオブジェクトが読み込まれたり保存されるときには、必 ず読み込まれたり保存されたりする。 データベースの他のテーブルから参照されない場合、 Album Mapper に Track へのマッピングを実行させることでこのマッピングを依存マッ ピングとして扱う)、マッピングの手順を簡素化できる。

124.1 動作方法

依存マッピングの基本的な考え方は、任意のクラス Dependent (依存) がデータベース の永続性のために他のクラス Owner (所有者) に依存するということである。 各 Dependent は、 Owner を1つだけ必ず持たなければならない。

これは明らかにマッピングを行うクラスである。 アクティブレコードと行データゲート ウェイの場合、 Dependent クラスには一切のデータベースマッピングコードは含まれず、 マッピングコードは Owner に配置されている。 データマッパーの場合、 Dependent に対 するマッパーはなく、マッピングコードは Owner のマッパーに配置されている。 テーブル データゲートウェイでは、通常、 Dependent はまったく存在せず、 Dependent の処理のす べては Owner で行われる。

多くの場合、 Owner を読み込むたびに Dependent も読み込むことになる。 Dependent の読み込み負荷が大きくしかも使用頻度が少ない場合、 レイジーロードを使用することで、 必要になるまで Dependent の読み込みを回避できる。

Dependent の重要な特性は、 一意フィールドを持たないため一意マッピングに格納され ないという点である。そのため ID を参照する find メソッドによる読み込みはできない。 あ

らゆる検索は、 Owner によって行われるため Dependent のfind メソッドはない。

Dependent 自身が他の Dependent の Owner となることもある。 その場合、最初の Dependent の Owner は、 2番目のDependent の永続性の責任も負うことになる。 Dependent のすべての階層構造は、1つのプライマリ Owner によって制御できる。

データベースのプライマリキーを、 Owner のプライマリキーを含む複合キーにすること は難しいことではない。 オブジェクトが同じOwner を持たない限り、 Dependent のテー ブルへの外部キーを持つテーブルはないはずである。 その結果、 Owner または Dependent 以外のメモリ上のオブジェクトが、 Dependent を参照することはない。 厳密に言うと、 参 照はデータベースに対して永続的ではないというルールを緩和できるが、 永続的ではない参 照を持つこと自体が混乱を招く原因でもある。

UML モデルでは、 Owner と Dependent 間のつながりを示すには、コンポジションが適 切である。

Dependent の書き込みおよび保存は Owner に任されていて、 外部参照がないため、 削 除および挿入することによって Dependent の更新を処理する。 そのため、 Dependent の コレクションを更新する場合、 Owner にリンクしている行を削除してから、 Dependent を 再び挿入する。これで Owner のコレクションに対し追加または削除されたオブジェクトの 分析を省略できる。

Dependent は、 多くの点でバリューオブジェクトに似ているが、何かをバリューオブ ジェクト (等号記号のオーバーライドなど) にするときに使用する方法を必要としないこと が多い。 純粋にメモリ上の観点からその違いを考えると、 Dependent とバリューオブジェ クトとの間には際立った違いは見あたらない。 オブジェクトの依存性は、データベースマッ ビングの振る舞いだけを表している。

依存マッピングを使用すると、 Owner に行った変更の記録が複雑化してしまう。 Dependent (依存) に変更を加えた場合、 変更の時点で Owner にマーキングする必要が生 じ、 結果 Owner はその変更をデータベースに書き込むことになる。 このような動作をシン ブルにするためには、 Dependent を不変にすることであり Dependent に行う一切の変更 は、消去または新しい Dependent の追加で行うことである。 メモリ上のモデルは動作が難 しくなるが、データベースマッピングはシンプルになる。 理論上、 データマッパーを使用す る場合、メモリ上のマッピングとデータベースマッピングは独立しているはずだが、これに 関しては柔軟性を持った対応も必要な場合がある。

124.2 使用するタイミング

依存マッピングは、他の1つのオブジェクトだけから参照されるオブジェクトがあるとき に使用する。 このような状況は、1つのオブジェクトが Dependent のコレクションを持つ

ときに起こる。 依存マッピングは、 Owner が Dependent への参照のコレクションを持つ が、バックポインタがないなどの状況に適切に対応できる。 独自のIDがないオブジェクト が数多くある場合、依存マッピングを使用して永続性の管理が容易になる。 依存マッピングを有効に使用するには、以下の前提条件を満たす必要がある。

Dependent は、 必ず1つのOwner を持たなければならない。

■Dependent のOwner 以外は、いかなるオブジェクトからも参照されていては いけない。

Entity (エンティティ) オブジェクトと Dependent オブジェクトを使ってドメインモデ ルを設計するオブジェクト指向設計を教える講義がある。 私は、 依存マッピングとは根本的 なオブジェクト指向設計メディアではなく、 データベースマッピングをシンプルにするため の1つの技法と考える。 特に、 大規模な Dependent グラフは避けるようにしている。 問題 は、グラフの外部から Dependent を参照することができなくなり、 ルート Owner の周辺 をベースとした複雑な照合スキームに陥りやすい点にある。

ユニットオブワークを使う場合、 依存マッピングの使用はお勧めしない。 ユニットオブ ワークを使用して記録する場合、 削除と再挿入がまったく役立たなくなってしまう。 また、 Dependent を制御しないため、さまざまな問題が生じる可能性もある。 Mike Retting が私 に語ったのは、ユニットオブワークがテストのために挿入された行を記録し、 テストが済ん だ時点でその行を削除するというアプリケーションについてである。この場合は Dependent を記録しなかったため、 オーファン (孤立) 行が発生しテストでエラーの原因 となったのである。

12.4.3 例: Album Track (Java)

このドメインモデル (図 12.7) では、 Album は Track のコレクションを保持している。 アプリケーションは実用的ではなくシンプルではあるが、 Track を参照するためにはこのア プリケーションだけで十分であり、依存マッピングの例としては有用である (パターンのた めに用意された例として考える人もいるだろう)。

Track {ordered} Album * title

12.7 依存マッピングを使用して処理するTrack を持つ Album

レーショナル構造パターン

284

Track は、 Title だけを持つ。 私の場合、 Track クラスを不変なクラスとして定義している。

class Track...

private final String title; public Track (String title) { this.title = title; } public String getTitle() { return title; }

Track は、 Album クラスに保持される。

class Album...

private List tracks = new ArrayList(); public void addTrack (Track arg) {

tracks.add(arg);

public void removeTrack (Track arg) {

tracks.remove (arg);

};

public void removeTrack (int i) (

tracks.remove(i);

return (Track []) tracks.toArray(new Track [tracks.size()]);

}

public Track [] getTracks () {

}

}

Album Mapper クラスは、 TrackのSQL を処理するため、 Track テーブルにアクセス する SQL文を定義している。

class AlbumMapper... protected String findStatement () { return "SELECT ID, a.title, t.title as trackTitle" + " FROM albums a, tracks t" + WHERE a.ID = ? AND t.albumID = a.ID" + ORDER BY t.seq";

Album (アルバム) が読み込まれるときには、常にTrack (曲目) がAlbum (アルバム) に読み込まれる。

class AlbumMapper...

protected DomainObject doLoad (Long id, ResultSet rs) throws SQLException {

String title = rs.getString(2);

Album result = new Album (id, title);

loadTracks (result, rs);

} return result; public void loadTracks (Album arg, ResultSet rs) throws SQLException { arg.addTrack (newTrack (rs)); } while (rs.next()) { } arg.addTrack (newTrack (rs)); private Track newTrack (ResultSet rs) throws SQLException { String title = rs.getString (3); Track newTrack = new Track (title); return newTrack;

オブジェク

ショナル構造パターン

わかりやすくするため、この例では分離したクエリーで Track の読み込みを行っている。 パフォーマンスを考えると、 262 ページの例のように同一のクエリーで各行を読み込むとい う方法を使用した方がよい場合もある。 Album が更新されると、 Track が削除または再挿入さ

れる。

class AlbumMapper...

public void update (DomainObject arg) { PreparedStatement updateStatement = null; try { updateStatement = DB.prepare("UPDATE albums SET title = WHERE id = ?"); updateStatement.setLong (2, arg.getID().longValue()); Album album (Album) arg; updateStatement.setString (1, album.getTitle()); updateStatement.execute(); updateTracks (album); } catch (SQLException e) { throw new ApplicationException(e);

?

} finally (DB.cleanUp (updateStatement); }

}

public void updateTracks (Album arg) throws SQLException { PreparedStatement deleteTracks Statement = null; try ( deleteTracks Statement = DB.prepare("DELETE FROM tracks WHERE albumID = ?"); deleteTracks Statement.setLong (1, arg.getID().longValue()); deleteTracks Statement.execute(); for (int i = 0; i < arg.getTracks ().length; i++) { } Track track = arg.getTracks ( ) [i]; insert Track (track, i + 1, arg); } finally (DB.clean Up (deleteTracks Statement); }

public void insert Track (Track track, int seq, Album album) throws SQLException {

PreparedStatement insertTracks Statement = null;

try {

}

insertTracks Statement = DB.prepare ("INSERT INTO tracks (seq, albumID, title) VALUES (?, ?, ?)"); insertTracks Statement.setInt(1, seq);

insertTracks Statement.setLong (2, album.getID().longValue()); insertTracks Statement.setString (3, track.getTitle()); insertTracks Statement.execute();

} finally (DB.cleanUp (insertTracks Statement);

}

12.5 組込バリュー

オブジェクトを他のオブジェクトテーブルの複数フィールドにマッピングする。

Employment ID person: person period: DateRange salary: Money "table" Employments ID: int personID: int start: date end:date salaryAmount: decimal salaryCurrency: char

データベースのテーブルとしては意味を持たない多くの小さなオブジェクトが、 オブジェ クト指向システムでは意味を持つ。 例では、並行性を重視する Money (貨幣) オブジェク トと Date Range (日付範囲) オブジェクトを含んでいる。 最初に考えるべきことはオブ ジェクトをテーブルとして保存する方法だが、データがない Person (人) には、Money 値 のテーブルは必要ない。

組込バリューは、 オブジェクトの値をオブジェクトのOwner のレコードフィールドに マッピングする。このスケッチでは、 Date Range オブジェクトと Money オブジェクトへ のリンクを持ったEmployment オブジェクトを使用している。 結果テーブルでは、オブ ジェクトのフィールドは新しいレコードとして作成されるのではなく、 Employment テー ブルのフィールドにマッピングされる。

12.5.1 動作方法

この例の動作はとてもシンプルである。 所有しているオブジェクト (Employment)が読 み込まれるか保存されると、 依存しているオブジェクト (Date Range や Money)も同時 に読み込まれ保存される。 永続性は Owner によって確保されるため、 Dependent が独自 の永続性のためのメソッドを持つことは必要ない。 組込バリューは特定のケースでの依存 マッピングと考えられる。 この場合値は、1つの Dependent オブジェクトになる。

12.5.2 使用するタイミング

動作はとてもシンプルだが、使用するタイミングを判断することが難しいパターンの1つ である。

288

第1章 オブジェクトリレーショナル構造パターン

組込バリューを使う最もシンプルなケースは、 Money や Date Range のようにシンプル なバリューオブジェクトの場合である。 バリューオブジェクトは、ID を持たないため同期 を維持するための一意マッピングのようなことを考えることなく、いつでも自由に作成およ び削除できる。 バリューオブジェクトのテーブルが必要ないため、バリューオブジェクトは 組込バリューとして維持されるのである。

判断が難しいのは、 Order や Shipping オブジェクトなどの参照オブジェクトを、組込バ リューで保存する価値があるかどうかである。 はじめに検討すべき点は、Shipping データ が、Order とは別のコンテキストで関連性があるかどうかである。 問題は読み込みと保存で ある。 Order の読み込み時にメモリにShipping データの読み込みだけを行う場合、同 テーブルに双方を保存することは一考を要する点である。 もう1つの検討すべき点は、SQL を介して個別に Shipping データにアクセスしたいかどうかである。 SQL を介してレポート を行い、 他にレポートする分離したデータベースがない場合にこの点が重要となる。

既存のスキーマにマッピングする場合、 メモリ上の複数のオブジェクトに分割するデータ が、テーブルに含まれているのであれば、組込バリューを使って行う。 このような状況が発 生する原因は、オブジェクトモデルの振る舞いを抜き出すために、分離したオブジェクトが 必要なのだが、 データベースでメモリ上にある複数のオブジェクトすべてを一つのエンティ ティとして扱ってしまう場合である。 この場合、 Dependent の変更が、 Owner を不確定な オブジェクトとして扱っている (Owner 内で置き換えられるバリューオブジェクトにとっ ては問題ではない)。

多くの場合、 オブジェクト間の関連が双方とも単一値 (1対1の関連) である時には、参 照オブジェクト上で組込バリューを使用すればよいのである。 また、 複数の Dependent の 候補があり、 その個数が少なくかつ固定されていれば使用する場合もある。このとき、各値 に番号付けされたフィールドを持つ。このような方法はテーブル設計の点でも、 SQL によ るクエリー実行の点でも複雑だが、 パフォーマンス上のメリットがある。 しかし、この場合 にはシリアライズ LOB の使用を勧める。

いつ組込バリューを使用するかを決定するロジックの多くは、シリアライズ LOB のロ ジックと同じであるため、双方のどちらを選択するかを検討する。 組込バリューの最大のメ リットは、 Dependent オブジェクトの値に対し SQL クエリーを作成できるという点である。 XMLを基盤としたSQL への追加クエリーと組み合わせ、 直列化機能で XML を使用する 方法は将来的には変わるかもしれないが、現時点ではクエリーで Dependent 値を使用する 場合には組込バリューが必要となる。 組込バリューという点は、データベース上の分離した レポートメカニズムでも有用である。

組込バリューは、 シンプルな Dependent にだけ使用できる。 独立した Dependent、 あ るいは2~3の分離した Dependent の場合に正しく機能する。 シリアライズ LOB は、大 規模なオブジェクトサブグラフを含む、 より複雑な構造に有効である。

125.3 参考文献

今まで組込バリューはさまざまな名称で呼ばれてきて、たとえば TOPLink では集合体 マッピングと呼ばれ、 Visual Age ではコンポーザと呼ばれている。

125.4 例: バリューオブジェクトの例(Java)

組込バリューにマッピングされたバリューオブジェクトの標準的な例である。 例では、以 下のフィールドを持つシンプルなProductOffering (製品販売) クラスから始める。

class ProductOffering...

private Product product; private Money baseCost; private Integer ID;

フィールド内で、IDは一意フィールドであり、 Product は標準的なレコードマッピング である。 組込バリューを使って、 基盤となるコストをマッピングすることにする。 シンプル にするため、 アクティブレコードによってマッピング全体を行う。

アクティブレコードを使用するため、 save ルーチンとload ルーチンが必要となる。 これ らシンプルなルーチンは、 Owner である ProductOffering クラスの中に配置されている Money クラスは、永続的な振る舞いを一切持っていない。 以下にload メソッドを示す。

class Productoffering....

public static ProductOffering load (ResultSet rs) (

Integer id = (Integer) rs.getObject("ID");

try{

BigDecimal baseCostAmount=rs.getBigDecimal ("base_cost_amount"); Currency baseCost Currency = Registry.getCurrency

(rs.getString("base_cost_currency")); Money baseCost = new Money (baseCostAmount, baseCostCurrency); Integer productID = Integer) rs.getObject("product"); Product product = Product.find((Integer) rs.getObject("product")); return new Product offering (id, product, baseCost); } catch (SQLException e) {

throw new ApplicationException(e);

}

90

以下に更新の振る舞いを示す。 更新のシンプルなバリエーションである。

class ProductOffering...

public void update() ( } PreparedStatement stmt = null; try { stmt = DB.prepare (updateStatement String); stmt.setBigDecimal (1, baseCost. amount ()); stmt.setString (2, baseCost.currency().code()); stmt.setInt(3, ID. intValue()); stmt.execute(); } catch (Exception e) { throw new ApplicationException(e); } finally (DB.cleanUp (stmt); } private String updateStatement String "UPDATE product_offerings" + " SET base_cost_amount = ?, base_cost_currency = ? WHERE id = ?";

"+

12.6 シリアライズ LOB

オブジェクトのグラフを直列化し、1つの大規模オブジェクト (LOB) としてデータ ベースフィールドに格納する。

{hierarchy} parent 1 children Customer Department 1 * -table- Customers | departments: BLOB

オブジェクトモデルには、小規模オブジェクトの複雑なグラフが含まれることが多い。 構 造に含まれる情報の多くはオブジェクトの中ではなく、 オブジェクト間のリンクの中にある。 Customer の組織図を保存する場合を考えてみよう。 オブジェクトモデルは、 組織図を表示 するためのコンポジットパターンを自然に表現できる。 また、 先祖、 兄弟、 子孫、 およびそ の他のつながりを取得するためのメソッドも容易に追加できる。

ただし、これらすべてをリレーショナルスキーマに配置することは容易ではない。 基本ス キーマ、親の外部キーを持ったOrganization (組織) テーブルはシンプルだが、スキーマ の操作にはさまざまな作業が必要となり困難で手間がかかる。

オブジェクトは、相互に関連したテーブル行として永続的である必要はない。 永続性を確 保する別の形式が直列化である。 オブジェクトのグラフ全体が、1つの大規模オブジェクト (LOB) としてテーブルに書き出された場合、 シリアライズ LOB はメメント [Gang of Four]の形式になる。

12.6.1 | 動作方法

直列化には、バイナリ形式 (BLOB) とテキスト形式 (CLOB の2種類の方法がある。 さまざまなプラットフォームは、 オブジェクトグラフを自動的に直列化する機能を含んでい るため、バイナリ形式 (BLOB) を作成することが最も容易である場合が多い。 グラフの保

ル構造バター

第1章 オブジェクトリレー

存とは、 バッファで直列化しバッファを関連するフィールドに保存するというシンプルな処 理である。

BLOB のメリットとしては、 プログラミングが容易であり(プラットフォームがサポート している場合)、 使用するスペースを最小化できるという点が挙げられる。一方短所は、使 用するデータベースがバイナリデータ型をサポートしていなければならないという点である。 また、そのオブジェクトがないとグラフの再構成ができず、 フィールドはまったく理解でき ないものになってしまう。 しかし、最も考えなくてはならない問題はバージョニングである。 たとえば、 Department (部署) クラスを変更する場合、データはデータベース内に長期間 存在することができるため、 以前の直列化をすべて読み込むことができない場合がある。 こ れは重要な問題である。

この代替案が CLOB である。 この場合、 Department グラフは、必要な情報を含むテキ スト文字列に直列化される。 テキスト文字列は、 人の頭脳で簡単に読むことができるため、 データベースの何気ない参照に役立つ。 ただしテキスト手法は、 より多くのスペースを必要 としテキスト形式のために単独のパーサーを作成しなければならない場合もある。 さらに、 バイナリ直列化よりも速度が遅くなりがちである。

CLOB のデメリットの多くは、 XML によって解決できる。 XML バーサーは一般的なた め記述する必要はない。 さらに、 XML は幅広くサポートされている標準であり操作に対し てもさまざまなツールを使用できる。 一方、XML でも解決できない短所は、スペースの間 題である。 この形式は冗長であるためスペースの問題は極めて深刻である。 1つの対処法と しては、 ZIP 化された XML 形式を BLOB として使用するという方法がある。 人が見て読 めなくなるが、スペースが問題となる場合には有効な選択肢である。

シリアライズ LOB を使用する場合、 ID の問題にも注意する必要がある。 たとえば、あ るOrder での Customer の詳細にシリアライズ LOB を使用するとしよう。 この場合、 Order テーブルに Customer LOB を配置してはいけない。 Customer データが Order に コピーされ、更新時に問題が発生してしまうからである(しかし、発注時点の Customer データのスナップショットをそのまま格納しておきたい場合にはよいことである。 一時的な 関係を回避できる)。 従来のリレーショナルから考えると、 各 Order に合わせて Customer データを更新したい場合には、 LOB を customer テーブルに配置して、複数の Order が LOB にリンクできるようにする必要がある。 ID およびデータのための1つのLOB フィールドだけを持つテーブルに関しては何の問題もない。

一般的にこのパターンを使用する場合には、データの重複に注意する必要がある。 シリア ライズ LOB 全体が複製されず、その一部分が他のLOB とオーバーラップしてしまう場合 も多い。 シリアライズ LOB に格納されるデータには十分な注意を払い、 シリアライズ LOB のOwner としての役割を果たす1つのオブジェクト以外からは、確実にデータにアクセス できないようにしなければならない。

126.2 使用するタイミング

シリアライズ LOB は、 意外にも検討される機会が少ない。 実装が容易なテキスト形式の 手法である XML は、シリアライズLOB をより使い勝手のよいものに変身させることがで きる。しかし短所は、 SQL を使用する構造にクエリーを発行できない点である。 SQL 拡張 は XML データをフィールドのように見せるが、それは同じ (あるいは移植可能) ではない。

このパターンは、オブジェクトモデルの一部を使ってLOB を表現する場合にも有効に機 能する。 LOB は、アプリケーション外部のSQL ルートからクエリーを発行する可能性の低 い、一連のオブジェクトを取得するための手段である。 次いでこのグラフはSQL スキーマ にフックされる。

LOB 参照 オブジェクトに外部オブジェクトが埋め込まれている場合、 シリアライズ LOB はうまく機能しない。 この状況に対応するには、 LOB 内部のオブジェクトへの参照をサ ポートする参照スキームの形式をいくつか考えなくてはいけないが、 とても面倒であるため 現実に使用されることはほとんどない。 XML、 あるいは XPath はこのような煩雑さを多少 軽減することはできる。

分離したデータベースをレポートのために使用していて、 他のすべての SQL がそのデー タベースに対して発行されている場合、 LOB を適切なテーブル構造に変換することができ る。 レポート用のデータベースは非正規化されるため、シリアライズ LOBに適した構造は、 分離したレポート用のデータベースにも適している場合が多い。

12.6.3 例: XML による Department 階層構造の直列化 (Java)

ここでは、スケッチの Customer と Department という概念を例に挙げて、 Department を XML CLOB に直列化する方法を解説する。 Java の XML 処理はややプリ ミティブで不安定であるため、最終的に生成されるコードには若干の差異が見られることが ある(私は初期バージョンのJDOM を使用している)。

このスケッチのオブジェクトモデルは、以下のクラス構造を構築する。

class Customer...

private String name; private List departments = new ArrayList();

class Department... private String name; private List subsidiaries = new ArrayList();

オブジェクト

アルパターン

この場合のデータベースが持っているテーブルは、1つだけである。

departments varchar)

create table customers (ID int primary key, name varchar,

Customer (顧客) をアクティブレコードとして扱い、挿入の振る舞いによるデータの書 き込みを説明する。

class Customer... public Long insert() ( PreparedStatement insertStatement = null; try { insertStatement =DB.prepare (insertStatement String); setID (findNext DatabaseId()); insertStatement.setInt(1, getID().intValue()); insertStatement.setString(2, name); insertStatement.setString (3, XmlStringer.write(departmentsToXmlElement()));

insert Statement.execute();

Registry.addCustomer (this);

return getID();

} catch (SQLException e) {

throw new ApplicationException(e);

} finally (DB.cleanUp (insert Statement);

}

public Element departmentsToXmlElement () { Element root = new Element ("department List"); Iterator i = departments.iterator();

}

while (i.hasNext()) {

Department dep (Department) i.next(); root.addContent (dep. toXmlElement());

}

return root;

class Department...

Element toXmlElement () { Element root = new Element ("department"); root.setAttribute("name", name); Iterator i subsidiaries.iterator(); while (i.hasNext()) {

}

} } Department dep (Department) i.next(); root.addContent (dep. toXmlElement()); return root;

オブジェクトリレーショナル構造パターン

Customer クラスは、Department フィールドを1つのXML DOM に直列化するため のメソッドを持つ。 各 Department クラスもまた、自ら (およびその再帰的な子孫)を DOM に直列化するメソッドを持つ。 次に insert メソッドは、 Department の DOM を取 得し文字列に変換して(ユーティリティクラスを介して)、 データベースに配置する 文字 列の構造について、ここでは特に気にする必要はない。 読むことはできるが定期的に参照す ることはないだろう。

<?xml version="1.0" encoding="UTF-8"?>

<departmentList> <department name="US"> <department name="New England"> <department name="Boston" /> <department name="Vermont" /> </department> <department name="California" /> <department name="Mid-West" /> </department> <department name="Europe" /> </departmentList>

読み込みは、このようなプロセスを反対にしたものに過ぎない。

class Customer...

public static Customer load (ResultSet rs) throws SQLException ( Long id new Long (rs.getLong("id")); Customer result = (Customer) Registry.getCustomer(id); if (result = null) return result; String name = rs.getString("name"); String department Lob = rs.getString("departments"); result new Customer (name); result.readDepartments (XmlStringer. read (department Lob)); return result;

void readDepartments (Element source) (

)

List result = new ArrayList(); Iterator it = source.getChildren ("department").iterator(); while (it.hasNext()) addDepartment (Department.readxml ( (Element) it.next()));

}

class Department...

static Department readXml (Element source) ( String name = source.getAttributeValue("name"); Department result = new Department (name); Iterator it = source.getChildren ("department"). iterator(); while (it.hasNext()) result.addSubsidiary (readXml ((Element) it.next())); return result;

読み込みコードは、明らかに挿入コードのミラーイメージである。 Department クラスは、 XML要素から自ら (およびその子孫) を作成する方法を知っていて、 Customer クラスは XML要素を取得して、そこから Department リストを作成する方法を知っている。 load メソッドは、 ユーティリティクラスを使用して、データベースから取得した文字列をユー ティリティ要素に変換する。

ここで注意しなくてはならないのは、誰かがデータベース内の XML を手動で編集しよう として XML を壊し、このload ルーチンによる読み込みができなくなってしまう場合であ る。妥当性確認のために DTD または XML スキーマをフィールドに追加する機能をサボー トできるツールがあれば、このような状況を回避するためにとても役立つ。

12.7 シングルテーブル継承

クラスの継承階層構造を、 さまざまなクラスのフィールドに対する列を持つ、1つの テーブルとして作成する。

name Player "<table> club Footballer Cricketer batting average name club Players batting average bowling average type Bowler bowling average

リレーショナルデータベースは、継承をサポートしていないため、 オブジェクトからデー タベースにマッピングする時には、リレーショナルテーブル内で優れた継承構造を作成する 方法について考えなければならない。 リレーショナルデータベースへのマッピングを行う場 合、私たちは最小限のジョインで処理しようとする。 ジョインは、複数テーブルの継承構造 を処理すると、急速に増えてしまう。 シングルテーブル継承でも、 継承構造のクラスの フィールドを1つのテーブルにマッピングするのである。

127.1 動作方法

継承マッピングスキームでは、継承階層構造のクラスすべてのデータを含む1つのテーブ ルを持つことになる。 各クラスには、1つのテーブル行に継承に関連するデータが格納され る。データベース内の関連のない列は空のままとなる。 マッピングの基本的な振る舞いは、 継承マッパーの汎用スキームに従ってい

オブジェクトをメモリに読み込む場合、 どのクラスをインスタンス化するのかを知ってお く必要がある。 そのため、どのクラスを使用するかを指示するフィールドをテーブルに持た せる。このフィールドは、クラス名かコードフィールドのいずれかである。 フィールドを関 連するクラスにマッピングするためには、コードフィールドは何らかのコードによって解釈 されるので、クラスが階層構造に追加されるときには、コードを拡張する必要がある。 クラ

第1章 オブジェクトリレーショナル構造パターン

ス名をテーブルに組み込む場合、 クラス名を直接使うだけでインスタンスを作成することが できる。 しかしクラス名は、多くのスペースを占有するので、 データベースのテーブル構造 をクラス名で直接処理するのは困難な場合がある。 また、データベーススキーマにクラス構 造をより密接に結合してしまう場合もある。

データの読み込みでは、 先ずコードを読み込み、 どのサブクラスをインスタンス化するか を知る必要がある。 データの保存時には、コードは階層構造のスーパークラスによって書き 出される。

12.7.2 使用するタイミング

シングルテーブル継承は、 継承階層構造のフィールドをリレーショナルデータベースに マッピングするための選択肢の1つである。 代替案としては、 クラステーブル継承と具象 テーブル継承がある。

シングルテーブル継承のメリットは、以下のとおりである。

■テーブルがデータベースに1つしかない。

■データを抽出するためのジョインはない。

階層構造に対するフィールドをリファクタリングしても、データベースを変更 する必要はない。

一方、 シングルテーブル継承の短所は以下のとおりである。

■フィールドは、関連を持つ場合と持たない場合があり、テーブルを直接使う人 の混乱を招く原因ともなる。

■一部のサブクラスだけが使う列によって、 データベースのスペースが浪費され る。スペースがどの程度問題となるかは、データの性質と、データベースによ る空きフィールドの圧縮率によって左右される。 たとえば Oracle は、特にデー タベーステーブルの右側に追加列を確保している場合、浪費スペースのトリミ ング効率に優れている。 それぞれのデータベースは、このような問題に対処す るための特別な仕掛けの構造を持っている。

■シングルテーブルが巨大化し、 インデックスも多くロックも頻繁に行われる結 果、 パフォーマンスに悪影響が及ぶことがある。 これを回避するには、 特定の プロパティを持つ行のキーをリストアップするか、 インデックスに関連のある フィールドのサブセットをコピーする分離したインデックステーブルを持つ。

■フィールドに対して1つの名前スペースだけしか持っていないため、異なる フィールドに対して同じ名前を使用しないように注意しなければならない。 この 場合、クラス名にプレフィックスまたはサフィックスを付けた複合名が役立つ。

階層構造全体に、継承マッピングの1つの形式を使う必要はないことを忘れないでほしい。 大量の特定のデータを持つクラスに対して、 具象テーブル継承を使う場合は、1つのテーブ ル内にある類似した6つのクラスを完全にマッピングできる。

127.3 例: Player のためのシングルテーブル (C#)

他の継承例と同様に、ここでは継承マッパーを基に、 図 12.8に示すクラスを使用してい る。各マッパーは、 ADO.NET データセットのデータテーブルにリンクしている。 リンク は、マッパースーパークラスで汎用的に作成できる。 ゲートウェイのデータプロパティは、 クエリーによって読み込みできるデータセットである。

Mapper + Insert (Domain Object) + Update (Domain Object) +Delete (Domain Object) -hook methods Save (Domain Object, Row) Load (Domain Object, Row) PlayerMapper + Find (key): Player +Insert + Update AbstractPlayer Mapper #Save #Load 1 FootballerMapper +Find (key): Footballer # Save # Load CricketerMapper + Find (key): Cricketer #Save 1 #Load 1 BowlerMapper + Find (key): Bowler #Save #Load

継承マッパーの汎用クラス図

0

図 12.8

class Mapper... protected DataTable table { get (return Gateway. Data. Tables [TableName]; } } protected Gateway Gateway; abstract protected String TableName (get;)

この例にはテーブルが1つしかないため、 AbstractPlayerMapper クラスによって定義

する。

class AbstractPlayerMapper...

protected override String TableName {

get (return "Players";)

}

それぞれのクラスには、 処理対象となる Player の種類をマッパーコードが把握できるよ うにするために、 タイプコードが必要になる。 タイプコードは、スーパークラスで定義され サブクラスに実装される。

class Abstract PlayerMapper...

abstract public String TypeCode (get; }

class CricketerMapper... public const String TYPE_CODE = "C"; public override String TypeCode ( get (return TYPE_CODE; } }

PlayerMapper クラスは、3つの具象 Mapper

class PlayerMapper...

クラスに対するフィールドを持っている。

private BowlerMapper bmapper; private CricketerMapper cmapper; private FootballerMapper fmapper; public PlayerMapper (Gateway gateway) base (gateway) ( : bmapper new BowlerMapper (Gateway) ; cmapper = new CricketerMapper (Gateway); fmapper = new Footballer Mapper (Gateway) ;

127.4|データベースからのオブジェクトの読み込み

各々の具象 Mapper クラスは、データからオブジェクトを取得する Find メソッドを持っ 71130

class CricketerMapper...

public Cricketer Find (long id) { return (Cricketer) AbstractFind(id); }

以下の例は、オブジェクトを検索する汎用の振る舞いを呼び出す。

class Mapper...

protected DomainObject Abstract Find (long id) { } DataRow row FindRow(id); return (row == null) ? null Find(row); protected DataRow FindRow (long id) { } String filter = String.Format("id = (0)", id); DataRow[] results = table. Select (filter); return (results. Length == 0) ? null results[0]; public DomainObject Find (DataRow row) { } DomainObject result = CreateDomainObject(); Load (result, row); return result;

abstract protected DomainObject CreateDomainObject();

class CricketerMapper...

protected override DomainObject CreateDomainObject() { return new Cricketer ();

}

私の場合は、一連のLoadメソッドによってデータを階層構造中の各クラスの新規オブ ジェクトに読み込む。

class Cricketer Mapper...

クトリレーショナル構造パターン

protected override void Load (DomainObject obj, DataRow row) { base.Load(obj, row); Cricketer cricketer = (Cricketer) obj; cricketer.battingAverage = (double) row["battingAverage"];

}

class Abstract PlayerMapper...

protected override void Load (DomainObject obj, DataRow row) base.Load(obj, row); Player player (Player) obj; player.name = (String) row["name"]; }

class Mapper...

protected virtual void Load (DomainObject obj, DataRow row) { obj.Id = (int) row ["id"];

また、 PlayerMapper クラスを介して Player を読み込むこともできる。 これを実現する にはデータを読み込み、 どの具象マッパーを使うかを判断するためにタイプコードを使う。

class PlayerMapper...

public Player Find (long key) ( DataRow row = FindRow (key); if (row == null) return null; else { String typecode = (String) row["type"]; switch (typecode) { case BowlerMapper.TYPE_CODE: return (Player) bmapper.Find(row); case Cricketer Mapper.TYPE_CODE: return (Player) cmapper.Find(row); case FootballerMapper.TYPE_CODE: return (Player) fmapper. Find (row); default: throw new Exception ("unknown type");

{

12.7.4.1 オブジェクトの更新

更新のための基本操作は、 すべてのオブジェクトで共通であるためマッパースーパークラ スに定義できる。

class Mapper...

public virtual void Update (DomainObject arg) ( Save (arg, FindRow (arg. Id)); }

Save メソッドはLoad メソッドと似ていて、 各クラスはSave メソッドに含まれるデー タを保存するように定義される。

class CricketerMapper...

protected override void Save (DomainObject obj, DataRow row) base. Save (obj, row); } Cricketer cricketer = (Cricketer) obj; row["battingAverage"] = cricketer.battingAverage;

class Abstract PlayerMapper...

protected override void Save (DomainObject obj, DataRow row) {

Player player = (Player) obj;

row["name"] = player.name;

row["type"] = TypeCode;

PlayerMapper クラスは適切な具象マッパーを返す。

class PlayerMapper... public override void Update (DomainObject obj) { } MapperFor (obj). Update (obj); private Mapper MapperFor (DomainObject obj) { ) if (obj is Footballer) return fmapper; if (obj is Bowler) return bmapper; if (obj is Cricketer) return cmapper; throw new Exception("No mapper available");

{

ナル構造パターン

12.7.4.2 オブジェクトの挿入

挿入は更新と似ているが、唯一の違いは新しい行をテーブル内に作成した後、 保存する必 要がある点である。

class Mapper....

public virtual long Insert (DomainObject arg) DataRow row = table.NewRow(); arg. Id = GetNextID(); row["id"] = arg. Id; Save (arg, row); table.Rows.Add(row); return arg. Id; }

{

class PlayerMapper...

public override long Insert (DomainObject obj) { } return Mapper For (obj). Insert (obj);

12.7.4.3 オブジェクトの削除

削除はとてもシンプルである。 削除は抽象マッパーレベル、 またはPlayer 義される。

Mapper に定

class Mapper...

public virtual void Delete (DomainObject obj) { DataRow row = FindRow (obj.Id); row. Delete(); }

class PlayerMapper...

public override void Delete (DomainObject obj) ( } MapperFor (obj). Delete (obj);

12.8 | クラステーブル継承

クラスごとに1つのテーブルを使って、クラスの継承階層構造を作成する。

オブジェクトリレーショナル構造パターン

club name Player club <table> Footballers Footballer Cricketer batting average "<table> Cricketers batting average «<table> Bowlers bowling average Bowler bowling average "<table> Players name

オブジェクトとリレーショナルのミスマッチが顕著に現れるのは、リレーショナルデータ ベースが継承をサポートしていない点である。 求められるデータベース構造は、 オブジェク トに対して明確にマッピングされ、 階層構造のどこへでもリンクできる構造である。 クラス テーブル継承は、継承構造のクラスごとに1つのデータベーステーブルを使うことで、この ような要件をサポートしている。

12.8.1 | 動作方法

ドメインモデルのクラスごとに1つのテーブルを持つクラステーブル継承は、 とてもわか りやすいパターンである。 ドメインクラスのフィールドは、 対応するテーブルのフィールド へ直接マッピングされる。 他の継承マッピングと同様、ここでも継承マッパーの基本的な手 法が適用されている。 問題となるのは、データベーステーブルの対応する行へのリンクの方 法である。 考えられる解決策としては、共通のプライマリキーの値を使う方法が挙げられる。 たとえば、 Footballers (フットボールプレイヤー) テーブルのキー101 の行と、 Players テーブルのキー 101の行は、同じドメインオブジェクトに対応する。 スーパークラステーブ ルは、他のテーブルの各行にそれぞれ対応する行を持っているため、この方法を使用する場 合、プライマリキーはすべてのテーブル間で一意となる。 代替案として、 各テーブルに単独 のプライマリキーを持たせ、スーパークラステーブルに対する外部キーを使って行を結び付

ける方法もある。

クラステーブル継承による実装に関する最大の問題は、複数テーブルからのデータの抽出 をいかに効率的に実行するかである。 当然、 データベースに対する複数の呼び出しがすでに あるため、各テーブルに呼び出しを行うことはあまり効率的な方法とは言えない。 これを回 避するには、さまざまなコンポーネントテーブルにまたがったジョインを行う必要があるが、 3つまたは4つ以上のテーブルのジョインは、 データベースが最適化を行う方法によっては 速度低下につながる傾向がある。

さらに大きな問題は、所定のあらゆるクエリー内で、 ジョイン対象であるテーブルを正確 に把握できなくなってしまうことが多いという点である。 たとえば、 Footballer (フット ボールプレイヤー) を検索する場合、 Footballer テーブルを使うことはわかっている。 しか し、 任意の Group に属している Player を探す場合、 どのテーブルを使用するかは容易に判 断できない。 一部のテーブルにデータがない場合に効率的にジョインを行うために、 外部 ジョインを行う必要があるが、 これは標準規格ではなく、速度が低下する場合も多い。 代替 案として、 最初にルートテーブルを読み込んだ後、 コードを使って次に読み込むテーブルを 判断するという方法も考えられるが、これには複数のクエリーが必要となる。

128.2 使用するタイミング

継承マッピングを考える場合、 クラステーブル継承、シングルテーブル継承および、具象 テーブル継承の3つの選択肢がある。

クラステーブル継承のメリットは以下のとおりである。

■ すべての列が各行に関連を持つため、テーブルの関係がわかりやすくスペース も浪費されない。

■ドメインモデルとデータベース間の関連が、シンプルでわかりやすい。

一方、 クラステーブル継承の短所は以下のとおりである。

■オブジェクトを読み込むために、複数のテーブルに作用する必要がある。これ はジョインまたは複数のクエリーとメモリでのソーイングを必要とする。

階層構造に対するフィールドのリファクタリングが、データベースの変化を引 き起こす。

■スーパータイプテーブルは頻繁にアクセスされるため、 ボトルネックとなる可 能性がある。

高度な正規化によって、 個別クエリーの把握が困難になる。

1つのクラス階層構造に対して継承マッピングパターンを1つに限定する必要はない。 階 層構造の最上部のクラスにクラステーブル継承を使用し、 そのクラスより下位のクラスに一 連の具象テーブル継承を使うこともできる。

128.3 参考文献

IBM のテキストでは、このパターンはルートリーフマッピング [Brown et al.] と呼ばれて いる。

12.8.4 例: Player とその Kin (仲間)(C#)

スケッチの実装は以下のとおりである。 ここでは再び、 図12.9 の継承マッパーを使って、 Player とその仲間というわかりやすいテーマに沿って進める。

Mapper + Insert (Domain Object) +Update (Domain Object) +Delete (Domain Object) -hook methods Save (Domain Object, Row) #Load (Domain Object, Row) PlayerMapper + Find (key): Player + Insert + Update AbstractPlayer Mapper #Save #Load FootballerMapper + Find (key): Footballer #Save #Load 1 1 CricketerMapper + Find (key): Cricketer #Save #Load BowlerMapper + Find (key) Bowier # Save #Load

継承マッパーの汎用クラス図

図 12.9

各クラスは、データとタイプコードを保持するテーブルを定義する必要がある。

class Abstract PlayerMapper...

abstract public String TypeCode (get; }

protected static String TABLENAME =

class FootballerMapper...

"Players";

public override String TypeCode (

get (return "F";)

)

protected new static String TABLENAME = "Footballers";

他の継承例とは異なり、この例にはオーバーライドされるテーブル名はない。これはイン スタンスがサブクラスのインスタンスである場合であっても、クラスに対するテーブル名を 持たなければならないためである。

12.8.4.1 オブジェクトの読み込み

すでに他のマッピングを読み込んでいる場合、 最初のステップは具象マッパーの Find メ ソッドである。

class FootballerMapper...

public Footballer Find (long id){

return (Footballer) AbstractFind (id, TABLENAME);

AbstractFind メソッドは、 キーに一致する行を探し、 検索に成功するとドメインオブ ジェクトを作成し、 そのLoad メソッドを呼び出す。

class Mapper...

public DomainObject Abstract Find (long id, String tablenameDataRow row = FindRow (id, tableFor (tablename)); if (row == null) return null; else { DomainObject result = CreateDomainObject(); result.Id = id; Load(result);

) {

}

return result;

protected DataTable tableFor (String name) { } return Gateway. Data. Tables [name]; protected DataRow FindRow (long id, DataTable table) { String filter = String.Format("id = (0)", id); DataRow] results = table. Select (filter); } return (results. Length == 0) ? null results [0]; protected DataRow FindRow (long id, String tablename) return FindRow(id, table For (tablename));

}

}

{

protected abstract DomainObject CreateDomainObject();

class FootballerMapper...

protected override DomainObject CreateDomainObject() { return new Footballer (); }

}

各クラスには、クラスが定義するデータを読み込む Load メソッドが1つある。

class FootballerMapper...

protected override void Load (DomainObject obj) { base.Load(obj); DataRow row = FindRow (obj.Id, table For (TABLENAME)); Footballer footballer (Footballer) obj; footballer.club (String) row["club"]; }

class AbstractPlayerMapper...

protected override void Load (DomainObject obj) { DataRow row FindRow (obj. Id, table For (TABLENAME)); Player player = (Player) obj; player.name(String) row["name"];

他の例のコードと同様 (ただしこの例の方がより顕著だが)、 ここでも私は、 ADO.NET データセットはデータベースからデータを抽出し、 それをメモリにキャッシュすることに 頼っている。これによりテーブルベースのデータ構造への複数のアクセスが可能となり、 パ

第1章 オブジェクトリレーショナル構造パターン

フォーマンスコストが大幅に低下することはない。 データベースに直接アクセスする場合は、 このような負荷を削減する必要がある。 この例では、テーブルにまたがるジョインを作成し 操作することで負荷を削減してある

PlayerMapper クラスは、 検索する必要のある Player の種類を決定し、 正しい具象マッ パーへ委譲する。

class PlayerMapper...

));

public Player Find (long key) ( DataRow row = FindRow (key, tableFor (TABLENAMEif (row == null) return null; else { String typecode = (String) row["type"]; if (typecode == bmapper. TypeCode) return bmapper. Find (key); if (typecode == cmapper. TypeCode) return cmapper. Find (key); if (typecode == fmapper. TypeCode) return fmapper. Find (key); throw new Exception("unknown type"); }

protected static String TABLENAME = "Players";

12.8.4.2 オブジェクトの更新

Update メソッドは、マッパースーパークラスに配置される。

}

class Mapper... public virtual void Update (DomainObject arg) { Save (arg); }

(階層構造の各クラスが1つずつ持っている) 一連のSave メソッドを介して実装される。

class FootballerMapper...

protected override void Save (DomainObject obj) { base. Save (obj); DataRow row = FindRow (obj. Id, table For (TABLENAME)); Footballer footballer (Footballer) obj;

row["club"] = footballer.club;

class Abstract PlayerMapper...

protected override void Save (DomainObject obj) ( DataRow row = FindRow (obj. Id, table For (TABLENAME)); Player player (Player) obj; row["name"] = player.name; row["type"] = TypeCode;

PlayerMapper (プレイヤーマッパー) クラスのUpdate メソッドは、正しい具象マッ バーに委譲するための汎用メソッドをオーバーライドする。

class PlayerMapper...

public override void Update (DomainObject obj) {

MapperFor (obj). Update (obj);

private Mapper MapperFor (DomainObject obj) {

if (obj is Footballer)

return fmapper;

if (obj is Bowler)

return bmapper;

if (obj is Cricketer)

return cmapper;

}

throw new Exception("No mapper available");

12.8.4.3 オブジェクトの挿入

オブジェクトを挿入するためのメソッドは、マッパースーパークラスで宣言される。 これ には次の2つの段階がある。 まずは、 新しいデータベース行を作成し、 次に Save メソッド を使い空白行を必要なデータで更新する。

class Mapper... public virtual void Update (DomainObject argSave (arg); }

) (

)

各クラスは、テーブルに1つの行を挿入する。

}

3 12

}

レーショナル構造バターン

class FootballerMapper...

protected override void AddRow (DomainObject obj) ( base. AddRow(obj); InsertRow (obj, table For (TABLENAME)); }

class Abstract Player Mapper...

protected override void AddRow (DomainObject obj) ( InsertRow (obj, table For (TABLENAME));

}

class Mapper...

abstract protected void AddRow (DomainObject obj); protected virtual void InsertRow (DomainObject arg, DataTable table) DataRow row = table.NewRow(); row["id"] = arg. Id; table.Rows.Add (row); }

{

PlayerMapper クラスは、具象マッパーへの委譲を行う。

class PlayerMapper... public override long Insert (DomainObject obj) ( } return MapperFor (obj). Insert (obj);

12.8.4.4 オブジェクトの削除

行を削除

オブジェクトを削除する場合、 各クラスはデータベースの対応するテーブルからする。

class Footballer Mapper...

public override void Delete (DomainObject obj) ( base. Delete (obj); DataRow row = FindRow (obj.Id, TABLENAME); row. Delete(); }

class Abstract PlayerMapper....

第1章 オブジェク

public override void Delete (DomainObject obj) { DataRow row = FindRow (obj.Id, tableFor (TABLENAME)); row.Delete(); }

class Mapper...

public abstract void Delete (DomainObject obj);

ル構造パターン

PlayerMapper クラスは、ここでも作業を軽減するため具象マッパーへと委譲を行う。

class PlayerMapper...

override public void Delete (DomainObject obj) {

MapperFor (obj).Delete(obj);

}

12g|具象テーブル継承

階層構造の具象クラスごとに1つのテーブルを使って、クラスの継承階層構造を作成する。

club Footballer name Player Cricketer batting average Bowler bowling average "<table> Footballers name club -table- Cricketers name batting average name "table- Bowlers batting average bowling average

純粋なオブジェクト指向主義者が主張するように、リレーショナルデータベースは継承を サポートしていない。 これがオブジェクトリレーショナルマッピングを複雑にしている理由

314

である。 オブジェクトインスタンスの観点からテーブルを考えた場合、最も有効な手段は、 メモリ上の各オブジェクトを取得し、1つのデータベース行にマッピングすることである。 この方法は、継承階層構造の各具象クラスに1つのテーブルがある具象テーブル継承を暗に 示唆している。

このパターンに対して難しい名前を付けてしまったのは私である。 多くの人は、階層構造 のリーフクラスごとに1つのテーブルを持つことから、これをリーフ指向と呼んでいる。こ のロジックに従うと、このパターンをリーフテーブル継承と呼ばざるを得ず、 「リーフ」と いう用語をパターンで使用することが多い。 しかし、 厳密にはリーフではない具象クラスも テーブルを持つことがあるため、あまり直感的な用語ではないと思うが、より正確な表現を 使うことにしたのである。

12.9.1 動作方法

具象テーブル継承は、 階層構造の各具象クラスに1つのデータベーステーブルを使用する。 各テーブルには、具象クラスと列が含まれるため、スーパークラスのフィールドはサブクラ スのテーブルにまたがってコピーされる。 他の継承スキームと同様に基本的な振る舞いは、 継承マッパーを使用する。

このパターンにおいては、 キーに注意する点がある。 重要なポイントは、キーは1つの テーブルに対してだけでなく、 必ず階層構造のすべてのテーブルに対して一意になるように することである。 これが必要なケースとは、たとえば Player のコレクションを持ち、 テーブ ルワイドなキーを持った一意フィールドを使用するような場合である。 具象クラスをマッピ ングするテーブル間でキーの複製が可能な場合、 特定のキーの値に対して複数の行を取得す ることになる。そのため、テーブル全体のキーの使用方法を記録するキー割り当てシステム が必要となり、 データベースのプライマリキーの一意性メカニズムは使用できなくなる。

そのため、他のシステムのデータベースに接続する場合、状況は複雑になる。 多くの場合、 テーブル間でのキーの一意性は保証されないので、 スーパークラスフィールドの使用を回避 するかテーブル識別子を含む複合キーを使用することになる。

この状況の一部は、 スーパークラスにタイプ化されていないフィールドを持たないことで 回避できるが、明らかにオブジェクトモデルの妥協である。 代替案としては、 インタフェー スにはスーパータイプのアクセッサーを持ち、実装の各具象タイプに対してはプライベート フィールドを使用する方法がある。 そして、 インタフェースをプライベートフィールドの値 と組み合わせる。 public インタフェースが単一値の場合、 null (設定なし) を除く任意のブ ライベート値を選択する。 一方 public インタフェースがコレクション値の場合、実装 フィールドの値を結合して応答する。

複合キーの場合、特別なキーオブジェクトを一意フィールドのID フィールドとして使用

第1章 オブジェク

する。キーはテーブルのプライマリキーとテーブル名の両方を使って一意性を判断する。

この点に関する問題は、データベースでの参照整合性である。 ここでは図 12.10 に示すオ ブジェクトモデルを取り上げてみよう。 参照整合性を実装するには、 Charity Function (チャリティイベント) と Player の外部キー列を含むリンクテーブルが必要となる。 問題は、 Player のテーブルがない点であり、 Footballer Cricketer (クリケットプレイヤー)のい ずれかを取得する外部キーの参照整合性の制約をできないことである。 残された選択肢は、 参照整合性を無視するか、 複数のリンクテーブル (データベースの実際のテーブルに対して 1つずつ持つ) を使うかである。 最大の問題は、キーの一意性を保証できるかである。

「ナル構造パターン

select 文によって Player を検索する場合、 適切な値がどのテーブルに含まれているかを 判断するには、すべてのテーブルをチェックしなければならない。 これは、複数のクエリー を使うか、 外部ジョインを使うかになるが、どちらもパフォーマンスに悪影響を与える。 必 要なクラスがわかっていれば、 パフォーマンスへの影響は避けられるが、パフォーマンスを 改善するためには、具象クラスを使う必要がある。

このパターンは、リーフテーブル継承とも呼ばれている。 具象クラスごとに1つのテーブ ルを持たせるのではなくて、リーフクラスごとに1つのテーブルを持たせるバリエーション を好む人もいる。 階層構造に具象スーパークラスがない場合にも同じ結果となる。 具象スー パークラスがある場合でもその差異は極めて小さい。

CharityFunction Player * name Footballer Cricketer club batting average

12.10- 具象テーブル参照に参照整合性の問題を引き起こすモデル

129.2 使用するタイミング

継承のマッピング方法を決める代替案としては、具象テーブル継承、 クラステーブル継承、 およびシングテーブル継承がある。

具象テーブル継承のメリットは、以下のとおりである。

■各テーブルは自己完結していて、 関連性のあるフィールドを持たない。 結果と

316

して、オブジェクトを使用しない他のアプリケーションから使われる際に役立 つ。

■具象マッパーからデータを読み込む場合、 ジョインの必要がない。

■各テーブルはクラスがアクセスされるときにだけアクセスされるため、アクセ ス負荷が分散される。

具象テーブル継承の短所は、以下のとおりである。

■プライマリキーが扱いにくい。

抽象クラスに対してデータベースの関連付けを実行できない。

■ドメインクラスのフィールドが階層構造で上下に移動された場合、 テーブル定 義を変更しなければならない。 クラステーブル継承ほどの変更は必要ないが、 シングルテーブル継承のときのように無視することはできない。

■スーパークラスフィールドが変化する場合、 スーパークラスフィールドはテー ブル間で複製されるため、このフィールドを持つ各テーブルを修正する必要が ある。

■スーパークラスの検索によって、 すべてのテーブルのチェックが強制され、 複 数のデータベースアクセス (あるいは正常とは言えないジョイン) へとつながっ ていく。

この3つの継承パターンは1つの階層構造に混在できるということを覚えておいてほし い。 そのため、1つまたは2つのサブクラスに対して具象テーブル継承を使い、 残りにシン グルテーブル継承を使うこともある。

12.9.3 例: 具象 Player (C#)

次に、スケッチの実装を示すことにしよう。 本章の他の継承例と同様、ここでも図 12.11 で示した継承マッパーにおけるクラスの基本設計を使っている。

各マッパーは、データのソースであるデータベーステーブルにリンクされている。 ADO.NET では、データセットはデータテーブルを保持する。

class Mapper...

public Gateway Gateway; private IDictionary identityMap = new Hashtable();

public Mapper (Gateway gateway) (

this.Gateway = gateway;

}

private DataTable table {

get {return Gateway. Data. Tables [TableName]; }

abstract public String TableName {get; }

Mapper + Insert (Domain Object) +Update (Domain Object) + Delete (Domain Object) -hook methods #Save (Domain Object, Row) #Load (Domain Object, Row) AbstractPlayer Mapper # Save # Load PlayerMapper +Find (key): Player + Insert + Update 1 FootballerMapper + Find (key): Footballer #Save # Load 1 1 CricketerMapper + Find (key): Cricketer # Save # Load BowlerMapper + Find (key): Bowler #Save # Load

12.11 継承マッパーの汎用クラス図

Gatewayクラスは、データプロパティ内にデータを保持する。 データは適切なクエリー を発行することによって読み込むことができる。

class Gateway...

public DataSet Data = new DataSet();

318

}

各具象マッパーは、データを保持するテーブルの名前を定義する必要がある。

class Cricketer Mapper・・・

public override String TableName ( get (return "Cricketers";}

PlayerMapper は、 各具象マッパーのフィールドを持つ。

class PlayerMapper...

private BowlerMapper bmapper; private CricketerMapper cmapper; private FootballerMapper fmapper; public Player Mapper (Gateway gateway) base (gateway) ( bmapper = new BowlerMapper (Gateway); cmapper new Cricketer Mapper (Gateway): fmapper = new FootballerMapper (Gateway) ;

129.3.1 データベースからのオブジェクトの読み込み

各具象 Mapper クラスは、与えられたキーの任意のオブジェクトを返すFindメソッドを 持っている。

class CricketerMapper...

public Cricketer Find (long id){

return (Cricketer) AbstractFind(id);

スーパークラスの抽象的な振る舞いは、 ID に対して正しいデータベースを見つけ出し、 タイプの新規ドメインオブジェクトを作成し、 Load メソッドを使ってそれを読み込む (Load メソッドについては後述する)。

class Mapper...

public DomainObject AbstractFind (long id) ( DataRow row = FindRow (id); if (row == null) return null;

}

オブジェクトリレーショナル構造パターン

else { } DomainObject result = CreateDomainObject(); Load (result, row); return result;

private DataRow FindRow(long id) { } String filter String.Format("id(0)", id); DataRow results = table. Select (filter); if (results.Length == 0) return null; else return results [0];

}

protected abstract DomainObject CreateDomainObject();

class CricketerMapper...

protected override DomainObject CreateDomainObject() {

return new Cricketer ();

}

データベースからのデータ読み込みは、 Load メソッドによって行われる(または、 Mapper クラス、およびスーパークラスごとに持っている複数のLoad メソッドによって行 われる)。

class CricketerMapper...

protected override void Load (DomainObject obj, DataRow row) { base.Load(obj, row); Cricketer cricketer = (Cricketer) obj; cricketer.batting Average = (double) row["battingAverage"];

class AbstractPlayerMapper...

protected override void Load (DomainObject obj, DataRow row) { base.Load(obj, row); Player player (Player) obj; player.name(String) row["name"];

class Mapper...

protected virtual void Load (DomainObject obj, DataRow row) { obj. Id = (int) row ["id"];

)

3 20

これは、具象クラスに対するマッパーを使ってオブジェクトを検索するためのロジック である。あるいはスーパークラスに対するマッパーである PlayerMapper を使うこともで きる。 PlayerMapper は、 オブジェクトがどのテーブルにあるかを見つけ出すためには不 可欠である。 データはデータセットとしてメモリ上にあるため、以下のような操作を行う。

class PlayerMapper...

public Player Find (long key){ Player result; result = fmapper.Find(key); if (result = null) return result; result = bmapper.Find(key); if (result = null) return result; result=cmapper.Find(key); if (result != null) return result; return null;

もちろん、このような方法が有効なのは、データがメモリ上にあるのが条件である。 デー タベースに3回もアクセスしなければならないとすると (サブクラスが増えると回数も増え る)、アクセスする速度は低下する。 これは、具象テーブル間にジョインを作成する場合に 役立ち、1回のデータベース呼び出しでデータにアクセスできるようになる。 しかし、大規 模なジョインはそれ自体に時間がかかるため、アプリケーションに対してはいくつかのベン チマークを実行して、 何が機能し何が機能しないかを把握する必要がある。 また、これは外 部ジョインとなるため、 構文の速度が低下するだけでなく移植性が失われ、 暗号文のように なってしまうことも多い。

12.9.3.2 オブジェクトの更新

Update メソッドは、マッパースーパークラスで定義できる。

class Mapper...

public virtual void Update (DomainObject arg) (

Save (arg, FindRow (arg. Id));

読み込みと同様、 各 Mapper クラスにSave メソッドを使用する。

)

class CricketerMapper...

オブジェクトリレーショナル構造パターン

protected override void Save (DomainObject obj, DataRow row) { base. Save (obj, row); Cricketer cricketer = (Cricketer) obj; row["battingAverage"] = cricketer.battingAverage; )

class AbstractPlayerMapper...

protected override void Save (DomainObject obj, DataRow row) Player player = (Player) obj; } row["name"] player.name;

PlayerMapper は正しい具象マッパーを検索し、 更新呼び出しを委譲する必要がある。

class PlayerMapper...

public override void Update (DomainObject obj) { } MapperFor (obj).Update(obj); private Mapper MapperFor (DomainObject obj) { }) if (obj is Footballer) return fmapper; if (obj is Bowler) return bmapper; if (obj is Cricketer) return cmapper; throw new Exception("No mapper available");

12.9.3.3 オブジェクトの挿入

挿入は、更新のバリエーションである。 追加した振る舞いは、 新しい行を作成するある。この動作はスーパークラスで実行できる。

ことで

class Mapper...

) {

public virtual long Insert (DomainObject argDataRow row = table.NewRow(); arg. Id GetNext ID(); row["id"] arg. Id; Save (arg, row); table.Rows.Add(row); return arg. Id; }

322

{

ここで再び、 Player クラスは、 適切なマッパーに委譲を行う。

class PlayerMapper...

public override long Insert (DomainObject obj) (

return MapperFor (obj). Insert (obj);

12.9.3.4 オブジェクトの削除

削除は、とてもシンプルである。 前述の例と同様、 メソッドはスーパークラス上れている。

に定義さ

}

class Mapper...

public virtual void Delete (DomainObject obj) { DataRow row = FindRow (obj.Id); row.Delete(); }

また、委譲メソッドは、 Player Mapper 上に定義されている

class PlayerMapper...

public override void Delete (DomainObject obj) {

MapperFor (obj).Delete(obj);

}

12 マッパー

1 オブジェクトリレーショナル構造パターン

継承階層構造を処理するデータベースマッパーを組織化するための構造。

Mapper + Insert (Domain Object) + Update (Domain Object) +Delete (Domain Object) -hook methods Save (Domain Object, Row) #Load (Domain Object. Row) AbstractPlayer Mapper #Save # Load PlayerMapper +Find (key): Player + Insert +Update 1 FootballerMapper + Find (key): Footballer #Save # Load 1 Cricketer Mapper + Find (key): Cricketer #Save # Load BowlerMapper 1 + Find (key) Bowler : #Save # Load

メモリ上のオブジェクト指向の継承階層構造からリレーショナルデータベースへマッピン グする場合、データをデータベースに保存し、 読み込むために必要なコード量は最小限に抑 える必要がある。 また同時に、抽象マッピングの振る舞いと具象マッピングの振る舞いを作 成し、スーパークラスまたはサブクラスの保存または読み込みを可能にしたい。

このような振る舞いの詳細は、 どのような継承マッピングスキーム (シングルテーブル 承、 クラステーブル継承、 および具象テーブル継承) を使用するかによって異なるが、 汎用 構造はいずれのスキームにおいても同じように機能する。

3 24

12.10.1 | 動作方法

階層構造によってマッパーを組織化することで、 各ドメインクラスに対してドメインクラ スのデータの保存や読み込みを行うマッパーを持たせることができるようになる。 これで マッピングの変更が可能なポイントが確保される。 この手法は、 階層構造の具象オブジェク トをマッピングする具象マッパーには特に有効である。 しかし、 抽象クラスのマッパーが必 要となる場合もある。 それは基本階層構造の外部にあるが、具象マッパーへの委譲を行う マッパーで実装できる。

一連の動作をわかりやすく説明するため、 まずは具象マッパーから始めることにしよう。 スケッチでの具象マッパーは、 Footballer Cricketer (クリケットプレイヤー)、 および Bowler (ボウリングプレイヤー)の各 Player のマッパーである。 基本的な振る舞いには、 find insert update および delete 操作が含まれる。

findメソッドが具象クラスを返すため、 find メソッドは具象サブクラス上で宣言される。 これによって、 BowlerMapper (ボウリングプレイヤーマッパー) クラスのfind メソッド は、 抽象クラスではなく、 Bowler を返す。 標準的なオブジェクト指向言語は、 メソッドの 宣言された戻り値タイプの変更を許可しないため、 find 操作を継承し、 特定の戻り値タイプ を宣言することはできない。 もちろん抽象タイプを返すことは可能だが、クラスのダウン キャストをユーザに強制してしまうため絶対に回避すべきである (動的なタイプ化を行う言 語では、このような問題は起こらない)。

find メソッドの基本的な振る舞いは、データベースの行を検索し、 正しいタイプのオブ ジェクトをインスタンス化し (その判断はサブクラスによって行われる)、 次にデータベース からデータとともにオブジェクトを読み込むことである。 load メソッドは、 階層構造の各 マッパーによって実装され、 対応するドメインオブジェクトに対する振る舞いを読み込む。 つまり、BowlerMapper の load メソッドは、 Bowler クラスに固有のデータを読み込み、 Cricketer クラス固有のデータを読み込むためにスーパークラスメソッドを呼び出す。 そして、 さらにこのメソッドがスーパークラスメソッドを呼び出すという順序で処理は進んでいく。

insertメソッドと update メソッドは、 save メソッドを使用する場合と同様に動作する。 インタフェースは、スーパークラス上、レイヤスーパータイプ上に定義できる。 insert メ ソッドは、 新しい行を作成した後、 save フックメソッドを使ってドメインオブジェクトの データを保存する。 update メソッドも、同様に save フックメソッドを使うが、データの 保存だけを行う。 これらのメソッドはload フックメソッドと同じように動作し、 各クラス は固有データを保存しスーパークラスのsave メソッドを呼び出す。

このようなスキームによって、 階層構造の特定の部分にとって必要な情報を保存する適切 なマッパーの記述が容易になる。 次のステップは、 抽象クラスの読み込みと保存であり、 例 では Player が対象である。 最初は、スーパークラスマッパーに適切なメソッドを配置する 方法だが、現実にはかなり複雑である。 具象 Mapper クラスは、 抽象マッパーの insert メ

第1章 オブジェクトリレーショナル構造パターン

ソッドと update メソッドを使うが、 PlayerMapper の insert メソッドと update メソッド が具象マッパーを呼び出すにはこれらをオーバーライドしなければならない。 その結果が汎 用化と組織化の組み合わせの1つである。

私は、マッパーを2つのクラスに分離する方法を好んで用いる。 抽象的な Player Mapper は、データベースに対する特定の Player の読み込みおよび保存を行う。 これは抽象クラス であり、振る舞いは具象マッパーオブジェクトでだけ使われる。 分離した PlayerMapper クラスは、 Player レベルの操作のためのインタフェースに使われる。 PlayerMapper は、 find メソッドを提供し、 insert メソッドやupdate メソッドをオーバーライドする。 これら が果たす役割とは、どの具象マッパーがタスクを処理するかを判断し委譲を行うことである。

このような広範な仕組みは継承マッピングのすべてのタイプに有効だが、 詳細部分は異 なっている。 そのため、 ケースに対する例のコードを提示することはできない。 各継承マッ ピングパターン (シングルテーブル継承、 クラステーブル継承、 および具象テーブル継承 ) の中で例を探すことである。

1210.2 使用するタイミング

汎用スキームは、継承ベースのデータベースマッピングに有効であるが、 代替案として 具象マッパー間におけるスーパークラスマッピングコードのコピーや、 Player のインタ フェースを抽象的な Player Mapper クラスに含めるなどの操作が考えられる。前者は問題 外であり、 後者はありえなくはないが煩雑でわかりにくい PlayerMapper クラスになる。 全体的に見て、このパターンの優れた代替案を考え出すことは困難だろう。

32 6

オブジェクトリレーショナルメタデータマッピングパターン

13.1 メタデータマッピング

メタデータでのオブジェクトリレーショナルマッピングの詳細を保持する。

DataMap domainClass tableName ColumnMap columnName fieldName *

オブジェクトリレーショナルマッピングを処理するコードは、 データベース内のフィール ドとメモリ上のオブジェクト内のフィールドとを対応させる方法を記述している。 コードの 作成は、単調で繰り返しの多い作業になりがちである。 メタデータマッピングを使うと、 開 発者はシンプルなテーブル形式でマッピングを定義した後、表書式を汎用コードで処理し、 データの読み込み、 挿入、 および更新を実行できる。

13.1.1 動作方法

メタデータマッピングを使う際の重要な決定は、 実行時のコードにどのようにメタデータ の情報を組み込むかという点である。 それには、主としてコード生成とリフレクティブプロ グラミングという2つの方法がある。

コード生成によってプログラムを書き込む場合、入力はメタデータになり、 出力はマッピ ングを実行するクラスのソースコードとなる。 クラスは手動で書き込まれたように見えるが、 すべてビルドプロセスで生成されていて、 コンパイルの直前に生成される。その結果の コードとともに配置される。

Mapper クラスはサーバ

コード生成を使うときは、 コード生成がビルドプロセスに完全に統合されていることを確

13

1

認すべきで、どのビルドスクリプトを使っても構わない。 生成されたクラスは、手動で編集 ができないためソースコードとして管理しない。

リフレクティブプログラムでは、オブジェクトに setNameメソッドを呼び出した後、 setName メソッド上で適切な引数を渡してinvoke メソッドを実行する。 複数のメソッド (とフィールド) をデータとして処理することによって、 リフレクティブプログラムでは、 フィールド名とメソッド名をメタデータファイルから読み込むことができ、 これらのデータ を使用してマッピングを実行できる。 通常はリフレクションを勧めない。 それは、リフレク シションの速度が遅いことや、リフレクションからデバッグ困難なコードが生成されることが 多いからである。強いていうとリフレクションはデータベースマッピングには最適である。 1つのファイルから複数のフィールド名とメソッド名の読み込みにリフレクションの柔軟性 を最大限に活用できる。

コード生成はリフレクションほど動的な手法ではない。 それは、マッピングを変更するに は、少なくともソフトウェアの一部で再コンパイルと再配置を常に行う必要があるからであ る。 リフレクティブ手法の場合、 マッピングデータファイルを変更するだけで、 既存のクラ スで新しいメタデータを使えるようになる。 これは、 特定の割り込みを実行して、メタデー タの再読み込みを行うことで、 実行時にも行うことができる。 つまり、 データベースやコー ドに変更を加える場合があるため、 マッピングの変更は最小限に抑えなければならない。 し かし最近の環境では、アプリケーションを部分的に再配置することが容易にできる。

リフレクティブプログラミングでは、速度の面で不都合が生じることが多い。 ただし、 こ の問題は使用環境によって大きく異なり、 ある環境ではリフレクティブ呼び出しの速度が大 幅に遅くなる場合もある。 ただし、 SQL 呼び出しのコンテキストでリフレクションが実行 中であり、リモート呼び出しの速度が遅いことを考えると、速度の低下は必ずしも大きな問 題ではない場合がある。 パフォーマンスの問題と同様に、 環境内を測定して、 速度がどの程 度重要であるかを確認する必要がある。

どちらの手法でもデバッグがやや困難である。これらの手法を比較するには、コード生成 とリフレクティブコードに開発者がどの程度まで習熟しているかによって大きく左右され る。コード生成の方が明示的であり、 デバッガで実行されている内容を確認できる。 このた め、私はリフレクションよりコード生成の方を好んで使う。 また一般的に、コード生成は (私が思うに) 経験の浅い開発者でも容易に使うことができる。

メタデータは、別のファイル形式で保存される場合がとても多い。 最近は XML が頻繁に 使用されるようになったが、 それは XML が階層構造になっていて、 ユーザが単独のバーサ やその他解析ツールを使う必要がないからである。 読み込みステップで、 このメタデータを 取得しプログラミング言語構造に変換する。 そのプログラミング言語によってコード生成出 力かリフレクティブマッピングのいずれかが行われる。

シンプルなケースでは、外部ファイル形式を省略し、ソースコード内に直接メタデータを

データマッピングパターン

328

表示する。 解析は不要になるが、 メタデータの編集は困難になる。

他にもデータベース自体でマッピング情報を保持する方法がある。 この方法ではデータ ベースと内部データが結合される。 データベーススキーマが変更されてもマッピング情報は 正しく表示される。

メタデータ情報を保持する方法を選択する場合、 アクセスと解析のパフォーマンスを考え る必要はない。 コード生成を使う場合、 アクセスと解析は設計時に行われ、 実行時には行わ れない。 リフレクティブプログラミングを使う場合、 実行時にアクセスと解析が行われるが、 システム起動時に一度だけ行われる。 そして、 ユーザはメモリ上の表示を保持することがで きる。

メタデータをどこまで複雑にするかが最大の決定事項の1つである。 包括的なリレーショ ナルマッピングの問題に直面する場合、 メタデータ内に保持するためには数多くの異なる要 因が存在する。 しかし多くのプロジェクトでは、完全に包括的なスキームより少ないスキー ムで管理することができるため、 メタデータはよりシンプルなものになる。 つまり、 メタ データ駆動型のソフトウェアでは新しい機能を簡単に追加できるので、この方法は需要に応 じた設計の拡張に有効である。

メタデータの問題の1つとして挙げられるのは、 通常シンプルなメタデータスキームは存 続期間中 90%は問題なく動作するが、 特定のケースではとても扱いにくい場合が多いことで ある。このような例外的なケースに対処するため、通常はメタデータを複雑にしなければな らない場合が多い。 この他に役立つ方法は、 サブクラスで汎用コードをオーバーライドする ことである。 このサブクラスでは特定のコードが手動で作成される。 このような特定のケー スのサブクラスは、生成されたコードかリフレクティブルーチンのいずれかのサブクラスで ある。これは特別なケースであり、 オーバーライドをサポートするためにどのような処理を 行うかを一般的な用語で説明するのは容易ではない。 臨機応変に対処してほしい。 オーバー ライドが必要な場合、 特別なケースでオーバーライドを行う必要があり、 実際にオーバーラ イドした1つのメソッドを分離するために、 生成されたコードあるいはリフレクティブコー ドを変更する必要がある。

13.1.2 使用するタイミング

メタデータマッピングを使用すると、 データベースマッピング処理に必要な作業負荷を大 幅に削減できる。 ただし、 メタデータマッピングのフレームワークを使用するにはいくつか の設定が必要になる。 また、 メタデータマッピングを使用すると多くの場合は処理が容易に なるが、例外的に、 メタデータが実際には複雑になってしまうこともある。

当然のことながら、商用のオブジェクトリレーショナルマッピングツールではメタデータ マッピングを採用している。 すなわち、洗練されたメタデータマッピングを生成する製品を

販売するためには、それなりの労力を常に費やさなければならないということだ。

独自のシステムを構築する場合、 トレードオフについて考慮する必要がある。 新しいマッ ピングを追加するため、 手動で作成したコードを使用する場合とメタデータマッピングを使 用する場合を比較する。 リフレクションを使用する場合、 リフレクションがパフォーマンス に与える影響を検討する必要がある。 リフレクションによって、パフォーマンスが低下する ことがあれば、向上する場合もあるからである。 また測定方法自体に問題がある場合もある。

| オブジェクトリレーショナルメタデータマッピングパターン

共通的な振る舞いの処理すべてに最適なレイヤスーパータイプを作成することで、手動 コーディングの追加作業を大幅に削減できるようになる。 レイヤスーパータイプを作成する ためには、各マッピングにいくつかのフックルーチンを追加する必要がある。 これによって、 通常はメタデータマッピングの数が大幅に減少する。

メタデータマッピングは、特に自動ツールを使用している場合にリファクタリングを妨げ るときがある。 プライベートフィールドの名前を変更すると、 あるアプリケーションが突然 壊れることがある。 自動リファクタリングツールでも、マッピングの XML データファイル 内に隠ぺいされたフィールド名を検出することはできない。

検索メカニズムによって自動ツールを使用できるため、コードを生成する手間が若干省け る。それでもコードを再生成すると、 必ず自動更新される。 ツールが問題を警告することも あるが、メタデータを変更するかどうかはユーザが決定することである。 リフレクションを 使用すると、 警告が表示されることすらない。

しかし、メタデータマッピングを使用することで容易にデータベースリファクタリングを 行える理由は、メタデータがデータベーススキーマのインタフェースのステートメントとし て機能するからである。 したがって、 メタデータマッピングを変更することで、 データベー スへの変更を行うことができる。

13.1.3 例: メタデータとリフレクションの使用 (Java)

本書の例の多くでは、理解しやすくするため明示的なコードを使用している。 ただし、こ れによってとても単調なプログラミングとなり、また単調なプログラミングということは、 どこかに異常があることを示している。 メタデータを使用することによって、 多くの単調な プログラミングを取り除くことができる。

13.1.3.1 メタデータの保持

メタデータに関して最初に決定することは、メタデータをどのように保持するかというこ とである。ここでは、2つのクラスでメタデータを保持している。 データマッピングとは、1 つのクラスを1つのテーブルにマッピングすることである。これはシンプルなマッピングで あるが、説明する場合には役立つ。

3 30

class DataMap...

private class domainClass;

private String tableName;

private List columnMaps = new ArrayList();

データマッピングは、 テーブル内の列をフィールドにマッピングする列マッピングのコレ クションを含んでいる。

class ColumnMap...

private String columnName; private String fieldName; private Field field; private DataMap dataMap;

これはあまり洗練されたマッピングとは言えない。 私はデフォルトのJava 型マッピング だけを使用しているが、これはフィールドと列の間に型の変換がないことを意味している。 また、テーブルとクラスの関係も1対1に設定している。

上記の構造でマッピングを保持する。 次の決定は、 どのようにしてメタデータを配置する かである。 この例では、 私は Java コー ードを使用して特定の Mapper クラスにメタデータを 配置する。 少し奇妙に思うかもしれないが、 Java コードを使用することでメタデータのメ リットを最大限に活用できる。 たとえば、コードの繰り返しを回避できる。

class PersonMapper...

protected void dataMap = new DataMap (Person.class, "people"); dataMap.addColumn ("lastname", "varchar", "lastName"); dataMap addcolumn ("firstname", "varchar", "firstName"); dataMap.addColumn ("number_of_dependents", "int", "numberOf Dependents");

loadDataMap() {

列のマッパーを構築するときに、私はフィールドへのリンクを構築する。 厳密にいうと、 これは最適化であり、フィールドを計算する必要がない場合がある。 しかし、 最適化するこ とにより、小型のノートパソコンでのその後のアクセスが大幅に削減される。

class ColumnMap...

| オブジェクトリレーショナルメタデータマッピングパターン

public ColumMap (String columnName, String fieldName, DataMap dataMap) { } this.columnName = column Name; this.fieldName = fieldName; this.dataMap dataMap; initField(); private void initField() { try { field = dataMap.getDamainClass() .getDeclaredField (getFieldName()); field.setAccessible(true); } catch (Exception e) { throw new ApplicationException ("unable to set up field: fieldName, e);

XML ファイルから、またはメタデータデータベースからマッピングを読み込ませるため のルーチンを記述する方法を理解することはそれほど難しくはない。 難しくはないが敢えて ここでは省略するので、各自で習得してほしい。

現時点では複数のマッピングが定義されていて、これらのマッピングを使用することがで きる。 メタデータ手法のメリットは、 実際に操作するコードすべてがスーパークラスの中に ある点である。 したがって、 明示的に記述した場合は、マッピングコードを書く必要はない。

13.1.3.2 ID による検索

ID メソッドによる検索から始める。

class Mapper...

public Object findObject (Long key) { if (wow.isLoaded (key)) return uow.getObject (key); String sql = "SELECT + dataMap.columnList() + " FROM dataMap.getTableName () + " WHERE ID = ?"; PreparedStatement stmt = null; ResultSet rs = null; DomainObject result = null; try{ stmt = DB.prepare (sql);

stmt.setLong (1, key.longValue());

3 3 2

rs = stmt.executeQuery();

rs.next();

result load (rs);

} catch (Exception e) (throw new ApplicationException (e);

} finally (DB.cleanUp (stmt, rs);

}

return result;

private UnitOfWork uow;

protected DataMap dataMap;

class DataMap...

public String columnList() { StringBuffer result = new StringBuffer("ID"); for (Iterator it = columnMaps.iterator(); it.hasNext(); ) { result.append(","); ColumnMap columnMap = (ColumnMap) it.next(); result.append(columnMap.getColumnName());

}

return result.toString();

public String getTableName() (

return tableName;

}

ここでの select は他の例よりも動的に構築されているが、 このようにデータベースセッ ションが select を適切にキャッシュ内に格納できるようにしておくことは有効である。 必 要な場合には、データマッピングの存続期間中に列を更新する呼び出しがないため、 構築中 に列リストを計算してキャッシュに格納することができる。 この例の場合、 データベース セッションを処理するためにユニットオブワークを使用している。

本書の例に共通することであるが、 私は読み出しと検索を分離している。 したがって、 同 じloadメソッドを使用して別のfindメソッドから検索できる。

class Mapper...

public DomainObject load (ResultSet rs) ( throws InstantiationException, IllegalAccessException, SQLException Long key new Long (rs.getLong ("ID")); if (uow.isLoaded (key)) return uow.getObject (key); DomainObject result = (DomainObject)

}

オブジェクトリレー

} dataMap.getDomainClass() .newInstance(); result.setID (key); uow.registerClean (result); loadFields (rs, result); return result; private void loadFields (ResultSet rs, DomainObject result) throws SQLException { for (Iterator it = dataMap.getColumns (); it.hasNext();) ColumnMap columnMap = (ColumnMap) it.next(); Object columnValue = rs.getObject (columnMap.getColumn Name()columnMap.setField(result, columnValue);

ナルメタデータマッピングバタ

(

class ColumnMap...

);

public void setField (Object result, Object column Value) { try { field.set(result, columnValue); } catch (Exception e) { throw new ApplicationException "Error in setting" + fieldName, e); })

これは典型的なリフレクティブプログラムである。 個々の列マッピングを介し、その列 マッピングを使用して、ドメインオブジェクト内のフィールドを読み込む。 loadFields メ ソッドを分離して、 拡張性のあるより複雑なケースにする方法を紹介する。 メタデータを保 持しないクラスとテーブルがあると単純に仮定した場合、 サブクラスマッパー内の loadFields をオーバーライドするだけで、任意に複雑なコード内に置くことができる。 こ れはメタデータを使用した一般的な技法である。 変則的なケースではフックを使用してオー バーライドする。 通常、サブクラスを使用して変則的なケースをオーバーライドする方が、 少数の稀なケースに適用される洗練されたメタデータを構築するより容易である。

もちろん、サブクラスがある場合は、サブクラスを使用してダウンキャストを回避したほ うが賢明である。

class PersonMapper...

public Person find (Long key) { return (Person) findObject (key); )

3 3 4

13.1.3.3 データベースへの書き込み

更新には、1つの更新ルーチンを使用する。

class Mapper...

public void update (DomainObject obj) ( } String sql = "UPDATE " + dataMap.getTableName() + dataMap.updateList() + "WHERE ID = ?"; PreparedStatement stmt = null; try ( stmt =DB.prepare (sql); int argCount = 1; for (Iterator it = dataMap.getColumns(); it.hasNext(); ) { ColumnMap col = (ColumnMap) it.next(); } stmt.setObject (argCount++, col.getValue(obj)); stmt.setLong (argCount, obj.getID().longValue()); stmt.executeUpdate(); } catch (SQLException e) (throw new ApplicationException (e); } finally (DB.clean Up (stmt); }

class DataMap...

public String updateList() { StringBuffer result = new StringBuffer(" SET "); for (Iterator it = columnMaps.iterator(); it.hasNext(); ) { ColumnMap columnMap = (ColumnMap) it.next(); result.append(columnMap.getColumnName()); result.append("=?, ");

result.setLength (result.length() - 1);

return result.toString();

public Iterator getColumns() {

return Collections.unmodifiableCollection (columnMaps) .iterator();

}

}

}

class ColumnMap...

public Object getValue (Object subject) ( try (

第1章 オブジェク

return field.get(subject); } catch (Exception e) { } throw new ApplicationException (e);

挿入には、同様のスキームを使用する。

class Mapper...

データマッピングパターン

public Long insert (DomainObject obj) { String sql = "INSERT INTO " + dataMap.getTableName() + VALUES (? + dataMap.insertList () + ")"; PreparedStatement stmt = null; try ( stmt = DB.prepare (sql); stmt.setObject(1, obj.getID()); int argCount = 2; for (Iterator it = dataMap.getColumns(); it.hasNext(); ) { ColumnMap col = (ColumnMap) it.next(); } stmt.setObject (argCount++, col.getValue(obj)); stmt.executeUpdate(); } catch (SQLException e) {throw new ApplicationException (e); } finally (DB.cleanUp (stmt); } return obj.getID();

class DataMap...

}

public String insert List() { StringBuffer result = new StringBuffer(); for (int i=0; i<columnMaps.size(); i++) { ) result.append(", "); result.append("?"); return result.toString();

13.1.3.4 複数のオブジェクトの検索

1つのクエリーを発行して複数のオブジェクトを取得するための手法がいくつかある。 汎

3 3 6

用マッパー上で汎用クエリー機能が必要な場合、 SQL の where句を引数とするクエリーを 発行することができる。

class Mapper...

public Set findObjects Where (String whereClause) ( String sql = "SELECT" + dataMap.columnList() + "FROM " +

dataMap.getTableName() + "WHERE + whereClause;

PreparedStatement stmt = null;

ResultSet rs = null;

Set result = new HashSet(); try (

stmt =DB.prepare(sql);

rs stmt.executeQuery(); result loadAll (rs);

} catch (Exception e) {

throw new ApplicationException (e);

} finally (DB.cleanUp (stmt, rs);

return result;

public Set loadAll (ResultSet rs) throws SQLException, InstantiationException, IllegalAccessException { Set result = new HashSet(); while (rs.next()) { DomainObject newObj = (DomainObject) dataMap.getDomainClass () .newInstance(); newObj = load (rs); result.add(newObj); } return result;

別の方法として、マッパーサブタイプ上で特定のケースのfindメソッドを使用すること もできる。

class PersonMapper...

public Set findLast Names Like (String pattern) String sql = "SELECT" +dataMap.columnList() + " FROM +dataMap.getTableName() +

(

}

}

WHERE UPPER (lastName) LIKE UPPER (?)"; PreparedStatement stmt = null; ResultSet rs = null; try{ stmt = DB.prepare(sql); stmt.setString(1, pattern); rs = stmt.executeQuery(); return loadAll(rs); } catch (Exception e) { throw new ApplicationException (} finally {DB.cleanUp(stmt, rs); }

ラッピングパターン

e);

さらに一般的な選択肢として、 クエリーオブジェクトがある。

つまり、メタデータ手法の大きなメリットは、 loadMap メソッドといくつかの特化され たfind メソッドを追加することで、 データマッピングに新しいテーブルとクラスを追加で きることである。

13.2 クエリーオブジェクト

データベースクエリーとして機能するオブジェクト。

Criteria operator="> field="numberOfDependents | value = 0 Query Criteria operator= field="lastName" value = "fowler"

SQL は複雑な言語になることがあるため、 SQL に習熟している開発者は多くない。さら に、クエリーを形成するためにはデータベーススキーマの構造を知っている必要がある。 バ ラメータ化されたメソッド内部にSQLを隠ぺいする特化されたfindメソッドを作成するこ とによって、 SQL を使用しないこともできるが、その場合には、 よりアドホックなクエ リーを作成することは難しい。 また、 データベーススキーマを変更する場合、 SQL 文内で

338

重複してしまうこともある。

クエリーオブジェクトはインタプリタプログラム [Gang of Four]である。 つまり、クエ リーオブジェクト自体がSQLクエリーとして機能することのできるオブジェクト構造に なっている。 テーブルと列ではなく、 クラスとフィールドを参照することによってSQLク エリーを作成することができる。 上記のとおり、クエリーの作成者はデータベーススキーマ に関わる必要がなく、 スキーマへの変更を1箇所に格納することができる。

13.2.1 動作方法

クエリーオブジェクトとはインタプリタパターンのアプリケーションであり、SQLクエ リーとして機能する。 クエリーオブジェクトの第一の役割は、クライアントがさまざまな種 類のクエリーを作成し、そのオブジェクト構造を適切な SQL 文字列に変換できるようにす ることである。

クエリーとして機能するためには、柔軟性のあるクエリーオブジェクトが必要である。し かし、多くの場合、 アプリケーションはSQL のすべての機能よりもはるかに少ない機能を 使用して動作している。 この場合には、クエリーオブジェクトはよりシンプルになる。 シン プルになったクエリーオブジェクトがすべての機能を実行できるわけではないが、特定の ニーズを満たすことはできる。 さらに、 通常、 最初から完全な機能を持つクエリーオブジェ クトを作成するより、 追加機能が必要になったときに拡張する方が作業負荷が少ない。 結果 として、現在必要な最低限の機能を持つクエリーオブジェクトを作成し、必要に応じて拡張 するべきである。

クエリーオブジェクトの一般的な機能は、 データベーススキーマではなくメモリ上のオブ ジェクトの言語で、 クエリーを表現できることである。 つまり、テーブル名や列名を使用せ ずに、オブジェクト名とフィールド名を使用できる。 オブジェクトとデータベースが同じ構 造かどうかは重要ではないが、この2つがさまざまな方法で組み合わされているときにはと ても役に立つ場合がある。 ビューをこのように変更するためには、クエリーオブジェクトは、 どのようにしてデータベース構造をオブジェクト構造にマッピングするか、すなわち実際に メタデータマッピングを必要としている機能を知る必要がある。

複数のデータベースの場合、 クエリーが動作しているデータベースに応じて、異なった SQL を生成するようにクエリーオブジェクトを設計できる。 最もシンプルなレベルでも、 クエリーオブジェクトは SQL 構文の面倒な相違を考慮できる。 大規模なレベルでは、クエ リーオブジェクトは多様なマッピングを使用して、異なるデータベーススキームに格納され た同じクラスを処理することができる。

クエリーオブジェクトの特に洗練された使用法は、データベースに対する重視したクエ リーを取り除くことである。 セッションの初期に同じクエリーを発行したことがわかる場合、

そのクエリーを使用して一意マッピングからオブジェクトを選択してデータベースへの移行 を回避できる。 洗練された手法では、あるクエリーが以前のクエリーの特定のケースかどう かを検出できる。 以前のクエリーとは、たとえば以前と同一だが、 AND と連結した句が追 加されたようなクエリーである。

オブジェクトリレーショ

この洗練された機能を実現する正確な方法は本書の内容の範囲を超えているが、 O/R マッピングツールがこの種類の機能を提供している。

クエリーオブジェクトは、ドメインオブジェクトの例によってクエリーを特定することが できる。 したがって、 Person オブジェクトの姓はFowler と設定され、その他のすべての 属性は null (設定なし) に設定されている場合もある。 インタプリタ型クエリーオブジェク トのような処理を行ったサンプルによって、 Person オブジェクトをクエリーとして動作さ せることができるようになる。 これによって、 データベース内で姓がFowler というすべて の Person が返される。 この方法はとてもシンプルで使用しやすいが、 複雑なクエリーは使 用できない。

1322 使用するタイミング

クエリーオブジェクトは連結が必要な洗練されたパターンであるため、 手動で作成した データソースレイヤがある場合、 ほとんどのプロジェクトでは使用しない。 ドメインモデル やデータマッパーを使っている場合にだけクエリーオブジェクトが必要になり、さらにクエ リーオブジェクトを正しく使用するためにはメタデータマッピングも必要になる。

その場合でも、開発者がSQL に慣れていればクエリーオブジェクトは必ずしも必要では ない。 特化されたfind メソッドの裏側にデータベーススキーマの詳細を隠ぺいできる。

クエリーオブジェクトのメリットによって、 カプセル化されたデータベーススキーマの保 持、複数のデータベースのサポート、 複数のスキーマのサポート、 および重複したクエリー を回避するための最適化などの、より洗練されたニーズに対応できる。 特に洗練されたデー タソースチームとのプロジェクトでは、独自にこれらの機能を作成することを望むこともあ る。 しかし、商用のツールによってクエリーオブジェクトを使用する場合が多い。 私は、 ツールの購入にはそれなりの価値が常にあると思っている。

ここまで読み進んだ読者は、限定された機能しかないクエリーオブジェクトでも十分に ニーズを満たすことができ、機能満載のバージョンを必要としないプロジェクトなら難なく 構築できることに気付くだろう。 実際に使用しない機能を外すことが秘訣である。

1323 | 参考文献

インタプリタの解説としては、 [Alpert et al.jに記載されているクエリーオブジェクトの

ルメタデータマッピングバター

340

サンプルを挙げることができる。 またクエリーオブジェクトは、 [Evans and Fowler]や [Evans] の仕様パターンと密接に関連している。

13.2.4 例: シンプルなクエリーオブジェクト (Java)

クエリーオブジェクトのシンプルな例である。 実用的なレベルとは言えないが、クエリー オブジェクトの概要を理解するには十分である。 「AND'ed」 (やや専門的な言語であり、初 歩的な部の連結処理を実行する) で連結された一連の判断基準に従って、1つのテーブル にクエリーを発行できる。

クエリーオブジェクトは、テーブル構造の言語ではなく、ドメインオブジェクトの言語を 使って作成される。 したがって、クエリーは、そのクエリーを発行するクラス、および複数 の where 句に対応する判断基準のコレクションを把握している。

class QueryObject...

private Class klass; private List criteria = new ArrayList();

シンプルな判断基準はフィールド、 値、

および SQL 演算子を取得し、これらを比較する。

class Criteria...

private String sqlOperator; protected String field; protected Object value;

的確な判断基準を容易に作成できるように、適切な作成メソッドを提供しよう。

class Criteria...

public static Criteria greaterThan (String fieldName, int value) { return Criteria.greater Than (fieldName, new Integer(value)); }

public static Criteria greaterThan (String fieldName, Object value) { return new Criteria (">", fieldName, value);

private Criteria (String sql, String field, Object value ){ this.sqlOperator= sql; this.field = field;

}

this.value = value;

以下のようなクエリーを作成し、扶養家族を持つすべてのPerson を検索できる。

class Criteria...

QueryObject query = new QueryObject (Person.class); query.addCriteria(Criteria.greater Than ("numberOf Dependents

", 0));

したがって、私が使用する Person オブジェクトは、以下のとおりである。

class Person...

private String lastName; private String firstName; private int numberOf Dependents;

扶養家族を持つ Person を検索するには、 Person を検索するクエリーを作成して、ある 判断基準を加える。

QueryObject query = new QueryObject (Person.class); query.addCriteria (Criteria.greater Than ("numberOf Dependents", 0));

クエリーを記述するにはこれで十分である。 次にクエリーをSQL の select 文に変換して 実行する必要がある。 この場合、 Mapper クラスが、 where 句の文字列に基づいてオブ ジェクトを検索するメソッドをサポートすると仮定する。

class QueryObject...

public Set execute (Unit OfWork uow) {

this.uow=uow; return uow.getMapper (klass) .findObjectswhere (generatehereClause());

class Mapper...

public Set findObjects Where (String whereClause) { String sql = "SELECT" + dataMap.columnList() + " FROM. dataMap.getTableName() + WHERE " + whereClause;

342

PreparedStatement stmt = null; ResultSet rs = null; Set result = new HashSet(); try { stmt =DB.prepare (sql); rs stmt.executeQuery(); result loadAll(rs); } catch (Exception e) { throw new ApplicationException (e); ) finally (DB.cleanUp (stmt, rs); } return result;

}

クラスによってインデックス付けされたマッパーを保持するユニットオブワークと、 メタ データマッピングを使うマッパーを使っている。 コードは、本項で同じコードの繰り返しを 省略するためのメタデータマッピングの例と同じものである。

where 句を生成するには、クエリーが判断基準全体を繰り返して各クエリーを出力した 後 AND と結合して使う。

class QueryObject...

private String generateWhereClause() { StringBuffer result = new StringBuffer(); for (Iterator it = criteria.iterator(); it.hasNext(); ) { } Criteria c = (Criteria) it.next(); if (result.length() != 0) result.append(" AND "); result.append(c.generateSql (uow.getMapper (klass).getDataMap())); return result.toString();

class Criteria...

public String generateSql (DataMap dataMap) ( ) return dataMap.getColumnForField(field) + sqlOperator + value;

class DataMap...

public String getColumnFor Field (String fieldName) (

for (Iterator it = getColumns(); it.hasNext(); ) {

オブジェクトリレーショナルメタデータマッピングパターン

ColumnMap columnMap = (ColumnMap) it.next();

if (columnMap.getFieldName().equals (fieldName)) return columnMap.getColumnName();

throw new ApplicationException ("Unable to find column for ⚫ + fieldName);

}

シンプルなSQL 演算子を持つ判断基準と同様に、多くのことを実行する複雑な判断基準 クラスを作成することができる。 たとえば、 姓がFで始まる Person を検索するような大文 字と小文字を区別しないパターンマッチクエリーがあるとする。 Fで始まる姓を持つ扶養家 族がいる Person を対象としたクエリーオブジェクトを作成することができる。

QueryObject query = new QueryObject (Person.class); query.addCriteria (Criteria.greater Than ("numberOf Dependents", 0)); query.addCriteria (Criteria.matches("lastName", "f%"));

where 文でより複雑な句を作成する Criteria クラスを使う。

class Criteria...

public static Criteria matches (String fieldName, String pattern) { } return new MatchCriteria (fieldName, pattern);

class MatchCriteria extends Criteria...

public String generateSql (DataMap dataMap) { return "UPPER ( +dataMap.getColumnForField(field). + ") LIKE UPPER (+ value + "')"; }

}

344

13.3 リポジトリ

(by Edward Hieatt, Rob Mee).

ドメインオブジェクトにアクセスするためのコレクション型インタフェースを使って、 ドメインとデータマッピングレイヤとを仲介する。

client new Criteria equal (this, BENEFACTOR) matching (Criteria) repository in memory strategy Person | matching (Criteria) satisfies (Criteria) people who satisfied the criteria

複雑なドメインモデルを持つシステムは、データマッパーのレイヤなどから複数のメリッ トを得る場合が多い。 この場合、 データマッパーは、ドメインオブジェクトをデータベース アクセスコードから分離する。 このようなシステムでクエリーを構成するコードが、 集中し ているマッピングレイヤ上に別の抽象レイヤを構築する。 この構築が重要なのは、 多くのド メインクラスや複雑なクエリーがある場合である。 特に抽象レイヤの追加時には、同じクエ リーロジックの繰り返しを最小限に抑えることに役立つ

リポジトリは、ドメインとデータマッピングレイヤの仲介をし、 メモリ上のドメインオブ ジェクトコレクションの役割を果たす。 クライアントオブジェクトは、 宣言型でクエリーの 仕様を構築し、仕様を満たすためリポジトリに送る。 オブジェクトは、シンプルなオブジェ クトコレクションから削除できるのと同様に、 リポジトリに追加することも削除することも できる。また、リポジトリによってカプセル化されたマッピングコードは裏側で操作を行う。 理論上リポジトリは、データストアにある一連のオブジェクトおよびオブジェクト上で実行 された操作をカプセル化し、 永続的なレイヤよりオブジェクト指向の強いビューを提供する。

リポジトリは、明確な目的の分離も、 ドメインとデータマッピングレイヤ間での一方向の依 存性もサポートしている。

13.3.1 | 動作方法

リポジトリは、本書に記述されている他のパターンを使うことのできる洗練されたパター ンの1つである。 リポジトリは、オブジェクト指向データベースの一部のように思われてい て、その意味ではクエリーオブジェクトに類似している。 開発チームは、 オブジェクトリ レーショナルマッピングツールでクエリーオブジェクトを見つける方が、 独自に作成するよ りも多い。ただし、すでにチームがクエリーオブジェクトを作成済みである場合、 リポジト リ機能を追加するのは容易である。 クエリーオブジェクトと連結して使うと、 リポジトリに よってあまり労力を使うことなく、 オブジェクトリレーショナルマッピングレイヤが大幅に 使いやすくなる。

裏側での処理だが、 リポジトリはシンプルなインタフェースとして機能し、 クライアントは、 クエリーから返したいオブジェクトの特性を指定する Criteria (判断基準) オブジェクトを作 成する。 たとえば、 Person オブジェクトを名前で検索するには、 まずCriteria オブジェクト を作成して、個別の判断基準を設定する。 criteria.equals (Person.LAST_NAME, "Fowler")、 および criteria.like (Person.FIRST_NAME, "M" )、 次に repository.matching (criteria) を呼び出して、 姓が Fowler で名がM で始まる Person を示すドメインオブジェクトのリス トを返す。 matching (criteria) に類似した便利なメソッド類を抽象リポジトリで定義でき る。たとえば、一致するものが1つだけ予想される場合、 soleMatch (criteria) は、 コレク シションではなく検索条件に適合したオブジェクトを返すことがある。 他の共通のメソッドには、 soleMatch を使って簡単に実装できる byObjectId(id)が含まれている

リポジトリを使うコードは、シンプルなドメインオブジェクトのメモリ上のコレクション で表示される。 リポジトリ内に直接格納されていないドメインオブジェクトは、クライアン トコードからは見ることができない。 もちろん、 リポジトリを使うコードを認識しておく必 要があるのは、 可視的なオブジェクトコレクションが、 数十万ものレコードを持つProduct テーブルにマッピングされることが十分考えられるからである。 カタログシステムの ProductRepository上でall() を呼び出すことはあまり勧められない。

リポジトリは、データマッパークラス上の特化された find メソッドを、 オブジェクトセ レクション [Evans and Fowler] の仕様ベースの手法に置き換える。 クエリーオブジェクト を直接使う方法と比較すると、 クエリーオブジェクトではクライアントコードが Criteria オ ブジェクト (仕様パターンの簡単な例)を作成し、クエリーオブジェクトに直接add() を実 行しクエリーを発行する。 リポジトリでは、クライアントコードが判断基準を作成してリボ ジトリに渡し、一致するオブジェクトの判断基準を選択するように要求する。 クライアント

ルメタデータマッピングパターン

3 4 6

コードの観点から見ると、クエリーの「発行」という考えはない。むしろ、クエリーの仕様 を 「満たす」ことでオブジェクトの選択を行う。 この違いが、 リポジトリとオブジェクトと の相互作用を明示しているのである。理論上では、この処理がリポジトリのほぼすべての機 能なのである。

隠れた所でリポジトリは、メタデータマッピングとクエリーオブジェクトを組み合わせて、 自動的にその判断基準でSQL コードを生成する。 判断基準がクエリーへの追加方法を知っ ているかどうか、 クエリーオブジェクトがCriteria オブジェクトを組み込む方法を知ってい るかどうか、またはメタデータマッピング自体が相互作用を制御するかどうかということが、 実装時の詳細項目となる。

リポジトリのオブジェクトソースは、決してリレーショナルデータベースではない。 これ は、特化したストラテジーオブジェクトを介したデータマッピングコンポーネントの再配置 にとても役立つ。したがって、 リポジトリは、複数のデータベーススキーマやドメインオブ ジェクトのソースを持つシステムで特に有効であり、 メモリ上のオブジェクトを使う速度の 最適化のテスト時においても有効である。

リポジトリは、広範囲にクエリーを発行するコードであり、読みやすく分かりやすい優れ たメカニズムである。 たとえば、 多くのクエリーページを表示する機能があるブラウザー ベースのシステムで、 HttpRequest オブジェクトを処理してクエリー結果を表示するには、 明確なメカニズムが必要になる。 リクエストに対するハンドラコードは、自動ではなくても HttpRequest を Criteria オブジェクトに容易に変換できる。 判断基準をリポジトリに送る ために必要なのは、 1、2箇所に行を追加するだけである。

13.3.2 使用するタイミング

多くのドメインオブジェクトタイプとクエリーを持つ大規模システムでリポジトリは、実 行中のすべてのクエリーを処理する必要なコードの数を削減し仕様パターンを促進する (本 書の例にある Criteria オブジェクトの形式において)。 パターンはクエリーをカプセル化し て、純粋なオブジェクト指向で動作する。 特定のケースでは、クエリーオブジェクトを設定 するコードを削除できる。 クライアントは、SQLを考える必要は一切なく純粋にオブジェ クト指向で記述する。

複数のデータソースの環境では、 リポジトリを使うことになる。 たとえばパフォーマンス 向上のためにメモリ上で一連のユニットテストを実行したいために、シンプルなメモリ上の データ格納を使いたくなる場合がある。 データベースアクセスがない場合、 長時間にわたる 一連のテストの速度は、格段に速くなる。 ドメインオブジェクトを作成してそれをコレク ションの中に挿入する方法の方が、 ドメインオブジェクトをセットアップ内のデータベース に保存し、取り除くよりもユニットテストを容易に作成できる。

また、アプリケーションが正常に稼動しているとき、 常に任意のドメインオブジェクトが メモリ内にある点も考えるべきである。 このような例は、不変なドメインオブジェクト (ユーザが変更できない)で、ドメインオブジェクトが一度メモリ内に格納されると、その 状態を保持される必要があり、 再度クエリーは実行されない。 本章で後述するが、 リポジト リバターンへのシンプルな拡張によって、状況に応じて異なるクエリーストラテジーを取り 入れることもある。

また、リポジトリが有用な例として、 データフィードがドメインオブジェクトのソースと して使われている場合が挙げられる。 たとえば、 SOAP を使ってインターネットを介した XML ストリームをソースとして取り入れる場合や、フィードから読み込み、XML からド メインオブジェクトを作成する XMLFeedRepositoryStrategy を実装する時である。

ッピングパターン

13.3.3 参考文献

仕様パターンについては、まだ推奨できる参考書はない。 ここまで記述した中で、 出版物 として最良のものが [Evans and Fowler] である。 また、 [Evans] の中に優れた解説を見つ けることができる。

13.3.4 例: Person が持つ扶養家族の検索 (

Java)

クライアントオブジェクトの観点からすると、 リポジトリは簡単に使うことができる。 データベースから扶養家族を検索するには、 Person オブジェクトに一致させたい検索基準 を表す Criteria オブジェクトを作成し、 Criteria オブジェクトをリポジトリに送る。

public class Person { public List dependents(){ Repository repository = Registry.personRepository(); Criteria criteria = new Criteria(); criteria.equal (Person. BENEFACTOR, this); return repository.matching (criteria); }

共通のクエリーを、リポジトリに特化したサブクラスに格納する。 前の例では、リポジト リのサブクラス PersonRepository を作成し、 リポジトリ自体に検索基準の作成を移行した。

public class PersonRepository extends Repository ( public List list dependentsof (Person aPerson) (

348

Criteria criteria = new Criteria (); criteria.equal (Person. BENEFACTOR, aPerson); return matching (criteria);

)

次に Person オブジェクトは、 dependents () メソッドを直接リポジトリ上に呼び出す。

public class Person ( public List dependents() { ) return Registry.personRepository() .dependentsof (this);

13.3.5 例: リポジトリストラテジーのスワッピング (Java)

リポジトリのインタフェースは、ドメインレイヤをデータソースから隠ぺいするため、 ク ライアントからの呼び出しを変更せずにリポジトリ内部のクエリーコードの実装をリファク タリングできる。 ドメインコードは、ドメインオブジェクトのソースや送信先に関係しない。 メモリ上に格納する場合、 matching() メソッドを変更してドメインオブジェクトコレク ションの中から判断基準を満たすものを選択する。 ただし、 使うデータ格納を随時変更する のではなく、 データ格納間のスワッピングが自在にできることに魅力がある。 したがって、 クエリーを発行するストラテジーオブジェクトに委譲する matching() メソッドの実装を変 更する必要がある。 もちろんメリットは、 複数のストラテジーを持ち必要に応じてストラテ ジーを決定できるという点にある。 この場合、 次の2つのストラテジーを持つことをすすめ る。 RelationalStrategy は、 データベースにクエリーを発行し、 InMemoryStrategy は、 ドメインオブジェクトのメモリ上のコレクションにクエリーを発行する。 いずれのストラテ ジーも RepositoryStrategy インタフェースを実装し、 matching () メソッドを公開する。 したがって、 次のようにリポジトリクラスになる。

abstract class Repository ( private RepositoryStrategy strategy; protected List matching (Criteria aCriteria) ( return strategy.matching (aCriteria); )

RelationalStrategy は、 判断基準からクエリーオブジェクトを作成し、データベースに

クエリーを発行することによってmatching() メソッドを実装する。 クエリーオブジェクト が判断基準から生成する方法を知っていると仮定して、 判断基準によって定義されるフィー ルドと値を使って設定できる。

public class Relational Strategy implements Repository Strategy ( protected List matching (Criteria criteria) { Query query = new Query (myDomainObjectClass()) query.addCriteria (criteria); return query.execute (unitofwork());

データマッピングパターン

InMemoryStrategy は、ドメインオブジェクトコレクションを繰り返し、 判断基準を満た している場合、それぞれのドメインオブジェクトで判断基準を要求することによって、 matching() メソッドを実装する。 判断基準は、ドメインオブジェクトに特定のフィールド の値を問い合わせ、リフレクションを使って要求を満たすコードを実装する。 以下に、この 選択を行うためのコードを示す。

public class InMemory Strategy implements Repository Strategy { private Set domainObjects; protected List matching (Criteria criteria) { List results = new ArrayList(); Iterator it = domainObjects.iterator(); while (it.hasNext()) { DomainObject each = (DomainObject) it.next(); if (criteria.isSatisfiedBy (each)) results.add(each); return results;

350

Webプレゼンテーションパターン

14.1 モデルビューコントローラ

ユーザインタフェースの相互作用を3つの明確な役割へ分割する。

View Model Controller

モデルビューコントローラ (MVC: Model View Controller) は、頻繁に引用される(そ れと同時に誤った引用も行われる) パターンである。 1970年代後半、 Trygve Reenskaug によって Smalltalk プラットフォーム向けに開発されたフレームワークとしてスタートし た。その後UI フレームワークおよびUI設計思想に重要な役割を果たしてきた。

14.1.1 動作方法

MVC には、それぞれの役割を持つ3つの要素がある。 その要素とはモデル、ビュー、 そ してコントローラである。 モデルは、ドメインについて何らかの情報を表すオブジェクトで ある。これはデータや振る舞いを収納する非ビジュアル的なオブジェクトで、 UIには使わ れない。 ドメインモデルの中のオブジェクトは、このモデルの最もオブジェクト指向的な形

14

章

態である。 また、もしUIの機構を含まなければ、トランザクションスクリプトをこのモデ ルと見なすこともできる。 このような定義はモデルの概念を拡げてしまうが、 MVC の内容 を表すには適している。

ビューはUIの中でモデルを表現する。 ユーザオブジェクトのモデルであれば、その ビューはUI ウィジェットでいっぱいのフレームか、 モデルからの情報を載せた HTML ページとなる。 ビューは情報の表示にだけ関わる。 情報の変更を扱うのは、 MVC の第3の 要素であるコントローラである。 コントローラはユーザ入力を受け取り、 モデルを操作し、 ビューを適切に更新する。 このように、UIはビューとコントローラのコンビネーションに よって成り立つのである。

MVC を考えるとき、 そこには根本的に異なる2種類の分離がある。 モデルからのプレゼ ンテーションの分離と、 ビューからのコントローラの分離である。

まず、モデルからのプレゼンテーションの分離であるが、優れたソフトウェア設計におけ る基本的な経験則の1つである。この分離が重要なのは、次のとおりである。

■基本的にプレゼンテーションおよびモデルは、 利害関係が異なっている。 ビューの開発を行う場合、 UI の機構と優れたインタフェースのレイアウト方法 を考えるが、一方、モデルを操作する場合、 ビジネスポリシーについて、 特に データベースとの相互作用について考えることになる。 どちらか一方を操作す る場合には、まったく異なるライブラリを使う。 2つの領域がある場合、 設計者 はどちらか一方を選択し専属的に扱うことが多い。

状況によっては、同一の基本的なモデル情報を別の角度から見る場合もある。 プレゼンテーションとビューを分離することで、 複数のプレゼンテーション (実際にまったく別物のインタフェース) の開発が可能となる一方、引き続き同 じモデルコードを使うこともできる。 顕著なメリットある構築として、 リッチ クラアイント、 Web ブラウザー、 リモート API、 コマンドラインインタフェー スを備えた同一モデルを提供することができる。 単独の Web インタフェース内 部でも、アプリケーションのさまざまなポイントに異なる顧客ページを持つこ ともできる。

■非ビジュアルなオブジェクトは、通常ビジュアルなオブジェクトよりもテスト が容易である。 プレゼンテーションとモデルを分離することで、面倒なGUI ス クリプティングツールの手段に頼ることなくドメインロジックを簡単にテスト できる。

分離におけるキーポイントは、依存の方向である。プレゼンテーションはモデルに依存す

| Webプレゼンテーションパターン

352

るが、モデルはプレゼンテーションに依存することはない。 モデルでプログラミングを行う 場合、 どんなプレゼンテーションが使われているかについては、まったく意識しなくてすむ。 このためタスクが簡単になると同時に、後の新しいプレゼンテーションの追加が容易になる。 モデルを変更することなく自由にプレゼンテーションを変更できるのである。

こうした原則によって、 ある共通の問題が発生する。 複数ウィンドウを持ったリッチクラ イアントインタフェースの場合、 あるモデルの複数のプレゼンテーションが同時に画面上に 表示される可能性が生じる。 したがってユーザが1つのプレゼンテーションからモデルに変 更を加えた場合、 他のプレゼンテーションも同様に変更しなければならない。 依存性を作ら ずにこうした作業を実行するには、 イベント伝播またはリスナーといった「オブザーバー」 パターンの実装 [Gang of Four] が必要となる。 プレゼンテーションは、モデルのオブザー バーとして動作し、 モデルが変化するごとにイベントが送信され情報を更新する。

もう1つのエリアであるビューとコントローラの分離だが、こちらの重要度はやや低めで ある。 皮肉なことだが、 Smalltalk のほとんどのバージョンでビューとコントローラは、分離 されていない。 両者を分離したいと考える最も一般的な例は、編集可能な振る舞いと編集不 可能な振る舞いのサポートである。この2つのケースに対して、1つのビューと2つのコン トローラで対応できる (ここではコントローラが、ビューに対するストラテジーとして機能 する [Gang of Four])。 しかし、 ほとんどのシステムで、ビューごとに1つのコントローラレ か用意されず、その分離も通常は行われていない。 この方法が再び脚光を浴びるようになっ たのは、コントローラとビューの分離が有効な Web インタフェースの登場によってである。

GUI フレームワークは、ビューとコントローラを組み合わせているために、 MVC は誤っ て引用されることが多かった。 モデルおよびビューは明白だが、コントローラはどこにある のか。一般的に、モデルとビューの間にある (アプリケーションコントローラ) と考えられ ているが、それではなぜ「コントローラ」 という言葉が2つの場所で使われているのか。 ア プリケーションコントローラのメリットがどのようなものでも、 MVC コントローラとは まったく異質のものである。

このパターンセットの目的を理解するために、原則は必ず知っておくべきである。 MVC を深く掘り下げて知りたい場合に最も役立つ参考書は、 [POSA] である。

14.1.2 使用するタイミング

すでに述べたように、 MVC の特長は2種類の分離にある。プレゼンテーションとモデル の分離は、ソフトウェアの設計における最も重要な原則の一つである。 唯一の例外は、モデ ルが振る舞いを持たないようなとてもシンプルなシステムの場合である。 非ビジュアルなロ ジックなら、すぐに分離すべきである。 残念なことに、多くのUIフレームワークでは、その 実行は困難で、そうでないフレームワークは分離しないように教えられることが多い。

ビューとコントローラの分離は、比較的重要ではなく、 必要なときにだけ分離を実践する ことを推奨する。 リッチクライアントシステムの場合、分離はほとんどないが、 コントロー ラが分離されている Web フロントエンドにおいて分離は珍しいことではない。 ここに示す Web 設計のパターンは、こうした原則をベースとしている。

14.2 ページコントローラ

特定のページに対するリクエストや Web サイト上のアクションを扱うオブジェクト。

PageController -handle HTTP get and post |- decide which model and view to use Model - domain logic View display HTML

多くの人にとって基本的な Web 環境とは、 静的な HTML ページである。 静的HTML をリクエストする場合、 Web サーバに対して、 リクエスト先に保存されている HTML 文 書の名前とバスを渡す。 つまり Web サイトの各ページは、サーバ上では独立した文書であ るという考え方である。 動的ページの場合、パス名と対応するファイルの間には、複雑な関 があるため、より興味深い。 しかし、リクエストを扱う1つのファイルにアクセスするた めに1つのパスを使うという手法は、 シンプルなモデルなのでわかり易い。

その結果、ページコントローラは、Web サイトの論理ページごとに1つの入力コント ローラを持つ。 コントローラは、サーバページ環境に置かれることが多いために、ページ自 体であるだけでなく、ページに対応する独立したオブジェクトの場合もある。

14.21 | 動作方法

ページコントローラの背後にある基本的な考え方とは、Webサーバ上の1つのモジュー ルを、Webサイト上の各ページのコントローラとして機能させることである。 正確にペー ジごとに1つのモジュールというわけにはいかない。 リンクをクリックすると、動的な情報 に応じてさまざまなページが表示されることがあるからである。 厳密には、コントローラは、 リンクやボタンをクリックするそれぞれのアクションと結び付いている。

ページコントローラは、スクリプト (CGI スクリプト、サーブレットなど)として構築す

354

ることも、サーバページ (ASP、PHP、JSP など) として構築することも可能である。 サー バページを利用するとページコントローラとテンプレートビューが同一ファイル内で結合す る。 ページの表示方法がシンプルな場合は問題ないが、 適切なモデルの構築には手間がかか るため、テンプレートビューにとっては良いが、 ページコントローラにとってはそれほど有 用ではない。 しかし、 リクエストからのデータの抽出や表示するビューの決定に関するロ ジックが含まれる場合は、サーバページにおいて難しいスクリプトレットコードとなってし まう可能性がある。

スクリプトレットコードを処理する1つの方法としては、 ヘルパーオブジェクトの利用が 挙げられる。この場合、サーバページが最初に行うのは、ヘルバーページを呼び出してロ ジックを処理することである。 ヘルパーは、オリジナルのサーバページに制御を返すことも、 異なるサーバページへ転送してビューとして機能することも可能である。 その場合サーバ ページはリクエストハンドラとなるが、 コントローラロジックの大部分はヘルパーにある。

別の手法としては、スクリプトをハンドラおよびコントローラにする方法が挙げられる。 Web サーバがスクリプトに制御を渡すと、スクリプトはコントローラの機能を実行し、最終 的に適切なビューへ結果を転送して表示させる。

ページコントローラの基本的な機能は、以下のとおりである。

■URL をデコードし、 フォームデータを抽出してアクションに必要なデータを算 出する。

■データを処理するモデルオブジェクトを作成し実行する。 そして、 HTML リク エストの関連データをモデルへ渡す。 その結果モデルオブジェクトは、HTML リクエストへの関係を持つ必要はなくなる。

■どのビューが結果を表示するかを判断し、 モデル情報を転送する。

ページコントローラは単独のクラスである必要はなく、ヘルパーオブジェクトを実行する ことができる。 複数のハンドラが同じタスクを行わなければならない場合は、 特に有効であ る。ヘルパークラスは、重複する可能性のあるコードの置き場所としても利用できる。

サーバページやスクリプトで何らかのURLを処理できないという理由はない。 コントロー ラロジックをまったく持たないか、もしくはほとんど持たないURLは、わかりやすく修正し やすいシンプルなメカニズムのため、サーバページにとっては簡単な処理対象である。 より複 雑なロジックを持ったURLは、 スクリプトにまかせるのがよい。 私は、すべて同一の方法 (サーバページまたはスクリプト) で処理する方針を持ったチームと交流を持った経験がある。 アプリケーションにおける一貫性というメリットも、スクリプトレットが満載されたサーバ ページやスクリプトを介した大量のシンプルなバスによる弊害により、相殺されてしまう。

第1章 Webプレゼンテーションパターン

14.2.2 使用するタイミング

意思決定のポイントは、ページコントローラとフロントコントローラのどちらを利用する かである。 ページコントローラは一般の作業に適し、 特定の動作が特定のサーバページまた はスクリプトクラスによって処理される構築メカニズムにつながる。 したがって、 トレード オフは、フロントコントローラのメリットとその複雑性をどう評価するかである。 トレード オフの大部分は、Web サイトの案内操作の複雑性の違いとなって現れる。

ページコントローラは、コントローラロジックの大半がとてもシンプルなサイトでは、特 に有用である。 この場合、ほとんどのURLはサーバページによって処理でき、より複雑な ものもヘルパーによって処理できる。 コントローラロジックがシンプルな場合、 フロントコ ントローラは多くのオーバーヘッドを追加する。

一部のリクエストをページコントローラによって処理し、その他はフロントコントローラ によって処理するようなサイトは珍しくない (特に、 開発チームがそれらをリファクタリン グする場合)。これら2つのパターンは、 特に問題なく混在できる。

1423 例: サーブレットコントローラとJSPビューによるシンプルな表示 (Java) ページコントローラのシンプルな例とは、 ある対象に対する情報を表示するというもので ある。ここでは、レコーディング Artist (アーティスト) に関する情報を表示する。 URL は、http://www.thingy.com/recordingApp/artist?name=danielaMercury という行に 含まれている。

ActionServlet ArtistController ArtistHelper Artist.jsp Artist find getName

図 14.1 ページコントローラサーブレットおよび JSPビューによるシンプルな表示方法に関連したクラス

356

Web サーバは、 /artist を ArtistController の呼び出しと認識するように設定してお く。Tomcat では、web.xml ファイルに次のようなコードを記述する。

<servlet> <servlet-name>artist </servlet-name> <servlet-class>actionController.ArtistController</servlet-class> </servlet> <servlet-mapping> <servlet-name>artist </servlet-name> <url-pattern>/artist</url-pattern> </servlet-mapping>

ArtistController は、リクエストを処理するメソッドを実装する。

class ArtistController...

public void doGet (throws IOException, ServletException { Artist artist = Artist.findNamed (request.getParameter("name")); if (artist == null) forward("/MissingArtistError.jsp", request, response); else { request.setAttribute("helper", new ArtistHelper (artist)); forward("/artist.jsp", request, response); }

HttpServletRequest request, HttpServletResponse response)

とてもシンプルな例だが、重要なポイントが含まれている。 まず、 コントローラは、処 理を行う (ここでは表示すべき正しいモデルオブジェクトを見つけ出す) ために必要なモデ ルオブジェクトを作成しなければならない。 次に、 JSP が、 オブジェクトを正しく表示でき るように、 HTTP リクエストに正しい情報を格納する。 例では、 ヘルバーを作成しリクエ ストに格納している。 最後に、テンプレートビューへと転送して、表示の処理を行わせる。 転送は、標準的な振る舞いであるため、 当然ながらページコントローラのスーパークラスに 置かれている。

class ActionServlet...

protected void forward (String target, HttpServletRequest request, HttpServletResponse response)

throws IOException, ServletException

Request Dispatcher dispatcher =

getServletContext().getRequestDispatcher (target);

dispatcher.forward (request, response);

Webプレゼンテーションパターン

}

テンプレートビューとページコントローラを結合するときの重要なポイントは、JSP が必 要とするオブジェクトを渡すリクエストの中のパラメータ名である。

ここに示すコントローラロジックはとてもシンプルだが、より複雑になった場合は、サー ブレットをコントローラとして引き続き利用する。 Album (アルバム) にも同様の振る舞い ができる。 ただし、 ClassicalAlbum (クラシックアルバム) は、 異なるモデルオブジェク トを持ち、他の異なる JSP によって加工される必要があるとする。 この振る舞いを実現す るには、ここでもコントローラクラスを使用する。

class AlbumController...

public void doGet (HttpServletRequest request,

HttpServletResponse response) throws IOException, ServletException

{ Album album = Album.find(request.getParameter("id")); if (album == null) { } forward("/missingAlbumError.jsp", request, response); return; request.setAttribute("helper", album); if (album instanceof ClassicalAlbum) forward("/classicalAlbum.jsp", request, response); else forward("/album.jsp", request, response); }

例では、独立したヘルパークラスを作成する代わりに、 モデルオブジェクトをヘルバーと して利用している点に注目してほしい。 ヘルパークラスがモデルクラスに対し、転送する意 味がないようなコードである場合、こうした方法は効果的である。 ただしその場合、モデル クラスに一切のサーブレット依存コードが含まれないようにする必要がある。 サーブレット 依存コードは、必ず独立したヘルパークラスに置かなければならない。

358

14.2.4 例: JSP をハンドラとして使用する (Java)

サーブレットをコントローラとして利用することは1つの手段ではあるが、最も一般的な 手法は、サーバページ自体をコントローラにすることである。 この手法の問題点は、データ の収集時におけるサーバページの先頭のスクリプトレットコードにある。 同意していただけ ると思うが、優れた設計のソフトウェアに対するスクリプレットコードの位置付けは、純粋 なスポーツに対するプロレスの位置付けに等しいというのが私の考えだ。

それにもかかわらず、コントローラの機能を実際に実行するヘルパーに制御を委譲する一 方で、サーバページをリクエストハンドラにすることは可能である。 そのため、サーバペー ジによって URL を示すというシンプルなプロパティは維持される。 私は、 http://localhost:8080/isa/album.jsp?id=zero 形式のURLを利用して、この方法を Album 表示のために行っている。 Album は、 アルバム JSP によって直接表示されるが、

クラシックレコードの場合、別の表示方法であるクラシックアルバム JSP を必要とする。

コントローラの振る舞いは、 JSP のヘルプクラスにおいて現れる。 ヘルバーは、アルバム JSP 自身に設定されている。

album.jsp...

<jsp:useBean id="helper" class="actionController.AlbumConHelper/> < helper.init(request, response); %>

init の呼び出しは、コントローラの振る舞いを実行するようにヘルパーを設定する。

class AlbumConHelper extends HelperController...

public void init (HttpServletRequest request, HttpServletResponse response) super.init(request, response); if (getAlbum () == null) forward ("missingAlbumError.jsp", request, response); if (getAlbum () instanceof ClassicalAlbum) { request.setAttribute("helper", getAlbum()); forward("/classicalAlbum.jsp", request, response);

(

標準的なヘルパーの振る舞いは、当然ヘルパースーパークラスに置かれている。

class HelperController....

第1章 Webプレゼンテーションパターン

public void init (HttpServletRequest request,

HttpServletResponse response) {

this.request = request;

this.response = response;

}

protected void forward (String target,

HttpServletRequest request,

HttpServletResponse response)

try( RequestDispatcher dispatcher = request.getRequestDispatcher (targetif (dispatcher == null) response.sendError (response.SC_NO_CONTENTelse dispatcher.forward (request, response); } catch (IOException e){ throw new ApplicationException(e); } catch (ServletException e) {

)

ここに示すコントローラの振る舞いと、 サーブレットを使う場合のコントローラの振る舞 いとの大きな違いは、ハンドラ JSP もデフォルトビューであり、 コントローラが別のJSP に転送しない限り、制御はオリジナルのハンドラへと戻る点である。 大抵の場合、 JSP が ビューとして直接機能するため、 転送がほとんど行われないようなページにおいてはこれが 長所となる。 ヘルパーの初期化はあらゆるモデルの振る舞いを開始し、その後のビューの設 定を行う役割を担う。 Web ページは、ビューとして機能するサーバページと関連付けられ るためとてもわかりやすいモデルであり、当然ながら Web サーバのシステム構成とも適合 することが多い。

以下のカスタムタグの実装は、その作業を行うためである。

);

);

throw new ApplicationException(e);

ハンドラを初期化するための呼び出しは、あまりうまくいかない場合がある。 JSP 環境で は、こうした点もカスタムタグによる処理によって大幅に改善される。 タグは自動的に適切 なオブジェクトを作成し、リクエストに収めて初期化する。 そのために必要なのは、JSP ページのシンプルなタグだけである。

<helper: init name="actionController.AlbumConHelper"/>

360

class HelperInitTag extends HelperTag...

private String helperClassName;

public void setName (String helperClassName) ( this.helperClassName = helperClassName;

}

public int doStartTag() throws JspException (

HelperController helper = null;

try {

helper (HelperController) Class.forName (helperClassName).newInstance(); } catch (Exception e) {

throw new ApplicationException ("Unable to instantiate + helperClassName, e);

}

initHelper (helper);

pageContext.setAttribute (HELPER, helper);

return SKIP_BODY;

private void initHelper (HelperController helper) ( HttpServletRequest request = (HttpServletRequest)

pageContext.getRequest();

HttpServletResponse response = (HttpServletResponse)

pageContext.getResponse();

helper.init (request, response);

}

class HelperTag...

public static final String HELPER = "helper";

}

私がカスタムタグを使う場合、 プロパティアクセス用に作成することもある。

class HelperGetTag extends HelperTag... private String propertyName; public void set Property (String propertyName) { } this.propertyName = propertyName; public int doStartTag() throws JspException { try { pageContext.getOut ().print (get Property (propertyName)); } catch (IOException e) { ) throw new JspException ("unable to print to writer");

第1章 Webプレゼンテーションパターン

}

return SKIP_BODY;

class HelperTag... protected Object get Property (String property) throws JspException ( Object helper = getHelper(); try { final Method getter = helper.getClass().getMethod (gettingMethod (property), null); return getter.invoke (helper, null); } catch (Exception e) { throw new JspException ("Unable to invoke " + gettingMethod (property) + " + e.getMessage()); }

private Object getHelper() throws JspException {

Object helper = pageContext.getAttribute (HELPER);

if (helper == null) throw new JspException("Helper not found."); return helper;

}

private String gettingMethod (String property) (

String methodName = "get" + property.substring(0, 1).toUpperCase() + property.substring(1);

return methodName;

(リフレクションを利用してgetメソッドを呼び出すよりも、 Java Bean を使う方がよい と考える人も中にはいるだろうが、それは正しい。 そういう人は、おそらくメソッドをどう 変更すればよいかも心得ているにちがいない)。

取得用のタグを定義して、 ヘルパーの情報を抽出するのに使うこともできる。 タグのほう が短くて済み、 「helper」 という綴りを間違うことも減る。

<B> < helper get property = "title"/> </B>

14.25 例:裏側にコードを持ったページハンドラ(C#)

.NET における Web システムは、ページコントローラとテンプレートビューのパターン とともに動作するように設計されている。 ただし、 Web イベントを別の手法によって処理 することも可能である。 以下の例では、 私は.NET の推奨スタイルを基に、テーブルモ ジュールを使ってドメイン上部にプレゼンテーション層を構築し、レイヤ間の情報のメイン キャリアとしてデータセットを使っている。

3 62

ここでは、クリケットの試合の1イニングにおける得点数および得点率を表示するページ を作成する。 競技が多くの読者にとって馴染みのないものであることは十分承知しているの で、次のように定義させてもらうことにする。 まず得点数とは打者の得点であり、 得点率と は、得点を投球数で割ったものとする。 得点数と投球数はデータベースにあり、得点率はア プリケーション (小さいが、説明する上で有用なドメインロジックの構成要素である)が計 算によって求めるのである。

この設計におけるハンドラは、 ASP.NET Web ページであり、.aspx ファイルに収めら れている。 他のサーバページの構築と同様、ファイルによって、プログラミングロジックを スクリプトレットとして直接ページに埋め込むことができる。 スクリプトレットを書くぐら いなら気の抜けたビールを飲んでいる方がましだと考えている私は、もちろんそんなことは しない。 ASP.NET のコードビハインドメカニズムを使えば、 ファイルおよびクラスを aspxページと関連付け、 aspx ページのヘッダーに示すことができるからだ。

<%@ Page language="c#" Codebehind="bat.aspx.cs trace="False" Inherits="batsmen.BattingPage AutoEventWireup="false" 8>

ページは、コードビハインドクラスのサブクラスとして設定されているため、保護されて いるプロパティおよびメソッドの利用が可能となる。 ページオブジェクトは、リクエストの ハンドラであり、コードビハインドは、 page_Load メソッドを定義することによって、処理 方法を定義できる。 ページが共通のフローに従うなら、テンプレートメソッド [Gang of Four]を持ったレイヤスーパークラスを定義することができる。

class Cricket Page...

protected void Page_Load(object sender, System.EventArgs e)db = new OleDbConnection (DB.ConnectionString); if (hasMissingParameters ()) errorTransfer (missingParameterMessage); Dataset ds = getData(); if (hasNoData (ds)) error Transfer ("No data matches your request"); applyDomainLogic (ds); DataBind(); prepareUI (ds);

テンプレートメソッドは、リクエスト処理をいくつかの共通の手順へと分割する。 こうす ることで、 Web リクエストを処理する単一の共通フローを定義できる一方、各ページコン

{

Webプレゼンテーションパターン

トローラに特定の手順の実装を行わせることもできる。 そのためページコントローラを記述 してしまえば、テンプレートメソッド用にどの共通フローを使用すべきかがわかる。 まった く別の動作を必要とするページがある場合、 いつでもそのページ読み込みメソッドを無効に できる。

最初の作業は、ページに送られてくるパラメータの妥当性の確認である。 より現実に近い 例では、さまざまな形式の値の初期チェックが必要になるが、 例では http://localhost/ batsmen/bat.aspx?team=England&innings=2&match=905 形式の URL を解読している。 例における唯一の妥当性確認は、 データベースクエリーに必要なパラメータがあるかどうか である。 これに関しても私は、誰かが妥当性確認の優れたパターンセットを作成してくれる まで、シンプルなエラー処理に徹してきた。そのため、ここで示す特定のページには、一連 の必須パラメータが定義されていて、レイヤスーパータイプはそれをチェックするロジック を持っている。

class CricketPage...

abstract protected String[] mandatory Parameters (); private Boolean hasMissing Parameters() {

foreach (String param in mandatory Parameters()) if (RequestParams[param] == null) return true; return false;

private String missingParameterMessage (

get {

String result = "<P>This page is missing mandatory parameters: </P>"; result += "<UL>";

foreach (String param in mandatory Parameters ())

if (Request.Params[param] == null)

result += String.Format("<LI>{0}</LI>", param);

result += "</UL>";

return result;

}

protected void errorTransfer (String message) (

}

}

Context.Items.Add("errorMessage", message);

Context.Server.Transfer ("Error.aspx");

)

class BattingPage...

override protected String[] mandatoryParameters () (

364

String[] result = ("team", "innings", "match"); return result;

}

次の段階では、データベースからデータを抽出し、 ADO.NET 非接続データセットオブ

ジェクトに収める。 これは batting テーブルに対する単独のクエリーである。

class Cricket Page...

abstract protected DataSet getData();

protected Boolean hasNoData (DataSet ds) (

foreach (DataTable table in ds.Tables)

if (table.Rows.Count != 0) return false; return true;

class Batting Page...

}

override protected DataSet getData() { } OleDbCommand command = new OleDbCommand (SQL, db); command. Parameters.Add(new OleDbParameter ("team", team)); command.Parameters.Add(new OleDbParameter("innings", innings)); command. Parameters.Add(new OleDbParameter ("match", match)); OleDbDataAdapter da = new OleDbDataAdapter (command); DataSet result = new DataSet(); da. Fill (result, Batting. TABLE_NAME); return result;

private const String SQL =

@"SELECT FROM batting

WHERE team = ? AND innings = ? AND matchID = ? ORDER BY battingOrder";

ここで、テーブルモジュールにまとめられているドメインロジックの出番となる。 コント ローラは、抽出されたデータセットをテーブルモジュールに渡して処理を委ねる。

class Cricket Page...

protected virtual void applyDomainLogic (DataSet ds) ( )

class Batting Page...

override protected void applyDomainLogic (DataSet dataSet) {

Webプレゼンテーションパターン

batting = new Batting (dataset); batting.CalculateRates();

}

この時点で、 ページハンドラのコントローラの部分が実行される。 つまり、 従来のモデル ビューコントローラの言い方に従うと、 コントローラは、表示を行うためにここでビューに 引き渡すのである。 設計において、 BattingPage はコントローラおよびビューとして機能 prepareur に対する最後の呼び出しはビューの振る舞いの一部である。

以上でパターンの例は終了である。 ドラマティックなエンディングに欠けていると思われ るかもしれないが、そうした例は後ほど (373ページ参照) 紹介することにしよう。

|14.3 フロントコントローラ

Web サイトへのあらゆるリクエストを扱うコントローラ。

Handler doGet doPost Abstract Command process Concrete Command 1 process Concrete Command 2 process

複雑な Web サイトでは、リクエストの処理時に、 同じようなことをいろいろ行わなけれ ばならない。その中には、セキュリティ、 国際化、 特定のユーザに対する特定のビューの 提供などが含まれる。 入力コントローラの振る舞いが複数のオブジェクトに分散している 場合、振る舞いの多くは重複してしまうことが多く、 実行時に振る舞いを変更することも 難しくなる。

フロントコントローラは、単独のハンドラオブジェクトを介してリクエストをチャンネル 化することで、リクエスト処理を統合する。 オブジェクトは共通の振る舞いを実行し装飾子 によって実行時に修正することもできる。 その後ハンドラは、リクエストに固有の振る舞い

3 6 6

を行うコマンドオブジェクトを送信する。

14.3.1 動作方法

フロントコントローラは、 Web サイトのすべての呼び出しを扱い、 Web ハンドラとコマ ンド階層構造の2つの部分から構成される。 Web ハンドラは、サーバからの情報を受け 取ったり、リクエストを取得したりする。 URLとリクエストから必要な情報を抽出し、ど のようなアクションを実行するかを判断し、 アクションを実行するコマンドに委譲を行う (図 14.2 参照)。

handler handle HTTP get examine URL new (with data) concrete command process

図 14.2 フロントコントローラの動作

Web ハンドラはまったくレスポンスを返さないため、サーバページとしてではなくクラ スとして実装されることがほとんどである。 コマンドもサーバページというよりはクラスで あり、頻繁に HTTP の情報を渡されるが、 Web 環境についてまったく感知する必要がない。 Web ハンドラ自体は極めてシンプルなプログラムであり、実行するコマンドを判断する以 外は何も行わない。

Web ハンドラは、実行するコマンドの判断を静的に行うことも、動的に行うこともでき る。 静的バージョンにはURLの解析と条件分岐ロジックが含まれ、 動的バージョンには URL の標準部分の抽出と、動的インスタンス化を使ったコマンドクラスの作成が含まれる。

静的なケースには、明示的なロジック、 ディスパッチのコンパイルタイムエラーチェック、 およびURLの柔軟性というメリットがある。 動的なケースでは、Web ハンドラを変更する ことなく新しいコマンドを追加することができる。

動的な呼び出しの場合、コマンドクラスの名前を URL に収めることもでき、 URL をコ マンドクラス名と結び付けるプロパティファイルを使うこともできる。 プロパティファイル を使うと編集しなければならないファイルが1つ増えるが、 大量の Web ページ検索をしな くても簡単にクラス名を変更することができる。

フロントコントローラとの組み合わせが特に有効なパターンとしては、インターセプティ ングフィルタが挙げられる ([Alur et al] 参照)。 これは基本的にはフロントコントローラの ハンドラをラッピングする装飾子であり、 認証、ログの記録、ロケールの識別といった問題 を処理するフィルタチェーン(フィルタのパイプライン) の構築ができる。 フィルタを利用 することで、システム構成時に使うフィルタの動的な設定ができる。

Rob Mee は、 フロントコントローラの素晴らしいバリエーションを私に見せてくれた。 そこでは、Web ハンドラとディスパッチャとに分離した2段階の Web ハンドラが使われ ていた。 Web ハンドラは、 http パラメータから基本データを抽出し、 ディスパッチャが Web サーバフレームワークから完全に独立するような仕方でディスパッチャに渡す。 これ によりテストが簡素化される。 テストコードは Web サーバ上で実行しなくてもディス バッチャを直接動かすことができるのである。

ハンドラもコマンドも、コントローラの一部であることを覚えておいてほしい。 結果とし て、コマンドはレスポンスのためにどのビューを使用するかを選ぶことができる(あるいは 選ばなければならない)。 ハンドラの唯一の役割は、実行するコマンドの選択である。 選択 が終わればリクエストに対するハンドラの役割はもはやない。

1432 使用するタイミング

Webプレゼンテーションパターン

フロントコントローラは、対応するページコントローラより複雑な設計となっている。 そ のため利用する以上は、いくつかのメリットがなければならない。

Web サーバには、フロントコントローラが1つだけ構成され、 Web ハンドラは残りの 送信を行う。 これによって Web サーバのシステム構成が簡素化され、 Web サーバの設定 が面倒な場合にはメリットとなる。 動的コマンドの場合、一切の変更をせずに新しいコマン ドを追加できる。 ハンドラは Web サーバに一定の方法で登録するだけでよいので、移植も 容易となる。

リクエストごとに新しいコマンドオブジェクトを作成するため、 コマンドクラスを安全な スレッドにすることに気を使わなくてよい。 マルチスレッド化プログラミングの複雑さを回 避できるが、モデルオブジェクトなどほかのオブジェクを共有しないように注意する必要が ある。

一般に言われているフロントコントローラのメリットとは、ページコントローラにおいて 重複する可能性のあるコードを外に出せる点にある。 しかし厳密に言えば、こうした操作の

368

大部分は、スーパークラスであるページコントローラによって実現できる。

存在するコントローラはただ1つなので、 装飾子によって実行時にその振る舞いを簡単に 拡張できる [Gang of Four]。 認証、 文字のエンコーディング、 国際化のための装飾子とシ ステム構成ファイルを使って、 サーバの実行中であっても装飾子を追加することができる ([Alur et al.) では、インターセプティングフィルタの名でこうした手法について詳しく解説 されている)。

1433 参考文献

[Alur et al.Jは、Javaによるフロントコントローラの実装方法について詳しく解説してい る。また、フロントコントローラと相性の良いインターセプティングフィルタについても解 説されている。

Java の Webフレームワークの多くがこのパターンを使用している。 中でも優れた例が [Struts] に紹介されている。

14.3.4 例: シンプルな表示 (Java)

これは、レコーディングアーティストについての情報を表示するという、オリジナルかつ 斬新なタスクのためにフロントコントローラを使用した簡単な例である。

ここでは、 http://localhost:8080/isa/music?name=barelyWorks&command=Artist 形式のURLとともに動的コマンドを使用している。 コマンドパラメータによって、 Web ハ ンドラにどのコマンドを使うかを指示している。

第1章 Webプレゼンテーションパターン

HttpServlet KH FrontServlet doGet doPost FrontCommand process ArtistController process Album Controller process

14.3 ーフロントコントローラを実装するクラス

まずハンドラから始めよう。 私はこれをサーブレットとして実装している。

class FrontServlet...

public void doGet(HttpServletRequest request, } HttpServletResponse response) throws IOException, ServletException { Front Command command = getCommand (request); command. init(getServletContext(), request, response); command.process(); private Front Command getCommand (HttpServletRequest request) ( try { return (FrontCommand) getCommandClass (request) .newInstance(); } catch (Exception e) { } throw new ApplicationException(e); private Class getCommandClass (HttpServletRequest request) ( Class result; final String commandClassName = "frontController." + (String) request.getParameter("command") + "Command";

37 0

} try ( result = Class.forName (commandclassName); } catch (ClassNotFoundException e) { } result = UnknownCommand.class; return result;

ロジックはシンプルである。 ハンドラは、 コマンド名と 「Command」 の組み合わせを名 前として持つクラスをインスタンス化しようとする。 新しいコマンドが用意できたら、 HTTP サーバから得た必要な情報によってそれを初期化する。 私は、このシンプルな例の ために必要なものだけを渡しているが、 HTTP セッションなどが必要になることもある。 コマンドが見つからない場合、 私はスペシャルケースパターンを使って、 定義されていない コマンドを返すようにしている。 よくあることだがスペシャルケースで多くのエラーチェッ クの追加を回避できる。

コマンドは、かなりのデータと振る舞いを共有する。 すべては Web サーバからの情報に よる初期化が必要である。

class FrontCommand...

protected ServletContext context; protected HttpServletRequest request; protected HttpServletResponse response; public void init (ServletContext context, HttpServletRequest request, HttpServletResponse response) this.context = context; this.request = request; this.response = response;

また、forward メソッドなど共通の振る舞いを提供することができ、 コマンドをオーバー ライドする抽象プロセスコマンドを定義することもできる。

class FrontCommand...

abstract public void process () throws ServletException, IOException; protected void forward (String target) throws ServletException, IOException

第1章 Webプレゼンテーションパターン

Request Dispatcher dispatcher = context.getRequestDispatcher (target); dispatcher. forward (request, response);

}

コマンドオブジェクトは、少なくともこの例ではとてもシンプルである。 process メ ソッドを実装するだけだが、そこにはモデルオブジェクトの適切な振る舞いの実行、 ビューが必要とする情報リクエストの追加、 およびテンプレートビューへの転送などが含 まれている。

class ArtistCommand...

public void process () throws ServletException, IOException { Artist artist = Artist.findNamed (request.getParameter("name")); request.setAttribute("helper", new ArtistHelper (artist)); forward("/artist.jsp");

}

定義されていないコマンドは、 単調なエラーページを表示するだけである。

class UnknownCommand...

public void process () throws ServletException, IOException { forward("/unknown.jsp"); }

372

144 テンプレートビュー

HTML ページにマークを埋め込むことで、 HTML へ情報を加工する。

Book Model Author <HTML> <P> <B> <jsp.getProperty name="bookHelper* BookHelper property= "title"/> </B> <BR/> getTitle getAuthor Author: <jsp:getProperty |name="bookHelper* property="author"/> <</P> </HTML>

HTML を吐き出すプログラムの記述は、意外に難しいことが多い。 プログラミング言語 は、以前にくらべてテキストの作成を得意としてはいるが (Fortran や標準的な Pascal で のキャラクタ処理を覚えている読者は何人いるだろう)、文字列の作成や連結には今でも苦 労する。 そうした作業が少なければいいのだが、 しかし HTML ページ全体はテキスト処理 の集合である。

静的HTML ページ (リクエストによって変化することがない) の場合、 適当な WYSIWYGエディタが利用できる。 通常のテキストエディタを好む人であっても、プログ ラム言語で文字列連結を行うよりは、テキストやタグを入力する方がはるかに簡単であると 感じている。

もちろん、問題となるのは動的 Web ページの場合である。 つまり、データベースクエ リーなどの結果を取り込み、 それをHTML へと組み込むようなページである。 ページは結 果ごとに外観が異なるため、 HTMLエディタは役立たない。

最も適切な方法は、 静的ページと同様に動的ページを構成する一方で、 動的な情報を集め る呼び出しになるマークを埋め込むことである。 ページの静的な部分は、特定のレスポンス に対するテンプレートとして機能するので、私はこれをテンプレートビューと呼んでいる。

14.4.1 動作方法

テンプレートビューの基本的な考え方は、記述時に静的HTMLにマークを埋め込むこと である。 ページがリクエストへの情報提供に使用される場合、 マークは、データベースクエ

リーなどの計算処理によって置き換えられる。こうしたページは、プログラマではない人で も、WYSIWYGエディタなどを利用することによりレイアウトすることができる。 マーク は実際のプログラムとやり取りを行い、 結果を組み込む。

テンプレートビューを利用しているツールは数多い。 そのため、ここで紹介するパターン は自分でページを構築するためのものではなく、ページの効果的な使い方やその他のオプ ションに関するものである。

14.4.1.1 マークの埋め込み

HTMLにマークを配置する方法は数多くある。 1つはHTML 風のタグを使う方法であ る。これは WYSIWYGエディタとの相性が良い。 というのも、角括弧() で囲まれて いるものはすべて特別であるとみなされ、無視されるか、 別な扱い方が行われる。 タグがき ちんと整形された XML のルールに従っていれば、結果として生成される文書に XML ツー ルを使うこともできる (HTML の場合はXHMTL )。

もう1つの方法は、本文中に特別なテキストマークを使う方法である。 WYSIWYGエ ディタは、これをテキストとして扱い、無視はするがスペルチェックのような処理を行うこ とがある。 この方法のメリットは、 シンタックスがHTML/XML のシンタクスよりも簡単 になるという点である。

多くの環境において、 一連のタグが用意されているが、それぞれのニーズに合ったページ を設計するため、独自のタグやマークを定義する機能を持ったプラットフォームが増えつつ ある。

最も一般的なテンプレートビューの形式は、 ASP、 JSP、 PHPなどのサーバページであ る。これらは基本的なテンプレートビュー形式よりはるかに進化していて、 自由度の高いプ ログラミングロジック (スクリプトレットと呼ばれる) をページに組み込めるようになって いる。しかし、私の考えでは、こうした機能は数多くの問題を含んでいて、 サーバページ技 術を利用する場合、基本的なテンプレートビューの振る舞いに限定することを推奨する。

ページにスクリプトレットを配置することの明らかなデメリットは、プログラマ以外の ユーザがページを編集できなくなる点が挙げられる。 ページ設計にグラフィックデザイナー を起用する場合などには、重要な問題である。 しかし、ページへのスクリプトレット埋め込 みによる最大の問題は、ページがプログラムの貧弱なモジュールとなってしまう点である。 オブジェクト指向言語を使っても、そうしたページ構成方法では、オブジェクト指向スタイ ルやプロシージャルスタイルによるモジュラー設計の構造的機能の大部分が失われてしまう。

さらに悪いことには、ページにスクリプトレットを詰め込み過ぎると、 エンタープライズ アプリケーションの異なるレイヤが紛れ込みやすくなる。 サーバページ上にドメインロジッ クが出現し始めると、 異なるサーバページが重複しやすくなり、 ドメインロジックをうまく 構築することが難しくなる。 過去数年間に私が目にした最悪のコードは、サーバページコー

374

Webプレゼンテーションパターン

ドである。

14.4.1.2ヘルパーオブジェクト

スクリプトレットを避けるために重要なのは、 各ページに対するヘルパーとしての標準オ ブジェクトを提供することである。 ヘルバーは、あらゆる現実のプログラミングロジックを 持つ。 ヘルパーに対する呼び出しだけを持つことで、ページは簡略化され、テンプレート ビューは保たれる。 簡潔であるためプログラマ以外のユーザによるページの編集ができ、 プ ログラマはヘルパーだけに専念できるようになる。 使うツールによっては、ページ上のテン プレートをHTML/XML タグへと変換することができ、 その結果、ページの一貫性は保た れツールサポートを受けやすくなる。

これは簡単で優れた原則のように思えるが、状況を複雑にする問題点もいくつかある。 最 もシンプルなマークとは、システムのある場所から情報を取り出してページの正しい位置に 収めるものである。 マークはヘルパーの呼び出しに変換され、 結局はテキストとなり(また はテキストへ変換される何かになり)、エンジンは、テキストをページ上に配置することに なる。

14.4.1.3 条件付き表示

より複雑な問題が、 条件付きページの振る舞いである。 最も簡単な例としては、たとえば 条件が真のときだけ、 あるものが表示されるような状況が挙げられる。 たとえば、<IF condition = "$pricedrop > 0.1 ... show some stuff </IF> のような行に見られる 条件付きタグである。 ここでの問題は、このような条件付タグを使い始めると、やがてテン プレートからプログラミング言語への道をたどり始めてしまう点である。 その結果、 ページ にスクリプトレットを埋め込む場合と同様の問題に直面することになる。 完全なプログラミ ング言語が必要だと言うならスクリプトレットを使う手もあるが、 スクリプトレットについ ての私の考えはすでに述べたとおりである。

つまり、私は条件付きタグにも一抹の不安を感じているので、あまり勧められない。 条件 付きタグが必要な状況もあるかもしれないが、 できる限りふつうの<IF> タグよりも目的の はっきりした方法を見つけるべきである。

あるテキストを条件的に表示する場合の1つのオプションとしては、条件式をヘルパーに 移すという方法が挙げられる。 その場合、ページは必ず呼び出しの結果をヘルパーへと挿入 する。 条件式が真でなければ、ヘルパーは空の文字列を送り返すが、 ロジックはヘルパーが 持つ。 こうした手法は、 返されるテキストへのマークアップがない場合、 またはブラウザー によって無視される空のマークアップを返せる場合に適している。

しかし、一番頻度の高いアイテムの名前を太字に設定し強調したいときには、こうした方 法は適していない。 つまり、 名前は常に表示する必要があり、 特別なマークアップを施した

第1章 Webプレゼンテーションパターン

いと考える場合もある。そうした処理を実現するには、ヘルパーにマークアップを生成させ るという方法が挙げられる。 こうすることで、ロジックはページの外部に置かれ、強調のた めの選択はページ設計者の手を離れプログラムコードにまかされる。

HTML の選択をページ設計者の手元に置くには、 何らかの条件付きタグが必要となる。 これは <IF> の先に目を向けることである。 目指すべきは狙いのはっきりしたタグ (focused tag) であり、 次のようなタグではなく、

<IF expression= "isHighSelling()"> <B></IF> <property name = "price"/> <IF expression = isHighSelling()"></B></IF>

次のようなタグにすべきである。

<highlight condition = "isHighSelling" style = "bold"> <property name = "price"/> </highlight>

いずれの場合も、ヘルパーの単独のブール型プロパティをベースに条件が満たされること が重要である。 より複雑な式をページに挿入するのは、事実上ページ自体にロジックを組み 込むことに等しい。

もう1つの例は、システムが実行されているロケールに依存する情報をページに配置する 方法である。 ロケールが、アメリカまたはカナダの場合だけテキストを表示する場合、 次の ようなタグにはならない。

<IF expression = "locale = 'US' || 'CA'"> ...special text </IF>

次のようなタグになる。

<locale includes = *US, CA"> ... special text </locale>

14.4.1.4 イテレーション

コレクションに対する繰り返しは、同じような問題を起こす。 各行がある注文の品目名に 対応する表が必要な場合、各行ごとの情報の表示を簡単にできる構造が必要である。 ここで は、コレクションタグに対する一般的な繰り返しを回避することは難しいが、ほとんど問題 なく動作する。

もちろん、作業の対象となるタグは、 自分が置かれている環境によって制限されることが多 い。決まったテンプレートセットが提供される環境もあり、その場合は、前述のガイドライン

376

に従う以上に、 より多くの制限を受けるだろう。 しかし、他の環境では使うタグに関しては、 より多くの選択肢が利用でき、さらには独自のタグライブラリを定義できるものもある。

14.4.1.5 処理の時期

テンプレートビューという名前は、パターンの基本機能がモデルビューコントローラにお けるビューの表示であることは明らかであり、さまざまなシステムにおいて、テンプレート ビューはビューの表示だけを行う。 モデルプロセスをできる限り分離したいが、よりシンプ ルなシステムにおいては、コントローラとして利用することも、モデルとすることもできる。 テンプレートビューがビューの裏の役割を担う状況では、そうした役割をページではなくへ ルパーによって処理させることが重要である。 コントローラとモデルの役割は、プログラム ロジックに関連し、 プログラムロジックはヘルパーに置かれる必要がある。

あらゆるテンプレートシステムは、 Web サーバによる追加処理を必要とする。 これは、 ページ作成後のコンパイル時に行うことも、また最初のリクエストにおけるページのコンパ イル時に行うことも、 あるいは、各リクスエトにおけるページの解釈時に行うこともできる。 ただし、解釈に時間がかかる場合、3番目の選択肢は勧められない。

テンプレートビューでは例外に注意すべきである。 例外が Web コンテナに及ぶ場合、リ ダイレクトの代わりに、 呼び出し側のブラウザーへ異例な出力を提供するという処理途中の ページを目にすることがある。 自分の Web サーバが、 例外をどのように処理するか注視す る必要がある。 何か変な処理を行っているようであれば、 例外をすべてヘルパークラスに処 理させるのである (スクリプトレットを軽視するという理由もある)。

14.4.1.6スクリプトの利用

サーバページはテンプレートビューの最も一般的な形式だが、テンプレートビュースタイ ルのスクリプトを記述することもできる。 私は、こうした方法で書かれたPerl を目にした ことがある。 Perl のCGIで目立つのは、レスポンスに適切なタグを出力する機能呼び出し を持つことで、 文字列の連結を回避する仕掛けである。こうすることで、自分のプログラミ ング言語を使ってスクリプトを記述し、プログラミングロジックによる print 文字列の散乱 を回避できるのである。

144.2 使用するタイミング

モデルビューコントローラにおいてビューを実装する場合の主な選択肢には、テンプレー トビューとトランスフォームビューがある。 テンプレートビューの長所は、ページ構造に注 目してページのコンテンツを作成できる点である。 これは多くの人にとって実践しやすく学 習も容易である。とりわけプログラマはヘルバーを担当し、ページのレイアウトはグラ

フィックデザイナーが担当するという方法が最適である。

Webプレゼンテーションパターン

一方、テンプレートビューには、2つの大きな弱点もある。 1つ目は、標準的な実装では、 ページに複雑なロジックが入り込みやすく、 プログラマ以外のユーザにとっては、維持管理 が困難になる点である。 ページはできる限りシンプルかつ表示専用にして、ロジックの部分 はヘルパーにまかせるといったルールに従う必要がある。 2つ目の弱点は、 トランスフォー ムビューに比べて、テンプレートビューはテストが困難だという点である。 テンプレート ビューの実装のほとんどは、Web サーバとの利用を前提として設計されているため、それ 以外のテストはとても困難もしくは不可能である。 トランスフォームビューの実装は、テス ト用のハーネスへの設置が容易で、 Web サーバなしでもテストができる。

ビューについて考える場合、 ツーステップビューについても考慮する必要がある。テンプ レートスキームによっては、特定のタグによってこうしたパターンの実装が可能となること もある。しかし、トランスフォームビューをベースにして実装する方法のほうが簡単かもし れない。 ツーステップビューが必要になったら、この点について考慮する必要がある。

14.4.3 例:独立コントローラを持ったビューとしてのJSP の利用 (Java)

JSP をビューとしてだけ利用する場合、サーブレットコンテナからではなく必ずコント ローラから実行する。 そのため、 何を表示すべきかを判断するために必要なすべての情報を JSP に渡すことが重要である。 最良の手段は、コントローラにヘルパーオブジェクトを作成 させ、HTTP リクエストを使って JSP に渡すことである。 ここでは、ページコントローラ のところで示した簡単な表示例を使って、その方法を紹介する。サーブレットの Web 操作 メソッドは以下のようになる。

class ArtistController...

public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { Artist artist = Artist.findNamed (request.getParameter("name")); if (artist == null) forward("/MissingArtistError.jsp", request, response); else { request.setAttribute("helper", new Artist Helper (artist)); forward("/artist.jsp", request, response); }

テンプレートビューに関する限り、重要な振る舞いとは、ヘルパーの作成とリクエストへ の配置である。 サーバページは、 useBean タグによってヘルパーへと到達できる。

378

<jsp:useBean id="helper" type="actionController. ArtistHelper scope="request"/>

ヘルパーの準備ができると、 それを使って表示に必要な情報へのアクセスができる。 ヘル バーが必要とするモデル情報は、その作成時にすでに渡されている。

class Artist Helper...

private Artist artist; public Artist Helper (Artist artist) ( this.artist = artist; )

ヘルパーを利用することで、 モデルから適切な情報を入手する。 最もシンプルなケースで は、 メソッドによって、 シンプルなデータ (Artist 名など) を取得する。

class ArtistHelper...

public String getName(){ return artist.getName(); }

その後、Java の式によって情報にアクセスする。

<B> <%= helper.getName() %></B>

あるいはプロパティを利用する。

<B> <jsp:getProperty name="helper" property="name" /> </B>

プロパティを使うか式を使うかは、 誰がJSP を編集するかによって決まってくる。プロ グラマにとっては式の方がコンパクトで読みやすいが、 HTMLエディタはそうした式を扱 えないこともある。 プログラマ以外のユーザは、タグを好むだろう。 タグはHTML の標準 形式に適合し、エラーが発生する余地が少ない。

また、ヘルパーを利用することで、難しいスクリプトレットコードも回避できる。 ある Artist のアルバムリストを表示する場合、 ループの実行が必要になるが、そうした処理は サーバページのスクリプトレットによって実現できる。

<UL>

<8

第1章 Webプレゼンテーションパターン

for (Iterator it helper.getAlbums ().iterator(); it.hasNext(); ) { Album album = (Album) it.next(); %> <LI><=album.getTitle()8> </LI>

<8}g>

</UL>

率直に言って、このようなJava と HTML の混在はとても読みにくい。 その他のオプ ションとしては、次のようにfor ループをヘルパーへ移動するという方法がある。

class ArtistHelper...

public String getAlbumList () { StringBuffer result = new StringBuffer(); result.append("<UL>"); for (Iterator it = getAlbums () iterator(); it.hasNext();) ( } Album album = (Album) it.next(); result.append("<LI>"); result.append(album.getTitle()); result.append("</LI>"); result.append("</UL>"); return result.toString(); } public List getAlbums (){ return artist.getAlbums (); }

HTML の分量が少ないので、私としてもこれはわかりやすいと思う。 また、 プロパティ を利用したリストの取得も可能となっている。 ヘルパーにHTMLコードを配置する方法を 好まない人は多い。私も好きではないが、スクリプトレットとどちらを選ぶかと問われれば、 ヘルパーにHTMLを置く方法を選ぶ。

最良の手段は、繰り返しのための特殊なタグである。

<UL> <tag:forEach host = "helper collection = "albums" id="each"> <LI> <jsp:getProperty name="each property= "title"/> </LI> </tag: forEach> </UL>

これはヘルパーのJSPやHTML にスクリプトレットを使わなくてすむという点で、 より 優れたオプションである。

380

14.4.4 例: ASP.NET サーバページ (C#) 1

ここでも、ページコントローラのところで示した例を引き続き使う (362ページ)。クリ ケットの試合のイニングにおいて打者が獲得した得点を示すものである。 クリケットに興 味のない読者もいるだろうから、ここではこの偉大なるスポーツの真の魅力を語ることは敢 えて避け、 基本的な以下の3種類の情報だけを表示することにする。

■試合を参照するためのID番号

■どのチームの得点でどのイニングの得点かが表示されている

■各打者の名前、 得点 得点率 (その打者への総ボール数を総得点で割った値)

こうした統計データの意味がわからなくても、心配する必要はない。 クリケットには統計 データが豊富にある。 クリケットの最大の功績は、物好きな新聞雑誌に対してふんだんに統 計データを提供していることだろう。

ページコントローラに関する論点は、 Web リクエストをどう扱うかという点であるが、 一言で言えば、 コントローラおよびビューの両方として機能するオブジェクトは、aspx ASP.NET ページである。 スクリプトレットを使わずにこのコントローラコードを作成す るためには、クラスの裏に独立したコードを定義することである。

<%@ Page language="c#" codebehind="bat.aspx.cs AutoEventWireup="false" trace="False" Inherits="batsmen. BattingPage %>

このページは、クラスの裏にあるコードのメソッドとプロパティに直接アクセスできる。 さ らに、裏のコードはリクエストを扱う page_Load メソッドを定義できる。 ここで私は、 テンプ レートメソッド [Gang of Four] としてレイヤスーパータイプに page_Load を定義している。

class CricketPage...

protected void Page_Load(object sender, System.EventArgs e) { db = new OleDbConnection (DB.ConnectionString); if (hasMissingParameters ())

errorTransfer (missingParameterMessage);

DataSet ds = getData();

if (hasNoData (ds))

error Transfer

apply DomainLogic (ds);

("No data matches your request");

DataBind();

prepareUI (ds);

第1章 Webプレゼンテーションパターン

テンプレートビューの目的のために、私は page_Load メソッドの最後の数行以外はすべ て無視している。 DataBindへの呼び出しによって、 さまざまなページ変数は、ベースとな るデータソースと適切に結び付けられている。 これはシンプルなケースのためのものだが、 より複雑なケースでは、最後の行は特定ページの裏のコードにあるメソッドを呼び出すこと で使うオブジェクトを用意する。

対応するID番号、チーム、イニングは、ページにとって単一の値である。 それらは HTTPリクエストのパラメータとしてページに加わったものである。 私は、クラスの裏に あるコードのプロパティを利用することで、これらの値を提供している。

class Batting Page...

protected String team ( get { return Request.Params["team"]; } } protected String match ( get {return RequestParams["match"];} } protected String innings ( get { return Request.Params["innings"];} } protected String ordinal Innings ( } get {return innings == "1") ? "1st": "

2nd";}

プロパティを定義することで、ページのテキスト中での利用もできる。

<P> Match id: <asp:label id="matchLabel" Text="<8# match>" runat="server" font-bold="True"> </asp:label>&nbsp; </P> <P> <P> <asp:label id=teamLabel Text="<%# team %>" runat="server" font-bold="True"> </asp:label>&nbsp; <asp:Label id=inningsLabel Text="<%# ordinalInnings ・ runat="server"> </asp:Label>&nbsp; innings</P>

この表はやや複雑だが、 Visual Studio のグラフィック機能のおかげで簡単に動作する。

382

Visual Studio は、 データセットの単独の表に結び付けることができるデータグリッド制御 を提供する。 私は、 page_Load メソッドで呼び出される prepareUI メソッドにバインドす ることでこれを実現している。

class Batting Page...

override protected void prepareUI (DataSet ds) ( DataGrid1.DataSource = ds; DataGridl.DataBind(); }

Batting クラスは、データベースのbatting テーブルにドメインロジックを提供するテー ブルモジュールである。 データプロパティは、テーブルモジュールのドメインロジックに よって補強される表のデータである。 ここで補強されるものとは得点率であり、 データベー スに保存されているものではなく計算によって求められる。

ASP.NET データグリッドによって、表の外観に関する情報とともに、 Web ページに表 示したい列の選択ができる。 例では、 名前 (name) 列、 得点 (runs) 列、および得点率 (rate) 列を選択している。

<asp: DataGrid id="DataGridl" runat="server" Width="480px" Height="171px" BorderColor="#336666" BorderStyle="Double" BorderWidth="3px" BackColor="White" CellPadding="4" GridLines-"Horizontal" AutoGenerateColumns="False">

<SelectedItemStyle Font-Bold="True" ForeColor="White"

BackColor="#339966"></SelectedItemStyle>

<ItemStyle ForeColor="#333333" BackColor="White"></ItemStyle> <HeaderStyle Font-Bold="True" ForeColor="White"

BackColor="#336666"></HeaderStyle> <Footer Style ForeColor="#333333" BackColor="White"></Footer Style> <Columns>

<asp:BoundColumn DataField="name" HeaderText="Batsman"> <HeaderStyle Width="70px"></HeaderStyle> </asp:BoundColumn> <asp:BoundColumn DataField="runs" HeaderText="Runs"> <HeaderStyle Width="30px"></HeaderStyle> </asp:BoundColumn> <asp:BoundColumn DataField="rateString" HeaderText="Rate"> <HeaderStyle Width="30px"></HeaderStyle> </asp:BoundColumn> </Columns> <PagerStyle HorizontalAlign="Center" ForeColor="White" BackColor="#336666" Mode="Numeric Pages"></PagerStyle> asp:DataGrid></P>

</

第1章 Webプレゼンテーションパターン

このデータグリッド用のHTMLの組み込みは一見大変そうだが、 Visual Studio ではそ れらを直接操作するわけではなく、ページのその他の部分と同様に、 開発環境でプロパティ シートを介して操作するのである。

データセットおよびデータテーブルのADO.NET の抽象的概念を理解し、 Web フォーム コントロールを Web ページに配置できるという能力は、このスキームの強みでもあり限界 でもある。 強みとしては、 Visual Studio が提供するツールのおかげで、 データセットを介 して情報を転送できる点が挙げられる。 一方、限界としては、テーブルモジュールのような パターンを使うときだけ、シームレスな動作ができる点が挙げられる。 とても複雑なドメイ コンロジックを持っている場合ドメインモデルが役立つが、 ツールを利用するためにはドメイ ンモデルは独自のデータセットを作成しなければならない。

14.5 トランスフォームビュー

要素ごとにドメインデータ要素を処理し HTML へと変換するビュー。

Model Album Artist Transformer creates HTML read transformAlbum transformArtist

ドメインおよびデータソースレイヤに対してデータリクエストを発行するとき、 要件を満 たすために必要なデータが返されるが、 適切な Web ページを作成するために必要なフォー マッティングは行われていない。 モデルビューコントローラにおけるビューの役割は、デー タをWeb ページへと加工することである。 トランスフォームビューは、こうした処理を、 モデルのデータを入力、 HTML を出力とする一種の変換と考える。

14.5.1 動作方法

トランスフォームビューの基本的な考え方は、ドメイン指向のデータに注目し、 HTML へと変換するプログラムを記述することである。 プログラムはドメインデータの構造を チェックし、ドメインデータの各形式を確認しながら、 HTML の特定の要素へと書き出す。 これを絶対的なものとするには、 customer オブジェクトを受け取り、 HTML へと加工す render Customer というメソッドを持つ必要がある。 顧客が多くの注文をしている場合、 メソッドは、 renderOrder を呼び出すことでその注文にループ処理を行うのである。

38 4

トランスフォームビューとテンプレートビューの重要な違いは、ビューのまとめ方である。 テンプレートビューは、 出力を中心に形成される。一方、トランスフォームビューは、 それ ぞれの入力要素に対する独立した変換を中心として形成される。 変換は、各入力要素に注目 し、 要素に合った変換方法を判断し、 そのための変換メソッドを呼び出すシンプルなループ 処理で制御される。 標準的なトランスフォームビューのルールは、結果出力に影響すること なく、いかなる順番にも並べ替えることができるのである。

トランスフォームビューはどんな言語でも記述できるが、 現時点では XSLT が優勢であ る。 XSLT の興味深い点は、 Lisp や Haskell などの言語と同様に、決して国際規格の主流 になることがなかった機能プログラミング言語だということである。 そのため異なる種類の 構造を持っている。 たとえば、 XSLT は明示的にルーチンを呼び出す代わりに、 ドメイン データの要素を確認した後、 適切な加工変換を実行する。

XSLT 変換を実行するには、まず XML データから始める必要がある。 変換が起こる一 番シンプルな状況は、ドメインロジックの戻り型が XML または自動的に XML に変換可 能なもの(たとえば.NET) の場合である。 それを行わない場合、 自ら XML に直列化でき るデータ変換オブジェクトを投入することで、独自に XML を生成する必要がある。 このよ うに、データは便利なAPI を使ってアセンブルできる。 シンプルなケースでは、トランザ クションスクリプトによって XML を直接返すこともできる。

通信回線を混線させるために文字列形式が必要だというのでない限り、 変換へ送られる XML は文字列である必要はない。 DOM を作成しそれを変換へと渡す方が迅速かつ簡単で ある。

XML を用意できたら、 それを XSLT エンジンに渡す (XSLT エンジンも最近では商用 になってきた)。 変換のためのロジックは XSLT スタイルシートに取り込まれ、また変換 コードへと渡される。 その後変換コードは、スタイルシートを入力である XML に適用して、 出力である HTML を生成するが、これはHTTPレスポンスに直接書き出すことができる。

14.5.2 使用するタイミング

トランスフォームビュー、テンプレートビューの選択は、ビューソフトウェアに携わる チームがどの環境を好むかによって決まることがほとんどであるため、ツールが重要な要因 となる。テンプレートビューの記述に利用できるHTMLエディタは、数多くある。一方、 XSLT用のツールは、現時点では十分に成熟していない。 また XSLT 自体、機能プログラ ミングスタイルと複雑な XML シンタクスとが組み合わされた結果、 習得するのがとても困 難な言語となっている。

一方、 XSLT の長所は、他の Web プラットフォームへの移植性の高さである。 J2EE ま たは.NET から作成された XMLの変換にも同じ XSLT が利用できるが、これは異なる

| Webプレゼンテーションパターン

ソースからのデータに共通の HTML ビューを配置するときに役立つ。

XML ドキュメントにビューを構築する場合も、 XSLT は容易であることが多い。 他の環 境では、ドキュメントをオブジェクトに変換するよう求められたり、複雑な XML DOM の 解析に多くの時間を費やされたりすることが多い。 その点、 XSLT は XML の世界に自然と 適合する。

トランスフォームビューは、テンプレートビューが抱える2つの重大な問題を回避できる。 変換の目的をHTMLへの加工に絞り込むことが容易であり、他のロジックがビューへと大 量に注ぎこまれることを回避できる。 また、 トランスフォームビューの実行は容易であるた め、テスト用の出力の取得も簡単である。そのため、 ビューのテストも簡単で、テストを行 う場合も Web サーバを必要としない。

トランスフォームビューは、ドメイン指向の XMLをHTML へと直接変換する。 たとえ ば、Web サイトの外観全体を変更したいときは、複数の変換プログラムへの変更が必要で ある。 XSLT が持つような標準的な変換コードは、こうした問題の解決に役立つ。テンプ レートビューを使うよりも、 トランスフォームビューを使って共通の変換コードを呼び出す 方が簡単である。 全体的な変更を加えたり、 同一データに対する複数の表示方法をサポート したりする必要がある場合は、 2段階のプロセスを使用するツーステップビューの利用も考 えるべきである。

14.5.3 例 シンプルな変換 (Java)

シンプルな変換のための設定には、レスポンスを形成する正しいスタイルシートを呼び出 すJava コードの準備作業も含まれる。 またレスポンスに書式を設定するスタイルシートの 準備も含まれる。 ページに対するほとんどのレスポンスは標準的であり、 フロントコント ローラを使うことで十分である。 ここではコマンドについてだけ解説するが、 コマンドオブ ジェクトがその他のリクエストに対するレスポンス操作にいかに適合するかについては、フ ロントコントローラの項を参照してほしい。

コマンドオブジェクトが行う作業は、モデルのメソッドを呼び出して XML 入力ドキュメ ントを取得し、 XML プロセッサを介してXML ドキュメントを渡すことだけである。

class AlbumCommand...

public void process() {

try( Album album = Album.findNamed (request.getParameter("name")); Assert.notNull(album); PrintWriter out = response.getWriter(); XsltProcessor processor = new SinglestepxsltProcessor ("album.xs1*);

386

out.print (processor.getTransformation (album.toXmlDocument())); }catch(Exception e) {

throw new ApplicationException(e);

}

XML ドキュメントは以下のようになる。

<album> <title>Stormcock </title> <artist > Roy Harper </artist> <trackList> <track> <title>Hors d Oeuvres</title> <time>8:37</time> </track> <track> <title>The Same Old Rock</title> <time>12:24</time> </track> <track> <title> One Man Rock and Roll Band</title> <time>7:23</time> </track> <track> <title>Me and My Woman</title> <time> 13:01</time> </track> </trackList> </album>

XML ドキュメントの変換は、 XSLT プログラムによって行われる。 各テンプレートは XML の特定の部分と一致し、 適切な HTML 出力をページのために生成する。 このケース では、私は基本要素だけを示すため、 出力書式は基本的なものにとどめている。 以下のテン プレート旬は、XML ファイルの基本要素と一致している。

<xsl:template match="album">

<HTML> <BODY bgcolor= "white">

<xsl:apply-templates/>

</BODY> </HTML>

</xsl:template>

<xs1:template match="album/title">

<h1> <xs1: apply-templates/></h1>

< /xs1:template>

<xs1template match= "artist">

<P> <B>Artist:

</xsl:template>

</B><xs1:apply-templates/></P>

こうしたテンプレートの一致によって表は処理され、 異なる色によって行を強調するよう な変更が加えられている。 これはまさにスタイルシートだけでは不可能であり、 XML を利 用する必然性を示す良い例である。

}

第1章 Webプレゼンテーションパターン

<xsl:template match= "trackList"> <table><xsl:apply-templates/></table> </xsl:template> <xsl:template match= "track"> <xsl:variable name="bgcolor"> <xsl:choose> <xsl:when test=" (position () mod 2) =1">linen</xsl: <xsl:otherwise>white</xsl: otherwise> </xsl:choose> </xsl:variable> <tr bgcolor="{$bgcolor}"><xsl:apply-templates/></tr> </xsl:template>

when>

<xsl:template match= "track/title"> <td><xsl:apply-templates/></td> </xsl:template>

<xsl:template match= "track/time"> <td><xsl:apply-templates/></td> </xsl:template>

146 ツーステップビュー

ドメインデータを2つの手順でHTML に変換する。 まずは論理ページを形成し、次に 論理ページを HTML へと加工する。

Album read artist: Artist Stage 1 create renderAlbum renderArtist Screen artist: Field read Stage 2 create renderScreen renderField HTML

Webアプリケーションが複数ページから構成される場合、 外観および構成には一貫性が 求められることが多い。 各ページの外観が異なっていると、ユーザの混乱を招きやすいサイ

388

トとなってしまう。 また、 サイト全体に対して、 容易に全面的な変更を加えたいこともある。 しかし、テンプレートビューやトランスフォームビューによる一般的な手法では、そうした 変更は難しい。 プレゼンテーションの決定が、複数のページまたはトランスフォームモ ジュールにまたがって重複することが多いからである。 そうした大規模な変更を行うと複数 のファイルの変更が必要になる。

ツーステップビューは、 変換プロセスを2つの段階に分割することで、こうした問題に対 処する。 最初の段階では、 特定の書式設定をせずに、モデルデータを論理的なプレゼンテー ションへと変換する。 2番目の段階では、論理的なプレゼンテーションを本来求められる出 力書式に変換する。このようにして、 全体的な変更が必要なら、2番目の段階を変更すれば よい。あるいは、2番目の段階を複数用意することで、複数の外観を備えた出力もサポート できる。

14.6.1 動作方法

このパターンのポイントは、HTMLへの変換を2段階の処理として行う点である。 最初 の段階では、論理的な画面構造で情報を組み立てていて、 HTML がまだ含まれていない表 示要素を構成する。 第2段階では、そのプレゼンテーション指向の構造をHTMLへと加工 する。

この中間フォームは、一種の論理画面である。 要素には、フィールド、 ヘッダー フッ ター、表 オプションが含まれる。 したがって、 これはプレゼンテーション指向であるため、 画面は確実に明確なスタイルに従うようになる。 プレゼンテーション指向モデルは、所有可 能なさまざまな仕掛けや含まれるデータを定義はするが、 HTML の外観は指定しないもの と考えることができる。

こうしたプレゼンテーション指向の構造は、それぞれの画面用に記述された特定のコード によって組み立てられる。 最初の段階の役割とは、ドメイン指向モデルにアクセスすること であり、データベース、 実際のドメインモデル、 あるいはドメイン指向のデータ変換オブ ジェクトにアクセスし、画面に関連する情報を抽出して情報をプレゼンテーション指向の構 造へと収めることである。

第2段階では、プレゼンテーション指向の構造をHTML へと変換する。 この段階では、 プレゼンテーション指向の構造に含まれる各要素を把握し、 HTML として表示する方法を 把握している。そのため、多くの画面を持つシステムでも、第2段階だけですべて加工し、 HTML 書式の決定も一度で済む。 ただし、 その結果である画面は、プレゼンテーション指 向の構造から派生する必要があるという制限は依然としてある。

第1段階のスタイルシートは、ドメイン指向のXMLをプレゼンテーション指向のXML へと変換し、 第2段階のスタイルシートは、 XML を HTML へと変換する。

Webプレゼンテーションパターン

その場合、プレゼンテーション指向の構造を、 テーブルクラス、 行クラスなど一連のクラ スとして定義する。 第1段階では、 ドメイン情報を取得し、 論理画面をモデル化する構造へ クラスをインスタンス化する。 第2段階では、クラスをHTML へ加工する。 そのためには、 プレゼンテーション指向の各クラスを取得し、独自にHTMLを生成するか、あるいは HTML への加工を行う独立したクラスに作業を行わせる。

いずれの手法もトランスフォームビューをベースとしている。 テンプレートビューベース の手法を利用することもできるが、その場合は、論理画面のアイデアをベースとしたテンプ レートを選択する。

<field label = "Name" value = "getName" />

その後、テンプレートシステムは、論理タグを HTML へと変換する。 こうした仕組みに おいては、ページ定義にはHTML は含まれず、 論理画面タグだけが含まれる。結果としてそ れは XML文書になり、 WYSIWYG HTMLエディタを使う能力は失われることになる。

1 Order 1 Table OrderFirstStage renderOrder renderLineltem SecondStage renderTable renderRow Lineltem * Row *

図14.42段階の加工のための例クラス

390

data Order new get data- line item Response new Table new get data - Row get data second stage add html add html

get

first stage

2段階の加工のためのシーケンス図

new

Controller

図 14.5

14.6.2 使用するタイミング

ツーステップビューの最も重要な点は、第1段階と第2段階とが独立しているために、全体 的な変更が簡単に行えるという点にある。 これは、複数の外観を持つ Web アプリケーション と、単独の外観を持つ Webアプリケーションの2つの状況を想定する手助けとなる。 複数の 外観を持つアプリケーションは、現在はかなり稀であるが、成長しつつある。 そうしたアプリ ケーションでは、複数の組織に提供される基本機能はほとんど同じでも、外観は組織ごとに異 なる。 具体的な例としては、 航空旅行者向けサイトが挙げられる。 ページごとのレイアウトお よび設計は明らかに違っていても、すべては基本となるサイトが変化したものである。 多くの 航空会社は、明らかに異なる外観を除いて、ほとんど同じ機能を必要としているようである。 単独の外観を持つアプリケーションはとても一般的である。 代表を務める組織は1つだけ

であり、彼らはサイト全体に渡って一貫した外観を求めている。 まずはこの簡単な例から先 に取り上げることにしよう。

シングルステージビュー (テンプレートビューまたはトランスフォームビュー) の場合、 Web ページごとに1つのビューモジュールを構築する (図14.6 参照)。 ツーステップビュー には2つの段階がある。 ページごとに1つの第1段階のモジュールと、 アプリケーション全 体に対して1つの第2段階のモジュールである (図 14.7 参照)。 ツーステップビューを使う メリットは、 第2段階におけるサイトの外観の変更が容易であることだ。 これは第2段階の 1回の変更がサイト全体に影響するためである。

複数の外観を持つアプリケーションの場合は、画面と外観の組み合わせごとに第1段階の ビューを持つため、こうしたメリットは大きくなる (図14.8)。 たとえば、 10個の画面と3 個の外観は30個の第1段階ビューモジュールを必要とする。 しかし、 ツーステップビュー を使えば (図 14.9 参照)、 10の第1段階と3つの第2段階で十分となる。 画面および外観 の数が増えるほど、その節約の効果は高まる。

ただし、成否はプレゼンテーション指向の構造をいかに外観のニーズに応えられるように できるかにかかっている。 ページごとに外観が異なるような設計重視のサイトでは、ツース テップビューは効果を発揮できない。 それは、シンプルなプレゼンテーション指向の構造が 得られるだけの共通性を画面間に見出すことが難しいからである。 基本的にサイト設計は、 プレゼンテーション指向の構造によって制限されるが、そうした制限が多すぎるサイトは少 なくない。

ツーステップビューのもう1つの弱点は、利用するためのツールが必要となることだ。 プ ログラミング能力を持たないデザイナーがテンプレートビューを使ってHTML ページのレ イアウトを行うためのツールはたくさんあるが、 ツーステップビューでは、プログラマはレ ンダリングオブジェクトとコントローラオブジェクトの記述を要求される。 そのため、 プロ グラマはあらゆる設計上の変更に関係を持つ必要が出てくるのである。

392

第1章 Webプレゼンテーションパターン

Customer Data Order Data Customer View Order View "create" "create Customer HTML Order HTML

図 14.6 1つの外観を持ったシングルステージビュー

複数レイヤを持つツーステップビューが、 習得困難なプログラミングモデルであることは 事実である。 しかし、慣れてしまえばそれほど難しくはなく、決まりきった反復的なコード を減らすこともできる。

複数の外観という点では、異なるデバイスに対する異なる第2段階の提供というバリエー ションも考えられる。 具体的には、ブラウザーと PDA ごとに異なる第2段階を用意するこ ともできるのである。 ここでの制限事項としては、いずれの外観も同じ論理画面に従わなけ ればならないことである。 そのため、まったく異なるデバイスの場合には行うのが難しい。

Webプレゼンテーションパターン

Customer Data Order Data Customer First Stage Order First Stage -create- Customer Logical Screen Customer HTML "create" Second Stage 14.7 1つの外観を持ったツーステップビュー "create" "create" Order Logical Screen Order HTML

Customer Data Order Data Foo Customer View Bar Customer View Foo Order View Bar Order View "create" "create" "create" A "create" Foo Customer HTML Bar Customer HTML Foo Order HTML Bar Order HTML

14.8 2つの外観を持ったシングルステージビュー

394

"create" Foo Customer HTML Customer Data Order Data Customer First Stage Order First Stage "create" -create- Customer Logical Screen Order Logical Screen Foo Second Stage Bar Second Stage H "create" "create" -create- Foo Order Bar Customer Bar Order HTML HTML HTML

14.9 2つの外観を持ったツーステージビュー

14.6.3 1-75-XSLT (XSLT)

ツーステップビューのこの手法は、 2段階の XLST 変換を利用する。 第1段階ではドメ イン固有の XML を論理画面 XML へ変換し、 第2段階では論理画面 XMLをHTMLへと 変換する。

初期のドメイン指向 XML は、以下のようになる。

<album>

<title>Zero Hour</title>

<artist>Astor Piazzola</artist>

<trackList>

<track><title>Tanguedia III</title> <time>4:39</time></track>

Webプレゼンテーションパターン

<track><title>Milonga del Angel</title> <time>6:30</time></track> <track><title>Concierto Para Quinteto</title><time>9:00</time></track>> <track><title>Milonga Loca</title> <time>3:05</time></track> <track><title>Michelangelo 70</title> <time>2:50</time></track> <track><title>Contrabajisimo</title> <time>10:18</time></track> <track><title>Mumuki</title> <time>9:32</time></track> </trackList>

</album>

第1段階の XSLT プロセッサは、以下のような画面指向の XML へと変換する。 これを行うためには、以下の XSLT プログラムが必要となる。

<xsl:template match="album">

<screen><xsl:apply-templates/></screen> </xsl:template>

<xsl:template match="album/title">

<title><xsl:apply-templates/></title>

</xsl:template>

<xsl:template match="artist">

<field label="Artist"> <xsl:apply-templates/></field> </xsl:template>

<xsl:template match= "trackList">

<table> <xsl:apply-templates/></table>

</xsl:template>

<xsl:template match= "track">

<row> <xsl:apply-templates/></row> </xsl:template>

<xsl:template match= "track/title">

<cell><xsl:apply-templates/></cell>

</xsl:template>

<xsl:template match= "track/time">

<cell><xsl:apply-templates/></cell> </xsl:template>

画面指向 XML はとても簡素である。 これをHTML に変換するには、第2段階の XSLT プログラムを利用する。

<xsl:template match="screen"> <HTML> <BODY bgcolor="white"> <xsl:apply-templates/> </BODY></HTML>

</xsl:template>

396

<xsl:template match="title">

<h1><xsl:apply-templates/></h1>

</xsl:template>

<xsl:template match="field">

<P><B><xsl:value-of select = "@label"/>: </B><xsl:apply-templates/></P>

</xsl:template>

<xsl:template match="table">

<table><xsl:apply-templates/></table>

</xsl:template>

<xsl:template match="table/row">

<xsl:variable name="bgcolor">

<xsl:choose>

<xsl: when test=" (position () mod 2) = 1">linen</xsl: when>

<xsl:otherwise>white</xsl:otherwise>

</xsl:choose>

</xsl:variable>

<tr bgcolor="{$bgcolor}"><xsl:apply-templates/></tr> </xsl:template> <xsl:template match="table/row/cell">

<td><xsl:apply-templates/></td>

</xsl:template>

2つの段階の組み立てにおいて、 作業を行うコードを分離するための助けとしてフロント コントローラを利用している。

class AlbumCommand...

public void process () ( try { Album album Album. findNamed (request.getParameter ("name")); album Album. findNamed ("1234"); Assert.notNull (album); PrintWriter out = response.getWriter(); Xslt Processor processor = new Two StepXsltProcessor ("album2.xsl", "second.xsl"); out.print (processor.getTransformation (album. toXmlDocument())); } catch (Exception e) { throw new ApplicationException(e); )

これと、トランスフォームビューにおける1段階手法とを比較することは有効である。た とえば、行の色を交互に変更したい場合、 トランスフォームビューではすべての XSLT プ

Webプレゼンテーションパターン

ログラムの変更が必要となるが、 ツーステップビューでは、変更は第2段階の XSLT プロ グラム1つで済む。呼び出し可能なテンプレートによって同様の操作を行うことはできるか もしれないが、それにはかなりの XSLT 能力が求められる。 ツーステップビューのデメ リットとしては、最終的な HTML が画面指向 XML の制限を強く受けてしまうという点が 挙げられる。

14.6.4 例: JSP およびカスタムタグ (Java)

理論的には、 XSTL方式はツーステップビューの実装を考える上で最も簡単な方法だが、 その他の方法も数多くある。 例では、 私はJSP とカスタムタグを使っている。 それらは XSLT に比べると面倒で非力だが、 パターンがいかにさまざまな方法で自らを宣言できるか を示す例となっている。 私はこうした方法が実際に行われているのを見たことがないため、 この例の紹介については若干のためらいがある。 しかし理論的な例によって、 可能性を提示 できると期待している。

ツーステップビューの基本ルールとは、表示対象の選択と表示する HTML の選択とを完 全に分離するというものである。 この例では、第1段階はJSP ページとヘルパーによって 処理し、第2段階は一連のカスタムタグによって処理している。 第1段階のポイントはJSP ページである。

<8@ taglib uri="2step.tld" prefix = "2step" >

<%@ page session= "false">

<jsp:useBean id="helper" class="actionController. AlbumConHelper"/> < helper.init(request, response); %>

<2step: screen>

<2step:title><jsp: getProperty name = "helper" property = *title"/> </2step:title>

<2step field label = "Artist"> <jsp:getProperty name = "helper property = "artist*/></2step: field> <2step: table host = *helper" collection = "trackList" columns = "title, time"/> </2step: screen>

私はこのJSP ページに対して、 ヘルパーオブジェクトとともに、ページコントローラを 利用している (詳しくはページコントローラの項を参照)。 ここでのポイントは、2step ネームスペースの一部であるタグに注目している点である。 第2段階を呼び出すためにこれ らを利用している。 JSP ページ上にはHTML はなく、 存在するタグは第2段階タグ、もし くはヘルバーから値を取得する bean 操作タグである。

各第2段階タグは、 論理画面要素に必要なHTMLを送り出すための実装を持っている。

398

最もシンプルな例はタイトルである。

class TitleTag...

public int doStartTag() throws JspException ( } try { pageContext.getOut ().print ("<H1>"); } catch (IOException e) { ) throw new JspException("unable to print start"); return EVAL_BODY_INCLUDE; public int doEndTag() throws JspException ( try { pageContext.getOut () .print("</H1>"); } catch (IOException e) { } throw new JspException("unable to print end"); return EVAL_PAGE;

カスタムタグは、 タグ化されたテキストの最初と最後に呼び出されるフックメソッドを実 装することで機能する。 タグは、シンプルに <H1> タグで本体部分を囲んでいる。 フィール ドのように、より複雑なタグは属性を持つことができる。 属性は、設定メソッドによってタ グのクラスと結び付けられている。

class FieldTag...

private String label; public void setLabel (String label) { this.label = label;

}

}

値がセットされた後は、それを出力に利用できる。

class FieldTag... public int doStartTag() throws JspException { try { pageContext.getOut () .print ("<P>" + label " <B>"); } catch (IOException e) ( } throw new JspException ("unable to print start");

第1章 Webプレゼンテーションパターン

return EVAL_BODY_INCLUDE;

} public int doEndTag() throws JspException { try { pageContext.getOut().print("</B></P>"); } catch (IOException e){ } throw new JspException("how are checked exceptions helping me here?"); return EVAL_PAGE; )

Table タグは最も高度なタグである。 JSP の記述者が表に収める列を選択できるようにす るだけでなく、 行を交互に強調する。 タグの実装は第2段階として機能するため、 強調はそ こで行われ、その結果、システム全体のグローバルな変更ができる。

Table タグは、コレクションプロパティの名前、 コレクションがあるオブジェクト、 そし てカンマ区切りの列名リストに対する属性を持つ。

class TableTag...

private String collectionName; private String hostName; private String columns; public void setCollection (String collectionName) } this.collectionName = collectionName; public void setHost (String hostName){ this.hostName = hostName; } public void setColumns (String columns) { this.columns = columns; }

{

私は、オブジェクトからプロパティを取得するためのヘルパーメソッドを作成した。 「何 かを取得する」 メソッドを呼び出す代わりに、 Java Bean をサポートするクラスを利用する 方法については十分な根拠がある。 しかし、この例にとっては前者が有効である。

class TableTag...

private Object getProperty(Object obj, String property) throws JspException( try( String methodName = "get" + property.substring(0, 1).toUpperCase()

400

+property.substring(1); Object result = obj.getClass().getMethod (methodName, null).invoke(obj, null); return result; } catch (Exception e) ( throw new JspException("Unable to get property + property + } " from obj);

このタグは本文を持たない。 呼び出されると、 リクエストプロパティから名前の付けられ たコレクションを抽出し、コレクションに繰り返し処理を行って表の行を生成する。

class TableTag...

public int doStartTag() throws JspException { try { JspWriter out = pageContext.getOut(); out.print ("<table>"); Collection coll = (Collection) getPropertyFromAttribute (hostName, collectionName); Iterator rows = coll.iterator(); int rowNumber = 0; while (rows.hasNext()) { } out.print ("<tr"); if ((rowNumber++ % 2) == 0) out.print (" bgcolor= + HIGHLIGHT_COLOR); out.print (">"); printCells (rows.next()); out.print ("</tr>"); out.print ("</table>"); } catch (IOException e) { ) throw new JspException("unable to print out"); return SKIP_BODY; "

)

private Object getPropertyFromAttribute (String attribute, String property) throws JspException

Object hostObject = pageContext.findAttribute (attribute); if (hostObject == null) throw new JspException("Attribute "+attribute + "not found.");

return get Property (hostObject, property);

}

'linen'";

public static final String HIGHLIGHT_COLOR=

Webプレゼンテーションパターン

繰り返しの間、タグは一行おきにその背景色を設定することで行を強調する。 各行のセルを印刷する場合、私はコレクションのオブジェクトのプロパティ値を列名とし て使う。

class TableTag...

private void printCells (Object obj) throws IOException, JspException { } JpWriter out = pageContext.getOut(); for (int i = 0; i < getColumnList().length; i++) { } out.print("<td>"); out.print (get Property (obj, getColumnList ( ) [i])); out.print("</td>"); private String[] getColumnList() { } StringTokenizer tk = new StringTokenizer (columns, ","); String[] result = new String [tk.countTokens () ]; for (int i=0; tk.hasMoreTokens(); i++) result[i] = tk.nextToken(); return result;

XSLT の実装と比べて、このソリューションは、サイトレイアウトの統一性に対する制限 が少ない。 ページごとに独立したHTML を仕込みたいと考えるページ作者は、それが容易 であることに気付くはずだ。 もちろん、 設計重視のページができる一方で、 動作に詳しくな い人が不適切に利用することもある。制限もときにはミスを防ぐ手助けとなる。 これもまた 開発チームが自ら判断すべきトレードオフなのである。

402

147 | アプリケーションコントローラ

アプリケーションの画面ナビゲーションとフローを扱うための集中管理ポイント。

request. application domain input controller view controller command get domain command run get view forward

アプリケーションによっては、異なるポイントごとに使われる画面に関する膨大な量のロ ジックが含まれ、その中には、アプリケーションにおける特定のタイミングでの特定の画面 の呼び出しも含まれる。 具体的には、一連の画面が一定の順番でユーザの前に提示される、 いわゆるウイザード方式のやり取りが挙げられる。 あるいは、一定の条件下においてだけ特 定の画面が表示されたり、 前の入力の内容によって表示される画面が変わったりすることも ある。

モデルビューコントローラ入力コントローラは、このような決定を行うことができるが、 アプリケーションがより複雑になると、 異なる画面に対する複数のコントローラが特定の状 況において行うべき操作を把握しなければならないため、コードの重複につながる。

こうした重複を回避するには、すべてのフローロジックをアプリケーションコントローラ に配置する。 そして、 入力コントローラはアプリケーションコントローラに対して、 モデル への適切なコマンドの実行と、アプリケーションの状況に応じた正しいビューを要求する。

14.z.1 | 動作方法

アプリケーションコントローラは2つの役割を持つ。 実行するドメインロジックの判断と、 レスポンスを表示するビューの判断である。 それを行うため、クラス参照の2種類の構造化 されたコレクションを保持する (1つはドメインレイヤにおいて実行されるドメインコマン ド用、 もう1つはビュー用) (図14.10)。

ApplicationController | getDomainCommand (context) |getView(context) "<metaclass>> View * "metaclass"> Domain Command

図14.10 アプリケーションコントローラは、ドメインロジック用とビュー用というクラスへの参照の2つのコレ クションを持つ。

ドメインコマンドとビューの両方に対して、アプリケーションコントローラは、呼び出し できる対象を保存する手段を必要とする。 コマンド [Gang of Four] は、コードのブロックを 容易に入手し、実行するという点で、優れた選択肢である。 関数を扱える言語も、それらに 対する参照を保持することができる。 その他の選択肢としては、リフレクションによるメ ソッドの呼び出しに使う文字列を持つという方法も挙げられる。

ドメインコマンドは、アプリケーションコントローラレイヤの一部であるコマンドオブ ジェクトでも、トランザクションスクリプトへの参照またはドメインレイヤのドメインオブ ジェクトメソッドでもかまわない。

サーバページをビューとして利用する場合、 そのサーバページ名を使用できる。 クラスを 使う場合は、反復的な呼び出しのためのコマンドや文字列を使う。 また、 アプリケーション コントローラが、 参照としての文字列を保持できる XSLT 変換も使える。

ここで下すべき判断は、アプリケーションコントローラをプレゼンテーションの他の部分 からどれくらい分離するかである。 最初のレベルでは、アプリケーションコントローラはそ の UI 機構に対して依存性を持つかどうかを判断することになる。 おそらくそれはHTTP セッションデータに直接アクセスし、 サーバページへと転送するか、あるいはリッチクライ アントクラス上のメソッドを呼び出すか、 という判断になる。

私はダイレクトアプリケーションコントローラを目にしたことがあるが、 個人的にはアプ リケーションコントローラがUI機構へのリンクを持つ方が好みである。 まず、 UI とは切り 離した形でのアプリケーションコントローラのテストができるが、 これにはかなり大きなメ リットがある。 複数のプレゼンテーションに対して同じアプリケーションコントローラを使 う場合にも、こうした方法は有効である。 そのためアプリケーションコントローラを、プレ ゼンテーションとドメインの中間レイヤと考える人も少なくない。

第1章 Webプレゼンテーションパターン

404

アプリケーションは、複数のアプリケーションコントローラに個々の異なる部分を操作さ せることができる。これによって、 複雑なロジックも複数のクラスへと分割できる。こうし たケースでは、作業はさまざまなUI の領域へと分割され、 領域ごとに独立したアプリケー ションコントローラが構築される。 シンプルなアプリケーションであれば、単独のアプリ ケーションコントローラで十分であろう。

Web のフロントエンド、 リッチクライアント、 PDA など複数のプレゼンテーションがあ る場合、各プレゼンテーションに同じアプリケーションコントローラを使うことは可能だが、 あまり固執すべきではない。 実用的なユーザインタフェースを実現するためには、 異なる UI が異なる画面フローを必要とすることも多い。 しかし、 単独のアプリケーションコント ローラを再利用すれば、 開発の手間が節約でき、その労力をより面倒なUIへと回すことも できる。

UIについての最も一般的な考え方は、アプリケーションの特定のキーオブジェクトの状 態に応じて、 特定のオブジェクトが異なるレスポンスのトリガーとなる状態マシンである。 その場合、アプリケーションコントローラは、メタデータを使って状態マシンの制御フロー を表現することに適応しやすい。 メタデータは、プログラミング言語の呼び出しによって設 定することもでき (これが最も簡単な方法である)、 独立したシステム構成ファイルに保存 することもできる。

アプリケーションコントローラに置かれる1つのリクエストにだけ固有のドメインロジッ クを目にすることもあるかもしれない。 私はこのような方法には大反対である。 しかし、 ド メインロジックとアプリケーションロジックの境界は極めて不透明である。 たとえば、保険 のアプリケーションにおいて、 申込者が喫煙者の場合にだけ、別の質問のための画面を表示 したいとしよう。これはアプリケーションロジックだろうか、それともドメインロジックだ ろうか。そうした場面が少なければロジックをアプリケーションコントローラに収めること は可能だが、頻繁な場合は、それを誘導するような方法でドメインモデルを設計する必要が ある。

14.7.2 使用するタイミング

アプリケーションのフローおよびナビゲーションがあまりにシンプルで、どのような順番 でも目的の画面にたどり着ける場合、 アプリケーションコントローラを利用する価値はほと んどない。 アプリケーションコントローラの長所は、表示されるページの順番に対する明確 なルールと、オブジェクトの状態に応じてビューが異なる点にある。

アプリケーションのフローが変更されたときに、多くの異なる箇所に同じような変更を加 える必要があると判断したなら、 アプリケーションコントローラを使うべきである。

14.7.3 | 参考文献

第1章 Webプレゼンテーションパターン

このパターンの記述のベースになっている概念は、ほとんど [Knight and Day] に由来する。 そうした概念は必ずしも新しいものではないが、説明がわかりやすく説得力に富んでいる。

14.7.4 例: 状態モデルアプリケーションコントローラ (Java)

状態モデルは、 ユーザインタフェースを考える一般的な方法である。 あるオブジェクトの 状態に応じて、 イベントに対する反応をさまざまに変える必要がある場合には特に有効であ る。この例では 私はある Asset (資産) に対する2、3のコマンドに対してシンプルな状 態モデルを用意している (図14.11)。 Thought Work 社のリースの専門家がこのモデルを 見たら、その非現実的なシンプルさに驚くかもしれないが、状態ベースのアプリケーション コントローラの例としては十分である。

On Lease return In Inventory damage damage In Repair

図 14.11 -Asset (資産)のためのシンプルなステートチャート図

コードに関しては、以下のようなルールが設定されている。

return コマンドを受け取ったとき、 On Lease 状態にある場合、 Asset の収益 に関する情報を取得するページを表示する。

In Inventory 状態にあるときのリターンイベントがエラーになる場合、不正ア クションページを表示する。

damage コマンドを受け取ったときには、 Asset が In Inventory 状態にある か On Lease 状態にあるかに応じて、異なるページを表示する。

入力コントローラはフロントコントローラである。 以下のようなリクエストに対してサー ビスを提供する。

406

class FrontServlet....

public void service (HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException

(

ApplicationController appController = getApplicationController (request); String commandString = (String) request.getParameter("command"); Domain Command comm=

appController.getDomainCommand (commandstring, getParameterMap (request));

comm.run(getParameter Map (request));

String viewPage = "/" + appController.getView (commandString, getParameter Map (request)) + ".jsp"; forward (viewPage, request, response);

service メソッドのフローは極めてシンプルである。 まず任意のリクエストに対する正し いアプリケーションコントローラを判断して、 アプリケーションコントローラにドメインコ マンドを要求し、 次にこのドメインコマンドを実行しアプリケーションコントローラに ビューを要求して、最後にビューへと転送する。

スキームについては、 私はすべてが同じインタフェースを実装する数多くのアプリケー ションコントローラを想定している。

interface ApplicationController...

DomainCommand getDomainCommand (String commandString, Map params); String getView (String commandstring, Map params);

コマンドに対して適切なアプリケーションコントローラは、 Asset アプリケーションコン トローラである。 Response クラスを使って、 ドメインコマンドおよびビュー参照を保持す る。 私は、ドメインコマンドに対してはクラスへの参照を使い、 ビューに対してはフロント コントローラがJSP用のURLへと変換する文字列を使っている。

class Response...

private Class domainCommand; private String viewUrl; public Response (Class domainCommand, String viewUrl)( this.domainCommand= domainCommand; this.viewUrl = viewUrl; )

第1章 Webプレゼンテーションパターン

public DomainCommand get DomainCommand() { try { return (DomainCommand) domainCommand.newInstance(); } catch (Exception e) (throw new ApplicationException (e); } } public String getViewUrl() { } return viewUrl;

アプリケーションコントローラは、コマンド文字列と Asset 状態によってインデックス 付けされたマッピングの1つを使って、レスポンスを維持している (図14.12)。

«<interface Application Controller Asset Application Controller command asset state 1 view 1 Response *

String

Class

1

14.12 ･Asset アプリケーションコントローラによるドメインコマンドとビューへの参照の保存方法

class Asset ApplicationController...

private Response getResponse (String commandString, AssetStatus state) ( } return (Response) getResponseMap (commandString).get (state);

8

(

private Map getResponseMap (String key) return (Map) } events.get(key); private Map events = new HashMap();

ドメインコマンドを要求されると、コントローラはまずリクエストから Asset ID を調べ、 次にドメインで Asset の状態を判断し、 ドメインコマンドクラスを参照してクラスをイン スタンス化し、 新しいオブジェクトを返す。

class AssetApplicationController...

public DomainCommand getDomainCommand (String commandString, Map params) ( Response reponse = getResponse (commandstring, getAssetstatus (params)); return reponse.getDomainCommand();

}

private Asset Status getAssetStatus (Map params) { String id = getParam("assetID", params); Asset asset = Asset.find(id); return asset.getStatus();

private String getParam (String key, Map params) ( return((String[]) params.get(key)) [0]; }

}

ドメインコマンドは、フロントコントローラによるコマンド実行できるシンプルなインタ フェースに従う。

interface DomainCommand...

abstract public void run (Map params);

ドメインコマンドが必要な操作を行った後、ビューを要求されると、 アプリケーションコ ントローラは再び活動を開始する。

class AssetApplicationController...

public String getView (String commandString, Map params) { return getResponse (commandString, getAsset Status (params)) .getViewUrl();

}

第1章 Webプレゼンテーションパターン

このケースでは、アプリケーションコントローラは完全な URL を JSP に返さない。 ある 文字列が返されるが、 フロントコントローラがURLへ変換しているものである。 私がこう した処理を行っているのは、レスポンスにおける URL パスの重複を防ぐためである。 また、 後でインダイレクションが必要となった場合、 追加も容易になる。 アプリケーションコントローラは、コードによる利用の目的で読み込むことができる。

class AssetApplicationController...

public void addResponse (String event, Object state, Class domainCommand, String view) ( Response newResponse = new Response (domainCommand, view); if(events.containsKey (event)) events.put(event, new HashMap()); getResponseMap (event).put(state, newResponse);

}

private static void loadApplicationController (AssetApplicationController appController) { appController = AssetApplicationController.getDefault(); appController.addResponse("return", AssetStatus.ON_LEASE, Gather ReturnDetailsCommand.class, "return"); appController.addResponse("return, AssetStatus.IN_INVENTORY, NullAssetCommand.class, "illegalAction"); appController.addResponse("damage", AssetStatus.ON_LEASE, InventoryDamageCommand.class, "leaseDamage"); appController.addResponse("damage Asset Status.IN_INVENTORY, LeaseDamageCommand.class, inventoryDamage");

これをファイルから行うこともそれほど難しくはない。

4 1 0

15.1 リモートファサード

章 15 分散パターン

ネットワークの効率性を向上させるため、細かい粒度のオブジェクトに対して粗い粒度 のファサードを提供する。

AddressFacade getAddressData setAddress (street, city, zip) Address getStreet() getCity() getZip() setStreet(arg) setCity (arg) setZip(arg)

オブジェクト指向モデルでは、 メソッドが少なく規模の小さなオブジェクトを使うのが最 善である。その理由は、 振る舞いの制御や変更を行ったり、適切な命名規則を設定したりす ることで、理解しやすいアプリケーションを構築することが容易になるからである。 このよ うな細かい粒度の振る舞いとした結果、 オブジェクト間の多大な相互作用が生じ、 大量のメ ソッド呼び出しが必要になる。

1つのアドレススペース内では、 細かい粒度の相互作用は有効に動作するが、 プロセス間 で呼び出しを行う場合には困難が生じる。 リモートコールはとてもコストがかかる。 データ マーシャリングしたり、 セキュリティをチェックしたり、パケットを複数のスイッチを介 してルーティングしたりするなどの操作が必要になるからである。 2つのプロセスが互いに 地球の反対側のマシン上で動作している場合、 光LAN の速さですらコスト要因になること がある。 しかし相互のプロセス呼び出しは、両方のプロセスが同じマシン上にある場合でも、 プロセス内の呼び出しと比べると桁ちがいにコストがかかる。 それが効率性に及ぼす影響は、 楽観的に考えても無視することができない。

第

その結果、リモートオブジェクトとして使う予定のあらゆるオブジェクトには、呼び出し の数を最小限にするインタフェースが必要になる。 これは、 メソッド呼び出しだけではなく オブジェクトにも影響する。 Order と個々のOrder Line を要求するのではなく、1回の呼 び出しで、 Order と Order Line にアクセスし、更新する必要がある。 これはオブジェクト 構造全体に影響する。 そのため、規模の小さいオブジェクトとメソッドで実行できた明確な 目的と細かい粒度の制御をあきらめることになる。 プログラミングは一層困難なものとなり、 生産性も低下する。

リモートファサードとは、 複雑化した細かい粒度のオブジェクトに対するファサード [Gang of Four] である。 どの細かい粒度のオブジェクトにもリモートインタフェースはな く、リモートファサードはドメインロジックを一切含まない。

リモートファサードの機能は、 メソッドを基本的な細かい粒度のオブジェクトに変換する ことである。

15.1.1 動作方法

リモートファサードは、 分散の問題、 つまり個別の責任を異なるオブジェクトに分けると

いう標準的なオブジェクト指向手法を使った解決策であり、標準的なパターンとなっている。 細かい粒度のオブジェクトが複雑なロジックの適切な対処法であり、 どのような複雑なロ ジックも、1つのプロセス内でコラボレートするように設計された細かい粒度のオブジェク トに配置されるべきであると私は確信している。 オブジェクトへのリモートアクセスの効率 性を向上させるため、リモートインタフェースとして機能する個々のファサードオブジェク トを作成する。 名前のとおり、 ファサードは、単にインタフェースから細かい粒度のインタ フェースへ変換するという薄い皮にしかすぎない。

アドレスオブジェクトのようなシンプルな例の場合、 リモートファサードは、 元のアドレ スオブジェクトのget メソッドと set メソッドを、 通常バルクアクセッサーと呼ばれる、1 つのget メソッドと1つのsetメソッドに置き換える。 クライアントがバルクセッターを呼 び出すと、アドレスファサードは、 set メソッドからデータを読み込み、 本来のアドレスオ ブジェクトの個々のアクセッサーを呼び出し (図 15.1 参照)、 処理は終了する。 このように、 アドレスオブジェクトは正確に組み込まれ、 別の細かい粒度のオブジェクトが使えるように なり、アドレスオブジェクト上に妥当性確認と計算が構築される。

複雑な場合には、1つのリモートファサードが多数の細かい粒度のオブジェクトのリモー トゲートウェイとしての役割を果たす場合もある。 たとえば、 Order ファサードを使って、 Order の情報、つまりすべてのOrder Line のほか、場合によっては何らかの顧客データに 関する情報の取得と更新を行う。

4 1 2

第1章 分散パターン

address facade getAddressData getCity getState getZip address

図 15.1 ファサードへの1つの呼び出しが、 ファサードからドメインオブジェクトへの複数の呼び出しを行う

このように情報を一括して転送する際、回線上で容易に伝送できる形式にする必要がある。 細かい粒度のクラスが接続の両端にあり、直接接続ができる場合、 コピーして直接転送する。 このような場合、 getAddressData メソッドがオリジナルのアドレスオブジェクトのコピー を作成する。 setAddressData は、アドレスオブジェクトを受け取り、それを使用してアド レスオブジェクトのデータを更新する (オリジナルのアドレスオブジェクトは一意性を保持 する必要があり、 容易には新しいアドレスに変更できないものとしている)。

しかし、普通上記の方法は使えない。 その理由は、 ドメインクラスを複数のプロセスに複 製することを望まなかったり、 複雑な関連構造であったりするために、ドメインモデルのセ グメントを直列化することが困難な場合があるからである。 クライアントは、モデル全体で はなく、シンプルにされたサブセットを必要とすることがある。 このような場合、 転送には 基本的にデータ変換オブジェクトを使うことが有効である。

スケッチでは、1つのドメインオブジェクトに対応するリモートファサードを示している。 これは目新しいものではなく、理解しやすいものであるが、必ずしも通常のケースとは限ら ない。1つのファサードには、複数のオブジェクトから情報を伝えるように設計されたいく つかのメソッドがある。 そのため、 getAddressData と setAddress Data は、 getPurchasing History や updateCreditData で指定するメソッドも持つ、 Customer Service のようなクラスで定義されるメソッドとなる。

粒度は、リモートファサードに関する最も困難な問題の1つである。 ユースケースごとに 1つなど、 とても小さなリモートファサードを作成することを好む人もいる。 私は、リモー トファサードの少ない、 とても限定した粗い粒度の構造を好む。 普通サイズのアプリケー ションの場合は1つだけ、大規模なアプリケーションでも6つ程度である。このことは、リ

モートファサードには多数のメソッドがあることを意味しているが、 メソッドが小型である ため問題にはならないと思う。

ユーザインタフェースを介して情報の表示と更新を行うというユーザの特定のニーズに基 づいてリモートファサードを設計するとする。 このような場合、 一連の画面用に1つのリ モートファサードがあり、 各画面に対して、1つのバルクアクセッサーメソッドがデータの ロードとセーブを行う。 画面上のボタンを押すことで、 Order 状況の変更を指示すると、 ファサードのコマンドメソッドが呼び出される。 ほとんどの場合リモートファサード上には、 基盤となるオブジェクトと同じ機能のある複数の異なるメソッドがある。 これはよくあるこ とで合理的である。 ファサードは、 システム内部ではなく、 外部のユーザがわかりやすいよ うに設計されている。 そのため、 クライアントプロセスが異なるコマンドと見なす場合、 プ ロセスがまったく同じ内部コマンドに達している場合でも、異なるコマンドとなる。

リモートファサードをステートフルまたはステートレスにすることができる。 ステートレ スリモートファサードはブールできるので、 特にB2C においてリソースの使用頻度と効率 性を向上させることができる。 しかし、相互作用でセッションを超えた状態が呼び出される 場合、セッションはクライアントセッションステート、 データベースセッションステート、 およびサーバセッションステートの実装を使って、 どこかにセッション状態を格納する必要 がある。 ステートフルの場合、 リソースファサードはそれ自体の状態を持続できるので、 サーバセッションステートの実装は容易になるが、何千ものユーザが同時に使用する場合は、 パフォーマンスの問題が生じる可能性がある。

インタフェースを提供するだけではく、ほかのいくつかの役割をリモートファサードに追 加することができる。 たとえば、メソッドにセキュリティを適用するのは自然なことである。 アクセス制御リストには、どのユーザがどのメソッドで呼び出しを行えるかを表示できる。 リモートファサードメソッドは、 さらにトランザクション制御を適用する適切な場所でもあ る。 リモートファサードメソッドは、 トランザクションの開始、 内部動作のすべての実行、 そしてトランザクションのコミットを行うことができる。 各呼び出しは、クライアントに返 すときにトランザクションをオープンにしたくないのでかなり長いものとなる。 トランザク ションがこのような長時間継続するケースでの効率性を考慮に入れて構築されていないから である。

リモートファサードに関して、 私の知る限り最も大きな間違いの1つは、ドメインロジッ クをリモートファサードに配置することである。 「リモートファサードにはドメインロジッ クを配置しない」と、私の後について3回繰り返して言ってほしい。 いずれのファサードも、 最低限の役割だけを持つ薄い皮であるべきだ。 ワークフローや調整にドメインロジックが必 要な場合、それを細かい粒度のオブジェクトに配置するか、あるいはそれを含めるために別 個のリモート処理不可能なトランザクションスクリプトを作成する必要がある。 リモート ファサードを使うことなく、 またはいずれかのコードの複製を要することなく、 アプリケー

第15章 分散パターン

14

ション全体をローカルで動作させるべきだ。

15.1.1.1 リモートファサードとセッションファサード

ここ2、3年、 セッションファサード [Alur et al.) パターンがJ2EE コミュニティに登場し てきた。 私は、以前の草稿で、 リモートファサードをセッションファサードと同じパターン と見なし、セッションファサードという名前を使っていた。 しかし両者には決定的な違いが ある。 リモートファサードは、薄いリモートの皮を持つものにすぎない。 そのため、リモー トファサードにドメインロジックを配置することに対して私は警鐘を鳴らすのである。 反対 に、セッションファサードについてのほとんどの解説には、ロジックを、セッションファ サード、ワークフロー分野のものに配置することが含まれている。 大部分は、エンティティ Bean をラップするために J2EE セッション Bean を使う一般的な手法によるものである。 エンティティ Bean のあらゆる連携は、 エンティティ Bean が再入可能ではないので、他の オブジェクトによって行う必要がある。

その結果、私は、セッションファサードをいくつかのトランザクションスクリプトをリ モートインタフェースに配置するものと理解している。 これは妥当な手法であるが、 リモー トファサードとは異なる。 セッションファサードには、ドメインロジックが含まれるので、 それは到底ファサードとは呼べないと主張したい。

15.1.1.2 サービスレイヤ

ファサードに類似した概念がサービスレイヤである。 主な相違点は、サービスレイヤはリ モートである必要はなく、 そのため、細かい粒度のメソッド以外にも使うことができること である。 シンプルにしたドメインモデルでは通常はメソッドで終了するが、これはわかりや すさのためであり、 ネットワークの効率性を考慮したものではない。 さらに、 サービスレイ ヤでデータ変換オブジェクトを使う必要はない。 サービスレイヤは、何の問題もなく、ドメ インオブジェクトをクライアントに返すのである。

ドメインモデルがプロセス内とリモートの両方で使われる予定の場合、 サービスレイヤを 持ち、その一番上に個別のリモートファサードをレイヤ化する。 プロセスが、リモートだけ で使われる場合、 サービスレイヤがアプリケーションロジックをまったく持たないという条 件で、 サービスレイヤをリモートファサードに組み込む方が容易だと思われる。 サービスレ イヤに何らかのアプリケーションロジックがある場合、 私ならリモートファサードを個別の オブジェクトにする。

15.1.2 使用するタイミング

細かい粒度のオブジェクトモデルへのリモートアクセスが必要な場合、 いつでもリモート

ファサードを使うべきである。 インタフェースのメリットを享受しながら、 他方で細かい粒 度のオブジェクトのメリットも保持されるなど、両者の最も良いところを活用する。

第1章 分散パターン

このパターンが最も普及しているのは、プレゼンテーションとドメインモデルの間で、両 者が異なるプロセスで動作している場合である。 Swing UI とサーバドメインモデル間、 ま たはアプリケーションと Web サーバが異なるプロセスの場合にはサーブレットとサーバオ ブジェクトモデルでこれを使うことができる。

ほとんどの場合、これは異なるマシン上の異なるプロセスで実行される。 しかし、同じ ボックス上の相互のプロセス呼び出しコストは大きいので、 プロセスがある場所に関係なく、 相互のプロセス通信用の粗いインタフェースが必要である。

アクセスが1つのプロセス内である場合、 変換は必要ないため、私はパターンを1つの Web サーバで動作するクライアントドメインモデルとプレゼンテーション間またはCGI ス クリプトとドメインモデル間の通信には使うつもりはない。 トランザクションスクリプトは、 リモートファサードを意識することはない。

リモートファサードは、 分散の同期 (つまりリモート手続コールの) 形式である。 非同期 のメッセージベースのリモート通信を使うことで、アプリケーションのレスポンスを改善で きる場合もあり、事実、 非同期の手法には多くのメリットがある。 残念ながら非同期パター ンの解説は、本書の範囲を逸脱するものである。

15.1.3 例: リモートファサードとしてのJava セッション Bean の使用 (Java)

エンタープライズ Java プラットフォームで作業している場合、分散ファサードの適切な 選択はセッション Bean である。 理由は、リモートオブジェクトでステートフルあるいはス テートレスであるからだ。 例では、 EJBコンテナ内部で一群の POJO (Plain Old Java Object) を実行し、リモートファサードとして設計されたセッション Bean を介しリモート でアクセスする。 セッション Bean は、 特に複雑なものではないので、 以前に取り扱ったこ とがなくても理解できるはずである。

2つの補足説明が必要である。 まず私にとって驚きなのだが、 Java では EJBコンテナ内 部でプレーンオブジェクトを実行できないと信じている人が多いように思える。 「ドメイン オブジェクトはエンティティ Bean ですか」という質問を耳にする。 答えは、そうではある が必要はないということである。 シンプルな Java オブジェクトは、例のようにとても有効 に機能する。

もう1つの補足説明は、これがセッション Bean を使う唯一の方法ではないということで ある。 セッション Bean は、 トランザクションスクリプトのホスト機能としても使うことが できる。

例では、音楽アルバムについての情報にアクセスするためのリモートインタフェースを考

416

える。 ドメインモデルは、 Artist、 Album、 Track を表すオブジェクトから構成されてい る。 周辺にアプリケーションにデータソースを提供する他のいくつかのパッケージがある (図 15.2 参照)。

図 15.2のdto パッケージには、回線を介してデータをクライアントに伝送するデータ変 換オブジェクトが含まれている。 オブジェクトは、シンプルなアクセッサーとして振る舞い、 さらにバイナリまたは XML テキストフォーマットで直列化する機能もある。 リモートバッ ケージには、ドメインオブジェクトとデータ変換オブジェクト間でデータを伝送するアセン ブラオブジェクトがある。 この機能の動作の詳細は、 データ変換オブジェクトの項を参照し てほしい。

api Album Home AlbumService remote AlbumServiceBean AlbumAssembler ArtistAssembler client dto ArtistDTO AlbumDTO TrackDTO domain Album Artist Track Player Registry

図 15.2 リモートインタフェースのパッケージ

ファサードの解説のため、データをデータ変換オブジェクトに入出力して、リモートイン タフェースを使えることとする。 1つの論理的なJava セッション Bean には、3つの実体ク ラスがある。 その中の2つはリモート API (実際はJava インタフェースでもある) を構成 し、もう1つは API を実装するクラスである。 2つのインタフェースは、 Albumservice と ホームオブジェクトのAlbumHome である。 ホームオブジェクトは、分散ファサードにアクセ スするための命名サービスに使われるが、ここではEJB の詳細は省略する。 ここでの焦点

は、リモートファサードつまり AlbumService である。 インタフェースは、クライアントが 使えるよう API パッケージで宣言されていて、単なるメソッドのリストである。

class AlbumService...

String play (String id) throws RemoteException; String getAlbumXml (String id) throws RemoteException; AlbumDTO getAlbum (String id) throws RemoteException; void createAlbum (String id, String xml) throws RemoteException; void createAlbum (String id, AlbumDTO dto) throws RemoteException; void updateAlbum (String id, String xml) throws RemoteException; void updateAlbum (String id, AlbumDTO dto) throws RemoteException; void addArtistNamed (String id, String name) throws RemoteException; void addArtist (String id, String xml) throws RemoteException; void addArtist (String id, Artist DTO dto) throws RemoteException; Artist DTO getArtist (String id) throws RemoteException;

この短い例でさえ、ドメインモデルの中に Artist と Album という2つの異なるクラス のメソッドを確認できる。 さらに、 同じメソッドだが少しだけ異なるバリエーションも確認 できる。データをリモートサービスに伝送するため、 メソッドにはデータ変換オブジェクト または XML 文字列を使うバリエーションがある。 クライアントは接続の環境に応じて使う 形式を選択できる。小規模のアプリケーションの場合でも AlbumService 上には多くのメ ソッドがある。

幸い、 メソッド自体はとてもシンプルなものである。 Album を処理するメソッドは以下 のとおりである。

class AlbumServiceBean...

public AlbumDTO getAlbum (String id) throws RemoteException ( return new AlbumAssembler().writeDTO (Registry.findAlbum (id));

public String getAlbumXml (String id) throws RemoteException {

AlbumDTO dto = new AlbumAssembler().writeDTO (Registry.findAlbum (id)); return âto.toXmlString();

public void createAlbum (String id, AlbumDTO dto) throws RemoteException ( new AlbumAssembler().createAlbum (id, dto);

public void createAlbum (String id, String xml) throws RemoteException ( AlbumDTO dto AlbumDTO.readXmlString (xml);

new AlbumAssembler().createAlbum (id, dto);

)

)

第1章 分散パターン

418

}

public void updateAlbum (String id, AlbumDTO dto) throws RemoteException { new AlbumAssembler().updateAlbum (id, dto);

}

public void updateAlbum (String id, String xml) throws RemoteException { AlbumDTO dto AlbumDTO.readXmlString (xml); new AlbumAssembler ().updateAlbum (id, dto);

メソッドは単に他のオブジェクトに委譲するだけなので、1行または2行に過ぎない。 こ の断片は、 分散ファサードがどうあるべきかを端的に表している。 つまり、 ロジックをほと んど含まないとても短いメソッドの長いリストである。 ファサードは、単にメカニズムを パッケージ化したものである。

テストに関する数行でこの例を完了させよう。 1つのプロセスで可能な限りのテストがで きるのはとても役立つ。 セッション Bean の実装用のテストを直接記述できる。 つまり EJB コンテナに配置することなく実行することができるのである

class XmlTester...

private AlbumDTO kob; private AlbumDTO newkob;

private AlbumServiceBean facade = new AlbumServiceBean(); protected void setUp() throws Exception { } facade.initializeForTesting(); kob = facade.getAlbum (kob"); Writer buffer = new Stringwriter(); kob.toXmlString (buffer); newkob= AlbumDTO.readXmlString (new StringReader (buffer.toString()))public void testArtist () { assertEquals (kob.getArtist (), newkob.getArtist());

これはメモリで実行する Junit テストの1つであった。 コンテナ外部で私がどのように セッション Bean のインスタンスを作成し、テストを実行したかを示したもので、所要時間 も短いテストである。

15.1.4 | 例: Web サービス (C#)

私は本書について Addison-Wesley 社の編集者である Mike Hendrickson と相談した。 常に最新の専門用語に注意するようにということで、彼は本書に Web サービスについての

:

)

用語があるかどうかと聞いてきた。 私は何でも流行に走ることは嫌いだが、 結局、 本の出版 の遅々としたペースを考えると、私が記述した 「最新の手法」 も読者が読むころには古風な ものになっているかもしれない。 最新のさまざまな技術的転換でも核心となるパターンは、 その価値を保つことができるが、そのことを示すよい例になるかもしれない。

第15章 分散パターン

根本的に Web サービスは、単にリモート用途のインタフェースである (速度の遅い文字 列解析ステップが付いてくるが)。 リモートファサードについての基本的なアドバイスは、 次のとおりである。 細かな方法で機能を構築し、 Web サービスを処理するため細かなモデ ル上にリモートファサードをレイヤ化するものである。

以前に解説した基本的な事項を使うが、ここでは1つの Album 情報のリクエストだけを 解説する。 図15.3 は、関与するさまざまなクラスを示している。 これらのクラスは次のグ ループに分類される。 Album Service (リモートファサード)、 2つのデータ変換オブジェ クト、ドメインモデルの3つのオブジェクト、 およびドメインモデルからデータを引き出し データ変換オブジェクトに挿入するアセンブラである。

-web service- AlbumService GetAlbum (key: String): AlbumDTO Album Assembler WriteDTO (Album): AlbumDTO Album Artist AlbumDTO Title: String * Name: String 1 * Artist: String |Tire: String TrackDTO Title: String Performers: Array of String * Track * Title: String

図 15.3 -Album (アルバム) Web サービスのクラス

4 20

ドメインモデルは、 他に例をみないほどシンプルである。 テーブルデータゲートウェイを 使ってデータ変換オブジェクトを直接作成した方が有効であるが、そうすると逆に、ドメイ ンモデル上にレイヤ化したリモートファサードに悪影響を及ぼす。

class Album...

public String Title; public Artist Artist; public IList Tracks { } get (return ArrayList. ReadOnly (tracks Data); } public void AddTrack (Track arg) ( } tracks Data. Add (arg); public void RemoveTrack (Track arg) ( } tracksData. Remove (arg); private IList tracks Data = new ArrayList();

class Artist...

public String Name;

class Track...

public String Title; public IList Performers ( } get (return ArrayList. ReadOnly (performers Data); } public void AddPerformer (Artist arg) { } performers Data. Add (arg); public void Remove Performer (Artist arg) { } performers Data. Remove (arg); private IList performers Data = new ArrayList();

私は、回線を介してデータを渡すのにデータ変換オブジェクトを使用する。 これらは単に Web サービスのために構造を平坦化するデータホルダーである。

class AlbumDTO...

public String Title;

public String Artist; public TrackDTO [] Tracks;

class TrackDTO...

public String Title; public String[] Performers;

これはNET なので、直列化と XMLへの復元を行うためコードを記述する必要はまった くない。 .NET フレームワークには、ジョブを実行するシリアライザクラスが付属している。 Webサービスなので、 データ変換オブジェクトの構造を WSDL で宣言する必要もある。 Visual Studio ツールはWSDLを生成する。 私は怠慢な方なので、このツールを使うつもり でいる。 データ変換オブジェクトのXML スキーマの定義は次のとおりである。

<s:complexType name="AlbumDTO">

<s:sequence> <s:element minOccurs="1" maxOccurs="1" name="Title" nillable="true" type="s:string" /> <s:element minOccurs="1" maxOccurs="1" name="Artist" nillable="true" type="s:string" /> <s:element minOccurs="1" maxOccurs="1" name="Tracks" nillable="true" type="s0: ArrayOfTrackDTO" />

</s:sequence>

</s:complexType>

<s:complexType name="ArrayOfTrackDTO">

<s:sequence>

<s:element minOccurs="0" maxOccurs="unbounded" name="TrackDTO" nillable="true" type="s0: TrackDTO" />

</s:sequence>

</s:complexType>

<s:complexType name="TrackDTO">

<s:sequence>

<s:element minOccurs="1" maxOccurs="1" name="Title"

nillable="true" type="s:string" />

<s:element minOccurs="1" maxOccurs="1" name="Performers" nillable="true" type="s0: ArrayOfString" />

</s:sequence>

</s:complexType>

<s:complexType name="ArrayOfString">

<s:sequence>

<s:element minOccurs="0" maxOccurs="unbounded" name="string"

nillable="true" type="s:string" />

第15章 分散パターン

422

</s:sequence> </s:complexType>

XML の詳細なデータ構造の定義であり、 これでジョブが実行される。 ドメインモデルからデータ変換オブジェクトへデータを渡すためアセンブラが必要である。

class AlbumAssembler...

public AlbumDTO WriteDTO (Album subject) { AlbumDTO result = new AlbumDTO(); result.Artist subject.Artist. Name; result.Title = subject.Title; ArrayList trackList = new ArrayList(); foreach (Track t in subject.Tracks) trackList. Add (WriteTrack (t)); result. Tracks = (TrackDTO []) trackList.ToArray (typeof (TrackDTO)); return result;

public TrackDTO WriteTrack (Track subject) { TrackDTO result = new TrackDTO(); result. Title = subject.Title; result. Performers = new String [subject. Performers. Count]; ArrayList performer List = new ArrayList(); foreach (Artist a in subject. Performers) performerList.Add (a.Name); result. Performers = (String[]) performerList.ToArray(typeof (String)); return result;

最後に必要なのは、サービス定義である。 最初にC#クラスから作成される。

class AlbumService...

}

[WebMethod] public AlbumDTO GetAlbum (String key) ( Album result = new AlbumFinder () [key]; if (result == null) throw new SoapException ("unable to find album with key: key, SoapException. Client Fault Code); else return new AlbumAssembler () .WriteDTO (result);

もちろんこれは、本来のインタフェース定義ではなく、 WSDL ファイルから作成される。 関連ビットは、以下のとおりである。

}

<portType name="AlbumServiceSoap">

<operation name="GetAlbum">

第15章 分散パターン

<input message="s0: GetAlbumSoapIn" />

<output message="s0: GetAlbumSoapOut" /> </operation>

</portType>

<message name="GetAlbumSoapIn">

<part name "parameters" element="s0: GetAlbum" /> </message>

<message name="GetAlbumSoapOut">

</message>

<part name="parameters" element="s0: GetAlbumResponse" />

<s:element name="GetAlbum">

<s:complexType>

<s:sequence>

<s:element minOccurs="1" maxOccurs="1" name="key"

nillable="true" type="s:string" />

</s:sequence>

</s:complexType>

</s:element>

<s:element name="GetAlbumResponse">

<s:complexType>

<s:sequence>

<s:element minOccurs="1" maxOccurs="1" name="GetAlbumResult"

nillable="true" type="s0: AlbumDTO" />

</s:sequence>

</s:complexType>

</s:element>

予想どおり WSDLは、 冗長であるがジョブを実行する。 これで私は、 SOAP メッセージ を送信してサービスを呼び出すことができる。

<?xml version="1.0" encoding="utf-8"?>

<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

xmlns:xsd="http://www.w3.org/2001/XMLSchema"

xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">

<soap:Body>

<GetAlbum xmlns="http://martinfowler.com">

<key>aKeyString</key>

</GetAlbum>

</soap:Body>

</soap:Envelope>

4 24

この例で忘れないでほしい重要な点は、 これらは、 SOAP と.NET を使った方法ではなく 基本的なレイヤ化手法である。 分散しないでアプリケーションを設計し、その一番上にリ モートファサードとデータ変換オブジェクトを置いて分散機能をレイヤ化するのである

152 | データ変換オブジェクト

メッセージ呼び出しの数を削減するため、プロセス間のデータを伝送するオブジェクト

AlbumDTO Album title: String title: String AlbumAssembler artist: String * toXmlElement readXml 1 Artist | name: String

リモートファサードなどリモートインタフェースで処理をする場合、 呼び出しには多大な コストがかかる。 その結果、 呼び出しの数を減らさなければならないが、これはそれぞれの 呼び出しでより多くのデータを転送する必要があるということである。 これを実行する1つ の方法は、 多くのパラメータを使うことだが、プログラムを複雑にする上、1つの値だけを 返すといった Java などの言語では、プログラムできない。

この解決策は、呼び出しの全データを保持できるデータ変換オブジェクトを作成すること である。それには、 接続全体を直列化する必要がある。 サーバ側では、データをDTO とド メインオブジェクト間で転送するのにアセンブラを使う。

Sun コミュニティの多くの人は、このパターンについて「バリューオブジェクト」という 用語を使っている。 私はこの用語を少し異なる意味で使っているので、 508 ページの解説を 参照することを勧める。

15.21 動作方法

広義の意味でデータ変換オブジェクトは、暗黙の了解オブジェクトとでも呼べるものであ る。これは単に一群のフィールドとget メソッドと set メソッドに過ぎないが、1つの呼び 出しで情報をネットワークを介し伝送できるので、分散システムでは不可欠である。

リモートオブジェクトが、何らかのデータを必要とする場合はいつでも、データ変換オブ

ジェクトを要求する。 データ変換オブジェクトは、リモートオブジェクトがリクエストする 以上のデータを保持できるが、今のところはリモートオブジェクトが必要とするデータを保 持するだけでよい。 リモートコールの待ち時間コストを考えても、 複数の呼び出しをして データを送り過ぎる失敗の方がまだましである。

データ変換オブジェクトには、1つのサーバオブジェクトだけではなく、それ以上のデー タが含まれている。これには、 リモートオブジェクトがデータを要求しそうな、すべての サーバオブジェクトからのデータが集積されている。 したがって、 リモートオブジェクトが Order オブジェクトのデータをリクエストする場合、 データ変換オブジェクトには、 Order、 Customer Line Items、 注文明細のProducts, Delivery Information (配送情報) など、 あらゆる種類の要素のデータが含まれている

ドメインモデルからオブジェクトを転送することはできない。 オブジェクトは、複雑に絡 み合って接続されているので、不可能ではないにしても直列化が困難というのがその理由で ある。さらにクライアントのドメインオブジェクトクラスを必要とはしない。 これはドメイ ンモデル全体をコピーすることと同じになるからであり、 その代わりドメインオブジェクト をシンプルにした形式のデータを転送する。

データ変換オブジェクトのフィールドは、 とてもシンプルでプリミティブであり、 文字列 や日付または他のデータ変換オブジェクトのようなシンプルなクラスである。 データ変換オ ブジェクト間の構造は、シンプルなグラフ構造 (階層構造) で、 ドメインモデルで解説する 複雑なグラフ構造とは対照的である。 データ変換オブジェクトは直列化可能であり、かつ回 線の両端で理解される必要があるので、このようなシンプルな属性を保持しなければならな い。結果としてデータ変換オブジェクトのクラスおよびそれらが参照するクラスは、両側に 必要である。

特定のクライアントのニーズを考えても、データ変換オブジェクトを設計することは合理 的である。 そのような理由から、 Web ページや GUI 画面に対応したデータ変換オブジェク トを見かけるのである。 さらに、 特定の画面に応じた複数のデータ変換オブジェクトも見か けることがある。プレゼンテーションが異なっても同様のデータが必要な場合に、1つの データ変換オブジェクトを使って、 処理する方が役立つ。

関連した問題で、相互作用全体に1つのデータ変換オブジェクトを使うか、 それともそれ ぞれのリクエストに対して異なるデータ変換オブジェクトを使うかということがある。 異な るデータ変換オブジェクトを使うと、 呼び出しでどのようなデータが転送されているかを把 握しやすくなるが、データ変換オブジェクトの数が増加する。 1つだけの場合は記述する手 間は省けるが、 呼び出しがどのように情報を転送するかを把握するのは困難になる。 私は、 データ全体に多くの共通点がある場合、1つだけを使うことにしている。 しかし特定のリク エストで示唆されている場合には、 データ変換オブジェクトは使わない。 総括的な規則をつ くることはできないからである。

1章 分散パターン

426

そのため私は、相互作用と一対のリクエストとレスポンスに対して、 1つのデータ変換オ ブジェクトを使うようにしている。

他の同様な問いとしては、リクエストとレスポンスの両方に1つのデータ変換オブジェク トを使うか、それともそれぞれに個別のデータ変換オブジェクトを使うかというものである。 繰り返しになるが、 総括的な規則はないので、データがほとんど同じであれば1つを使い、 大きく異なれば2つ使うのである。

中には、 データ変換オブジェクトを不変にしたいと考える人もいる。 このスキーマでは、 同じクラスの場合でさえクライアントから1つのデータ変換オブジェクトを受け取り、異な るデータ変換オブジェクトを作成し返信する。 リクエストであるデータ変換オブジェクトを 変更する人もいる。 私には、 どちらの方法がいいかについての明確な見解はないが、 全般的 には、レスポンス用に新しいオブジェクトを作成する場合でも、データを徐々に配置する方 が容易なので、 可変のデータ変換オブジェクトを好む。 不変のデータ変換オブジェクトを支 持する議論では、バリューオブジェクトとの命名の混乱を避ける必要がある。

データ変換オブジェクトの一般的な形式は、 レコードセットの形式である。 テーブルレ コードのセットでSQL クエリーによって返されるものである。 レコードセットは、SQL データベースのデータ変換オブジェクトであり、 アーキテクチャでは設計全体でそのレコー ドセットを使う。 ドメインモデルは、クライアントに転送してデータのレコードセットを生 成し、 セットをSQLから直接受け取ったかのように処理する。 レコードセット構造にバイ ンドするツールがクライアントにあれば役立つ。 レコードセットの全体をドメインロジック で作成することはできるが、それよりもプレゼンテーションに渡す前にSQLクエリーで生 成し、 ドメインロジックで変更する。 この形式は、 テーブルモジュールに適している。

データ変換オブジェクトの別の形式は、包括的なコレクションデータ構造である。 私はこ れに使われる配列を見たことがあるが、配列のインデックスがコードを不明瞭にしていて、 失望した。 最善のコレクションとは、キーとしてわかりやすい文字列を使うことができる ディクショナリである。 問題は、明示的なインタフェースと強制的な型定義のメリットを失 うことである。 手元に生成プログラムがない特定の状況では、ディクショナリを使う方が、 手作業で明示的なオブジェクトを記述するより処理しやすくなる。 しかし私は、生成プログ ラムで明示的なインタフェースを作成した方が賢明だと考える。 特に、異なるコンポーネン ト間の通信プロトコルとして使うことを考える場合は尚更である。

15.2.1.1 データ変換オブジェクトの直列化

シンプルなget メソッドと set メソッド以外に、 データ変換オブジェクトはそれ自体を直 列化して、 回線上を移動して何らかのフォーマットにする機能もある。 どのフォーマットか は、接続のいずれかの側に接続されているもの、 接続自体を介して伝送ができるもの、 直列 化の簡素化の方法などに左右される。 いくつかのプラットフォームでは、シンプルなオブ

ジェクトにビルトインの直列化機能を提供している。 たとえば Java には、 ビルトインのバ イナリ直列化機能があり、 .NET には、ビルトインのバイナリと XMLの直列化機能がある。 ビルトインの直列化を使う場合、 データ変換オブジェクトは、 ドメインモデルのオブジェク トにあるような複雑な処理をしないシンプルな構造なので、細かい粒度の設定をしなくても すぐに動作する。 そのため、私はできるだけ自動メカニズムを使う。

自動メカニズムがない場合、 自分自身でメカニズムを作成することができる。 シンプルな レコード記述を取り込み、 データを保持する適切なクラスの生成、アクセッサーの提供、お よびデータの直列化の読み書きを行ういくつかのコード生成プログラムを見たことがある。 重要なことは、 生成プログラムは必要な分だけにとどめ、自分だけが必要と考える機能を組 み込まないようにすることである。 最初のクラスは手作業で記述し、 それを使って生成プロ グラムの記述に役立てることはよい考え方である。

さらに、リフレクティブプログラミングを直列化の処理に使うこともできる。 この場合必 要なのは、 直列化ルーチンと非直列化ルーチンを一度記述し、スーパークラスに組み込むこ とである。 これはパフォーマンスを低下させることがあるので、その場合は調査測定する必 要がある。

その場合、 接続の両端が協調するメカニズムを選択する。 両端を制御している場合は、 容 易な方を選ぶ。 そうでない場合は、 所有していない方の終端にコネクターを供給できる。 そ して接続の両側でシンプルなデータ変換オブジェクトを使い、 外部のコードに適合させるた めコネクターを使う。

データ変換オブジェクトで直面する一般的な問題の1つは、 直列化形式をテキストまたは バイナリのどちらにするかということである。 テキストの直列化の場合、 読み込みが容易な ので何が通信されているかもすぐにわかる。 XML は、 簡単に XML 文書の作成および解析 を行うツールを入手できるので人気がある。 テキストを使う場合の大きな欠点は、同じデー タを送信するのに広いバンド幅が必要なため (特に XMLではそのようなことがある)、パ フォーマンスが犠牲になりかなり深刻になる場合があることだ。

直列化で重要なのは、両側のデータ転送オブジェクトの同期化である。理論的には、サー バがデータ変換オブジェクトの定義を変更すると直ちに、 クライアントも同様の更新をする はずだが、実際のところこれがうまくいかない場合がある。旧式のクライアントでサーバに アクセスすると必ず問題が発生するが、直列化のメカニズムが問題を多かれ少なかれ困難な ものにすることがある。 データ転送オブジェクトの純粋なバイナリ直列化の場合、 構造に対 するいかなる変更も通常非直列化でエラーの原因となるため、通信は完全に失われてしまう。 オプションのフィールドを追加するなどのたいしたことのない変更でさえ、この影響を被る ことがある。 結果的に、 直接的なバイナリ直列化で、 通信回線の脆弱性が高くなるというこ とである。

別の直列化スキーマを使うと、この状況を回避できる。 その1つは XML の直列化で、 ク

4 28

第1章 分散パターン

ラスの変更に耐性を強化した方法で記述することができる。 もう1つは、ディクショナリを 使ったデータの直列化などの、耐性を強化したバイナリ手法である。 私はデータ変換オブ ジェクトとしてのディクショナリを好まないが、一定の耐性を同期化に組み込むので、デー タをバイナリ直列化する場合の有効な方法と思われる。

15.2.1.2 ドメインオブジェクトからのデータ変換オブジェクトの組み立て

データ変換オブジェクトは、 ドメインオブジェクトとのつながりがわからない。 それは、 接続の両側にデータ変換オブジェクトを配置するからである。 このため、 データ変換オブ ジェクトをドメインオブジェクトに依存させたくない。 さらに、 インタフェースフォーマッ トの変更時にデータ変換オブジェクトの構造は変わるので、ドメインオブジェクトはこれに 依存させたくない。 原則的にドメインモデルは外部インタフェースから独立させている。

そのため、 ドメインモデルからのデータ変換オブジェクトの作成およびドメインモデルの 更新の機能を果たす個別のアセンブラオブジェクトをつくる (図15.4)。 アセンブラは、 データ変換オブジェクトとドメインオブジェクト間のマッピングを行うのマッパーの一例で ある。 同じデータ変換オブジェクトを共有する複数のアセンブラが存在する場合もある。 こ のよくある例は、 同じデータを使う、 異なるシナリオの更新セマンティクスである。 アセン ブラを独立させるもう1つの理由は、 データ変換オブジェクトはシンプルなデータ記述から 容易に自動的に生成できるためである。 アセンブラの生成は困難で、普通は不可能である。

DomainObject Assembler createData TransferObject (DomainObject) updateDomainObject (Data TransferObject) createDomainObject (Data TransferObject) Data TransferObject serialize deserialize

アセンブラオブジェクトは、ドメインモデルとデータ変換オブジェクトを互いに独立させる。

図 15.4

15.2.2 使用するタイミング

2つのプロセス間の1つのメソッド呼び出しで、 複数のデータ項目を転送する場合は、い つでもデータ変換オブジェクトを使ってかまわない。

私が推奨するわけではないが、 データ変換オブジェクトには、いくつかの代替方法がある。 その1つは、オブジェクトをまったく使わないで、単に多くの引数を持つ set メソッドまた は受け渡し参照引数を持つget メソッドを使う方法である。 この方法の問題点は、 Java な どの多くの言語では戻り値として使えるオブジェクトが1つだけなので、更新には使えるが、 適切なコールバックなしでは情報検索に使えないことである。

もう1つの代替方法は、インタフェースとして機能するオブジェクトを使わずに、 何らか の形式の文字列表現を直接使う方法である。 この方法の問題は、他も文字列表現と連結され ることである。 明示的なインタフェースの裏側の表現を隠ぺいするには良い方法で、文字列 を変更したり、 文字列をバイナリ構造に置き換えたりしたい場合、 他に何も変更する必要は ない。

特に、XML でコンポーネント間の通信をしたい場合、 データ変換オブジェクトを作成す る価値がある。 XML DOM は、 処理上の悩みの種であるが、 データ変換オブジェクトはと ても簡単に生成できるので、 XML DOM のカプセル化にとても役立つ。

データ変換オブジェクトが使われる他の目的は、 異なるレイヤのさまざまなコンポーネン トの共通データソースとしての機能である。 コンポーネントは、データ変換オブジェクトに 何らかの変更を加え次のレイヤに渡す。 COM や.NET におけるレコードセットはこの好例 である。この場合、各レイヤはデータをベースとしたレコードセットの処理方法を認識して いて、それがSQL データベースから直接取得したものか、または他のレイヤで変更された ものかどうかを認識できる。 .NET は、 レコードセットをXML に直列化するビルトインメ カニズムを提供して機能を拡張している。

本書は同期システムに焦点を合わせているが、 データ変換オブジェクトの非同期にも興味 深いものがある。 インタフェースを同期と非同期の両方で使いたい場合を取り上げる。 同期 の場合は、データ変換オブジェクトを返し、 非同期の場合は、データ変換オブジェクトのレ イジーロードを作成し、それを返す。 レイジーロードを、 非同期呼び出しの結果が現れる場 所と接続する。 データ変換オブジェクトは、 呼び出しの結果へアクセスしようとする場合に ブロックされる。

1523 参考文献

[Alur et al.jは、バリューオブジェクトの名でパターンを検討しているが、これは前述し たデータ変換オブジェクトと同様である。 私のバリューオブジェクトはまったく異なるパ ターンだ。同じ名前が異なる意味に使われているわけだが、ほとんどの人は私が使う意味で もバリューオブジェクトを使っている。 言えることとしては、私がデータ変換オブジェクト を使っているのは、J2EE コミュニティ内においてだけであり、 普通は一般的な用法に従っ てきたということである。

第15章 分散パターン

4 3 0

バリューオブジェクトアセンブラ [Alur et al. Jは、アセンブラの検討事項である。 私は マッパーベースの名前ではなくアセンブラ関連の名前を使うが、個別のパターンにすること はしない。

[Marinescu]はデータ変換オブジェクトの実装バリエーションについて検討し、 [Riehle et al] は直列化の異なる形式間の切り換えも含め、 直列化の柔軟な方法について検討している。

15.2.4 例: Album についての情報の転送 (Java)

例では、 図 15.5のドメインモデルを使う。 転送したいデータは、リンクされたオブジェ クトについてのデータで、 データ変換オブジェクトの構造は図15.6に示している。

データ変換オブジェクトは、この構造をとてもシンプルにする。 Artist クラスからの関連 データは Album DTO に凝縮され、 Track のパフォーマーは文字列で表現される。 これは、 データ変換オブジェクトの標準的な構造の凝縮である。

Album 1 title: String * 1 * Track title: String Artist Album のクラス図 Artist name: String * performers AlbumDTO TrackDTO title: String title: String artist: String 1 * performers: Array of String

15.5

図 15.6 データ変換オブジェクトのクラス図

2つのデータ変換オブジェクトがあり、1つはAlbum 用で、 もう1つは各 Track 用であ る。この場合、データは他の2つの内の1つに存在するので、 Artist 用のデータ変換オブ ジェクトは必要ない。 Album にはいくつかのTrack があり、それぞれに1つ以上のデータ

第1章 分散パターン

項目が含まれている可能性があるので、 変換オブジェクトとして Track があれば十分である。 ドメインモデルからデータ変換オブジェクトを記述するためのコードは、以下のとおりで ある。 アセンブラは、リモートファサードなど、 リモートインタフェースを処理するいずれ かのオブジェクトから呼び出される。

class AlbumAssembler...

public AlbumDTO write DTO (Album subject) ( AlbumDTO result = new AlbumDTO (); result.setTitle (subject.getTitle()); result.setArtist (subject.getArtist ().getName()); writeTracks (result, subject); return result;

private void writeTracks (AlbumDTO result, Album subject) { List newTracks = new ArrayList(); Iterator it subject.getTracks () .iterator(); while (it.hasNext()) { } TrackDTO newDTO = new TrackDTO (); Track thisTrack = (Track) it.next(); newDTO.setTitle (this Track.getTitle()); write Performers (newDTO, thisTrack); newTracks. add (newDTO); result.setTracks ((TrackDTO []) newTracks.toArray (new TrackDTO

}

[0]));

}

private void write Performers (TrackDTO dto, Track subject) { List result = new ArrayList(); Iterator it subject.getPerformers () .iterator(); while (it.hasNext()) { } Artist each (Artist) it.next(); result.add(each.getName()); dto.setPerformers ((String()) result.toArray (new String[0])); }

データ変換オブジェクトからモデルを更新するためには、 普通はさらにコードが必要であ る。 例では、新しい Album の作成と既存の Album の更新には違いがある。 作成のための コードは以下のとおりである。

4 32

class AlbumAssembler...

public void createAlbum (String id, AlbumDTO source) {

Artist artist = Registry.findArtistNamed (source.getArtist()); if (artist == null)

throw new RuntimeException("No artist named source.getArtist()); Album album = new Album (source.getTitle(), artist); createTracks (source.getTracks (), album); Registry.addAlbum (id, album);

private void createTracks (TrackDTO[] tracks, Album album) (

for (int i = 0; i < tracks.length; i++) (

Track newTrack = new Track (tracks [i].getTitle());

album.addTrack (newTrack);

createPerformers (newTrack, tracks [i].getPerformers ());

private void createPerformers (Track newTrack, String[] performer Array) ( for (int i = 0; i < performer Array.length; i++) { Artist performer = Registry.findArtist Named (performerArray[i]); if (performer == null) throw new RuntimeException("No artist named "+performerArray[i]); newTrack.addPerformer (performer); } }

DTO の読み込みには、 多くの決定事項が必要になる。 注目は Artist の名前が入ってくる 時の、その名前の処理方法である。 私の要件としては、 Album の作成時に、 すでに Artist がレジストリにあることで、 Artist が見つからない場合エラーとなる。 異なる生成メソッド では、データ変換オブジェクトで名前が言い渡されている時に、 Artist を作成することにす るものもある。

例では、既存の Album の更新には異なるメソッドを使っている。

class AlbumAssembler...

public void updateAlbum (String id, AlbumDTO source) {

Album current Registry.findAlbum (id);

if (current == null) throw new RuntimeException("Album does

not exist: "+source.getTitle());

if (source.getTitle() != current.getTitle())

}

current.setTitle(source.getTitle());

if (source.getArtist () != current.getArtist ().getName()) {

}

)

Artist artist = Registry.findArtistNamed (source.getArtist()); if (artist == null) throw new RuntimeException("No artist

第15章 分散パターン

named source.getArtist()); current.setArtist (artist);

)

updateTracks (source, current);

}

private void updateTracks (AlbumDTO source, Album current) { for (int i = 0; i < source.getTracks ().length; i++) { current.getTrack (i).setTitle (source.getTrackDTO (i).getTitle()); current.getTrack (i).clear Performers (); createPerformers (current.getTrack (i),

source.getTrackDTO (i).getPerformers ());

更新する際には、既存のドメインオブジェクトを更新するか、 既存のものを破棄し、 新し いものに置き換えるかを決定する。 ここで生じる疑問は、更新したいオブジェクトを参照す る他のオブジェクトがあるかどうかである。 このコードの場合、 Album と Track を参照す る他のオブジェクトがあるのでAlbum を更新するが、 Track のタイトルとパフォーマーに ついては、単にそこにあるオブジェクトに置き換えている。

別の疑問は、 Artist の変更についてである。 既存の Artist の名前の変更だろうか、また は Album のリンク先のArtist の変更だろうか。 ケースバイケースで解決する必要があり、 私はリンク先を新しい Artist にすることで処理している。

例では、ネイティブバイナリの直列化を使っているので、回線両側のデータ変換オブジェ クトの各クラスが同期を保つよう注意する必要がある。 サーバのデータ変換オブジェクトの データ構造を変更し、クライアントは変更しないままの場合、 転送でエラーが発生すること もある。 直列化にマッピングすることで、 転送の耐性を強化することができる。

class TrackDTO...

public Map writeMap() { Map result = new HashMap(); result.put("title", title); result.put("performers", performers); return result;

public static TrackDTO readMap (Map arg) {

TrackDTO result = new TrackDTO();

result.title = (String) arg.get("title");

result.performers = (String[] arg.get("performers");

4 34

} return result;

次に、フィールドをサーバに追加し、 以前のクライアントを使う場合、 新しいフィールド はクライアントが受け取らないがデータは正常に転送される。

このような直列化と非直列化のルーチンを記述することは、単調な作業である。 私はレイ ヤスーパータイプ上などにある自己反映的ルーチンを使うことで、単調な作業の大半を回避 している。

class DataTransferObject...

public Map writeMapReflect() { Map result = null; try ( Field[] fields = this.getClass().getDeclaredFields(); result = new HashMap(); for (int i = 0; i < fields.length; i++) result.put(fields[i].getName(), fields[i].get(this)); } catch (Exception e) { throw new ApplicationException (e); } return result;

} public static TrackDTO readMapReflect (Map arg) { TrackDTO result = new TrackDTO(); try { Field [] fields = result.getClass().getDeclaredFields (); for (int i = 0; i < fields.length; i++) fields[i].set (result, arg.get (fields[i].getName())); }catch(Exception e) { throw new ApplicationException (e); } return result;

ルーチンで、ほとんどのケースが処理される (プリミティブを処理するにはコードを余分 に追加する必要がある)。

15.2.5 例: XML を使用する直列化 (Java)

解説してきたとおり、 Java による XML 処理はとても流動的で、 不安定な API も全般的 に良くなりつつある。 読者がここまで読み進む頃には、本項は時代遅れの古い情報になって

第1章 分散パターン

いるかもしれないが、 XML への変換の基本概念はほとんど同じである。

最初に、データ変換オブジェクトからデータ構造を入手し、 直列化を決定する必要がある。 Java では、マーカーインタフェースを使うことで、自由にバイナリ直列化を行える。 デー タ変換オブジェクトの場合、 作業は完全自動化されていて、 私も最初に選択するのはこれで ある。 しかし、テキストベースの直列化も必要とされる。 例では XML を使っている。

この例の場合、 XML の処理が W3C 規格のインタフェースより容易なので、JDOM を 使っている。 データ変換オブジェクトクラスであるクラスを表現するための、XML要素の 読み書きをするメソッドを記述する。

class AlbumDTO...

Element toXmlElement() { Element root = new Element("album"); root.setAttribute("title", title); root.setAttribute("artist", artist); for (int i = 0; i < tracks.length; i++) root.addContent(tracks[i].toXmlElement()); return root;

static AlbumDTO readxml (Element source) { AlbumDTO result = new AlbumDTO (); result.setTitle(source.getAttributeValue("title")); result.setArtist (source.getAttributeValue("artist")); List trackList = new ArrayList(); Iterator it = source.getChildren ("track").iterator(); while (it.hasNext()) trackList.add(TrackDTO.readXml ( (Element) it.next())); result.setTracks ((TrackDTO []) trackList.toArray (new TrackDTO[return result;

0]));

}

class TrackDTO...

Element toXmlElement() { Element result = new Element ( "track"); result.setAttribute("title", title); for (int i = 0; i < performers.length; i++) { } Element performer Element = new Element("performer"); performer Element.setAttribute("name", performers[i]); result.addContent (performer Element); return result;

}

}

436

static TrackDTO readXml (Element arg) { TrackDTO result = new TrackDTO (); result.setTitle (arg.getAttributeValue("title")); Iterator it arg.getChildren("performer").iterator(); List buffer = new ArrayList(); while (it.hasNext()) ( } Element eachElement = (Element) it.next(); buffer.add(eachElement.getAttributeValue("name")); result.setPerformers ((String[]) buffer.toArray (new String [0]return result;

));

}

もちろんこれらのメソッドは、 XML DOM の要素を作成するだけである。 直列化を行う には、テキストを読み書きする必要がある。 Track は、 Album のコンテキストに合わせて 転送されるので、 必要なのはこのAlbum のコードを記述するだけである。

class AlbumDTO...

public void toXmlString (Writer output) { Element root = toXmlElement(); Document doc = new Document (root); XMLOutputter writer = new XMLOutputter(); try { writer.output (doc, output); } catch (IOException e) { e.printStackTrace(); } } public static AlbumDTO readXmlString (Reader input) { try { SAXBuilder builder = new SAXBuilder(); Document doc = builder.build(input); Element root = doc.getRootElement(); AlbumDTO result readXml(root); return result; } catch (Exception e) { e.printStackTrace(); throw new RuntimeException();

難しいことではないと思うが、JAXB によってこの種の要素が不必要なものになることを 期待している。

第16章 分散パターン

4 38

オフライン並行性パターン

|16.1| 軽オフラインロック

(by David Rice)

コンフリクトの検出とトランザクションのロールバックによって、同時に発生するビジ ネストランザクション間のコンフリクトを防止する。

Martin's Session Database David's Session getCustomer 129 return customer 129 getCustomer 129 edit customer return customer 129 update customer 129 rollback failure: wrong customer version update customer 129 System Transaction Boundary edit customer Business Transaction Boundary

16

ビジネストランザクションは、一連のシステムトランザクションにまたがって実行される 場合が多い。 一旦、1つのシステムトランザクションの領域外に出た場合、 データベースマ ネージャーだけに頼っていたのでは、ビジネストランザクションが確実に一貫した状態でレ コードデータを保持し続けることはできない。 2つのセッションが同じレコードで処理を開 始すると、データ整合性は危険な状態になり、 更新が無効になる可能性が十分ある。 さらに、 あるセッションが読み込み中のデータを別のセッションが編集すると、 同様に一貫性のない 読み込みも発生する可能性がある。

軽オフラインロックは、この問題の解決策として、1つのセッションでコミット予定の変 更が別のセッションの変更とコンフリクトしないよう妥当性確認を行う。 事前コミット妥当 性確認が正常に行われるということはつまり、レコードデータへの変更開始の承認を示す ロックを取得できるということである。 妥当性確認と更新が1つのシステムトランザクショ ン内で発生する限り、ビジネストランザクションは一貫していると言える。

重オフラインロックは、セッションコンフリクトの可能性が高いので、システムの並行性 を制限することを前提としているのに対し、 軽オフラインロックはコンフリクトの可能性が 低いことを前提としている。 セッションコンフリクトが発生する可能性は少ないという予想 の下で、複数のユーザが同時に同じデータを処理することができる。

16.1.1 動作方法

軽オフラインロックは、1つのセッションがレコードをロードし、 別のセッションがレ コードを修正していない時点で妥当性確認を行うことによって取得できる。 軽オフライン ロックはいつでも獲得できるが、取得したシステムトランザクションの間だけ有効である。 したがって、ビジネストランザクションはレコードデータとコンフリクトしないように、 データベースに変更を行うシステムトランザクション間の変更セットの各メンバに対して、 軽オフラインロックを獲得する必要がある。

最も一般的な実装は、システムのバージョン番号と各レコードを関連付けることである。 レコードがロードされると、 番号は他のすべてのセッションステートとともにセッションに よって保持される。 軽オフラインロックを取得することは、セッションデータに格納されて いるバージョンとレコードデータの現行バージョンを比較することである。 妥当性確認が正 常に行われると、 バージョンの増分を含むすべての変更をコミットできるようになる。 バー ジョンの増分により、旧バージョンのセッションがロックを獲得できないので、一貫性のな いレコードデータを防止することができる。

RDBMS データストアの場合、妥当性確認は、バージョン番号をレコードの更新または削 除に使われる SQL 文の基準に追加することである。1つのSQL文で、ロックの獲得と、 レ コードデータの更新の両方を行うことができる。 最終ステップは、ビジネストランザクショ

第16章 オフライン並行性パターン

0

ンがSQL の実行によって返される行カウントを検査することである。 行カウントの1は正 常終了を示し、 0はレコードがすでに変更または削除されていることを示す。 行カウントが 0の場合、 ビジネストランザクションはシステムトランザクションをロールバックし、レ コードデータに何らかの変更を行うことを防止する。 この時点で、ビジネストランザクショ ンは、コンフリクトの解決と再試行の中止または試行のいずれかを行う。

各レコードのバージョン番号の他に、並行性コンフリクトを管理する場合、 だれが最後に レコードを修正したか、 いつ修正するのが有効かについての情報を格納する。 ユーザに並行 性違反による更新失敗を通知する場合、 適切なアプリケーションを使用することによって、 いつ、だれがレコードを修正したかを伝える。 軽チェックに、バージョンカウントではなく 修正したタイムスタンプを使用することは勧められない。 その理由は、システムクロックは まったく信頼性がないためである。 特に、 複数のサーバ全体を調整する場合には信頼性がな くなる。

代替実装の場合、更新の where 句には行のすべてのフィールドが含まれる。 メリットは、 何らかの形式の Version (バージョン) フィールドを使うことなく where 句を使えること である。これは、データベーステーブルを修正して Version フィールドを追加できない場合 に役立つ。 問題点は、 これによって where 句が長大になり、 UPDATE 文を複雑化してし まうことである。 さらにデータベースが適切にプライマリキーインデックスを使えるかどう かによっては、パフォーマンスに影響を与える可能性もある。

Session SELECT Customer edit Customer Database System Transaction Boundary UPDATE Customer return row count Check row count is UPDATE Customer SET. ... version = (session's copy of version + 1) WHERE id = ? and version session's copy of version

UPDATE 文の軽チェック

図 16.1

軽オフラインロックを実装すると、 UPDATE 文と DELETE 文にバージョンを含んでい ないので、一貫性のない読み込みの問題を解決することができなくなる。 料金設定と適切な 売上税の計算を行う請求システムを考えてみる。 1つのセッションが料金を設定し、それに 加算する税金を計算するため Customer の Address を調べる。 しかし料金生成セッション 中に、別の Customer 保守セッションが、 Customer の Address を編集する場合がある。 税率は所在地に左右されるので、 料金生成セッションによって計算された税率は無効になる はずである。 しかし、 料金生成セッションは、コンフリクトが検出されない場合には Address を一切変更しない。

軽オフラインロックを、 一貫性のない読み込みの検出に使えないという理由はない。 上記 の例の場合、料金生成セッションは正確性がCustomer の Address の値に左右されてしま うことを認識しなければならない。 したがって、 料金生成セッションは Address に対して もバージョンチェックを行う必要がある。 これは、 Address を変更セットに追加すること、 またはバージョン確認された項目の個別のリストを保持することによって実行できる場合が ある。 後者の場合、設定に若干作業負荷が増えるが、より明確なコードによって一貫性のあ る読み込みを実現できる。 人為的更新ではなく、単にバージョンの再読み込みで一貫性のあ る読み込みをチェックする場合、 特にシステムトランザクションの分離レベルを認識してほ しい。 バージョンの再読み込みは、 繰り返しできる読み込みまたはより明確な分離を行う場 合にだけ有効である。 分離レベルが低い場合は、必ずバージョンの増分が必要となる。

一貫性のない読み込みの任意の問題に対しては、バージョンチェックを行うほどではない 場合がある。 トランザクションはレコード、 またはフィールドの1つの値にだけ依存してい ることがある。 その場合、同時更新がビジネストランザクションのコンフリクトを発生させ ることがほとんどないため、バージョンではなく状態をチェックすることでシステムの稼働 率を向上できることがある。 並行性問題の理解が進むにつれ、さらにその問題をコードで管 理することができるようになる。

ロックは、 オブジェクトのグループを1つのロック可能な項目として扱うことによって、 一貫性のない読み込みの特定の難問に対処するのに役立つ。 別の選択肢は、単に長時間継続 するトランザクション内に問題になりそうなビジネストランザクションのステップを実行す ることである。 実装が簡単であるため、 散在する数個のロングトランザクションを使うとき には、リソースのヒットに有効な場合がある。

トランザクションが特定のレコードの読み込みではなく、 動的なクエリーの結果に依存し ている場合、一貫性のない読み込みの検出は少し難しくなる。 軽オフラインロックの取得方 法として、最初の結果を保存し、 コミット時の同じクエリーの結果と比較することができる。

ロックメカニズムと同様に、 ビジネスアプリケーションの複雑な並行性や一時的な問題に よっては、軽オフラインロックそれ自体では適切な解決策を提供することができないことが ある。 ビジネスアプリケーションの並行性管理が、 技術的問題であるのと同様にドメインの

第16章 オフライン並行性パターン

442

問題でもあることを強調しておく。 上記のCustomer Address のシナリオは、本当にコン フリクトだろうか。 Customer の旧バージョンで売上税の計算することでも問題ないかもし れないが、どのバージョンを使うべきだろうか。 これはビジネス上の問題である。 あるいは、 コレクションを考えてほしい。 2つのセッションが同時に項目を1つのコレクションに追加 すると、 どうなるだろうか。 一般的な軽オフラインロックスキームでは、確実にビジネス ルールに違反している場合でもこれを防止できない。

習得すべき軽オフラインロックを使った1つのシステムが、 ソースコード管理 (SCM) である。 SCM システムは、プログラマ間にコンフリクトを発見した場合、適切なマージで 解決し、コミットを再試行することができる。 上位のマージメカニズムによって、システム の並行性がとても優れたものになるからだけでなく、 ユーザが何らかの作業を再度行う必要 がほとんどなくなるため、 軽オフラインロックがとても強力なものとなる。 もちろん、 SCM システムとエンタープライズビジネスアプリケーションの大きな相違点は、 SCMが1種類 のマージを実装するのに対し、 ビジネスシステムは何百ものマージを実装する点である。 中 にはとても複雑なため、コーディングのコストをかけるだけの価値がないものもある。 ビジ ネスにおいてとても価値があるため、マージを何とかしてコーディングすべきものもある。 ほとんど行われることはないが、ビジネスオブジェクトのマージも可能である。 ビジネス データのマージは、それ自体でパターンである。 テーマを台無しにしないためそれには触れ ないでおく。 しかし、マージで軽オフラインロックを追加する機能を理解してほしい。

ビジネストランザクションがコミットする場合、 軽オフラインロックだけが最後のシステ ムトランザクション中に通知してくる。 しかし、 コンフリクトが発生するとき、 早期に通知 されることが役立つ場合がある。 この場合、他のだれかがデータを更新しているかどうかを チェックする checkCurrent メソッドを使うことができる。 これによってコンフリクトにな らないとは保証できないが、 事前にコミットしないと通知できる場合、 複雑なプロセスを中 止できることが有効な場合がある。 失敗の早期チェックが役立つことがある場合には常に、 check Current を使ってほしい。 しかしコミット時に失敗しないという保証には決してなら ないことを忘れないでほしい。

16.1.2 使用するタイミング

軽い並行性管理は、いずれか2つのビジネストランザクション間のコンフリクトの可能性 が低い場合に適切である。 コンフリクトが起こりそうな場合、 ユーザが作業を終了しコミッ トの用意ができているときだけ通知するようでは、ユーザフレンドリーとは言えない。 結局、 ユーザはビジネストランザクションが失敗したと思い、システムを中止する。 コンフリクト の可能性が高い場合や、 コンフリクトによる犠牲を受け入れられない場合、重オフライン ロックの方が適している

第16章 オフライン並行性パターン

ただし、軽ロックは実装しやすく、 重オフラインロックで起こるような欠点や実行時エ ラーが発生しにくいため、構築するシステムにおけるビジネストランザクションコンフリク ト管理のデフォルトの手法として使うことを考えてほしい。 重いバージョンは、軽いバー ジョンを補完することもある。 コンフリクトを防止するために、重い手法をいつ使うべきか ではなく、軽い手法だけでは不十分なのはどんな時かと自問していただきたい。

並行性管理の適切な手法は、データに対する同時アクセスを最大限にする一方で、コンフ リクトを最小限にするものである。

16.1.3 例: データマッパーによるドメインレイヤ (Java)

軽オフラインロックの最も短い例には、 Version 列を含むデータベーステーブルと、 更新 基準の一部としてバージョンの UPDATE 文と DELETE文だけが必要なはずである。 も ちろん、読者はより洗練されたアプリケーションを構築するだろう。 そこでドメインモデル とデータマッパーを使う実装を示す。 これで軽オフラインロックを実装するときに生じる問 題がさらに明確になる。

行うべき最初の作業の1つは、ドメインのレイヤスーパータイプが、 軽オフラインロック の実装に必要なあらゆる情報、つまり修正とバージョンのデータを格納可能かどうかを確認 することである。

class DomainObject...

private Timestamp modified; private String modifiedBy; private int version;

データはリレーショナルデータベースに格納されているので、テーブルにはバージョン と修正のデータも格納されていなければならない。 customer テーブルのほか、 軽オフライ ンロックのサポートに必要とされる標準的な CRUD SQL のスキーマは、以下のとおりで ある。

table customer...

create table customer (id bigint primary key, name varchar, createdby varchar, created datetime, modifiedby varchar, modified datetime, version int)

SQL customer CRUD... INSERT INTO customer VALUES (?, ?, ?, ?, ?, ?, ?)

SELECT * FROM customer WHERE id = ?

UPDATE customer SET name = ?, modifiedBy= ?, modified = ?,

version = ? WHERE id = ? AND version= ?

DELETE FROM customer WHERE id = ? AND version = ?

いったん数個以上のテーブルやドメインオブジェクトを持つようになると、 O/Rマッピ ングの単調で繰り返しの多いセグメントを処理するデータマッパーのために、レイヤスー パータイプを導入したくなる。 これは、 データマッパーを記述する際の多くの作業を省くだ けではない。 暗黙ロックを使うことによって、 開発者がロック手順の一部のコーディングを 忘れ、 ロックの組み込みを忘れてしまうことを防止することができる。

抽象マッパーに入力する最初の部分は、 SQL の構築である。 マッパーにテーブルに関す るわずかなメタデータを提供する必要がある。 マッパーが実行時に SQL を構築するように するための代替方法は、 SQL のコードを生成することである。 しかし、これは読者の自習 に任せ、SQL文の構築には手をつけないことにする。 以下の抽象マッパーでは、 修正デー タの列名と位置についていくつかの仮説を立てた。 これによってレガシーデータを使う場合 の実行可能性が低下する。 抽象マッパーは、 それぞれの具象マッパーから供給される若干の 列メタデータを必要とする可能性がある。

抽象マッパーはSQL文を持つと CRUD 動作を管理することができる。 find メソッドを 実行する方法は、以下のとおりである。

class AbstractMapper...

public AbstractMapper (String table, String[] columns)(

this.table = table;

this.columns=columns;

buildstatements();

} public DomainObject find (Long id) ( DomainObject obj = AppSessionManager.getSession().getIdentityMap().if (obj == null) { Connection conn = null; PreparedStatement stmt = null; ResultSet rs = null; try ( conn = ConnectionManager. INSTANCE.getConnection (); stmt = conn.prepareStatement (loadSQL); stmt.setLong (1, id. longValue()); rs = stmt.executeQuery(); if (rs.next()) ( obj = load (id, rs);

get(id):

String modifiedBy = rs.getString (columns.length + 2); Timestamp modified = rs.getTimestamp (columns.length + 3); int version = rs.getInt(columns.length + 4);

AppSessionManager.getSession().getIdentityMap().put(obj); }else{

1 オフライン並行性パターン

throw new SystemException (table + "" + id + " does not exist");

)

} catch (SQLException sqlEx) (

throw new SystemException("unexpected error finding + table +

id);

} finally {

cleanupDBResources (rs, conn, stmt);

return obj;

少し注釈を加えよう。 最初にマッパーは、一意マッピングをチェックし、 オブジェクトが ロード済みではないことを確かめる。 一意マッピングを使わないと、 ビジネストランザク ションで異なる時間にロードされている、 異なるバージョンのオブジェクトをもたらすこと になる。 これはアプリケーションに定義されていない振る舞いを行う結果となり、またすべ てのバージョンチェックが混乱することにもなる。 結果群が取得されると、マッパーは抽象 load メソッドに従い、 具象マッパーは抽象load メソッドを実装して、 フィールドの抽出と アクティブなオブジェクトを返す。 マッパーは setSystemFields () を呼び出し、 抽象ドメ インオブジェクトにバージョンと修正データを設定する。 このデータを渡す方法としてはコ ンストラクタの方が適切に思えるかもしれないが、 コンストラクタを使うと、バージョンを 格納する責任の一部をそれぞれの具象マッパーやドメインオブジェクトが担うことになるた め、暗黙ロックが弱体化することになる。

具象load() メソッドは、以下のとおりである。

class CustomerMapper extends AbstractMapper...

protected DomainObject load (Long id, ResultSet rs) throws SQLException { String name = rs.getString (2); return Customer.activate (id, name, addresses); )

抽象マッパーも同様に、 更新および削除動作の実行を管理する。 このジョブは、データ ベースの動作が1の行カウントを返すかどうかをチェックすることである。 行がまったく更

}

}

protected abstract DomainObject load (Long id, ResultSet rs) throws SQLException;

新されない場合、 軽ロックを取得できず、マッパーは並行性例外を起こす必要がある。 削除 動作は、以下のとおりである。

class class AbstractMapper...

public void delete (DomainObject object) ( AppSessionManager.getSession().getIdentityMap().remove (object.getId(Connection conn = null; PreparedStatement stmt = null; try ( conn = ConnectionManager. INSTANCE.getConnection(); stmt = conn.prepareStatement (deleteSQL); stmt.setLong (1, object.getId().longValue()); int rowCount = stmt.executeUpdate(); if (rowCount == 0) { } throwConcurrencyException (object); } catch (SQLException e) { throw new SystemException("unexpected error deleting"); } finally { cleanup DBResources (conn, stmt); }

));

protected void throwConcurrency Exception (DomainObject object) throws SQLException ( Connection conn = null; PreparedStatement stmt = null; ResultSet rs = null; try ( conn = ConnectionManager.INSTANCE.getConnection(); stmt = conn.prepareStatement (checkVersionSQL); stmt.setInt(1, (int) object.getId().longValue()); rs = stmt.executeQuery(); if (rs.next()) { int version = rs.getInt(1); String modifiedBy = rs.getString(2); Timestamp modified = rs.getTimestamp (3); if (version > object.getVersion()) { String when DateFormat.getDateTimeInstance().format (modifiedthrow new Concurrency Exception (table ++ object.getId() modified by modifiedBy+at+ when); } else { throw new SystemException("unexpected error checking timestamp"

); +

)

} else (

);

}

第16章 オフライン並行性パターン

} throw new Concurrency Exception (table + + object.getId() + has been deleted"); } } finally { cleanupDBResources (rs, conn, stmt); }

並行性例外のバージョンチェックに使われる SQL も、 抽象マッパーが知る必要がある。 マッパーは CRUD SQL を構築するときには、 SQL も構築する必要がある。 それは、以下 のとおりである。

checkVersionSQL...

SELECT version, modifiedBy, modified FROM customer WHERE id = ?

このコードを見ても、 さまざまな部分が1つのビジネストランザクション内で複数のシ ステムトランザクションにまたがって実行されているとは思わないかもしれない。 重要なこ とは、 軽オフラインロックの獲得はレコードデータの一貫性を維持するため、変更のコミッ トを保持している同じシステムトランザクション内で実行されなければならない点である。 UPDATE 文と DELETE 文にバンドルされるチェックの場合、 このことは問題にはなら ない。

緩ロックの例のコードでVersion オブジェクトを使う場合を見てみよう。 緩ロックを使 うと一貫性のない読み込みのいくつかの問題を解決することができる。 しかし、 シンプルな 非共有 Version オブジェクトは、 increment () または checkVersionIsLatest () などの軽 チェックの振る舞いを追加する場所でもあるため、一貫性のない読み込みを検出するのに役 立てられる。 追加するユニットオブワークは以下のとおりであり、 分離レベルがわからない ため、 Version の差分を根本的に測定することよって、 一貫性のある読み込みチェックをコ ミットプロセスに追加する。

class UnitofWork...

private List reads = new ArrayList(); public void registerRead (DomainObject object){ } reads.add(object); public void commit()( try(

4 4 8

checkConsistentReads ();

insertNew();

deleteRemoved();

updateDirty ();

}catch(Concurrency Exception e) { rollback SystemTransaction ();

throw e;

}

public void checkConsistent Reads () ( for (Iterator iterator = reads.iterator(); iterator.hasNext();) ( DomainObject dependent (DomainObject) iterator.next(); dependent.getVersion().increment();

ユニットオブワークは並行性違反を検出すると、 システムトランザクションをロールバッ クする。 ほとんどの場合、 コミット中に何らかの例外が発生した場合には、ロールバックを 行うことになる。 このステップを忘れないでほしい。 Version オブジェクトの代替として、 バージョンチェックをマッパーインタフェースに追加することもできる。

(by David Rice)

|162| 重オフラインロック

データへのアクセスを一度に1つのビジネストランザクションに限定することで、同時 ビジネストランザクション間のコンフリクトを防止する。

オフライン並行性パターン

Business Martin's Session getCustomer (129) return customer 129 Transaction Boundary edit customer Database David's Session System Transaction Boundary getCustomer (129) | error: customer locked

オフライン並行性では、複数のリクエストにまたがってビジネストランザクションのデー タを処理する場合がある。 その場合の最もシンプルな手法は、システムトランザクションを、 ビジネストランザクション全体に対してオープンにすることである。 しかし残念なことに、 トランザクションシステムはロングトランザクションで機能するようになっていないため、 この手法が必ずしも有効とは限らない。 このため複数のシステムトランザクションを使う必 要があり、 データへの同時アクセスの管理をしているデバイスに任せる。

最初に取り組むべき手法は軽オフラインロックである。 ただし、 パターンには問題がある。 数人がビジネストランザクション内の同じデータにアクセスすると、 そのうちの1人は容易 にコミットされるが、 その他の人はコンフリクトし失敗することになる。 コンフリクトはビ ジネストランザクションの最後でだけ検出されるため、 その犠牲者はトランザクションすべ

450

てを実行し終わってはじめて、すべてが失敗に終わり、費やした時間が無駄になったことに 気付く。 長時間継続するビジネストランザクションでこのようなコンフリクトが頻繁に発生 するなら、システムの評判はたちまち失墜してしまうだろう。

重オフラインロックを使うことによって、 上記の状態をすべて回避し、 コンフリクトを完 全に防止できる。 重オフラインロックは使用開始前に、ビジネストランザクションがデータ の一部分にロックを獲得することを強制する。 多くの場合、ビジネストランザクションを開 始しても並行性制御によって拒否されることなく、トランザクションを確実に完了できる。

16.21 動作方法

重オフラインロックは次の3つのフェーズで実装することができる。 つまり、必要なロッ クの種類の決定、ロックマネージャーの構築、 およびビジネストランザクションがロックを 使う手続の定義である。 さらに、 軽オフラインロックの補完として重オフラインロックを使 う場合、 ロックするレコードの種類を決定する必要がある。

ロックの種類における最初の選択肢は書き込み専用ロックである。 これは、ビジネストラ ンザクションにセッションデータを編集するロックだけを獲得することを求める。 また、 2 つのビジネストランザクションが同じレコードを同時に変更することを許可しないため、 コ ンフリクトを防止する。 データの読み込みをこのロックメカニズムは無視するので、 ビュー セッションが最新データを保持することが必須ではない場合には、この考え方で十分である。

ビジネストランザクションが常に最新データを保持していなければならない場合には、 編 集するかどうかに関わらず読み込み専用ロックを使ってほしい。 これは、ビジネストランザ クションに単にレコードをロードするロックを獲得することを求める。 この考え方では明ら かに、システムの並行性が厳しく制限される可能性がある。 エンタープライズシステムでは、 書き込み専用ロックの方が、 読み込み専用ロックより多くのレコードに同時アクセスできる。

3つ目の考え方は2種類のロックを組み合わせたものであり、読み込み専用ロックの制限 的なロックに加え、 書き込み専用ロックの向上した並行性も提供する。 読み書きロックと呼 ばれ、最初の2つよりも少し複雑になっている。 読み込みロックと書き込みロックの関係は 以下のとおりであり、 両方の機能のメリットを活かすことが重要である。

読み込みロックと書き込みロックは相互に排他的である。 他のいずれかのビジ ネストランザクションがレコードに読み込みロックを持っている場合、 そのレ コードに書き込みロックを実行することは不可能である。 また、 他のいずれか のビジネストランザクションが書き込みロックを持っている場合、レコードに 読み込みロックを実行することも不可能である。

■同時の読み込みロックは許可されている。1つの読み込みロックが存在すると、

ビジネストランザクションがレコードを編集できなくなるため、1つのセッショ ンでの読み込みが許可されるとき、いくつものセッションでの読み込みが可能 になることには問題はない。

複数の読み込みロックが許可されると、システムの並行性が向上する。 この仕組みの弱点 は実装がとても難しいことであり、 システムをモデリングする際にドメインの専門家は頭を 抱えながら、 弱点を克服するためにより一層奮闘するのである。

適切なロックの種類を選ぶ場合、システムの並行性の最大化、ビジネスニーズへの適合性、 およびコードの複雑性の最小化を考えてほしい。 さらにドメインモデラーとアナリストは、 ロックメカニズムを理解しなければならないことにも留意してほしい。 ロックは単なる技術 的な問題ではい。 その理由は、不適切なロックの種類、 つまり単にすべてのレコードをロッ クしたり、不適切な種類のレコードをロックしたりするだけなら、 効果のない重オフライン ロックメカニズムになる可能性があるからである。 効果のない重オフラインロックメカニズ ムでは、ビジネストランザクションの開始時点でコンフリクトを防止できず、 シングルユー ザシステムのように見えるほどに、マルチユーザシステムの並行性が劣化してしまう。 不適 切なロックメカニズムは、 適切な技術的実装で埋め合わせることはできない。 ドメインモデ ルに重オフラインロックを含めることは、悪い考えではない。

ロックの種類を決定したら、 ロックマネージャーを定義してほしい。 ロックマネージャー のジョブは、ビジネストランザクションがロックを獲得または解除するリクエストに対し、 許可または拒否を行うことである。 ジョブを実行するために、 ロックマネージャーはビジネ ストランザクションにおいてロックされているもの以外に、ロックを実行した所有者も認識 している必要がある。ビジネストランザクションの概念が、 一意に識別できるようなもので ない可能性は十分ある。 その場合、 ビジネストランザクションをロックマネージャーに渡す ことが少し困難になる。 この場合、 自身の判断でセッションオブジェクトを持つ可能性を多 くするようにセッションの概念を考えること。 「セッション」と「ビジネストランザクショ ン」という用語は、まったく区別せずに使うことができるものである。 ビジネストランザク ションが、1つのセッション内で直列的に実行される限り、 セッションは重オフラインロッ クの所有者として適切である。 コードの例で、この考え方をいくらか明確にさせなければい けないだろう。

ロックマネージャーを構成するのは、ロックを所有者にマッピングするテーブルである。 シンプルなロックマネージャーがメモリ内のハッシュテーブルをラップする場合、 あるいは ロックマネージャーがデータベーステーブルである可能性がある。 どのような場合であって も、1つ、つまりロックテーブルを1つだけ持つ必要がある。 それがメモリ内にある場合、 必ずシングルトン [Gang of Four] を使ってほしい。 アプリケーションサーバがクラスタ化し ている場合、 メモリ内のロックテーブルは、1つのサーバインスタンスに対応していない限

第16章 オフライン並行性パターン

52

り機能しない。 クラスタ化されたアプリケーションサーバ環境である場合、データベースを ベースとするロックマネージャーの方が適切である可能性が高い。

ロックは、データベーステーブルにオブジェクトまたはSQLとして実装されているかど うかに関わらず、 ロックマネージャー専用である必要がある。 ビジネストランザクションは、 ロックマネージャーとだけ相互作用を行う必要があり、 ロックオブジェクトとは決して相互 作用を行わない。

次に、ビジネストランザクションがロックマネージャーを使うために従うべきプロトコル を定義する。 プロトコルには、何をいつロックするか、いつロックを解除するか、そして ロックが獲得できなかったときはどのように動作するかを含める必要がある。

何をロックするかは、いつロックするかに左右される。 そのため、いつロックするかを最 初に考慮する。 一般的に、 ビジネストランザクションはデータをロードする前にロックを獲 得する必要がある。 ロックされた項目の最新バージョンを持てるという保証がない場合は、 ロックを獲得するメリットは少ない。 しかし、 システムトランザクション内でロックを獲得 しているため、ロックとロードの順序を問題にしない環境もある。 ロックの種類によっては、 直列化可能または繰り返し可能な読み込みトランザクションを使っている場合、 オブジェク トのロードとロックの獲得を行う順序は問題にはならないはずである。 重オフラインロック を獲得した後に、 軽チェックを項目に対して実行するという選択肢もある。 オブジェクトを ロックしてしまえば、オブジェクトが最新バージョンであることはまちがいない。このこと は、オブジェクトはデータをロードする前にロックを獲得する、 と言うのと同じなのである。

次に、何をロックするか。 オブジェクトでもレコードでも、つまりどのようなものでも ロックされているようだが、 通常それらのオブジェクトを検索するために使う ID またはブ ライマリキーをロックしている。 これによって、 オブジェクトをロードする前にロックを取 得できる。 ロックを獲得した後もオブジェクトが現時点と同じものであるというルールに違 反しない限りは、 オブジェクトのロックは有効である。

ロックを解除する最もシンプルなルールは、 ビジネストランザクションが完了したときに 解除することである。 ロックの種類とオブジェクトを再度トランザクション内で使う場合、 完了前のロック解除も許可されるはずである。 さらに、 とても扱いにくいシステム稼働率の 問題など、 解除を早めるべき極めて特殊な問題がない限りは、ビジネストランザクションの 完了時に解除することを厳守してほしい。

ロックを獲得できないビジネストランザクションに対する最も簡単な対処は、 中止するこ とである。 重オフラインロックでは、トランザクションのやや早い時点で失敗に終わるはず なので、ユーザは中止することを受け入れざるを得ないと思わなければならない。このよう な状況を改善するには、開発者と設計者が、 失敗する可能性の特に高いロックをトランザク シションの後半まで待たずに獲得することである。 可能な限りユーザが作業を開始する前に、 すべてのロックを獲得することを勧める。

ロックしたい特定の項目がある場合、 ロックテーブルへは直列化されたアクセスを行う。 メモリ内のロックテーブルの場合、最も簡単な方法は、使っているプログラミング言語が提 供する構造体を用いて、 ロックマネージャー全体へのアクセスを直列化することである。 こ の方法で提供されるよりも高度な並行性を必要としている場合、 複雑な領域に足を踏み入れ ることを覚悟してほしい。

ロックテーブルがデータベースに格納されている場合、 もちろん、 最初のルールは1つの システムトランザクション内でそのテーブルと相互作用することである。 データベースが提 供する直列化機能のメリットを十分活用しよう。 読み込み専用ロックと書き込み専用ロック を使う場合に直列化を行うには、 ロック可能な項目のID を格納する列に一意性制約を適用 するだけでよい。 しかし、 データベースに読み込み / 書き込みロックを格納する場合、ロ ジックがロックテーブルの挿入だけではなく読み込みも必要とするため、 一貫性のない読み 込みの防止が必須になり、事態は少し難しくなる。 直列化可能な分離レベルのシステムトラ ンザクションは、一貫性のない読み込みを行わないことを保証するため、 最高の安全性を提 供できる。 システム全体で直列化可能トランザクションを使用すると、 パフォーマンス障害 が発生する場合があるが、 ロックを獲得するために個別の直列化可能システムトランザク ションを用意し、他の動作に対しては分離レベルを低くすることで、この問題を緩和できる 場合がある。 別の選択肢は、ストアドプロシージャがロック管理に役立つかどうかを調べる ことである。 並行性の管理は難しくなる場合があるので、 重要な時には管理をデータベース に任せることを躊躇しないようにする。

直列的なロック管理によって、パフォーマンスのボトルネックが増大する。 ロックが少な いと、 発生するボトルネックも少なくなるため、 ロックの細分度を十分検討する。 緩ロック によって、 ロックテーブルの競合に対処できる。

「SELECT FOR UPDATE…」 またはエンティティ EJB などの、 システムトランザク ションの重ロックメカニズムを使う場合、 メカニズムはロックが使えるまで待機するため、 明らかにデッドロックの問題が発生する可能性がある。 デッドロックを以下のように考えて ほしい。 2人のユーザがリソースAとBを必要としているとする。 一方がAのロックを取 得し、もう一方がBのロックを取得した場合、両方のトランザクションは停止し、他のロッ クをいつまでも待機し続ける。1つのビジネストランザクションに20分もの時間が必要と なることもあるので、 範囲が複数のシステムトランザクションに及ぶ場合は、ロックを待機 してもあまり意味がない。 だれもそんなロックを待ちたくはないだろう。 また、 待機のコー ディングにはタイムアウトが必要になり、 すぐにコードが複雑になるので、 待機しないほう がよい。 ロックが使えなくなった場合はすぐに、 ロックマネージャーで例外を起こす。これ によって、デッドロックに対処する負荷を削減できる。

最後の要件は、失われたセッションのロックタイムアウトの管理である。 トランザクショ ンの途中でクライアントマシンに障害が発生した場合、 失われたトランザクションが所有し

第16章 オフライン並行性パターン

4 54

ていたロックすべての完了および解除が不可能になる。 定期的にユーザから破棄されるセッ ションを含む Web アプリケーションの場合、これは大問題である。 アプリケーションでタ イムアウトを処理するよりも、 アプリケーションサーバが管理するタイムアウトメカニズム を使う方が望ましい。 Web アプリケーションサーバは、 このために HTTP セッションを提 供している。 タイムアウトは、 HTTP セッションが無効になったときにロックを解除する ユーティリティオブジェクトを登録して実装できる。 別の選択肢は、タイムスタンプとロッ クを関連付け、 一定時間を経過したロックは無効と見なすようにすることである。

16.2.2 使用するタイミング

重オフラインロックは、同時セッション間のコンフリクトの可能性が高い場合に有効であ る。ユーザは、決して作業をあきらめる必要はない。 さらに、 ロックはコンフリクト発生の 可能性に関係なく、 コンフリクトのコストがあまりにも高い場合にも適切である。システム のすべてのエンティティをロックすると、ほぼ確実に膨大なデータの競合の問題が発生する。 そのため、重オフラインロックは軽オフラインロックを補完するものにすぎず、 本当に必要 な部分にだけ使用すべきものであるということを忘れないでほしい。

重オフラインロックを使う必要がある場合、 ロングトランザクションのことも考える必要 がある。 ロングトランザクションは決して推奨できるものではないが、状況によっては、重 オフラインロックほど損害を与えることもなく、はるかにプログラムしやすい場合がある。 いくつか負荷テストを行ってみてから、この方法を選択するとよい。

ビジネストランザクションが1つのシステムトランザクション内に収まっている場合は、 これらの技法は使わないでほしい。 多くのシステムトランザクションの重ロック技法が、 す でに使っているアプリケーションやデータベースサーバに同梱されていて、それらの中には、 データベースロック用の 「SELECT FOR UPDATE」 SQL 文とアプリケーションサーバ ロック用のエンティティ EJB が含まれている。 必要がないのに、どうしてタイムアウトや ロックの可視性などを気にかけることがあるだろうか。 これらのロックの種類について理解 していれば、確かに重オフラインロックの実装時に多くの付加価値を加えることができる。 しかし、 その逆は真実ではない。 ここでの解説は、データベースマネージャーやトランザク ションモニタを記述するためのものではない。 本書で紹介しているオフラインロック技法の すべては、システムが独自のトランザクションモニタを持っていることを前提としている。

16.2.3 例: シンプルなロックマネージャー (Java)

例では、最初に読み込み専用ロックのためのロックマネージャーを構築する (ロックはオ ブジェクトの読み込みや編集に必要なものである)。 次に、ビジネストランザクションが複

数のシステムトランザクションにまたがる場合のロックマネージャーの使い方を解説する。 最初のステップは、 ロックマネージャーインタフェースを定義することである。

interface ExclusiveReadLockManager...

public static final ExclusiveReadLockManager INSTANCE =

(ExclusiveReadLockManager)

Plugins.getPlugin (ExclusiveReadLockManager.class); public void acquireLock (Long lockable, String owner) throws ConcurrencyException; public void releaseLock (Long lockable, String owner); public void relase All Locks (String owner);

lockable を長整数型、 owner を文字列型で定義していることに注意してほしい。 Lockable は長整数型である。 理由は、データベースのテーブルがシステム全体で一意であ る長いプライマリキーを使っていて、正確なロック可能なID として機能するためである (ロック可能なID はロックテーブルで処理されるすべての種類のテーブルで一意である必 要がある)。 owner ID は文字列型である。 理由は、 例は Web アプリケーションであり内部 でHTTP セッション ID が適切なロックの所有者を作成するからである。

ロックオブジェクトではなく、データベースのロックテーブルと直接相互作用を行うロッ クマネージャーを記述する。これはデータベース内部のロックメカニズムではなく、他のア プリケーションテーブルと同様のlock と呼ばれる独自のテーブルであることに留意してほ しい。 ロックを獲得するということは、 行をロックテーブルに正しく挿入するということで ある。 ロックを解除するということは、 行を削除するということである。 ロックテーブルと ロックマネージャーの一部の実装スキーマは、以下のとおりである。

table lock...

create table lock (lockableid bigint primary key, ownerid bigint)

class Exclusive ReadLockManagerDBImpl implements ExclusiveLockManager...

private static final String INSERT_SQL = INSERT INTO lock VALUES (?, ?)"; private static final String DELETE_SINGLE_SQL = "DELETE FROM lock WHERE lockableid = ?AND ownerid = ?"; private static final String DELETE_ALL_SQL = *DELETE FROM lock WHERE ownerid = ?"; private static final String CHECK_SQL = SELECT lockableid FROM lock WHERE lockableid = ? AND ownerid = ?"; public void acquirelock (Long lockable, String owner) throws ConcurrencyException(

第16章 オフライン並行性パターン

456

if (!hasLock (lockable, owner)) ( Connection conn = null; PreparedStatement pstmt = null; try { conn = ConnectionManager. INSTANCE.getConnection (); pstmt = conn.prepareStatement (INSERT_SQL); pstmt.setLong (1, lockable. longValue()); pstmt.setString (2, owner); pstmt.executeUpdate(); } catch (SQLException sqlEx) { throw new Concurrency Exception ("unable to lock lockable); ) finally ( close DBResources (conn, pstmt); ) }

) public void releaseLock (Long lockable, String owner) ( Connection conn = null; PreparedStatement pstmt = null; try ( conn = ConnectionManager.INSTANCE.getConnection(); pstmt = conn.prepareStatement (DELETE_SINGLE_SQL); pstmt.setLong (1, lockable.longValue()); pstmt.setString (2, owner); pstmt.executeUpdate(); } catch (SQLException sqlEx) ( throw new SystemException("unexpected error releasing lock on " + lockable); } finally { closeDBResources (conn, pstmt); }

ロックマネージャーに示されていないのは、 パブリックな release AllLocks ()メソッド とプライベートな hasLock() メソッドである。 releaseAllLocks () は、名前のとおりに Owner のロックを解除する。 hasLock() は、 Owner がすでにロックを所有しているかどう かをデータベースに確認する。 セッションコードがすでに所有しているロックを獲得しよう とすることは珍しくない。そのため、 acquireLock()はロック行を挿入しようとする前に、 まず、 Owner がすでにロックを所有していないかどうかをチェックする必要がある。 ロッ クテーブルはリソースが競合するポイントであるため、 読み込みを繰り返すと、アプリケー ションパフォーマンスが低下する場合がある。 所有者チェックのため、セッションレベルで 所有しているロックをキャッシュすることが必要な場合がある。 これを慎重に行ってほしい。

次に Customer レコードを管理するため、シンプルなWebアプリケーションを構築しよ

オフライン並行性パターン

う。最初に、ビジネストランザクションの処理に役立つインフラの一部を設定する。 ユーザ セッションの概念によっては、 Webティアの下のレイヤで必要とされる場合がある。 その ため、 HTTP セッションだけに依存することはできない。 新しいセッションを、 HTTP セッションとは別のアプリケーションセッションと見なすことにする。 アプリケーション セッションには、ID、 ユーザ名、および一意マッピングが格納され、 ビジネストランザク ションの間にロードまたは作成されたオブジェクトをキャッシュする。 それらのオブジェク トは、見つけやすくするために現在実行中のスレッドと関連付けられている。

class AppSession...

private String user; private String id; private IdentityMap imap; public AppSession (String user, String id, IdentityMap imap) { this.user = user; } this.imap = imap; this.id = id;

class AppSessionManager...

private static ThreadLocal current = new ThreadLocal (); public static AppSession getSession() { return (AppSession) current.get(); } public static void setSession (AppSession session) { current.set (session); }

フロントコントローラを使ってリクエストを処理するためには、コマンドの定義が必要に なる。コマンドが最初に行う必要のあることは、 新しいビジネストランザクションを開始す るか、または既存のビジネストランザクションを継続するかのいずれであるかを明確にする ことである。 この決定によって、 新しいアプリケーションセッションを設定するか、または 現行のアプリケーションセッションを発見するかが決まる。 ビジネストランザクションのコ ンテキストを設定するために使いやすいメソッドを提供する抽象コマンドは、以下のとおり である。

interface Command...

public void init (HttpServletRequest req, HttpServletResponse

458

rsp);

public void process () throws Exception;

abstract class BusinessTransactionCommand

implements Command...

public void init (HttpServletRequest req, HttpServletResponse rsp) ( req; this.req this.rsp rsp;

protected void startNewBusiness Transaction () {

HttpSession httpSession = getReq().getSession (true);

AppSession appSession = (AppSession) httpSession.getAttribute (APP SESSION); if (appSession != null) {

ExclusiveReadLockManager.INSTANCE.relaseAllLocks (appSession.getId());

)

appSession = new AppSession (getReq().getRemoteUser(). httpSession.getId(), new IdentityMap());

AppSessionManager.setSession (appSession); httpSession.setAttribute (APP_SESSION, appSession); httpSession.setAttribute (LOCK_REMOVER,

new LockRemover (appSession.getId()));

protected void continueBusinessTransaction() {

HttpSession httpSession = getReq().getSession();

AppSession appSession (AppSession) httpSession.getAttribute (APP_SESSION); AppSessionManager.setSession (appSession);

protected HttpServletRequest getReq() {

return req;

}

protected HttpServletResponse getRsp() (

return rsp;

新しいアプリケーションセッションを設定する場合、 既存のアプリケーションセッション のためのロックを削除することに注意してほしい。 さらに、リスナーをHTTP セッション の構築イベントに追加する。 イベントは、 対応する HTTP セッションが期限切れになった とき、アプリケーションセッションが持つあらゆるロックを削除する。

class LockRemover implements HttpSessionBindingListener...

private String sessionId; public LockRemover (String sessionId) ( this.sessionId = sessionId;

}

}

}

}

162 オフラインロック

第16章 オフライン並行性パターン

}) public void valueUnbound (HttpSession BindingEvent event) { try{ beginSystemTransaction(); ExclusiveReadLockManager. INSTANCE.relaseAllLocks (this.sessionId); commit SystemTransaction(); } catch (Exception e) { handleSerious Error(e);

コマンドには標準ビジネスロジックとロック管理の両方が含まれ、1つのシステムトラン ザクションの範囲内で実行する必要がある。 確実に行うため、 トランザクションのコマンド オブジェクトで装飾する[Gang of Four] ことができる。1つのリクエストに対するロックお よび標準ドメインビジネスが、1つのシステムトランザクション内で発生することを確認し てほしい。 システムトランザクションの境界を定義するメソッドは、配置コンテキストに依 存している。 並行性例外、およびこのケースでの他の例外のいずれかが検出される場合、シ ステムトランザクションをロールバックすることが必須である。 これでコンフリクトが発生 しても、何らかの変更が永続レコードデータに挿入されるのを防止できる。

class Transactional Comamnd implements Command...

public TransactionalCommand (Command impl)} this.imp1 = impl; public void process() throws Exception ( beginSystemTransaction(); try { impl.process(): commit SystemTransaction (); } catch (Exception e) { rollbackSystemTransaction (); throw e: )

{

次は、コントローラサーブレットと具象コマンドの書き込みについてである。 コントロー ラサーブレットには、コマンドをトランザクションコントローラでラップする責任がある。 具象コマンドは、 ビジネストランザクションのコンテキストの設定、 ドメインロジックの実 行、適切なロックの獲得と解除を行うために必要である。

4 6 0

class ControllerServlet extends HttpServlet...

protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws ServletException, IOException { try { String cmdName = req.getParameter("command"); Command cmd = getCommand (cmdName); cmd. init (req, rsp); cmd.process(); } catch (Exception e) { writeException (e, rsp.getWriter()); ) } private Command getCommand (String name) ( try { String className = (String) commands.get(name); Command cmd = (Command) Class.forName (className).newInstance(); return new Transactional Command (cmd); } catch (Exception e) ( } e.printStackTrace(); throw new SystemException("unable to create command object for * + name); }

class EditCustomerCommand implements Command...

public void process () throws Exception ( startNewBusiness Transaction(); Long customerId = new Long (getReq().getParameter("customer_id')); ExclusiveReadLockManager. INSTANCE.acquireLock( customerId, AppSessionManager.getSession().getId()); Mapper customerMapper MapperRegistry. INSTANCE.getMapper (Customer.class); Customer customer (Customer) customerMapper.find(customerId); getReq().getSession().setAttribute("customer", customer); forward("/editCustomer.jsp");

}

class SaveCustomerCommand implements Command...

public void process () throws Exception ( continueBusiness Transaction(); Customer customer (Customer) getReq().getSession().getAttribute("customer"); String name = getReq().getParameter ("customerName"); customer.setName (name); Mapper customerMapper MapperRegistry. INSTANCE.getMapper (Customer.class);

1-2 オフラインロック

16

} customerMapper.update (customer); ExclusiveReadLockManager. INSTANCE.releaseLock (customer.getId(), AppSessionManager.getSession().getId()); forward(*/ customersaved.jsp");

オフライン並行性パターン

上記で表示しているコマンドは、 任意の2つのセッションが同時に Customer の処理を 行うことを防止する。 アプリケーションのCustomer オブジェクトを処理する他のコマンド も、確実にロックを獲得するか、 または同じビジネストランザクションの以前のコマンドに よってロックされた Customer だけを処理するかのいずれかである必要がある。 ロックマ ネージャーに hasLock() チェックがあれば、 コマンドでロックを容易に獲得することもでき る。このことはパフォーマンスにとっては不利であるが、 ロックを設定する場合には確かな 保証となるはずである。 暗黙ロックでは、ロックメカニズムに関する他の極めて簡単な手法 を解説する。

フレームワークコードの量は、ドメインコードの量に比べ若干バランスが取れていないと 感じられるかもしれない。重オフラインロックには、最小限の組み合わせでも、アプリケー ションセッション、ビジネストランザクション、ロックマネージャー、 およびシステムトラ ンザクションが必要であり、 これは疑いもなく難問である。 この例は、多くの部分で強固さ が不足しているため、 アーキテクチャテンプレートとしてよりも、アイデアの源泉として役 立つだろう。

16.3 ロック

(by David Rice, Matt Foemmel)

1つのロックで関連オブジェクトセットをロックする。

中 Customer 1 1 Lock Address

462

オブジェクトはグループとして編集できる場合が多い。 おそらく、 Customer と Address のセットを使っているはずである。 アプリケーションを使う際にこれらの中のい ずれか1つをロックしたい場合、 項目すべてをロックすることは有効である。 個々のオプ ジェクトを個別にロックすることには、いくつもの課題がある。 まず、 誰であれそのような オブジェクトを処理する人は、ロックするためにオブジェクトを発見するコードを記述する 必要がある。 Customer とその Address については容易だが、さらにロックグループを取 得するためのコードは複雑で難しいものになる。 グループが複雑になったときはどう対処す ればいいのだろうか。 フレームワークがロックの獲得を管理する場合、振る舞いはどこに配 置すればいいのだろうか。 軽オフラインロックを使う場合のように、ロックするためにオブ ジェクトをロードする必要があるロックメカニズムの場合、大規模なグループをロックする とパフォーマンスに影響を及ぼす。 また、 重オフラインロックでは、大規模なロックセット は管理が厄介となりロックテーブルの競合を増大させる。

緩ロックは、多くのオブジェクトを対象とする1つのロックである。 これによって、 ロッ クアクション自体が簡素化されるだけではなく、 ロックするためにグループのメンバすべて をロードする必要もなくなる。

16.3.1 | 動作方法

緩ロックを実装する最初のステップは、オブジェクトのグループをロックするための、単 一の競合ポイントを作成することである。 これで、 セット全体をロックするのに必要なロッ クは1つだけになる。 これによって、 ロック取得プロセスにおいて、 メモリへロードされ識 別されなければならないグループメンバを最小化するためのシングルロックポイントを見つ ける最短パスを供給できるようになる。

軽オフラインロックの場合、1つのグループの各項目でバージョンを共有すると (図16.2 参照)、 競合のシングルポイントが作成される。 これは、同じバージョンを共有することで あって、等しいバージョンを共有することではない。 このバージョンを増分すると、 グルー 全体が共有ロックでロックされる。 グループのすべてのメンバが共有バージョンを指すよ うにモデルを設定する必要がある。 これによって、確実に競合のポイントへのバスが最短化 される。

共有重オフラインロックでは、グループのメンバがいくつかの種類のロック可能なトーク ンを共有し、このロックを獲得する必要がある。 重オフラインロックは、軽オフラインロッ クを補完するものとして使われるため、共有バージョンオブジェクトはロック可能なトーク ンの役割にふさわしい優れた対象になる(図16.3)。

Eric Evans と David Siegel [Evans]は、データ変更のユニットとして扱われる関連オブ ジェクトのクラスタとして集合体を定義している。 それぞれの集合体には、セットのメンバ

第1章 オフライン並行性パターン

への唯一のアクセスポイントを提供するルートと、 セットに含まれているものを定義する境 界がある。 集合体のメンバのいずれかを処理する場合には、メンバすべてをロックする必要 があるため、集合体の特性上緩ロックが求められる。 集合体のロックは、ルートロックと呼 ばれる共有ロックの代替方法となる(図16.4 参照)。 定義では、ルートをロックすると集合 体のすべてのメンバがロックされる。 ルートロックにより、 競合のシングルポイントが提供 される。

* Customer 1 * Address * {version= customer.version} 1 Version getValue() increment() 1

図 16.2バージョンの共有

ロックとしてルートロックを使うと、 オブジェクトグラフにルートへの遷移を実装する 必要がある。 これで集合体のすべてのオブジェクトにロックが要求される場合、 ロックメカ ニズムはルートに遷移してそのままルートをロックすることができる。 遷移は2つの方法で 実現することができる。 集合体のそれぞれのオブジェクトはルートへの直接遷移の管理、 ま または一連の中間関係を使うことができる。 たとえば、 階層構造では、ルートは明白にトップ レベルの親であり下層に直接リンクできる。あるいは、ノードをその直上の親とリンクさせ、 遷移を行いルートに到達することもできる。大きなグラフの場合、後者の考え方ではそれぞ れの親が自分には親があるかどうかを特定するためにロードする必要があるので、パフォー マンスの問題が発生する可能性がある。 ルートへのパスを形成するオブジェクトをロードす る場合、必ずレイジーロードを使う。 これによって、 オブジェクトが必要とされる前にロー ドされるのを防止できるだけでなく、 双方向の関係をマッピングする場合には、無限のマッ ピングループも防止できる。 1つの集合体のレイジーロードが、 複数のシステムトランザク ション全体にまたがる可能性があることに十分注意してほしい。 これで一貫性のない部分で 構築された集合体になる可能性がある。 もちろんこれは推奨されることではない。

464

* Customer 1 * Address {version= customer.version} 1 Version 1 * 図 16.3 共有バージョンのロック 1 1 Pessimistic Lock 1 1 Customer Lock 1 root boundary Address

図 16.4 ルートのロック

集合体のオブジェクトがロックされると同時にルートもロックされるため、共有ロックも 集合体のロックとして有効であることに留意してほしい。

緩ロックの共有ロックとルートロックの両方の実装には、それぞれトレードオフがある。 リレーショナルデータベースを使う場合、 共有ロックでは、選択したものをバージョンテー ブルに関連付けしなければならないという困難な作業が必要になる。 しかし、オブジェクト のロードとルートへの遷移を同時に行うと、さらにパフォーマンスへの打撃となる可能性も ある。 おそらくルートロックと重オフラインロックは奇妙な組み合わせになるだろう。 ルー トへの遷移が行われロックされるときまでに、数個のオブジェクトを再ロードして、 オブ ジェクトを最新に保つ必要がある場合がある。 レガシーデータに対してシステムを構築する と、実装を選択するときに多くの制約が生じる。 ロック実装の選択肢は多数あり、これに類 似した選択肢はもっと多くなる。 必ずニーズに合った実装を実行しなければならない。

16-3 ロック

第16章 オフライン並行性パターン

16.3.2 使用するタイミング

ロックを使う明確な理由は、 ビジネス要件を満たすことである。 その実例が、集合体を ロックする場合である。 Asset (資産) コレクションを所有するLease (賃貸借契約) オブ ジェクトを考えてみる。 おそらく、 1人のユーザがLease を編集し、もう1人のユーザが同 時に Asset を編集するということは、ビジネスではありえないだろう。 Lease または Asset のいずれかをロックすると、 Lease と Asset がロックされるはずである。

ロックを使うメリットは、 ロックの獲得と解除のコストを節約できることである。 これ は確かに緩ロックを使うための合理的な動機である。 共有ロックは、集合体 [Evans] の概念 の枠を越えて使えるが、パフォーマンスなどの非機能的な要件に基づいて動作させる場合に は慎重さが求められる。 緩ロックを十分に活用するためには、不自然なオブジェクト関係を 作成しないように注意してほしい。

16.3.3 | 例: 共有軽オフラインロック (Java)

例では、レイヤスーパータイプ、 永続ストアとしてのリレーショナルデータベース、およ びデータマッパーを備えるドメインモデルを紹介する。 最初の手順は、 Version クラスと テーブルの作成である。 簡素化するためにはやや適用範囲の広いバージョンを作成し、値を 格納するだけでなく静的なfindメソッドも持つようにする。

留意してほしいのは、一意マッピングを使ってセッションのバージョンをキャッシュする ことである。 オブジェクトがバージョンを共有する場合、 オブジェクトがバージョンの同じ インスタンスを正確に指すことは重要なことである。 Version クラスはドメインモデルの一 部であるため、 データベースコードを配置する形式にはなっていない可能性がある。 そのた め、ここでは個別のバージョンのデータベースコードをマッパーレイヤに置いたままにして おき、それ以上のことは読者の学習に委ねたい。

table version...

create table version (id bigint primary key, value bigint, modifiedBy varchar, modified datetime)

class Version...

private Long id; private long value; private String modifiedBy; private Timestamp modified; private boolean locked; private boolean isNew;

466

private static final String UPDATE_SQL = "UPDATE version SET value = ?, modifiedBy = ?, modified = ? + "WHERE id = ? AND value = ?"; private static final String DELETE_SQL = "DELETE FROM version WHERE id = ? AND value = ?"; private static final String INSERT_SQL = "INSERT INTO version VALUES (?, ?, ?, ?)"; private static final String LOAD_SQL = "SELECT id, value, modifiedBy, modified FROM version WHERE id = ?"; public static Version find (Long id) { Version version = AppSessionManager.getSession(). get IdentityMap().getVersion (id); if (version == null) { } version load(id);

return version;

private static Version load (Long id) (

ResultSet rs = null;

Connection conn = null;

PreparedStatement pstmt = null;

Version version = null;

try (

conn ConnectionManager. INSTANCE.getConnection(); pstmt = conn.prepareStatement (LOAD_SQL); pstmt.setLong (1, id.longValue());

rs=pstmt.executeQuery();

if (rs.next()) (

long value rs.getLong (2);

String modifiedBy = rs.getString(3);

Timestamp modified = rs.getTimestamp (4);

version new Version (id, value, modifiedBy, modified); AppSessionManager.getSession().getIdentityMap().putVersion (version);

} else {

throw new Concurrency Exception("version id not found.");

}

} catch (SQLException sqlEx) (

throw new SystemException("unexpected sql error loading version", sqlEx); ) finally (

cleanupDBResources (rs, conn, pstmt);

return version;

}

)

}

16

第16章 オフライン並行性パターン

バージョンは、バージョン自身の作成方法も知っている。 データベースの挿入と作成を分 離させることで、1つのOwner をデータベースに挿入するまでは、 挿入を禁止する。 ドメ インのデータマッパーは、対応するドメインオブジェクトが挿入されている場合、 バージョ ンでの挿入を安全に呼び出すことができる。 バージョンは、ドメインオブジェクトが一度だ け挿入されることを確かめるために、新規かどうかを追跡する。

class Version...

public static Version create() { Version version = new Version (IdGenerator. INSTANCE. nextId(), 0, AppSessionManager.getSession().getUser(), now()); version.isNew = true; return version;

public void insert() { if (isNew()) ( Connection conn = null; PreparedStatement pstmt = null; try{ conn = ConnectionManager. INSTANCE.getConnection(); pstmt = conn.prepareStatement (INSERT_SQL); pstmt.setLong (1, this.getId().longValue()); pstmt.setLong (2, this.getValue()); pstmt.setString(3, this.getModifiedBy()); pstmt.setTimestamp (4, this.getModified()); pstmt.executeUpdate(); AppSessionManager.getSession().getIdentityMap().putVersion (this); isNew = false; } catch (SQLException sqlEx) { throw new SystemException ("unexpected sql error inserting version", sqlEx); } finally { cleanupDBResources (conn, pstmt); )

}

次は、対応するデータベース行のバージョンの値を増分させる increment() メソッドで ある。 変更セットの複数のオブジェクトは同じバージョンを共有する可能性が高いため、 バージョンは増分される前にまずロックされていないことを確認する。 データベースを呼び 出した後、 increment()メソッドは、バージョン行が本当に更新されたかどうかをチェック

468

する必要がある。行カウント 0 が返される場合、 並行性違反が検出されているため例外が起 こされる。

class Version...

public void increment () throws Concurrency Exception (

if (!isLocked()) {

Connection conn = null;

PreparedStatement pstmt = null; try ( conn pstmt ConnectionManager.INSTANCE.getConnection(); conn.prepareStatement (UPDATE_SQL); pstmt.setLong (1, value + 1); pstmt.setString (2, getModifiedBy()); pstmt.setTimestamp (3, getModified()); pstmt.setLong (4, id.longValue()); pstmt.setLong (5, value); int rowCount = pstmt.executeUpdate(); if (rowCount == 0) { } throwConcurrency Exception(); value++; locked true; } catch (SQLException sqlEx) { throw new SystemException("unexpected sql error incrementing version", sqlEx); } finally ( cleanup DBResources (conn, pstmt); }

private void throwConcurrency Exception() { Version current Version = load (this.getId()); throw new Concurrency Exception( "version modified by " + currentVersion.modifiedBy at * + DateFormat.getDateTimeInstance().format (currentVersion.getModified ()));

}

}

このコードを使って、 コミットしたビジネストランザクションのシステムトランザクショ ン内だけで increment を呼び出していることを確認してほしい。 isLocked フラグを使うこ とで、コミットトランザクション中にトランザクションの初期における増分が誤ったロック

163 ロック

第16章 オフライン並行性パターン

を獲得するようにする。 軽ロックでは、 コミットするときにだけロックするので問題にはな らない。

このパターンを使うときには、以前のシステムトランザクションのデータベースと比較し て、データが現在のものかどうかを確認したい場合がある。 check Current メソッドを Version クラスに追加することでそれを確認できる。 メソッドを使うことで、 軽オフライン ロックが更新しなくても使えるかどうかを容易にチェックできる

データベースから Version を削除するための SQL を実行する delete メソッドは、ここ では示していない。 返される行カウントが0の場合、 並行性例外が発生する。 このバージョ ンで使う最後のオブジェクトが削除されるとき、 軽オフラインロックが取得されていなかっ たためであると思われる。 これは決して起こってはならないことである。 実際の動作は、 い つ共有バージョンの削除が許可されるかを認識している。 集合体全体でバージョンを共有し ている場合、集合体のルートを削除した後、単にバージョンを削除するだけである。 しかし、 他のシナリオの場合はかなり難しい。 1つは、 Version オブジェクトがそのOwner の参照 カウントを保持し、そのカウントが0になったときに自らを削除することである。このため にやや洗練された Version オブジェクトになる可能性があることを警告しておきたい。 バージョンが複雑になると、 Version オブジェクトを本格的なドメインオブジェクトにする ことを考える場合がある。 もちろんこれは十分に有効なことだが、 Version のない特殊なド メインオブジェクトとなる。

次は、共有バージョンの使い方について解説する。 ドメインレイヤスーパータイプには、 シンプルなカウントではなく Version オブジェクトが含まれている。 データマッパーによっ て、ドメインオブジェクトのロード時に Version を設定する。

class DomainObject...

private Long id;;

private Timestamp modified; private String modifiedBy; private Version version; public void setSystemFields (Version version, Timestamp modified, ) String modifiedBy) { this.version = version; this.modified = modified; this.modifiedBy = modifiedBy:

作成に関して、 Customer のルートと Address から構成される集合体を見てみよう。 Customer の create メソッドで、 共有バージョンが作成される。 Customer は、Address

470

を作成する addaddress () メソッドを持ち、 Customer のバージョンを渡す。 抽象データ ベースマッパーは、 バージョンを挿入してから対応するドメインオブジェクトを挿入する。 バージョンによって一度だけ挿入されることを忘れないようにする

class Customer extends DomainObject....

public static Customer create(String name) { return new Customer (IdGenerator. INSTANCE.nextId(), Version.create(), name, new ArrayList()); class Customer extends DomainObject...

public Address addAddress (String linel, String city, String state) { Address address = Address.create(this, getVersion (), linel, city, state); addresses.add (address);

return address;

class Address extends DomainObject...

}

public static Address create (Customer customer, Version version, String linel, String city, String state) { return new Address (IdGenerator.INSTANCE.nextId(), version, customer, linel, city, state); }

class AbstractMapper...

public void insert (DomainObject object) ( object.getVersion().insert();

増分は、データマッパーがオブジェクトの更新または削除を行う前に、 データマッパーか ら Version に要求される必要がある。

class AbstractMapper...

public void update (DomainObject object) ( object.getVersion ().increment ();

class AbstractMapper...

1-3 ロック

16

public void delete (DomainObject object)object.getVersion().increment();

これは集合体なので、 Customer を削除するときに Address も削除する。 その直後に Version を削除できる。

第16章 オフライン並行性パターン

{

class CustomerMapper extends AbstractMapper...

public void delete (DomainObject object){ Customer cust = (Customer) object; for (Iterator iterator = cust.getAddresses () .iterator(); } iterator.hasNext(); ) { Address add = (Address) iterator.next(); MapperRegistry.getMapper (Address.class).delete (add); super.delete (object); cust.getVersion().delete(); }

16.3.4 例: 共有重オフラインロック (Java)

関連セットのオブジェクトの関連付けができるいくつかの種類のロック可能なトークンが 必要になる。 前述のように、重オフラインロックを軽オフラインロックを補完するものとし て使うので、 ロック可能なトークンとして共有バージョンを使う。

共有バージョンに達するために、 同じコードを使う。 唯一の問題は、バージョンを取得す るため一部のデータをロードする必要があることである。 データをロードしてから重オフラ インロックを獲得する場合、 データが現在のものであることをどうやって知ることができる だろうか。 簡単な方法としては、重オフラインロックを取得したシステムトランザクション 内のバージョンを増分することである。 システムトランザクションがコミットされると、 重 ロックが有効になり、 システムトランザクション内のどこでロードしたとしても、そのバー ジョンを共有するデータの最新のコピーを持っていることがわかる。

class LoadCustomerCommand...

try{

Customer customer = (Customer) MapperRegistry.getMapper (Customer.class).find(id); ExclusiveReadLockManager. INSTANCE.acquireLock (customer.getId(), AppSessionManager.getSession().getId());

472

customer.getVersion ().increment(); TransactionManager. INSTANCE.commit(); } catch (Exception e) ( TransactionManager. INSTANCE.rollback(): throw e;

バージョンの増分は、ロックマネージャーに構築したいものであることがわかる。 少なく とも、バージョンを増分するコードでロックマネージャーを装飾したい [Gang of Four] と思 うはずである。 もちろん、 本稼動するコードには、示した例より強固な例外処理やトランザ クション制御が必要になる。

16.3.5 例: ルート軽オフラインロック (Java)

この例は、これまでのレイヤスーパータイプやデータマッパーなどの例と同じことを前提 としている。 Version オブジェクトもあるが、ここでは省くことにする。 ここでは、単に データマッパーの外側で軽オフラインロックを獲得しやすくするための使いやすい increment() メソッドを提供する。 また、 変更セットを追跡するユニットオブワークも使っ ている

集合体には親子関係が構築されているので、ルートを見つけるためには、子-親遷移を 使う。 ドメインモデルとデータモデルもこれに対応させる。

class DomainObject...

private Long id; private DomainObject parent; public DomainObject (Long id, Domainobject parent) this.id = id; this.parent = parent;

Owner を持つと、ユニットオブワークをコミットする前にルートロックを取得できる。

class UnitOfWork...

public void commit() throws SQLException { for (Iterator iterator = _modifiedobjects.iterator(); iterator. hasNext();) ( DomainObject object = (DomainObject) iterator.next(); for (DomainObject owner = object; owner != null; owner=

1-3 ロック

16

owner.getParent ()) {

第16章 オフライン並行性パターン

}

owner.getVersion().increment();

for(Iterator iterator = modifiedobjects.iterator(); iterator.hasNext();){ DomainObject object = (DomainObject) iterator.next(); Mapper mapper = MapperRegistry.getMapper (object.getClass()); mapper.update(object);

16. 暗黙ロック

(by David Rice)

フレームワークまたはレイヤスーパータイプコードがオフラインロックを獲得できる。

Business Transaction load customer return customer Framework lock customer success Lock Manager

ロックメカニズムで重要な点は、すべての場所で使うことである。 ロックを獲得するコー ドの記述を行忘れたために、 オフラインロックメカニズム全体が使い物にならない場合も ある。 他のトランザクションが読み込みロックを使っているところで書き込みロックの検索 をしないと、更新セッションデータを取得できないこともあり、またバージョンカウントを 使わないと、他人が変更を上書きしても気付かないこともある。 一般的には、 ある項目が任 意の場所でロックされた場合、 すべての場所でもロックされている必要がある。 アプリケー ションのロックメカニズムを無視すると、ビジネストランザクションは一貫性のないデータ となってしまう。 ロックを解除しないと、レコードデータは破損することはないが、 作業が

474

}

できなくなってしまう。 オフライン並行性管理のテストは困難なので、どのようなテストス イートでもエラーを検出できない場合がある。

その1つの解決策は、 開発者に誤りを許さないことである。 一切の見落としが許されない ロックタスクは、 開発者により明示的に処理されるのではなく、 アプリケーションにより暗 黙的に処理される必要がある。 ほとんどのエンタープライズアプリケーションでは、フレー ムワークの組み合わせであるレイヤスーパータイプを使っているので、コード生成が暗黙 ロックを活用する十分な機会を提供する。

16.4.1 | 動作方法

暗黙ロックを実装することはコードを分析することであり、絶対に省略できないロックメ カニズムをアプリケーションフレームワークで実行できるのである。 適切な表現が思い浮か ばないので 「フレームワーク」という用語を使うが、これはレイヤスーパータイプ、 Framework クラス、および他の任意の 「プラミング」 コードの組み合わせをいうこととす る。コード生成ツールもまた、適切なロックを実現するための手段である。 これは決して くようなことではない。 これを使う可能性があるのは、アプリケーション全体で数回同じ ロックメカニズムのコーディングを行う場合である。 そのコーディングは不十分で、ざっと 目を通す必要がある場合が多い。

最初のステップは、ロックメカニズム内で処理するビジネストランザクションに必要なタ スクのリストをまとめることである。 軽オフラインロックの場合、リストには、 更新 SQL 基準のバージョンを含む各レコードのバージョンカウントの格納、およびレコード変更時に 増分されたバージョンなどの項目が含まれている。 重オフラインロックリストは、1つの データをロードするために必要なロック (通常、 読み込み専用ロック、または読み込み/書 き込みロックの読み込みロック部分)を獲得するビジネストランザクション、またはセッ ションの完了時にすべてのロックを解除する明細項目を含んでいる。

重オフラインロックのリストに含まれないものとして、1つのデータを編集するために必 要なロック (書き込み専用ロックや読み込み/書き込みロックの書き込みロック部分)の 得があることに留意する。 ビジネストランザクションがデータの編集を行う予定の場合、 ロックは必須である。 しかしロックが使えない場合、暗黙的にそれらを獲得すると2つの困 難な問題が発生する。 第1に、 ユニットオブワーク内の不確定なオブジェクトを登録するよ うな、書き込みロックを暗黙的に獲得する際の唯一のポイントは、ロックが使えない場合が あることだ。 この場合、ユーザの作業開始直後にトランザクションが中止されるという保証 はない。 アプリケーションは、これらのロックを獲得する時点を発見できないのだ。 早い時 期に失敗しないトランザクションは、重オフラインロックの「ユーザに同じ作業を2度させ てはならない」という目的とコンフリクトしてしまう。

第2に、同じくらい重要な点だが、ロックの種類は極限までシステムの並行性を制限して しまうことである。暗黙ロックを使わないということは、その問題を技術的な領域から切り 離して、ビジネスドメインの領域で考え、 並行性にどのような影響が及ぼされるかについて 検討するのに役立つ。 それでも、書き込みに必要なロックは、変更がコミットされる前に獲 得する必要がある。 フレームワークにできることは、何らかの変更がコミットされる前に書 き込みロックが取得されるようにすることである。 コミット時までにロックが獲得されない 場合、それはプログラマの間違いであり、コードは少なくともアサーションの失敗を発生さ せる。しかし私は、アサーションを省略して並行性例外を起こすことを勧める。 理由は、ア サーションが機能を停止するときに発生する、 本稼動システム上のいかなるエラーも望まし くないからである。

暗黙ロックを使うことについての注意を一言述べたい。 暗黙ロックによって、開発者は ロックメカニズムの大部分を無視することできるが、結果を無視することはできない。 たと えば、 開発者がロックを待機する重ロックメカニズムで暗黙ロックを使う場合、 デッドロッ クについても考える必要がある。 暗黙ロックの軽視とは、いったん開発者がロックについて 考えていないと、ビジネストランザクション全体で予想外の形で失敗する可能性があるとい うことである。

ロックを機能させることは、フレームワークを取得する最善の方法を決定することであり、 暗黙的にロックシステムを実行する。 そのロックの種類の暗黙的な処理の例については、 軽 オフラインロックを参照してほしい。 上位レベルの暗黙ロックの実装は、 とても多くの種類 があるため、本書ですべてを紹介することはできない。

16.4.2 使用するタイミング

暗黙ロックを使う必要があるのは、 フレームワークの概念をもたない最もシンプルなアプ リケーション以外の場合である。 ロックを1つ忘れた場合、 そのリスクの大きさは計りしれ ない。

16.4.3 | 例: 暗黙オフラインロック (Java)

読み込み専用ロックのシステムを考えてみよう。 このアーキテクチャにはドメインモデル が含まれ、ドメインオブジェクトとリレーショナルデータベース間を仲介するものとして データマッパーを使っている。 フレームワークは、 読み込み専用ロックでドメインオブジェ クトのロックを獲得する。 その後ビジネストランザクションは、ドメインオブジェクトでい かなる処理でも行うことができる。

ビジネストランザクションで使われる任意のドメインオブジェクトは、マッパーの

第16章 オフライン並行性パターン

476

find() メソッドで配置される。 これは、ビジネストランザクションが find() を呼び出すこ とで直接的に、 またオブジェクトグラフを遷移して間接的に、マッパーを使ういずれの場合 にも適用できる。 次に、マッパーにロック機能を装飾する[Gang of Four] ことができる。 ロックを獲得するロックマッパーを記述してから、 オブジェクトの検索に取りかかろう。

interface Mapper...

public DomainObject find (Long id); public void insert (DomainObject obj): public void update (DomainObject obj); public void delete (DomainObject obj);

class Locking Mapper implements Mapper...

private Mapper impl;

public LockingMapper (Mapper impl) ( this.impl = impl;

public DomainObject find (Long id) {

ExclusiveReadLockManager.INSTANCE.acquireLock

id AppSessionManager.getSession().getId());

}

return impl.find(id);

}

public void insert (DomainObject obj)(

impl.insert(obj):

}

public void update (DomainObject obj)(

impl.update(obj);

public void delete (DomainObject obj) {

}

impl.delete (obj);

}

セッションのオブジェクトを1回以上検索することはよくあるので、上記コードを動作さ せるために、ロックマネージャーがセッションをロックする前に、 セッションがすでにロッ クを持っていないかをまずチェックする必要がある。 読み込み専用ロックではなく書き込み 専用ロックを使う場合は、ロックを獲得するときではなく更新や削除を行うときに、以前の ロック獲得をチェックするマッパー装飾子を記述する。

装飾子のメリットの1つは、ラップされているオブジェクトが機能を拡張していることが わからないことである。 以下のようにレジストリでマッパーをラップできる。

LockingMapperRegistry implements Mapping Registry...

オフライン並行性パターン

private Map mappers = new HashMap(); public void registerMapper (Class cls, Mapper mapper) { } mappers.put(cls, new LockingMapper (mapper)); public Mapper getMapper (Class cls) { } return (Mapper) mappers.get(cls);

ビジネストランザクションが、マッパーにアクセスして標準的な更新メソッドを呼び出す ときに実際に起こっていることを図16.5に示す。

Edit Customer Locking Mapper Customer Mapper Lock Manager Transaction load customer return customer acquireLock load customer

図 16.5 ロックマッパー

478

セッションステートパターン

17.1 クライアントセッションステート

セッションステートをクライアントに格納する。

17.1.1 動作方法

サーバ指向の設計でセッション識別子を保持するだけでも、少なくともクライアントセッ ションステートが必要になる。 アプリケーションによっては、クライアントのすべてのセッ ションデータを配置することもある。 そのような場合クライアントは、各リクエストでセッ ションデータのセットを送り、サーバは各レスポンスでセッションステートを返信する こ れでサーバは完全にステートレスになる。

データの転送処理には、 データ変換オブジェクトを使いたいと思う。 回線上で自らを直列 化することができるので、 複雑なデータでさえ送信することができるからだ。

さらに、クライアントはデータの格納を求める。 リッチクライアントアプリケーションの 場合、 インタフェース内のフィールドのように、構造の中でこれを行えるが、私としてはそ んな作業を行うならバドワイザーでも飲んでいたいものだ。データ変換オブジェクトやドメ インモデルなどの非ビジュアルオブジェクトを使う方がよい方法だ。 いずれの場合も大きな 問題はない。

HTML インタフェースを使う場合、 やや複雑になる。 クライアントセッションステート を実行するのによく使われているのは、 URL パラメータ、隠しフィールド、クッキーとい う3つの方法である。

URL パラメータは、少量のデータに対しても容易に機能する。 基本的にいずれのレスポ ンスページであっても、 URLがパラメータとしてセッションステートを取得する。 この機 能の限界は、 URL のサイズが限定されるためであるが、 データ項目が2つだけの場合は有 効である。 そのためセッションID などによく選択される。 プラットフォームによっては、

17

自動的にURLを書き換えてセッションIDを追加する。 URLの変更はブックマークで問題 になる場合があるので、一般的なWeb サイトにはURL パラメータを使うことに反対する 意見がある。

隠しフィールドは、ブラウザーに送ってもWebページに表示されないフィールドである。 <INPUT type = "hidden"> 形式のタグを使って取得する。 隠しフィールドを機能させるに は、リクエストに対してレスポンスおよび再読み込みを行う場合、フィールドへのセッショ ンステートを直列化し、データを隠し、フィールドに配置するフォーマットが必要になる。 標準的には XML が選択されるが、やや冗長であるといえる。 何らかのテキストベースのエ ンコーディングスキーマで、データをエンコードする方法もあるが、 隠しフィールドは表示 されるページから隠されているだけで、 ページソースを閲覧すれば誰でもデータが見られる ことを覚えていてほしい。

以前の Web ページや固定された Web ページを含む混合サイトには注意が必要である。 セッションデータへの遷移を行うと、 すべてのセッションデータを失う可能性がある。

最後に、賛否両論をもたらす選択はクッキーである。 クッキーでは返信と送信が自動的に 行われ、隠しフィールドとまったく同様に、その中に入れるセッションステートを直列化し て使う。 クッキーのサイズには限界があり、 多くの人はクッキーを好まず、 使わない設定に している。クッキーを使わない設定の場合は、サイトは機能しなかったが、 現在多くのサイ トでクッキーに依存する傾向が強くなってきているため、サイトが機能しないということは 減少している。 また、 純粋な企業内システムの場合、問題にならないことは確かである。

クッキーでは確実な安全性は保てないため、 あらゆる種類の不正な閲覧が起こり得ると考 えてほしい。 さらに1つのドメイン内でだけ機能するため、サイトがさまざまなドメイン名 で分割されている場合、 クッキーはその間を移動できない。

ブラットフォームによってはクッキーが有効かどうかを判断できるが、その機能がない場 合、 URL の再読み込み機能を使う。 データ量が極めて少ない場合、 このURL の再読み込み 機能によってクライアントセッションステートを簡素化できる。

17.1.2 使用するタイミング

クライアントセッションステートには多くのメリットがある。 クラスタリングとフェイル オーバーは、ステートレスサーバオブジェクトをサポートする場合、 特に有効に機能する。 もちろん、クライアントに障害が発生した場合にはすべてを失うが、 そのようになっても ユーザは覚悟して使っている場合が多い。

クライアントセッションステートのとらえ方は、データの量で幾何級数的に違ってくる。 2~3のフィールドの場合、 すべては有効に機能する。 データが大量の場合、データの格納 場所、およびリクエストで要求されるものを転送する時間コストの問題がとても深刻になる。

480

実行中のスタートポロジーに http クライアントが含まれている場合は特にこの傾向が強い。 さらに、セキュリティの問題もある。 クライアントに送信されるデータは、閲覧されたり、 修正されたりすることがとても多い。 これを防止する唯一の方法は暗号化であるが、それぞ れのリクエストで暗号化および複号化を行うことは、パフォーマンスに対して負荷がかかる。 暗号化しない場合、 不正な閲覧から隠ぺいした方がよいと思われるものを確実に送信しない ようにする必要がある。 finger サービスも不正に閲覧される場合があるため、送信したもの と、返信されたものが同じであると考えるべきではなく、 返信されるデータの妥当性確認を 再度徹底的に行わなければならない。

セッションの識別のためには、クライアントセッションステートを常時使う必要がある。 幸い、このクライアントセッションステートは1つだけなので、上記のどの仕組みでも負荷 はかからない。 さらに、セッションスティーリングについても注意が必要である。 セッショ ンスティーリングは、 悪意を持つユーザが、他人のセッションを妨害できるかどうかを確認 するため自らのセッションIDを変更するときに発生する。 プラットフォームではこのリス クを軽減するため、 ランダムなセッション ID を採用しているが、そうでない場合にはハッ シュを使ってシンプルなセッションID を実行する。

172 サーバセッションステート

サーバシステムのセッションステートを直列化形式で保持する。

17.2.1 動作方法

このパターンの最もシンプルな形式は、セッションオブジェクトをアプリケーションサー バのメモリ上に保持することだ。 こうしてセッション ID がキーとなるセッションオブジェ クトを保持するメモリ上に、数種類のマッピングを持つことができる。 つまり、クライアン トが行うべき唯一の動作は、 セッション ID を提供し、 セッションオブジェクトをマッピン グから検索しリクエストを処理することである。

この基本的なシナリオは、アプリケーションサーバがタスクを実行するのに必要なメモリ を十分に搭載していることを前提としている。 さらに、アプリケーションサーバは1つであ る。つまりクラスタリングが行われていないことを前提としているので、アプリケーション サーバに障害が発生した場合、 当然セッションが中止され、それまで行われたすべての処理 が消失する。

ほとんどのアプリケーションでこのような状況が問題になることはないが、一部のアプリ ケーションによっては問題となる場合もある。 この状況を回避するための対処方法は複数あ る。それにより基本的にシンプルなパターンにいくらか複雑さが加わり、共通のバリエー

ションが作られる。

最初は、 セッションオブジェクトによって保持されるメモリリソースの処理の問題である。 これはサーバセッションステートによく見られる難点である。 もちろん、その解決方法はメ モリ上にリソースを保持するのではなく、 すべてのセッションステートを永続的なストレー ジのメメント [Gang of Four]に直列化することである。 この方法を使う場合には、 次の2つ の点を決定する必要がある。 どのような形式でサーバセッションステートを永続化するかと いう点と、 どこで永続化するかという2点である。

サーバセッションステートの特長はプログラミングのシンプルさであるため、 使用する形 式はできる限りシンプルなものでなければならない。 いくつかのプラットフォームでは、極 めて簡単にオブジェクトのグラフを直列化できるシンプルなバイナリ直列化メカニズムを提 供している。 別の方法は、テキストや流行の XML ファイルなど別の形式で直列化すること である。

一般的には、プログラミングがほとんど不要なバイナリ形式の方が容易である。 一方、テ キスト形式の場合、 少しのコードが必要になる。 バイナリ直列化ではディスク容量も節約で きる。 総ディスク容量が問題になることは稀だが、 直列化した大型のグラフの場合、メモリ へのアクティブ化には、そのサイズに応じた時間がかかる。

バイナリ直列化には、一般的に次の2つの問題がある。 1つは、直列化形式は可視ではな い。もっとも、読みたいと思わなければ問題はない。 2つ目は、バージョニングの問題が発 生する可能性があることである。 たとえば、直列化した後にフィールドを追加してクラスを 修正した場合、 それを再読み込みできない場合がある。 もちろん、複数のマシンでクラスタ 化されている 365日24時間稼動のノンストップサーバを使って、 アップグレードされてい るマシンとされていないマシンが存在する環境でない限り、サーバソフトウェアのアップグ レードの影響を受けるセッションは少ない。

このため、サーバセッションステートをどこに格納するか決定することである。 明解に言 えることは、アプリケーションサーバ自体のファイルシステムかローカルデータベースのい ずれかに格納すべきだということである。 シンプルな方法であるがクラスタリングやフェイ ルオーバーを十分にサポートしない場合がある。 サポートするには、 パッシブ化されたサー バセッションステートで一般的にアクセスできる場所が必要である。 サーバの起動に長い時 間がかかるというコストはあるが、 クラスタリングとフェイルオーバーがサポートできる。 もちろんキャッシュ機能によってコストの大部分は削減することができる。

この解説は皮肉にも、セッションIDのインデックス付きのセッションテーブルを使って、 直列化されたサーバセッションステートをデータベースに格納するということを、推し進め ているかもしれない。 直列化されたサーバセッションステートを保持するために、テーブル にはシリアライズ LOB が必要になる。大型のオブジェクトを処理する場合、 データベースの パフォーマンスは変動するため、この方法ではデータベースに左右されることが極めて多い。

482

セッションステートパターン

現時点では、 私はサーバセッションステートとデータベースセッションステートとの境界 線の狭間に立っている。 境界はまったく任意のもので、私はサーバセッションステートの データをテーブルの形式に変換するポイントに対してその一線を画した。

サーバセッションステートをデータベースに格納する場合、 特に一般用のアプリケーショ ンでのセッション削除の処理について考える必要がある。1つの方法は、古いセッションを 検索して削除するデーモンを持つことであるが、この方法ではセッションテーブル上で多く の類似が発生することがある。 Kai Yu は、 成功した手法について次のように話してくれた。 セッションテーブルを12個のデータベースセグメントに分割し、 2時間ごとにセグメント を循環し、最も古いセグメント中のデータを削除し、そこにすべてのデータを挿入するよう 指定する。この方法では、24時間アクティブなセッションが突然落ちることもあるが、こ れはめったに起こらないため問題になることはないとのことである。

このようなバリエーションを実行するには、 多大な労力が必要となるが、幸いなことに最 近のアプリケーションサーバは、徐々にこれらの機能を自動的にサポートするようになって きている。 アプリケーションサーバのベンダーにとっては助けとなる作業であると思われる。

Java の実装

サーバセッションステートの最も普及している2つの技法は、 http セッション とステートフルセッション Bean を使う技法である。 http セッションはシンプル な方法であり、これを使って Web サーバはセッションデータを格納する。 ただし この方法によって、 多くはサーバアフィニティによりフェイルオーバーに対処で きなくなる。 ベンダーによっては、アプリケーションサーバで使うデータベース に、 http セッションデータを格納する共有 http セッション機能を実装している (もちろん手作業でもできることではある)。

ステートフルセッション Bean を使うというもう1つの方法では、 EJB サーバ が必要になる。 EJBコンテナは永続性とバッシブ化を処理するが、とてもプログ ラムしやすい。 ただし主な短所は、サーバアフィニティの回避をアプリケーショ ンサーバに要求する仕様になっていないことである。 しかし、 この機能を装備し ているアプリケーションサーバもある。 それがアプリケーションサーバの1つで ある IBM の WebSphere であり、 ステートフルセッション BeanをDB2の BLOB に直列化して、複数のアプリケーションサーバが状態を取得できる。

ステートレスセッション Bean の方がパフォーマンスがよいため、ステートフル Bean の代わりに使うべきだと言う人は多い。 率直に言って、これはまったくの誤り である。 まずステートフルとステートレス間の速度の違いが、使っているアプリ ケーションに影響を与えるかどうかを負荷テストで調べてみるとよい。 Thought Works 社には、数百人もの同時ユーザでテストを行った負荷テスト済みの

アプリケーションがある。 そのアプリケーションでは、ユーザ負荷サイズでステー トフル Bean を使っているが、何のパフォーマンスの問題も発生しない。 現在の負荷 ではパフォーマンスメリットがあまりなく、ステートフル Bean の方が容易な場合は、 こちらを使うべきである。 ステートフル Bean で注意すべき別の理由は、 フェイル オーバーがベンダー依存になるという問題である。 パフォーマンスの違いは、高負 荷の場合にしか発生しない。

別の代替方法としては、エンティティ Bean がある。 全体的に、私はエンティ ティ Bean にとても否定的だが、セッションデータのシリアライズ LOB を格納す るために使うことはできる。 とてもシンプルで、あまり問題は発生しない。

.NET の実装

サーバセッションステートは、ビルトインのセッションステート機能を使うと実 装しやすい。 デフォルトの場合、 .NET はセッションデータをサーバプロセス自体 に格納する。さらに、ステートサービスを使ってストレージを調整することがで きる。ステートサービスは、ローカルマシンまたはネットワーク上のマシンのい ずれかに常駐できる。 個別のステートサービスを使うと、 Web サーバをリセット し、セッションステートを保持できる。 プロセス内の状態と構成ファイル内のス テートサービスの間で変更を行うと、 アプリケーション全体の変更は必要ない。

17.2.2 使用するタイミング

サーバセッションステートの一番の魅力はシンプルさである。 大半は、 これを動作させる プログラミングがまったく必要ない。 プログラミングしなくてもよいかどうかは、 メモリ内 の実装をどうするかで決まる。 実装が必要な場合は、 アプリケーションサーバプラット フォームの機能が大きな助けになる。

機能がなくても実装はわずかな労力で済む。 BLOB をデータベーステーブルに直列化す ると、サーバオブジェクトをテーブルの形式に変換するよりかなりの労力を削減できる。

プログラミングの成果が試されるのは、セッションの保守である。 クラスタリングやフェ イルオーバーをするためサポートを行う場合、 特にその成果は大きい。 ただし、 処理データ 量があまり多くない場合やセッションデータが容易にテーブル形式に変換できる場合、他の 選択肢よりも多くの問題を生じることもある。

484

173 | データベースセッションステート

コミットされたデータのセッションデータをデータベースに格納する。

17.3.1 | 動作方法

呼び出しがクライアントからサーバへ送られる場合、サーバオブジェクトはまずデータ ベースからリクエストに必要なデータを抜き出す。 次にサーバオブジェクトは処理を行い、 データをデータベースに返して保存する。

データベースから情報を抜き出すため、サーバオブジェクトはセッションについての情報 を必要とする。 ここで、クライアントに格納されているセッション ID の番号は必須である。

通常この情報は、データベース内でデータを見つけるために必要なキー群でしかない。

含まれているデータは、ローカルで現在相互作用しているデータとすべての相互作用でコ ミットされたデータの混合である。

ここで考えるべき問題の1つは、セッションデータはセッションにローカルなものであり、 セッション全体がコミットされるまでは、システムの別の部分に影響を与えてはならないこ とである。 そのため、セッションのOrder で作業して、 中間状態をデータベースに保存し たい場合、 セッションの最後で確認されたOrder とは異なった方法で処理する必要がある。 理由は、 書籍の在庫や日々の収益などに関するデータベースに対し実行するクエリー内に、 保留中のOrder を頻繁に表示しないためである。

では、どのようにセッションデータを分離するのか。 セッションデータを持つデータベー ス行に、フィールドを追加することが1つの方法である。 このシンプルな形式で必要なのは、 論理 isPending フィールドだけである。 しかし、 より良い方法は、 セッション ID を Pending (保留) フィールドとして格納することである。 これで特定のセッションデータが とても見つけやすくなる。 レコードデータだけを求めるクエリーでは、 sessionID is not NULL 句を使って修正したり、 あるいはレコードデータをフィルタするビューが必要である。

セッション ID フィールドを使うのは、侵略的な解決方法である。 それは、レコードデー タベースにアクセスするすべてのアプリケーションがフィールドを認識し、セッションデー タを取得しないようにするためである。 ビューが有効に機能し、 他への影響を回避する場合 もある。 しかし、ビュー自身のコストが増大することも多い。

2つ目の代替方法は、 Pending (保留) テーブルの個別セットである。 データベースにす でに Orders および Order Lines テーブルがある場合、 Pending Orders (保留注文) およ び Pending Order Lines (保留注文品目) のテーブルを追加する。 そして、 Pending セッ ションのデータは Pending テーブルに保存する。 そして、それがレコードデータとなった ときに実際のテーブルに保存する。 これで多くの影響を回避できるが、テーブル選択ロジッ

クをデータベースマッピングコードに追加するため、 ある程度複雑にならざるを得ない。

レコードデータには、保留データに適用されない整合性のルールがある。 この場合、 Pending テーブルを使うことで、必要でない場合はルールを無視し、 必要な場合はルールを 実施することができる。 同様に妥当性確認ルールも保留データとして保存する場合は適用さ れない。 セッション内の場所によっては、異なる妥当性確認ルールが適用される場合もある が、これはサーバのオブジェクトロジックに示される。

Pending テーブルを使う場合、テーブルの正確なクローンとして動作する必要がある。 マッピングロジックもできる限り同じものにする。 2つのテーブル間では同じフィールド名 を使う必要があるが、 Pending テーブルにセッションID フィールドを追加して、 セッショ ンのデータを見つけやすくする。

セッションが中止または破棄される場合、セッションデータを空にする必要がある。 セッ ション ID を使って ID のついたデータを見つけて削除する。 ユーザが通知せずにセッショ ンを破棄する場合、タイムアウトメカニズムが必要になる。 数分ごとに実行されるデーモン は、古いセッションデータを探すことができる。この場合、セッションとの最新の相互作用 が実行された時間を保存するテーブルが必要になる。

更新によってロールバックはとても複雑なものになってしまう。 セッション全体のロール バックができるセッション内の既存の Order を更新する場合、 どのような方法でロール バックを行うのだろうか。1つの選択肢は、セッションを中止できないようにすることであ る。既存のレコードデータの更新も、リクエストの最後でレコードデータの一部になる。こ の方法はシンプルで、ユーザが直感的にわかりやすい。 代替方法は、 Pending フィールドま たは Pending テーブルのいずれかを使うことである。 修正しようとするデータを Pending テーブルにコピーして修正し、 セッションの最後でコミットし、そのデータをレコードテー ブルに返すことは容易である。 セッション ID がキーの一部になる場合にだけ、 Pending フィールドでこの方法が行える。 新旧のIDを同時に同じテーブルで保存することができる が、これはとても複雑なものになる。

セッションを処理するオブジェクトだけから読み込みができる個別の Pending テーブルを 使う場合、データをテーブル形式化するポイントがほとんどない場合は、シリアライズ LOB を使うことで改善できる。 ここからはサーバセッションステートの領域である。

保留データをまったく持たなければ、保留データのすべての問題を回避できる。 つまり、 データがすべてレコードデータと見なされるようなシステムを設計することである。 もちろ んこれが常に有効であるとは限らないし、できてもとても面倒な場合があるため、設計者は 明示的な保留データについては十分に考えなくてはいけない。 しかし、この選択肢が選べる ならデータベースセッションステートがとても処理しやすくなるといえる。

486

セッションステートパターン

17.3.2 使用するタイミング

データベースセッションステートはセッションステートを処理する1つの代替方法であり、 サーバセッションステートやクライアントセッションステートと比較してみる必要がある。

このパターンについて考えるべき第1の点は、パフォーマンスである。 サーバ上でステー トレスオブジェクトを使うことによってパフォーマンスが向上するため、プールや簡単なク ラスタリングを行える。 しかしその分、 それぞれのリクエストでデータベースへの挿入と抽 出に時間がかかる。 サーバオブジェクトをキャッシュすれば、このコストを削減することが できる。 キャッシュがヒットする場合は、データベースからデータを読み込む必要はなくな るが、それでも書き込みコストは必要になる。

第2は、 プログラミングに関する労力であり、ほとんどはセッションステートの処理に関 する作業であるが、 セッションステートがなく、 リクエストでデータをレコードデータとし て保存する場合は、明らかにこのパターンを選択する。 理由は、 労力とパフォーマンスのい ずれでも無駄がないからである (サーバオブジェクトをキャッシュする場合)。

データベースセッションステートとサーバセッションステートのどちらを選択するかの最 も大きな問題は、使っている特定のアプリケーションサーバにおいて、 サーバセッションス テートでクラスタリングとフェイルオーバーをサポートするのがどのくらい容易かというこ とにある。 データベースセッションステートのクラスタリングとフェイルオーバーの方がよ りわかりやすい方法である。

777-3 データベースセッションステート



18 ベースパターン

181 | ゲートウェイ

外部システムまたはリソースへのアクセスをカプセル化するオブジェクト。

Customer Lease PricingGateway Pricing Package Asset

ソフトウェアが孤立して動作することは稀である。 オブジェクト指向システムでも、リ レーショナルデータベーステーブル、 CICS トランザクション、 XML データ構造など、オ ブジェクト以外のものとつなぎ合わさっている。

このような外部リソースにアクセスする場合、リソースから API を取得する。 このAPI は、リソースをアカウントに取り入れるためやや複雑になっている。 リソースを理解しよう とする人は、リソースの API も理解すべきである。 たとえそれがリレーショナルデータ ベース用のJDBCやSQL、 あるいは XML 用の W3C や JDOM のいずれであっても理解す べきである。 API の知識が不足していると、 ソフトウェア全体の理解もなく、 将来のある時 点で、 何らかのデータをリレーショナルデータベースから XML メッセージにシフトする必 要があるときなどに変更がとても難しくなる。

ベースパターン

対策は一般的なものなので、 特に取り上げて述べる必要もないだろう。 特定の API コー ドをインタフェースが、 オブジェクトのように見えるクラスにラップすればよい。 他のオブ ジェクトは、ゲートウェイを介してリソースにアクセスし、シンプルなメソッド呼び出しを 特定の API に変換する。

18.1.1 動作方法

これは極めてシンプルなラッパーパターンである。 まず外部リソースを取得する。 アプリ ケーションはどのように処理する必要があるだろうか。 使用方法に応じたシンプルなAPI を作成し、 ゲートウェイを使って外部リソースを変換する。

ゲートウェイの主な使用法の1つは、 サービススタブを適用するための優れたポイントと して使うことである。 ゲートウェイの設計を変更して、 サービススタブを適用しやすくする 場合が多い。この方法を採用することを躊躇してはいけない。 この方法でサービススタブを 配置することによって、 システムのテストと書き込みが容易になる。

ゲートウェイは、できる限りシンプルにするべきである。 外部サービスの適合とスタブ機 能に優れたポイントを提供する基本的な役割に集中すればよい。 ゲートウェイをできる限り 最小化してタスクを処理する必要がある。 より複雑化したロジックは、 ゲートウェイのクラ イアントに配置する。

ゲートウェイを作成するために、コード生成を使うと有効である場合が多い。 外部リソー スの構造を定義することにより、 外部リソースをラップする Gateway クラスを生成するこ とができる。 また、リレーショナルメタデータを使ってリレーショナルテーブル用の Wrapper クラスを、 あるいは XML スキーマまたはDTD を使って XML 用のゲートウェ イのコードを生成することができる。 これでゲートウェイは単純な仕掛けとして動作するよ うになる。他のオブジェクトは多少複雑な各操作を実行する。

1つ以上のオブジェクトという観点からゲートウェイを構築することが優れたストラテ ジーである。 明白な形式は、バックエンドとフロントエンドの2つのオブジェクトを使うこ とである。 バックエンドは、 外部リソースに対して最小限のオーバーレイを果たすが、リ ソースのAPIはシンプルにはならない。 次のフロントエンドは、 複雑な API をアプリケー ションが使えるように、 より使いやすいものに変換する必要がある。 外部サービスのラッピ ングとニーズへの適合が極めて複雑な場合には、この手法は有効である。 それぞれが1つの クラスで処理されるからである。 逆に、 外部サービスのラッピングがシンプルな場合は、 1 つのクラスでラッピングなどすべてを処理することができる。

490

18.1.2 使用するタイミング

外部へのインタフェースが複雑な場合は常にゲートウェイの使用を考えるべきである。 複 雑さをシステム全体に拡大せずに、それらを格納するゲートウェイを使うのである。 ゲート ウェイを作成することで、システムの他の場所にあるコードを読み込むことがとても容易に なる。

ゲートウェイは、サービススタブの明確なポイントで、システムをテストしやすくする。 外部システムのインタフェースが有効でも、 サービススタブの適用は、第1段階として役 立つ。

さらにゲートウェイのメリットは、1種類のリソースから別のリソースにスワップアウト しやすくすることである。 Gateway クラスを変更するだけでリソースに何らかの変更を行 うことができ、変更はシステムの他の部分には影響しない。 ゲートウェイは、保護されたバ リエーションでしかもシンプルで強力な形式と言える。 ゲートウェイを使うことへの議論の 焦点は、こうした柔軟性に関するものになる。 しかし、 リソースの変更を考えていない場合 でも、ゲートウェイがもたらすシンプルさとテストの容易さは大変有効である。

上述したような一対のサブシステムがある場合、 サブシステムを分離する別の選択はマッ バーである。 ただし、マッパーはゲートウェイより複雑であるため、私は外部リソースへの アクセスへはゲートウェイを使っている。

このパターンをファサードやアダプター [Gang of Four] などの既存のこのパターンとは 異なった、 新しいパターンにすべきかどうかについてかなり悩んだことがある。 結局、 この パターンを他のパターンから分離することにしたが、それはこの区別が有効だと判断したか らである。

■ファサードは複雑化した API をシンプルにする一般向けのサービスを開発する ときに使う。 ゲートウェイは、 特定の使用目的を持つクライアントによって記 述される。 ファサードは常に隠ぺいされているインタフェースと考えられてい るが、ゲートウェイはラップされたファサード全体をコピーして置換またはテ ストのために使われる。

■アダプターは実装するインタフェースを変更し、別のインタフェースに適合さ せる。 実装をゲートウェイインタフェースにマッピングするためにアダプター を使用することはあるが、 ゲートウェイを使う場合は既存のインタフェースが 存在しないので、アダプターはゲートウェイの実装の一部になる。

■メディエータは複数のオブジェクトを分離する。 複数のオブジェクトは互いに 認識しないが、 メディエータは認識できる。 ゲートウェイでは2つのオブジェ クトのみ存在し、ラップされたリソースはゲートウェイを認識していない。

18.1.3 例: 固有のメッセージングサービスへのゲートウェイ (Java)

同僚の Mike Rettig と私はこのパターンについて話し合った。 彼は、 EAI (Enterprise Application Integration) ソフトウェアとのインタフェースを処理するためにこのパターン をどのように使ったかを話してくれた。私たちはこのパターンはゲートウェイの例として読 者に素晴らしいアイデアをもたらすものになるだろうと判断した。

事象を一般的なシンプルなレベルに保つため、 メッセージサービスを使ってメッセージを 送信するだけのインタフェースへのゲートウェイを構築する。 インタフェースは1つのメ ソッドだけで構築されている。

int send (String message Type, Object[] args);

最初の引数はメッセージの型を示す文字列であり、 2番目はメッセージの引数である。 メッセージングシステムを使って任意の種類のメッセージを送信できるため、このような汎 用インタフェースが必要になる。 メッセージシステムを構築するときには、システムが送信 するメッセージの型と対応する引数の数や型を指定する。 これで文字列 「CNFRM」 で確認 メッセージを構成し、文字列、整数、 ティッカーコードの文字列として、ID番号の引数を 持つことができる。 メッセージングシステムは引数の型を確認して、誤ったメッセージ、 ま たは誤った引数を持つメッセージを送信した場合にエラーを生成する。

これは必要不可欠な優れた柔軟性を提供する方法ではあるが、 汎用インタフェースは明示 的ではないため使いにくい。 インタフェースを見ただけでは、規定のメッセージの型や特定 のメッセージの種類に必要な引数はわからない。 代わりに必要になるのは、以下のようなメ ソッドを持つインタフェースである。

public void sendConfirmation (String orderID, int amount, String symbol);

この場合、 メッセージを送信するドメインオブジェクトが必要なら、以下のとおりに処理 する。

class Order...

public void confirm(){ if (isValid()) Environment.getMessageGateway().sendConfirmation (id, amount, symbol);

第16章 ベースパターン

メソッドの名前を見ればどのようなメッセージを送信しているかがわかり、 引数に型と名

492

前が与えられる。 汎用メソッドよりも、とても呼び出しやすいメソッドになっている。 役立 つインタフェースを作成するのが、 ゲートウェイの役割である。 しかし、これはメッセージ ングシステムでメッセージ型の追加または変更を行うときに常にGateway クラスを変更す る必要があり、 またメッセージ型を変更しない場合でも呼び出しコードを変更する必要があ ることを意味する。 この方法で、少なくともコンパイラでクライアントを見つけ、エラーを チェックすることはできる。

さらに別の問題もある。 インタフェースのエラーを受け取る場合は、リターンエラーコー ドが提供され、エラーが通知される。 0は正常終了を示し、 他のあらゆる数字は失敗を意味 し、それぞれの番号が異なったエラーを意味している。 Cプログラマが行う一般的な方法で はあるが、 Java で実行する方法とは言えない。 Java では例外を起こしてエラーを表示する。 そのため、ゲートウェイのメソッドはリターンエラーコードよりも例外を発生させる。

起こりそうなエラーはすべて、 私たちが無視しがちなものである。 次の2つのエラーだけ に話を絞ろう。 それは不明なメッセージ型によるメッセージの送信と、引数の1つが null 値であるメッセージの送信である。 リターンコードは、 メッセージングシステムのインタ フェースで定義される。

public static final int NULL_PARAMETER = -1; public static final int UNKNOWN_MESSAGE_TYPE = -2; public static final int SUCCESS = 0;

これら2つのエラーには大きな違いがある。 不明なメッセージ型のエラーは Gateway ク ラスのエラーを示す。 クライアントは完全に明示的なメソッドだけしか呼び出さないため、 クライアントはこのエラーを生成しない。 しかし、 クライアントはnull 値を渡すため、 null 値パラメータエラーは表示される。 エラーはプログラマのエラーを示し、チェック済みの例 外ではない (特定のハンドラーを記述するようなエラーではない)。 ゲートウェイは自ら null 値のチェックができるはずである。 しかし、 メッセージングシステムが同じエラーを発 生させるような場合は、チェックが有効ではない可能性がある。

このためゲートウェイは、明示的なインタフェースを汎用インタフェースに変換し、リ ターンコードを例外に変換する処理をする。

class MessageGateway...

protected static final String CONFIRM = "CNFRM";

private MessageSender sender;

public void sendConfirmation (String orderID, int amount, String symbol)( Object[] args = new Object[] (orderID, new Integer (amount), symbol); send (CONFIRM, args);

18-1 ゲートウェイ

ベースパターン

}

private void send (String msg, Object[] args) { } int returnCode = doSend (msg, args); if (returnCode == MessageSender. NULL_PARAMETER) throw new NullPointerException("Null Parameter passed for msg type: " + msg); if (returnCode != MessageSender. SUCCESS) throw new IllegalStateException( "Unexpected error from messaging system #: " + returnCode); protected int doSend (String msg, Object[] args) ( Assert.notNull(sender); return sender.send (msg, args);

このままでは、 dosend メソッドのポイントを見つけにくい。 そこでゲートウェイのもう 1つの重要な役割、つまりテスト機能を採用する。 メッセージ送信サービスがない場合も ゲートウェイを使うオブジェクトをテストできる。 それにはサービススタブを作成する必要 がある。 この場合、 ゲートウェイスタブはゲートウェイのサブクラスであり、 dosend を上 書きする。

class MessageGateway Stub...

protected int doSend (String messageType, Object[] args) {

int returnCode = isMessageValid (messageType, args);

if (returnCode == MessageSender. SUCCESS) {

messagesSent++;

return returnCode;

}

}

private int isMessageValid (String messageType, Object[] args) {

if (shouldFailAllMessages) return -999;

if (legalMessageTypes () .contains (messageType))

return MessageSender. UNKNOWN_MESSAGE_TYPE;

for (int i=0; i<args.length; i++) {

Object arg args[i];

if (arg == null) {

return MessageSender. NULL_PARAMETER;

}

}

return MessageSender. SUCCESS;

public static List legalMessageTypes () (

}

List result = new ArrayList(); result.add(CONFIRM);

494

return result;

false;

} private boolean shouldFailAllMessages = public void fail AllMessages () { } shouldFailAllMessages = true; public int getNumberOfMessages Sent () { return messagesSent; }

送信されたメッセージ数を取得することは、ゲートウェイが正常に動作しているかどうか をテストするのに役立つシンプルな方法である。

class GatewayTester...

public void testSend NullArg() { } try { gate().sendConfirmation (null, 5, "US"); fail ("Didn't detect null argument"); } catch (NullPointerException expected) ( } assertEquals(0, gate ().getNumberOfMessages Sent()); private MessageGateway Stub gate() { } return (MessageGateway Stub) Environment.getMessageGateway(); protected void setUp() throws Exception ( Environment.testInit(); }

クラスが既知の場所から発見できるようにゲートウェイを設定して、 静的な環境インタ フェースを作っている。 プラグインを使って、 システム構成時にサービスとスタブの間を切 り換えたり、テストを設定するルーチンでサービススタブを使う環境を初期化したりする。

この場合、ゲートウェイのサブクラスを使ってメッセージングサービスのスタブを作成す るが、サービス自体のサブクラス化 (または再実装) を行うという別の方法もある。 テスト のため、 送信するサービススタブにゲートウェイを接続する。 サービスの再実装があまり困 難でない場合には有効である。 サービスのスタブを作成するか、 またはゲートウェイのスタ ブを作成するかを選択する。 場合によっては、 ゲートウェイのクライアントをテストするス タブ化されたゲートウェイと、 ゲートウェイ自体をテストするスタブ化されたサービスの画 方を使うことで、両方のスタブの作成が役立つ場合もある。

BB-1 ゲートウェイ

18.2 マッパー

独立した2つのオブジェクト間の通信を設定するオブジェクト。

第16章 ベースパターン

Customer Lease PricingMapper Pricing Package Asset

互いに環境設定が不明な状態で、 2つのサブシステム間の通信を設定しなければいけない 場合がある。 設定が必要な理由は、2つのサブシステムを修正できない、あるいは修正はで きるが2つのサブシステムの間、 または2つのサブシステムと他の分離している要素との間 に依存性を作成したくないからである。

1821 動作方法

マッパーはサブシステム間の分離レイヤである。 レイヤは、どちらのサブシステムにも互 いを認識させることなく、両者間の通信の詳細を制御する。

多くの場合、マッパーは、1つのレイヤから別のレイヤにデータをシャッフルする。 シャッフル動作をアクティブにすると、極めて容易に動作方法を確認できる。 マッパーを使 うときに難しいのは、マッパーを呼び出す方法の決定である。 それは、 マッピングしている サブシステムのいずれからも、マッパーを直接呼び出せないためである。 第3のサブシステ ムがマッピングを開始して、マッパーを呼び出す場合もある。 代替方法としては、1つまた は他のサブシステムのオブザーバー[Gang of Four] をマッパーとして機能させる方法があ る。この方法では、サブシステムの1つのイベントをリッスンすることによって呼び出せる。

マッパーの動作方法は、マッピングレイヤの種類に左右される。 マッピングレイヤで普及 している例では、データマッパーを使う。 マッパーの使用方法についての詳細は、 データ マッパーを参照してほしい。

18.2.2 使用するタイミング

基本的に、マッパーはシステムの異なる部分を分離させる。分離させたい場合は、 マッ パーとゲートウェイのどちらを使うかを選択する。 コードの記述とその後の両面で、 マッ パーよりもゲートウェイの方がはるかにシンプルであるため、 ゲートウェイを選択すること が多い。

どちらのサブシステムも相互作用に依存しないようにする場合はマッパーだけを使う。 マッパーが重要になるのは、サブシステム間の相互作用が特に複雑で両サブシステムの目的 から逸脱する場合である。 このように、エンタープライズアプリケーションでは、マッパー はデータマッパーなどのようにデータベースとの相互作用に使うことがほとんどである。

マッパーは異なる要素に対して使われるため、メディエータ [Gang of Four]にも似てい る。 ただし、 メディエータを使うオブジェクトは、 お互いのオブジェクトは認識していなく てもメディエータを認識している。 これに対して、 マッパーが分離するオブジェクトは、 マッパーさえも認識していない。

18.3 レイヤスーパータイプ

レイヤのすべてのタイプに対して、スーパータイプとしての役割を果たすタイプ。

1つのレイヤのオブジェクトが、システム全体では複製されたくないメソッドを持つ場合 が多い。この振る舞いを共通のレイヤスーパータイプに移動させる。

18.3.1 動作方法

レイヤスーパータイプはシンプルな考えに基づくとても短いパターンである。 必要なのは、 1つのレイヤ内にあるオブジェクトのスーパークラスである。 たとえば、ドメインモジュー ルのドメインオブジェクトである Domain Object (ドメインオブジェクト) スーパークラ スがある。 一意フィールドの格納や処理などの共通の機能をレイヤスーパータイプに移動で きる。 同様に、マッピングレイヤのすべてのデータマッパーが、 共通のスーパークラスを持 つすべてのドメインオブジェクトに依存することもできる。

レイヤに1種類以上のオブジェクトがある場合、複数のレイヤスーパータイプを持つのは 有用である。

49

183 レイヤスーパータイプ

18.3.2 使用するタイミング

第16章 ベースパターン

レイヤのオブジェクトから共通の機能を取得する場合に、レイヤスーパータイプを使うと よい。 私は多数の共通機能を利用するため、これを自動的に行っている場合が多い。

1833 例: ドメインオブジェクト (Java

ドメインオブジェクトでは、 ID処理のための共通のスーパークラスを持つ。

class DomainObject...

private Long ID; public Long getID () { } return ID; public void setID (Long ID) { } Assert.notNull (Cannot set a null ID", ID)this.ID = ID: public DomainObject (Long ID){ this.ID = ID: } public DomainObject() { }

;

498

|18.4 セパレートインタフェース

実装から分離したパッケージでインタフェースを定義する。

domain Customer Order DataMapper Interface= UnitofWork UnitofWorkImpl

システム開発を行うときには、システムの各部分間の結合を最小限にすることによって、 設計の質を向上させることができる。 これを実現するための優れた方法は、クラスをパッ ケージにまとめてパッケージ間の依存性を制御することである。1つのパッケージのクラス が、どのように別のパッケージのクラスを呼び出すかというルールに従うことでこれを行う。 このルールはたとえば、ドメインレイヤのクラスは、presentation (プレゼンテーション) パッケージのクラスを呼び出してはならないというようなものである。

ただし、一般的な依存構造にあてはまらないメソッドを呼び出すこともある。 この場合 つのパッケージでセパレートインタフェースを使ってインタフェースを定義し、別のバッ ケージでインタフェースを実装する。 この方法によって、 インタフェースに依存する必要が あるクライアントが、 実装を一切心配する必要がなくなる。 セパレートインタフェースで ゲートウェイとの適切なプラグインポイントが提供される。

14 セパレートインタフェース

18

18.4.1 動作方法

パターンはとても簡単に採用することができる。 基本的に実装はインタフェースに依存し ているが、その逆の依存はないためである。 これは、インタフェースと実装を別々のパッ ケージに配置でき、 implementation (実装) パッケージは interface (インタフェース) パッケージに依存するということである。 他のパッケージは implementation パッケージに 依存することなく interface パッケージに依存する。

当然、 ソフトウェアを実行するにはいくつかのインタフェースを実装する必要がある。 コ コンパイル時に2つのパッケージを結び付ける別のパッケージを使うか、またはシステム構成 時にプラグインを使うかのいずれかの方法でインタフェースを実装する。

(冒頭のスケッチにあるように) インタフェースはclient (クライアント) パッケージに 配置するか、または(図18.1 のように)3つ目のパッケージに配置することができる。 実装 するクライアントが1つだけ、 またはクライアントが同じパッケージにある場合にも、 同様 にインタフェースをクライアントに配置できる。 インタフェースのクライアントへの配置に ついては、 client パッケージ開発者がインタフェースの定義の責任を担うのが適切である。 基本的に client パッケージは、 client パッケージが定義するインタフェースを実装する他の 任意のパッケージとともに動作するパッケージである。 client パッケージが複数ある場合は、 3つ目の interface パッケージを使う方が有効である。 クライアントパッケージ開発者がイ ンタフェースの定義の責任を担っていないことを明確にしたい場合にも、この方法が有効で

ある。 実装の開発者が責任を担っている場合にも同様である。

orders Customer Order DataUtils UnitOfWork DataMapper UnitOfWorkImpl

図 18.1 セパレートインタフェースを3つ目のパッケージに配置

インタフェースに使う言語の特徴を考える必要がある。 Java や C# などのインタフェー ス構造体を持つ言語の場合、インタフェースキーワードは当然の選択である。 しかし、最良

ベースパターン

500

の選択ではないかもしれない。 抽象クラスは、 クラス内に共通ではあるが、選択できる実装 の振る舞いを持てるので、 優れたインタフェースを作成できる。

分離したインタフェースについて考えるべき点の1つは、実装のインスタンス化方法であ る。 それには Implementation クラスの知識が必要になる場合がほとんどである。分離した Factory (ファクトリー) オブジェクトを使うのが一般的な手法である。この場合もセバ レートインタフェースがある。 さらに実装をファクトリーにバインドするので、 プラグイン を使って処理を行う。 つまり、 依存性が生じないばかりか、 システム構成時まで Implementation クラスについて決定する必要がない。

プラグインを使うほどではない場合のシンプルな代替案は、 インタフェースと実装の両方 を認識する別のパッケージを使って、 アプリケーション起動時にオブジェクトのインスタン スを作成するという方法である。 セパレートインタフェースを使うオブジェクトは、自らを インスタンス化できるか、 または起動時にインスタンス化されるファクトリーを持っている かのいずれかである。

18.4.2 使用するタイミング

システムの2つの部分間の依存性を排除する必要がある場合、セパレートインタフェース を使う。 いくつかの例を以下に示す。

framework (フレームワーク) パッケージが、 特定のアプリケーションコード を呼び出す必要があるときに、 共通のケースに対応する抽象コードを構築して framework パッケージに挿入する場合。

■1つのレイヤが、認識すべきでない別のレイヤのコードを呼び出す必要があると きに、レイヤ内にあるデータマッパーを呼び出すドメインコードなどのいくつ かのコードを持つ場合。

別の開発グループによって開発された関数を呼び出す必要があるが、 API に依 存することを望んでいない場合。

私が出会った数多くの開発者は、記述するクラスごとに別のインタフェースを使っている。 しかし、アプリケーション開発では、この方法は負荷がかかりすぎると私は考える。 個別の インタフェースと実装の保持は、 特に (インタフェースと実装を持つ) Factory クラスも必 要になってくるため、 無駄な作業も入ってくる場合が多い。 アプリケーションのためには、 依存性を排除したい場合または複数の独立した実装を持つ場合にだけ、分離したインタ フェースを使うことをお勧めする。 この方法は、インタフェースと実装をともに配置した後 で分離するとき、 分離処理を必要な時まで遅延できるシンプルなリファクタリングである。

第16章 ベースパターン

この方法で依存性を決定して管理することは、 度合いによっては不要な作業になる場合が ある。 依存性だけを考えてオブジェクトを生成し、その後そのインタフェースを使っても問 題はない。 問題は、 構築時に依存性チェックの実行などの依存性ルールを実施しようとする 場合に発生する。 発生した場合は、 すべての依存性を削除しなければならない。 小規模シス テムでは依存性ルールを実施しても問題は大きくはならないが、大規模システムではルール を遵守させることが極めて重要である。

18.5 レジストリ

他のオブジェクトが一般的なオブジェクトとサービスを検索するために使う既知のオブ ジェクト。

Registry 1 getPerson (id) addPerson (Person)

オブジェクトを検索したい場合、 関連する別のオブジェクトから開始し、 関連を使って検 索したいオブジェクトへ遷移する。 Customer の Order すべてを検索したい場合、 Customer オブジェクトから開始し、 オブジェクト上のメソッドを使ってOrder を取得す る。ただし、開始するためのオブジェクトがない場合もある。 たとえば、 CustomerのID 番号は認識しているが、参照できないときがある。 このような場合、 いくつかの種類の lookup (照合) メソッド、 つまり find メソッドが必要である。 ただし、 find メソッドを取 得する方法には、どちらにしろ問題も残る。

基本的にレジストリは、たとえ一見するとグローバルには見えない場合でも、グローバル オブジェクトまたは少なくともグローバルオブジェクトに似たオブジェクトである。

18.5.1 | 動作方法

すべてのオブジェクトに言えることだが、 インタフェースと実装の観点からレジストリの 設計について考える必要がある。 インタフェースと実装を同じように考える人が多いが、そ れは誤りであり、 多くのオブジェクトと同様これら2つは極めて異なる。

最初に考えるべきなのはインタフェースで、レジストリの場合私が好むインタフェースは 静的なメソッドである。 クラス上の静的なメソッドは、 アプリケーション内のどこに配置さ れていても見つけやすい。 さらに、 好みの任意のロジックを静的なメソッド内でカプセル化

502

できる。 ロジックには、 (静的あるいはインスタンスのいずれかの) 他のメソッドへの委譲 が含まれている。

ただし、メソッドが静的であるからといってデータも静的なフィールドになければいけな いということはない。 定数でない限り、私はほとんど静的なフィールドを使わない。

データの保持方法を決定する前に、データのスコープについて考えたい。レジストリの データは、実行方法によって異なる。 プロセス全体でグローバル、スレッドの中でグローバ ル、セッションの中でグローバルのようにさまざまである。 スコープが異なると、異なる実 装が必要となるがインタフェースは必要ない。 アプリケーションプログラマは、 静的なメ ソッド呼び出しがプロセススコープまたはスレッドスコープのいずれであるかを知る必要は ない。 異なるスコープに異なるレジストリを持つことも、異なるメソッド内に異なるスコー プの1つのレジストリを持つこともできる。

データがプロセス全体で共通の場合、 静的なフィールドが1つの選択肢となる。ただし、 置換ができないため、 私が静的な可変フィールドを使うことは稀である。 特定の目的、 特に テストのためにレジストリの置換が可能であれば、 とても役立つ (プラグインはテストのた めの優れた方法である)。

プロセススコープレジストリの場合には、選択肢はシングルトン [Gang of Four] である。 レジストリクラスには、レジストリインスタシスを保持する静的な1つのフィールドがある。 シングルトンを使うと、 呼び出し元が内在するデータに明示的にアクセスできる場合が多い が (Registry.soleInstance.getFoo ())、 私は、 Singleton (シングルトン) オブジェクト が隠ぺいされる静的なメソッドの方を好む (Registry.getFoo ())。 C ベースの言語では、 静的なメソッドがプライベートインスタンスデータにアクセスできるメソッドは特に有効で ある。

シングルトンはシングルスレッドのアプリケーションで広く使われているが、マルチス レッドのアプリケーションでは問題になる可能性がある。 理由は、予測不可能な方法で、複 数のスレッドが同じオブジェクトの処理を簡単に行ってしまうからである。 この問題は同期 化することで解決できるが、 同期化コードの記述は難しく、 パグをすべて取り除く頃には神 経を病むことになりかねない。 この理由で、 私はマルチスレッド環境での可変データに対す るシングルトンは勧めない。 変更できないデータは何であれスレッドクラッシュの問題に陥 ることはない。 シングルトンは、不変データに対しては有効である。 そのため米国全州のリ ストのようなデータは、プロセススコープレジストリのよい例になる。 データは、プロセス が開始されて変更の必要がないときにロードする。 あるいは稀な場合だが、いくつかの種類 のプロセス割り込みによって更新される場合がある。

一般的なレジストリデータはスレッドスコープである。 例としてはデータベース接続が適 している。 多くの環境では、Java スレッドローカルなどの形式のスレッド専用記憶域を提 供している。 代替技術は、 スレッドがキーとなるディクショナリであり、 スレッドの値が

データオブジェクトである。 接続のリクエストがあると、 現在のスレッドがディクショナリ を照合する。

スレッドスコープデータについて忘れてはならない重要なことは、それがプロセススコー プデータと同じように見えるということである。 私は、プロセススコープデータにアクセス するときと同じ形式の、 Registry.getDbConnection() などのメソッドを使う。

ディクショナリ照合も、 セッションスコープデータに使える技術である。 必要なのはセッ ション ID であるが、リクエストの開始時にスレッドスコープレジストリに配置する。 後続 するセッションデータにアクセスする場合、 マッピングのデータを照合する。 マッピングは セッション ID を使うセッションがキーとなっていて、 セッション ID はスレッド専用のス トレージに保持されている

静的なメソッドを持つスレッドスコープレジストリを使う場合、 複数のスレッドでメソッ ドを使うとパフォーマンスに問題が起きる場合がある。 この場合、 スレッドインスタンスに 直接アクセスすることでボトルネックを回避できる。

1つのレジストリを持つアプリケーションもあれば、いくつかのレジストリを持つアプリ ケーションもある。 普通レジストリは、システムレイヤまたは実行コンテキストで分割され る。私が好む方法は、実装ではなくレジストリを使用方法ごとに分割する方法である。

18.5.2 使用するタイミング

レジストリはメソッドのカプセル化にも関わらずグローバルデータであるため、 私は使う ことを躊躇してしまう。 アプリケーションにいくつかの形式のレジストリを見つける場合が とても多いが、レジストリを使うよりは、相互のオブジェクト参照を介してオブジェクトへ のアクセスを常に試みることにしている。 基本的に、レジストリは最後の手段として使うべ きである。

レジストリを使うための代替方法がいくつかある。その1つは、広範囲で必要なデータを パラメータとして渡すことである。 問題は、 パラメータはメソッド呼び出しに追加されるが、 パラメータを必要とするのは呼び出されたメソッドではなく、 呼び出しツリーのさらに下方 にあるレイヤの別のメソッドであるという点である。 データが処理時にほとんど必要ない場 合、 パラメータに渡すよりも私ならレジストリを使うことにする。

レジストリについてのもう1つの代替方法は、オブジェクト作成時に共通データの参照を オブジェクトに追加することである。 コンストラクタに不必要なパラメータを追加すること になるが、少なくともそれはコンストラクタでは使われる。 この場合、 メリットより問題の 方が多いが、データがサブクラスで使われるのであれば、この技法で制限することができる。

レジストリの問題の1つは、新しいデータを追加するごとに修正しなければならないこと である。このため、グローバルデータのホルダーとしてマッピングを好む人もいるが、私は

第1章 ベースパターン

504

明示的なクラスを好む。 理由は、明示的なクラスはメソッドを明示的に保ち、 検索に使う キーとの混乱が生じないからである。 明示的なクラスを使うと、ソースコードや生成された 文書を見るだけで、使うデータを調べることができる。 マッピングでは、どのようなキーを 使っているかを見つけるために、システムの中でマップにデータの読み書きを行っている部 分を探したり、 すぐに不要になるドキュメントに頼らなければならない。 明示的なクラスで は、静的な型付き言語で型の安全性を維持でき、システム拡張に合わせてリファクタリング するためにレジストリの構造をカプセル化する。 そのままのマッピングはカプセル化されて いないため、実装を隠ぺいすることが難しい。 データの実行スコープの変更が必要な場合、 特に問題になる。

したがって、レジストリを使う方が適している場合が多い。 しかし、 どのようなグロー バルデータであっても完全に正常であることが実証されるまでは問題が潜んでいることを 忘れてはいけない。

18.5.3 例: シングルトンレジストリ (Java)

データベースからデータを読み込んだ後、データを変更して情報に変えるアプリケーショ ンを考えてみよう。 データにアクセスするために、 行データゲートウェイを使うとてもシン プルなシステムを想定する。 システムは、データベースクエリーをカプセル化する Find オ ブジェクトを持っている。 find メソッドは、 インスタンスとして作成されるのが最も有効で ある。 理由は、テストのためのサービススタブを作成するために、 インスタンスを置き換え ることができるからである。 インスタンスを配置する場所を選択する必要がある。 レジスト リが当然の選択である。

シングルトンレジストリは、シングルトンパターン [Gang of Four] のシンプルな例であ る。 1つのインスタンスに対し1つの静的な変数を持つ。

class Registry...

private static Registry getInstance() { } return soleInstance; private static Registry soleInstance =

new Registry();

レジストリに格納されているデータはインスタンスに格納される。

class Registry...

protected PersonFinder personFinder = new PersonFinder();

1

ただしアクセスを簡単にするため、 静的なパブリックメソッドを使う。

ベースパターン

class Registry...

public static PersonFinder personFinder () {

return getInstance().personFinder;

}

1つの新しいインスタンスを作成するだけで、 レジストリを再初期化できる。

class Registry...

public static void initialize() { } soleInstance = new Registry();

テストのためにサービススタブを使いたい場合、 代わりにサブクラスを使う。

class RegistryStub extends Registry...

public RegistryStub() { personFinder = new PersonFinderStub(); )

find メソッドサービススタブは、 Person 行データゲートウェイの直接書かれたインスタ ンスを返すだけである。

class PersonFinderStub...

public Person find (long id) { if (id == 1) { } return new Person("Fowler", "Martin", 10); throw new IllegalArgumentException("Can't find id: + String.valueOf(id));

メソッドをレジストリに配置してレジストリをスタプモードで初期化し、スタブの振る舞 いをサブクラスに保持することによって、 テストに必要なコードを分離することができる。

506

class Registry...

public static void initializeStub() ( soleInstance = new RegistryStub(); }

18.5.4 例: スレッドセーフレジストリ (Java)

(by Matt Foemmel, Martin Fowler) 上記のシンプルな例は、異なるスレッドが独自のレジストリを必要とするマルチスレッド アプリケーションでは動作しない。 Java は、 スレッドにローカルな Thread Specific Storage (スレッド専用のストレージ) 変数 [Schmidt] を提供し、スレッドローカル変数と 呼ばれている。 変数を使ってレジストリを作成し、レジストリは1つのスレッドに対して一 意とする。

class ThreadLocalRegistry...

private static ThreadLocal instances = new ThreadLocal (); public static ThreadLocalRegistry getInstance() { return (ThreadLocal Registry) instances.get(); }

レジストリは、獲得と解除のためのメソッドを設定する必要がある。 一般ザクションまたはセッション呼び出しの境界で行う。

的には、トラン

class ThreadLocalRegistry...

public static void begin() { } Assert.isTrue (instances.get() == null); instances.set (new ThreadLocalRegistry ()public static void end() { Assert.notNull (getInstance()); instances.set (null); }

);

次に、 person Find メソッドを格納する。

50

1-5 レジストリ

18

class ThreadLocalRegistry...

第16章 ベースパターン

private PersonFinder personFinder = new PersonFinder();; public static PersonFinder personFinder () { } return getInstance().personFinder;

begin メソッドと end メソッドで、外部からの呼び出しがレジストリをラップする

try { ThreadLocalRegistry.begin(); PersonFinder f1 = ThreadLocalRegistry.personFinder(); Person martin = Registry personFinder().find(1); assertEquals("Fowler", martin.getLastName()); } finally {ThreadLocalRegistry.end(); }

18.6 バリューオブジェクト

ID に基づいた等価性を確保していない、 Money や Date Range などのシンプルな小型 オブジェクト。

さまざまな種類のオブジェクトシステムを使うとき、 参照オブジェクトとバリューオブ ジェクトの相違が役立つことに気づいた。これら2つのオブジェクトではバリューオブジェ クトの方が小型であり、純粋にオブジェクト指向ではない多くの言語にあるプリミティブな 型に類似している。

18.6.1 | 動作方法

参照オブジェクトとバリューオブジェクトの相違の定義は難しい場合がある。 広い意味で は、バリューオブジェクトはMoney (貨幣) オブジェクトやDate (日付) オブジェクトな どの小型のオブジェクトであり、 一方参照オブジェクトは Order オブジェクトや Customer オブジェクトなどの大型のオブジェクトである。 この定義は便利だが、 どちらか というと不適切である。

参照オブジェクトとバリューオブジェクトの主な相違点は、 等価性の処理の方法である。 参照 オブジェクトはID を等価性の基準として使う。 ID は、 オブジェクト指向プログラミン グ言語のビルトインIDなど、プログラミングシステム内のIDであったり、リレーショナ ルデータベースの主キーなど何らかのID番号であったりする。 バリューオブジェクトの等

508

価性の概念はクラス内のフィールド値に基づいている。 2つのDateオブジェクトで日、月、 年の値が同じ場合は、 等価ということになる。

相違点は、2つのオブジェクトを処理する方法で明白になる。 バリューオブジェクトは小 型で容易に生成されるため、 参照ではなく値によって渡される場合が多い。 March 18, 2001 (2001年3月18日) オブジェクトがシステム内にいくつ存在するかを意識する必要はあま りない。 さらに、 2つのオブジェクトが同じ物理データオブジェクトを共有しているのか それとも異なっているが同じデータのコピーであるかどうかなどを意識する必要もない。

ほとんどの言語はバリューオブジェクトの特定の機能を持っていない。 バリューオブジェ クトが機能するためには、バリューオブジェクトを不変、つまり作成時のフィールドがその まま変更できないようにすることが有効である。 理由は、 別名割り当てのバグを防止するた めである。 別名割り当てのバグは、2つのオブジェクトが同じバリューオブジェクトを共有 し、一方のOwner がオブジェクトの値を変更するときに発生する。 したがって、 Martin の雇用日付が3月18日で、 Cindy も同じ日に雇用されたことを知っている場合、 Cindy の 雇用日付は、 Martin の雇用日付と同じに設定する場合がある。 Martin が自分の雇用日付 の月を5月に変更する場合、 Cindy の雇用日付も変更される。 正しいかどうかに関係なく 変更される。このように値が少ない場合、 既存の Date (日付) オブジェクトを新しいオブ ジェクトに置き換えて、 雇用日付を変更する。 バリューオブジェクトを不変にするだけで完 成する。

バリューオブジェクトは完全なレコードとして永続化しない。 バリューオブジェクトでは なく、組込バリューまたはシリアライズ LOB を使うとよい。 バリューオブジェクトは小型 であるため、組込バリューが最良の選択肢である。 組込バリューはバリューオブジェクトの データを使う SQL クエリーも発行できるからである。

特に、バリューオブジェクトを処理しない Java などの言語でバイナリ直列化を多く行う 場合、 バリューオブジェクトの直列化を最適化してパフォーマンスを向上できる。 バリューオブジェクトの例については、マネーを参照してほしい。

.NET の実装

.NET はバリューオブジェクトを処理するという優れた機能を持っている。 C# の場合、オブジェクトはクラスではなく構造体として宣言することによって、バ リューオブジェクトとしてマーク付けされ、値のセマンティクスでバリューオブ ジェクトを処理する。

18.6.2 使用するタイミング

第16章 ベースパターン

等価性を確保するために ID以外を基準にしたい場合、 基準をバリューオブジェクトで処 理するとよい。 作成が簡単な小型の任意のオブジェクトでこの方法は有効である。

18.6.2.1 名前の衝突

かなり以前から、バリューオブジェクトという名称がこのパターンに使われていることを 知っている。 残念なことに、 最近 J2EE コミュニティ [Alur et al.) では、 バリューオブジェク トという名称はデータ変換オブジェクトの意味で使っているため、パターンコミュニティでは 争いの原因になっている。 この論争は、 業界で常に起こる名前に関する争いの1つに過ぎな い。 最近 [Alur et al] は、上記の代わりに変換オブジェクトという名称を使うことに決めた。

私は、引き続きバリューオブジェクトを本文で使うことにする。 少なくとも私の執筆内容 が、私が以前執筆した内容と同じであれば何の問題もないはずだ。

|187 マネー

貨幣の値として機能する。

Money amount currency allocate >,>, <, >,

コンピュータは Money (貨幣) を処理しているが、困ったことに主流のプログラミング 言語はどれも Money を最重要データ型として扱っていない。通貨を扱う環境にとって、型 がないことが問題の原因であることは明らかである。 すべての計算が1つの通貨だけで行わ れる場合、このことはあまり問題にならないが、複数の通貨を扱う場合は、 通貨の違いを無 視してドルを円に足したりしないようにするはずである。 最も難解なのは、 通貨の丸めに関 する問題である。 金銭の計算では最小通貨単位までに数値が丸められる場合が多い。 このた め丸めエラーにより小さな金額が失われてしまいやすい。

オブジェクト指向プログラミングのメリットは、 処理する Money クラスを作成して問題 を修正できることである。 意外なのは、主流のベースクラスライブラリにこれを処理する機 能がまったくないことである。

5 1 0

18.7.1 動作方法

基本的な考え方は、数量と通貨のフィールドを持つ Money クラスを持つことである。 数 量を整数型または固定小数点型のいずれかで格納する。 小数型が処理しやすい場合もあれば、 整数型が処理しやすい場合もある。 必ずどの種類であっても浮動小数点型は避ける必要があ る。 それを使うと Money で回避しようとしている丸めに関する問題を持ち込んでしまう。 多くの場合、 ドルのセントのように、最小の端数単位まで丸め処理された金銭の値が必要と される。 しかし、場合によっては小数単位も必要である。 処理している Money の種類を明 確にすることが重要であり、 特に両方の種類の丸めを使うアプリケーションの場合には重要 である。 演算は2つのケースで異なる振る舞いを示すため、2つのケースに対しそれぞれの 型を持つことが有効である。

Money はバリューオブジェクトのため、貨幣単位と数量に基づいて、 等価性とハッシュ コー ードの動作がオーバーライドされなければならない。

Money の場合、 Money オブジェクトを数字のように簡単に使えるような、 算術演算が必 要である。 しかし、 Money の算術演算と数字の Money 演算との間には、重要な相違点が いくつかある。 最も明確なのは、異なる貨幣単位の金銭を合算しようとする場合、加算や減 算では常に貨幣単位を認識する必要があることである。 シンプルでよく使われる対処方法は、 異なる貨幣単位の合算をエラーとして処理することである。 洗練された状況では、財布に関 する Ward Cunningham の考え方を使うこともできる。 複数の貨幣単位の Money をとも に1つのオブジェクトに含めるというオブジェクトである。 オブジェクトは、 Money オブ ジェクトのように計算に加わり通貨の貨幣単位での評価もできる。

乗算と除算は、 丸めの問題でさらに複雑になってしまう。 スカラー量で、 Money の乗算 を行う。 請求書に5%の税金を加算したい場合 0.05 を掛ける。 このように、通常の数値型 によって乗算の結果を得る。

特に、 異なる場所に Money を配分する際、丸めのためにさらに複雑になってしまう。こ こでは、 Matt Foemmel のシンプルな問題を紹介する。 Money の合計を2つの口座に配分 するというビジネスルールがあるとする。 つまり、1箇所には70%、 そしてもう1箇所に は30%である。 ここで、5セントを配分するとする。 計算すると、 3.5 セントと1.5セント になる。 どちらの方法で丸めを処理しても問題が起こる。 通常の四捨五入で処理すると、1.5 は2に、3.5は4になる。 つまり1セント増加する。 端数を切り捨てるなら4セントになり、 切り上げるなら6セントになるのである。 1セントの増加または減少を防止するため、この 分配に適用できる丸めの汎用スキーマはないのである。

この問題には、いろいろな解決策がある。

■私が最も行うのは、無視することである。 たった1セントの違いじゃないか。 もちろん、経理担当者の逆鱗には触れることになる。

■分配するときは常に、 分配済みの分から差し引いて最新の分配を行う。こうす ることでセントの損失を防止できるが、最新の分配の際にセントが累積されて いく可能性がある。

第16章 ベースパターン

Money クラスのユーザがメソッドを呼び出す時、 丸めスキーマを宣言する。 こ れによって、 プログラマは70%の側を切り上げて、 30%の側は切り下げると 宣言できる。 これが2口座ではなく、 10口座すべてに分配する場合は複雑にな る可能性がある。 丸めの処理を忘れてはいけない。 丸め処理を忘れないよう、 Money クラスが丸めパラメータに強制的に乗算させているのを私は見たことが ある。 プログラマは必要な丸め処理について考えるだけではなく、 書き込みの テストを行うことも忘れないようにする。 しかし、 すべて同じような方法で丸 めを処理する税金計算がたくさんある場合、 処理が難しくなる。

私の好む解決策は、金銭についてのアロケータ関数を持つことである。 アロケー タのパラメータは、分配すべき比率を表す数字のリストである (aMoney allocate ([73]) など)。 アロケータは Money リストを返し、 外部からは擬似乱数に見 える方法で、分配された Money にセントを分散させることによって、確実にセ ント単位で切り捨て分がないようにする。 アロケータには、 使い忘れてはいけ ないという欠点がある。 忘れてしまうと、セントの割り当て場所についての正 確なルールを実行することが難しくなってしまう。

ここでの基本的な問題は、 (税金など) 比例して課金されるものを乗算によって決めるこ とと、乗算によって複数の場所に金額を配分することの間にある。 乗算は、前者に対しては 正しく機能するが、後者に対してはアロケータの方が正しく機能する。 重要なことは、金銭 の値に対して乗算/除算を行う目的を考えることである。

aMoney.convert To (Currency.DOLLARS)などのメソッドを使って、1つの貨幣単位から 別の貨幣単位へ変換することができる。 変換のための明解な方法は、 交換レートを掛けるこ とである。 たいていの場合はこの方法で十分だが、丸めのためにうまく機能しない場合もあ る。ユーロ圏の固定された通貨間の変換規則には独特の丸め処理があったが、これはシンプ ルな乗算に機能しなかった。 それゆえアルゴリズムをカプセル化する Convertor オブジェ クトを持つほうが賢明である。

比較動作によって、金銭を分類できる。 加算演算と同様に、比較するには貨幣単位を認識 する必要がある。 異なる貨幣単位を比較する場合、 例外を発生させるか、 変換を行うかのい ずれかを選択する。

マネーは印刷の振る舞いをカプセル化できる。 カプセル化により、 ユーザインタフェース とレポートに良好な表示を行うことがとても容易になる。 さらに、 Money クラスは文字列 を解析して貨幣単位認識入力メカニズムを提供するが、これはユーザインタフェースにとっ

512

てとても有用である。 Money クラスは、プラットフォームライブラリが支援可能な場所で ある。 特定の国に対して特定の数のフォーマッターを使うことによって、ますます多くのプ ラットフォームがグローバル化をサポートしている。

データベースもまた金銭の重要性を理解していないようなので(ベンダーは理解しているの だが)、データベースにマネーを格納すると、いつでも問題が発生する。 取るべき方法は、 組 込バリューを使って金銭ごとに貨幣単位を格納することである。 たとえば、1つの口座に入っ ているのがすべてポンドの場合には、やりすぎになる場合がある。 この場合、口座に貨幣を格 納し、データベースのマッピングを修正し、口座の貨幣が引き出せるようにすればよい。

18.7.2 使用するタイミング

私はオブジェクト指向環境での大多数の数値計算に対してマネーを使う。 理由は、丸めの 振る舞いの処理をカプセル化するためである。 これによって、 丸めエラーの問題を減少させ ることができる。 マネーを使う別の理由は、複数の貨幣単位での動作がとても簡単になるた めである。 マネーに対する反対意見はパフォーマンスの問題である。 しかし私は、何らかの 著しい違いが発生したという話をほとんど聞いたことがない。 それどころかカプセル化 チューニングが簡単になる。

18.7.3 例: Money クラス (Java)

(by Matt Foemmel. Martin Fowler) 最初の決定事項は、数量に使うデータ型である。 浮動小数点数を推奨しないことを納得さ せる必要がある場合、 以下のコードを実行しよう。

double val = 0.00; for (int i = 0; i < 10; i++) val += 0.10; System.out.println (val == 1.00);

浮動小数点では安全ではないので、 固定小数点小数か整数のいずれかの選択になる。 Java では、BigDecimal BigInteger long になる。 整数値を使うと、内部の演算が容易にな る。 そして、 long を使うと、 基本形を使うことができ、それによって読み取り可能な計算 式を持つことができる。

class Money...

private long amount; private Currency currency:

第186塁ベースパターン

私は整数量、つまり最少の基本単位を使っている。 コード内では centと呼んでいるが、 いい名前だと思う。 long の場合、 数値があまりにも大きいとオーバーフローエラーが発生 する。 92,233,720,368,547,758.09 ドルを受け取る場合、 BigInteger を使うバージョンを記 述する。 種々の数値型からコンストラクタを提供できることは便利である。

public Money (double amount, Currency currency) ( } this.currency = currency this.amount = Math.round (amount * cent Factor()); public Money (long amount, Currency currency){ } this.currency = currency; this.amount = amount centFactor(); private static final int[] cents = new int[]{1, 10, 100, 1000); private int centFactor() { return cents [currency.getDefault FractionDigits() ]; }

貨幣単位が異なると、小数量も異なる。 Javal.4 の Currency クラスは、 クラスの小数の 桁数を通知する。 大きい方の単位の中に、 10の累乗で、 どのくらいの数の小さい方の単位 を入れるかを決定できるが、 Java ではとても面倒なので配列の方が簡単である(そのほう がおそらく処理速度が速い)。 これは、4つの小数桁を使った際にコードが壊れることにう まく対処する準備をしているのである。

多くの場合、金銭処理を直接使いたいと思うだろうだが、 基盤となるデータにアクセスす ることが必要な場合もある。

class Money...

public BigDecimal amount(){ } return BigDecimal.valueOf(amount, currency.getDefaultFractionDigits()); public Currency currency () {

return currency;

いかなる場合でも、 アクセスを使うかどうかを考える必要がある。 たいていはカプセル化 を破壊しない方法を選ぶが、無視できない例として組込バリューなどのデータベースのマッ ピングが挙げられる。

リテラルな量に1つの貨幣単位を頻繁に使う場合、ヘルパーコンストラクタが役立つ。

5 14

}

class Money...

public static Money dollars (double amount) { return new Money (amount, Currency. USD); }

Money はバリューオブジェクトなので、 同等を定義する必要がある。

class Money...

public boolean equals (Object other) { } return (other instanceof Money) && equals ((Money) otherpublic boolean equals (Money other) ( } return currency.equals (other.currency) && (amount

);

other.amount);

さらに、同等がある箇所は、必ずハッシュが必要である。

class Money... public int hashCode() ( return (int) (amount (amount >>> 32)); }

加算と減算のある演算を行ってみよう。

class Money...

public Money add (Money other) ( assertSameCurrencyAs (other); return newMoney (amount + other. amount); ) private void assertSameCurrencyAs (Money arg) { } Assert.equals("money math mismatch", currency, private Money newMoney (long amount) ( Money money new Money(); money.currency this.currency; money. amount = amount; return money; }

arg.currency);

第16章 ベースパターン

上記の private なファクトリーメソッドの使い方に注意してほしい。 セントベースの量へ の通常の変換を行わない。 これをマネーコードの内部で何度か使っている。 定義を追加することで、減算は簡単に行える。

class Money...

public Money subtract (Money other) { assertSameCurrencyAs (other); return newMoney (amount other.amount);

比較のためのベースメソッドは、 compareTo である。

class Money...

public int compareTo (Object other) { } return compareTo( (Money) other); public int compareToo (Money other) { assert SameCurrencyAs (other); if (amount other.amount) return -1; else if (amount == other.amount) return else return 1; }

0;

現在、Java クラスで取得できるのはこれですべてであるが、 次のような他の比較メソッ ドを使うと、コードがさらに読み取りやすくなることが分かる。

class Money... public boolean greaterThan (Money other) return (compareTo (other) > 0); )

{

次に、乗算に着目することにする。 ここではデフォルトの丸めモードを提供しているが、 読者も自分自身で同様に設定することができる。

class Money...

public Money multiply (double amount) { } return multiply (new BigDecimal (amount));

5 16

public Money multiply (BigDecimal amount) { } return multiply (amount, BigDecimal. ROUND_HALF_EVEN); public Money multiply (BigDecimal amount, int roundingMode) ( return new Money (amount () .multiply (amount), currency, roundingMode); }

金額を多くのターゲットに分配し、しかもセントを損失したくない場合、 allocation メ ソッドが必要である。 最もシンプルなのは、多くのターゲットに対して(ほとんど) 同じ額 を分配することである。

class Money...

public Money [] allocate (int n) { Money lowResult = newMoney (amount n); Money highResult = newMoney (lowResult. amount + 1); Money results = new Money [n]; int remainder = (int) amount n; } for (int i = 0; i < remainder; i++) results[i] = highResult; for (int i = remainder; i < n; i++) results[i] = lowResult; return results;

より高度な分配アルゴリズムは、任意の比率で処理することができる。

class Money...

public Money [] allocate (long [] ratios) ( long total = 0; for (int i = 0; i < ratios.length; i++) total + ratios [i]; long remainder = amount; Money results = new Money [ratios.length]; for (int i = 0; i < results.length; i++) { } results[i] = newMoney (amount ratios [i] total); remainder = results[i].amount; for (int i = 0; i < remainder; i++) { } results[i].amount++; return results;

これを使うと、 Foemmel の謎を解決できる。

51

18

class Money...

| ベースパターン

public void testAllocate2() { long[] allocation = {3,7}; Money [] result = Money dollars (0.05).allocate (allocation); assertEquals (Money dollars (0.02), result[0]); assertEquals (Money dollars (0.03), result[1]);

}

18.8 | スペシャルケース

特定のケースで特別な振る舞いを提供するサブクラス。

Missing Customer Customer KH Unknown Customer

オブジェクト指向プログラムでは、 null を扱うのは難しい。 ポリモフィズムを無効にする からだ。 通常は、 項目が正確な型かサブクラスのいずれかについて心配することなく、 所定 の型の変数参照で自由に foo を呼び出すことができる。 強力な型付き言語を使うと、コンパ イラに呼び出しが正しいことの確認もできる。 しかし、変数には null が含まれるので、null のメッセージを呼び出すと実行時エラーになる場合があり、正確でフレンドリーなスタック トレース情報を取得しなければならない。

変数が nullである場合、 null テストコードで周りを取り囲む必要がある。 null テスト コードで周りを取り囲んでおくと、 null があるときに適切に対処できる。 しかし、 多くのコ ンテキストで同じ場合が多いので、 多くの場所に同様のコードを記述するということになり、 コードの重複になる。

null は、上記のような問題の一般的な例であり、他の問題も頻繁に発生する。 数値体系で は、無限大を処理する必要がある。 数値体系には、 実数の通常の不変量を破壊する加算に対 して特殊な規則がある。 ビジネスソフトウェアでの最初の経験の1つは、あまり知られてい ない 「オキュパント (occupant)」 と呼ばれるユーティリティ Customer に関するもので あった。タイプの普通の振る舞いを修正しなければならない。

518

null やその他の値を返すのではなく、 呼び出し元が同じインタフェースを持つスペシャル ケースを返さなければならない。

18.8.1 動作方法

基本的な考え方は、スペシャルケースを処理するサブクラスを作成することである。 つま り、 Customer オブジェクトがあり、 null チェックを回避したい場合、 nullCustomer オブ ジェクトを作成する。 顧客のすべてのメソッドを、 無害な振る舞いを提供するスペシャル ケースのメソッドでオーバーライドする。 そして、 null があるときは必ず、 nullCustomer のインスタンスを使う。

nullCustomer のインスタンス間の違いを区別する理由はないので、 フライウェイト [Gang of Four] でスペシャルケースを実装することができる。 ただし、いつでもフライウェ イトで実装できるとは限らない。 ユーティリティの場合、 あまり課金できないときもオキュ パント Customer に対する料金を累積することができるので、 オキュバントを別々に保持す ることは重要である。

null は違った意味を持つ場合もある。 nullCustomer は Customer がいないこと、または Customer (顧客) があるがだれかは知らないことを意味することもある。この場合、単に nullCustomer を使うのではなく、 Missing Customer (行方不明の顧客) や Unknown Customer (身元不明の顧客)として別々にスペシャルケースを持つことも考えなければな らない。

スペシャルケースがメソッドをオーバーライドする一般的な方法は、別のスペシャルケー スを返すことである。 Unknown Customer に最新の請求書を要求すると、 不明な請求書と なる場合がある。

IEEE 754 浮動小数点演算は、正の無限大、負の無限大、 および NaN (not-a-number) を 備えるスペシャルケースの優れた例である。 0で除算をする場合、 処理が必要な例外を取得 する代わりに、システムはNaN を返す。 そして、 NaN は他のいずれかの浮動小数点数と同 じように扱われる。

18.8.2 使用するタイミング

特定のクラスのインスタンスに対する条件チェックの後か、 null チェックの後に同じ振る舞 いを持つ複数の箇所がシステム内にある場合は、いつでもスペシャルケースを使うべきである。

18.8.3 参考文献

パターンとして解説されたスペシャルケースを見たことはまだないが、 null オブジェクト

18 スペシャルケース

第16章 ベースパターン

は [Woolf] で解説されている。 駄洒落を許してもらえるなら、 null オブジェクトはスペシャ スペシャルケース ルケースの特別な場合と言える。

18.8.4 例 シンプルなNull オブジェクト (C#)

ここでは、 null オブジェクトとして使われるスペシャルケースのシンプルな例を紹介し よう。

まず、正規の従業員がいるとする。

class Employee...

public virtual String Name { } get {return_name; } set {_name = value; } private String_name; public virtual Decimal GrossToDate ( } get {return calculate GrossFromPeriod (0);} public virtual Contract Contract ( } get {return_contract; } private Contract_contract;

クラスの機能は、 nullEmployee でオーバーライドできる。

class NullEmployee Employee, INull...

public override String Name { } get {return "Null Employee";} set {} public override Decimal GrossToDate { } get (return Om; } public override Contract Contract ( get { return Contract. NULL; } }

nullEmployee に契約を要求すると、 null 契約が返されることに注意してほしい。 デフォルト値が同じ null 値になる場合、多くの null テストを回避することになる。 繰り 返される null 値は、 デフォルトで null オブジェクトによって処理される。 null でないこと

5 20

を明示的にテストするには、 Customer に isNull メソッドを提供するか、またはマーカー インタフェースのタイプテストを使うことで行える。

18.9 | プラグイン

(by David Rice. Matt Foemmel)

コンパイル時ではなくシステム構成の際にクラスをリンクする。

DomainObject "interface- IDGenerator ?

セパレートインタフェースは、アプリケーションコードが複数の実行時環境で実行される 場合に使われ、それぞれの環境では特定の振る舞いを異なる方法で実装することが必要であ る。 ほとんどの開発者は、ファクトリーメソッドを記述することで、 適切な実装を提供して いる。 ユニットテストにはシンプルなメモリ内カウンターを使うが、 本番時の稼動には、 データベース管理のシーケンスを使うように、 セパレートインタフェースを備える主キー生 成プログラムを定義する。 ファクトリーメソッドにはある条件文が含まれている。 ローカル 環境変数を調べてシステムがテストモードかどうかを判定し、 適切なキー生成プログラムを 返す条件文である。 いったん数個のファクトリーを持つと管理に混乱が発生する。 新しい配 備システム構成、 つまり、 「トランザクション制御機能なしのメモリ内データベースに対し てユニットテストを実行する」 または 「トランザクション全制御機能のある DB2 データ ベースに対して本番稼動モードで実行する」 では、 システム構成を設定するのにいくつかの ファクトリーでの条件文の編集、 再構築、 および再配備が必要とされる。 システム構成のア プリケーション全体に対する分散、 再構築や再配備は必要ではない。 プラグインは、一元管 理された実行時構成を提供して両方の問題を解決する。

18.9.1 動作方法

最初に行うことは、実行時環境に基づいた異なる実装の振る舞いを持つセパレートインタ フェースを定義することである。 さらに、 特別な要件を数個だけ加えた基本的なファクト リーパターンを使用する。 プラグインファクトリーでは、システム構成を容易に管理できる ようにするために、1つの外部ポイントで示されるリンク命令が必要である。さらに、実装 へのリンクは、コンパイル時ではなく実行時に動的に行われなければならないので、再構築 時にリビルドする必要がなくなる。

第16章 ベースパターン

caller plugin plugin factory configuration getPlugin lookupPluginByType new plugin.

図 18.2 呼び出し元は、分離されたインタフェースのプラグイン実装を取得する。

テキストファイルは、リンク規則の表明手段としてとても良好に機能する。 プラグイン ファクトリーは、単にテキストファイルを読み取り、 要求されたインタフェースの実装を指 定して返す。

ファクトリーはコンパイル時に実装へ依存しないで構築できるので、プラグインはリフレ クションをサポートする言語において見事に機能する。 リフレクションを使う際、システム 構成ファイルには実装クラス名へのインタフェース名のマッピングが含まれている。 ファク トリーは、フレームワークパッケージから独立して配置され、 新しい実装をシステム構成の 選択肢に追加する際にも変更する必要がない。

リフレクションをサポートしない言語を使う場合でも、システム構成で中央ポイントを設 定するだけの価値がある。 リンク規則を設定する場合にもテキストファイルを使うが、その 違いは、ファクトリーがインタフェースを希望する実装にマッピングするために条件分岐ロ ジックを使うことだけである。 それぞれの実装の型は、ファクトリーで説明される必要があ るが、実際にはそれほどの量ではない。 新しい実装をコードベースに追加する場合はいつで も、同時にファクトリーメソッド内に別のオプションを追加する。 ビルド時チェックでレイ ヤとパッケージの依存性を持たせるために、ファクトリーを自らのパッケージに配置し、ビ ルドプロセスの中断を避けなければならない。

18.9.2 使用するタイミング

実行時環境に基づいた実装が必要な振る舞いを持つ場合は、常にプラグインを使う。

5 22

18.9.3 ID (Java)

上述のとおり、 キーまたはIDの生成では、その実装が配備環境によって変化する (図

18.3).

最初に、IDGenerator セパレートインタフェースや必要な実装を記述する。

interface IDGenerator....

public Long nextId();

class OracleIDGenerator implements IDGenerator...

public OracleIDGenerator() { this.sequence = Environment.getProperty("id.sequence"); this.datasource = Environment.getProperty("id.source");

DomainObject Plugins loadInstance 오 -interface- IDGenerator nextid OracleID Generator nextid nextid Counter

if (in Testing) return new Counter if (inProduction) return new OracleIDGenerator

複数のID生成プログラム

18.3

189 プラグイン

52

OracleIDGenerator の場合 nextId() は、 次に利用可能な番号を定義済みデータソースの 定義済みのシーケンスから選択する。

第16章 ベースパターン

class Counter implements IDGenerator...

private long count = 0; public synchronized Long nextId() { } return new Long(count++);

構築すべきものがある場合、 現在のインタフェースから実装へのマッピングを実現するプ ラグインファクトリーを記述してみよう。

class PluginFactory....

private static Properties props = new Properties();

static ( try { String propsFile = System.getProperty("plugins"); props.load(new FileInputStream (propsFile)); } catch (Exception ex) { throw new ExceptionInInitializerError (ex); }

public static Object get Plugin (Class iface) {

String implName = props.getProperty (iface.getName()); if (implName == null) { ) throw new RuntimeException("implementation not specified for * + iface.getName() + " in PluginFactory propeties.")try{ return Class.forName (implName).newInstance(); } catch (Exception ex) { throw new RuntimeException("factory unable to construct instance of + iface.getName());

;

リンク命令を含むファイルが配置され､ プラグインという名前を持つシステムプロパティ を検索することによって、 システム構成をロードできることに注意してほしい。 リンク命令 の定義や格納には多くの選択肢があるが、シンプルなプロパティファイルが最も簡単である。

524

クラスパスを見るのではなく、ファイルを見つけるシステムプロパティを使うことによって、 マシン上のどこに配置しても新しいシステム構成の指定が簡単になる。 開発、テスト、 本番 時の稼動の各環境間でビルドを変更する場合、 上記のことはとても便利である。 次のように、 1つがテスト用で、もう1つが本番稼動用の2つの異なるシステム構成ファイルがどのよう なものかを紹介する。

config file test.properties...

# test configuration

IDGenerator TestIDGenerator

config file prod.properties...

# production configuration

IDGenerator=OracleIDGenerator

IDGenerator インタフェースに戻り、 プラグインファクトリーへの呼び出しで設定され る静的な INSTANCE メンバを追加する。 INSTANCE メンバは、プラグインとシングルトンパ ターンを組み合わせて、 ID を取得するための簡単で読み取りできる呼び出しを提供する。

interface IDGenerator...

public static final IDGenerator INSTANCE = (IDGenerator) PluginFactory.getPlugin (IDGenerator.class);

これで、適切な環境に対して適切な ID を取得するということを認識している呼び出しを 作成できる。

class Customer extends DomainObject...

private Customer (String name, Long id) { } super (id); this.name=name; public Customer create (String name) ( Long newobjId = IDGenerator. INSTANCE.nextId(); Customer obj = new Customer (name, newObjId); obj.markNew(); return obj; }

19 プラグイン

18.

18 サービススタブ

(by David Rice)

テスト中に問題となるサービスへの依存性を除去する。

第16章 ベースパターン

Charge Generator Interface TaxService getTaxInfo WSDL Acme TaxService getTaxInfo Class TaxServiceStub

getTaxInfo

エンタープライズシステムは、貸方の記入、 税率の調査、および価格決定などサードパー ティのサービスコンポーネントへのアクセスに依存している。 上記のようなシステムを構築 している開発者はすべて、 自分が完全に制御できないリソースに依存していることから来る フラストレーションを口にする。 機能の配信は予測できず、機能がリモート信頼性の場合も あり、パフォーマンスも悪化する可能性がある。

少なくとも、このような問題があると開発プロセスは遅れてしまう。 開発者は、サービス がオンラインで戻ってくるのをぼんやりと座って待っているか、 または、 おそらく間に合わせ のプログラムをコードに挿入し、まだ配信されない機能の代わりとするかもしれない。さらに 発生する可能性が大きい深刻な問題は、そうした依存性により何回もテストが実行不可能にな ることである。 テストが実行不可能になると開発プロセスは中断してしまうからである。

テストの際、サービスをローカルで高速に実行してメモリで実行するサービススタブに置 き換えると、 開発作業を改善することができる。

18.10.1 | 動作方法

最初のステップは、ゲートウェイを使ってサービスへのアクセスを定義することである。 ゲートウェイは、クラスではなくセパレートインタフェースなので、サービスを呼び出す1 つの実装と少なくとも1つの単なるサービススタブを持つ。 ゲートウェイの望ましい実装は、 プラグインを使ってロードされる必要がある。 サービススタブを記述する際に重要な点は、 できるだけシンプルにすることである。 複雑にすると目的を果たすことができない。

ここでは、売上税サービスをスタブする流れを行ってみることにする。 このサービスは、

5 26

住所、 製品タイプ、 および売上金額が与えられている州の売上税額と税率を提供する。 サー ビススタブを提供する最もシンプルな方法は、リクエストに適合する一定の税率を使った数 行のコードを記述することである。

もちろん、税金の法律はシンプルではない。 製品によっては、特定の州で非課税な場合が ある。 そのため、 製品と州をどのように組み合わせると非課税になるかについては実際の税 金サービスに委ねている。 しかし、アプリケーションの多くの機能は税金が課されるかどう かに依存しているので、 サービススタブで非課税機能に対応する必要がある。この振る舞い をスタブに追加する最もシンプルな方法は、 住所と製品の特定の組み合わせを除外する条件 文を通して、該当するいずれかのテストケースで同じデータを使うことである。 スタブの コードの行数は片手でカウントできる。

より動的なサービススタブでは、非課税製品と州の組み合わせリストを管理し、テスト ケースリストを追加することができる。 この場合でさえ、 10行程度のコードである。 開発 プロセスの時間の短縮が目的なので、コードはシンプルである。

動的なサービススタブによって、 サービススタブとテストケース間の依存性に関して興味 深い疑問が提起される。 サービススタブは、 本来の税金サービスゲートウェイインタフェー スにはない非課税の対象を追加する setup メソッドに依存している。 サービススタブのロー ドにプラグインを利用するために、この setup メソッドがゲートウェイに追加される。 setup メソッドは、 あまり余計なものをコードに追加することなく、 テストの名前で行われ るので差し支えない。 サービスを呼び出すゲートウェイの実装が、 いずれかのテストメソッ ドの中でアサーションの失敗を確実に起こすようにしなければならない。

18.10.2 使用するタイミング

特定のサービスへの依存性が開発とテストを妨げていることがわかった場合は、サービス スタブを使うべきである。

エクストリームプログラミング (Extreme Programming) に従事する多くのユーザは、 サービススタブの代わりにモックオブジェクトという用語を使っているが、サービススタブ の方が長い間使われているので、ここではサービススタブを使うことにする。

18.10.3 例: 売上税サービス (Java)

アプリケーションは、Web サービスとして配備された税金サービスを使う。 考慮したい 最初の項目は、ドメインコードが Web サービスの未知な点を処理することがないように ゲートウェイを定義することである。 ゲートウェイは、記述した任意のサービススタブの ロードに役立つインタフェースとして定義される。 税金サービスの実装のロードにはブラグ

インを使う。

第16章 ベースパターン

interface TaxService...

public static final TaxService INSTANCE = (TaxService) PluginFactory.getPlugin (TaxService.class); public Tax Info getSales Tax Info (String productCode, Address addr, Money sale Amount);

シンプルな一定税率のサービススタブは、次のようになる。

class FlatRateTaxService implements TaxService...

private static final BigDecimal FLAT_RATE= new BigDecimal("0.0500"); public TaxInfo getSales Tax Info (String productCode, Address addr, ) Money sale Amount) { return new TaxInfo (FLAT RATE, saleAmount.multiply (FLAT RATE));

特定の住所と製品の組み合わせを非課税扱いにするサービススタブは、次のとおりである。

class Exempt ProductTaxService implements TaxService...

private static final BigDecimal EXEMPT_RATE= new BigDecimal ("0.0000"); private static final BigDecimal FLAT RATE = new BigDecimal("0.0500"); private static final String EXEMPT_STATE = "IL"; private static final String EXEMPT_PRODUCT = 12300"; public TaxInfo getSales Tax Info (String productCode, Address addr, Money sale Amount) { if (productCode.equals (EXEMPT_PRODUCT) && addr.getStateCode().equals (EXEMPT_STATE)) { return new TaxInfo (EXEMPT RATE, saleAmount.multiply (EXEMPT RATE)); } else { } return new TaxInfo (FLAT RATE, saleAmount.multiply (FLAT RATE));

次に、ここでは、テストケースを追加して非課税の組み合わせをリセットできるメソッド を備えた動的なサービススタブを紹介する。 追加のテストメソッドが必要な場合は、 逆戻り して、よりシンプルなサービススタブや実際の税金 Web サービスを呼び出す実装にもメ

5 28

ソッドを追加する必要がある。 不要なテストメソッドは、 アサーションの失敗を起こさなけ ればならない。

class TestTaxService implements TaxService...

private static Set exemptions = new HashSet();

public Tax Info getSales Tax Info (String productCode, Address addr,

Money saleAmount) (

BigDecimal rate = getRate (productCode, addr);

return new TaxInfo (rate, saleAmount.multiply (rate));

public static void addExemption (String productCode, String stateCode) { exemptions.add (getExemptionKey (productCode, stateCode));

public static void reset(){

}

exemptions.clear();

}

private static BigDecimal getRate (String productCode, Address addr) (

if (exemptions.contains (getExemptionKey (productCode,

addr.getStateCode()))) {

return EXEMPT_RATE;

} else {

return FLAT_RATE:

)

税金のデータを提供する Web サービスを呼び出す実装は示されず、 本番稼動のプラグイ ンシステム構成により税金サービスインタフェースにリンクする。 テストプラグインシステ ム構成は、上記のサービススタブにリンクする。

最後に、税金サービスのあらゆる呼び出し元は、 ゲートウェイを介してサービスにアクセ スする。 以下の料金生成プログラムは、 標準料金を生成し、対応する税金をすべて生成する 税金サービスを呼び出す。

class ChargeGenerator...

public Charge[] calculateCharges (Billing Schedule schedule) { List charges = new ArrayList(); Charge baseCharge = new Charge (schedule.getBillingAmount(), falsecharges.add(baseCharge); TaxInfo info = TaxService.INSTANCE.getSales TaxInfo( schedule.getProduct(), schedule.getAddress(),

);

}

1810 サービススタブ

schedule.getBilling Amount()); if (info.getStateRate ().compareTo(new BigDecimal (0)) > 0) { Charge taxCharge = new Charge (info.getStateAmount(), true); charges.add(taxCharge);

return Charge []) charges.toArray (new Charge [charges.size()]);

1811 レコードセット

テーブルデータのメモリ上の表現。

RecordSet Table Row Column

ここ20年間、 データベースのデータを表現する方法は、テーブルのリレーショナル形式 が主流である。 大小のデータベース企業と標準的なクエリー言語の後押しを受けて、私が 知っている多くの新しい開発にはリレーショナルデータが使われている。

これに加えて、 UI を短時間で構築するための豊富なツールがある。 ツールのデータ認識 U フレームワークは、基盤となるデータがリレーショナルであることに依存し、データを プログラミングすることなく、 データの表示や処理をしやすくするさまざまな種類のUI ウィジェットを提供している。

上記の環境の欠点は、表示やシンプルな更新は極めて容易だが、ビジネスロジックを配置 する実際の機能がないことである。 「有効な日付」 を過ぎた妥当性確認も、 どんなビジネス ルールや計算も行き場所がない。 ビジネスロジックを配置する機能は、ストアドプロシー ジャとしてデータベースに押し込まれるか、UIコードに混入されるかのいずれかである。

レコードセットの考え方は、SQL クエリーの結果と厳密に類似しているが、システムの他 の部分から生成および処理を行うことができるメモリ内構造を提供するというものである。

}

5 3 0

18.11.1 | 動作方法

レコードセットは、作業中のソフトウェアプラットフォームのベンダーから提供され、自 ら構築することのない種類のものである。 一例として、 ADO.NET のデータセットと JDBC 2.0 の行セットが挙げられる。

レコードセットの最初の基本的要素は、厳密にデータベースクエリーの結果と同じに見え ることである。 つまり、クエリーを発行しデータを直接データ認識 UIに投げる2ティア手 法を、 2ティアツールを使うことで簡単に利用できる。 2番目の基本的な要素は、容易に自 らレコードセットを構築すること、およびデータベースクエリーの結果のレコードセットを 取得し、 ドメインロジックコードで容易に処理できることである。

プラットフォームにレコードセットが用意されているが、 自分で作成することもできる。 問題は、データ認識 UI ツールがない場合、 自分で作成しなければならなくなるという点に ある。いずれにしてもレコードセット構造をマッピングのリストとして構築することは、動 的型付きスクリプト言語では一般的であり、このパターンの優れた例であると言える。

データソースへのリンクからレコードセットを切り離す機能は価値がある。 これによって データベースへの接続を意識することなく、 ネットワーク一帯にレコードセットを渡すこと ができる。 さらに、 簡単にレコードセットを直列化することができる場合、 アプリケーショ ンに対してデータ変換オブジェクトとしての機能を果たすこともできる。

接続を解除すると、レコードセットを更新した場合に何が発生するかという問題が起きる。 ますます多くのプラットフォームでレコードセットをユニットオブワークの形式にすること ができるので、レコードセットを修正して、 データソースに返し、コミットすることができ る。通常、データソースでは軽オフラインロックを使って競合の有無を確認し、競合がない 場合、 変更をデータベースに書き込む

18.11.1.1 明示的なインタフェース

レコードセットの実装では、 暗黙的なインタフェースが使われる。 つまり、レコードセッ トから情報を取得するためには、必要なフィールドを示す引数を持つ汎用メソッドを呼び出 す。 たとえば、航空会社の予約の乗客を取得するには aReservation ("passenger * ] などの 式を使う。 明示的なインタフェースでは、メソッドとプロパティが定義済みの Reservation クラスが必要となる。 明示的な予約では、乗客を求める式は aReservation.passenger と なる。

暗黙的なインタフェースは、任意の種類のデータに対して汎用のレコードセットを使うの で柔軟性がある。 新しい種類のレコードセットを定義するたびに新しいクラスを記述する必 要がなくなる。 しかし、概して私は、暗黙的なインタフェースが悪いものであることに気づ いた。 予約についてのプログラミングをする場合、 どのようにして客を取得する方法がわか るのだろうか。 文字列は、 「passenger」、 「guest」、 「flyer」 のいずれであるのか。 唯一の方

第16章 ベースパターン

schedule.getBillingAmount()); if (info.getStateRate().compareTo (new BigDecimal (0)) > 0) { Charge taxCharge = new Charge (info.getStateAmount(), true); charges.add(taxCharge);

}

return (Charge []) charges.toArray (new Charge [charges.size()]);

}

18.11 レコードセット

テーブルデータのメモリ上の表現。

RecordSet Table Row Column

ここ20年間、 データベースのデータを表現する方法は、テーブルのリレーショナル形式 が主流である。 大小のデータベース企業と標準的なクエリー言語の後押しを受けて、私が 知っている多くの新しい開発にはリレーショナルデータが使われている。

これに加えて、 UI を短時間で構築するための豊富なツールがある。 ツールのデータ認識 UI フレームワークは、基盤となるデータがリレーショナルであることに依存し、 データを プログラミングすることなく、データの表示や処理をしやすくするさまざまな種類のUI ウィジェットを提供している。

上記の環境の欠点は、表示やシンプルな更新は極めて容易だが、ビジネスロジックを配置 する実際の機能がないことである。 「有効な日付」 を過ぎた妥当性確認も、どんなビジネス ルールや計算も行き場所がない。 ビジネスロジックを配置する機能は、ストアドプロシー ジャとしてデータベースに押し込まれるか、 UI コードに混入されるかのいずれかである。

レコードセットの考え方は、SQLクエリーの結果と厳密に類似しているが、システムの他 の部分から生成および処理を行うことができるメモリ内構造を提供するというものである。

5 3 0

18.11.1 | 動作方法

レコードセットは、作業中のソフトウェアプラットフォームのベンダーから提供され、自 ら構築することのない種類のものである。 一例として、 ADO.NET のデータセットと JDBC 2.0 の行セットが挙げられる。

レコードセットの最初の基本的要素は、厳密にデータベースクエリーの結果と同じに見え ることである。 つまり、 クエリーを発行しデータを直接データ認識 UIに投げる2ティア手 法を、 2ティアツールを使うことで簡単に利用できる。 2番目の基本的な要素は、容易に自 らレコードセットを構築すること、およびデータベースクエリーの結果のレコードセットを 取得し、ドメインロジックコードで容易に処理できることである。

プラットフォームにレコードセットが用意されているが、自分で作成することもできる。 問題は、データ認識 UIツールがない場合、 自分で作成しなければならなくなるという点に ある。いずれにしてもレコードセット構造をマッピングのリストとして構築することは、動 的型付きスクリプト言語では一般的であり、このパターンの優れた例であると言える。

データソースへのリンクからレコードセットを切り離す機能は価値がある。 これによって データベースへの接続を意識することなく、ネットワーク一帯にレコードセットを渡すこと ができる。 さらに、簡単にレコードセットを直列化することができる場合、 アプリケーショ ンに対してデータ変換オブジェクトとしての機能を果たすこともできる。

接続を解除すると、レコードセットを更新した場合に何が発生するかという問題が起きる。 ますます多くのプラットフォームでレコードセットをユニットオブワークの形式にすること ができるので、レコードセットを修正して、データソースに返し、 コミットすることができ る。 通常、データソースでは軽オフラインロックを使って競合の有無を確認し、競合がない 場合、変更をデータベースに書き込む

18.11.1.1 明示的なインタフェース

レコードセットの実装では、暗黙的なインタフェースが使われる。 つまり、レコードセッ トから情報を取得するためには、必要なフィールドを示す引数を持つ汎用メソッドを呼び出 す。 たとえば、航空会社の予約の乗客を取得するにはaReservation ["passenger ] などの 式を使う。 明示的なインタフェースでは、メソッドとプロパティが定義済みの Reservation クラスが必要となる。 明示的な予約では、乗客を求める式はaReservation.passenger と なる。

暗黙的なインタフェースは、任意の種類のデータに対して汎用のレコードセットを使うの で柔軟性がある。 新しい種類のレコードセットを定義するたびに新しいクラスを記述する必 要がなくなる。 しかし、概して私は、暗黙的なインタフェースが悪いものであることに気づ いた。予約についてのプログラミングをする場合、 どのようにして客を取得する方法がわか るのだろうか。 文字列は、 「passenger」、 「guest」、 「lyer」 のいずれであるのか。 唯一の方

踊り、予約が作成されて使われている場所を見つけるように試み インタフェースがある場合、 予約の定義を見て必要なプロパティを

ではさらに悪化する。 乗客の名字を知りたい場合、 ((Person) Last Name などの複雑な式を使わざるを得ないが、コンパイラ で、手作業で入力し、必要な情報を取得する必要がある。 明示的な 保持の aReservation.passenger.lastName を使うことがで

インタフェースには不満である (ディクショナリで時間を余計に ニーズに対しても同様である)。 さらにレコードセットを伴う暗黙的なイン 評価していない。 しかし、ここでの唯一の救いは、通常、レコードセッ 定についての情報を保持することである。 さらに、 列の名前はレコード SQL で定義されているので、必要な場合にプロパティを見つけることは

べると、明示的なインタフェースを持つ方が優れていると言える。 レコードセットが強力な型付きデータセット、レコードセット用の明示的 インタフェースを提供する生成されたクラスとともに提供されている。 セットには、多くのテーブルとテーブル間の関係を含めるので、強力な セットもその関係情報を使うことができるプロパティを提供している。 クラス ②タセットの定義から生成される。

タフェースの方がよく使われているので、本書の例では型なしデータセット ADO.NET の本番稼動のコードでは、型付きのデータセットを使 ADONET 以外の環境の場合は、自らの明示的なレコードセットの する。

タイミング

ブル レコードセットの価値は、データ処理の共通の方法としてレコードセット 上にあるレコードセットは多くのツールで使われている。 U フルモジュールを使用してドメインロジックを構築すべきである。 ドセットを取得し、引き出した情報を計算するためにテーブルモ 創業を目に渡して表示編集を行う。 そして、テーブルモジュールに戻 7 V 更する 下する。 ES9日までにも存在していたが、何らかの代替構造

いろいろな意味でレコードセットをとても価値あるもの

にするツールが登場した。 現在は、もちろん広く標準化された構造と XPath でのクー 言語を持つ XML がある。 しかし私は、現行のツールが現在レコードセットを使っているの と同じ方法で階層的な構造ツールが登場するようになるのではないかと考えている。 おそら く、これは一般的なパターンの特別なケース、 つまり、 汎用データ構造のようなものである。 しかし、そのパターンについてはその時期が来てから考えることにする。

法は、コードベースを探し回り、 予約が作成されて使われている場所を見つけるように試み ることである。 明示的なインタフェースがある場合、 予約の定義を見て必要なプロパティを 確認することができる。

この問題は、 静的型付き言語ではさらに悪化する。 乗客の名字を知りたい場合、 ((Person) aReservation ["passenger * }) . lastName などの複雑な式を使わざるを得ないが、コンパイラ はすべての型情報を失うので、 手作業で入力し、必要な情報を取得する必要がある。 明示的な インタフェースでは、 型情報の保持の aReservation.passenger lastName を使うことがで きる。

このため、私は暗黙的なインタフェースには不満である (ディクショナリで時間を余計に 費やすインタフェースに対しても同様である)。 さらにレコードセットを伴う暗黙的なイン タフェースもあまり評価していない。 しかし、ここでの唯一の救いは、通常、 レコードセッ トが中にある規定の列についての情報を保持することである。 さらに、 列の名前はレコード セットを作成する SQL で定義されているので、必要な場合にプロパティを見つけることは それほど難しくない。

しかし、もう一言述べると、 明示的なインタフェースを持つ方が優れていると言える。 ADO.NET では、レコードセットが強力な型付きデータセット、レコードセット用の明示的 で完全な型付きインタフェースを提供する生成されたクラスとともに提供されている。 ADO.NET データセットには、 多くのテーブルとテーブル間の関係を含めるので、 強力な 型付きデータセットもその関係情報を使うことができるプロパティを提供している。 クラス は、XSD のデータセットの定義から生成される。

暗黙的なインタフェースの方がよく使われているので、 本書の例では型なしデータセット を使っている。 しかし、 ADO.NET の本番稼動のコードでは、型付きのデータセットを使 うことを提案する。 ADO.NET 以外の環境の場合は、自らの明示的なレコードセット コード生成を提案する。

18.11.2 使用するタイミング

私の考えでは、レコードセットの価値は、データ処理の共通の方法と に依存する環境を得ることにある。 レコードセットは多くのUIツー ツールを使う場合、 テーブルモジュールを使用してドメインロジ データベースからレコードセットを取得し、引き出した情報を ジュールに渡し、結果をUIに渡して表示と編集を行う。 そ. して妥当性確認を行い、 データベースに更新をコミットす

リレーショナルデータベースと SQLはこれまでに

とクエリー言語がなかったために、いろいろな意

5 32

ベースパターン

にするツールが登場した。 現在は、もちろん広く標準化された構造と XPath でのクエリー 言語を持つ XML がある。 しかし私は、現行のツールが現在レコードセットを使っているの と同じ方法で階層的な構造ツールが登場するようになるのではないかと考えている。おそら く、これは一般的なパターンの特別なケース、つまり、汎用データ構造のようなものである。 しかし、そのパターンについてはその時期が来てから考えることにする。



参考文献

[Alexander et al.)

Alexander, et al. A Pattern Language. Oxford, 1977. 「パタン・ランゲージ環境設計の手引 平田 翰那訳 鹿島出版会、1984)

パターンに携わる人々のためのアイディア集。 私はそれほど熱中しなかったが、いろいろな手法を理 解する上で一見の価値がある。

[Alpert et al.]

Alpert, Brown and Woolf. Design Patterns Smalltalk Companion.Addison-Wesley, 1998. Smalltalkコミュニティ以外にはあまり知られていないが、従来のパターンの多くを詳細に説明して いる。

[Alur et al.]

Alur, Crupi, and Malks. Core J2EE Patterns: Best Practices and Design Strategies. Prentice Hall, 2001. 「J2EEパターン一明暗を分ける設計の戦略」、 中野明彦ほか訳、ウルシステムズ株式会社監訳、 ピアソンエデュケーション、2002)

形式に新しい生命を吹き込むパターン書籍のニューウェイブの一つ。 パターンはJ2EEプラットフォー ム向けに表現されているが、 他のプラットフォームにも活用できる。

[Ambler]

http://www.ambysoft.com/mappingObjects.html

オブジェクトリレーショナルマッピングに関する考えに役立つソース。

[Beck XP 2000]

Beck, Extreme Programming Explained. Addison-Wesley, 2000 (XPエクストリーム・プログラミ ング入門一ソフトウェア開発の究極の手法」、 永田 飯塚麻理香訳、長瀬嘉秀監沢、ピアソン・エデ ュケーション、2000)

XP (エクストリームプログラミング)のマニフェスト。 ソフトウェアプロセスに関心がある人には必 読の書。

[Beck Patterns)

Beck. Smalltalk Best Practice Patterns. Prentice Hall, 1997. (「ケント・ベックのSmalltalk ベストプラ クティスパターン シンプル デザインへの宝石集」、 梅澤真史ほか、ピアソンエデュケーショ , 2003)

Smalltalkベースのため残念ながらあまり読まれていないが、 ○○言語向けに書かれたたいていの書籍 より優れたアドバイスが収められている。

5 3 E

[Beck TDD]

Beck. Test-Driven Development: By Example. Addison-Wesley, 2003. (「テスト駆動開発入門」、テク ノロジックアート訳、 長瀬嘉秀監訳、ピアソン・エデュケーション、2003)

本書と同時期に出版された。 設計を発展させることができるテストとリファクタリングの緊密なサイ クルへのBeck氏の指針である。

[Bernstein and Newcomer]

Bernstein and Newcomer. Principles of Transaction Processing. Morgan Kaufmann, 1997.(「トラン ザクション処理システム入門」、 大磯和広ほか、 日経BP社、1998) 頭を痛めるトランザクションの世界のすばらしい入門書。

[Brown et al.]

Brown et al. Enterprise Java Programming with IBM Websphere Addison-Wesley, 2001. (「IBM WebSphereエンタープライズ Javaプログラミング]、 落合修監訳、出版:エスアイビーアクセス、 発売: 星雲社, 2002)

本書の2/3はソフトウェアのマニュアルであるが、 その他の1/3には、このテーマに特化したほとんど すべての本より、優れた設計上のアドバイスが凝縮されている。

[Brown and Whitenack]

http://members.aol.com/kgb1001001/Chasms.htm

オブジェクトリレーショナルマッピングに関する最初期の、かつ最も優れたレポートの1つ。

[Cockburn UC]

Cockburn. Writing Effective Use Cases. Addison-Wesley, 2001. (「ユースケース実践ガイド 効果的 なユースケースの書き方」、 山岸耕二ほか訳、ウルシステムズ株式会社監訳、 翔泳社、2001) ユースケースに関する間違いなく最高の参考文献。

[Cockburn PloP]

Cockburn, "Prioritizing Forces in Software Design," in [PLoPD 2].

アプリケーションの境界についての解説。

[Coleman et al.J

Coleman, Arnold, and Bodoff. Object-Oriented Development: The Fusion Method, Second Edition. Prentice Hall, 2001.

UML以前の部分に対しては歴史的な関心しかそそられないが、インタフェースモデルについての解

説は、サービスレイヤの設計者にとって非常に役立つものである。

[Evans and Fowler] http://martinfowler.com/apsupp/spec.pdf

Specificationパターンの解説。

[Evans)

Evans.Domain Driven Design. Addison Wesley, 2003. ドメインモデルの開発に関する書籍。 エンタープライズアプリケーション開発の重要で困難な側面に ついての興味深い解説。

[Fowler Temporal Patterns]

http://martinfowler.com/ap2/timeNarrative.html

時間とともに変わるオブジェクトの履歴を処理するパターン。

参考文献

5 36

[Fowler AP]

Fowler.Analysis Patterns. Addison-Wesley, 1997. (「アナリシスパターン 再利用可能なオブジェクト モデル」、 児玉公信 友野晶夫・大脇文雄訳、 堀内一監訳、アジソン・ウェズレイ・パブリッシャー ズ・ジャパン, 1998)

ドメインモデルのパターン。

[Fowler Refactoring|

Fowler, Refactoring. Addison-Wesley, 1999. (「リファクタリング―プログラミングの体質改善テクニッ ク」、児玉公信ほか訳、ピアソン・エデュケーション、2000)

既存のコードベースの設計を改善するための技術。

[Fowler CI]

http://martinfowler.com/articles/continuousIntegration.html

1日に数回ソフトウェアを自動的にビルドする方法を説明するエッセイ。

[Gang of Four]

Gamma, Helm, Johnson, and Vlissides.Design Patterns.Addison-Wesley, 1995. (「オブジェクト指向 における再利用のためのデザインパターン」、 本位田真一 吉田和樹監訳 ソフトバンクパブリッシン 7, 1999)

パターンに大きな影響を与えた書籍。

[Hay]

Hay. Data Model Patterns. Dorset House, 1995. リレーショナルの観点からの概念モデルのパターン。

[Jacobson et al.)

Jacobson et al. Object-Oriented Software Engineering. Addison-Wesley, 1992. (「オブジェクト指向ソ フトウェア工学OOSE-Use-caseによるアプローチ」、西岡利博ほか監訳 トッパン、 1995) ○○設計に関する初期の書籍で、 ユースケースと設計に対するインタフェースーコントローラーエン ティティ手法を紹介している。

[Keller and Coldewey]

http://www.objectarchitects.de/ObjectArchitects/orpatterns/index.htm オブジェクトリレーショナルマッピングについてのすばらしいソース。

[Kirtland]

Kirtland. Designing Component-Based Applications. Microsoft Press, 1998. DNAアーキテクチャの説明。

[Knight and Dail

Knight and Dai. "Objects and the Web. "IEEE Software, March / April 2002. Webアプリケーションにおけるモデルビューコントローラとその発展および使用に関するすばらしい レポート。

[Larman]

Larman. Applying UML and Patterns, Second Edition. Prentice Hall, 2001. (「実践UMLパターンに よる統一プロセスガイド」、 依田光江訳、 今野睦 依田智夫監訳、ピアソン・エデュケーション、 2003)

私が選ぶ〇〇設計の入門書の筆頭。

参考文献

5 37

Lea. Concurrent Programming in Java, Second Edition.Addison-Wesley, 2000. (「Javaスレッドプログ ラミング並列オブジェクト指向プログラミ537ングの設計原理」、 松野良蔵監訳、 翔泳社、2000) 複数のスレッドでプログラムしたい場合、 まず本書を最初に理解する必要がある。

参考文献

[Marinescu]

Marinescu.EJB Design Patterns. New York: John Wiley, 2002. (「EJBデザインパターン」、トップスタ ジオ訳 出版: 日経BP社、 発売 日経BP出版センター、 2003) JavaのEJBについての最近のパターンに関する書籍。

[Martin and Odell] Martin and Odell.Object Oriented Methods: A Foundation (UML Edition).Prentice Hall, 1998. 概念的観点からのオブジェクトモデリングのほか、モデリングとは何かに関する基礎研究。

[Nilsson]

Nilsson. .NET Enterprise Design with Visual Basic .NET and SQL Server 2000.Sams, 2002.

Microsoft プラットフォームのアーキテクチャについての内容が充実した書籍。

[Peckish]

200万(79ページを参照)

[PLoPD 2]

Vlissides, Coplien, and Kerth (eds.).Pattern Languages of Program Design 2.Addison-Wesley, 1996. さまざまなパターンレポートの選集。

[PLoPD 3]

Martin, Buschmann, and Rielhe (eds.).Pattern Languages of Program Design 3.Addison-Wesley, 1998.

さまざまなパターンレポートの選集。

[POSA]

Buschmann et al.Pattern-Oriented Software Architecture. Wiley, 2000. (「ソフトウェアアーキテクチ ャーソフトウェア開発のためのパターン体系」 金澤典子ほか訳、 近代科学社, 2000) 広範囲のアーキテクチャパターンに関する最良の書籍。

[Richle et al.]

Richle, Siberski, Baumer, Megert, and Zullighoven. "Serializer," in [PLoPD 3]. オブジェクト構造の直列化について掘り下げて説明しているもので、異なる形式への直列化を要する 場合には必要な書

[Schmidt]

Schmidt, Stal, Rohnert, and Buschmann.Pattern-Oriented Software Architecture, Volume 2. New York: John Wiley, 2000.

並列分散システムのついてのパターン。 アプリケーションサーバーを使用する人より、 アプリケー ションサーバーを設計する人向け。 ただし、設計されたものを使用する場合にも、 その設計思想につ いてある程度の知識を持っていると有益である。

[Snodgrass]

nodgrass. Developing Time-Oriented Database Applications in SQL. Morgan-Kaufmann, 1999. リレーショナルデータベースで履歴情報を追跡する方法。

[Struts]

http://jakarta.apache.org/struts/ ますます人気が高まっているJavaのWebプレゼンテーションフレームワーク。

5 3 8

(Lea)

[Waldo et al.]

Waldo, Wyant, Wollrath, and Kendall.A Note on Distributed Computing. SMLITR-94- 29,http://research.sun.com/technical-reports/1994/smli_tr-94-29.pdf, SunMicrosystems, 1994. なぜ「透過的な分散オブジェクト」に危険な矛盾が含まれているのかに関する古典的なレポート

[wiki]

http://c2.com/cgi/wiki Ward Cunningham によって開発された当初のWiki Web。 まとまりには欠けるが魅力的でオープン なWebサイトで、 あらゆる人々があらゆる種類の考え方を共有している。

[Woolf]

Woolf. "Null Object," in [PLoPD 3)

スルオブジェクトパターンの説明。

[Yoder] http://www.joeyoder.com/Research/objectmappings オブジェクトリレーショナルパターンの優れたソース。

.

参考文献



記号数字

.NET. .108 1つのセッションに1つのプロセス。 081 1つのリクエストに1つのスレッド。 082 1つのリクエストに1つのプロセス。 082 2重のマッピング 051

A ACID..... AbstractFindメソッド。 AbstractMapper..... AbstractPlayerMapper ADO.NETデータセット. 309 184. 271, 275 7. 301 074 158 ADOセットライブラリ 136 Album. 284 AlbumMapper クラス. 285 Albumクラス. 255, 418 Application Boundary/-. .146 ArtistMapper. .190 Artist オブジェクト 261 Artistクラス. 258, 418 ASP. 374 ASP.NET. 363 ASP.NETサーバページ。 381 Atomicity. ..074 Attachメソッド。 229

B

batch update...

BLOB...

C caller registration. 198 CLOB. 292 CMP 125 Composite Entityパターン 107 Consistency. 074 Contract 128 Cor J2EEL. 111 Criteriaオブジェクト 346, 348 CRUDユースケース_ 144 Customerクラス。 294 D delete メソッドー 153, 158 Department. 294 Dependentクラス. 282 Durability. 074 E EJBサーバー 483 EmployeeMapper 92. 268, 272 Employeeクラス 268, 276 F Findオブジェクト。 Findメソッド_ 163, 505 224. 302, 309 find F042. 153, 163, 168, 171, 173, 180, 183, 188, 243, 264, 273, 325

202

索引

BowlerMapper 52.

292

G

Brown レイヤ

325

110

Gatewayクラス.

getメソッド。

166, 318

..169

5 4

Ghost. GUID.

226, 229 234

H

Ownerクラス.

282

HTML.

373, 384, 388

httpセッション

483

ID生成プログラム。

IDメソッド。

insertX

523

332

insertメソッド

Isolation.

PersonFinder..

PersonGateway.

PersonMapper.

182

.167

156

249

153, 157, 187, 296, 325

J

.184

176, 183

342, 348

074

172, 176

Person レコード.

J2EE

P

Person.

PersonMapper 57.

Personオブジェクト

106, 125

Personクラス。

Java

106

JavaBean.

JSP

JSP ビュー

165

359, 374, 378, 398

PHP.

374

416

L

Line Items-71.

LineItemクラス。

243, 250 246, 251

Loaderクラス.

Loadメソッド

load 184, 243, 262, 264, 273, 290

M

PlayerMapperクラス.

301, 303, 313, 326

Playerマッパー。

Player レコード。

265

POJO ドメインモデル、

112

Microsoft DNA レイヤ.

Moneyクラス。

111

MVC.

N

Nilsson レイヤー

null.

nullオブジェクト

519

263

356

ProductOfferingクラス.

R

126

290

302, 309, 320

Recognition Strategy.

RecognitionService..

Revenue Recognition 028, 119, 127, 137, 147

S

279

Saveメソッド.

136

object registration...

Ordersクラス.

Orders-7.

029

271, 304, 312

Marinescu レイヤ

saveメソッド。

Microsoft COM.

set メソッド

325

Skill

.147

268, 276

351

SQL...

193

T

513

055

Team 757-

112

Track..

263

Track レコード.

U

284

255

518 Updateメソッド.

271, 311, 321

update 153, 157, 161, 187, 325

W

199

WebSphere.

251

243

Webアプリケーション 057

Webサービス..

483

109, 419

542

Webハンドラ 367 Webプレゼンテーション。 057 Webプレゼンテーションパターン。 351 アプリケーションコントローラ... 060, 403 ツーステップビュー 060, 106,388 テンプレートビュー 060, 105, 355,

373, 385

トランスフォームビュー 060, 106,384 フロントコントローラ. 105, 366

ページコントローラ

063,105,354

モデルビューコントローラ_058, 105,351

WSDL.

422

x

XML

XSLT.

385, 435

え

385

あ

アーキテクチャ

アクティブレコード.

アセンブラオブジェクト

033, 037, 163, 170

001

アダプター---

アプリケーションコントローラ...

アプリケーションロジック

429

491

060, 403

暗黙重オフラインロック

暗黙的なインタフェース 暗黙ロック

143

1080, 474

い

依存マッピング.. 212. 256. 267, 282 一意フィールド. 一意マッピング。 一時的読み込み、 044, 231, 315 041, 044, 209 072 一貫性 074 一貫性のない読み込み. 066, 071 意味のあるキー 232 意味のないキー. 232 インターセプティングフィルタ 368 インタプリタプログラム..... 339 う

パターン 197 一意マッピング 041. 044, 209 ユニットオブワーク。 041. 104. 197 レイジーロード 041,044,098, 213 オブジェクトリレーショナルマッピング 327 531 オブジェクトリレーショナルメタデータ マッピングパターン 327

476

クエリーオブジェクト 052,338,341,

メタデータマッピング。 _052, 181. 327

リポジトリ

052, 345

オフライン並行性

065, 078. 450

売上税サービス、

エンタープライズアプリケーション 002 エンティティBean. 125

お

オブザーバーパターン 151 オブジェクトリレーショナル構造パターン 231 依存マッピング 212. 256. 267, 282 一意フィールド 044, 231, 315 外部キーマッピング 044, 254, 267 関連テーブルマッピング 045,25,266 具象テーブル継承 組込バリュー 047,299, 307,314 288. 509 クラステーブル継承 047. 299, 306,316 継承マッパー_ 324 シリアライズLOB. 047, 292, 509 シングルテーブル継承 047,298, 307, 316

オブジェクトリレーショナル振る舞い

346

オフライン並行性制御。

080

オフライン並行性パターン。

暗黙ロック

ロック

439

_080, 474

080, 442, 448, 462

オフラインロック.080, 104,439,463

重オフラインロック_080443.450 463 重い並行性制御 .069

か

527

外部キーマッピング

書き込み専用ロック 拡張性。

044. 254, 267

451

008

カスタムタグ 仮想プロキシー 214, 217 空のオブジェクト、 193 軽い並行性制御 .069 関係のマッピング。 043 関連テーブルマッピング。 045, 25, 266 ロック。 080, 442, 448, 462 き キー 231 マッピングの~。 210 キークラス 241 キーテーブル. 境界_ 235, 238 464 行データゲートウェイ 共有軽オフラインロック 共有重オフラインロック. 共有ロック。 027, 036, 103, 162 466 ゲートウェイ 463, 472 463 <

Person Mapperクラス. .176. 183 Personクラス.. 172, 176 PlayerMapperクラス... 301, 303,313,326 ProductOfferingクラス. 290 Teamクラス. 263 クラスタリング。 095 クラステーブル継承.. 047, 299, 306, 316 繰り返し可能な読み込み. 繰り返し不可能な読み込み. 076 .076

軽オフラインロック. 080, 104, 439, 463

クエリーオブジェクト。 _052, 338. 341. 346 具象Mapperクラス 具象Player. 224 317

324

具象テーブル継承

組込バリュー

047, 299, 307, 314

クライアント/サーバシステム.

288, 509

018

クライアントセッションステート 088,479

クラス

AbstractPlayer Mapperクラス,

301

Album Mapperクラス。

Albumクラス.

285

047

069

074, 079

..076

こ

255, 418

Artistクラス

363

258, 418

076

BowlerMapper クラス

325

Customerクラス

Dependentクラス.

Employee Mapperクラス、

294

Employeeクラス.

282

268, 272

268, 276

継承マッパー

Gatewayクラス

.166, 318

LineItemクラス。

246, 251

Loaderクラス.

Moneyクラス.

513

軽ロック.

原子性。

036, 489

更新結果の喪失。

279

効率性...

066

ゴースト

008

ゴーストリスト.

215, 221

コード生成

226

Ordersクラス.

コードビハインドメカニズム. コミットされた読み込み、

327

コミットされていない読み込み。 コレクション

..077

コントローラ

046

コントローラ/メディエータ

コントローラエンティティ

058, 060, 353

さ

110

033

Ownerクラス。

251

幻像

け

继承

サーバアフィニティ 089 サーバセッションステート. 088, 481 サーバページ. 058, 355, 374 サービススタブ 490, 526 サービスレイヤ 033, 142, 415 サーブレットコントローラ, 356 参照のコレクション 263

し

282

システムトランザクション 077

544

075

疎結合トランザクション。

耐久性

_074. 079

実行コンテキスト 自動生成フィールド 067 234 収益認識オブジェクト。 重オフラインロック 集合体。 028 080, 443, 450, 463 464 集合体マッピング。 290 重ロック 条件付きページ。 状態モデル。 シリアライズLOB. 070 375 406 017, 292, 509 シングルステージビュー 392 シングルスレッドアパートメント。 082 シングルテーブル継承 ...... 047, 298, 307.316 シングルトンレジストリ 505

す

スクリプトレット 374 スケールアウト 008 スケールアップ 008 ステートフルセッションBean. 483 ステートレスサーバ。 085 ステートレス性。 085 ストアドプロシージャ。 108 スペシャルケース。 371, 518 スループット 008 スレッド....... 068 スレッドセーフレジストリ 507

せ

整数型キー

セッション

236

068

た

单一值参照。

単純キー..

ち

データベースセッションステート... 088,485

セッションファサード.....

セパレートインタフェース。

258

232

180, 499, 521

遅延トランザクション

075

直列化

XMLを使用する~

292

435

076

直列化可能。

つ

セッション移行

089

085, 087

セッションステート

セッションステートパターン.

クライアントセッションステート... 088,479 サーバセッションステート 088,481

479

146, 415

そ

操作スクリプト手法 143

ツーステージXSLT-

ツーステップビュー。

395

060, 106, 388

て

ティア

データセットホルダー

020

即応性

269

データソースのアーキテクチャに関するパターン

153

アクティブレコード_033. 037. 163, 170 行データゲートウェイ 027,036, 103. 162

データマッパー_038, 105, 175,345, 444 テーブルデータゲートウェイ027,036

103, 119, 153 データソースレイヤ 020. 103 データソースロジック 020 データ転送オブジェクト 428 データベース一意キー。 233 データベースカウンタ 234 データベースセッションステート 088. 485 データベース接続。 053 データ変換オブジェクト. 025, 09, 425 データマッパー。 038, 105, 175, 345, 444. データマッピング。 テーブル_ 330 039 テーブル一章キー。 233 テーブルスキャン、 234 テーブルデータゲートウェイ027,036, 103,

119, 153

067

545

テーブルモジュール。 027. 030, 032, 102. 104. 133 テキスト形式 292 デッドロック 072 テンプレートビュー___060, 105,355,373,385

と

498

ドメインオブジェクト。

ドメインオブジェクト用のデータホルダー_169 ドメインファサード的手法. 143

ドメインモデル 024,027,032,102,123

ドメインレイヤ_

020, 102

ドメインロジック

021, 027, 143

ドメインロジックパターン

サービスレイヤ

115

033, 142, 415

テーブルモジュール。 102, 104, 133

027. 030, 032,

ドメインモデル_024.027,032, 102,123 トランザクションスクリプト_024027 032, 102, 115

トランザクション。

トランザクション可能なリソース_

068, 073

トランザクションスクリプト024,027,032, 102, 115

074

トランスフォームビュー。 060, 106, 384

に

入力コントローラ. 058, 063 認識ストラテジーオブジェクト 029

は

バイナリ形式。

292

パターン。 009 Webプレゼンテーション~ .351 アクティブレコード__033,037, 163,170 アプリケーションコントローラ.060,403 暗黙ロック。 080, 474 依存マッピング 一章フィールド。 一意マッピング 212, 256, 267, 282 044, 231, 315 041, 044, 209 オブジェクトリレーショナル構造~ 231 オブジェクトリレーショナル振る舞い〜

オブジェクトリレーショナルメタデータ

マッピング~。 オフライン並行性~ 327 .439 外部キーマッピング 044. 254, 267 関連テーブルマッピング .....045,025,266 ロック _ 080, 442, 448, 462 行データゲートウェイ 027, 036, 103, 162

クエリーオブジェクト 052,338,341, 346

具象テーブル継承 047, 299, 307,314 組込バリュー 288, 509 クライアントセッションステート... 088, 479 クラステーブル継承 047, 299, 306,316 軽オフラインロック 080, 104,439,463 継承マッパー。 324 ゲートウェイ. 036, 489 サーバセッションステート 088, 481 サービススタブ. サービスレイヤ 490, 526 .033, 142. 415 オフラインロック 080, 443, 450, 463 シリアライズLOB. 047, 292, 509 シングルテーブル継承 047,298,307, 316

スペシャルケース.. 371, 518 セッションステート~ 479 セパレートインタフェース 180,499,521 ツーステップビュー.. 060, 106, 388 データソースのアーキテクチャに関する〜

153 103, 119, 153

データベースセッションステート...088,485 データ変換オブジェクト......025,009,425 データマッパー038, 105, 175,345, 444 テーブルデータゲートウェイ... 027,036,

テーブルモジュール....027,030,032, 102, 104, 133

テンプレートビュー。 060, 105, 355, 373, 385

ドメインモデル...024,027,032, 102,123 ドメインロジック〜 .115

197

トランザクションスクリプト ...... 024,027, 032, 102, 115

546

プレゼンテーションロジック

トランスフォームビュー..... 060, 106, 384 バリューオブジェクト 046,098,215,

020

290, 430, 508, 510 プラグイン 521 フロントコントローラ 分散~ 105, 366 ..411 ページコントローラ. 063, 105, 354 ベース~ マッパー 489 496 マネー 121, 139, 510 メタデータマッピング 052, 181.327 モデルビューコントローラ_058, 105, 351 ユニットオブワーク 041, 104, 197 リポジトリ リモートファサード。 レイジーロード 052. 345 025, 098, 411 041,044,098,213 レイヤスーパータイプ_075, 187 221,497 レコードセット. 030, 036, 053, 054. 135, 427, 530

レジストリ

パフォーマンス

054. 502

バリューオブジェクト

430, 508, 510

006, 008

046,098,215, 290,

バリューホルダー。

215, 218

バルクアクセッサー.

ひ

ビジネスインタフェース

ビジネスロジック

ビュー.

ふ

負荷..

負荷感度。

不確定な読み込み

複合キー

プラグイン

プロセス 068 フロントコントローラ. 分散オブジェクト 分散境界。 105. 366 093 097 分散ストラテジー 093 分散パターン。 411 データ変換オブジェクト025,009,425 リモートファサード 025, 098, 411 分散用インタフェース。 098 分離

ビューとコントローラの

352

353

モデルとプレゼンテーションの~ 分離されたスレッド. 分離性

074, 079

068

並行性

065

アプリケーションサーバの〜

並行性制御。

ページコントローラ.

081

ページハンドラ

063. 105, 354

ベースパターン

複数テーブル検索

069

362

489

412

ゲートウェイ

021, 143

サービススタブ.

490. 526

036, 489

.149

ビジネストランザクション.

078

スペシャルケース_

039, 060, 385

371, 518

セパレートインタフェース__ 180.499,521

バリューオブジェクト

046,098,215,

フィルタチェーン

290. 430, 508, 510

プラグイン。

マッパー。

368

.008

521

マネー。

496

121, 139, 510

レイヤスーパータイプ_075, 187,221.

008

497

.077

232, 240

複雑性のブースター

振る舞い..

レコードセット

030, 036, 053, 054.

135, 427, 530

ヘキサゴナルアーキテクチャ 021 .025 ヘルパーオブジェクト. 375

261

レジストリ

054, 502

521

プレゼンテーションレイヤ

ま

040 マークの埋め込み。

020, 105 待ち時間

374

007

451

マッパー。 マッピング 2重の 関係の〜。 496 051 043 メタデータ~ 052 マッピングツール、 040 マッピングの構築。 マネー- 050 121, 139, 510

め

明示的なインタフェース.

531

メソッド

AbstractFind メソッド。

Attachメソッド_

delete メソッド.

309 リモートファサード..

Findメソッド。

229

153, 158

224, 302, 309

findメソッド_042, 153, 163, 168, 171,

173, 180, 183, 188, 243, 264, 273, 325

getメソッド_

IDメソッド_

.169

insertメソッド__ 153, 157, 187, 296, 325

332

Loadメソッド。

302, 309, 320

loadメソッド_184,243,262 264 273,

290

Saveメソッド.

saveメソッド

set メソッド.

Updateメソッド..

update メソッド... 153, 157, 161, 187,325

052. 181. 327

メッセージングサービス、 メディエータ

も

ゆ

読み書きロック 451

読み込み専用ロック

リーフテーブル継承。

リクエスト。

ユニットオブワーク.

ユニットオブワークコントローラ

067

316

り

リクエストトランザクション

075

リッチクライアント

020

リフレクション

リフレクティブプログラム リポジトリ

330

328, 334

リモートインタフェース

052, 345 094

025, 098, 411

リレーショナルデータベース.

る

035

ルート

325

.464 ルート軽オフラインロック 473 ルートリーフマッピング ルートロック... 308 .464

れ

193

271, 311, 321

メタデータ

メタデータマッパー。

052

メタデータマッピング_

179

モデルビューコントローラ.

_058, 105, 351

レイジーイニシャライズ

271, 304, 312 レイヤ

レイジーロード.

214, 217

レイヤ化

041, 044, 098, 213 017, 020

041, 104, 197

017

レイヤスーパータイプ 075, 187,221,497 レコードセット 030,036,053,054,135,

.492

427, 530

レコードデータ

レジストリ

054, 502

087

レスポンス時間。

レスポンス性

007

491, 497

201

007

ろ

ローカルインタフェース,

ロックエスカレーション ロックマッパー

094

075

ロックマネージャー。

477

ロングトランザクション

455

わ

075

よ

容量

008

ワークフローロジック

143

548

■著者紹介

Martin Fowler (マーチン・ファウラー)

エンタープライズアプリケーションの開発元であるThought Works社のチーフサイエンティ ストをつとめる。 10年以上にわたりオブジェクト指向テクノロジーをエンタープライズ系の ソフトウェア開発に適用してきた。 パターン、 UML、 リファクタリング、およびアジャイル 手法の分野の第一人者である。 マサチューセッツ州メルローズ市在住。 ホームページは http://www.martinfowler.com

[著書]

Analysis Patterns: Reusable Object Modeling. 1997 「アナリシスパターン」 (ピアソン・エデュケーション、 2002) Refactoring. Improving the Design of Existing Code, 1999 「リファクタリング」 (ピアソン・エデュケーション 2000) UML Distilled. 2nd Edition. 2000 「UMLモデリングのエッセンス第2版」 (翔泳社, 2000)

■監訳者紹介

長瀬嘉秀 (ながせ よしひで )

1986年東京理科大学理学部応用数学科卒業。 朝日新聞を経て、1989年テクノロジックアート を設立。 OSF (Open Software Foundation) のテクニカルコンサルタントとしてDCE関連の オープンシステムの推進を行う。 OSF日本ペンダ協議会DCE技術検討委員会の主査をつとめ る。 現在、 株式会社テクノロジックアート代表取締役。 UMLによるオブジェクト指向セミナーの講師、 UML関連のコンサルティングを行っている。 UML Profile for EDOCの共同提案者、 ISO/IECJTC1 SC32/WG2委員、 情報処理相互運用技

術協会 (INTAP) オープン分散処理委員、 電子商取引推進協議会 (ECOM) XML/EDI標準 化調査委員。 明星大学情報学部講師。

【著書】

「分散コンピューティング環境DCE」 (共著、 共立出版、1997) 「DCE Today」 (共著、 米国Prentice-Hall、1998) 「ソフトウェアパターン再考」 (共著、 日科技連出版社、2000) 「コンポーネントモデリングガイド」 (監修、ピアソン・エデュケーション「eXtreme Programming テスト技法」 (監修、 翔泳社, 2001) 「オブジェクト脳のつくり方」 (監修、 翔泳社、2003) 「UMLシステム設計実践技大全」 (監修、 ナツメ社, 2003) 「独習デザインパターン」 (監修、 翔泳社、2003) 「UMLトレーニングブック」 (監修、 ソーテック社, 2004) 「UML 2 ハンドブック」 (監修、 翔泳社, 2004)

、2001)

[訳書】

「パターンハッチング」 (共訳、ピアソン・エデュケーション 1999)

「独習UML」(監訳、 翔泳社, 2000)

「XPエクストリーム 「XPエクストリーム 2002)

(監訳、 ピアソンエデュケーション、2000) プログラミング入門」 (監訳、 ピアソン・エデュケーション、 プログラミングアドベンチャー」

「アジャイルソフトウェア開発」 (監訳、ピアソン・エデュケーション、2002)

「テスト駆動開発入門」 (監訳、 ピアソン・エデュケーション、2003)

「プログラミングJakarta Struts」 (監訳 オライリー・ジャパン、2003)

「Executable UML」 (監訳、 翔泳社, 2003)

「MDA (モデル駆動型アーキテクチャ) 導入ガイド」 (監訳、 インプレス、 2003)

「実践eXtreme プログラミング」 (監訳、 九天社、2004)

「アジャイルソフトウェア開発ソフトウェアチーム」 (監訳、 九天社, 2004)

■訳者紹介

永田渉 (ながたわたる)

1991年東京大学文学部社会心理学専修課程卒業。 トランスコスモス株式会社、マイルストーン株 式会社を経て、1994年株式会社テクノロジックアート入社。 現在、 分析、実装、テスト、執筆、教 育などシステム開発のあらゆるフェーズに携わっている。 方法論やオブジェクト指向に関する書籍 および雑誌記事の執筆多数。

[訳書

「パターンハッチング」 (共訳、 ピアソン・エデュケーション, 1999)

「XPエクストリームプログラミング入門」 (共訳、ピアソン・エデュケーション 2000) 「アジャ イルソフトウェア開発」 (共訳、 ピアソン・エデュケーション, 2002)

「アジャイルプロジェクト管理」 (共訳、ピアソン・エデュケーション 2002)

「初級デザインパターン」 (共訳、 ピアソン・エデュケーション, 2002)

「プログラマのためのJava設計ベストプラクティス」 (共訳、ピアソン・エデュケーション2002) 「入門 Carbon」(共訳、 オライリー・ジャパン, 2001)

「入門Cocoa」 (共訳、 オライリー・ジャパン, 2002)

「Webサービスエッセンシャルズ」 (共訳、 オライリー・ジャパン2002)

「Java Webサービス」 (共訳、 オライリー・ジャパン, 2002)

「プログラミングJakarta Struts」 (オライリー・ジャパン, 2003)

「Jakarta Struts デスクトップリファレンス」(オライリー・ジャパン, 2003)

坂本武志 (さかもとたけし)

1994年千葉大学大学院工学研究科修了。 同年産業用電気機器メーカに入社。 人間共存型ロボットの 研究・開発に従事。2000年医療系ソフトウェア開発会社に入社。 電子カルテシステムを中心とした 医療情報システムの開発に従事。 2004年株式会社テクノロジックアート入社。 現在、 UML Profile for EDOC や RM-ODPを用いた医療分野のモデリング、 組込分野における開発方法論の開発に従事。

【著書】

「独習UML 第3版」 (共著、 翔泳社, 2005)

【訳書】

「マインドストームプログラム入門-LEGOでメカトロニクス/ロボティクスを学習する COMPUTER TECHBOLOGY」 (CQ出版)

藤川幸一 (ふじかわこういち) 2001年早稲田大学理工学部卒業。同年ヤフー株式会社入社。 2004年株式会社テクノロジックアート 入社。 現在、 UMLやMDAなどの執筆やセミナー活動, ebXML (UMM) を用いたEDIのモデリン グに従事。

【著書】

「JSPプログラミングステップアップラーニング [応用編]」(技術評論社) 「独習UML 第3版」 (共著、 翔沐社, 2005)

武田 知子(たけだともこ) 1993年川村短期大学英文科卒業。 生命保険会社を経て、2002年株式会社テクノロジックアート入社。 現在、 UML 関連書籍の翻訳、 執筆等に従事。

【著書】

「基礎UML」(共著、 インプレス、2003) 「UMLモデリング教科書 UML モデリングL1 (T1 T2対応)」 (共著、 翔泳社, 2004)

【訳書】

「ワークブック形式で学ぶUMLオブジェクトモデリング- 「ユースケース駆動」でソフトウェアを 開発する」 (共訳、ソフトバンクパブリッシング、2002) 「Developing Applications with JAVA and UMLプログラマーのための統一モデリング」 (共訳、 ビーエヌエヌ新社, 2003) 「JavaによるExtreme Programmingクックブック」 (共訳、 オライリー・ジャパン、2003) 「MDA (モデル駆動型アーキテクチャ) 導入ガイド」 (共訳、 インプレス、2003) 「リファクタリングワークブック-設計の改善テクニックを学ぶ」 (共訳、 アスキー、2004)

ボルターハウス) DTP 株式会社コスモユノー

エンタープライスアプリケーション アーキテクチャパターン

2005年4月20日 第1刷発行

著者 監訳 EF Martin Fowler (マーチン・ファウラー) ながせ よしひで) 株式会社テクノロジックアート 速水 浩二: 株式会社 (http://www.seshop.com) 大日本印刷株式会社

を受けています。本書の一部または全部に

およびプログラムを含む)、株式会社

ずに、いかなる方法においてもで

記載の内容をお読みくだ

ますまでください。

4-7981-0553-8 Printed in Japan

