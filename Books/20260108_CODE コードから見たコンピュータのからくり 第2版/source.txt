CODE

■コードから見たコンピュータのからくり

第2版

チャールズ・ベゾルド 著 酒匂寬 訳

1000011 1001111 1000 100 1000101

C

D SECOND EDITION

E

武雄市図書館| 11287097-7

TRC236006

uage of

and Software

日経BP



CODE コードから見たコンピュータのからくり

第2版

チャールズ・ベゾルド 著 酒匂 寛 訳

The Hidden Language of Computer Hardware and Software

Code: The Hidden Language of Computer Hardware and Software: Second Edition

Published with the authorization of Microsoft Corporation by: Pearson Education, Inc. Copyright © 2023 by Charles Petzold.

Japanese translation rights arranged with Pearson Education, Inc. through Japan UNI Agency, Inc., Tokyo, Japan Japanese language edition published by Nikkei Business Publications, Inc. Copyright © 2024

code (kōd) n.

1. a. メッセージを送信する際に、 文字または数字を表すために

使用される信号システム。 b. 特定の意味を与えられた記号、 文字、 または単語の体系で、 秘密または簡潔さを必要とするメッセージの送信に使用さ れる。

2.

a. 特定のコンピュータプログラムを構成する情報。 b. コンピュータの命令となる記号と規則のシステム。

『アメリカン ヘリテージ英語辞典』 (オンライン版) より

北で

目次

第2版への序文 7

第1章 親友 11

第 2 章 コードと組み合わせ 19 第3章 点字とバイナリーコード 27 第4章 懐中電灯の解剖学 37 第5章 角を曲がったやり取り 49 第6章 スイッチを使ったロジック 61 第7章 電信とリレー 83 第 8 章 リレーとゲート 91 第9章 私たちが使う 10種類の数字 123 第10章 10 に代わる数 133 第1章 ビットでちょびっとずつ 157 第12章 バイトと16進数 185 第13章 ASCII から Unicode へ 199 第14章 論理ゲートによる加算 225

第15章

これは本当なのか? 243

第16章

でも、減算はどうする? 261

第17章

フィードバックとフリップフロップ 281

第18章

時計を作ろう! 315

第19章

メモリーの組み立て 349

第20章

計算の自動化 379

第21章

第22章

算術論理演算装置 (ALU) 413

第23章

レジスターとバス 437

CPU 制御信号 463

第24章

ループ、ジャンプ、コール 495

第25章

周辺機器 527

第26章

第27章

オペレーティングシステム 541

コーディング 559

第28章 世界頭脳 589

索引 606

・本文中 [ ]は訳者による補足を示す。



第2版への序文

本書の第1版は1999年9月に発行された [日本語版は2003年4月]。 そのとき は、ついに「改訂不要」 の本が書けたと喜んだ! これは、私の初めての著書であ る Microsoft Windows向けアプリケーションのプログラミングに関する書籍と は好対照だった。 こちらは、わずか10年の間にすでに5回も改訂していたのだ。 そして、私の2冊目となる OS/2 Presentation Manager (覚えている人はいるだ ろうか) の本は、もっと早く陳腐化してしまった。 しかし、この 『CODE』 は永 遠にこのままでいけると確信していた。

CODE の最初のアイデアは、 デジタルコンピュータの仕組みを、とてもシンプ ルなコンセプトから徐々に深く理解していくことだった。 この「知識の丘」 へ着 実に上っていく過程で、私はたとえ話、類推、 くだらないイラストの使用を最小 限に抑え、その代わりにコンピュータを設計・構築する実際のエンジニアが用い る言葉と記号を使用するつもりだった。 私にはとても巧妙な戦術もあった。 普遍 的な原則を示すために、 枯れた技術を使用するのだ。 何しろ十分に枯れた技術は こなれていて、これ以上古くなることはないと考えたからだ。 それはまるで、 フォード・モデルTに基づいて内燃機関の本を書いているようだった。

そのやり方は正しかったと今でも思っているものの、細かい部分では限界も あった。 年月が経つにつれて、 第1版に古さを感じるようになったのだ。 文化 的な物言いの中には陳腐化したものもあった。 携帯電話や手の指がキーボードや マウスの代わりをし始めた。 1999年当時にもインターネットは確かに存在して いたが、その後の変化に比べるとまだ何もないようなものだった。 世界中の言語

や絵文字を統一的に表現するためのテキストエンコードである Unicode [ユニコー ド] の記述は、 初版では1ページにも満たないほどだった。 そして、 ウェブに浸 透しているプログラミング言語である JavaScript [ジャバスクリプト]については、 全く触れていなかった。

そうした問題はおそらく容易に修正できたと思うが、第1版には私を悩ませ 続けた別の側面が存在していた。 実際の CPU、 すなわちコンピュータの脳、心、 魂を形成する中央演算処理装置の仕組みをきちんと説明したかったものの、 結局 うまくいかなかったのだ。 もっとうまくやれたのでは、と感じたりもしたが、 最 後は諦めてしまった。 読者は不平を言わなかったようだが、 私にとっては際立っ た欠陥だった。

この欠陥は、 第2版で修正された。 本書が100ページ近く第1版よりも長く なっている理由でもある。 その通り、 本書を読み進めるのは長い旅になる。 ペー ジを通して私と一緒に最後までたどり着ければ、 CPUの内部にさらに深く潜り 込むことができる。 これがあなたにとって楽しい経験になるかどうかは、私には わからない。 溺れそうだと感じたなら、 息をするために上がってくるように。し かし、 第24章を乗り越えたなら、 非常に誇らしい気持ちになるはずだし、 本書 の残りの部分は楽勝であることをうれしく感じるだろう。

本書のウェブサイト

CODE の第1版では、 電気の流れを示すため、 回路図に赤色を使 用していた。 第2版でも同じだが、これらの回路の動作を、 Code Hidden Language.com という新しいウェブサイトで、 グラ フィカルかつインタラクティブに見ることができる。

本書を読み進める際に、 時折このウェブサイトを思い出してもらうつもりだ が、この段落の余白にある、 特別なアイコンも使う予定だ。 このアイコン (通常 は回路図と一緒に登場する) があれば、ウェブサイト上でその回路の動作を確認 できる (技術的な背景を知りたい人のために補足すると、 これはHTML5の canvas 要素を使ってJavaScript でプログラミングしたウェブグラフィックスで ある)。

Code Hidden Language.com のウェブサイトは完全に無料で使用できる。 有料 プランはなく、目にするのは本書の広告だけだ。 いくつかの例ではクッキーを使

8

第2版への序文

用するものの、読者のコンピュータにわずかな情報を保存するためだけである。 このウェブサイトは読者を追跡したり邪悪なことは一切しない。

また、本書に記載されている内容の補足や訂正のために、このウェブサイトを 利用する予定である [日本語版についての補足や訂正は日本語版のサイトに掲載]。

本書の責任者

本書の責任者の1人の名前は表紙にある。 以下で紹介する人たちも責任者同 様に欠かせない存在だ。

特に、エグゼクティブエディターのHaze Humbert に言及したい。 彼女は、 私の準備ができていたちょうど正しいタイミングで、第2版の可能性を聞いて くれた。 私は2021年1月に本書の改訂作業を開始したが、彼女は試練を通して 私を巧みに導いてくれた。 たとえ原稿が締切を何か月すぎても、 そして私が道を 完全に踏み誤っていないという保証がほしかったときにも、 である。

第1版のプロジェクトエディターは Kathleen Atkins で、 彼女も私がやろうと していることを理解して、 楽しい共同作業時間をたくさん提供してくれた。 当時 私のエージェントは Claudette Moore だったが、 彼もこのような本の価値を 見抜き、マイクロソフトプレスを説得して出版にこぎつけた。

第1版のテクニカルエディターは Jim Fuchs で、 彼が私の恥ずかしいミスを たくさん見つけてくれたことを覚えている。 第2版では、 テクニカル・レビュ アーの Mark Seemann と Larry O'Brien が、 いくつかの間違いを指摘し、本書 をよりよいものにするために協力してくれた。

私は何十年も前に 「compose」と「comprise」 の違いを理解できたと思って いたのだが、どうやらそうではなかったようだ どちらも「構成する」と訳出できる がニュアンスが異なる。 前者は構成する、後者は成る、を意味する]。 このようなミスを修 正できたのは、コピーエディターのScout Festa の貴重な貢献だ。 私はいつも、 コピーエディターの優しさに頼ってきた。 実際に会う機会はほとんどないが、 彼 らはいつも言葉の不正確さや乱用と不屈に戦っているのだ。

本書に残る誤りは、すべて私の責任である。

第1版のベータリーダーのみなさんに改めて感謝したい。 Sheryl Canter、 Jan Peter Goldeman, Lynn Magalska, UT Deirdre Sinnott (5 に私の妻となる)。 Eastlund,

9

第1版に掲載された多数の図版は、 故 Joel Panchot の作品であり、 彼は本書 での自分の仕事を当然のように誇りにしていたと聞いている。 彼の図版の多くは 残っているが、回路図を追加する必要があったため、 一貫性を持たせるためにす べての回路は作り直した (追加的な技術的背景。 これらの図は、 Scalable Vector Graphics [SVG] ファイルを生成する SkiaSharp グラフィックライブラ リを使用して、 私が C#で書いたプログラムによって生成された。 その SVG は、 シニアコンテンツプロデューサーのTracey Croom の指示のもと、Adobe InDesign でページを構成するための EPS に変換された)。

さいごに

本書を、 私の人生で最も大切な2人の女性に捧げます。

私の母は、弱い人間であれば挫けてしまうような逆境と闘っていました。彼女 は、決して私を束縛することなく、 私の人生に強い方向性を与えてくれたので す。 本書の執筆中に、 彼女は95歳の (そして最後の) 誕生日を迎えました。

私の妻、 Deirdre Sinnott はいなくてはならない存在でした。 彼女の功績、 サ ポート、そして愛情を誇りに思い続けています。

そして、第1版を読んでくださった読者の方々の温かいご感想も、 本当にう れしいものでした。

Charles Petzold 2022年5月9日

10

第1章 親友

あなたは10歳だとしよう。 親友が通りの向かいに住んでいる。 2人の寝室の 窓は通りを挟んで向かい合っている。 毎晩、 親から「もう寝なさい!」 と言われ たあとでも、 考えごとや出来事、 秘密、 噂話、 冗談、 夢などを親友とやり取りし たい。 無理もない。 コミュニケーションへの衝動は、人間の最も重要な特性の 1つなのだ。

寝室の明かりが点いているなら、窓から手を振り合って、 大まかなジェス チャーや初歩的なボディランゲージで親友同士の簡単な思いを伝え合える。しか し、さらに込み入ったやり取りは難しいし、 親が 「消灯!」 と宣言したあとで は、もっとこっそり行える解決策が必要になる。

どのようにコミュニケーションすればよいのだろう? もしあなたが幸運にも 10歳で携帯電話を持っていたなら、こっそり通話したり黙ってメッセージを送っ たりできるかもしれない。 それでも、就寝時には両親に携帯電話を没収され、 Wi-Fiも切られてしまうような家だったらどうすればいい? 電子通信手段のない 寝室はすっかり孤立してしまう。

けれども、あなたとあなたの親友は懐中電灯を持っているとしよう。 懐中電灯 は、子どもが布団の中でこっそり本を読むために発明されたことはよく知られて いるが、暗くなってからの通信手段としても最適に思える。 音は十分に静かだ し、光は指向性が高いので寝室のドアの下から漏れて疑い深い両親に気づかれる こともないだろう。

懐中電灯で会話は可能だろうか? もちろん、 やってみる価値はある。 小学校

1年生で紙に文字や言葉を書くことを習ったのだから、その知識を懐中電灯で使 うのは合理的だろう。 窓辺に立って、 光で文字を描けばよい。 O(オー) を描く 場合は、まず懐中電灯を点けて、 空中で円を描いて、スイッチを切る。 I(アイ) の場合は、 縦に振るわけだ。 しかし、 すぐわかるように、この方法は失敗に終わ る。 友だちの懐中電灯が空中にさっと線を描くのを見ているうちに、頭の中で複 数の線を組み立てるのは難しすぎることに気がつく。 くるくる渦巻いたり、 さっ と振り払うような光は、正確さに欠けるのだ。

おそらく映画で、海を挟んだ2人の船乗りが、 光を点滅させて通信する場面 を見たことがあるだろう。 ある映画では、 スパイが鏡を動かして、別のスパイが 捕らわれている部屋に太陽光を反射させるシーンがあった。 それが解決策なのか もしれない。 そこでまず、簡単なテクニックを考案してみよう。 アルファベット の各文字を、 懐中電灯の一連の点滅に対応させるのだ。 Aは1回の点滅、 Bは2 回の点滅、 Cは3回の点滅 そしてZは26回の点滅という具合だ。 こうする と BAD は、 2回点滅、 1回点滅、 4回点滅、 で表現される。このとき、文字と 文字の間に少し長い消灯を入れて、 Gを表す7回の点滅と区別できるようにす る必要がある。

これはうまくいきそうだ。 ありがたいことに、 もう懐中電灯を空中で振り回す 必要はなく、 相手に向けてチカチカさせればいいだけだ。 しかし、 残念なこと に、最初に送りたかったメッセージ 「How are you? [元気?])」 のためには、 131 回の点滅が必要なことが判明した! しかも、 英字以外の文字のことは忘れて いたので、 クエスチョンマーク (?) のためには何回点滅させればいいのかわか らない。

でも、いい感じできていたのだ。 きっと以前にも誰かが同じ問題に直面したこ とがあるに違いない、 とあなたは思うだろう。そう、 その想像は正しい。 図書館 に行ったり、 インターネットで調べたりすれば、 モールスコード [モールス符号] という素晴らしい発明を発見するだろう。 アルファベットの「書き方」 は勉強し 直さなければならないが、これこそまさに求めていたものだ。

どこに違いがあるのだろう。 あなたが考えたシステム [体系] ではAは1回、 Zは26回という具合に点滅を行ったが、 モールスコードには短い点灯と長い点 灯の2種類がある。 こうすることで、 モールスコードが少し複雑になるのは仕 方ないが、 実際にやってみると、 はるかに効率的なことがわかる。 「How are

12

第1章 親友

13

you?」 という文章を書くのに必要な点滅回数は、 クエスチョンマークを含んで も以前の 131 回からわずか32回となる(これには長い点滅と短い点滅が含まれ る)。

ところで、 モールスコードの動作を議論するとき、 「短い点滅」 や 「長い点滅」 という言葉は使わない。 その代わりに使われるのが「ドット[.]」 と 「ダッシュ [一]」 だ。 これらが使われるのは、印刷物でコードを示すのに便利なためである。 モールスコードでアルファベットの各文字は、次の表にあるように、 ドットと ダッシュの短い列に対応する。

A J S B K T - C momo L moo U D M -- V .com E • N -O W M F X 1001 G ■■ P Y -ON- H .... Q -1 Z O I .. R mo

モールスコード自体は、 コンピュータとは全く関係がない。 それでも、 コン ピュータのハードウエアの内部構造やソフトウエアに隠された言語を深く理解す るための予備知識

として、 コードの性質を熟知することは必要だ。

本書では通常、 コードという言葉は、 人と人の間、 人とコンピュータの間、 あ

るいはコンピュータ自体の中で情報を伝達するためのシステムを意味する。 コードを使えば、 コミュニケーションができるようになる。 コードが秘密に なっている場合もあるが、ほとんどのコードはそうではない。 コードは人間同士 のコミュニケーションの基礎になるため、十分に理解される必要がある。

私たちが口から発する音声は、私たちの声が聞こえてその話す言葉が理解でき る人なら誰でも理解できるコードを構成している。 このコードは 「話し言葉」 ま たは「スピーチ」 と呼ばれる。

聴覚障害者のコミュニティでは、 様々な手話が、 手や腕の動きや身振りを使っ

14

ろう て、文字や言葉、 概念を伝える。 北米で最も普及している手話体系は、19世紀 初頭にアメリカの聾学校で開発されたアメリカ手話 (ASL、 American Sign Language)と、フランス語の手話を基に作られたケベック手話 (LSQ、 Langue des signes Québécoise) である。

私たちは、紙に書く言葉には別のコードを使っていて、それらは「書き言葉」 あるいは「テキスト」 と呼ばれる。 テキストは手で書かれたり、キーボードで入 力されたあと、新聞、雑誌、 本に印刷されたり、 様々なデバイス [機器] 上でデ ジタル表示されたりする。 多くの言語では、音声とテキストの間に強い対応関係 が存在する。 たとえば、英語では、文字や文字の集まりが話し言葉の音に (多か れ少なかれ) 対応している。

視覚障害のある人のためには、書き言葉を点字に置き換えることが可能だ。 点 字は、文字、文字のグループ、および単語全体に対応した、 隆起した点のシステ ムを使用する(点字については、第3章で詳しく説明する)。

話し言葉を素早くテキストに書き起こす必要があるなら、 速記が有効だ。法廷 やニュース・スポーツ番組のリアルタイム字幕制作では、 テキストに対応した独

自のコードを組み込んだ簡易キーボード付きのステノタイプ [速記機] を使用する。 私たちは様々なコードを使ってコミュニケーションしているが、それはある コードが別のコードよりも便利だからだ。 話し言葉のコードは紙にそのまま保存 できないので、代わりに書き言葉のコードが使われる。 暗闇の中、 離れた場所間 で静かに情報をやり取りするのは、音声や紙では不可能だ。 だから、モールス コードが便利な代替手段になる。 あるコードが、 ほかのコードにはできないよう な目的を果たすなら、 代用には意味がある。

後ほど示すように、コンピュータでも、 内部の命令はもちろん、 文字、数字、 音、音楽、写真、動画などを保存し伝達するために、 様々な種類のコードが使わ れる。 また、 人間の目、耳、口、 指の使い方をコンピュータは正確に再現できな いので、 人間由来のコードは簡単に扱えない。 コンピュータに話し方を教えるの は難しいし、 話し言葉を理解させるのはもっと難しい。

それでも、多くの進展があった。 コンピュータは、視覚 (文字や絵)、聴覚 (話し言葉、音、音楽)、 あるいはその両方 (アニメーションや映画) を含む、 人 間のコミュニケーションに用いられる多種類の情報を取り込み、 保存し、操作 し、表示することができるようになった。 これらの情報には、それぞれ独自の

第1章 親友

コードが必要になる。

15

先ほど見たモールスコードの表も、それ自体が一種のコードである。 表は、 そ れぞれの文字がドットとダッシュの組み合わせで表現されることを示している。 とはいえ、実際にドットやダッシュそのものを送ることはできない。 懐中電灯で モールスコードを送るには、 ドットとダッシュを点滅時間に対応させるのだ。

懐中電灯でモールスコードを送るには、 ドットは素早く、 ダッシュはやや長 く、懐中電灯のスイッチを点けて消す (オンオフする) 必要がある。 たとえば 「A」 を送るには、 懐中電灯を素早くオンオフし、 次にそこまでは素早くないオ ンオフを行う。そして次の文字を送る前に、 ちょっとした間隔を空ける。 ダッ シシュの長さは、ドット長さの約3倍とするのが通例だ。 信号を受ける側は、短 い点滅と長い点滅を見て、 Aが送られたことを理解する。

モールスコードのドットやダッシュの間の消えている時間はとても重要だ。 た とえばAを送るときには、 ドットとダッシュの間で約1ドット分に相当する時 間、 懐中電灯を消す必要がある。 1つの単語内の文字同士は、 ダッシュ1つ分の 長さで区切られる。 たとえば以下に示すのは 「hello」 という単語に対応するモー ルスコードで、文字と文字の間に間があることがわかる。

•

単語と単語の間はおよそダッシュ2つ分のオフ時間で区切られる。以下は、 「hi there [こんにちは]」のモールスコードだ。

1●

懐中電灯が点灯される時間および消灯される時間は決まっていない。 それらは ドットの長さに対して相対的に決まる。 ドットの長さは、 懐中電灯のスイッチを 押す速さに依存するし、 送信者が特定の文字のモールスコードを思い出す速さに も左右される。 速い送信者のダッシュと遅い送信者のドットが同じ長さになる可 能性もある。このささやかな問題は、 モールスコードの読み取りを難しくするか もしれないが、通常は1文字目あるいは2文字目を受け取った段階で、受け手 は何がドットで何がダッシュなのかがわかる。

はじめはモールスコードの定義が (ここでいう定義とは、 アルファベットの文

字とドットやダッシュの並びを対応させたもの)、 コンピュータのキーボードの レイアウトのように、 気まぐれに並んだもののように見える。しかし、よくよく 調べてみると、そうとも言い切れない。 EやTなどよく使われるアルファベッ トには、よりシンプルで短いコードが割り当てられている。 スクラブルゲームの プレイヤーやホイール・オブ・フォーチュンのファンなら、すぐに気がつくだろ う[どちらも単語あるいはフレーズ当てゲーム]。 スクラブルでは10点獲得でき、ホ イール・オブ・フォーチュンではほとんど登場しない、 Q やZなどの、あまり 一般的でない文字は、 コードが長くなっている。

実はほとんどの人がちょっとしたモールスコードを知っている。 国際的な救難 信号である SOS は、 3つのドット、 3つのダッシュ、3つのドットで表される。 SOS は何かの略語ではなく、単に覚えやすいモールスコード列というだけだ。 第二次世界大戦中、 英国放送協会 (BBC) はラジオ番組の冒頭にベートーベン の交響曲第5番の最初のフレーズ 「ジャジャジャジャーン」 を流すこと があったが、 ベートーベンはまさか自分の曲のこの部分が 「勝利」 (Victory) を 表す V(...) のモールスコードになるとは思いもしなかっただろう。

モールスコードの欠点は、 大文字と小文字の区別がつかないことだ。 しかし、 モールスコードには、文字を表すだけでなく、 5つのドットとダッシュの組み合 わせで数字を表すコードも含まれる。

1 ---- 6 2 COMMO 7 3 Comm 8 4 m 9 5 ..... 0 -

これらの数字のコードは、少なくとも文字コードよりは規則的になっている。 ほとんどのパンクチュエーション [旬読記号] は5、6、 または7個のドットと ダッシュを使用する。

16

第1章 親友

? : MOMMO = mccom O ; + Om $ comcom 1 9 ●momo COMMOM

また、ヨーロッパ言語のアクセント記号付き文字や、 特殊な用途のための略記 コードも定義されている。 SOS コードは、 そのような略記コードの1つだ。 3 文字の間に1ドット分だけ間を空けて連続送信することになっている。

友だち同士のモールスコードの送信には、 専用の懐中電灯があると便利だろ う。そうした懐中電灯には、 通常のスライド式のオンオフスイッチのほかに、 押して離すだけで点滅させられるプッシュスイッチも搭載されている。 ある程 度練習すれば、 1分間に5語から10語程度の送受信ができるようになるかもし れない。まあ、話し言葉 ( 1分間に100語程度) よりはずっと遅いが、とりあ えず十分な速度であることは確かだ。

親友と一緒にモールスコードを暗記すれば (それこそが送受信に習熟できる唯 一の方法だ)、 普段の会話の代わりに、 声に出して使うこともできる。 最大速度 を得るには、 ドットをdih [ディー] (そして文字の最後のドットをdit [ディト ] )、 ダッシュを dah [ダー] と発音してみよう。 たとえば、 V の場合は dih-dih-dihdah [ディーディーディーダー] となる。 モールスコードが書き言葉をドットと ダッシュにしたように、 音声版のコードでは2つの音 [ディーとダー] だけになる。 ここでキーワードとなるのが2だ。 2種類のまばたき、2種類の音、 そのほか

2つの異なるものなら何でも、 適切に組み合わせることにより、 あらゆる情報を 伝達できるのだ。

17



第2章

コードと組み合わせ

モールスコードは、 1837年頃、 サミュエル・フィンリーブリース・モール ス (1791-1872) によって発明された。 この人物については、 本書の後半でさら に詳しく紹介しよう。 その後、 アルフレッド・ヴェイル (1807-1859) らによっ てさらに発展し、いくつかの異なるバージョンに進化していった。 本書で紹介す る方式は、正式には国際モールスコードと呼ばれるものだ。

モールスコードの発明は、 電信の発明と密接に関係している。 電信についても 本書の後半で詳しく見ていこう。 モールスコードがコードによる符号化 [コード [化] の性質をよく表しているように、 電信はコンピュータの仕組みをよく表した ハードウエアを備えているからだ。

ほとんどの人は、 モールスコードを受信するよりも、 送信する方が簡単だと思 うだろう。 たとえモールスコードを覚えていなくても、 前章でも示したアルファ ベット順の対応表を使うだけでいいのだから。

A -M J ---- S ... B K 101 T - C momo L U D MOT E . F come G -- H **** M N O P Q -- V 100m mo W -- --- X -1 ON-O Y 1101 Z I " R

モールスコードを受信して、それを文字に変換するのは、 送信に比べてかなり 難しく、時間がかかる。 なぜなら、 コード化された特定のドットやダッシュの列 [シーケンス] に対応する文字を逆算しなければならないからだ。 ダッシュドッ トダッシュ・ダッシュを受け取ったときに、コードを記憶していなければ、 対 応表を1文字ずつ見ていって、ようやくそれがYの文字であることを発見する ことになる。

問題は、私たちの手元には次のように変換する表はあるものの

アルファベット文字 モールスコードのドットとダッシュの列

以下のように逆算できる表がないということだ。

モールスコードのドットとダッシュの列 → アルファベット文字

モールスコードを学習し始めた当初は、このような表があれば確かに便利だろ う。しかし、そうした表をどのように作ればよいのだろうか。 ドットやダッシュ には、アルファベット順に並べられるような性質はないのだ。

ということで、 アルファベット順は忘れよう。 ドットやダッシュの数で分類す るのが、よりよいコードの整理方法かもしれない。 たとえば、 ドットまたはダッ シュを1つだけ含むモールスコード列は、EとTの2文字だけを表す。

• E - T

20

第2章 コードと組み合わせ

21

ドットやダッシュをちょうど2つ組み合わせると、 I, A、N、Mの4文字を 表現できる。

.. I -o N -- A -- M

ドットやダッシュを3つ並べると、 さらに8文字を表現できる。

... S mo D U 111 K ●mo R G W W

そして最後に (数字や句読記号はここでは忘れておこう)、4つのドットとダッ シュの列を使うと、 さらに 16文字の表現が可能になる。

.... H B m V -com X F C 0 Y moo L Z ●mm Ä 1011 Q P J --- Ö $

4つの表を合わせると、 2 +4 +8 + 16 で合計30文字となり、 ラテンアル ファベットの26文字より4文字多くなる。 このため、 最後の表にあるコードの うち4つがアクセント記号付きの文字だったことに気づいたのではないだろう か。ウムラウト [ドイツ語の「"」]付きのものが3つ、セディーユ[ラテン文字の 「,」] 付きのものが一つだ。

これらの4つの表は、誰かがモールスコードを送ってきたときに重宝する。 ある文字のコードを受け取ったら、その文字が何個のドットとダッシュでできて

22

いるかわかるので、 それに適した対応表を見て調べることができる。 各表では、 ドットだけのコードが左上に、 ダッシュだけのコードが右下に置かれるように、 系統だって配置されている。

4つの表の大きさにパターンがあるのがわかるだろうか? 各表には、 その前の 表の2倍のコードが含まれているのだ。 これは当然といえる。 各表は、 前の表 のすべてのコードの後ろにドットを続けたものとダッシュを続けたもので構成さ れているからだ。

この興味深いパターンは、次のようにまとめることができる。

ドットとダッシュの数 コードの数 1 2 2 4 3 8 4 16

4つの表はそれぞれ前の表の2倍のコードを持つので、最初の表のコードが2 個なら、2番目の表は2×2個、3番目の表は2×2×2個のコードを持つこ とになる。ここで、もう1つの見せ方で示そう。

ドットとダッシュの数 コードの数 1 2 2 2×2 3 2 × 2 ×2 4 2×2×2×2

自乗していく数を扱うなら、 指数を使ってべき乗を表すことができる。 たとえ ば、 2×2×2 × 2 は、 2 (2の4乗) と書くことができる。 2、4、8、 16 はす べて2のべき乗であり、どれも2を掛けていくことで計算できる。 この結果は 次のように示すこともできる。

第2章 コードと組み合わせ

ドットとダッシュの数 コードの数 1 2' 2 22 3 23 4 24

表は、とてもシンプルになった。 コードの数は、単純に2にドットやダッシュ の数をべき乗したものとなる。

コードの数=2ドットとダッシュの数

2のべき乗はコード中に頻出し、本書では特に多い。 次章では、別の例を紹介

しよう。

モールスコードの解読をいっそう容易にするには、 次に示すような大きな樹形 図を描くとよいだろう。

H

V

C

ぐ。

23

この図は、 連続したドットとダッシュの特定の並びに対応する文字を示してい る。 特定の列をデコード [復号] するには、 左から右へ矢印をたどればよい。 た とえば、ドットダッシュドットのコードに対応する文字を知りたいとする。 左端から始めて、 まずドットを選び、 矢印に沿って右に移動してダッシュを選 び、さらにドットを選ぶ。 3つ目のドットの横に示されている文字はRだ。

考えてみれば、そもそもモールスコードを定義するためには、このような図を 作ることが必要だったのだろう。 この図を使うことで、 2つの異なる文字に同じ コードを使うという愚かなミスを防げるし、 ドットやダッシュの列を不必要に長 くせずに可能な限り多くのコードを使用できる。

ページからはみ出してしまうかもしれないが、もし望むなら、 ドットとダッ シュを5個使ったコードを作ることもできる。 ちょうど5個のドットとダッシュ の列を使うことで、 32(2×2×2 × 2 ×2、 つまり25) 個のコードが追加され る。 通常、 モールスコードで定義されている10個の数字と16個の句読記号を 表すにはこれで十分だ。 実際、 数字は、5個のドットとダッシュでコード化 [エ ンコード]されている。 しかし、5個のドットとダッシュの並びを使う他のコー ドの多くは、 句読記号ではなく、 アクセント記号付き文字を表している。

すべての句読記号を含めると、 6個のドットとダッシュに拡張しなければなら ず、そのときには 64個 (2 × 2 × 2×2×2×2、 つまり26個) のコードが追 加され、合計では 2 +4 +8 +16 +32 + 64、 つまり126文字となる。 モー ルスコードとしてはやりすぎなので、こうした長いコードの多くは未定義のまま になっている。 つまり、 「何の意味も持たないコード」 を意味する。 モールス コードを受信しているときに未定義のコードが送られてきたら、 誰かが間違えた のだと思えばいい。

なぜなら、私たちは次の小さな式を開発できるほど賢かったからだ。

コードの数=2ドットとダッシュの数

ドットやダッシュを長く並べることで、いくつのコードが得られるかは次のよ うに把握できる。

24

第2章 コードと組み合わせ 25

ドットとダッシュの数 コードの数 1 2' = 2 2 22=4 3 23=8 4 5 6 7 24 = 16 25 = 32 26=64 27 = 128 8 28 = 256 9 29=512 10 210 1024

幸いなことに、コードの数がいくつになるかを判断するために、 実際にすべて のコードを書き出す必要はない。 2を何度も何度も自乗すればいい。

モールスコードは、 ドットとダッシュの2種類だけで構成されているので、 バイナリー(文字通りの意味は「2つずつ｣ と言われる。 それは、 コインが、表 か裏のどちらかしか上にして着地しないことに似ている。 10回投げたコインは、 1024通りの表と裏の組合せ列を表すことができる。

(コインなどの) バイナリーオブジェクトや、 (モールスコードなどの) バイナ リーコードの組み合わせは、 いつでも2のべき乗で記述される。 本書では、2は とても重要な数字なのだ。



第 3 章

点字とバイナリーコード

サミュエル・モールスは、書き言葉の文字を、 伝達 できて理解できる別のコードに変換することに成功し た最初の人物ではない。 さらに、 本人よりもコード名 の方が有名になった最初の人物でもない。 その栄誉 は、サミュエル・モールスの18年後に生まれながら、 はるかに早熟な才能を開花させた盲目のフランス人青 年に与えられるべきだ。 彼の生涯はほとんど知られて いないが、その物語はとても心に響くものがある。

ルイ・ブライユは1809年、 パリから東に25 マイ ル [約40キロメートル] 離れた、フランスのクヴレ村に 生まれた。 父親は馬具職人だった。 ブライユは3歳のとき、遊んではいけない と言われていた父親の仕事場で、 先の尖った工具を誤って目に刺してしまった。 その傷が膿んでしまい、 もう一方の目にもその感染が広がり、 彼は全盲になって しまった。 当時、 このような人たちの多くは、無学のまま貧しい生活を強いられ る運命にあった。 しかし、 若いルイの知性と学習意欲はすぐに周囲の認めるとこ ろとなる。 村の神父と学校の先生の仲介で、最初は村の学校にほかの子どもたち と一緒に通い、 10歳の時にはパリの王立盲学校に入学した。

視覚障害児の教育に大きく立ちふさがったのは、読めるように工夫された教材 が存在しないことだった。 王立盲学校の設立者であるヴァランタン・アユイ (1745-1822) は、 丸みを帯びた大きな活字を使って紙にエンボス加工 [浮き出し

ullstein bild Dtl/Getty Images

加工、紙に凹凸をつける] を施し、 触って読めるシステムを発明していた。 しかし、 このやり方は扱いがとても難しく、 それで作られた本は数冊だけだった。

目が見えたアユイは、ひとつのパラダイム [物の見方] にはまり込んでいた。 彼にとって、 AはAであり、 A という文字はAのように見え (感じられ) なけ ればならないものだったのだ(もし彼が通信手段として懐中電灯を渡されたな ら、私たちが前の章で試してうまくいかないことを知った、 空中に文字を描く方 法を採用したかもしれない)。 アユイはおそらく、 エンボス文字とは全く異なる タイプの暗号が、 目の見えない人たちに適している可能性について 気づいてい なかったのだろう。

違う種類のコードのアイデアは、 意外なところからやってきた。 フランス軍の 大尉だったシャルル・バルビエは、 1815年までに、のちに 「エクリチュール・ ノクターン [夜間書法] 」 と呼ばれる記述方法を考案していた。 このシステムは、 厚紙に盛り上がったドット[点] のパターンを使ったもので、 兵士が暗闇で沈黙 しながらメモを交換するのに使われることを想定していた。 兵士たちは、千枚通 しのようなペン(スタイラス) を使って、 紙の裏を刺してドットを描くことがで きた。そうして盛り上がったドットは、 指で読み取れたのだ。

ルイ・ブライユがバルビエのシステムに触れたのは、12歳の時だった。 指で 読みやすいだけでなく、書きやすいという理由からも、ブライユは盛り上がった ドットを使うことを好んだ。 教室で紙とスタイラスを使えば、 生徒はノートを とって、何度でも読める。 ルイ・ブライユは熱心に改良を続けて、 3年後(15 歳の時) に、 現在もその基本部分が使われている独自のシステムを考え出した。 長い間、 このシステムは盲学校内だけで使われていたが、 徐々に世界へと広がっ ていった。 1835年、 結核にかかったルイ・ブライユは徐々に命を削られ、 1852 年、43歳の誕生日を迎えた直後に亡くなった。

今日では、様々な点字システムが、 視覚障害者が書き言葉を読めるように、 オーディオブックと競い合っている。 それでも、 点字は依然として重要であり、 視覚と聴覚の両方の障害を持つ人たちが文字を読む唯一の方法だ。 ここ数十年、 エレベーターや ATM [現金自動預け払い機] などに点字が多く使われ、 一般の人に も身近な存在である。

本章では、点字コードを解き明かし、 その仕組みを紹介する。 点字を実際に学

28 |

第3章 点字とバイナリーコード

29

んだり、何かを暗記したりする必要はない。 本章での演習の唯一の目的は、コー ドの本質についてさらなる洞察を得ることである。

点字では、 文字、 数字、 句読記号など、 通常の書き言葉で使われるすべての記 号が、 2×3の領域内に1つ以上の盛り上がったドットとしてコード化 [エンコー ド] されている。 これらのドットには通常、1から6までの番号が振られている。

1 2

点字のドットを紙に浮き彫りにするために、 特殊なタイプライターが開発さ が行われている。

れ、最近ではコンピュータを使ったエンボス加工本書の数ページ分を点字でエンボス加工するのはとてもコストがかかるので、 ここでは印刷物で点字を表示するときによく使う表記法を採用しよう。 この表記 法では、 領域内の6個のドットがすべて表示されている。 大きなドットは、 紙 が盛り上がっている凸部分を示し、 小さなドットは、 領域の平らな部分を示して いる。たとえば、 次のような点字表現の場合、 ドット1、3、5が盛り上がって いて、 ドット2、4、6は平らになっている。

ここで興味深いのは、 ドットがバイナリー [2値] であることだ。 特定の位置の ドットは、盛り上がっているか、 平らか、 の2種類である。 つまり、 モールス コードやバイナリーの組み合わせで学んだことを、 点字にも応用できる。 ドット は6つあり、それぞれのドットは盛り上がっているか、 あるいは平らであるこ とがわかっているので、 6つのドットの組み合わせの総数は、2×2×2×2× 2 x 2 = 2、 つまり64個となる。

このように、 点字のシステムは64個のユニークな [一意の] コードを表現でき る。それらを次ページに示す。

30

::: :: * ::. ::

点字においては、 64個すべてを使う必要はないが、6つのドットのパターン では 64個が上限になることは間違いない。 点字コードをひも解くために、 基本となる小文字のアルファベットを見てみよう。

:. :: :: a b c d e f g h 1 k 1 m n . ::: 0 u V x y Z P 「 S

たとえば、 「you and me」 というフレーズを点字にすると、次のようになる。

単語と単語の間には大きなスペース(ドットのない領域、 空白) があることに 注意しよう。 以上がルイ・ブライユの考案した点字の基本で、少なくともラテンアルファ

第3章 点字とバイナリーコード

ベットの文字には適用されている。 ルイ・ブライユはまた、フランス語でよく使 われるアクセント記号のついた文字のコードも考案した。 なお、 古典フランス語 では使われないwのコードがないことに注意してほしい (いずれ出てくるので ご心配なく)。この時点では、表現できる64個のコードのうち、25個しか使っ ていない。

よく見ると、 小文字 25 文字の点字コードに規則性のあることがわかる。 1行 目 (aからjまで)は、領域の上方4か所 (1、2、4、5)のみを使用している。 2行目 (kからtまで) は、 ドット3が盛り上がっている以外は、 1行目と同じ だ。 3行目 (uからzまで) は、 ドット3とドット6が盛り上がっている以外は、 1行目と同じである。

ルイ・ブライユは、もともと手でドットをパンチすることを想定してシステム を設計した。 手動だと精密性に欠けるので、 曖昧さを少なくするために小文字 25 文字を巧みに定義したのだ。 たとえば、 64個ある点字のうち、1つだけ点が 浮き出ているものは6個ある。 しかし、そのうちの1つだけが小文字aの表現に 使われる。 また 64個のコードのうち縦に隣接する2つだけのドットを持つのは 4個だけだが、ここでもその1つだけが小文字b に使用される。 隣り合う2つだ けの水平ドットのコードは3個あるが、 cのための1個しか使われていない。

ルイ・ブライユがこのシステムで定義したのは、ページ上で多少ずれても同じ ものを意味するユニークな形のコレクションなのだ。 aは盛り上がった1つの ドット、 bは縦に隣接する2つのドット、 cは水平に隣接する2つのドット、と いう具合である。

コードにエラー [誤り]の入り込む余地は多々ある。 コードを書くとき (点字 の学習者が紙にドットを打つなど) に発生するエラーをエンコーディング [符号 [化] エラーと呼び、 逆にコードを読み取る際に発生するエラーをデコーディング [復号] エラーと呼ぶ。 また、 点字が記載されたページが何らかの形で破損してい る場合など、 トランスミッション [伝送] エラーが発生することもある。

より高度なコードは、様々なタイプのエラー訂正の仕組みを内蔵していること が多い。 その意味で、ルイ・ブライユが最初に定義した点字は、 洗練されたコー ディングシステムといえる。 ドットの打ち方 (パンチの仕方) や読み取り方に多 少の不正確さがあっても許容できるように冗長性を持たせているからだ。

ルイ・ブライユの時代から点字コードは、 数学や音楽を表記するシステムな

31

ど、様々な形で拡張されてきた。 現在、出版されている英文テキストで最も多く 使われているのは、グレード2点字と呼ばれる方式である。 グレード2点字は、 紙の使用量を減らし、読むスピードを上げるために、 短縮形が多く使われる。 た とえば、 文字コードが単独で現れた場合には、 よく使われる一般的な単語を表し ている。 次の3行は、そうした単語のコードだ。

8 .. :: :: :: :: (なし) but can do every from go have (なし) just *** " knowledge like more not " .. .. ::: (なし) people quite rather 00 so that us very it you as and for of the with

したがって、「you and me」 というフレーズは、グレード2点字で書くと以下 になる。

ここまでに 31 個のコードを紹介した。 盛り上がったドットが全くない、単語 間のスペース [空白]のコード1個と、文字や単語を表す3列× 10 コードの30 個、 である。 理論上で使用可能な64個のコードには、まだ数が足りない。 グレー ド2点字はどのコードも無駄にしていないので、それをこれから見ていこう。

まず、 aからjまでの文字コードは、 ドット6を盛り上げて別のコードとして 使用できる。 これらは、主に単語内の文字の短縮形として使われ、 w や別の単 語の短縮形も含まれる。

... ch gh sh th wh ed cr ou ow W

(またはwill)

32

第3章 点字とバイナリーコード

33

たとえば、 「about」 は、 グレード2点字では以下になる。

次の文字コードでは、ルイ・ブライユの原型にはない、 潜在的な曖昧さが登場 する。 aからjまでの文字に対応するコードを、 ドット2、3、5、6のみを使用 する形に下にずらすことで効果的に使うのだ。 これらのコードは、文脈に応じ て、いくつかの句読記号あるいは短縮形を表す。

.. ea bb CC dis en to gg his in was : i ()

これらのコードの最初の4つはコンマ(,)、 セミコロン(;)、 コロン(:)、 ピリオド (.)を表す。 左括弧と右括弧には同じコードが使われるが、引用開始 (*)と引用終了 (") には2つの異なるコードが使われることに注意しよう。 こ れらのコードは、aからjまでの文字と間違われる可能性があるため、 ほかの文 字に囲まれた大きな文脈でしか意味をなさない。

ここまでで51個のコードを見てきた。 次の6つのコードは、まだ出てきていな い組み合わせでドット3、4、5、6を使い、 短縮形あるいは句読記号を表現する。

st ing ble # ar com

「ble」 を表すコードはとても重要である。 それが単語の一部ではない場合に は、その後に続くコードは数字として解釈すべきことを意味しているからだ。 数 字コードは、 アルファベットのaからjまでと同じものが使われる。

3 5 6 7 8 9 0

したがって、次のコード列は数字の256を意味している。

34

ここまできちんと数えていた人なら、 64個まではあと7個のコードが必要だ とわかっているだろう。 それを次に示そう。

1つ目(ドット4が盛り上がったもの) はアクセント指示コードとして使用さ れる。そのほかは、いくつかの短縮形の接頭辞として使われ、さらにほかの目的 にも使われる。 ドット4とドット6が盛り上がっていると(この列の5番目の コード)、 文脈に応じて数字の小数点または強調表示となる。 ドット5とドット 6が盛り上がっているとき (6番目のコード) は、 数字開始コードと対をなす文 字開始コードとなる。

最後に (大文字をどのように表記するのか気になる人のために)、 ドット6が 盛り上がった大文字指示コードが用意されている。 このコードは、 そのあとに続 く文字が大文字であることを示す。 たとえば、このシステムの発明者の名前 (Louis Braille) は次のように書くことができる。

この列は、 大文字指示コードから始まり、 その後にI、 短縮形の ou iとs、 スペース、もう1つの大文字指示コード、 b, r、a、 i、 l、 I, e と続いている (実 用上、 発音しない最後の2文字を省いたり、 「brl」 と表記することでさらに省略 されることもある)。

まとめると、 6つのバイナリー要素 (ドット) から64個のコードが得られ、 それ以上は存在しないことを確認した。 このように、 64個のコードの多くは、 文脈によって二重の役割を担っている。 特に注目すべきは、 数字開始コードと、 それを元に戻す文字開始コードだ。 これらのコードはあとに続くコードの意味 を文字から数字、数字から文字へと変化させる。 このようなコードは、しばし ば優先コード、 またはシフトコードと呼ばれる。 シフトコードが現れると、 シフ トが取り消されるまでそれ以降のすべてのコードの意味が変わってしまうのだ。

シフトコードは、パソコンのキーボードのShift [シフト] キーを押し続けるの

第3章 点字とバイナリーコード

35

と似ている。 昔のタイプライターでは、大文字を打つためにシフトキーを押して 機械的にシフトして [切り替えて] いたことから、このような名前がついた。

点字の大文字指示コードは、 続く文字だけを大文字にすることを意味する。 このようなコードはエスケープコードと呼ばれる。 エスケープコードは、 通常の コードの解釈から 「エスケープ [脱出]」 して、 別の解釈を指示する。 書き言葉を バイナリーコードで表現するときには一般に、シフトコードやエスケープコード を使う。 その際、 それらのコードの前がどのようなコードなのかを知らないと、 続くコードは単独では読み取れないため、 解釈が困難になってしまう。

1855年には早くも、 点字を推進する一部の人たちが、この点字コードの拡張 に取りかかっていた。 2つのドットをもう1行加えるというものだ。 この8ドッ ト点字は、 音楽、速記、 日本の漢字など、 特別な用途に使われる。 ユニークな コードの数が2個、 つまり 256個に増えるので、シフトコードやエスケープ コードに悩まされることなく、 小文字、 大文字、数字、 句読記号をすべてユニー クなコードにできるため、 いくつかのコンピュータアプリケーションにとって便 利なものとなっている



第4章

懐中電灯の解剖学

懐中電灯は様々な場面で活躍する。 布団の中で本を読んだり、コード化した メッセージを送ったりという使い方は、 そのわかりやすい例にすぎない。 そして 普通の家庭用懐中電灯は、 どこにでもある 「電気」 を教育目的で紹介するときに も、中心的な役割を果たす。

電気は驚くべき現象であり、 その仕組みを知っているように見える人たちでさ え、 実際は謎を残したまま、 便利に使っている。 ただ幸いにも、コンピュータ内 部で電気がどのように使われているかを理解するには、ほんのわずかな基本概念 を知るだけでよい。

懐中電灯は、多くの一般家庭にある単純な電化製品だ。 普通の懐中電灯を分解 してみると、1本以上の電池、電球、スイッチ、いくつかの金属部品、 それらす べてをまとめるケースで構成されているのがわかる。

最近では発光ダイオード (LED) を使う懐中電灯が主流だが、 昔ながらの電 球の利点は、ガラス球の内部が見えることだ。

меня

これが白熱電球と呼ばれているものだ。 白熱電球は、アメリカではトーマス・

エジソンが発明したと考えられているが、 イギリスではジョセフ・スワンが発明 したと信じられている。 実際には、 エジソンまたはスワンが関与する前に、 ほか の多くの科学者や発明家が重要な進歩を成し遂げていたのだ。

電球内部にはタングステンでできたフィラメントがあり、 電気を流すと光る。 電球内は不活性ガスで満たされ、 タングステンが熱くなっても燃え尽きないよう になっている。 フィラメントの両端は細いワイヤー [電線] に接続され、その細 い電線は電球の管状の基部と底部の先端に接続されている。

懐中電灯から電池と電球だけを取り出せば、 単純な懐中電灯を自作できる。 た だし、絶縁体で覆われた短い電線 (両端の絶縁体は剝がれているもの)と、それ らすべてを支えるのに十分な数の手も必要になる。

JA

図の右側、 離れている2本の電線の端に注目しよう。 これが、 私たちのスイッ チだ。 電池が正常で、電球が切れていなければ、2本の電線の端をくっつけるこ とで、電球が点灯する。

38

第4章 懐中電灯の解剖学

本書では、 電線に電気が流れ、電球が点灯していることを赤色で表現する。 ここで作ったのは簡単な電気回路だが、 最初に気づくのは、 回路は円環状とい うことだ。 電池 電線→電球→スイッチ→電池という経路がつながっているとき だけ、 電球は点灯する。 この回路がどこかで切断されると、 電球は消灯する。 こ の過程を制御するのがスイッチの目的である。

円環状の電気回路は、 何かが回路内を巡っていることを想像させる。 おそらく パイプ内を水が流れるような感じなのだろう。 この「水とパイプ」という比喩は 電気の仕組みを説明するときによく使われるが、 どんな比喩も最後には必ず破綻 する。 電気は他に類を見ないものであり、 私たちは真正面から電気に向き合わな ければならない。

電気の働きを理解する入口の1つに、電気を電子の動きとして捉える電子論 がある。

よく知られているように、 (通常) 私たちが見たり感じたりできる物質はすべ て、原子という非常に小さなものからできている。 それぞれの原子は、中性子、 陽子、 電子という3種類の粒子で構成されている。 原子を小さな太陽系に見立 てて まるで太陽の周りを惑星が回るかように、 中性子と陽子からなる原子核の 周りを電子が回っていると表現することがある。 しかし、 これは時代遅れのモデ ルだ。

39

原子に含まれる電子の数は通常、 陽子の数と同じである。 しかし、 ある状況下 では、電子が原子から外れてしまうことがある。 電気はこうして起こる。

電子(electron)と電気(electricity)はともに古代ギリシャ語の nÀEKT pov (elektron) に由来しており、 これは不思議なことにギリシャ語の「琥珀」 (木の樹液がガラス状に固まったもの) を意味する言葉だ。 古代ギリシャ人が琥 珀を羊毛でこすり、 今でいう静電気を発生させる実験を行ったことに由来する。 琥珀に羊毛をこすりつけると、 羊毛が琥珀の電子を奪う。 その結果、 羊毛には陽 子より電子が多くなり、 琥珀では陽子より電子が少なくなる。 もっと現代的な実 験では、カーペットが靴底の電子を奪う現象を利用できる。

陽子や電子には電荷と呼ばれる性質がある。 陽子はプラス (+) 電荷、電子は マイナス(-) 電荷を持つといわれるが、これらの記号は算術的な意味でのプラ スとマイナスではない。 陽子にはあって電子にはないものがあるという意味では ないのだ。 +とーは、単に陽子と電子が反対の性質を持つことを示す記号であ る。この反対の性質は、 陽子と電子の関わり方にも表れている。

陽子と電子は、 同じ数だけ一緒に存在しているときが、 最も平和で安定してい る。 陽子と電子の数のバランスが崩れると、それら自体が元に戻ろうとする。 カーペットが靴の電子を奪ったあと、 あなたが何かに触れてピリッと火花を感じ ることで、バランスが回復しているのだ。 静電気の火花は、 電子の移動により起 !きる。 電子がカーペットから体を通って靴に戻るという、 かなり遠回りするルー トを移動することで起きている。

静電気は、 ドアノブに指が触れたときに発生する小さな火花だけにとどまらな い。 嵐になると、雲の底には電子がたまり、 雲の上からは電子が失われて、やが て落雷によってその崩れたバランスが元に戻る。 雷とは、たくさんの電子がある 場所から別の場所へ、 非常に速く移動することだ。

懐中電灯の回路の電気は、 火花や稲妻よりもずっと扱いやすい。 電子がここか らあちらへと跳ね回っているわけではないので、 光は安定して放たれ続ける。 回 路内のある原子が近くの別の原子に電子を奪われた場合、 その原子は隣の原子か ら別の電子を奪い、 その隣の原子はさらに隣の原子から電子を奪い······· といった 具合に、 電子は次々に奪われ続ける。 回路内の電気とは、原子から原子への電子 の移動なのだ。

これは自発的には発生しない。 適当に何でも配線して、 電気が流れることを期

40

第4章 懐中電灯の解剖学

待しても無駄だ。 回路を巡る電子の動きを引き起こすものが必要なのだ。 単純な 懐中電灯の図を振り返ってみよう。 電気の動きを引き起こすのは、 電線でもなく 電球でもなく、 おそらく電池だと考えてよいだろう。

懐中電灯に使われる電池は通常円筒形で、サイズによって単1、 単2、単3、 単4と呼ばれている [米国ではD、C、 AA、 AAA と呼ばれる]。 電池の平らな端には マイナス記号 (-) が、 もう一方の端にはプラス記号 (+) が書かれた小さな突 起がある。

電池は、化学反応を使って電気を発生させる。 電池内の化学物質は、反応を起 こすことによって、 電池のマイナス印のある側 (マイナス端子、 または負極[ア ノード]) に余剰の電子を生み出す。 また、 電池の反対側 (プラス端子、 または正 極 [カソード])には電子を要求する物質が選ばれる。 このようにして、化学エネ ルギーが電気エネルギーに変換される。

懐中電灯に使われている電池は、 約1.5ボルトの電気を発生する。 これが何を 意味するかは、後ほど説明しよう。

電池のマイナス端子から余剰電子を取り出し、 プラス端子に戻す方法がなけれ ば、 化学反応は進行しない。 2つの端子をつなぐ電気回路を作ることで進行する ようになる。 電子は次の回路を反時計回りに回る。

電池に含まれる化学物質からの電子と銅線中の電子は自由に混ざり合う。これ

41

はすべての電子はどこにあろうとも全く同じという単純な事実に基いている。 銅 中の電子とほかの電子を区別するものは何もない。

2個の電池が同じ向きであることに注意してほしい。 下の電池のプラス端子 は、上の電池のマイナス端子から電子を受け取る。 まるで、 2個の電池が合体し て、片方がプラス端子、 もう片方がマイナス端子の大きな電池になったような感 じだ。 組み合わせた電池の電圧は、 1.5ボルトではなく3ボルトになる。 片方の電池を逆向きにつなぐと、 回路は動かなくなる。

電池のプラス端子2つはどちらも化学反応のために電子を必要としているが、 互いにくっついているのでここに電子はこない。 2個の電池のプラス側同士が接 続されている場合には、これらのマイナス側も接続されている必要がある。

42

第4章 懐中電灯の解剖学

この回路は動作する。 並んだ電池は先ほど見たような直列 [シリーズ] ではな く、並列 [パラレル] に接続されているという。 2個の電池を合わせた電圧は、 そ れぞれの電池の電圧と同じ 1.5 ボルトになる。 電球は点灯するものの、 2個の電 池を直列に接続したときほどには明るくない。 しかし、 電池は2倍長持ちする。

私たちは普段、 電池は回路に電気を供給するものと考えがちだ。 しかし、回路 が電池の化学反応を引き起こすと考えることもできる。 回路は、電池のマイナス 端子から電子を取り出し、 プラス端子へと運ぶ。 電池内部の反応は化学物質がな

くなるまで進むので、 その時点で電池を適切に廃棄するか、 充電することになる。 電子は電池のマイナス端子からプラス端子へ、 電線と電球の中を通って流れ る。 しかし、 電線はなぜ必要なのだろう? 電気は空中を流れないのだろうか? ま あ、答えはイエスでもありノーである。 そう、 電気は空気 (特に湿った空気)の 中を流れる。 そうでなければ、 雷を見ることはないだろう。 しかし、 電気は空気 の中をなかなか流れようとはしないのだ。

世の中には、圧倒的に電気を通す物質がある。 物資の元素が電気を運ぶ能力 は、その内部構造による。 電子は原子核の周りを何層にも取り囲んでおり、 これ をシェル [殻] という。 外殻に電子が1個しかない原子は、 電気を流すのに必要 な電子を簡単に手放してしまう。こうした物質は電気を通す性質 (伝導性) があ るため、 導体と呼ばれる。 優れた導体には、銅、 銀、 金などがある。 これら3 つの元素が周期表の同じ列にあるのは偶然ではない。 銅は電線を作るための最も 一般的な物質である。

伝導性の反対は抵抗性である。 電気を通しにくい物質が存在し、それらは抵抗 体と呼ばれる。抵抗性が非常に高く、 電気をほとんど通さない物質は絶縁体と呼 ばれる。 ゴムやプラスチックは絶縁性が高いので、 電線の被覆によく使われる。 布や木も、乾燥した空気同様、優れた絶縁体だ。 しかし、電圧が十分に高けれ ば、 どんなものでも電気を通す。

はとても抵抗性が少ないものの、 それでもある程度の抵抗性はある。 電線は 長くなればなるほど抵抗値が高くなる。 もし、 何キロメートルもある電線で懐中 電灯を配線したら、 電線の抵抗値が高くなり、 懐中電灯は動作しないだろう。

電線は太いほど抵抗値が小さくなる。 これは、い。 太い電線の中を 「埋め尽くす」ためには、より多くの電気が必要だと想像し てしまうかもしれない。 しかし、実際には、電線が太ければ、 より多くの電子が

やや直感に反するかもしれな

43

電線内を移動できるようになる。

電圧はすでに登場しているものの、 その定義はまだだった。 電池の電圧が1.5 ボルトというのはどういう意味なのだろう? 「電圧」 (ボルテージ) は、1800年 に初めて電池を発明したアレッサンドロ・ボルタ伯爵 (1745-1827) にちなんで 名づけられたもので、 電気の基礎概念の中でも難しいものの1つだ。 電圧とは、 仕事をするポテンシャル [潜在能力] を表している。 電圧は、 電池に何か接続さ れているかどうかに関係なく存在する。

レンガを考えてみよう。 床に置かれているレンガには、ほとんどポテンシャル がない。 床から4フィート [約1.5メートル] 上に手で持っているとき、 レンガは 床に置かれているときよりも、もっと高いポテンシャルを持っていることにな る。このポテンシャルを実感するには、 レンガを落としてみればよい。 高いビル の屋上で手に持っているレンガは、もっと大きなポテンシャルを秘めている。 3 つのケースのいずれも、 レンガは手に持たれたまま (あるいは置かれたまま) で 何もしていないのに、 ポテンシャルは異なるのだ。

電気でもっと簡単な概念は、電流である。 電流は、 実際に回路を跳び回ってい る電子の数に関係する。 電流の単位がアンペアだ。 これはアンドレ・マリー・ア ンペール (1775-1836) にちなんで名づけられた。 英語では 「10アンプヒュー 「ズ」 のように単にアンプと呼ばれることも多い。 1アンペアの電流を流すには、 1秒間に600 京個以上の電子が通過する必要がある。 これは6の後に0が18個 続く値だ。

ここで役立つのが、 水とパイプのアナロジーである。 電流はパイプを流れる水 の量に、そして電圧は水圧に似ている。 抵抗性はパイプの細さに似ていて、 細い ほど抵抗性が大きくなる。こうして、 水圧が高ければ高いほど、 パイプの中を流 れる水の量は増え、パイプが細ければ細いほど、 流れる水の量は少なくなる。 パ イプを流れる水の量 (電流) は、 水圧 (電圧) に正比例し、 パイプの細さ (抵 抗) に反比例する。

電気の世界では、 電圧と抵抗がわかれば、 回路にどれだけの電流が流れるかを 計算できる。抵抗とは、電子の流れを妨げる物質の性質のことで、有名なオーム の法則を提唱したゲオルク ジーモン・オーム (1789-1854) の名をとって、 オームという単位で測定される。この法則は次のようなものだ。

44

第4章 懐中電灯の解剖学

I = E/R

ここでは、 Ⅰは電流 (アンペア)、 Eは電圧 (electromotive force [起電] の略Rは抵抗を表している。

)、

45

たとえば、 何も接続されていない電池を考えてみよう。

電圧Eは1.5である。 それは、 仕事をするためのポテンシャルだ。 しかし、 プラスとマイナスの端子は空気だけでつながっているので、間の抵抗 (R) の値 はとてつもなく大きくなり、電流 (1) は 1.5ボルトをその大きな数字で割った 値になる。 つまり、電流はほぼゼロになる。

では、プラスとマイナスの端子を短い銅線で結んでみよう (ここからは、 電線 の被覆を描かないことにする)。

これは短絡 (ショート) といわれている状態だ。 電圧は変わらず 1.5だが、抵 抗値はとてつもなく低くなる。 電流は1.5ボルトをごく小さな数字で割ったもの になる。つまり、電流がとてつもなく大きくなるのだ。 電線には本当にたくさん の電子が流れるだろう。 実際には、電池の物理的な大きさにより、 流れる電流は 制限される。 電池は大電流を供給することはできず、 電圧はおそらく1.5ボルト を下回るだろう。 電池が大きければ、 電気エネルギーが熱に変換されるため、 電 線が熱くなる。 電線が非常に高温になると、 実際に光り、 溶けてしまうことさえ あるだろう。

多くの回路は、この両極端のシナリオの間にある。 これは次のように示せる。

ギザギザの線は、電気技師には抵抗器の記号としておなじみである。 回路の抵 抗値が、それほど低くもなければ高くもないことを意味している。 もし電線の抵抗値が低いと、 電線が熱くなって光り出すことがある。 それこそ が白熱電球の仕組みだ。

懐中電灯の白熱電球によく使われているフィラメントの抵抗値は4オーム程 度である。 懐中電灯に端と端をつないだ2個の電池を使う場合、 流れる電流は3 ボルト÷4オームで、 0.75 アンペアとなる、 これは750ミリアンペアと表すこ ともできる。 つまり、1秒間に450京個以上の電子が電球内を流れることにな る。そして、フィラメントの持つ抵抗によって、 電気エネルギーが光と熱に変換 されるのだ。

もう1つ、 よく使われている電気の測定単位にワットがある、 これは蒸気機 関で有名なジェームズ・ワット (1736-1819) にちなんで名づけられた。 ワット は電力 (P) を表す値であり、 次の式で計算される。

P = EXI

3ボルトで0.75アンペアが流れる懐中電灯の場合、 2.25 ワットを消費する電 球を使っていることがわかる。 今ではLEDが白熱電球に取って代わりつつある が、これはLEDの方が少ない熱と少ないワット数で同量の光を照射できるため だ。電気代はワット数で決まるので、 電球のワット数を下げれば、 節約になるし 環境にも優しい。

ここまでで電池、電線、 電球といった懐中電灯のすべてが分析できたように思 える。しかしながら、 実は一番大切なことを忘れてしまっている! そう、スイッチだ。 スイッチは、 回路に電気が流れるか否かを制御するもの

46

第4章 懐中電灯の解剖学

47

だ。 スイッチが電気を流している状態をオン、 または閉と呼ぶ。 反対にスイッチ がオフ (開)のときは、 電気は流れない。 (スイッチの閉と開の使い方は、ドア の場合と逆になることに注意しよう。 閉じたドアは何も通さないが、 閉じたス イッチは電気を流す)。

スイッチは閉か、 開かのどちらかだ。 つまり、 電流が流れるか流れないかのい ずれかとなる。 それは電球が点くか点かないかということだ。

モールスやブライユが発明したバイナリーコードのように、このシンプルな懐 中電灯もオンかオフのどちらかになる。 中間の状態はない。 このバイナリーコー ドと単純な電気回路の類似点は、以降の章でとても役立つだろう。



第 5 章

角を曲がったやり取り

12歳のある日。 悲しいことに、 親友とその家族が別の町に引っ越してしまっ た。 たまに電子メールやメッセージを送ってはみるものの、 深夜に懐中電灯を点 滅させながらモールスコードでやり取りするようなスリルはない。 いつしか、隣 の家に住んでいる二番目の友だちが親友となる。 さあ、 新しい親友にモールス コードを教えて、 深夜に懐中電灯を点滅させるときが再びやってきた!

だが問題は、新しい親友の寝室の窓が、 自分の寝室の窓に面していないこと だ。 家は横並びで、 寝室の窓は同じ方向を向いている。 外壁にいくつか鏡を設置 しない限り、 日没後のコミュニケーションに懐中電灯は使えない。 いや、本当にそうだろうか?

おそらくこの頃には、 電気について何かしら学んでいるはずだ。 そこで、電 池、電球、 スイッチ、 電線を使って、 自前の懐中電灯を作ることにした。 最初の 試みとして、自分の寝室で電池とスイッチを配線しよう。 それらにつながった2 本の電線を窓から出し、 フェンス越しに親友の寝室に入れ、 そこで電球につなげ るのだ。

<W>

あなたの家

親友の家

ここからは記号を用いて回路を描いていこう。 図では電池を1つだけ示して いるが、 実際には2つかもしれない。 この図や今後の図では、次のように、 オ フ (開)のスイッチを示す。

そして、以下がオン (閉) のスイッチだ。

本章の懐中電灯は、 部品間をつなぐ電線が少し長くなっただけで、 前章で示し た回路と同様に動作する。 自分の手元のスイッチを閉じると、 親友の家にある電 球が点灯するわけだ。

あなたの家

<W>

親友の家

さあ、モールスコードを使ってメッセージを送れるようになった。 懐中電灯が使えるようになったので、もう1つ懐中電灯を使って、 親友がメッ

50

第5章 角を曲がったやり取り

セージを送れるようにしてみよう。

www <W>

あなたの家

親友の家

おめでとう! 双方向の電信システムができた。 これらは完全に独立した、 2つ の同一回路であることがわかるだろう。 理論的には、 親友がメッセージを送って いるときでも、こちらから同時にメッセージが送れるのだ。 ただし、 メッセージ を読みつつ別のメッセージを送るのは、 脳にとって難しいかもしれない。 あなたなら、 2軒の家にまたがった電線の数をもっと少なくできることに気づ くかもしれない。 次の構成で配線すれば、4本の電線のうち1本を省ける。

あなたの家 <W> 親友の家

本書では、 電線同士の接続部分を小さな黒丸の記号で表現する。 上の図では、 自分の家の電池の下と、 親友の家の電球の下に、そうした接続がある。

ここでは、2つの電池のマイナス端子同士がつながっていることに注意してほ しい。「電池→スイッチ→電球→電池」という2つの循環回路は、つながってい ても独立して動作する。

2つの回路の接続部分はコモン [共有部] と呼ばれる。 この回路では、2つの電 線接続点の間、つまり左側の電球と電池が接続されている黒丸から右側の電球と 電池が接続されている黒丸までの部分がコモンだ。

51

もっとよく見て、何もおかしなことは起きていないことを確かめよう。 まず、 自分側のスイッチを閉じると、 親友の家の電球が点灯する。 赤い線は、回路内の 流れる電気を示している。

www www

あなたの家

親友の家

回路のほかの部分には電気は流れない。 なぜなら電子が循環しない、言い換え れば回路にならないからだ。

自分は送信せずに親友が送信するときには、 親友の家のスイッチが自分の家の 電球を制御している。 ここでも、 赤い線は回路内の電気の流れを示している。

<W>

あなたの家

親友の家

自分と親友が同時に送信するときには、 両方のスイッチが同時に開いていた り、片方のスイッチが閉じていてもう片方が開いていたり、 両方のスイッチが同 時に閉じていたりする。 両方のスイッチを閉じたときには、 回路内の電気の流れ は次のようになる。

52

第5章 角を曲がったやり取り

www

www

あなたの家

親友の家

面白いことに、両方の電球が点灯しているとき、 回路のコモンには電流が流れ ない。

コモンを使って2つに分かれた回路を1つにまとめることで、 2軒間の電気接 続を4線から3線に減らし、 電線代を 25% 節約することができた。

もし、非常に長い距離を配線しなければならないとしたら、もう1本配線を 省いて、 電線代をさらに節約したくなるかもしれない。 残念ながら、 1.5ボルト の単一電池と小さな電球では、実現が不可能だ。 しかし、 100 ボルトの電池と もっとずっと大きな電球を使えば、実現できる。

その理由はこうだ。 一度、 回路のコモンを決めてしまったら、 その部分に電線 を使う必要はない。 電線を 「別のもの」 に置き換えられる。 ここで 「別のもの」 として使えるのは、 金属、 岩石、 水、 有機物 (そのほとんどは死んでいる)から なる直径約1万2700キロメートルの巨大な球体だ。 この巨大な球体は、 私たち には 「地球」として知られている。

前章では、優れた導体として銀や銅、 金をあげたが、 砂利や落ち葉の話はしな かった。 実のところ、地球はそれほど優れた導体ではない。 まあ、 一部の土 (た とえば湿った土) はほかのもの (たとえば乾いた砂) よりも優れているといった 違いがあるくらいだ。 しかし、導体で学んだことに 「大きければ大きいほどい 「い」がある。 極太の電線は、 極細の電線よりもはるかに電流の流れがよい。これ こそ、地球が優れているところだ。 言うまでもなく、本当に大きいからである。

地球を導体として使うには、 トマトの苗の隣の地面に、か細い電線を刺すだけ ではダメだ。 地球、つまり大地と接触面積が大きいもの、 具体的には表面積の大 きい導体を使う必要がある。 よい解決策の1つは、長さ8フィート [約244セン [チメートル] 以上、直径 1/2インチ [約1.27センチメートル] 以上の銅製の棒を使う

53

54

ことだ。これにより、 150平方インチ [約970平方センチメートル] が大地と接す る。銅製の棒をハンマーで地面に打ち込んで、そこに電線をつなげばよい。 ある いは、屋内の水道管が銅製で屋外の地面から続いている場合は、その管に電線を 接続してもいい。

地面と電気的に接触している部分を、 イギリスではアース、 アメリカではグラ ンドと呼ぶ。 グランドという言葉は、 ここまでコモンと呼んできた部分の回路を 指す言葉としても使われることが多いので、混乱を招きがちだ。 本章では、特に 断りがない限り、 グランドとは地面との物理的な接触点を指すものとする。 電気回路を描くときは、 次の記号でグランドを表現する。

電気技師がこの記号を使うのは、地中に埋まっている 8フィートの銅柱を描 くのに時間を使いたくないからだ。 また、 グランドに接続された回路は、「接地 されている」 または 「接地済み」 といわれる。

では、グランドの働きを見てみよう。 本章の冒頭では、次のような一方通行の 回路を紹介した。

あなたの家

<W>

親友の家

高電圧の電池や電球を使う場合には、 自分の家と親友の家の間は、 地球を配線 の1つとして使えるので、電線は1本で済む。

第5章 角を曲がったやり取り

wwwwww

あなたの家

親友の家

スイッチを入れると、 電流は次のように流れる。

あなたの家

親友の家

電子は親友の家のグランドから出て、 電球と電線を通り、 自分の家のスイッチ を経て、 電池のプラス端子に入ってくる。 電池のマイナス端子から出た電子は、 地中へと向かう。

何なら、自分の家の裏庭に埋めた 8フィートの銅柱から電子が地中に飛び出 し、地中を通って親友の家の裏庭に埋めた 8フィートの銅柱まで急いで移る様 子を思い浮かべてもよいだろう。 しかし、 地球が世界中の何千もの電気回路に対 して同様の機能を果たしていることを考えると、 「電子はどうやって行き先を決 めているのか」と疑問に思うかもしれない。 まあ、 明らかに電子は行き先を知ら ない。 もっと別の形で地球を思い浮かべた方がよさそうだ。

確かに地球は巨大な導体だが、 電子の供給源であると同時に電子の貯蔵庫でも あると考えられる。 地球と電子の関係は、海と水滴の関係と同じだ。 地球は事実 上、 無限の電子の源であり、 巨大な電子の海でもある。

しかし、地球にはある程度の大きな抵抗がある。 そのため、 1.5 ボルトの単一 電池と懐中電灯の電球を使うときには、配線を減らすためのグランドとして地球

55

は使えない。 低電圧の電池にとって、地球の抵抗が大きすぎるからだ。 前の2つの図には、マイナス端子がグランドにつながった電池が含まれるこ とにお気づきだろう。

ここからはグランドに接続された電池の絵を描くのはやめる。 その代わり、 大 文字のV を使おう。 V はボルテージ [電圧] を意味する。 Vから伸びる電線は、 電池のプラス端子に接続された電線と同じだ (電池のマイナス端子はグランドに 接続されているものとする)。 こうすると、 一方通行の電球電信は、次のように 描ける。

V

あなたの家

親友の家

Vはボルテージを意味するが、 ある意味では、 バキューム [真空] を表すと考 えることもできる。 その場合、 Vを電子を吸い込む掃除機と考え、 グランドを 電子の海と考えればよい。 電子掃除機は、 グランドからの電子を回路に引き込 み、 その過程で電球を点灯させるといった仕事をする。

グランドは、ゼロ電位点とも呼ばれることがある。 これは、電圧がないことを 意味する。 電圧とは、前述したように、 仕事をするための潜在エネルギーだ。 空 中に吊り下げられたレンガが、 落下するための潜在的なエネルギーを持っている

56

第5章 角を曲がったやり取り

ことと同じである。 ゼロ電位は、地面に置かれたレンガのようなもので、そこか ら落ちたりはしない。

第4章でまず気づいたのは、 回路は円環状だということだった。 新しい回路 は円環状にまるで見えないかもしれないが、 それでも立派な回路だ。 Vを、マ イナス端子がグランドに接続された電池に置き換えて、グランド記号が出てきた 場所すべてをつなぐ電線を描けばよい。 そうすれば、 本章の冒頭で描いたのと同 じ図ができあがる。

そういうわけで、 銅柱 (または水道管) を2本用意すれば、 自分の家と親友 の家の間を、 フェンス越しの2本の電線で結ぶだけで、 双方向のモールスコー ドシステムができあがる。

www

<W>

あなたの家

この回路は、51~53ページにある、 家と家の間のフェンス越しの3本の電線 を交差させた構成と機能的に同じだが、 高電圧の電池と電球でなければ動作しな い。

V

親友の家

本章では、 通信の進化に向けて重要な一歩を踏み出した。 これまでは、モール スコードを使って通信はできたものの、 直線上で懐中電灯の光が届く範囲だけ だった。

電線を使うことで、 角を曲がった見えない場所同士で通信できるシステムがで きただけでなく、距離の制限からも解放された。 電線をどんどん長くしていくだ けで、何百、何千キロ離れていても通信ができるのだ。

正確を押せば、少し違う。 銅は電気をよく通す素材だが、 完璧ではない。 電線 が長いほど抵抗は大きくなる。 抵抗が大きくなると、 流れる電流は少なくなる。 電流が少なくなるほど、 電球は暗くなる。

57

では、具体的にどのくらいの長さまで電線を延ばせるのだろう? それは条件に よる。グランドやコモンがないオリジナルの4線式双方向接続で、 懐中電灯の 電池と電球を使っているとしよう。 コストを抑えるため、最初はハイエンドの オーディオアンプにスピーカーを接続するための一般的な100 フィート [約30 メートル] 巻のスピーカー線を購入したとしよう。 スピーカー線は、2本の絶縁 電線を貼り合わせたもので、私たちの電信システムに適する。 自分の寝室と親友 の寝室の距離が50 フィート [約15メートル] 以内であれば、この一巻のスピー カー線でまかなえる。

電線の太さは、アメリカンワイヤーゲージ (AWG) [米国ワイヤゲージ規格] と いう単位で表される。 AWG の数字が小さいほど電線は太く、 抵抗も少なくなる。 たとえば20ゲージのスピーカー線を購入した場合、 電線自体の直径は約0.032 インチ [約 0.8 ミリメートル]、 抵抗値は1000フィート [約300メートル] あたり約 10オーム、 つまり寝室間の往復距離100 フィートで約1オームとなる。

これは悪くない数字だが、 もし電線を1マイル [約1.6キロメートル] の幅で通 したらどうだろう。 往復する電線の総抵抗値は100オーム以上となる。 前章で 電球が4オームしかなかったことを思い出そう。 オームの法則から、回路に流 れる電流は前述のように 0.75 アンペア (3ボルト÷4オーム) ではなく、 0.03 アンペア (3ボルト÷100オーム以上) 以下になることが容易に計算できる。 ほぼ間違いなく、電球を点灯させるのに十分な電流ではない。

太い電線を使うことはよい解決策だが、 コストがかかる。 10ゲージ線は約0.1 インチ [約2.5ミリメートル] の太さで、 抵抗値は1000フィートあたりわずか1 オーム、 1マイルあたり約5オームとなる。

電圧を高くして、 家庭の照明に使っているようなもっと抵抗値の高い電球を使 うという解決策もある。そうすれば、 電線の抵抗が回路全体に与える影響はずっ と小さくなる。

これは、19世紀半ばに、アメリカやヨーロッパに初めて電信システムを張り 巡らせた人たちが直面した問題だ。 電線の太さや電圧の高さにかかわらず、 電信 線を無制限に延ばしていくことはできなかった。 このやり方では、せいぜい数百 マイルが動作の限界だったのだ。 これではニューヨークとカリフォルニアの間の 何千キロもの距離をカバーすることは不可能だ。

この問題を解決したのは懐中電灯ではなく、 昔の電信機に利用されたカチカチ

58

第5章 角を曲がったやり取り

と音を立てる単純で地味な装置だった。 だが、 その装置からコンピュータが生み 出されたのだ。

59



第6章

スイッチを使ったロジック

「真」とは何か? アリストテレスは、 それに論理が関係していると考えた。 彼 の教えをまとめた 『オルガノン』 (紀元前4世紀) は、 論理学について詳しく書 かれた最も古い文献である。 古代ギリシャでは、論理学は真理を探究するために 言葉を分析する手段であり、 哲学の一種と考えられていた。 アリストテレスの論 理学の基本は三段論法だ。 最も有名な三段論法 (実はアリストテレスの著作には ないのだが)を示そう。

男性はみな死ぬ。

ソクラテスは男性だ。

それゆえ、ソクラテスは死ぬ。

三段論法では、2つの前提を正しいと仮定し、 そこから結論が導き出される。 ソクラテスが死ぬ結論は簡単そうに見えるが、 三段論法には様々な種類があ る。たとえば、19世紀の数学者チャールズ・ドジソン (ルイス・キャロルとし ても知られる) が提唱した次の2つの前提を考えてみよう。

哲学者はみな論理的だ。 非論理的な人間は常に頑固だ。

結論: 頑固な人の中には、哲学者ではない人がいるこれは、まったく自明で

はない。ここで突然現れた 「〜の中には」という言葉は何を意味するのだろうか。 2000年以上もの間、 数学者はアリストテレスの論理学を数学と演算子を使っ て整理しようと格闘してきた。 19世紀以前にこの仕事で最もいい線まで迫った のが、ゴットフリート・ヴィルヘルム・フォン・ライプニッツ (1648-1716) だった。 彼は早くから論理学に手を出したが、 その後、ほかのことに興味を持っ た (たとえば、 アイザック・ニュートンと同時期に微積分を独自に発明した)。 そして、ジョージ・ブールが登場した。

ジョージ・ブールは1815年に英国で生まれた。 当時の状況は、 彼にとって明らかに不利だった。 靴屋と元メイドの息子だったため、 通常なら英国 の厳格な階級社会が、 ブールを家柄と同様の仕事 に就くよう強制しただろう。 しかし、 科学 数学、 文学に強い関心を持つ父親の助けも借りて、 好奇 心旺盛なジョージ少年は、ラテン語、ギリシャ語、 数学など本来なら上流階級の少年しか受けられな いような学問を独学した。 数学に関する初期の論 文が評価され、ブールは1849年、 アイルランドの コークにあるクイーンズカレッジの初代数学教授に任命された。

1800年代半ば、 複数の数学者が論理の数学的定義に取り組んでいたが (最も 有名なのはオーガスタス・ド・モルガンだ)、 本当の概念的突破口を開いたのは ブールである。 最初は短い 『論理の数学的分析-演繹的推論の計算に関する試論 (The Mathematical Analysis of Logic, Being an Essay Towards a Calculus of Deductive Reasoning)』 (1847年) を発表し、 その後、より長く野心的な 『論理と確率の数 学的な理論の基礎となる思考法則の研究 (An Investigation of the Laws of Thought on Which Are Founded the Mathematical Theories of Logic and Probabilities、 便宜的に 『思考法則 (The Laws of Thought)』 と呼ばれる)』 (1854年) を発表した。 そして ブールは1864年、 雨の中を急いで教室に向かって肺炎にかかり、49歳で亡く なった。

1854年に出版されたブールの本のタイトルは、 野心的な動機を示唆している。 ブールは、人間の脳は論理を使って思考すると考えていた。 論理を数学で表現す る方法が見つかれば、 脳の働きも数学的に説明できるだろう、というわけだ。 し

brary/Getty Images

Science & Society

62

第6章 スイッチを使ったロジック

かし、彼のこの考えに必ずしも賛同しなくても、ブールの数学を研究することは できる。

ブールはまた、 従来の代数学とはまったく異なる代数学も発明した。 それは今 ではブール代数と呼ばれている。

従来の代数学では、 数字を文字で表すことが多かった。 それらはオペランド [被演算子] と呼ばれ、 オペレーター [演算子] (+や×など) と様々な形で組み合わ される。 例を示そう。

A = 3 × (B +5)

従来の代数学は、一定のルールに沿って実行される。 こうしたルールは、おそ らく私たちの日々の営みに深く浸透しているあまり、もはや認識されず、 名前す ら忘れられているかもしれない。 しかし、いかなる数学の世界でも、その根底に はルールがある。

最初のルールは、 加算 (足し算) と乗算 (掛け算) は交換法則 [交換律] を満 たす、つまり可換であることだ。 次のように、 演算子の左右の記号を入れ替える ことができる。

A + B = B + A A × B = B × A

これに対し、 減算 引き算) と除算 (割り算) は可換ではない。 加算と乗算は結合法則 [結合律] も満たす。 つまり、以下が成り立つ。

A + (B + C) = (A+B) + C A X (B × C) = (A × B) x C

最後に、乗算は加算に対して分配法則 [分配律] を満たす。

A X (B + C) = (AxB) + (AxC)

従来の代数学のもう1つの特徴は、豆腐の重さ、 アヒルの数、 列車の走行距 離、1日の秒数といったように、 常に数字を扱っていることだ。 代数学を数の概念から切り離し、 より抽象的なものにしたのはブールの天才の なせる技だった。 ブール代数では被演算子は数ではなく、 クラスを意味する。 ク

63

ラスとは単純にものの集まりを意味するが、のちにセット [集合] と呼ばれるよ うになったものと似た概念だ。

ここで猫の話をしよう。 猫にはオスとメスがいる。 便宜上、 オス猫のクラスを M (Male)、 メス猫のクラスをF (Female) と表記できる。 この2つの記号は、 猫の数を表しているわけではないことに注意しよう。 新しい猫が生まれ、年老い た猫が (残念ながら) 亡くなって、 オス猫とメス猫の数は刻々と変化する。 M とFの文字は、 猫のクラス (特定の特徴を持つ猫たち) を表している。 オス猫 を指す代わりに、ただM といえばよい。

また、ほかの文字を使って、 猫の色を表現することもできる。 たとえば、 T (Tan) は茶トラ猫のクラス、 B (Black) は黒猫のクラス、 W (White)は白猫の クラス、そしてO (Other) は T、B、 W のクラスに属さない 「その他」 すべて の色の猫のクラスを指すことができる。

最後に (少なくともこの例では) 猫は、去勢されているか否かに分かれる。こ こでは去勢された猫のクラスをN (Neutered [去勢済み])、 去勢されていない猫の クラスをU (Unneutered [未去勢]) と表記することにしよう。

従来の (数値) 代数学では、 演算子+と×はそれぞれ、 加算と乗算を表す。 ブール代数でも同じ + と × の記号を使うので、混乱することがあるかもしれな い。 従来の代数学での数字の加算や乗算は誰でも知っているが、 クラスの加算や 乗算はどうするのだろう?

実は、ブール代数では加算や乗算はしない。 その代わり、 +と×の記号はまっ たく別の意味を持つ。

ブール代数の+記号は、2つのクラスのユニオン [和] を意味する。 2つのク ラスの和とは、最初のクラスの内容すべてが2番目のクラスの内容すべてと合 わさったものだ。 たとえば、 B + W は、 「黒猫または白猫」 のクラスを表す。

ブール代数における× 記号は、 2つのクラスのインターセクション [交わり] を意味する。 2つのクラスの交わりは、最初のクラスと2番目のクラスの両方に 同時に属するものとなる。 たとえば、 FXTは、 メス猫かつ茶トラ猫のクラス を表す。 従来の代数学と同様にFXTをF・Tと書いたり、単にFT と書いた りできる(これはブール自身が好んだ書き方だ)。 この2文字は、 2つの形容詞 をつないだものと考えることができる。 たとえばFT は 「メス茶トラ」 猫といっ た具合だ。

64

第6章 スイッチを使ったロジック

65

従来の代数学とブール代数の混同を避けるために、 +とxの代わりにひとと いう記号を用いて、それぞれ和と交わりを表すことがある。 しかし、ブールが数 学に及ぼした大きな影響の1つは、おなじみの演算子を抽象的に使えることだっ た。 これに敬意を払い、 代数学に新しい記号を導入しないという彼の決断に従う ことにしよう。

ブール代数では、交換、結合、 分配の法則がすべて成立する。 さらに、 ブール 代数では、 +演算子は×演算子に対して分配法則を満たす。 これは、従来の代数 学は満たさない。

W + (B xF) = (W+B) × (W + F)

白猫 (W) と黒いメス猫 (BF) の和 (+) は、 白猫と黒猫の和 (W+B)、 白猫とメス猫の和 (W+F) という2つの和の交わり (x)と同じになる。 少 しわかりにくいかもしれないが、 この結果は正しい。

ブール代数を完成させるためには、さらに3つの記号が必要になる。 そのう ちの2つは数字のように見えるかもしれないが、 数字とは少し違う扱いを受け る。ブール代数の記号11つ目の記号』 は、 「ユニバース [宇宙]」、つまり私たち が扱うすべてのものを意味する。 猫の例では、1という記号は「すべての猫を含 むクラス」 を意味する。 よって、 以下の式

M+F=1

が意味するのは、 「オス猫クラスとメス猫クラスの和は、すべての猫のクラスと 等しい」 となる。 同様に、 茶トラ猫と黒猫と白猫とその他の色の猫の和も、 すべ ての猫のクラスと等しい。

T + B + W+0=1

次のようにしても、 すべての猫のクラスを表現できる。

N+U=1

1の記号は、マイナス記号 たつ目の記号と一緒に使うことで、何かを取り除 いたユニバースを表せる。 たとえば、

66

1-M

は、すべての猫のクラスからオス猫を取り除いたクラスだ。 すべてのオス猫を取 り除いたユニバースは、 メス猫のクラスと同じなので、次が成り立つ。

1-M=F

3つ目の記号は0 (ゼロ) だ。 ブール代数では、 0は空のクラス (何も持って いないクラス)を意味する。 たとえば、 オス猫とメス猫など、互いに排他的な2 つのクラスの交わりを取ると、 結果は空のクラスになる。

Fx M = 0

ブール代数では、1や0の記号が従来の代数学と同じように働くことがあるの で注意が必要だ。 たとえば、 すべての猫とメス猫の交わりはメス猫のクラスと同 じになる。

1xF=F

一方、 猫がいない空のクラスとメス猫クラスの交わりは、 猫がいない空のクラ スとなる。

0x F = 0

猫がいない空のクラスとすべてのメス猫クラスの和は、 メス猫クラスとなる。

0+F=F

しかし、 結果が従来の代数学と同じようにはいかないこともある。 たとえば、 すべての猫クラスとメス猫クラスの和は、すべての猫のクラスになる。

1+F=1

これは従来の代数学でFはすべてのメス猫のクラス、 (1-F) はメスでないすべての猫のクラスなの で、これら2つのクラスの和は1となる。

は意味をなさない。

第6章 スイッチを使ったロジック

67

F + (1-F)=1

そして、これら2つのクラスの交わりは0になる。

Fx (1-F) = 0

この式は、歴史的には、 論理学の重要な概念を表す。 これは矛盾律と呼ばれ、 何かがそれ自身であると同時にその反対であることはありえないことを示す。 ブール代数が従来の代数学と本当に違って見えるのは、次のような表現である。

FxF=F

この表現は、ブール代数では完全に意味をなしている。 メス猫クラスとメス猫 クラスの交わりは、 メス猫クラスであることに変わりはない。 でも、 Fが数字を 指しているなら、 確かに違和感がある。 ブールは

x2 = X

という式を、彼の代数学と従来の代数学を区別する表現の1つと考えていた。 もう1つ、従来の代数学から見るとおかしく感じるブール式 [真偽を表現する式] を示そう。

F + F = F

メス猫クラスとメス猫クラスの和は、 やはりメス猫クラスになる。 ブール代数は、アリストテレスの三段論法を解くための数学的手法を提供す る。 有名な三段論法の最初の3分の2を、 今度はジェンダーニュートラルな言 葉を使って見てみよう。

人間はみな死ぬ。 ソクラテスは人間だ。

ここで、 Pを全人間のクラス、Mを死すべきもののクラス、Sをソクラテス のクラスと表現することにする。 「人間はみな死ぬ」 とはどういう意味だろう

68

か?これは、すべての人間のクラスとすべての死すべきもののクラスの交わり が、すべての人間のクラスであることを意味している。

Px M = P

にれ ここで、P × M = M というのは間違いだろう。猫も犬も楡の木も、すべての死 すべきもののクラス M に含まれるのだから。

「ソクラテスは人間だ」 ということは、ソクラテスだけを含むクラス (とても 小さなクラス) とすべての人のクラス (はるかに大きなクラス) の交わりがソク ラテスだけを含むクラスであることを意味する。

SxP = S

最初の式からPは (P × M) に等しいことがわかっているので、それを2番目 の式に代入できる。

S X (P x M) = S

結合法則により、 これは以下と同じである。

(S×P) x M = S

S×P = Sであることはすでにわかっており、これを代入して簡略化できる。

S × M = S

これで終了だ。 この式は、ソクラテスのクラスとすべての死すべきもののクラ スの交わりがSであること、つまりソクラテスが死を免れないことを教えてく れる。この代わりに(S×M)=0という式が導かれたなら、ソクラテスは死な ないという結論になる。 また、 もし (S×M) = Mだとわかったなら、この結論 は、ソクラテスだけが死すべきもので、ほかのすべては不死である、 とならざる をえない。

ブール代数は、この明白な事実を証明するためには過剰と思えるかもしれない が(特に2400年前にソクラテスが自ら死ぬものであることを証明したことを考 えると)、ブール代数は、何かがある一定の基準を満たすか否かを判断するため にも使うことができるのだ。

第6章 スイッチを使ったロジック

たとえばある日、 あなたはペットショップに入って、店員にこう言うかもしれ ない。 「去勢済みのオス猫で、 白か茶トラのどちらかがほしい。 あるいは去勢済 みのメス猫で白以外の色なら何でもいい。 または、 黒ならどんな猫でも構わな 「い」。 そして、 店員はあなたに、 「つまり次の式

( M × N × (W + T)) + (F × N × (1-W)) + B

で表される猫のクラスに当てはまる猫がほしいわけですね?」 と尋ね、 あなたは 「はい、その通り!」 と答えるのだ。

店員が正しいか否かを検証する際には、 OR と AND という言葉を使って、和 と交わりの概念を表すとよい。 これらの単語 (OR, AND) を大文字にしてい るのは、 通常これらは英語の概念を表す単語であるものの、ブール代数における 演算を表すこともできるからだ。 2つのクラスの和を形成したときには、「最初 のクラス OR 2番目のクラス」 を満たすものを受け入れることになる。 そして、 交わりを形成する場合、 最初のクラスと2番目のクラスの両方に属するものだ けを受け入れることになる。 さらに、 「1」 のあとにマイナス記号が続く場所で は、 「NOT」という単語を使うことができる。 まとめると次のようになる。

● + (和) には、 OR の意味もある。

●x (交わり) には、 AND の意味もある。

•1- (全体から何かを取り除いた) は、 NOT を意味する。

そのため、 先の式は次のようにも書ける。

(MAND N AND (W OR T)) OR (FAND NAND (

NOT W)) OR B

かっこ これは、ほぼ、あなたが話した内容だ。 括弧が意図を明確にしていることに注 意しよう。 あなたは3つのクラスのうちのいずれかのクラスから猫を選びたい。

(MAND NAND (W OR T)) OR (FAND N AND (NOTW)) OR

B

69

上の式を見た店員は、ブーリアンテスト [真偽テスト] と呼ばれるものを行うこ とができる。 ブーリアンテストはブール代数の別のバリエーションで、文字は猫 の特性、 特徴、 属性を表し、 0 あるいは1の数字を割り当てることができる。 数 字の1は、 Yes [はい] または True [真] すなわち「この猫はこの条件を満たし ている」という意味だ。 数字の0は No [いいえ] または False [偽]、 すなわち 「この猫はこの条件を満たしていない」という意味になる。

まず、 店員が未去勢の茶トラ猫のオスを連れてきた。 あなたの希望に当てはま る猫の式を再度見てみよう。

(M × N × (W + T)) + (F × N × (1-W)) +B

ここに0と1を代入すると次のようになる。

(1 × 0 × 0 + 1)) + (0 × 0 × (1-0)) + 0

猫がオスで茶トラ猫なので、 1が割り当てられているのはMとTだけだ。 やらなければならないのは、この式を単純にすることである。 単純化して1 になれば、 猫はあなたの基準を満たし、 単純化して0になれば、 猫はあなたの 基準を満たさないわけだ。 式を簡略にする際には、 見た目とは異なり、 加算や乗 算をしているわけではないことに注意しよう。 +がOR を意味し、 × が AND を意味する場合、ほとんど同じルールが適用される (現代の教科書では、記号へ とVが、 x と + の代わりに AND OR の意味に使われることがある。 しかし、 ここで+や×の記号を使うと、 従来の代数学と似たようなルールになり、扱いが 容易になるだろう)。

× が AND を意味する場合、考えられる結果は次の通りだ。

0 × 0 = 0 0x1 = 0 1× 0 = 0 1×1=1

つまり、 左被演算子と右被演算子の両方が1のときのみ、 結果が1になる。 この 演算は、通常の乗算とまったく同じ結果となり、 簡単な表にまとめられる。 操作 は左上に表示され、 可能な組み合わせは上段と左列で表示される。

70

第6章 スイッチを使ったロジック

AND 0 1 0 0 0 1 0 1

| 71

+記号が OR を意味する場合の結果は次のようになる。

0+0=0 0+1=1 1+0=1 1+1=1

結果は、 左被演算子または右被演算子のいずれかが1であれば1となる。 こ の演算は、 1+1が1になること(ある猫が茶トラ猫または茶トラ猫なら、その 猫は茶トラ猫だ) を除けば、 通常の加算ととてもよく似た結果だ。 OR 演算も、 以下のような小さな表にまとめることができる。

OR 0 1 0 0 1 1 1 1

これらの表を使って、 式の結果を計算する準備が整った。 さっそく、 やっ

てみ よう。

(1 × 0 × 1) + (0 × 0 × 1) + 0=0+0+0= 0 結果 0 が意味するのは「いいえ」、「偽」。 つまりこの子猫は希望する猫ではない ということだ。

次に店員は、去勢された白いメスを連れてきた。 こちらの要求の式は以下にな る。

(M × N × (W + T)) + (F × N × (1-W)) +B

72

ここで、もう一度0と1を代入してみよう。

(0 × 1 × ( 1 + 0)) + (1 × 1 × (1-1)) + 0

さらに、 単純化すると、以下になる。

(0 × 1 × 1) + (1 × 1 × 0) + 0 = 0 +0 +0 = 0

今度もまた、 残念ながら子猫を見送らなければならない。 次に店員は去勢済みのグレーのメスを連れてきた(グレーは白や黒、茶トラで 「はなく 「その他」に該当する)。 式に当てはめてみよう。

00 × 1 × 00 + 0)) + (1 × 1 × (1-0)) +0

単純化してみよう。

(0 × 1 × 0) + (1 × 1 ×1) +0=0+1+0=1

最終結果は1。 ということは、 「はい」 または 「真」。 つまり子猫のお家が見つ

かったということだ (そして、 一番かわいい猫だった!)。 その夜、 膝の上で丸くなって寝ている子猫を見ながら、 あなたは、 「ある子猫 が自分の好みを満たしている」 と判断できるようスイッチや電球を配線できない だろうかと考えた (そう、 あなたは奇妙な子どもなのだ)。 だが、このときのあ あなたは、概念的なブレークスルーを成し遂げようとしていることに気づいていな い。 まさにジョージ・ブールの代数を電気回路と統合し、 デジタルコンピュータ の設計と構築を可能にする実験を行おうとしているのだ。 ただし、 だからといっ て怯む必要はない。

まず、いつも通り電球と電池をつなごう。 その際、スイッチは1つではなく2 つ使用する。

第6章 スイッチを使ったロジック

73

www

図の横にある地球のマークが示すように、 この回路のインタラクティブ版は、 ウェブサイト(www.CodeHidden Language.com) で見ることができる。 このように直線上に隣接して接続されたスイッチは、 直列につながっていると いう。 ここでは、 左のスイッチだけを閉じても、 何も起こらない。

<W>

また、左のスイッチを開いたまま、 右のスイッチを閉じても、同様に何も起こ らない。 次ページの図のように、 左のスイッチと右のスイッチの両方が同時に閉 まっているときだけ、電球は点灯する。

<WW

ここでキーワードとなるのが「と (and)」 だ。 回路に電流を流すには、 左の スイッチと右のスイッチの両方が閉まっている必要がある。

この回路は、 論理のちょっとした練習問題といえる。 事実上、 電球は 「両方の スイッチが閉まっているか?」 という質問に答えているのだ。 この回路の働きを 表にまとめると、次のようになる。

左のスイッチ 右のスイッチ 開 開 電球 点灯しない 開 閉 点灯しない 閉 開 点灯しない 閉 閉 点灯する

スイッチと電球がブール演算子だと考えると、上の表を0と1の数値で表現す ることもできる。 0は 「スイッチが開いている」 1は 「スイッチが閉じている」 という意味だと解釈できる。 電球には2つの状態があり、 0 は 「点灯していない」、 1は 「点灯している」 を意味する。 これを使って先の表を書き換えてみよう。

左のスイッチ

右のスイッチ

0

電球

0

0

1

0

0

0

0

1

1

1

1

74

第6章 スイッチを使ったロジック

75

左のスイッチと右のスイッチを入れ替えても、結果は同じであることに注意し てほしい。 実際、 どのスイッチがどちらなのかを気にする必要はない。 つまりこ の表は、 先に示した AND OR の表と同じように書き換えらえる。

直列配置のスイッチ 0 1 0 1 0 0 0 1

実際、これはAND の表と同じである。 比べてみよう。

AND 0 1 0 0 0 I 0 1

この単純な回路は、 実はブール代数の AND 演算を行っているのだ。 さて、今度は2つのスイッチの接続を少し変えてみよう。

これらのスイッチは、並列につながっているという。この配線が先の配線と違 うのは、上のスイッチを閉めただけで電球が点灯するということだ。

www

下のスイッチを閉じても点灯する。

www

そして、両方のスイッチを閉じても点灯する。

76

6 スイッチを使ったロジック

www

上のスイッチまたは (OR) 下のスイッチを閉じると電球が点灯する。ここで のキーワードはまたは (OR) だ。

ここでも、回路は論理演算を行っている。 電球が表現しているのは、「いずれ かのスイッチが閉まっているか?」という質問に対する回答である。 この回路の 仕組みは次の表のようにまとめられる。

左のスイッチ 開 右のスイッチ 電球 開 開 閉 点灯しない 点灯する 閉 開 点灯する 閉 閉 点灯する

ここでも、0を 「開いているスイッチ」、「点灯していない電球」、 1を 「閉じ ているスイッチ｣ ｢点灯している電球」という意味だとすると、上の表は次のよ うに書き換えられる。

左のスイッチ 右のスイッチ 電球 0 0 0 0 1 I 1 0 1 1 1

77

78

2つのスイッチが入れ替わっても問題ないので、次のように書き換えられる。

並列配置のスイッチ 0 1 0 1 0 1 1 1

そしてご想像の通り、これはブール演算のOR と同じなのだ。

OR 0 1 0 0 1 1 1 1

つまり、2つのスイッチが並列につながることで、 ブール演算の OR に相当する 演算が行われる。

ペットショップに入ったときに言ったことを思い出してほしい。 あなたが 「去 勢済みのオス猫で、 白か茶トラのどちらかがほしい。 あるいは去勢済みのメス猫 で白以外の色なら何でもいい。 または黒ならどんな猫でも構わない」 と言った ら、店員が次の表現を返してきた。

( M × N × (W + T)) + (F × N × (1-W)) + B

2つのスイッチを直列につなぐと論理 AND (× 記号) となり、 2つのスイッ チを並列につなぐと論理 OR (+記号) になることがわかった。 そのため、8つ のスイッチは次のように配線できる。

第6章 スイッチを使ったロジック

79

W M B. www

この回路の各スイッチには、ブール式と同じ文字が添えられている。 (Wは NOT W を意味する。これは1Wと同じ意味の表記である)。 確かに、 配線 図を左から右へ、上から下へと見ていくと、 式に登場する文字が同じ順番で出て くる。 式中の× 記号は、 回路の中で2つのスイッチ(またはスイッチ群) が直 列に接続された点に対応する。 式中の+記号は、回路中の2つのスイッチ(ま たはスイッチ群) が並列に接続されている場所に相当する。

思い出してみると、 店員が最初に連れてきたのは、 未去勢 (NOT N) の茶ト ラ (T) のオス (M) だった。 該当するスイッチを閉じてみよう。

M. W <W>

M. T. NOT W のスイッチは閉じているが、 電球を点灯させる回路にはなってい ない。 次に販売員が出してきたのは、去勢された (N) 白い (W) メス (F) だった。

|

B W www

この場合でも、 電球を点灯させるために必要なスイッチは閉じられていない。 そして、最後に店員が連れてきたのは、去勢された (N) グレーの ( NOT W) メス (F) だった。

W

どうやら今度の条件は、回路を完成さるものだったようだ。 その結果、 電球が 点灯し、子猫があなたの示した基準をすべて満たしていることがわかった。

もちろんジョージ・ブールがこんな回路を配線したことはない。 ブール自身 は、ブール式がスイッチや配線、電球として実現される感動を味わっていない。 それが実現できなかったのは、 白熱電球の発明がブールの死から15年後だった ためだ。 とはいえ、 ブールの 『思考法則』の出版よりも10年前に電信機が発明

80

第6章 スイッチを使ったロジック

81

されており、その主要部分は単純な装置だったので、単なるスイッチよりもはる かに迅速に論理演算ができただろう。



第7章

電信とリレー

サミュエル・フィンリー・ブリース・モールスは、バンカーヒルの戦いが行わ れたマサチューセッツ州チャールスタウン (現在のボストン北東部) で、 1791 年に生まれた。 モールスが生まれた年は、合衆国憲法が施行されてまだ2年、 ジョージ・ワシントンが大統領として1期目を務めていた。 当時のロシアは、 エカチェリーナ2世が統治していた。 フランスはまだ革命が進行中で、ルイ16 世とマリー・アントワネットはこの2年後にギロチンにかけられた。 1791年に は、モーツァルトは自身最後のオペラ「魔笛」 を完成させ、その年の暮れに 35 歳で亡くなるが、 そのときには弱冠20歳のベートーベンがすでに注目されてい た。

モールスはイェール大学で教育を受け、ロンドンで 美術を学び、 肖像画家として成功を収めた。 彼の描い た 「ラファイエット侯爵」 (1826年) は、 ニューヨー クの市庁舎に飾られている。 メトロポリタン美術館に 展示されている娘のスーザンを描いた肖像画 「ザ・ ミューズ」 はより個人的な、 彼の最後の作品だ。

サミュエル・モールスは、 初期の写真愛好家の1人 でもあった。 モールスは、ルイ ダゲール本人からダ ゲレオタイプ写真 [銀板写真] の作り方を学び、 アメリ カで最初のダゲレオタイプを作成した。 1840年、彼は17歳のマシュー・ブレ イディにその工程を教えた。 やがてブレイディは同僚とともに、南北戦争、 エイ ullstein

bild Dtl/Getty Images

84

ブラハム・リンカーン、そしてサミュエル・モールス自身の最も印象的な写真を 撮ることになる。

しかし、こうしたエピソードはモールスの多彩なキャリアの補足にすぎない。 今ではサミュエル・モールスは、電信の発明と自身の名前を冠した暗号でよく知 られている。

私たちが慣れ親しんでいる、世界規模での即時通信が可能になったのは、比較 的最近のことだ。 1800年代初頭には、 即時通信、 あるいは長距離通信が可能だっ たが、両方を同時に行うことはできなかった。 即時通信は、 声の届く範囲 (ただ し拡声器は存在しなかった) か、 望遠鏡で見える範囲に限られていた。対して長 距離通信には手紙が使われ、 時間がかかり、馬や列車、 船などが必要だった。

モールスの発明の数十年前から、 長距離通信を速くする試みが数多く行われて いた。 技術的に単純な方法としては、 丘の上に立った人間が手旗信号として知ら れるコード化されたパターンで旗を振る、 リレーシステムが採用されていた。 よ り複雑な解決法として、 可動式の腕木を持つ大型の仕掛けが使われたが、基本的 には人が旗を振るのと同じだった。

サミュエル・モールスが1832年に実験を開始する以前から、ほかの発明家た ちが「テレグラフ [電信]」 (文字通りの意味は 「遠くの文字」) のアイデアに挑戦 していた。 原理的には、 電気電信 [電気を使った電信] のアイデアは単純だった。 電線の片側で何かをすることで、 もう一方の電線の端で何かを起こすのだ。 これ は、第5章で長距離用懐中電灯を作ったときと全く同じである。 しかしモール スは、信号を伝える手段に電球が使えなかった。 実用的な電球が発明されたのは 1879年だったからだ。 その代わり、 モールスは電磁気現象に頼ることにした。

デンマークの物理学者ハンス・クリスティアン・エルステッドは、 電気と磁気 の関係を初めて体系的に解明したとされる。 1820年に発表した論文では、電流 を流すと磁気を帯びたコンパスの針の向きが変わることを示した。 その後、この 現象は、マイケル・ファラデーやジェームズ・クラーク・マクスウェルなど 19 世紀の科学界で最も優れた頭脳を持つ人たちの関心を集めた。 マクスウェルの著 した 1873年の『電気磁気論』 は、 数理物理学の古典として有名である。しかし、 その頃には、サミュエル・モールスのような独創的な革新者たちが、 すでに電磁 気を利用して巧妙な発明を行っていた。 鉄の棒に細い絶縁線を数百回巻きつけて 電流を流すと、鉄の棒は磁石になる。 そして、ほかの鉄や鋼の破片を引き寄せ

第7章 電信とリレー

る。 電流を止めると、 鉄の棒は磁気を失う。

上の図は一見ショートしているように見えるが、 鉄棒に巻かれている針金はと ても細く、 十分な電気抵抗を生む。

電磁石は、電信の基礎である。 一方の端のスイッチをオンオフすることで、 も う一方の端で電磁石が何かを行うのだ。

モールスの最初の電信機は、 実はのちに進化した電信機よりも複雑だった。 モールスは、電信システムは実際に紙に何かを書くべきだと考えていた。 すなわ ち、のちにコンピュータユーザーが口にするように、「ハードコピーをとる」 べき だと考えていた。 もちろん、 必ずしも普通の言葉をそのまま書く必要はない。 そ うすると複雑すぎるからだ。 ともあれ、 くねくねした線でも、 ドットとダッシュ でもいいから、何かを紙に書くべきだ。 モールスは、「何かを書いた紙」 を必要と するパラダイムから抜け出せなかった。 ヴァランタン・アユイが盲人用の本には アルファベットの盛り上がった文字を使うべきだと考えたのと同じように。

サミュエル・モールスは1836年、 特許庁に電信機の発明を届け出たが、 1843年になってようやく議会を説得し、 電信機の公開デモンストレーションの ために資金を得た。 デモが行われた1844年5月24日は歴史的な日だ。 ワシン トンDC とメリーランド州ボルチモアの間に敷設された電信線が、 聖書 (民数 記23章23節)の一節 「What hath God wrought ! 」 を伝えることに成功した。

これは疑問文ではなく 「神がなさったことを見よ!」 という意味である。 メッセージを送るために使われる伝統的な電信の 「キー」 は、 次ページに示す形 をしている。

85

86

見た目は派手だが、これはなるべく早く押すためにデザインされたスイッチ だ。長時間使う際には、 親指、人差し指、中指でハンドルをつかみ、 上下に叩く のが最も快適なキーの操作方法である。 短く叩くとモールスコードのドット、 長 く叩くとダッシュが送り出される。

電線の反対側には、 基本的に電磁石で金属のレバーを引っ張る受信機が置かれ ていた。もともとは、電磁石でペンを制御していた。 巻き上げられたバネでゆっ くりと引っ張られているロール紙に向かって、ペンが上下することで紙にドット やダッシュが描かれる。 モールスコードを読める人が、 ドットやダッシュを文字 や単語に書き換えていくのだ。

もちろん、人間は怠惰であると同時に独創的でもある。 電信技師はすぐに、ペ ンが上下に跳ねる音を聞くだけでコードから文字起こしができることに気がつい た。やがてペン機構は、電信機に採用された以下のような「サウンダー」という 機構に置き換えられる形で、姿を消した。

上部のバーは通常、 左の垂直部分の内側にある重りやバネで水平に保たれてい るが、回転もする。 電信のキーを押すと、 電磁石が回転可能なバーを引き下げ、 その際に「カチッ」という音がする。 キーを離すと、 バーが 「カチャ」 という音 を立てながら元の位置に戻る。 素早い 「カチカチャ」 はドット、 ゆっくりとした 「カチッカチャ」はダッシュを表す。

ちょうど前章までの電球式電信と同じように、鍵、サウンダー、電池、 電線を 接続できる。

第7章 電信とリレー

87

あなたの電信局

親友の電信局

すでに見たように、2つの電信局を結ぶのに2本の電線は必要ない。 電圧が十 分に高ければ、1本の電線で事足りる。 大地が残りの半分の回路を提供してくれ るからだ。

前章で行ったように、グランドに接続されたバッテリーを大文字のV に置き 換えることで、一方向通信の構成は次のようになる。

あなたの電信局 親友の電信局

双方向通信のためには、もう1つずつ、キーとサウンダーを用意すればよい。 これは、 前章で行ったのと同様である。

電信の発明は、 まさに近代的な通信の始まりを告げた。 人類は初めて、目で見 るよりも耳で聞くよりも遠くへ、 そして馬が駆け抜けるよりも速く、 通信できる ようになったのだ。 この発明でバイナリーコードが使われたことは、大いに興味 をそそる。以後、電話やラジオ、テレビといった電気無線通信ではバイナリー コードは放棄されたが、 コンピュータ内部で使われてからは事実上あらゆる電子 媒体で使われることとなった。

モールスの電信機がほかの電信機より優れていた点として、 回線状態が悪くて も耐えられたことがある。 キーとサウンダーの間に電線を張れば、大抵うまく動 作した。 ほかの電信システムは、これほど簡単ではなかった。 しかし、第5章 で説明したように、 電線は長さが長くなればなるほど、 電気の流れに対する抵抗 が大きくなる。 これは長距離電信の大きな障害となった。 電信線には300ボル

|

トの電圧で300 マイル [約483キロメートル] の長さに対応できるものもあったが、 電線を無限に延長することはできなかった。

わかりやすい解決策の1つは、 中継方式を採用することだ。 すなわちメッセー ジを受信し、それを送信できるよう、 数百マイルごとにサウンダーとキーを手元 に置いた人を配置していくやり方である。

あなたが電信会社に雇われ、 この中継システムの一員になったとしよう。あな たは、ニューヨーク~カリフォルニア間のどこかにある、 テーブルと椅子が設置 された小さな小屋で働いている。 東側の窓から入った電線は、 サウンダーに接続 されている。 電信キーは、 電池と西側の窓から出る電線に接続されている。 あな たの仕事は、ニューヨーク発のメッセージを受信し、 それを送信することで、最 終的にカリフォルニアまで届けることだ。 同じ構成で、 カリフォルニアから ニューヨークへもメッセージを中継する。

はじめは、 メッセージ全体を受信してから、それを送信することになるだろ う。サウンダーのクリック音に対応した文字を書き記し、 メッセージが完了した ら、それをキーで送るようにする。 だがそのうち、 文字を全部書かなくても、聞 きながらメッセージを送るコツがわかってくる。 時間の節約だ。

ある日、 メッセージの再送中、 あなたはサウンダーのバーが上下に跳ねている のを眺めつつ、同時に自分の指もキーを上下に跳ねているのに気がつく。 サウン ダーをもう一度見て、キーをもう一度見て、やがてキーが上下に跳ねているのと 同じようにサウンダーも上下に跳ねていることに気づくのだ。 そこで、 外に出て小 さな木片を拾い、その木と紐を使ってサウンダーとキーを物理的に接続してみる。 06

In -Out

勝手に送信できるようになったので、午後は休んで釣りに行くことができる。 これは面白い妄想だが、 サミュエル・モールスは実際、 早くからこの装置のコ

88

第7章 電信とリレー 89

ンセプト [概念] を理解していた。 ここで妄想した装置は、リピーター、 あるい はリレーと呼ばれるものだ。 リレーの仕組みはサウンダーと同じで、入力された 電流が電磁石を生み出し、 金属のレバーを引き下げる。 しかし、その引き下げら れるレバーは、カチッカチャという音を出すためではなく、 バッテリーと発信線 をつなぐスイッチの一部として使用される。 このようにして、弱い入力電流は、 「増幅」 されて強い出力電流となる。

リレーを図式化すると次のようになる。

In V Out

電磁石に電流が流れると、 回転する、 あるいは柔らかくて曲がる金属棒を引き 寄せて、電流を流すスイッチのような役割を果たす。

In V . Out

In と Out は、 電信線が小屋の窓から入ってきて、 反対側の窓から出る様子に 対応する言葉だが、 input [入力] と output [出力] の略語として考えることもでき

る。これらは電気信号だ。 In という名の信号は、 Out という名の信号に変化を 与える。 すなわち、 In と Out はそれぞれ、 原因と結果なのだ。

リレーは素晴らしいデバイスである。 確かにスイッチであるが、 人の手ではな く、電流でオンオフするスイッチなのだ。 このデバイスを使えば、凄いことがで きるかもしれない。 リレーを使えば、コンピュータのほとんどを組み立てること ができるかもしれないのだ。

そう、リレーは、 電信博物館に置いておくにはあまりにもったいない発明だ。 1個を手に取ってジャケットの中に隠し、 警備員の前を素早く通りすぎることに しよう。 心の中に、 あるアイデアが湧き出しているからだ。

90

第 8 章

リレーとゲート

本質を突き詰めれば、 コンピュータは、ブール代数と電気を合体させたもの だ。 この数学とハードウエアの融合を具体化する重要な部品が 「ロジックゲート [論理ゲート] 」 と呼ばれるものだ。 このゲート [門] は、 水や人が通る身近なゲー トと似ている。 論理ゲートは、 電流の流れを遮断したり、 通したりすることで、 ブール論理の簡単な演算を行う。

第6章であなたはペットショップに入り、威勢よく 「去勢済みのオス猫で白 か茶トラのどちらかがほしい。 あるいは去勢済みのメス猫で白以外の色なら何で もいい。 または、 黒ならどんな猫でも構わない」 と言ったことを思い出そう。 こ の基準は、次のブール式で表現できる。

(M × N × (W + T)) + (F × N × (1-W)) + B

この表現は、スイッチ、 電池、電球で構成された、 操作可能な回路として実現 できる。

W

このような回路はネットワークと呼ばれることもあるが、 現在ではネットワー クという用語は単なるスイッチの集合体ではなく、 接続されたコンピュータを指 す言葉として使われることが多い。

この回路の中には、 直列に配線されたスイッチと並列に配線されたスイッチの 組み合わせがある。 直列に接続されたスイッチは、ブール式では× 記号で表現さ れる論理 AND 演算を行う。 また並列に配線されたスイッチは、 +記号に対応す る論理 OR 演算を行う。 この回路はブール式と対応しているので、元になるブー ル式を簡略にできれば、回路も簡略にできる。 ほしい子猫に求める特徴を改めて示そう。

(M × N × (W + T)) + (F × N × (1-W)) +B

この表現をより簡単にしてみよう。 可換則を使えば、 AND (x) 記号で結合 される変数を並べ替えて、 次のように式を書き直せる。

(N × M × (W + T)) + (N × F × (1-W)) + B 何をするのかを明確にするため、 X と Y という名前の2つの新しい記号を定 義することにしよう。

X = M × (W +T) Y=Fx (1-W)

これで、 ほしい子猫の式は次のように書ける。

22 92

第8章 リレーとゲート

(N × X) + (N×Y) +B

93

式の簡略化が終わったら、 X と Y の式を元に戻すことにしよう。 Nという変数が式に2回出てくることに注目しよう。 分配則を使うことで、 この式はNを1つだけ使う次の形に書き換えられる。

(N × (X + Y)) + B

それでは、XとYの式を元に戻してみよう。

(N × ((M × (W + T)) + (Fx (1-W)))) + B

括弧が多すぎて、 この式はとても簡単になったようには見えない。 しかし、含ま れる変数は1つ少なくなっている。 つまり、 スイッチを1つ省けるということ だ。 この改訂版の回路は、次のようになる。

W W www

この回路が先の回路と等価であることを確認するのは、式同士が同じであること を確認するよりも簡単だろう。

それでもこの回路は、スイッチの数がまだ多すぎる。 オスとメスでスイッチが 分かれているが、たとえばメスはオン (または閉)、オスはオフ (または開)と いうように、スイッチは1つだけであるべきだ。 同様に、 白 (W) と非白 (W) のスイッチも別々に用意されている。

では子猫を選ぶためのコントロールパネルを作ってみよう。 このコントロール パネルは、5つのスイッチ (壁にある照明をコントロールするためのオンオフ

94

スイッチのよう

なもの) と電球がパネルに取り付けられているだけだ。

Dream Kitty FN B W T 8 & PP (Meow M U Control Panel

スイッチは、上がっているときがオン (閉)、下がっているときがオフ (開) である。1つ目のスイッチでメスかオスかを、2つ目のスイッチで去勢済みか未 去勢かを選択できる。 色を選択するスイッチは、 黒(B)、 白 (W)、 茶トラ (T) の3つとなる。色の選択スイッチは、1つだけがオンになっているか、ほかの色 を選びたいときには全部がオフになっていなければならない。

コンピュータ用語では、スイッチの組み込まれたパネルは入力デバイスに相当 する。 入力とは、 回路の動作を制御する情報であり、 この場合はほしい子猫の特 徴を示す。 出力デバイスは電球だ。 スイッチの組み合わせが満足のいく子猫を表 していた場合、電球が点灯する。 図の操作パネルに描かれたスイッチは、 未去勢 (U= NOT N) のメス (F) の黒 (B) 猫用に設定されている。 これはあなたの 条件を満たしているので、電球が点灯するというわけだ。

あとは、このコントロールパネルを動作させるための回路を設計するだけである。 前章では、 リレーと呼ばれる装置が、 電信システムの仕組みに欠かせないこと を紹介した。 長距離になると、 電信局を結ぶ電線は非常に高い抵抗値を持つよう になる。 そこで弱い信号を受信して、 同じ内容の強い信号を再送する方法が必要 になった。 リレーは、 電磁石でスイッチを制御することで、 これを実現した。 実 際、 リレーは弱い信号を増幅して強い信号を作り出していた。

だが、 今の段階では、リレーを使って弱い信号を増幅する方法は考えないこと にする。 リレーが、 手動ではなく、 電気で自動的に操作できるスイッチだという ことだけに興味があるからだ。 リレーはもともと電信用として設計されたが、 や がて電話という巨大ネットワークで使われるスイッチ回路に組み込まれ、その汎 用性が想像力豊かな電気技師たちに知られることとなった。

第8章 リレーとゲート

リレーはスイッチと同様、 直列や並列に接続することで、 論理的に単純な作業 を実行する。 このようなリレーの組み合わせを論理ゲートと呼ぶ。 これらの論理 ゲートが「論理的に単純な作業を実行する」 というとき、 私が意味しているの は、可能な限り単純という意味だ。 スイッチと比べてリレーには、 手動ではなく 別のリレーでオンオフを切り替えられるという利点がある。 つまり、 論理ゲート を組み合わせることで、 算数の簡単な演算など、 より複雑な処理を実行でき、最 終的にはコンピュータ全体の仕組みを作ることができる。

リレーがブール演算に使えるという発見は、一般にはコンピュータのパイオニ ア、 クロード・エルウッド・シャノン (1916-2001) のものとされる。 彼の有名 1938年の MIT [マサチューセッツ工科大学] での修士論文には『リレーとスイッ チング回路の記号解析 (A Symbolic Analysis of Relay and Switching Circuits)』 とい うタイトルがついている。ただし、その数年前に日本の電気技術者の中嶋章が同 等の理論を説明していた。

次の図のように、スイッチと電球と2個の電池を使って、 リレーを配線できる。

www

左側のスイッチが開いているとき、 電球は消えている。 このスイッチを閉じる と、左側の電池が鉄棒に何重にも巻かれた電線 [コイル] に電流を流す。 鉄棒が 磁気を帯び、 柔軟あるいは回転する金属の接点を引き下げることで、回路がつな がり電球が点灯する。

95

96 96

www

電磁石が金属の接点を引き下げたとき、リレーが作動したという。 スイッチを オフにすると、鉄棒は磁気を帯びなくなり、 金属接点は元の位置に戻る。

これは、電球を点灯させるためにはかなり間接的なやり方に思えるし、実際そ うだ。 単に電球を点灯させるだけなら、 リレーを完全に省ける。 だが、 私たちは 電球を光らせることに興味があるわけではない。 もっともっと野心的な目標を抱 いている。

本章ではリレーを多用するので (しかも論理ゲートを作ったあとはほとんど使 わないので)、 回路図をもっと簡単にしてみよう。 第5章と第7章では、グラン ドと大文字のV (voltage [電圧] のV) を使って電源を表現することで、配線の 一部を省略できた。 ここでは、 グランドは単に共通の接続点を表すだけで、 物理 的に地面につながっている必要はない。 これでリレーは次のように示せる。

V <W>

第8章 リレーとゲート

スイッチを閉じると、 電磁石のコイルを通してVとグランドの間に電流が流 れる。これにより電磁石が、 柔軟に動く金属接点を引き下げる。 この結果、 V と電球とグランドからなる回路がつながって、 電球が点灯する。

97

V V www

ち

これらのリレーの図では、2つの電圧源と2つのグランドが示されている。 た だし、 本章で示す図はすべて、 2つのVを互いに接続できる。 同様に、2つのグ ランドも互いに接続できる。

リレーをもっと抽象的に表現すると、スイッチや電球の絵を省いた上で、入力 と出力として示すことができる。

入力 V 出力

入力に電流が流れている場合 (たとえば、 スイッチで入力がVにつながって いる場合) 電磁石が作動し、 出力に電圧が発生する。

98

また、リレーの入力元はスイッチである必要はなく、 出力先も電球である必要は ない。 出力先として、別のリレーの入力に接続できる。 たとえば、こんな具合だ。

V <W>

これらのリレーは、カスケード接続されているといわれる。 スイッチを入れる と、1つ目のリレーが作動し、2つ目のリレーに電圧が供給される。 すると2つ 目のリレーが作動し、 電球が点灯する。

V V V

リレー同士の接続は、論理ゲートを作る上で重要である。

2つのスイッチを直列に接続できるように、 2つのリレーも直列に接続できる。

第8章 リレーとゲート

www

さて、ここに2つのリレーと2つのスイッチが用意されている。 上のリレー の出力は、下のリレーに電圧を供給する。 もうおわかりのように、 両方のスイッ チが開いているとき、 電球は点灯しない。 上のスイッチを閉じてみよう。

V <W>

99

それでも電球が点灯しないのは、下のスイッチが開いたままで、そちらのリレー が作動していないからだ。 上のスイッチを開けて、 下のスイッチを閉めてみよう。

V V V

これでも電球は点灯しない。 1つ目のリレーが作動していないので、 電流が電 球まで届かないのだ。 電球を点灯させるためには、 両方のスイッチを閉じなけれ ばならない。

100

8章 リレーとゲート

と www

(A)

これで両方のリレーが作動して、V、電球、 グランドに電流が流れるように なった。

第6章で見た2つのスイッチの直列接続と同様に、この2つのリレーはちょっ とした論理を実行する。 両方のリレーがトリガー [入力] された場合のみ、 電球 が点灯する。 この直列に配線された2つのリレーは、ブール論理の AND 演算 を行うため、 AND ゲートと呼ばれる。

電気技師は、面倒な描画を避けるため、 AND ゲートを表す特別な記号を用い る。その記号を次に示す。

人力

出力

これは、6つある基本的な論理ゲートの最初 [1番目の記号] となる。 AND ゲー トは2つの入力と1つの出力を持つ。 左側が入力、 右側が出力になるように描 かれている AND ゲートをよく目にすることになるだろう。 その理由は、左から 右に読むことに慣れている人は、 電気回路図も左から右に読むのが好きだから

|101

だ。 しかし、 AND ゲートは、上、右、下のどこから入力がくるように描いても よい。

先ほどの、 2つのリレーを直列に接続した図をより簡単に表すと、次のように なる。

V <W>

このAND ゲートの記号は、 直列に接続された2つのリレーの代わりになる だけでなく、 一番上のリレーが電圧に接続され、 両方のリレーがグランドに接続 されていることに注意しよう。 ここでも、上のスイッチと (AND) 下のスイッ チの両方が閉じている場合にのみ、電球が点灯する。 これが､ AND ゲートと呼 ばれる理由だ。

電圧がない場合を0. 電圧がある場合を1とすると、 AND ゲートの出力は次 のように入力に依存する。

0 0 D 0 iD 0 1

直列に配線された2つのスイッチの場合と同様、 AND ゲートも次に示す小さ な表で説明できる。

102

第8章 リレーとゲート

AND 0 1 0 0 0 1 0 1

AND ゲートの入力はスイッチに接続されている必要はなく、 出力も電球に接 続されている必要はない。 1つ目のAND ゲートの出力先を2つ目のAND ゲー トの入力元にすることもできる。

V V www

この電球は、3つのスイッチがすべて閉じている場合のみ、 点灯する。 上の2 つのスイッチが閉じているときだけ、 1つ目のAND ゲートが電圧を出力し、同 時に3番目のスイッチが閉じているときだけ、 2つ目のAND ゲートから電圧が 出力される。

この構成は、次の記号で表すこともできる。

D

これは3入力 AND ゲートと呼ばれる。 すべての入力が1である場合のみ、出 力が1になる。 また、 さらに多くの入力を持つ AND ゲートも作成できる。

次に取り上げる論理ゲートは、次ページに示すように2つのリレーを並列に 配線したものだ。

103

104

V <W>

2つのリレーの出力が互いに接続されていることに注目してほしい。 この接続 された出力が電球に電力を供給する。 2つのリレーのどちらか1つだけスイッチ が閉じていれば、 電球は点灯する。 たとえば、 上のスイッチを閉じると電球が点 灯する。 電球は上のリレーから電源が供給されるからだ。

V

V www

第8章 リレーとゲート

同様に、上のスイッチは開けたまま、下のスイッチを閉じると、電球は点灯する。

www

また、両方のスイッチを閉じたときにも電球は点灯する。

V

105

これで、上のスイッチまたは下のスイッチを閉じたときに電球が点灯する回路 ができた。キーワードが 「または (or)」 なので、 これは OR ゲートと呼ばれる。 電気技師は OR ゲートに次のような記号を使う [2番目の記号] 。

入力 D ・出力

AND ゲートの記号と似ているが、入力側がORのOのように丸みを帯びて いるのが特徴である (覚えるのに便利かもしれない)。

OR ゲートは、2つの入力のどちらかに電圧がかかったときに電圧が出力され る。ここでも、電圧がない状態を0、 電圧がある状態を1とすると、 OR ゲート の4つの状態は次のようになる。

1

OR ゲートの出力を AND ゲートと同様に、 表にまとめてみよう。

OR 0 1 0 0 I 1 I

OR ゲートも、 2つより多くの入力を持てる。 そのようなゲートの出力は、い ずれかの入力が1であれば1となり、すべての入力が0のときのみ0 となる。 ここで紹介しているリレーは、 双投リレーと呼ばれる。 電圧がかかっていない 状態では、 上部の金属棒が1つの接点に触れていて、 電磁石で引き下げられる と別の接点につながる。 下側の接点を常開 (ノーマリーオープン) 出力と呼ぶ

106

第8章 リレーとゲート 107

(定 『常』 状態では 『開』 いている状態の接点なのでこう呼ばれる)。 今まで使っ ていたのはこれだが、 上側の接点を出力に使う常閉 (ノーマリークローズ) 出力 を考えることもできる。 この上側の接点を使うと、リレーの出力が反転する。 入 カスイッチが開いているときに、電球が点灯するわけだ。

www

入力スイッチを閉じると、 電球が消灯する。

V

このように配線されたリレーをインバーターと呼ぶ。 インバーターは次の記号 で表現される [3番目の記号]。

108

入力 出力

0 (電圧なし) を (電圧あり) に反転したり、その逆を行うので、 インバー ター [反転装置] と呼ばれる。

0

これは、ブール論理の NOT 演算子を実現したものだ。

このインバーターを見た人からたまに、「入力に電圧がないのに、どうして出 力に電圧があるのですか、 その電圧はどこから来ているのですか?」 と聞かれる ことがある。 インバーターは実際には、 電圧に接続されたリレーであることを覚 えておこう。

インバーター AND ゲート、 OR ゲートがあれば、 ほしい子猫を選択できる コントロールパネルの配線が可能になる。 パネルを再掲しよう。

Dream Kitty F B N W T P M U PP Control Panel Meow

まずは、スイッチから始めよう。 最初のスイッチは、メスの場合は閉 (オン)、 オスの場合は開 (オフ) だ。 こうして、私たちがFとMと呼ぶ2つの信号を、 次のように生成できる。

第8章 リレーとゲート

V

F

・M

Fが1のとき、Mは0になり、 その逆も成り立つ。 同様に、 第2スイッチは、 去勢済みの子猫には閉、 未去勢の子猫には開となる。

V N

残りの3つのスイッチで、黒、白、 茶トラの3色を選択する。 ここでは、 3つ とも電圧に接続されている。

V W

ゲートとインバーターの接続方法には、いくつかの簡単なルールがある。 ある ゲート(またはインバーター) の出力は、1つまたは複数の他のゲート(または インバーター)の入力にできる。 ただし、 2つ以上のゲート(またはインバー ター)の出力を互いに接続してはならない。 子猫選びの表現を簡略にしたものを思い出そう。

(N × ((M × (W + T)) + (F × (1-W)))) +B

この式の+ 記号1つに対して、 回路にOR ゲートが1つあるはずだ。 また、 すべての× 記号に対して、 AND ゲートが1つある。

109

110

曲

N M B

回路図の左端には、 縦に記号が並んでいる。 式に登場する記号と同じ順番に なっている。この回路は、これまでに示した3種類の記号でできている。 (1W) の部分にインバーターを使用していることに注目しよう。

これを見て、 「とんでもない数のリレーだ」と思うかも知れない。 確かにその 通りだ。 リレーはAND ゲートとOR ゲートに2個ずつ、 インバーターに1個 ずつ搭載されている。 しかし、この先の章ではもっと多くのリレーを見ることに なるだろう。 実際にリレーを買ってきて家で配線する必要がないのはありがたい ことだ。

標準的な論理ゲートは6つあると前述した。 すでに3つは見てきたので、次か らは残りのゲートの番だ。 最初の2つは、 インバーターに使用したリレーの「常 閉」 出力を使用する。 この常閉出力は、 リレーが非作動状態であるときに電圧が 出力される。 たとえば、 次の構成は、1つ目のリレーからの出力が2つ目のリ レーに電力を供給している。 両方の入力がオフの状態になると、 電球が点灯する。

8章 リレーとゲート 111

www

上部のスイッチを閉じると、 電球は消灯する。

V V <W>

112

2つ目のリレーに電力が供給されなくなったので消灯したわけだ。 同様に、 上 のスイッチが開いていても下のスイッチが閉じていれば、 電球は消灯する。

V V <W>

そして、 両方のスイッチが閉じているときにも、電球は消灯する。

V V V

第8章 リレーとゲート

この動作は、 OR ゲートの動作と正反対だ。 この論理ゲートは NOT OR、 あ るいは、より簡単に NOR と呼ばれる。 NOR ゲートを表す記号は以下の通りで ある [4番目の記号。

入力 ・出力

出力に小さな円がある以外は、 OR の記号と同じである。 この小さな円は反転を 意味する。NOR は、 OR ゲートのあとにインバーターが続いたものと同じなのだ。

NOR ゲートの出力をまとめたのが次の表である。

NOR 0 1 0 1 0 1 0 0

OR ゲートは、2つの入力のどちらかが1であれば1、 両方が0であれば 0 だった。 しかし、この表は、その逆の結果を示している。 2つのリレーを配線する、 さらに別の方法を紹介しよう。

113

114

www

この場合、2つの出力が接続されていて OR 構成と似ているが、 OR とは別の 側の接点を使用している。 そのため、 両方のスイッチが開いているとき、 電球は 点灯する。

下側のリレーから電力を得られるので、上側のスイッチだけを閉じても電球は 点灯したままだ。

8章 リレーとゲート

www

同様に、下側のスイッチだけを閉じても電球が点灯する。 上側のリレーから電 力を得ているからだ。 A

V V www

115

116

両方のスイッチを閉じてはじめて、電球が消える。

V V <W>

この動作は、 AND ゲートの動作と全く逆である。 この論理ゲートは NOT AND、 あるいは、より簡単に NAND と呼ばれる。 [元々英語にある] NOR とは異 なり、 NAND という言葉は、 このタイプの論理を説明するために特別に作られ たものだ。 この言葉が生まれたのは1958年である。

NAND ゲートは ANDゲートと同じように描かれるが、 出力側に円があり、 出力が AND ゲートの反転であることを意味する [5番目の記号。

入力 ・出力

NAND ゲートは次のように動作する。

NAND 0 1 0 1 1 1 0

第8章 リレーとゲート

117

AND ゲートの出力は、両方の入力が1である場合のみ1となり、 それ以外は 0 となることを思い出そう。 NAND ゲートの出力はその逆となる。

ここまでで、 2入力1出力を持つリレーの配線方法を4種類見てきた。各構成 の動作は微妙に異なっている。 リレーを描いたり描き直したりするのを避けるた めに、論理ゲートと呼ぶものを導入し、 電気技師が使うのと同じ記号で表現する ことにしよう。論理ゲートの出力は入力に依存する。 以下にまとめよう。

AND 0 1 0 0 0 1 0 1 OR 0 1 0 0 1 1 1 1 D-

NAND 0

1

0

1

1

1

0

1

インバーターは次の記号だった。

Da

NOR

0

1

0

1

0

0

0

1

118

インバーターは信号を0から1へ、 または1から0へと反転させる。 最後を飾るのが1つだけのリレーで構成される以下の回路だ。

www

これはバッファと呼ばれ、 次の記号で表現する [6番目の記号]。

出力

インバーターと同じマークだが、 小さな円がない。 バッファはほとんど何もし ないことが特徴だ。 バッファの出力は入力と同じになる。

0 0 1

入力信号が弱いとき、 このバッファが役に立つ。 そもそも、 電信のためにリ レーが発明されたのは、 増幅が目的だったことを思い出そう。 現実の論理回路で は、1つの出力を多くの入力に接続することがある。 ファンアウトと呼ばれるも ので、結果として各入力での信号が小さくなってしまう。 バッファはこの信号を 増幅してくれる。 あるいは、 バッファを使用して信号をわずかに遅延させること もできる。 これが可能なのは、リレーが作動するまでにわずかな時間(1秒の何 分の1) を必要とするからだ。

8章 リレーとゲート

この先、本書ではリレーの記号はほとんど出てこない。 その代わり、 バッファ、 インバーター、4つの基本的な2入力論理ゲート、 そしてこれらの論理ゲートか ら作られるより高度な回路が登場する。 もちろん、 ほかの部品もすべてリレーか ら作られているが、実はもうリレーを見る必要はない。

本章の冒頭で、ほしい子猫を選択できる小さなコントロールパネルを紹介し た。黒猫、白猫、 茶トラ猫のスイッチはあったが、黒猫、 白猫、 茶トラ猫以外の 色に対応するスイッチはなかった。 しかしそれは、3つのインバーターと3入力 のAND ゲートで作ることができる信号だ。

B W T

3つの入力は反転して AND ゲートの入力となる。 B、 W、 Tがすべて0 のとき だけ、 AND ゲートのすべての入力が1になり、 出力が1になる。 インバーター抜きで同様の機能が描かれる場合もある。

AND ゲートの入力に小さな円があることに注目しよう。 小さな丸印は、そこで 信号が反転することを意味していて、 0 (電圧なし) が 1 (電圧あり)になったり、 その逆が起きたりする。

今回紹介した6つの論理ゲートから1つだけ選ばなければならないなら、 NAND か NORのどちらかを選ぼう。 NAND または NOR を使って、ほかのす べての論理ゲートを作れるからだ。 たとえば、以下に示すのは、NAND ゲート の入力をつなげてインバーターを作る方法だ。

|119

そのインバーターを別のNAND ゲートの出力に使えば、 AND ゲートができ る。 NAND ゲートからOR ゲートを作るなんて、最初はありえないように思え るが、 実は可能だ。 なぜなら、 すべての入力を反転させた AND ゲートは、 NOR ゲートと全く振る舞いになるからだ。

DD

同様に、2つの入力を反転させたOR ゲートは、 NAND ゲートと等価である。

= DD

両方の入力が1のときだけ、 出力が0になる。

この2組の等価回路は、ドモルガンの法則を電気的に実現したものだ。 オー ガスタス・ド・モルガンもビクトリア朝時代の数学者で、 ブールより9歳年上 である。 その著書 『形式論理学 (Formal Logic)』 は、 ブールの 『論理の数学的分 析―演繹的推論の計算に関する試論』 と全く同じ日 (1847年) に出版されてい るという話が伝わっている)。 ブールは実際、ドモルガンともう1人のイギ リス人数学者との間で繰り広げられていた、 盗作をめぐる抗争に触発されて論理 学を研究するようになったのだ (ド・モルガンの無罪は歴史的に証明されてい る)。 ド・モルガンも、 非常に早い段階からブールの洞察力の重要性を認識して いた。 彼は私心なくブールを励まして助けたが、 今日では有名な法則を除いて は、悲しいことにほとんど忘れられている。 れる。

ドモルガンの法則は、最も簡潔には次のように表現さ

AxB=A + B A+B=A×B

A、Bは2つのブール被演算子だ。 上に描かれたバーは反転を意味する。 最初 の式では、 AとBをそれぞれ反転させ、ブール演算子の AND で結合している。 これは、2つの被演算子をブール演算子のOR で結合し、その結果を反転させる

120

8章 リレーとゲート

ことと同じだ(この結果はNOR)。 これは日常会話でも通用する。 「雨が降って 「いない」 かつ (AND) 「雪が降っていない」 ならば、 「雨または OR) 雪では ない。

2番目の式では、2つの被演算子を反転させた後、 ブール演算子 OR で結合し ている。これは、ブール演算子 AND で被演算子を結合し、 反転させたものと同 じだ (これは NAND)。 自分が「大きくない」 または (OR) 「強くない」 ならば、 「大きくかつ (AND) 強い」 ことはない。 ド・モルガンの法則は、 ブール式を簡 略化するための重要なツール [道具] である、つまり回路を簡略化するためのツー ルでもある。 歴史的に見れば、 クロード・シャノンの論文が電気技師たちに与え たものの本質は、このツールだったのだ。 しかし、 本書では回路の簡略化にはあ まりこだわらない。 できるだけシンプルに物事を動かすことよりも、まずは物事 を動かすことを重視しよう。

次に紹介する大きなテーマは、論理ゲートだけで実装されたデジタル加算機 だ。 だがそのプロジェクトに入る前に、 小学校に戻って、 数え方を復習する必要 がある。 加算機はそれまで数章ほど、 おあずけとしよう。

121



第 9 章

私たちが使う10種類の数字

言語はコードにすぎないという考え方は、すんなり受け入れられるだろう。 私 たちの多くは、 高校時代に多少なりとも外国語を学ぼうとしたはずだ。 そのため 英語で cat [猫] と呼ばれる動物が、ほかの言語では gato, chat, Katze、 Ka、yára となるのに納得できるだろう。 кош

しかし、数字については、 文化的な違いはあまりないようだ。 私たちが話す言 語や数字の発音にはかかわらず、この地球上で出会う可能性のあるほとんどの人 たちが、 同じように数字を書く。

1 2 3 4 5 6 7 8 9 10

数学が 「世界共通語」 と呼ばれるのには、理由がありそうだ。 数字は、私たちが日常的に扱うコードの中で、最も抽象的なものであることは 言うまでもない。 次の数字を見たとき、

3

これをすぐに何かと関連づける必要はない。 私たちは、3個のリンゴやほかの3 個の何かを想像するかもしれないし、文脈に応じて、 子どもの誕生日、テレビの チャンネル、ホッケーのスコア、ケーキのレシピの小麦粉のカップ数、あるいは 3月を指したりもする。 そもそも私たちの数字は抽象的なので、数字だけから 「この数のリンゴがある」 と理解する方が難しい。 次のリンゴの数を

124

必ずしも以下の記号で表す必要はない。

3

本章と次章の多くを費やして、以下に示す複数のリンゴ

を、次のようにも書けることを理解していこう。

11

そこまでたどり着ければ、数字を電気回路の中、ひいてはコンピュータの中で 表現することが可能になる。 その前に身近な数字の仕組みを理解して、飛躍に向 けた準備をしよう。

人類が初めて数を数え始めたときから、私たちは手の指を使ってきた。その結 果、 ほとんどの文明が10を基調とした記数法を築いてきた。 唯一の重要な例外 は、52060 を基調に作られたいくつかの記数法である (古代バビロニアで 使われた60 を基本とする記数法が、 秒や分という時間の単位に残っている)。 人の手との関係を除けば、私たちの10を基調とした記数法に特別な意味はない。 もし人類が8本指や12本指で進化していたら、 私たちの数え方は少し違ってい ただろう。 Digit [デジット] という言葉が、 数字を指すだけでなく、 手の指や足の 指を意味することもあることや、 five [5] と fist [拳] の語源が似ているのも偶然 ではない。

その意味で、10進法あるいはデシマル (ラテン語で10を意味する) の利用は 完全に恣意的だ。しかし、 私たちは10を基調にした数字に、 まるで魔法のよう な意味を持たせ、特別な名前をつけている。 10年は decade [ディケイド]、 10

第9章 私たちが使う10種類の数字

decade は century [センチュリー (世紀)]、 そして10世紀は millennium [ミレニアム (千年紀)] だ。 千の千倍は百万、 百万の千倍は十億となる。 これらの数字はすべ て10のべき乗である。

10' =10 10²=100 103=1,000 (thousand、 千) 10=10,000 10' =100,000 10°=1,000,000 (million、 百万) 107 10,000,000 108 100,000,000 10°=1,000,000,000 (billion、 十億)

歴史家の多くは、 数字は元々、 人や所有物、 商取引などを数えるために発明さ れたと考えている。 たとえば、 アヒルを4羽飼っている人は、 4羽のアヒルの絵 でそれを記録するかもしれない。

M

アヒルを描くのが仕事だった人はやがて、 「なんでアヒルを4羽も描かなきゃ いけないんだ?」 と考えた。 「なぜ、 1羽のアヒルを描いた横に、それが4羽い ることを (まあ何でもいいけど) 適当なひっかき傷で示せないのだろう?」

そして、誰かが27 羽のアヒルを飼う日がきて、ひっかき傷の数がとんでもな いことになる。

125

さらに、誰かが「もっといい方法があるはずだ」 と言い、 記数法が誕生したのだ。 初期の記数法のうち、ローマ数字だけが今でも一般的に使われている。 ローマ 数字は、 置時計や腕時計の文字盤に書かれていたり、 記念碑や像の日付に使われ ている。 また、 本の章やページに使われていたり、 アウトラインの項目に使われ ていたりもする。 迷惑なことに、 映画の著作権表示にも使われている。「この映 画は何年に作られたものですか?」という質問に答えるには、クレジット表示の 末尾に流れる 「MCMLIII」 を素早く解読する必要があるのだ。 ローマ数字で書かれた27 羽のアヒルは

次のようになる。

XXVII

考え方は簡単だ。 Xは10個のひっかき傷 Vは5個のひっかき傷を意味する。 現在も残っているローマ数字の記号は、以下の通りだ。

IVX LCD M

Iは1を意味する。 これは、ひっかき傷、 または1本指に由来するものなのだ ろう。 手を表す記号であろう V は、 5を表す。 Vが2つで Xになり、10を意 味する。 Lは50だ。 Cはラテン語で100を意味する centum [センタム] という 言葉に由来する。 Dは500だ。 最後に、 Mはラテン語で 1000 を表す mille [ミ [ル] に由来する。 左右のステップ (2歩) を1000回繰り返せば、 約 1mile [マイ [ル] 歩くことになる。

納得できないかもしれないが、 ローマ数字は長い間、 加算や減算がしやすいも のとされ、ヨーロッパでは簿記用として生き残ってきた。 実際、 2つのローマ数 字を足すときは、 両方の数字の記号をすべて組み合わせ、 いくつかのルールで結 果を単純化するだけだ。 Iが5つでV、Vが2つで X, Xが5つでL、 といっ た具合に。

126

第9章 私たちが使う10種類の数字

127

しかし、ローマ数字の乗算や除算は難しい。 ほかの多くの初期の記数法 (古代 ギリシャのものなど) も、 洗練されたやり方で数字を扱うのには適していない。 こんにち 古代ギリシャ人は、今日でも高校でほぼ変わらずに教えられているほど素晴らし い幾何学を開発したが、 代数学では知られていない。

私たちが現在使っている記数法は、 ヒンドゥーアラビア式またはインドアラビ ア式と呼ばれる。 これはインドが起源だが、 アラブの数学者たちによってヨー ロッパにもたらされた。 特に有名なのはペルシャの数学者ムハンマド・ブン・ ムーサー・アル=フワーリズミー(この人物の名前からアルゴリズムという言葉 が生まれた) で、 彼は西暦820年頃にヒンドゥー記数法を使って代数学の本を 書いた。 ラテン語への翻訳は西暦1145年頃から行われ、 ヨーロッパでのローマ 数字から現在のヒンドゥーアラビア記数法への移行を早めた。

ヒンドゥーアラビア記数法が、それまでの記数法と異なる点は3つある。

●ヒンドゥーアラビア記数法には位取りがある、 すなわち、 ある数字が数のど こにあるかによって異なる量を表す。 数のどこに数字が現れるかは、実は数 字そのものよりも重要な意味を持つ! 100 も 1,000,000も1が1つしかな いが、100万が100よりずっと大きいことはご存知の通りである。

●ほぼすべての初期の記数法には、ヒンドゥーアラビア記数法には含まれてい ないものがある。 それは数字の10を表す特別なシンボルだ。 私たちの記数 法には、 10 を表す特別な記号は存在しない。

・一方、 初期の記数法には、ヒンドゥーアラビア記数法が備えるあるものが欠 けていて、それは10を表す記号よりもはるかに重要であることがわかって いる。それがゼロ (0) だ。

そう、 ゼロなのだ。 この控え目なゼロは、間違いなく数字と数学の歴史で最も 重要な発明の1つだ。 ゼロがあればこそ、25と205 と250の違いをすぐに確認 でき、 位取り記数法がうまく機能する。 またゼロは、位取りをしない記数法では 厄介な多くの数学的演算、 特に乗算と除算を容易にする。

ヒンドゥーアラビア数字の発音の仕方に、 そのすべての仕組みが表れている。 4825 を例にしよう。 私たちは 「4せん、 8ぴゃく、 2じゅう、 5」 と発話する。 すなわち、

128

4つの1000 8つの100 2つの10、 そして 5ということだ。

あるいは、次のように要素を記述することもできる。

4825 4000+800+20 +5

あるいはさらに分解して、次のように書くこともできる。

4825 4 x 1000 + 8 × 100 + 2 x 10 + 5 × 1

10のべき乗を用いると、 次のように書ける。

48254 x 103 + 8 x 102 + 2 × 10' + 5 × 10°

どんな数も0乗すると1になることを忘れないようにしよう。 複数桁の数字の各位置は、 特定の意味を持つ。 次に示す7つの箱は、 0から 9,999,999 までの好きな数字を表現できる。

第9章 私たちが使う10種類の数字

129

一十百千万十百

の位

の位

の位

の位

の位

万の位

万の位

箱の各位置は10のべき乗に対応しているので、 10を表す特別な記号は不要 である。なぜなら1を右から2番目の箱に入れて、 0 を右端の箱に入れればそれ で10を表現できるからだ。

とても素晴らしいことに、 小数点の右側の桁で示される端数も、同じパターン で表せる。 たとえば、 42,705.684 という数は次のようになる。

4 × 10,000 +

2 x 1,000 +

7 × 100 +

0 x 10 +

5x1+

6 ÷ 10 +

8 100+

4 1,000

なお最後の3行は、乗算ではなく、 除算を使うことに注目しよう。 この数字 は、次のように除算なしで表すこともできる。

4 × 10,000 +

2 x 1,000 +

7 × 100 +

0 x 10 +

5 x 1 +

6 x 0.1 +

8 x 0.01 +

4 x 0.001

あるいは、10のべき乗を用いることで、次のようにも表せる。

4 x 10* +

2 x 103 +

7 × 102 +

0 × 10' +

5 × 10° +

6 × 10 ' +

8 × 10 -2 +

4 × 10-3

指数がゼロを経由して負の数になっていく点に注目してほしい。 私たちの記数 法はとても身近なので、 その根本的な構造の優雅さを認識する機会はあまりない のだ。

私たちは、 3 +4が7であることは知っている。 同様に、 30 + 40は70、 300 + 400は700, 3,000 + 4,000 は 7,000 になる。 これがヒンドゥーアラビ ア記数法の素晴らしさだ。 任意の長さの10進数の加算をするときは、問題を各 ステップに分解した手順に従う。 各ステップは、 1桁の数字の組を足すだけで、 複雑ではない。 そのため、 以前誰かに無理やり、 加算の表を暗記させられたの だ。

130

第 9 章 私たちが使う10種類の数字

+ 0 1 2 0 0 1 2 1 1 2 3 334 4 5 6 7 8 9 4 5 56 6 7 8 9 7 8 9 10 2 2 3 4 5 6 7 8 9 10 11 3 3 4 5 6 7 8 9 10 11 12 4 4 5 6 7 8 9 10 11 12 13 5 5 6 7 8 9 10 11 12 13 14 6 6 7 8 9 10 11 12 13 14 15 7 7 8 9 10 11 12 13 14 15 16 8 8 9 10 11 12 13 14 15 16 17 9 9 10 11 12 13 14 15 16 17 18

まず上段と左の列から、足したい2つの数字を探そう。 そこから下と横にた どって、そこに書かれた和を読む。 たとえば、4+6の場合は10になる。

を踏むものの、そ れでも問題を分解して、 1桁の数同士の加算や乗算以上の複雑なことは必要ない。 小学生の頃には、 乗算の表も覚えていたはずだ。

同様に、2つの小数を掛け合わせる場合は、やや複雑な手順

0 1 2 3 4 5 6 7 0 0 0 0 0 0 0 1 2 3 4 5 6 7 8 2345678 00000000 1 2 3 4 06 5 17 0 7 808 9 0 9 69 46 8 12 9246 10 15 12 18 14 21 16 24 8262222 10 12 14 16 18 12 15 18 21 24 27 16 20 24 28 32 36 20 25 30 35 40 45 24 30 36 42 48 54 35 42 49 56 63 32 40 48 56 64 72 9 0 9 18 27 36 45 54 63 72 81

位取り記数法の優れている点は、それがいかにうまく機能するかではなく、 10を基準としない記数法に対していかにうまく機能するかだ。 私たちの記数法

131

132

は、必ずしもすべての人に適しているわけではない。 10 を基準とする記数法の 大きな問題は、アニメのキャラクターとの関連性がないことだ。 多くのアニメの キャラクターは、それぞれの手 (または前足) の指が4本しかないため、8を基 準とした記数法を好む。

そして面白いことに、私たちが知っている 10進数に関する知識の多くは、ア ニメに出てくる友人たちに適した記数法にも応用できる。

第 10 章 10 に代わる数

10は、私たち人間にとって非常に重要な数だ。 10 は、 私たちの多くが備える 手の指と足の指それぞれの本数だからである。 指は数を数えるのに便利なので、 私たち人間は、 10 という数字に基づいた記数法を築いてきた。

2 3 4 789 6 10

第9章で述べたように、 私たちが普段使っている記数法をベース10、あるい は10進法と呼ぶ。 10進法は、私たちにとってあまりにも自然なので、 その代 替案を考えるのは難しい。 実際、 10という数字を見ると、次のように並んでい るアヒルを指すと考えがちだ。

10 = RR

134

しかし、 10 という数字がこれらのアヒルを指すのは、 アヒルの数が私たちの 指の数と同じだからにほかならない。 もし人間の指の数が違っていたら、数え方 も違っていただろうし、 10 も別の意味になっていただろう。 同じ数字の10が、 次の数のアヒルを指していたかもしれない。

10 =

あるいはこうだったかもしれない。

10 =

それともこうだったかも。

10=33

こうして10が2羽のアヒルを意味するようになったなら、 スイッチや電線、 電 球がどのように数字を表現するのか、そしてリレーや論理ゲート (さらにはコン ピュータ) が、 どのように数字を操作するのかを調べる準備が整ったことになる。

もし人間の手の指が、 アニメのキャラクターのように、 4本しかなかったらど うだろう?私たちはおそらく、 10 を基準にした記数法を考えもしなかっただろ う。 そして、 記数法は8を基準にするのが当然で、 自然で、 賢明で、必然的で、 議論の余地もなく、 紛れもなく適切だと考えたことだろう。 これは8進法、 ま たはベース8と呼ばれる。

もし、私たちの記数法が10ではなく8を基準に構成されていたら、 次の記号 は必要なかったはずだ。

9

第10章 10 に代わる数

この記号をアニメのキャラクターに見せたら、「何それ? 何に使うの?」 とい う反応が返ってくるだろう。 さらに少し考えてみると、 次のような記号も必要な いことがわかる。

8

10進法には 10 を表す特別な記号がないのだから、 8進法にも8を表す特別な記 号はない。

10進法の数え方は、0、 1、2、3、4、5、6、7、8、9、 そして10だ。 では8 進法の数え方は、0、 1、2、3、4、5、6、7、 そして次は何だろう? その先にた だ置くための記号はない。 意味があるのは10だけで、 それが正しい表現になる。 8進法では、7の次の数字は10になる。 でも、 この10は、 人間の指の数を意味 しているわけではない。 8進法では、 10はアニメのキャラクターが持つ手の指 の数を指す。

2 6 10

そして、4本指の足で数え続けることができる。

135

12 13 14 15 16 17 11 20

10進法以外の記数法を扱う場合、 10のような数字はイチゼロと発音すれば、 混乱を避けることができる。 同様に、 13はイチサン、 20 はニイゼロと発音する。 より正確に曖昧さを本当に避けるには、 8進法でイチサンとか8進法でニイゼロ と言うこともできる。

さて、手足の指が尽きても、8進数で数え続けることはできる。 基本的には 10進法で数えるのと同じだが、 8や9が含まれる数をすべてスキップすること になる。

0, 1, 2, 3, 4, 5, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 40, 41, 42, 43, 44, 45, 46, 47, 50, 51, 52, 53, 54, 55, 56, 57, 60, 61, 62, 63, 64, 65, 66, 67, 70, 71, 72, 73, 74, 75, 76, 77, 100...

最後の数字は、 イチゼロゼロと発音する。 これはアニメのキャラクターの指の 数を自乗したものだ。

私たちは、 ずっと10進法そして10進数 [10進法で書かれた数] に慣れ親しんで きたために、ある特定の数字の列を見ると現実世界の特定の数に結びつけてしま う。 異なる記数法でカウントすることは、全く別の世界に入るようなものだ。 こ こでは、8進数 [8進法で書かれた数] の例をいくつか見てみよう。

白雪姫が出会う小人の数は7人で、 これは10進数と同じ。 アニメのキャラクターが持つ指の本数は10本。 ベートーヴェンが書いた交響曲の数は11曲。

136

第 10 章 10 に代わる数

人間が持っている指の数は12本。 1年間の月数は14か月。

あなたが、 これらの8進数を頭の中で10進数に変換しているのに気づいたのな ら、素晴らしいことだ。 いい練習になる。 1から始まる8進数2桁の数字は、 10進数に換算した場合、 8+2桁目の数になる。 たとえば8進法の月数は 14 なので、 10 進数では8+4で12となる。 続けよう。 いずれも8進数で表現し た場合には、

「パン屋の1ダース」 [10進数で13のこと。 パン屋はおまけで1個つける習慣が あったことから] は 15個。 2週間の日数は16日。 「スイート」 バースディは20歳の誕生日。 1日の時間数は30時間。 ラテン語のアルファベットの文字数は32文字。

2桁の8進数が1以外で始まるときには、 10 進数への変換は少し違ったやり方 になる。 この場合、 1桁目に8を掛けて2桁目を足す必要がある。 アルファベッ トの文字数は 8 進数で32なので、10進数では3×8 ( = 24) + 2 で 26 となる。

1 クォートは 40 液量オンス [1 クォートは10進数で32液量オンス] トランプの枚数は、4×15の64枚 [10進数では4×1352枚] チェス盤のマスの数は、 10 × 10 で100マス。

進数では、チェス盤のマスの数は8×8 で64 である。

なお 10

アメリカンフットボールのフィールドのヤード数は144ヤード。 ウィンブルドンの女子シングルスの先発選手の数は200人。 8ドット点字の文字数は400文字。

このリストには、 100, 200, 400 といった、 素敵なきりのよい数字がいくつ

137

138

か含まれる。 ここでいう素敵なきりのよい数字という言葉は、 末尾にゼロがいく つか続く数を意味する。 10 進数の末尾に0が2つ続く場合、 その数字が100 (10x10) の倍数であることを意味する。 8 進数の場合でも、 末尾に0が2つ あると100の倍数という意味になるが、 それは8進数の100、 つまり 10進数で は 64 に相当する。 なお、 ウィンブルドンの女子シングルスの先発選手の数は 10進数で128人、 8ドット点字の文字数は10進数で256文字である。

本書の最初の3章では、バイナリーコードと2のべき乗の関係を探った。 合 計4つのドットとダッシュで表現できるモールスコードの種類は、2の4乗、 つ まり16種類だ。 6ドット点字のコード数は、2の6乗、 つまり 64個。8ドット 点字のコード数は、2の8乗、 つまり256個まで増える。 2のべき乗に別の2 のべき乗をかけると、 結果も必ず2 のべき乗になる。

次の表は、2のべき乗の最初の13個を10進数と8進数で表現したものだ。

2 のべき乗

10進数

8 進数

1

222222222222 20 25 28

2

4

1

2

4

8

10

16

212

20

32

40

64

128

100

200

256

512

400

1000

1024

2048

2000

4000

4096

10000

第10章 10 に代わる数

|139

8は2のべき乗なので、 8進数の欄には素敵なきりのよい数字がたくさんある。 ここでは、 8 進数とバイナリーコードの密接な関係が示唆されている。 8進法と10進法は、 構造的に異なるわけではない。 ただ、 細部が違うだけだ。 たとえば、 8 進数の各桁は、 8 のべき乗を掛けた数になる。

1の位 8の位 64の位 512の位 4096の位 32768の位

したがって、 3725 という8 進数は、次のように分解できる。

37253000+ 700+20 +5

この数字は、各々の数字に 8 のべき乗を掛けたものとしても表現できる。

37253 x 1000+ 7 × 100 + 2 x 10 + 150+ 15×1

別の書き方も紹介しよう。

3725 = 3 × 8' +

7 x 82+

2 × 8' +

5 x 80

これを10進法で計算すると、 2005 になる。 このようにして8進数を 10 進数 に変換できる。

8 進数の加算と乗算は、10進数の加算と乗算と同じように行える。 実質的な

140

違いは、各々の桁の加算と乗算に異なる表を使うことだけだ。 8進数の加算表を 以下に示す。

+ 0 1 2 3 4 5 6 7 0 0 1 2 3 4 5 1 1 2 3 4 5 6 2 2 3 4 5 6 7 3 3 4 5 6 7 4 4 5 6 7 10 11 5 5 6 6 67 7 10 11 10 11 12 7 7 10 11 12 13 O1234 10 13 14 111111 6 7 10 121 7 10 12 13 14 15 14 15 16

たとえば、 5 + 7 = 14 となる。 長い8進数も10進数と同じように足すこと ができる。 次に示す3桁の8進数の加算で、 一番右の桁を見てみよう、 ここは5 + 3 = 10 となる。 0 を置き、 1を繰り上げよう。

135 +643 1000

右から2番目の桁では、繰り上がった1に3+4で10になる。 再びここに0 を置き、 1を繰り上げよう。 右から3桁目 繰り上がったに1+6で10にな る。 加算の結果は1000だ。

同じように乗算を見てみよう。 2の2倍は8進数では4のままだ。 でも、 3の 3倍は9ではない。 では、 どうなるんだろう? 実は、3の3倍は 11 になる。 8 進数の乗算表は次のようになる。

第10章 10 に代わる数

0 1 2 3 4 5 6 7 10 12 14 16 303 61141235 404 10 14 20 17 24 22 30 505121724364 6 7 07 6 14 16 22 25 30 34 36 43 44 52 34 52 61 1 202460246 -0-234567 000000000

この表から、 10進数で24の4×6は8進数では30 となることがわかる。 8進数は10進数と同様、れっきとした記数法であることがわかった。 もっと 飛躍してみよう。 アニメキャラクターの記数法ができたので、今度はロブスター にふさわしい記数法を開発しよう。 正確にいえばロブスターに指はないが、 Homarus americanus [アメリカンオマール]という種類のロブスターは、2本の 長い前脚の先にハサミを持つ。 このロブスターに適した記数法は、4進法、つま り4を基本とした記数法となる。

1 2

3 10

4進法での数え方は次のようになる。 0、 1、2、3、10、11、12、13、20、 21, 22, 23, 30, 31, 32, 33, 100, 101, 102, 103, 110, 111, 112, 113、120、 ...･･･という具合だ。

すぐにもっと大切な話題に移るので、4進法にあまり時間をかけるつもりはな い。 まあ、 4進数の各桁が4のべき乗に対応していることはわかるだろう。

141

142

1の位 4の位 16の位 64の位 256の位 1024の位

4 進数の31232 はこう書くことができる。

312323 x 10000 + 1 x 1000 + 2 x 100 + 3 x 10 + 2×1

各桁は4のべき乗をかけたものだ。

31232 3 x 44 +

1 × 43 +

2×42 +

3×4' +

2 x 4°

計算すると、 4進数の31232は10進数の878 と同じであることがわかる。 ここでもう一度飛躍しよう。 極端なジャンプだ。 今度は私たちがイルカで、数 を数えるのに、2つのヒレを使わなければならないとしよう。 これが、2進法 (binary [パイナリー]、 ラテン語で「2つずつの」を意味する "bini" に由来する) と呼ばれる2を基準とする記数法だ。 おそらくこの記数法には2種類の数字し かなく、それは0と1になるだろう。

ブール代数では1と0を使って、 True [真] または False [偽] Yes または No、 ほしい子猫またはそうでない子猫を表せることはすでに知っているはずだ。

第 10 章 10 に代わる数

143

同じ2種類の数字を使って、 数を数えることもできる。

ただ、0と1の1桁だけで仕事ができるわけではないし、 2進数に慣れるには 練習が必要だ。 大きな問題は、すぐに桁が足りなくなることである。 たとえば、 イルカがヒレを使って数を数える様子を示すと、

そう、 2進法では1の次の数字は10になる。 これにはびっくりするが、 本来 は驚くようなことではないはずだ。 どんな記数法を使っても、 1桁の数字を使い 尽くしたら、 2桁になった最初の数字は必ず10になる。 2進法では次のように 数えるのだ。

0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111, 10000, 10001...

これらの数字は大きく見えるかもしれないが、 実はそうでもない。 2進数は あっという間に大きくなるというよりも、 あっという間に長くなるといった方が 正確だ。

人間の頭の数は1。 イルカのヒレの数は 10。 大さじ1は小さじ 11。 正方形の辺の数は100。 人間の片手の指の数は 101。 昆虫の脚の本数は110。 1週間の日数は111。

八重奏団を構成する音楽家の数は1000。 野球の試合のイニング数は 1001。 カウボーイハットに関係するガロン数は 1010 [代表的なカウボーイハット にテン (10) ガロンハットがある]

こんな感じだ。

複数桁の2進数では、 桁の各位置が2のべき乗に対応する。

1の位 2の位 4の位 8の 16の位 32の位

つまり、1のあとにゼロだけが続く2進数の場合、 その数は2のべき乗という ことになる (続くゼロの数と同じべき乗となる)。この法則は次のように表せる。

2 のべき乗 10進数 8 進数 4進数 2進数 2º 1 1 2' 22 23 24 25 26 27 2" ♥ ã ã ã å ã ã ã ã ã å ≈≈ 1 1 2 2 2 10 4 4 10 100 8 10 20 1000 16 20 100 10000 32 40 200 100000 64 100 1000 1000000 128 200 2000 10000000 256 400 10000 100000000 29 512 1000 20000 1000000000 210 1024 2000 100000 10000000000 2" 2048 4000 200000 100000000000 212 4096 10000 1000000 1000000000000

144

第 10 章 10 に代わる数

145

目の前に2進数の101101011010 があるとしよう。 これは次のように書ける。

1011010110101 × 100000000000 +

0x 10000000000 +

1 x 1000000000 +

1 x 100000000+

0 x 10000000 +

1 x 1000000 +

0 x 100000 +

1 × 10000 +

1 × 1000 +

0 x 100 +

1 × 10+

0×1

同じ数を、2のべき乗を使って、もっと簡単に書ける。

101101011010 = 1 x 2" + 0 x 210 + 1 x 29+ 1 x 2 + 0 x 27 + 1 x 26+ 0 x 25 + 1 x 2 + 1 x 23 + 0 x 22+ 1 x 2' + 0 × 2º

各部分を10進数で足し上げると、 2048 + 512 + 256 + 64 + 16 +8 + 2

2906 となり、 これが2進数を10進数に換算したときの値となる。 2進数をより簡単に10進数に変換するには、次のテンプレートが役に立つ。

x128 x64 x32 x16 x8 x4 x2 x1 +

このテンプレートを使えば、2進数で8桁までの数字を変換できる。 桁数を増 やすのも容易だ。テンプレートを使うには、上部にある8つの箱に2進数の数 字を1桁ずつ入れていく。 8つの乗算を行い、その積を下部の8つの箱に入れ る。この8つの箱を足せば、答えが10進数で得られる。 以下は、 10010110の 10 進数換算値を求める例だ。

1 0 1 0 x128 x64 x32 x16 x8 x4 x2 x1 128+0+0+16+0+ 4 + 2 + 0 = 150

10進数から2進数への変換はこれほど簡単ではないが、 0から255までの10 進数を2進数に変換するテンプレートを紹介しよう。

+128 +64 +32 +16 +8 +4 +2 +1

変換は見た目以上に厄介だ。 まず、 左上の箱に対象の10進数全体 (ただし 255以下)を入れる。

150 +128 +64 +32 +16 +8 +4 +2 +1

146

第10章 10 に代わる数 147

その数を128で割って、 商と余りを求めよう。 たとえば150を128で割ると はになり、 余りは22になる。そして商を下部の最初の箱に、余りを上部の 次の箱に入れる。

150 22 +128 +64 +32 +16 +8 +4 +2 +]

今度は22を64で割るが、 22 は64より小さいので、 商は0となり、余りは 22 となる。 0を下部の2番目の箱に入れ、余りを上部の次の箱に入れる。

+128 +64 +32 +16 +8 +4 +2 +1

テンプレートに沿って同じように進めていこう。 それぞれの商は0か1のど ちらかになるので、 終了すると下部の箱には2進数の数字が並んで表示される。

150 6 2 0 +128 +64 +32 +16 +8 +4 +2 +1 0

150の2進数換算は10010110 となる。

このような10進数と2進数の変換は、確かに厄介だが、 実際に行う必要があ れば、Windows の電卓アプリにも、 そしてmacOSの電卓アプリにも、それを 行う 「プログラマーモード」 があるので安心だ。

初期のデジタルコンピュータでは、 2進数の使用は一般的ではなかった。 ごく 初期のコンピュータには、使い慣れた10進数を使うように設計製造されたもの がある。 イギリスの数学者チャールズ・バベッジ (1791-1871) が1830年代に 設計を始めた 「The Analytical Engine [解析機関]」は、歯車の位置関係を利用し

て 10 進数を記憶する機械だった (残念ながら彼はこの機械を実際に作ることは できなかった)。 ハーバード マークⅠ (1944年に初稼働) やエニアック (1946 年に稼働)など、初期の実運用されたデジタルコンピュータも10進数で動作す るように作られていた。 1960年代に製造されたIBMのコンピュータの中にも、 10 進数に基づいたアーキテクチャを持つものがあった。

しかし、デジタル革命を何よりも特徴づけてきたのは、 2進数による符号化 だった。 2進数の単純さは、 加算と乗算の基本操作に顕著に表れている。 ここが 本当に好まれる点だ。 もし、 暗記するものが次の表だけだったら、 どれだけ早く 加算をマスターできたかを、想像してみよう。

+ 0 1 0 0 1 1 1 10

この表を使って、 2つの2進数を足してみよう。

1100101 + 0110110 10011011

一番右の列から始めよう : 1 +0=1。 右から2列目 : 0 + 1 = 1。 右から3 列目 : 1+1=0で1が繰り上がる (キャリーされる)。 右から4列目 繰り上 がった(キャリーされた) を使って 1 +0+0=1。 右から5列目: 0 + 1 = 1。 右から6列目: 1+1=0で1が繰り上がる。 右から7列目 繰り上がった 1を使って1+1+0=0で、 1が繰り上がる。

乗算の表は加算の表よりもさらに単純だ。 乗算の2つの基本ルールに基づい て、すべてを導き出せるからだ。 すなわち、 0を掛けると0になり、 1 を掛ける と元のまま、 というルールだ。

148

第10章 10 に代わる数

X 0 1 0 0 0 1 0 1

ここでは、 10 進数の13 (2進数で1101) 10進数の11 (2進数で1011) の 乗算を見てみよう。 すべての手順をお見せするわけではないが、 10 進数の乗算 と同様の手順となる。

1101

x 1011

1101

1101

0000

1101

10001111

10進数で計算した結果は143になる。

2進数を扱う場合、 先行ゼロ (最初の1の左側にあるゼロ) をつけて数字を記 述することが多い。 たとえば、 11 ではなく 0011 のように、 だ。 数値の価値は 全く変わらない。 単に体裁上の問題だ。例として、最初の16個の2進数とそれ に等価な 10進数の値を示そう。

149

2進数

10進数

0000

0001

0

1

0010

2

3

0011

0100

0101

0110

5

0111

1000

1001

4

6

7

1010

8

9

1011

1100

1101

10

11

1110

1111

12

13

14

15

この2進数のリストを少し立ち止まって調べてみよう。 0と1で構成された4 つの縦の列を考え、 その中で0と1の数字が入れ替わりながら列を下っていく 様子に注目しよう。

●右端の桁 (列)では、0と1が交互に現れる。

●右から2番目の桁では、2つの0と2つの1が交互に並ぶ。

●その次の桁では、4つの0と4つの1が交互に現れる。

●次の桁 (左端の桁) では、8つの0と8つの1が交互に並ぶ。

これは非常に体系的だと思える。 実際、 とても整然としているので 2進数を 自動生成する回路を作ることができる。 これについては第17章で扱うつもりだ。 しかも、この最初の16個を繰り返し、 前に1をつけるだけで、 次の16個の 2進数を簡単に書くことができる。

150

第10章 10 に代わる数

151

2進数 10000 10001 10010 10011 10100 10101 10110 10111 11000 11001 11010 11011 11100 11101 29 11110 BERDARE22222222 10進数 16 17 18 19 20 21 23 24 25 26 27 28 30 11111 31

ここで、別の見方をしよう。 2進数で数える場合には、 右端の桁 (最下位桁と もいう)は0と1が交互にくる。 この桁が1から0に変化するたびに、右から 2番目の桁 (つまり次に大きい桁) 0から1、 または1から0に変化する。 よ 一般的には、 2進数の任意の桁が1から0に変化するたびに、 次に大きい桁も 0から1、 または1から0に変化する。

2進数はすぐに長くなってしまう。 たとえば、 2進数で1200万は、 101101110001101100000000 となる。 2進数をより簡潔に表すために、 8 進数 で表示する方法がある。 2進数の3桁が8進数の1桁に対応するため、このや り方は都合がよい。

2進数

8進数

000

001

0

1

2

3

010

011

100

101

4

5

110

111

6

7

たとえば、10進数の1200万に相当する長い2進数を、 右から3桁ずつのグ ループに分けて考えてみよう。

101 101 110 001 101 100 000 000

2進数3桁で構成される各グループは、それぞれ8進数1桁に対応する。

101 101 110 001 101 100 000 000 5 5 6 15 4 0 0

10進数の1200万は8進数では55615400 となる。 第12章ではもっと簡単 2進数の表現方法を紹介しよう。

記数法を2進数の0と1だけに減らしたことで、 私たちは行けるところまで たどり着いた。 原始的なひっかき傷に頼ることなく、 これ以上は単純にできな い。 ここで最も重要なのは、 2進数により算術と電気が一体化したことだ。 ス イッチ、 電線、 電球はすべて2進数の0と1を表現でき、 論理ゲートを加える ことで、これらの数字を操作できる。 これこそが、2進数がコンピュータと全面 的に関係している理由だ。

先ほど、3桁の2進数と8進数の対応を示す小さな表を示した。 スイッチ 電 球、論理ゲートを使って、この変換を行う回路を作ることができる。

この回路には、上部に3桁の2進数を表現する3つのスイッチがある。これ らのスイッチは、閉じているときは 1、開いているときは0を表す。 次の例では、

W

152

第10章 10 に代わる数

153

2進数の100がどのように表現されるかを示している。 下部には0~7と書か れた8個の電球がある。 どのスイッチを閉じたかによって、 そのうちの1つだ けが点灯する。

0 6

この回路は、最初はとてもとっつきにくそうに見えるだろう。 交通標識の読め ない外国の街で、 高速道路が交差している悪夢のような光景に思えるかもしれな い。 だが、実はかなり体系的だ。 小さなドットは、配線と配線がつながっている ことを示している。 ドット以外では配線は接続されず、 ただ重なっているだけだ。

おそらく回路は下から順に見ていった方がわかりやすいかもしれない。 下部の 8個の電球は、それぞれ3入力のAND ゲートから電力を供給されている。 AND ゲートの出力は、3つの入力がすべて1である場合のみ、 1となる。 各 AND ゲートの3つの入力は3つのスイッチに対応しており、 あるものは直接信 号が、 あるものはスイッチ直下の3つのインバーターで反転された信号が入力

154

される。インバーターは入力が0なら出力は1になり、 入力が1なら出力は 0 になることを思い出そう。

上部の3つのスイッチは、 2進数の100を表すように、 「閉」 「開」 「開」 の状 態になっている。赤い線をたどると、 最上位桁 (左端のスイッチ)の1が8進 数の4に関連する AND ゲートの入力の1つであることがわかる。 次の桁 (中 央のスイッチ)は、同じAND ゲートの入力となる前に反転される。 最下位桁 (右端のスイッチ) も反転してから、 そのAND ゲートの3番目の入力となる。 したがって、 8進数の4に対応する AND ゲートは、3つの入力がすべて1に セットされ、 そのため出力は1となる。

同様に、ほかの7つのAND ゲートには、スイッチからの信号または反転さ れた信号が異なる組み合わせで入力される。

この小さな装置は、 3-to-8 デコーダーと呼ばれる。 その名が示すのは、3桁の 2進数が8つの可能性のうちの1つを表すコードであることである。

8-to-3 エンコーダーという名の別の回路は、 逆の仕事を行う。 この仕事のため に、8つの位置から1つを選択できる新しいタイプのスイッチを作成しよう。現 実世界では、このスイッチは押しピンや釘、そして缶から切り取った金属片で作 ることができる。

第10章 10 に代わる数

下部に位置する2進数の各桁は、4入力のOR ゲートで駆動される電球を使っ て表示される。4つの入力のいずれかが1であれば、 OR ゲートの出力は1にな る。 上部のスイッチで8進数の6を選択すると、 第1と第2のOR ゲートに 1 が入力され、これらのOR ゲートの出力が1になり、2進数の110が示される。 左上の0の位置のスイッチには、 何も接続されていないことに注目しよう。こ これは8進数の0は2進数の 電球の点灯が不要だからだ。 になるので、

1947年頃、 アメリカの数学者ジョン・ワイルダー・テューキー (1915-2000) は、コンピュータが普及するにつれて、 2進数用の数字という言葉がより重要な 意味を持つだろうと考えた。 彼は、2進数用の数字 (バイナリーデジット) とい う扱いにくくて長い言葉に代わる、 より短い言葉を新たに作ることにした。 途中 でbigit 〔ビジット] や binit 〔ビニット] などの候補も挙がったが、彼は結局、 短く 単純で、エレガントかつピッタリな言葉、 bit [ビット]に決めた。

☐

155



第11章

ビットでちょびっとずつ

しかし 遠くの刑務所に収監された男が故郷に帰るという話は、 少なくとも1950年代 にはもう存在した。 男は自分が歓迎されるかどうかわからないから、木の枝に布 をくくりつけて合図してくれと手紙で頼み込む。 あるバージョンでは、 家族のも とへ汽車で旅する男は、 リンゴの木に白いリボンが結ばれているのを見たいと願 う。別のバージョンでは、妻のもとへバスで移動中、 男は樫の木に黄色いハンカ チが結ばれているのを望む。 どちらのバージョンでも、男が到着してみると、 木 はたくさんの大きな布で覆われていて、歓迎されていることを疑う余地はない。

1973年にこのエピソードは 「Tie a Yellow Ribbon Round the Ole Oak Tree」 邦題『幸せの黄色いリボン』] というヒット曲で広まり、 それ以来、 家族や恋人が戦 地に赴く際にも黄色いリボンを飾ることが習慣になっている。

黄色いリボンを望んだ男は、 詳しい説明や、長々しい話を求めていたわけでは ない。 「もしも「そして」 も 「しかし」 もいらない。 複雑な思いや心の動きは あったにせよ、この男が本当に欲しかったのは、単純な「イエス」もしくは 「ノー」だった。 男が黄色いリボンに託したのは、 「たとえあなたが大失敗をして 3年間刑務所にいたとしても、この家に戻ってきてほしい」という意味だった。 そして、 黄色いリボンがなければ、 「立ち寄ることさえ考えないで」という意味 になるのだ。

イエスとノーの2つは明確で、 相互に排他的な選択肢である。 黄色いリボン と同じくらい効果的なのは、 家の門に 「合流」 あるいは 「進入禁止」といった交 通標識を設置することだ (ただし、歌詞にするのは難しいかもしれない)。

あるいは、ドアに掛けられた 「オープン」 または 「クローズド」のサイン。 あるいは、窓際で懐中電灯を点けたり消したりとか。

イエスかノーかを伝えればよいだけなら、 多くの方法から選べる。 文章はいら ない単語もいらないし、文字さえもいらない。 必要なのはビットだけ、つまり 0か1だけでいい。

前の2つの章で見てきたように、私たちが普段、 数を数えるときに使う 10 進 法には、特別な意味はない。 私たちが10を基準にしているのは、単に両手指の 本数が10本だからだ。私たちがアニメのキャラクターなら8、 ロブスターなら4、 イルカなら2というように、自らにとって合理的な記数法を持つことができる。

2進法には、10進法にはない特徴がある。 2進法は最も単純な記数法である ことだ。 2進数には0と1の2つしかない。 2進法よりも単純なものがほしいな ら、1を取り除かなければならない。 そうすると0だけが残り、 それでは何もで きなくなる。

2進数用の数字 (binary digit) という意味の造語であるビット (bit) は、 コ ンピュータに関連して発明された最も愛おしい言葉の1つであることは間違いな い。もちろん、ビットにはもともと 「小さな部分、 程度、量」 という通常の意味 があるので、 実際に小さな量である2進数の1桁を表すのにふさわしい言葉だ。

言葉が発明されると、 新しい意味を持つことがある。 それはビットにも当ては まる。 イルカが数を数えるために使う2進数の数字という意味を越えて、 コン ピュータ時代にビットは情報の基本構成要素と見なされるようになった。

これは大胆な宣言だ。 もちろん、 情報を伝達するのはビットだけではない。 文 字や単語、 モールスコードや点字、 10進数も情報を伝える。 そうしたなか、ビッ トならではの特徴は、とても小さな情報を伝えるということだ。 たとえその情報 が黄色いリボンのように重要なものであったとしても、1ビットの情報は、可能 な限り小さい。 ビットより小さい情報は存在しない。 1ビットが可能な限り小さ な情報を表しているからこそ、より複雑な情報を複数のビットで伝えることがで きるのだ。

「Listen, my children, and you shall hear / Of the midnight ride of Paul Revere [子どもたちよ、耳を傾けよ、そして聞こう/ポール・リビアの真夜中の騎行」と ヘンリー・ワズワースロングフェローは詩に書いた。 彼が記述した、 イギリス 軍の侵略をアメリカの植民地に知らせたポール・リビアの行動は、歴史的には正

158

第11章 ビットでちょびっとずつ

159

確な描写ではなかったかもしれない。 それでもロングフェローは、ビットを使っ て重要な情報を伝達するという、深く考えさせる例を示した。

彼は友人に告げた。「もしイギリス軍が 今晩、 町から陸路か海路で進軍したら、 ノースチャーチの鐘楼アーチに 特別に灯したランタンを吊るせ 陸路なら1つ、 海路なら2つ......」

ポール・リビアの友人は2つのランタンを持っていた。 イギリス軍が陸路で 攻めてくるなら、 友人は教会の塔にランタンを1つだけ置くだろう。もしイギ リス軍が海路でやってくるなら、 友人は教会の塔に両方のランタンを置く。

ロングフェローはすべての可能性を明確に示しているわけではない。 彼は、 第 三の可能性、つまりイギリス軍が侵略してこないという可能性には言及していな い。 ロングフェローは、 教会の塔にランタンが置かれないことで、この状況が伝 わることを暗に示している。

さて、この2つのランタンは、実は教会の塔に常設されていると仮定してみ よう。 普段はどちらも点灯していない。

166

つまり、イギリス軍はまだ侵略していないという意味だ。 どちらか1つのラ ンタンが点灯している場合には、

or

イギリス軍は陸路でやってくるという意味になる。 両方のランタンが点灯してい る場合には、

イギリス軍は海路でやってくるという意味だ。

各ランタンはビットであり、0または1で表せる。 黄色いリボンの話は、2つ の可能性のうちの1つを伝えるためには、たった1つのビットがあればよいこ とを示している。 ポール・リビアが、イギリス軍がどこから攻めてくるかではな く、ただイギリス軍が攻めてきたことを知らせるだけでよかったのなら、ランタ ンは1つで十分だっただろう。 ランタンが点灯すれば侵略、 点灯されないなら 今夜は平和だということだ。

だが3つの可能性のうちの1つを伝えるには、もう1つランタンが必要だ。 この2つ目のランタンがあれば、2つのビットで4つの可能性のうちの1つを 伝えることが可能になる。

160 |

第11章 ビットでちょびっとずつ 161

00 = イギリス軍は今夜攻めてこない。 01= イギリス軍は陸路でやってくる。 10 イギリス軍は陸路でやってくる。 11 = イギリス軍は海路でやってくる。

ポール・リビアが3つの可能性にこだわったのは、とても巧みなやり方だっ た。 通信理論の用語を使うなら、ノイズの影響を相殺するために冗長性を利用し たのだ。 ノイズという言葉は、 通信理論では、コミュニケーションを妨害するも のを指す。 電話のコミュニケーションを妨害するノイズには、わかりやすい例と して携帯電話の接続不良がある。 話し言葉は冗長性が高いため、 電話によるコ ミュニケーションはノイズがあっても大抵はうまくいく。 言葉を理解するため に、音声のすべての音節を聞き取る必要はない。

教会の塔のランタンでは、夜の暗さとポール・リビアが塔から離れたところに いることがノイズの要因となる。 いずれの要因も、ランタンの点灯を判別する妨 げになりえる。 ロングフェローの詩で重要なのは、 次の部分だ。

そして見よ! 鐘楼の高さに目をやるときに 微かに光り輝く灯火を! 鞍に飛び乗り、 手綱を引く。 だがそこにしばし留まり目を凝らす 見えた。鐘楼の第二のランタンが灯る!

きっとポール・リビアは、 2つのランタンのうち、 どちらが先に点灯したかを正 確に把握できる位置にはいなかったのだ。

ここで重要なのは、 「情報とは、 2つもしくはそれ以上の可能性の中から選択 「するものである」 という考え方だ。 私たちの誰かが話すとき、 その言葉はすべ て、辞書に載っているあらゆる単語の中から選ばれたものだ。 辞書に載っている すべての単語に たとえば1から35万1482までの番号をつけたなら、単語の 代わりに数字を使って正確に会話ができるだろう (もちろん、両者とも同じ番号 がふられた辞書が必要だし、かなりの忍耐力も必要だが)。

逆に言えば、 2つ以上の可能性の中からの選択に還元できる情報は、複数の

162

ビットを使って表現できるということだ。 言うまでもなく人間のコミュニケー ションの中には、きれいに区別された可能性の中からは選択できない、それでい て重要な情報はたくさんある。これが、人間とコンピュータがロマンチックな関 係になれない理由だ (まあ、そうならないことを祈っておこう)。 対象を言葉や 画像 あるいは音声で表現できない場合には、 情報をビットでエンコード [符号 化] することもできない。 また、 そうしたいとも思わないだろう。

20世紀末の10数年間、 映画評論家のジーン シスケルとロバート・エバー トは、 彼らが司会を務めるテレビ番組 「At the Movies [映画館にて]」 で、 ビット の使い方を披露していた。詳細な映画評を行ったのち、 最後に彼らは「サムズ アップ [親指を立てる=気に入る]」 または 「サムズダウン [親指を下す=気に入らな い]」の判定を下していたのだ。

2本の親指がそれぞれビットなら、4つの可能性を表せる。

00=2人とも気に入らない。

01= シスケルは気に入らなかったが、 エバートは気に入った。 10=シスケルは気に入ったが、 エバートは気に入らなかった。 11 = 2人とも気に入った。

最初のビットはシスケルのビットで、シスケルがその映画を気に入らないなら 1になる。 同様に、2ビット目はエバートのビットだ。

0、 気に入ったならそのため、 「At the Movies」 が放映されていた時代には、 友人に 「新作映画 『Impolite Encounter [不愉快な出会いと訳せるが、実在の映画ではないようだ)」 のシス ケルとエバートの評価はどうだった?」 と聞かれたら、「シスケルがサムズアッ プで、エバートがサムズダウン」 あるいは 「シスケルが気に入って、 エバートが 気に入らなかった」 と答える代わりに、 「イチゼロ」、 または4進数に換算して 「2」と答えることもできた。 友人がシスケルのビットとエバートのビットの位 置、 そして1のビットがサムズアップ, 0のビットがサムズダウンを意味するこ とを知っていれば、 あなたの答えを完全に理解できるはずだ。 ただし、あなたと あなたの友人がともにコードを知っている必要がある。

1のビットをサムズダウン、 0のビットをサムズアップと決めることもできた たろう。 ただ、それは直感に反するかもしれない。 普通に考えると、1のビット

第11章 ビットでちょびっとずつ

は肯定を表し、 0のビットはその反対を表すとしたいところだ。 しかし、 実際に はこれらは恣意的な割り当てにすぎない。 唯一の要件は、コードを使用するすべ ての人が、0と1のビットの意味を知っていることだけだ。

かし 特定のビットやビットの集まりの意味は、常に文脈に沿って理解される。 樫の 木に巻かれた黄色いリボンの意味は、巻いた人とそれを見ることになる人にしか わからないだろう。色や木や日にちが変われば、 意味のないただの布切れにな る。同様に、シスケルとエバートの手の動きから有益な情報を得るには、少なく ともどのような映画が議論されているかを知る必要がある。

「At the Movies」 を見ながら、 作品と2人の親指投票のリストを記録してい たなら、その中に自分の意見を示す1ビットも追加できただろう。この3番目 のビットを加えることで、 異なる可能性の数は8つに増える。

000=3人とも気に入らなかった。

001 シスケルは気に入らなかった、 エバートは気に入らなかった、 私は気に入った。 010 = シスケルは気に入らなかった、 エバートは気に入った、 私は気に入らなかった。 011 = シスケルは気に入らなかった、 エバートは気に入った、 私は気に入った。 100=シスケルは気に入った、エバートは気に入らなかった、 私は気に入らなかった。 101= シスケルは気に入った、 エバートは気に入らなかった、 私は気に入った。 110 シスケルは気に入った、 エバートは気に入った、 私は気に入らなかった。 111=3人とも気に入った。

ビットを使ってこの情報を表現する利点は、すべての可能性を考慮できること だ。 可能性は8つしかなく、 それ以上でも以下でもない。 3ビットでは、(10進 数でいうところの) 0から7までしか数えることができない。 これ以外の3桁の 2進数は存在しない。 第 10 章の終わりにもあるように、この3桁の2進数は 8 進数の0~7でも表現できる。

ビットを語るとき、 私たちはしばしば特定のビット数について語る。 ビット数 が多ければ多いほど、 表現できる可能性の数も増えるのだ。

もちろん、10進数でも事情は同じである。 たとえば、 電話の市外局番はいく つあるだろう? 市外局番は3桁の10進数で、 3桁の組み合わせをすべて使うと (実際にはそうではないが無視しよう)、000から999 までの10個、つまり

163

164

1000通りのコードが存在することになる。 たとえば212の市外局番 (ニュー ヨーク市の市外局番) で、 7桁の電話番号はいくつまで可能だろうか?この場合 は 107 つまり 10,000,000 (1000万) 通りだ。 では市外局番 212に続く3桁交 換局番号 260 では、いくつの電話番号を持つことができるだろう? それは 10°、 つまり1万通りである。

同じように、2進法の場合は、 可能なコードの数は常に2のビット数のべき乗 に等しい。

ビット数 コードの数 1 2' = 2 2 22 = 4 3 23 = 8 4 24 = 16 5 25 = 32 6 26 = 64 7 27 = 128 8 28 = 256 9 29=512 10 210 = 1024

ビットが増えるごとに、コード数が2倍になる。

必要なコードの数がわかっているとき、 必要なビット数をどのように計算すれ ばよいのだろう? 言い換えれば、 先の表を逆方向 (右から左) に計算するには どうすればよいのだろうか?

_てい ここで必要な数学は、 2進対数 (または 「底を2とする対数｣) だ。 対数はべ き乗の反対の操作である。 2の7乗が128 であることは知っている。 このとき 128の2進対数は7になる。 数学的な表記を用いると、 以下の式

27 = 128

次の式と等価だ。

log21287

は、

第11章 ビットでちょびっとずつ

では、128の2進対数が7で、256の2進対数が8だとすると、 128 256 の中間の数、たとえば底を2とする200の2進対数はどうなるだろう? 実際に 計算すると約7.64 になるのだが、これを正確に知る必要はない。 ポール・リビ アが3つの可能性のうちの1つを伝えるために2つのランタンを必要としたよ うに、200の異なるものをビットで表現する場合には、8つのビットが必要にな る。 数学的に厳密にいうなら、ポール・リビアの3つの可能性を表現するため に必要なビット数は3の2進対数、 つまり約1.6 となるが、 現実的な意味では2 つ必要になる [ランタンは整数値しかとれないため]

ビットはしばしば、私たちが持つ電子機器の深部に隠されている。 コンピュー タ内部にエンコードされたビットや、 ネットワークケーブルを流れるビット、 Wi-Fi ハブや携帯電話の基地局アンテナの周りに渦巻く電磁波内のビットを見る ことはできない。 しかし、時として、はっきりとビットが見えることもある。

それは2021年2月18日、 火星に着陸した探査機 「パーシビアランス」の場 合だ。ローバーからの写真に写るパラシュートは、320枚のオレンジと白の布 を、4つの同心円状に並べたものだ。

165

Twitter [現X] ユーザーがそのパターンをデコード [解読] するのに時間はかか らなかった。 ポイントは、 短冊状の布を、 オレンジ [図ではグレー] と白の両方を 含む7枚ずつのグループに分けることだった。 これらの7枚の短冊グループは、 どれも3枚の白い短冊で区切られている。 連続したオレンジ色の短冊で構成さ れる領域は無視される。 次の図では、 7枚の短冊で構成されるグループがそれぞ れ黒く太い線で囲まれている。

166

第11章 ビットでちょびっとずつ

これらのグループはそれぞれ、 白い短冊が0、オレンジの短冊が1を表す2進 数になっている。 一番内側の円のすぐ上にあるのが第1グループだ。 時計回り に見ると、この7本の短冊は2進数の 0000100 つまり 10進数の4を表現し ている。 アルファベットの4番目の文字はDだ。 時計回りに見ると次の文字は 0000001 つまり10進数の1となる。これはAだ。 次は0010010 つまり 10 進数の18である。 アルファベットの18文字目はR。 次は0000101、つまり10 進数の5Eとなる。 最初の単語は DARE だ。

ここで次の外周にジャンプしよう [時計の6時方向で第2グループに移る]。 ビット 列は 0001101 つまり 10 進数の13でアルファベットのMとなる。 この調子 で最後までいったら、 テディ・ルーズベルトに由来し、 NASA ジェット推進研

167

究所 [JPL] の非公式モットーにもなっている3つの言葉が完成する [dare mighty things (大胆なことに挑戦せよ): セオドア (テディ) ルーズベルト大統領の演説に由来する。

34

32

0

5

N

外周には暗号化された数字があり、 JPLの緯度と経度がわかるようになって いる (34°11'58" N 118° 10′31" W)。 ここでは、 文字と数字を区別しない、 単純なコード体系が採用されている。 地理座標の一部である10と11 という数 字はJとKという文字の可能性もある。

2進数の視覚的表現として最も一般的なのは、私たちが購入するほぼすべての 商品に表示されているユニバーサルプロダクトコード [UPC] という小さなバー コードだろう。 UPCは様々な用途に使われる数十種類のバーコードのうちの1

168

第11章 ビットでちょびっとずつ | 169

つだ。 本書の紙版を読んでいる場合は、裏表紙を見れば本書の国際標準図書番号

(ISBN) を符号化したバーコード (UPCとは異なる) が印刷されているはずだ。 UPC が登場した当初は一種の被害妄想を引き起こしたこともあったが、 実際 のところ、 小売店のレジや棚卸しを自動化する目的で発明された、 ささやかな コードにすぎず、かなりうまく機能している。 UPCの登場以前は、 今では当た り前のスーパーのレジでの明細付きレシートの発行ができなかった。

UPCがバイナリーコードであることは、 一見そうは見えないだけに、興味深 い。 UPC をデコードして、その仕組みを検証してみるのも面白いだろう。

UPCの最も一般的な形は、 様々な幅を持つ 30本の縦線 [バー]であり、この 縦線は様々な幅の隙間 [ギャップ] で区切られている。 さらに、いくつか数字も 添えられている。

たとえば、 キャンベルのチキンヌードルスープ 1034オンス缶に印字されてい UPCは以下のものだ。

0 51000 012517

同じ UPCが本書の初版に掲載されているが、これは20年以上前から変わっ ていない!

私たちは、 UPC を細いバーと太いバー、狭いギャップと広いギャップで視覚 的に解釈しようとしたくなるし、 実際、そういう見方もある。 UPCのバーの幅 は4種類あり、一番細いバー、および、その2倍、3倍 4倍のものがある。 同 様に、バー間のギャップにも、一番細いギャップ、 および その2倍、3倍、4 倍のものがある。

しかし、 UPCのもう1つの見方は、ビットの連続として捉えるというものだ。 レジでスキャナーが 「見ている」のは、バーコードの記号全体ではない。たとえ ば、スキャナーは下部に書かれた数字を解釈しようとはしない。 これには光学的

170

文字認識 [OCR] として知られる、より高度な技術が必要になるからだ。 代わり にスキャナーは、このブロック全体を薄く切り取ったスライスだけを見る。 UPCが大きいのは、レジの人がスキャナーを向けるためだ。 スキャナーが見る スライスは、次のように表現できる。

III IIIIII

これは、ほとんどモールスコードのように見えないだろうか? 実際、 スキャナー で読み取るバーコードの原型は、 モールスコードからヒントを得て発明された。

コンピュータはこの情報を左から右にスキャンしていき、最初に出会った黒い バーには1のビット、 次の白いギャップには0のビットを割り当てる。 このあと は、バーとギャップをその幅に応じて、 1、2、3、 または4ビットの連続として 読み取る。 スキャンしたバーコードとビットの対応は単純で、次のようになる。

III III II II 10100011010110001001100100011010001101000110101010111001011001101101100100111011001101000100101

つまり UPCは、 ビットが95 個並んだものなのだ。 この例では、 ビットは次 のようにグループ化できる。

第11章 ビットでちょびっとずつ

ビット 意味 101 左側のガードパターン 0001101 0110001 0011001 左側の数字 0001101 0001101 0001101 01010 1110010 中央のガードパターン 1100110 1101100 右側の数字 1001110 1100110 1000100 101 右側のガードパターン

最初の3ビットは常に101である。 これは左側のガードパターンと呼ばれ、 このおかげでスキャナーは向きを決められる。 また、このガードパターンから、 スキャナーは1ビットに対応するバーとギャップの幅を決定できる。 これがな ければ、 すべての商品のUPCを決まったサイズにしなければならないだろう。

左側のガードパターンに続いて、 7ビットずつのグループが6つ続く。 次に示 すように、それぞれが0から9までの数字を表すコードだ。 次に5ビットの中 央のガードパターンが続く。 この固定パターン (常に01010) の存在は、エラー チェックのためである。 スキャナーが中央のガードパターンをあるべき場所に見 つけられない場合、 UPC を読み取ったとは認識されない。 中央のガードパター ンは、改ざんされたコードや印刷不良に対応するための予防措置の1つである。

中央のガードパターンに続いて、 さらに7ビットずつの6つのグループがあ り、続いて右側のガードパターンがある。 これは常に101 だ。 この末尾のガー ドパターンによって、 UPCコードは前方からだけでなく、 後方 (つまり右から 左) からも読み取ることができる。

| 171

つまり、 UPC には12桁の数字がエンコードされている。 UPCの左側には6 桁の数字がエンコードされており、 それぞれが7ビットを必要とする。これら のビットのデコードには次の表が使える。

左側のコード 0001101 = 0 0110001 = 5 00110011 01011116 0010011 = 2 01110117 01111013 01101118 01000114 00010119

7ビットの各コードは、0から始まり、 1で終わることに注目しよう。 左側か ら見て、 1で始まるか0で終わる7ビットコードに遭遇した場合、 スキャナーは UPCコードを正しく読み取っていないか、 コードが改ざんされたと認識する。 また、各コードには、 1の連続したグループが2つだけあることにも注意しよ う。これは、各桁が UPCコードの2本の縦棒に対応することを意味する。

これらのコードをよく見ると、 すべて奇数個の1を持つことがわかる。これ はエラーと一貫性をチェックするためで、 パリティと呼ばれる。 あるビット群 が、偶数個のビットを持つ場合は偶数パリティ、奇数個のビットを持つ場 合は奇数パリティとなる。 ここに示したコードはすべて奇数パリティだ。 UPCの右側にある6つの7ビットのデコードには次の表が使える。

右側のコード 1110010 0 1001110 5 1100110 1 1010000 = 6 1101100 2 1000100 = 7 10000103 1001000 = 8 1011100 4 1110100 9

これらは、先のコードとは逆あるいは補完するコードである。 (先のコードで) 0だった場所が1になり、1だった場所が0になる。 今度のコードは、常に1で

172

第11章 ピットでちょびっとずつ

始まり、0で終わる。 また、 ビットが偶数個あるので、 偶数パリティとなる。 これで UPC を読み解く準備ができた。 先の2つの表を用いると、 キャンベル のチキンヌードルスープ 103/4オンス缶に刻まれていた12桁の10進数は、次 のように解読できる。

051000 01251 7

これにはとてもがっかりだ。 おわかりのように、 UPCの下部に記載されてい る数字と全く同じである (ただし、 何らかの理由でスキャナーがコードを読み取 れなかったら、 レジ係が手で数字を入力して対処できる。 実際、 そんな光景を目 にしたことがあるはずだ)。 この数字をデコードするために苦労する必要はな かったし、ましてや秘密の情報が暴露されたりもしなかった。 このUPCにはも う、デコードできる情報は残っていない。 30本の縦線が、 12桁の数字になった だけである。

12桁の10進数のうち、1桁目 (スープの例の場合は0) はナンバーシステム キャラクターと呼ばれる。 0 は、 通常のUPCコードであることを意味する。 肉 や野菜など重量が変化する食料品の場合には、 UPCのコードは2になる。 クー ポンの場合は5だ。

続く5桁は、メーカーコードを構成する。 スープの例の場合、 51000はキャ ンベルスープ・カンパニーのコードである。 キャンベルの全商品にこのコード がついている。 そのあとに続く5桁の数字 (01251) は、 その会社の特定の製品 を表すプロダクトコードで、 例では103/4 オンス缶のチキンヌードルスープを表 している。このプロダクトコードは、メーカーコードと組み合わされて初めて意 味を持つ。 他社の場合、チキンヌードルスープは01251 とは異なるプロダクト コードだろうし、 01251 というプロダクトコードも全く違う意味になるだろう。

UPCには、一般認識とは異なり、 商品の価格は含まれない。 その情報は、お 店がレジのスキャナーと連動して使っているコンピュータから取り出さなければ ならない。

最後の1桁(例では7) はモジュロチェックキャラクターと呼ばれる。 この キャラクターによって、 もう1つのエラーチェックが可能になる。 さっそく試 してみよう。 最初の11桁の数字 (例では05100001251) にそれぞれアルファ ベットを割り当ててみる。

173

174

A BCDEFGHIJK

そして、次の値を計算してみよう。

3 × (A + C + E+ G+I+K) + (B + D + F + H+J)

この結果を、その数の次に大きい10の倍数から差し引く。キャンベルのチキン ヌードルスープの場合は次のようになる。

3 × (0 + 1 + 0 + 0 +2 + 1) + (5+0 +0 +1 +5) = 3 × 4+ 11 = 23

23の次に大きい10の倍数は30なので、 最終結果は

30-237

となる。これがスープのUPCにあるモジュロチェックキャラクターだ。 スキャ ナーを制御するコンピュータが、 UPCにエンコードされている文字と同じモ ジュロチェックキャラクターを算出できない場合、 コンピュータはその UPCを 有効とはみなさない。 こうして冗長性を高めている。

通常なら、0から9までの10進数を表現するためには、4ビットしか必要と しない。 だが UPCは1桁あたり7ビットを使っている。 全体として、 UPCは 95 ビットを使って、 有用な 11桁の10進数だけを符号化している。 実は、 UPC ではガードパターンの左右に空白 (0ビット9個分)が置かれている。 UPC 全 体では、 11 桁の10進数を符号化するために 113 ビット [95+9×2=113]、 つ まり10進数1桁あたり10ビット以上が必要なのだ!

エラーチェックのためとはいえ、 やりすぎのように思える。 それでも、顧客が フェルトペンを使ってUPCを簡単に変更できるようでは意味がないため、こう なっている。

UPC には、 両方向から読み取れるというメリットもある。 スキャナーがデ コードした最初の数字が偶数パリティ (7ビットの各コードが偶数個のを持つ) であれば、スキャナーはUPCコードを右から左にデコードしていると認識する。 するとコンピュータシステムは、次の表を使って、 右側の7ビットコードをデ コードする。

第11章 ビットでちょびっとずつ

1175

右側のコード (逆方向) 01001110 01100111 00110112 01000013 0011101 = 4 01110015 0000101 6 0010001 7 0001001 = 8 00101119

左側の7ビットコードは次の表でデコードできる。

左側のコード (逆方向) 10110000 1000110 5 10011001 1111010 6 11001002 1101110 7 1011110 3 1110110 = 8 11000104 1101000 9

これらの7ビットコードは、 UPC を左から右にスキャンしたときに読み取ら

れるコードとはすべて異なっている。 曖昧さはない。 ここまで見てきたバーコードよりも多くの情報を詰め込むには、コードを二次 元にする方法がある。 太いバーや細いバー、 ギャップを連ねるのではなく、黒と 白の四角で構成されたグリッドを使うものだ。

最も一般的な二次元バーコードは、 1994年に日本で最初に開発され、現在で は様々な用途で使われている QR (Quick Response) コードだろう。

QRコードの作成は、無料で簡単に行える。 そのためのウェブサイトがいくつ かある。 モバイル端末のカメラでQRコードを読み取ってデコードするソフト ウエアも容易に入手できる。 出荷する製品の追跡や倉庫での棚卸しなど、 産業用 に特化したQR スキャナーが用意されている。

次に示す QR コードは、本書のウェブサイト (www.Code Hidden Language. com) のURLを符号化したものだ。

176

モバイル端末にQRコードを読み取れるアプリがあれば、 この画像を読み取っ てウェブサイトにアクセスできる。

QRコードは、 公式仕様ではモジュールと呼ばれる正方形の格子で構成される。 例で示したQRコードは縦横25モジュールの大きさで、バージョン2と呼ばれ るサイズだ。 QR コードのサイズは40種類がサポートされており、バージョン 40 では縦横 177個ずつのモジュールが並ぶ。

25モジュールのグリッドを使うと、白を0. 黒を」としてデコードすれば、 25 × 25 つまり625ビット分を符号化できる可能性がある。 しかし、実際に 号化できるのはその3分の1程度。 情報の多くは、数学的に複雑で高度なエラー 訂正に割り当てられているからだ。 これにより QRコードの改ざんを防ぐとと もに、破損したQRコードから失われたデータを復元できる。 ただし、QRコー ドのエラー訂正については、ここでは説明しない。

見れば明らかなように、 QRコードには、 QR スキャナーがグリッドを適切に 位置づけるのを助けるいくつかの固定パターンが含まれている。 次の画像は、 定パターンを白黒で、 それ以外をグレーで示している。

第11章 ピットでちょびっとずつ

別され

隅にある大きな3つの正方形はファインダパターン、 右下の小さな正方形は アライメントパターンと呼ばれるものだ。 これらは、 QR コードリーダーがコー ドの正しい向きを認識し、 歪みを補正するのに使われる。 上方と左側に寄ったと ころにある黒と白のセルが交互に並んだ水平と垂直の列はタイミングパターンと 呼ばれ、 QR コードのセル数を決めるのに使われる。 また、 QRコードの周囲は、 セルの4倍の幅の白いクワイエットゾーンで完全に囲む必要がある。

QRコードを作成するプログラムには、エラー訂正の仕組みの違いといった、 いくつかの選択肢がある。 QRコードリーダーがこのエラー訂正 (およびその他 の作業)を行うために必要な情報は、フォーマット情報と呼ばれる15ビットで 符号化される。この15ビットは、QRコードに2回出現する。 次ページの図で は、 左上のファインダパターンの右側と下側に0~14と書かれた15ビットが あり、 右上のファインダパターンの下側と左下のファインダパターンの右側に同 ビットが繰り返されている。

177

178

3210

ビット列は、どのように長い値を構成しているかを示すために、 このように数 字が添えられることもある。 0と書かれたビットは最下位ビット (LSB) 値の一番右端に現れるものだ。 14と書かれたビットが最上位ビット (MSB) で、 数値の一番左側に相当する。 白いセルを0のビット、 黒いセルを1のビットと すると、この15ビットは次の数値を表している。

111001011110011

なぜ0の位置のビットが最下位ビットなのかって? 2進数の表現で200乗 に対応する位置にあるからだ (ビットがどのように数値を構成するかを思い出す 必要がある場合は145ページを参照しよう)。

この15ビットの数値は、3つの情報を集約しているため、 全体の数値そのも のは重要ではない。 最上位の2ビットは、4つのエラー訂正レベルのうちの1つ を指定する。 最下位10ビットは、誤り訂正に使用する 10ビットのBCH コー ドを指定する (BCHは、 このコードの発明者である Bose, Chaudhuri Hocquenghem の頭文字をとったものだが、QRコードのエラー訂正には触れな いと約束したのでこれ以上の説明はなし!)。

最上位2ビットの誤り訂正レベルと最下位10ビットのBCH コードの間には、 誤り訂正に使用されない3ビットがある。 その3ピットを以下では太字で強

してみよう。

第11章 ピットでちょびっとずつ

111001011110011

QRコードリーダーは、黒と白のマスがほぼ同数であるときに最適に動作する ことがわかっている。 一部の符号化された情報に対しては、この限りではない。 とはいえ、QRコードを生成するプログラムは、白黒のマスの数が均等になるよ うなマスクパターンを選択する責任を負う。 このマスクパターンをQRコード に適用すると、 選択したセルが白から黒、 あるいは黒から白に反転し、その結 果、 そのセルが表すビットが0から1 1から0になる。

QRコードの仕様では、 000001、010、011, 100 101 110、111の3 ビットで区別される8種類のマスクパターンが定義されている。 例で示した QR コードで使われているマスクパターンは「100」 で、 横線が1列おきに交互に並 ぶマスクパターンに相当する。

元のQRコードのうち、マスクの白い部分に対応するセルは、いずれも変更 されない。一方、黒い部分に対応するセルはすべて、 白から黒へ、 または黒から 白へ反転させる必要がある。 このマスクは、固定領域とフォーマット情報領域の 変更を回避するようになっていることに注意しよう。 このマスクを元のQRコー ドに適用した結果を次ページに示す。

179

先に述べたようにマスクは、 固定領域とフォーマット情報領域は変更しない。 そのほかの部分について、上の画像と元のQRコードを比較してみると、一番 上の列は色(白黒) が反転、 二番目の列は同じ、 三番目の列は反転、といった具 合に、 色が変わっていることがわかる。

これでいよいよ実際のデータを掘り下げていく準備が整った。 右下隅の4つ のビットから始めよう。 次に示す画像では、これらのセルには0から3までの 番号がつけられており、 3が最上位ビットで、 0が最下位ビットとなる。

0100 は8ビット値を意味する

180

第11章 ビットでちょびっとずつ

これら4つのビットはデータタイプインジケーターと呼ばれ、 QRコードにど のようなデータが符号化されているかを示す。 ここでは、ありえる値のいくつか を紹介する。

データタイプインジケーター

0001

0010

0100

1000

意味 数字のみ 大文字と数字のみ 8ビット値で符号化されたテキスト 日本語の漢字

このQRコードの場合、 データタイプの値は0100で、 テキストを8ビット値 で符号化したデータであることがわかる。

その次の項目は、データタイプインジケーターの上にある8つのセルに格納 される。 次の図では、この8ビットに0から7までの番号がつけられている。

希回

ロ

00011010 または10進数で26

この値は 00011010で、10進数では26となる。 これは、QRコード中に符号 化された文字の数である。

符号化された文字の並びは、組織的ではあるものの奇妙でもある。 先の「文字 「数」 の領域の真上から実際の文字列が始まる。 各文字は通常、 幅2マス、 高さ4

181

182

マスの領域を占め、 文字列は以下に示した方向にくねくねと進んでいく。

すべての文字が、 幅2セル、 高さ4セルの領域を占有するわけではない。 幸 いなことに、 QR の公式仕様は、領域が長方形でない場合のビットの向きを極め て正確に記述している。 次の画像では、 26文字分のセルが赤く塗られていて、 各セルには0から7までの番号がつけられている (0は最下位ビット、 7は最上 位ビットを表す)。

| 01110111 ("w")

= 01110111 ("w").

016

= 01110111 ("w")

0122 5670

345667012345

674523

27045230167

第11章 ビットでちょびっとずつ

QRコードの仕様では、 ISO/IEC 8859 という規格で定義された 8ビット値を 使って、 テキストが符号化される。 このものものしい規格名は、 第13章で詳し アスキー く説明する ASCII (American Standard Code for Information Interchange [情報 交換用米国標準コード]) の一種である。

最初の文字は 01110111 で、 これは文字 「w」 を表す ASCIIコードだ。 次の 文字も同じ 「w」。 次の文字は左に伸びているものの、 これもまた 「w」 だ。 今度 は、 2個並んだセルの列を下がっていこう。 次の文字は 00101110でピリオド (「.」)、 次は 01000011で大文字の 「C」、 そして次は 01101111 で 「o」 となる。 次の文字は左隣の行へと続いている。 これは01100100 で 「d」 だ。 次の文字は、 アライメントパターンの下で始まり、 その上へ続いている。 このASCIIコード は 01100101 で、 文字 「e」 に相当する。 この調子で進んでいけば、 www. Code Hidden Language.com となる。

以上でテキストの解読は終了した。 残りのコードの大部分は、エラー訂正に使 われるものだ。

UPC や QR などのコードは、 一見すると怪しげで、 秘密の (そしておそらく 悪意のある) 情報を符号化していると思われても仕方がない。 しかし、これらの コードが広く使われるためには、きちんと文書化され、一般公開されていること が必要だ。コードが使われれば使われるほど、膨大なコミュニケーションメディ アの一環として、 潜在的な価値が高まっていくのだ。

ビットはどこにでも登場するが、QRコードの説明の最後に 「8ビット値」と いう言葉が登場した。 この8ビット値を表す特別な言葉がある。 おそらく聞い たことがあるはずだ。

183



第 12 章 バイトと16進数

ビットだけでも意図は明確に伝えられる。 イエスかノーか、真か偽か、あるい は合格か不合格か。 しかし、もっと一般的な方法は、 複数のビットをまとめた数 字で文字や音声、 音楽、画像、動画などあらゆるデータを表現するやり方だ。 2 つのビットを足す回路も面白いが、 複数のビットを足す回路なら実際のコン ピュータとの関係も深そうだ。

コンピュータシステムは、 ビットの移動や操作に便利なように一定数のビット をワードと呼ぶ形でまとめていることが多い。 このワードの長さやサイズ、 つま リワードを構成するビットの数は、コンピュータのアーキテクチャにとって非常 に重要である。 なぜなら、コンピュータのデータはみな、1つのワードまたは複 数のワードのグループで処理されるからだ。

初期のコンピュータシステムには、ワードの長さを6ビットの倍数、たとえ 12ビット 18ビット、 24ビットとするものがあった。 これらのワードの長 さは、その値が8進数で容易に表現できるという単純な理由から、非常に魅力 的だった。 思い出してほしい。 8進数の数字は0、 1、2、3、4、5、6、 そして7 で、これらは次ページの表に示すように3ビットの値に対応する。

186

2進数

000

8 進数

001

0

010

1

2

011

3

100

101

110

4

5

111

6

7

6ビットのワードはちょうど2つの8進数で表現でき、 12ビット、 18 ビット、 24ビットといったワードサイズはその倍数だ。 24ビットのワードには8つの8 進数が必要になる。

しかし、コンピュータ業界は少し異なる方向に進んだ。 2進数の重要性が認識 されると、2のべき乗ではなく、3の倍数である6, 12, 18, 24 といったワー ドサイズで作業することは、 何だかひねくれたやり方に思えたのだろう。 ここで登場したのがバイト (byte) だ。

バイトの語源は IBM で、 おそらく1956年頃だと思われる。 元々は bite [噛む、 一口] から派生した言葉だが、 その単語がbit (ビット) と読み間違えられないよ うに、 2文字目をyと綴ったのだ。 当初、 バイトは特定のデータパス内のビット 数を意味した。 しかし1960年代半ば、 IBM の大規模なビジネスコンピュータ System/360の開発とともに、バイトという単語は8ビットのグループを意味す るようになった。

それが定着し、今ではバイトはデジタルデータの普遍的な尺度となってい 8ビットであるバイトは、 00000000 から 11111111 までの値を表現でき、こ れは 0 から 255 までの10進数、 または2つまり 256個の異なるものを表現で きる。実際、8は、 ビットを集めた「一口サイズ」としてちょうどよい、 つまり 小さすぎず大きすぎない、 適切な大きさなのだ。 これからの章で見ていくよう バイトはテキストを保存するのに理想的である。 なぜなら、 世界中の言語の 多くは256文字以下で表現できるからだ。 1バイトで不足する (たとえば中国 語、日本語、韓国語の表意文字を表現する) 場合には、2バイト (つまり、2、

第12章 バイトと 16

187

6万5536個のものを表現できる) が通常、十分に機能する。 バイトはまた、 白 黒写真のグレーの色合いを表現するのにも理想的だ。 なぜなら、 人間の目はおお よそ256段階のグレーの色合いを区別できるからだ。 またビデオディスプレイ は、赤、緑、青を表現できる3バイトで機能する。

パーソナルコンピュータの革命は、 1970年代後半から1980年代初頭にかけ て8ビットコンピュータとともに始まった。 その後の技術進歩により、 コン ピュータ内部で使われるビット数は倍増した。 16ビットから32ビット、 そし て64ビットへ。 つまり2バイト、4バイト、 8バイトとなった。 一部特殊な目 的のために、 128ビットや256ビットのコンピュータも存在する。

半バイト、 つまり4ビットは時折 nibble [ニプル、 nybble と綴ることもある」 と呼 ばれるが、この言葉はバイトほど頻繁には使われない。

バイトはコンピュータの内部に頻繁に登場するので、2進数の列よりも簡潔に その値を参照できた方が便利だ。 もちろん、 この目的に 8 進数が使える。たと えば、 バイト 10110110に対しては、右から始めてビットを3つのグループに 分け、先の表を使用して各グループを8進数に変換できる。

10110110 لبالبالي 266

8 進数の266 2進数の10110110よりも簡潔だが、 バイトと8進数との間 には基本的な非互換性がある。 8を3で割ると割り切れないので、ある16ビッ トの数を8進数で表現した以下の表現は、

1011001111000101 1 3 1 7 05

同じ16ビットの数を構成する2つのバイトの8進数表現とは同じにはならない。

10110011 263 11000101 305

マルチバイトの値の表現と、 それを構成する個々のバイトの表現を一致させる には、1バイトの中を同じ数のビットに分割する記数法が必要だ。

もちろん、各バイトを2ビットずつの4つの値に分けることはできる。 それ は、第10章で説明した4を基準とした数、つまり4進法の数 [4進数] になる。 でも、それは私たちが望んでいるほど簡潔ではないだろう。

そして、1バイトを4ビットずつの2つの値に分割することも可能だ。 そのた めには、 16進法と呼ばれる記数法を使う必要がある。

16進法の数、 つまり16進数。 本書にこれまで登場してこなかったが、 それに は理由がある。 16進数を使う記数法はヘキサデシマル (hexadecimal) と呼ば れるが、その言葉は混乱を招く。 ヘキサ (haxa) の接頭辞で始まる言葉 (ヘキ サゴン [6角形]、 ヘキサポッド [6脚]、 ヘキサメーター [6メートル」 など) の多く は、 何かが6あることを示す。 だがヘキサデシマルは16、 つまり6 (ヘキサ) + 10(デシマル) 16進数なのだ。 私は本書の文章を、 オンラインの「マイクロ ソフトスタイルガイド (Microsoft Style Guide)」 に準拠させるよう指示されて いるが、そこには明確に 「ヘックス (hex) と省略しないでください」 と記述さ れている。 だが、みなそうしているし、私も時折そうするかもしれない。 ヘキサデシマル (16進数) の変わった点は、 名前だけではない。 10進数では、

次のように数える。

0123456789 10 11 12

8 進数では、もはや数字の8と9は必要ない。

01234567 10 11 12...

しかし、 16進数はこれらとは異なる。 10進数よりも多くの数字を必要とする。 16進数での数え方は次のような感じだ。

0123456789 なにかはいる 10 11 12

ここで10(イチゼロと発音する) は実際には10進数では16を意味する。 だが、 その間の6つの抜けている記号 な、 に、 か、 は、 い、 る) には何を用いるの だろう?どこから持ってくればよいのだろうか? ほかの数字記号のように伝統的 に受け継がれてきたものではないので、この際、6つの新しい記号を作るのが合

188

第12章 バイトと16進数

理的だろう。 たとえば、次のように。

これらの記号には、 普段使っている数字とは異なり、 それらが表現する実際の 数を容易に覚えて識別できるという利点がある。 10ガロンのカウボーイハット、 アメフトのボール(チームには11人の選手がいる)、 1ダース(12個) のドー ナツ、 不運の13 を連想させる黒猫、 新月から約2週間 (14日) 後に出現する 満月、 そして3月15日にユリウス・カエサルが暗殺されたことを思い出させる 短剣だ。

だが、 残念ながら (実際のところ、大いに安堵するかもしれないが)、 現実に はアメフトのボールやドーナツを用いて16進数を書き表したりはしない。 可能 ではあるが、そうはならなかった。 代わりに、 一般的に用いられる 16進数表記 は、極めてわかりにくい代物だ。 その6つの抜けている 16進数の桁は、ラテン アルファベットの最初の6文字で代表されて、次のようになる。

0123456789ABCDEF10 11 12.....

次ページに示す表は、2進数、 16進数、 10 進数の変換を示す。

189

10進数

2進数

16進数

0000

0001

0

1

0010

2

0

1

3

0011

2

3

0100

0101

4

4

0110

5

0111

5

6

6

1000

7

8

1001

1010

7

8

9

A

1011

1100

9

11

1101

10

B

C

1110

12

D

1111

13

E

14

F

15

数字を文字で表現するのは気持ちのいいやり方ではないが (それに、 数字を文 字で表現すると混乱が増す)、 16進数はこれからも使われ続けるだろう。 それは 「バイトの値をなるべく簡潔に表現できる」 というたった1つの理由からだ。 16 進数はこれにぴったりなのだ。

各バイトは8ビット、 つまり 00 から FFまでの2桁の16進数で表す。 2進 数で 10110110と表現されるバイトは、 16進数でB6、 同じく2進数で 01010111 は、 16進数で57になる。

B6は文字があるので明らかに 16進数だが、 57は10進数の可能性もある。 混乱を避けるためには、10進数と16進数を容易に区別する、 何らかの方法が 必要だ。 もちろん、 その方法は存在する。 実際、 様々なプログラミング言語など において、 16進数を表現する方法は約20ある。 本書では、数のあとに小文字 のh をつけて表現する。 B6h や 57h のように、 だ。

代表的なバイトの16進数と、 それに相当する 10 進数の表を示そう。

190

第12章 バイトと16進数 | 191

2進数 16進数 10進数 00000000 00h 0 00010000 10h 16 00011000 18h 24 00100000 20h 32 01000000 140h 64 01100100 64h 100 10000000 80h 128 11000000 COh 192 11001000 C8h 200 11100000 E0h 224 11110000 FOh 240 11111111 FFh 255

2進数同様に 16進数も、 特定の桁数を扱っていることを明確にするため、 先 頭にゼロをつけて表記することが多い。 長い2進数の場合、 2進数4桁ずつが 16進数1桁に対応する。 16ビットの値は、2バイトで16進数4桁となる。 32 ビットの値は、4バイトで16進数8桁だ。

16進数の普及に伴い、長い2進数を4桁ごとにダッシュやスペースで区切っ て表記することが一般的になってきた。 たとえば、 2進数の 001001000110101011001110, 0010 0100 0110 1000 1010 1100 1110 0010-0100-0110-1000-1010-1100-1110 と書ける。 少しとっつきにくさが減っ て 16進数との対応関係が明確になる。

0010 0100 0110 1000 1010 1100 1110 2 4 6 8 ACE

先の2進数は7桁の16進数の2468ACE で、 偶数の16進数すべてを一列 に並べたものだ (チアリーダーたちが 「2468ACE! 計算機科学の、 学位 をつかめ!」と応援したら、 君の大学はちょっとオタクすぎるかもしれない)。 ウェブページで使われる HTML (Hypertext Markup Language) を扱ったこ とがある人なら、 16進数のよくある使い方をすでに知っているかもしれない。

コンピュータ画面上の色のついたドット (ピクセル) は、 赤、緑、青の3原色 加法混色で組み合わせたもので、 RGBカラーと呼ばれる。 この3つの要素の 強さ [明るさ] はそれぞれバイト値で与えられるので、 特定の色を指定するには 3バイトが必要になる。 HTML ページでは、しばしば6桁の16進数の前に シャープ記号 (#) をつけて色を表示する [シャープ記号というのは日本の俗称で、 ASCII では Number Sign、 日常会話では pound sign と呼ばれる。 JISでは番号記号と呼ばれ [る]。たとえば、本書のイラストに使われている赤色の値は #E74536だ、 これは 赤の値が E7h、 緑の値が45h、 青の値が36h であることを意味する。 この色は、 HTMLページでは、 rgb (231, 69,54) のように 10 進数で指定することもできる。

コンピュータ画面上の各ピクセルの色を指定するには、3バイトが必要なこと を知っていると、ちょっとした計算でほかの情報を導き出せる。 コンピュータ画 面が横方向に 1920 ピクセル 縦方向に 1080ピクセルの大きさなら(標準的な ハイビジョンテレビのサイズだ)、 そのディスプレイの画像を保存するのに必要 なバイトの総数は、 1920 × 1080 に3バイトを掛けた値、 つまり 6,220,800 バ イトとなる。

各原色は0から255までの値になるので、 その組み合わせの数は 256 × 256 × 256 のユニークな色、 つまり 16,777,216 色になる。 16進数では、 100hx 100h x 100h、 つまり 1000000h となる。

16進数では、各桁の位置が16のべき乗に対応する。

☐ ☐ 1の位 16の位 256の位 4096の位 65536の位

192

第12章 バイトと16進数

16進数で 9A48Chは、

9A48Ch=9 × 10000h + A X 1000h + 4 × 100h + 8 × 10h + Cx lh

これは、16のべき乗を使って次のように書ける。

9A48Ch=9 × 16+ +

A X 163 +

4 × 162 +

8 × 16 +

Cx 16°

あるいは、それらのべき乗に相当する10進数を使えば次のようになる。

9A48Ch=9 x 65,536 + A × 4096 + 4 x 256 + 8 × 16 + Cx1

数字のベースを示す添え字をつけずに、1桁の数字 (9、 A、 4、8、C) を書 いても、曖昧さがないことに注目しよう。 9単体は、10進数でも16進数でも 9 だ。そして、Aは明らかに 16進数だとわかり、 10進数の10に相当する。 すべての桁を次ページのように計算して、 10進数に変換できる。

193

9A48Ch= 9 × 65,536 +

10 × 4096 +

4 x 256 +

8 × 16 +

12x 1

答えは 631,948 となる。 16進数から10進数への変換はこのようにして実行 できる。

任意の4桁の16進数を10進数に変換するためのテンプレートも紹介しよう。

x4096 x256 x16 x1

たとえば、 79ACh は次のように変換できる。 16進数のA、Cは、それぞれ 10進数の10 12 であることに留意すること。

9 A C x4096 x256 x16 x1 28,672 +2304+ 160 + 12 |=31,148|

10進数を16進数に変換するときには、通常は割り算が必要だ。 10進数で 255 以下の場合は、 2桁の16進数である1バイトで表現できることは理解でき るだろう。 こうした数値を変換するには、 まず 10進数を16で割ってと を求める。 たとえば、 10 進数の182を16で割ると商は11 (16進数ではB) なり、 余りは6となる。 そのため、 16進数ではB6h になる。

変換したい 10 進数が 65,536 より小さい場合は、16進数への変換結果は4 以下となる。こうした数値を16進数に変換するテンプレートを紹介しよう。

194

第12章 バイトと16進数

+4096 +256 +16 +1

まず、 左上の箱に 10進数全体を入れる。

31,148 +4096 +256 +16 +1

その数を4096 で割ると、 商と余りが求まる。 商は下部の最初の箱に、余りは 上部の次の箱に入れる。

31,148 2476 +4096 +256 +16 ☐ ☐ 0:0 +1

その余り (2476) を256で割ると、 商は9、余りは172となる。 計算を続け よう。

31,148 2476 172 12 +4096 +256 +16 +1 9 10 12

10進数の10と12は16進数のAとCに対応しているので、結果は79ACh

となる。

別のやり方として、 65,535までの10進数を16進数に変換する場合、 まず 256で割って2バイトに分割する方法がある。 そして、各バイトを16で割る。 このテンプレートを次ページに示そう。

195

+256 +16 +16

一番上の箱から始めよう。 割り算をするたびに、 商を左の箱へ、余りを右の箱 へ入れていく。 たとえば、 51,966 を変換するには、

51,966 +256 202 254 +16 +16 12 10 15 14

結果の12 10 15 14 に対応する 16 進数は CAFE となり、 数字というよ り単語のように見える! (実際にはそこに行ったなら、56,495 のコーヒーを注 文したいかもしれない)。

ほかのすべての基準の数と同様に、 16進数にも加算表がある。

196

第12章 バイトと16進数

+ 0 1 2 3 4 5 6 7 8 9 A B C D E F 0 0 1 2 3 4 5 6 7 1 1 2 3 4 5 6 7 8 2 2 3 4 5 6 7 8 3 3 4 5 6 7 8 4 4 5 6 7 8 9 A 5 5 6 7 8 9 6 6 7 8 9 A B 7 7 8 9 A B 8 8 9 A B C 8 9 A B C D E F 9|A|B|C|DE|F | 10 9 A B C DEF 10 11 9 A B C D EF 10 11 12 BCDEF 10 11 12 13 A|BC|D|E|F|10 11 12 13 14 C|D|E|F |10|11|12 | 13 | 14 | 15 C DEF 10 11 12 13 14 15 16 DEF 10 11 12 13 14 15 16 17 9 9 A BCD EF 10 11 12 13 14 15 16 17 18 ΑΙΑ BCDE F 10 11 12 13 14 15 16 17 18 19 B B CDEF 10 11 12 13 14 15 16 17 18 19 1A CCDEF 10 11 12 13 14 15 16 17 18 19 1A 1B D D EF 10 11 12 13 14 15 16 17 18 19 1A 1B 1C E EF 10 11 12 13 14 15 16 17 18 19 1A 1B 1C ID F F 10 11 12 13 14 15 16 17 18 19 1A IB IC ID IE

この表と通常の繰り上がり規則を使って、 16進数の加算ができる。

4A3378E2 + 877AB982 D1AE3264

手で計算するのが面倒な場合は、 Windows や Apple の電卓アプリを使おう。 これには「プログラマーモード」 があって、 2進数、 8進数、 16進数で計算し たり、 記数法間で変換したりできる。 あるいは、 第14章で説明する 8ビット2進数加算器を作ることもできる。

197



第13章

ASCII Unicode ^

タブレットやスマートフォンをタップしたり、ノートパソコンやデスクトップ パソコンの前に座ったりするたびに、 私たちはテキストを扱っている。 ウェブ ページやワープロ、 電子メールやソーシャルメディア、ネットで見かけた冗談や 友人へのメッセージなどで、 私たちはテキストを読んだり、打ち込んだり、 ある 場所から別の場所にカット&ペーストしたりしている。

これらの操作が可能なのは、 コンピュータのビットとバイトでテキスト文字 [キャラクター] を表現するための標準化された方法があるからだ。 文字エンコー ディング [文字の符号化] は間違いなく、 最も重要なコンピュータ規格である。こ の規格は、現代の通信が様々な差異、 たとえばコンピュータシステムやアプリ ケーションの違い、ハードウエアやソフトウエアの違い、 さらには各国の違い、 を乗り越えるために極めて重要なのだ。

それでもなお、コンピュータがテキストの表現で失敗することもある。 2021 年初頭に私が本章の改訂を始めた頃、 ウェブホスティングのプロバイダーから次 の件名のメールを受け取った。

Weâ€™mve received your payment, thanks.

あなたもきっと、こうしたおかしな現象を目にしたことがあるだろう。 奇妙に見 えるかもしれないが、 本章を読み終わる頃には、これがどうして起こるのかを完 全に理解できるはずだ。

本書は、 2進数でテキストを表現する2つのやり方 (モールスコードと点字) の議論から始まった。 モールスコードは、 短いドットと長いダッシュ、 そして ドットとダッシュの間の様々な間隔が絡み合っているため、 初めて見たときは純 粋なバイナリーコードには見えないかもしれない。 しかし、 モールスコードはす べて、 ドットの長さの倍数であることを思い出してほしい。 ダッシュはドットの 長さの3倍、 文字間の間隔はダッシュの長さ、 そして単語間の間隔はダッシュ の2倍の長さだ。 ドットが1のビットなら、 ダッシュは3つ並んだ1のビット であり、 一時停止は0のビットが連続したものとなる。以下に 「HI THERE」 をモールスコードで表示し、 それに対応する2進数を示す。

.. 10101010001010000001110001010101000100010111010001000000

モールスコードは異なる文字ごとに異なるビット数が必要となるため、 可変 ビット長のコードに分類される。

文字の長さについては、 点字の方がずっと単純だ。 各文字は6つのドット [点] の配列で表現され、 各ドットは突起しているか否かのいずれかである。 点字は紛 れもなく6ビットのコードであり、 それは各文字が6ビットの値で表現できる ことを意味する。 ちょっとした問題点は、 数字や大文字を表現するために追加の 点字文字が必要になることだ。 点字で数字を表すには、シフトコード (後続の文 字の意味を変える点字) が必要だったことを思い出そう。

シフトコードは1870年代に印刷電信に関連して、フランス電信局の役員だっ たエミール・ボドー (Émile Baudot) が発明した。 初期のバイナリーコードに も登場し、それは今でも彼の名前で知られている。 このボーコード (Baudot code) は1960年代まで使われた [英語の発音はボドーコードだが日本ではボーコード と表記されることが多い。 ここでは日本語での表記に従う]。 たとえばウェスタンユニオ ンでは電報 [テレグラム] と呼ばれるテキストメッセージの送受信に使われてい た。今でもコンピュータ業界の古参者たちが、 バイナリーデータの伝送速度を ボーレート (baud rates) と呼ぶのを耳にすることがあるかもしれない。

ボーコードはしばしばテレタイプライターに用いられた。 テレタイプライター は、タイプライターに似たキーボードを持つ装置だが、 30個のキーとスペース バーしかないのが特徴だ。 各キーはスイッチで、 テレタイプライターの出力ケー

200

第13章 ASCII から Unicode へ

201

ブルにバイナリーコードを生成して送信する。 テレタイプライターには印字機構 も含まれる。 テレタイプライターの入力ケーブルを通じて電磁石を作動させ、 紙 に文字が印字される。

ボーコードは5ビットコードなので、 16進数で 00h から 1Fhまでの32通り のコードしか含まない。 以下に、これら32種類のコードがどのようにアルファ ベットの文字に対応しているかを示す。

16進数

コード文字

コード ボーコード文字 16進数コード ボー00 10 01 T 11 02 キャリッジリターン 12 03 O 13 04 スペース 14 05 06 07 HNM 15 16 17 08 ラインフィード 18 09 L 19 OA R 1A OB G 1B OC I IC OD P ID OE C 1E OF V IF

E

Z

D

B

S

X

Y

F

A

W

J

数字シフト

U

Q

K

文字シフト

コード 00h は、 何にも割り当てられていない。 残りの31のコードのうち、26 個がアルファベットの文字に割り当てられている。 そのほかの5つのコードの 意味は日本語で示している。

コード 04h はスペースで、 単語を区切るスペース [空白] に使用される。 コー ド02h と 08hはそれぞれキャリッジリターンとラインフィードで、 これらの用 語はタイプライターに由来する。 タイプライターで行の最後に達すると、レバー

やボタンを押して2つの操作を行う。 まず、 次の行が用紙の左側から始まるよ うに、 用紙を乗せたキャリッジが右に移動する (または印字機構が左に動く) よ うにする。 これがキャリッジリターンだ。 次に、 タイプライターはキャリッジを 回転させて紙の次の行が今打ち終わった行の下にくるようにする。 これがライン フィードである。 ボーコードでは、これら2つの操作は別々のコードで表され、 ボー式テレタイプライターのプリンターは印字するときにこれらのコードに反応 して動作する。

ボーコードの数字と句読記号はどこにあるのだろう? それがコード 1Bh、 先 の表では数字シフトとして示されているコードの目的だ。 数字シフトに続くコー ドは、文字シフト (1Fh) が出てきて文字に戻るまで、 すべて数字または句読記 号として解釈される。 以下に数字と句読記号のコードを示す。

16進数コード

ボー記号

00

01

5

16進数コード 10

ボー記号

02

キャリッジリターン

03

9

[ 「あなたは誰ですか?」 とい う問い合わせに使う。 ENQ と表記されることもある]

04

スペース

11

05

#

06

?

07

08

ラインフィード

8m0000 09 OA OB OC OD

4&8

12

0

3

Who Are You?

3456789MBCDEF 13 14 15 16 17 18 19

+

6

$

1A

2

ベル (警告)

IB

IC

数字シフト

OE

:

=

ID

OF

IE

IF

7

1

文字シフト

.

202

第13章 ASCII から Unicodeへ 203

この表は、米国でのコードを示している。米国以外では、 コード 05h OBh、 16h はしばしばヨーロッパの一部の言語のアクセント付き文字に使用された。 ベ ルコードは、テレタイプライターに備わるベルの音を鳴らすものだ。 Who Are You? コードは、テレタイプライターが自己を識別する仕組みを起動するための ものである。

モールスコードのように、 ボーコードには大文字と小文字の区別がない。 たと えば次の文

ISPENT $25 TODAY. [今日25ドル使った。」

は、次のような16進数のデータ列で表現される.

I SPENT $ 25 TODAY 0C 04 14 0D 1006 01 04 1B 16 1901 1F 04 01 03 12 18 15 1B 07 02 08

シフトコードが3つあることに注意しよう。 ドル記号の直前に1Bh、 数字のあ とに 1Fh、 最後のピリオドの前に再び1Bh がある。 行の最後は、 キャリッジリ ターンとラインフィードのコードで締めくくられる。

残念ながら、このデータを二度続けてテレタイプライターのプリンターに送る と、次のように印字される。

ISPENT $25 TODAY. 8 '03,5 $25 TODAY.

何が起こったのだろう? 2行目が始まる前にプリンターが受け取った最後の シフトコードは数字シフトだった。 そのため、 次に文字シフトが出てくるまでの コードは数字として解釈されてしまうのだ。

これはシフトコードの使用に伴う典型的な問題だ。 そのため、 ボーコードをよ り現代的で多機能なものに置き換えるときには、シフトコードの使用を避け、小 文字と大文字に別々のコードを定義することが望ましいと考えられていた。

このようなコードには何ビット必要だろう?英語だけを対象にして文字を足し 上げると、ラテンアルファベットの大文字と小文字だけで52のコードが必要で、 数字の0から9までで10のコードが必要になる。 すでに62まできてしまった。

いくつかの句読記号を追加すると64以上になってしまい、 6ビットの限界を超 える。 しかし、 128 文字を超えるまでにはまだ余裕がある (それを超えると8 ビットが必要となる)。

ということで、答えは7だ。 英語のテキストで通常使うすべての文字をシフ トコードなしで表現するには、 7ビットが必要になる。

ボーコードに代わって登場したのが、 ASCII (American Standard Code for Information Interchange [情報交換用米国標準コード]) と呼ばれる7ビットコード である。 これは ASS-key (アスキー) というありえない発音だ [ASSに下品な意味 がある]。 1967年に規格化され、 コンピュータ業界で最も重要な標準となった。 大きな例外を除いて(このあとすぐに説明する)、 コンピュータ上でテキストに 遭遇するときは、 何らかの形で必ず ASCII が関与している。

7ビットコードとして ASCIIは、 2進数コード0000000から1111111 を使 用し、 それらは16進数コードの00から7Fhに相当する。 このあとすぐに全 128 個の ASCII コードを紹介するが、 まずはコードをそれぞれ32個の4つの グループに分けて、最初の32個のコードは飛ばして説明しよう。 なぜなら、 最 初の32個のコードは概念的にほかのものより少し難しいからだ。 2番目の32 個のコードには、 句読記号と10個の数字が含まれる。 16進数コード 20hから 3Fhのコードと対応する文字を以下に示す。

16進数コード

ASCII 文字

スペース

20

2222222221 23 24 25 26 27 28 29 2A

16進数コード

ASCII 文字

#

30

31

0

32

33

%

1

2

34

3

&

35

4

36

5

37

6

38

7

8

39

3A

9

:

204

205

2B 3B 2C 3C 2D 2E 2F 13 ASCII 5 Unicode^ 3D = 3E > 3F ?

20h は単語と文章を区切るスペース文字である。

次の32個のコードには、大文字と追加の句読記号が含まれる。 アットマーク (@)とアンダースコア(_)を除けば、これらの句読記号はタイプライターに は通常存在しないが、 コンピュータのキーボードでは標準仕様となった。

16進数コード ASCII 文字 16進数コード ASCII 文字 40 @ 50 P 41 42 44 45 47 48 49 4B 4C * * * * * * * * * Y *** A 51 Q B 52 R 43 C 53 S D 54 T E 55 U 46 F 56 V G 57 W H 58 X I 59 Y 4A J 5A Z K 5B [ L 5C 1 4D M 5D 1 4E N 5E Λ 4F O 5F

次の32文字には、 すべての小文字と、 タイプライターではあまり見かけない がコンピュータのキーボードでは標準的ないくつかの句読記号が含まれる。

16進数コード ASCII 文字 16進数コード ASCII 文字 60 70 P 61 a 71 62 b 72 63 с 73 64 d 74 65 e 75 q r S t u 66 f 76 V 67 g 77 W 68 h 78 X 69 i 79 y 6A j 7A Ꮓ 6B k 7B { 6C 1 7C 6D m 7D 6E n 7E 6F 0

この表にはコード7Fhに対応した最後の文字が欠けている。 それが何かはほ どなく説明しよう。

文字列の

Hello, you!

は、 ASCIIの16進数コードで次のように表せる。

Hello, you! 48 65 6C 6C 6F 2C 20 79 6F 75 21

文字コードに加えて、 カンマ (2Ch) スペース (20h), 感嘆符 (21h) のコー ドに注目してほしい。 さらに別の短い文を見てみよう。

206

第13章 ASCII から Unicodeへ

I am 12 years old.

ASCII 表現は以下になる。

I am 1 2 years old. 49 20 61 6D 20 31 32 20 79 65 61 72 73 20 6F 6C 64 2E

文中の数値 「12」 は、 16進数の31hと32hで表現されることに注意してほし い。 これらは数字の1と2に対応する ASCIIコードだ。 数字12がテキストス トリーム [文字列] の一部である場合、それを16進数コードの01h と 02h、 あ るいは OCh として表現してはならない。 これらのコードは、 ASCII では別の意 味を持つからだ。

ASCII では、 大文字はその小文字と 20h分異なる。 この性質から、コンピュー タプログラムでは大文字と小文字の変換が容易に行える。 大文字のコードに20h を加えれば小文字に変換でき、 小文字のコードから20hを引けば大文字に変換 できる(ただし、 実際に加算する必要はない。 大文字と小文字の変換には1ビッ トだけを変更すればよい。 本書の後半で紹介する)。

ここまで見た 95個の ASCIIコードは、 視覚的な表現に対応するため、 グラ フィック文字と呼ばれる。 ASCII にはさらに、視覚的な表現ではないが特定の 機能を果たす 33個の制御文字も含まれる。 33個の ASCII制御文字を以下に示 すが、すべてを理解できなくても心配する必要はない。 ASCII が開発された当 時は主にテレタイプライターでの使用が想定されており、これらのコードの多く は今ではとても理解しにくいからだ。

16進数コード 頭字語 ASCII制御文字名 NUL SOH STX Null 文字 ヘッダー開始 テキスト開始 TIE ETX EOT テキスト終了 転送終了 問い合わせ (照会ENQ ACK 受信確認 (肯定

) 応答)

207

07

ベル (警告)

BEL

08

BS

HT

後退

水平タブ

09

OA

LF

VT

OB

ラインフィード (改行)

OC

FF

OD

垂直タブ

フォームフィード

CR

SO

OE

(書式送り、 改ページ)

OF

SI

DLE

10

DC1

キャリッジリターン

11

12

DC2

13

DC3

14

DC4

デバイスコントロール1

15

NAK

SYN

デバイスコントロール2 デバイスコントロール3 デバイスコントロール4 受信失敗 (否定応答)

16

17

ETB

18

CAN

EM

19

JA

SUB

1B

シフトイン

ESC

同期

FS

伝送ブロック終了

キャンセル (取り消し)

メディア終了 (媒体終結)

1C

ID

RS

データリンクエスケープ

置換

エスケープ

ファイルセパレーターまたは 情報セパレーター4

GS SP グループセパレーターまたは 情報セパレーター3

1E

US

シフトアウト

レコードセパレーターまたは 情報セパレーター2

IF

DEL

ユニットセパレーターまたは 情報セパレーターⅠ

7F

削除 (抹消)

208

第13章 ASCII から Unicode へ

209

ここでの考え方は、テキストを符号化する際、 制御文字とグラフィック文字を 混在できるというものだ。 これは、テレタイプライターやプリンターのように、 ASCIIコードの入力に応じてページの上に文字を打ち出す機器を思い浮かべる とわかりやすい。 通常、 機器の印字ヘッドは、1つの文字コードに対して、1文 字を印字し、 右へ|スペース移動する動作を行う。 最も重要な制御文字は、こ の動作を変更する。

たとえば、次の16進数の文字列を考えてみよう。

41 09 42 09 43 09

この文字 09 は水平タブ、 略してタブと呼ばれる。プリンターページの水平方 向のすべての文字位置を0から始まる番号と考えると、 タブコードは通常、 次 の文字を8の倍数に相当する水平位置に印字することを意味する。

A B

C

これはテキストを縦に整列させるのに便利だ。

今でもプリンターの中には、 フォームフィードコード (OCh) に応答して、 現在のページを排出して新しいページを開始するものがある。

後退 (Backspace) コードは、 一部の古いプリンターでは合成済み文字の印刷 に使用できる。 たとえば、 コンピュータがテレタイプライター上にグレイブアク セント [主にラテン文字を使う言語の表記に用いるアクセント符号] が付いた小文字のe つまりを表示したいとする。 これは16進数のコード 650860 を使って実現 できる。

最も重要な制御コードは、 キャリッジリターンとラインフィードで、これらは 対応するボーコードと同じ意味を持つ。 古いプリンターの中には、キャリッジリ ターンコードで印字ヘッドを同じ行のページの左端に移動させ、 ラインフィード コードで印字ヘッドを1行下に移動させるものもあった。 新しい行に移るには 通常、これら2つのコードが必要だったのだ。 また、 キャリッジリターンを単 体で使用すると既存の行に上書き印刷ができ、ラインフィードを単体で使用する と左端に移動せずに次の行にスキップできた。

テキスト、画像、音楽、ビデオはすべて、 バイトの集合であるファイルという 形でコンピュータに保存できる。 各ファイルは名前で識別される。 こうしたファ

210 |

イルの名前は、ファイルの内容を示す説明的な部分と、 ファイルの種類を示す通 常は3~4文字の拡張子から構成されることが多い。 ASCII 文字からなるファ イルは、 しばしばテキストを意味する拡張子 txt を持つ。 ASCII には、イタリッ 体のテキスト、 太字、 様々なフォントの種類やサイズのためのコードは含まれ ない。 そういった高度な要素は、 書式付きテキストやリッチテキストが担う。 ASCIIはプレーンテキストのための形式なのだ。 Windows では、 「メモ帳 (ノー トパッド)」 アプリでプレーンテキストファイルを作成できる。 macOS では、 「テキストエディット」 が同じ機能を持つ ただし、 デフォルト [初期設定]では リッチテキストの編集になる)。 いずれのアプリも、フォントの種類とサイズを 選択できるが、それはあくまでもテキストをその場で見るための機能だ。それら の情報は、 テキストそのものの情報には含まれていない。

メモ帳とテキストエディットは、 Enter キーまたは Return キーを入力すると、 現在の行から次の行の先頭に移動する。 しかし、これらのアプリはワードラッピ ング (行の折り返し) も実行する。 文字入力がウィンドウの最右端に達すると、 アプリは自動的に次の行で入力を受け付け、入力されたテキストは独立した行で はなく段落の一部となる。 Enter キーまたは Return キーを入力すると、その段 落の終わりが示され、 新しい段落が開始される。

Windows のメモ帳の場合、 ユーザーが Enter キーや Return キーを入力する と、 16進数コードのODhと0Ah (キャリッジリターンとラインフィード)が ファイルに挿入される。 macOS のテキストエディットの場合は、 0Ah (ライン フィード) だけが挿入される。 なお、 今ではクラシック Mac OS と呼ばれる OS (1984年から2001年まで) では、 行末には0Dh (キャリッジリターン) だけを 挿入していた。 この非一貫性は、1つのシステムで作成したファイルを別のシス テムで読み込むときに、 問題を引き起こす｡ プログラマは近年、この問題を減ら すために努力してきたが、 プレーンテキストファイルの行末や段落の終わりを示 すコンピュータ業界の標準がいまだに存在しないという事実には驚かされる。 恥 ずべきことでさえある。

ASCII は導入された直後から、コンピューティング分野でのテキストの支配 的な標準になったが、IBM 内部ではそうはならなかった。 System/360 と関連 して、IBM は独自の文字コードである拡張 BCD 交換コード (Extended BCD Interchange Code)、 すなわち EBCDIC [エビシディックと発音される] を開発した。

第13章 ASCII から Unicode へ

211

これは、IBM のパンチカードで使用されていたコードから派生した初期の6 ビットコードである BCDICの8ビット拡張版だった。 このスタイルのパンチ カード (80文字のテキストを保存可能)は1928年にIBMによって導入され、 50年以上にわたり使用されていた。

ABCDEFGHIJKLMNOPORSTUVWXYZ

0123456789

00000000000000000 12345678910111213141516 00000000000000000000000000000000000000000000000000000 2222: 33 3333333333333333 444 4444444444444444444444 5555 555555555555555555555 14444 4444444444 555555 66666666666666666666666666666666666666 777777 7777777777777777777777777777777777 888888888888888888888888888888888888888888888888888888 99999999 99999999 99999999 999999999999999999 9999999! 123456789101112131415161718192021nnnnnna293031323334 1111 3333 4444 5555555 56666666 7777777771 77777777 8888888888888888888 999999999999

うが 黒い長方形は、カードに穿たれた穴だ。 パンチカードには文字を表現する方法 に影響を与える実用上の問題がある。 穴を多く穿ちすぎると、 カードの構造的な 強度が失われて裂けてしまい、 機械を詰まらせてしまう可能性があるのだ。

各文字は、パンチカードの一列に穿たれた1つまたは複数の長方形の穴の組 み合わせによって符号化される。 対応する文字そのものは、しばしばカードの上 部近くに印刷される。 下方の10行は数字行と呼ばれ、 下から第0行、 第1行と いったように番号で識別され、 第9行まである。 これらは、10進数で動作した コンピュータシステムの名残だ。 上部に近い番号のない2行はゾーン行と呼ば れ、第11行と第12行 (一番上の行) になる。 第10行は存在しない。

EBCDIC 文字コードは、ゾーンパンチと数字パンチの組み合わせである。 10 個の数字に対応するEBCDICコードは、FOh から F9h となっている。 大文字 のEBCDICコードは、 Clh~C9h、 Dlh~D9h, E2h~E9hの3つのグルー プに分かれている。 小文字のEBCDICコードもまた、81h~89h、 91h 99h, A2h~A9hの3つのグループに分かれている。

ASCII では、すべての大文字と小文字が連続した配列になっている。 これに より、 ASCII データをアルファベット順に並べるのは簡単だ。 しかし、

EBCDICでは文字の並びに隙間があるので、ソート [並べ替え] が複雑である。 幸いなことに、現在では EBCDICはほとんど歴史的な興味の対象であって、 個 人的あるいは職業的に遭遇することはほとんどない。

ASCII が開発されていた当時、メモリーは非常に高価だった。 メモリーを節 約するために、 ASCIIは6ビットのコードとし、シフトキャラクターを使って 大文字と小文字を区別すべきだという意見もあった。 そのアイデアが却下され、 ASCII は8ビットのコードであるべきだという意見が出た。 というのも、7ビッ トのアーキテクチャよりも、 8ビットのアーキテクチャの方がコンピュータと親 和性が高いと考えられたからだ。 今では8ビットからなるバイトが標準であり、 ASCII は技術的には7ビットのコードではあるものの、ほとんどどこでも8ビッ トの値として格納されている。

バイトとASCII 文字の等価性は便利だ。 文字数を数えるだけで、 そのテキス ト文書がどれくらいのメモリーを必要とするかを大まかに把握できるからだ。 た とえば、ハーマン・メルヴィルの「白鯨 (Moby-Dick または The Whale)」 は約125万文字でなので、 125万バイトのコンピュータストレージを占めるこ とがわかる。 この情報から、 おおよその単語数も導き出せる。 平均的な単語は5 文字とされており、単語の間に現れるスペースを数えると、 「白鯨」 の長さは約 20万語である。

「白鯨」 のプレーンテキストファイルは、プロジェクト・グーテンベルク (Project Gutenberg) のウェブサイト (gutenberg.org) からダウンロードでき る。 これはパブリックドメインになっているほかの古典文学作品と同じだ。 プロ ジェクト グーテンベルクはプレーンテキストでの書籍提供の先駆けであり、 同 じ書籍をいくつかの電子書籍形式や HTML (Hypertext Markup Language) も提供している。

インターネットのウェブページで使用される形式として、 HTML は間違いな く最も人気のあるリッチテキスト形式だ。 HTML は、 マークアップまたはタグ と呼ばれる小さなテキストの断片を使用して、 プレーンテキストに装飾的な書式 を追加する。 興味深いのは、 HTML がマークアップに通常の ASCII 文字を使用 するため、 HTML ファイル自体も通常のプレーンテキストファイルであるとい うことだ。HTML をプレーンテキストとして表示すると次のように見える。

212

第13章 ASCII から Unicode へ 213

これは <b> 太字 </b>のテキストで、 これは<i>イタリック <i> のテキストです。

かっこ 角括弧 (<>) は ASCIIコードでは3Chと3Ehだ。 しかし、 HTML として 解釈されると、ウェブブラウザはそのテキストを次のように表示できる。

これは太字のテキストで、これはイタリックのテキストです。

同じテキストを、 異なる方法で表示するわけだ。

ASCII は間違いなくコンピュータ業界で最も重要な規格だが、 当初から至ら ない点があることは明らかだった。 大きな問題は、アメリカンスタンダード・ コード・フォー・インフォメーション・インターチェンジ (ASCII) があまりに も「アメリカン」 すぎることだ! 実際、 ASCIIは主要な言語が英語であるほか の国々にもあまり適していない。 ASCIIにはドル記号が含まれるが、 英国のポ ンド記号はどこにある? 西ヨーロッパの多くの言語で使用されるアクセント記号 を含む文字は? もちろん、 ギリシャ語、アラビア語、ヘブライ語、 キリル文字を 含むヨーロッパの非ラテン文字、 インドや東南アジアのブラーミー文字 (デー ヴァナーガリー、 ベンガル語、タイ語、チベット語など) については言うまでも ない。 そして、 中国語、 日本語、韓国語の数万の表意文字や、 韓国語の数千のハ ングルの音節を、7ビットのコードがどうやって扱えるのだろう?

1960年代に全世界の言語を ASCII に組み込むことは、あまりにも野心的な

目標だった。 しかし、たとえ初歩的な解決策であったとしても、ほかの国々の ニーズは考慮されていた。 公表された ASCII 標準によると、10個の ASCIIコー ド (40h, 5Bh, 5Ch, 5Dh, 5Eh, 60h, 7Bh, 7Ch, 7Dh, 7Eh) が各国の国内利用の ために再定義可能とされている [日本のJISでは5Chが¥に割り当てられたので、プロ グラミングの教科書などには\n といった表記が登場することとなった。 これは ASCII で表現 すれば \n となる]。 さらに、 ナンバーサイン (#) は英国のポンド記号 (f) に、 ド ル記号 ($) は一般的な通貨記号 (ロ) に置き換えられる [#は日常会話ではパウンド (ポンド) サインと呼ばれることが多い。 日本ではシャープ記号 (#) と呼ばれたりもするが、 シャープ記号はナンバーサイン (#) とは異なる。 最近はハッシュタグの影響もありハッシュ と呼ぶことも多い]。 明らかに、 記号の置換が意味を持つのは、これらの再定義さ れたコードを含む特定のテキスト文書を使用する関係者全員が変更について知っ

ている場合に限られる。

多くのコンピュータシステムは、 文字を8ビットの値として格納するため、 128文字ではなく256文字からなる拡張 ASCII 文字セットを使用できる。 こう した文字セットでは、最初の128 のコード (16進数の値 00hから7Fh)は ASCII と同じように定義されるが、 次の128 のコード (80hからFFh)は任意 のものにできる。これは、アクセント付きの文字や非ラテン文字といった追加の 文字コードを定義するのに使われてきた。 不幸なことに、 ASCIIは多くの異な る方法で何度も拡張されてきたのだ。

マイクロソフトのWindows が初めてリリースされたとき、 拡張 ASCII 文字 セットをサポートしていたが、これはマイクロソフトが ANSI 文字セットと呼 んだものだった。 しかし、実際には、米国国家規格協会 (ANSI) による認可は 受けていない。 AOhFFhまでのコードに対する追加文字は、 主にヨーロッパ の言語でよく見られる記号やアクセント記号である。 次の表は、 A0h~FFhま での16進数の文字コードを、 上の行の上位ニブル (4ビット) と、 左の列の下 位ニブルで示すものだ。

A- B- C- -0 。 À -1 i -2 ¢ -3 |23 £ Á Â Ã . -4 Ä -5 ¥ Å μ 67 -6 ¦ 1 Æ -7 -8 S Ç È -9 © 1 É -A a 0 Ê -B " Ë -C 14 Ì -D ½ DDN666×OUDOUY D- E- F- à á ñ â o ã Ô ä å a Ö + è Ø Ù é ù ê ú Û ë i Ü Ý - í ý

214

第13章 ASCII から Unicodeへ

-E Ⓡ 3/4 Î P 1 -F B Ï ŷ

コード A0h の文字は、 ノーブレークスペース [改行禁止スペース] として定義さ れている。 コンピュータプログラムがテキストを行や段落に整形するときには通 常、 それぞれの行を ASCIIコード20hのスペースの位置で区切って改行する。 コード AOh はスペース文字として表示されるが、 行を区切るためには使用でき ない。 たとえば、 「WWⅡ」 「第二次世界大戦の意味で、WW と Ⅱの間にスペースがある] というテキストでは、 II が WW と離れて次の行に送られてしまわないように、 ノーブレークスペースを使う。

コード ADh は、ソフトハイフンとして定義されている。これは単語の途中で 音節に沿って分割するために使われるハイフンで、印刷ページ上で1つの単語 が2行にわたって表示されるときだけに使われる。

ANSI 文字セットは Windows に含まれたために広く使われたが、 数十年にわ たって頻繁に実施された ASCII 拡張の1つにすぎなかった。 様々な拡張を区別 するために、 数値やほかの識別子が付与された。 Windows ANSI 文字セットは、 ISO-8859-1 別名 Latin-1 [ラテンアルファベットNo.1] として知られる ISO 標準 となった。この文字セットが80h9Fhまでのコードの文字を含むように拡張 されたときには、 Windows-1252 として知られるようになった。

8- 9- A- B- C- D- E- F- -0 € 0 À -1 -2 i ¢ 2 Á Â -3 f £ 3 Ã -4 Ä -5 " ... Y μ Å -6 t -7 -8 -9 %0 TM 11 Æ S . Ç CDN6666× à á ñ â 0 a 6 ä Ô å ō æ Ö f + È Ø è Ø ◎ - É é 9 ù

215

-A -B Š Š ° É Ú ê ú < > << Ë 0 ë Û -C (E @ - 1/4 Ì Ü i ü -D 1/2 Ý í ý -E Ž ž 3/4 þ -F Ÿ - i Ï B Ï

1252 という番号はコードページ識別子と呼ばれる。 コードページはEBCDIC の異なるバージョンを区別するためにIBMで生まれた言葉だ。 ギリシャ語、 キ リル文字、アラビア語など、 独自のアクセント文字やアルファベットを必要とす る国々を対象に、 様々なコードページが対応づけられた。 文字データを正しく描 画するには、どのようなコードページが含まれるのかを知る必要があった。 HTML ファイルの先頭にある情報 (ヘッダーと呼ばれる)は、そのページを作 成するのに使用されたコードページを示し、インターネットでは最も重要な情報 となった。

ASCII はまた、 中国語、日本語、 韓国語の表意文字を符号化するために、 よ り過激な拡張も行われた。 Shift-JIS [シフトJIS] と呼ばれる有名な符号化方式で は、 81h~9Fh は2バイトの文字コードの先頭バイトを表す。 このような手法 により、 Shift-JISでは約6000もの文字が追加できるようになった。 残念なが この手法を使ったのは Shift-JIS だけではなかった。 アジアではほかにも、 3つの標準的なダブルバイト文字セット (DBCS) が普及したのだ。

互換性のない複数のダブルバイト文字セットが存在することは、数ある問題の 1つにすぎない。一部の文字 (たとえば通常の ASCII 文字) は1バイトコード で表現されるのに対し、数千個もある表意文字は2バイトコードで表現される という問題もある。 このような文字セットの扱いは難しくなる。

だが、安心してほしい。 こうした状況を「面倒くさい」 と考えたのはあなただ けではない。 何とか解決する方法はないだろうか?

世界中の言語に対応するには、 曖昧さのない一つの文字コード体系が望まし いという考えのもと、 1988年に大手コンピュータ会社が集まり、 ASCIIに代わ るUnicode [ユニコード] というコードの開発を開始した。 ASCII が7ビットコー ドであるのに対し、 Unicode は 16ビットコードだ (少なくとも最初の構想はそ

216

第13章 ASCII から Unicode へ

うだった)。 当初のコンセプトでは、 Unicodeの各文字は2バイトで表現され、 文字コードは 0000h ~ FFFFh で、 65,536個の異なる文字を表現するものだっ た。これならコンピュータ通信が使われる可能性の高い世界中の言語に対して十 分であり、 拡張の余地もあると考えられた。

Unicode はゼロからスタートしたわけではない。 Unicode の最初の128文字 (コード 0000h ~ 007Fh) は、 ASCII 文字と同じである。 また、 Unicode の コード 00AOh から 00FFh は、 先に説明した ASCII の ISO-8859-1 [Latin-1] 拡 張と同じだ。 そのほかの世界的な規格もUnicode に取り入れられている。

Unicode コードは単なる 16進数の値だが、 それを示す標準的な方法は、 値の 前に大文字のUとプラス記号を付けるというものだ。 以下に代表的なUnicode の文字を紹介する。

16進数コード 文字 説明 U+0041 A ラテン文字の大文字のエー U+00A3 £ ポンド記号 U+03C0 ㄦˊ ギリシャ文字の小文字のパイ U+0416 Ж キリル文字の大文字のジ U+05D0 א ヘブライ文字のアレフ U+0BEB ௫ タミール語の数字の5 U+2018 左シングルクォーテーションマーク U+2019 U+20AC € 右シングルクォーテーションマーク ユーロ記号 U+221E 00 無限

Unicode コンソーシアムが運営するウェブサイト unicode.org では、さらに 多くの文字を見ることができる。 このサイトは、世界の言語と記号の豊かさを魅 力的に紹介している。 ホームページの一番下までスクロールして「Code Charts」 「コードチャート] をクリックすると、表示されるポータルを通して、想像 もしなかった数の文字の画像を目にすることだろう。

8ビットの文字コードから16ビットの文字コードに移行すると、 また別の問 題が発生する。 コンピュータによって、16ビットの値の読み方が異なる。 たと

217

えば、次の2つのバイトを考えてみよう。

20h ACh

一部のコンピュータは、この文字列をユーロ記号のUnicode である 16ビット 値20ACh として読み取る。 こうしたコンピュータはビッグエンディアンマシン と呼ばれる。つまり、最も重要なバイト (Most Significant Byte = MSB、 ビッ グエンド) が最初にくる。 そうでないコンピュータはリトルエンディアンマシン だ これらの用語はジョナサン・スウィフトの「ガリヴァー旅行記」 にある、 ゆ で卵をどちらの側から割るべきかという論争に由来する)。 リトルエンディアン マシンは上の値を AC20h として読み取る。 Unicode では韓国語のハングルの 「」だ。

この問題を回避するために、 Unicode ではバイトオーダーマーク (BOM) と 呼ばれる特殊文字を定義しており、 そのコードはU+FEFFである。 BOM は 16 ビット Unicode 値のファイルの先頭に置かれることになっている。 ファイルの 最初の2バイトがFE と FFhの場合、 ファイルはビッグエンディアン順となる。 もしFFhとFEh であれば、 ファイルはリトルエンディアン順だ。

1990年代半ば、 ちょうど Unicode が普及し始めたとき、 すでに使われていな かったものの歴史的な理由から表現する必要のある文字や、 多くの新たな記号を 含むために、 16ビットを超える必要が出てきた。 こうした新しい記号の中には、 絵文字と呼ばれる人気の高い楽しいキャラクターも含まれる。

2021年の原稿執筆時点では、 Unicode は U+10FFFFまでの21ビットのコー ドに拡張され、100万以上の異なる文字をサポートできるようになっている。こ ここでは、16ビットコードでは対応できなかった文字のほんの一部を紹介する。

16進数コード

文字

U+1302C

U+1F025

U+1F3BB

説明

U+1F47D

エジプト・ヒエログリフ A039

麻雀牌 菊

U+1F614

歓喜の涙を流す猫の顔

U+1F639

ヴァイオリン

地球外生命体

物思いにふける顔

218

第13章 ASCII から Unicodeへ

絵文字を Unicode に含めるのはくだらないことに思えるかもしれない。 それ でも、メッセージに入力した絵文字が、受信者の携帯電話で全く別のものとして 表示されたら困るだろう。 誤解が生じて人間関係が悪くなる可能性がある。

もちろん、 Unicode に対するニーズは様々だ。 特に、 アジアの言語の表意文 字を表す際には、 Unicode を多用する必要がある。 ほかの文書やウェブページ はより控えめなニーズを持つ。 多くは古き良き ASCII だけで十分だ。 そのため、 Unicode のテキストを保存して伝送するための、いくつか異なる方法が定義さ れている。 これらは、 Unicode 変換フォーマット (Unicode Transformation Format)、 またはUTFと呼ばれる。

Unicode 変換フォーマットの中で最もわかりやすいのはUTF-32 だ。 この形 式では、すべてのUnicode の文字は32ビット値として定義される。 各文字に 必要な4バイトは、リトルエンディアンまたはビッグエンディアンのいずれか の順序で指定できる。

しかし UTF-32の欠点は、大量のスペースを使用することだ。 「白鯨」 のテキ ストを含むプレーンテキストファイルは、 ASCII での 125万バイトから、 Unicode (UTF-32) では500万バイトに増加する。 また、 Unicode が 32 ビッ トのうち21 ビットしか使わないことを考えると、1文字あたり11 ビットが無 駄になってしまう。

妥協の1つがUTF-16だ。 この形式では、ほとんどのUnicode 文字は2バイ トで定義されるが、 U+FFFF を超えるコードの文字は4バイトで定義される。 この目的のために、 元のUnicode 仕様の U+D800 から U+DFFFの領域が未割 り当てにされていた。

Unicode 変換フォーマットとして最も重要なのはUTF-8 で、 インターネット 上で広く使われている。 最近の統計によると、 今では全ウェブページの97%が UTF-8 を使っているという。これは望むべき普遍的な標準としては十分だろう。 プロジェクトグーテンベルクのプレーンテキストファイルはすべて UTF-8 で ある。 Windows のノートパッドや macOS のテキストエディットは、デフォル トではファイルを UTF-8 で保存する。

UTF-8 は、柔軟性と簡潔性の妥協の産物である。 UTF-8 の最大のメリットは、 ASCII との後方互換性があることだ。 つまり、 7ビットのASCIIコードだけを バイトとして格納したファイルは、 自動的に UTF-8 ファイルとなる。

219

220

この互換性を可能にするために、ほかのすべての Unicode 文字は、 その値に 応じて2バイト、 3バイト、 または4バイトで格納される。 次の表はUTF-8の 仕組みを要約したものだ。

Unicode 範囲

U+0000 ~

U+0080 ~

U+0800 ~

U+10000~

ビット数 バイト列 U+007F 7 OXXXXXXX U+07FF 11 110xxxxx 10xxxxxx U+FFFF 16 1110xxxx 10xxxxxx 10xxxXXXXX U+10FFFF 21 11110xxx 10xxxxxx 10xxxxxx 10 xxxxxxx

第1列 [Unicode 範囲] に示すコードの範囲では、 各文字は第2列 [ビット数] に示すビット数で一意に識別される。 これらのビットは、 第3列 [バイト列] に 示すように、1や0を先頭に付けてバイト列を構成する。 第3列のxの数は、 第2列に書かれた数と同じである。

表の最初の行 [U+0000 ~U+007F] は、 その文字が7ビットのASCIIコードの オリジナルコードに対応する場合、 その文字の UTF-8 エンコーディングは、 0 のビットのあとにそれらの7ビットが続き、 ASCIIコードそのものと同じにな ることを示している。

Unicode の値が U+0080 以上の文字は、2バイト以上を必要とする。 たとえ ば、イギリスのポンド記号 (f) は、 Unicode では U+00A3 だ。 この値は U+0080 ~U+07FFの間なので、 表の2行目から2バイトの大きさのUTF-8 で符号化されていることがわかる。 この範囲の値では、 次の図に示すように、最 下位 11ビットのみを使用して2バイトのコードが導出される。

0 0 A 3 0000 0,000 10,10 0011 11000010 10100011 C2 A3

第13章 ASCII から Unicodeへ

図の上部に 00A3 の Unicode 値が示されている。4つの16進数の各数字は、 その下にある4ビット値に対応する。 この値が07FFh 以下であることはわかっ ているので、最も上位の5ビットは0で無視できる。 次の5ビットは、(図の下 部にあるように) 110 を先行させてバイト C2h を構成する。 最下位の6ビット は、 10 を先行させてバイト A3h を構成する。

このようにして、 UTF-8 では2バイトのC2h と A3h が英国の記号を表す ことになる。 本来はバイトの情報を2バイトで表現するのは残念に思えるが、 UTF-8のその他の部分を機能させるために必要なのだ。

もう1つの例を見てみよう。 ヘブライ文字のN (アレフ) は Unicode では U+05D0 となる。 これもまた、 その値はU+0080~ U+07FFの間にあるので、 表の第2行を使用する。 f文字と同じ流れだ。

0 5 D 0 0000 0,101 1101 0000 11010111 10010000 D7 90

05D0h の値の最初の5ビットは無視できる。 次の5ビットは110を先行させ、 最下位の6ビットは10を先行させて、 UTF-8 のバイト D7hと90h を構成する。 実際にはありそうにないイメージだが、 「歓喜の涙を流す猫の顔」の絵文字は Unicode U+1F639 で表され、 UTF-8 では4バイトの列になる。 次の図は、 元 のコードの21ビットから、 その4バイトがどのように組み立てられるかを示す。

0 000.0 1 0001 111 F 6 3 9 0110 8011 1001 11110000 10011111 10011000 10111001 F0 9F 98 B9

221

文字を可変バイト数で表現することにより、 UTF-8 Unicode の純粋さと美 しさを若干損なっている。 ASCII と関連づけられた、これまでのこうした変換 フォーマットは、 様々な問題や混乱を引き起こしてきた。 UTF-8 も完全に問題 から免れているわけではないが、非常に賢明に定義されている。 UTF-8 ファイ ルのデコードでは、各バイトはかなり正確に識別できる。

・バイトが0で始まる場合、 それは単純に7ビットのASCII 文字コードだ。 ●バイトが10で始まる場合、 それは複数バイトの文字コードを表すバイトの シーケンスの一部だが、そのシーケンスの最初のバイトではない。

・上記以外の場合、 バイトは少なくとも2つの1のビットで始まり、 複数バイ トの文字コードの最初のバイトを表す。 文字コードのための合計バイト数 は、この最初のバイトの中に最初に現れる0の前に並んでいる1の数によっ て示される。 これは、2、3、 または4になる。

もう1つ、UTF-8の変換を試してみよう。 右シングルクォーテーションマー ク [右単一引用符記号] はU+2019 だ。 この値はU+0800 とU+FFFF の間にある ため、表の第3行を参照する必要がある。 UTF-8 で表現すると3バイトになる。

2 0 1 9 0010 0000 0001 1001 E2 11100010 10000000 80 10011001 99

元のUnicode 番号のすべてのビットが3バイトを構成するために必要となる。 最初の4ビットは1110で始まり、 次の6ビットは10で、最下位の6ビットも 10で始まる。 結果は、 E2h、 80h、 99h という3バイトの列となる。 これで、 私が本章の冒頭で触れた電子メールの謎と向き合える。 電子メールの 件名を再び示そう。

Weâ€™Mve received your payment, thanks.

222

第13章 ASCII から Unicodeへ

最初の単語は明らかに 「We've」 だが、この短縮形には昔ながらの ASCII ア ポストロフィ (ASCII 27h または Unicode U+0027) ではなく、 よりお洒落な Unicode の右シングルクォーテーションマークが使われているのだ (先ほど見 たように、 UTF-8 ではE2h, 80h、 99h の3バイトだ)。

ここまでは問題ない。 しかし、このメールの HTML ファイルには、文字セッ ト 「windows-1252」 の使用が記載されていた。 しかしながら本当は「utf-8」 と記載されるべきだったのだ。なぜなら、そのようにテキストが符号化されてい たのだから。 しかし、HTMLファイルが windows-1252 を指示していたので、 私のメールプログラムは Windows-1252 文字セットを用いてこれらの3バイト を解釈した。 215ページに示した Windows-1252 コードの表では、E2h, 80h. 99hの3バイトがâ€, TM という文字に対応することを確認してほしい (まさ に電子メールで表示されている文字だ)。

謎は解けた。

コンピューティングをユニバーサルで多文化的な体験へと拡大することによ Unicode は非常に重要な規格となった。 だが、ほかの規格と同様、正しく 使わない限り、 その機能を発揮できないのだ。

223



第 14: 章

論理ゲートによる加算

加算は最も基本的な算術演算だ。 コンピュータを作りたいのなら (明らかに本 書の目的でもある)、 最初に2つの数を足し合わせる 「何か」 を作り出す方法を 知らなければならない。 突き詰めて考えてみると、 実は加算はコンピュータが行 うことのほとんどすべてなのだ。 加算を行う 「何か」 を作れれば、それを使って 減算、乗算、除算はもとより、 住宅ローンの支払い計算、ロケットの火星への誘 導、チェスのプレイも可能になる。 さらには、 最新のダンスや料理のコツ ペッ トのおかしな行動などをソーシャルメディアで共有したりもできるのだ。

本章で作る加算機 [足し算をする機械] は、 日常生活で見かける電卓やコンピュー タと比べると、 大きく、扱いにくく、 遅く、 うるさいものだ。 最も興味深い点 は、この加算機を単純な電気部品、 すなわち前章までに学んだスイッチ、電球、 電線 電池 そして様々な論理ゲートとしてあらかじめ配線されたリレーだけで 作り上げることである。 これらの部品はすべて、20世紀より前から利用可能だっ た。 そして、 本当に素晴らしいのは、実際に「何か」 を作り上げる必要はなく、 紙の上と頭の中でこの加算機を作れることだ。

この加算機は2進数だけを対象に動作し、 現代的な使いやすさには欠けるも のとなる。 足したい数字を入力するためのキーボードは使えず、代わりにスイッ チの列を使うことにする。 結果を表示する数値は、ディスプレイではなく、 電球 の列で表示することにしよう。

しかし、この機械は間違いなく2つの数を足すことができるし、 その方法は コンピュータが数字を足す方法ととても似ているのだ。

226

2進数の加算は、10進数の加算とよく似ている。 245 と 673 という2つの10 進数を足したいときは、まず、問題をより単純な手順に分解する。 各ステップ は、10進数の桁を一組足すだけだ。 この例では、 5+3から始める。 人生のあ る時期に加算表を暗記していれば、 素早く行えるはずだ。 10進数に対する2進数の大きなメリットは、 加算表がシンプルなことである。

+ 0 1 0 0 1 1 1 10

もしイルカのコミュニティで育ち、 イルカの学校でこの表を暗記したのなら、 内容を大声で鳴いたことだろう。

0足す 0は0。

0足す1は1。

1足す0は1。

1足す1は0で、 1キャリー (繰り上がり)。

各結果が2ビットの値になるように、 先行するゼロを付けて加算表を書き直 してみよう。

+ 0 1 0 00 01 1 01 10

このように、 2つの2進数を足して得た2つのビットを、 サムビットとキャ リービットと呼ぶ (「1足す1は0で、 1 キャリー」 の 「キャリー」 で繰り上が りを示す)。 ここで、この2進数の加算表を2つに分けて、1つ目はサムビット 用とする。

第14章 論理ゲートによる加算

サム[和] 0 1 0 0 1 1 1 0

そして、2つ目はキャリービット用だ。

キャリー 0 1 [繰り上がり] 0 0 0 1 0 1

私たちの作る加算機は、 加算と繰り上がりを別々に行うので、このように2 進数の加算を捉えると便利だ。 2進数の加算機を作るためには、これらの操作を 実行する回路を設計する必要がある。 2進数を使っているので、この課題は大幅 に単純化できる。 回路のすべての部分 (スイッチ、 電球、 電線) を、 2進数の各 桁に対応させられるからだ。

10進数の加算と同じように、2つの2進数を列ごとに足そう。 一番右の列、 つまり最も下位のビットから足していくのだ。

01100101 +10110110 100011011

右から3番目の列を足すときに、 1が次の列に繰り上がることに注目しよう。

繰り上がりは右から6番目、 7番目、 8番目の列でも同様に起きる。 では、どれほどのサイズの2進数を足したらよいだろう?頭の中だけで加算 機を作っているのだから、 非常に長い数字を足す機械も作れるだろう。しかし、 現実的に考えて、 最大8ビットの2進数を足すことにしよう。 つまり、 00000000 から 11111111 までの2進数を足すことを考える。 これらの値は、 16進数で 00h ~FFh, 10 進数なら0~255の範囲となる。 2つの8ビット数

227

値の和は、 最大10進数で510、 16進数で1FEh、 2進数で111111110 となる。 2進数加算機のコントロールパネルは、次のようになる。

6 1 B A JA A 8

パネルには、8つのスイッチが2列に並んでいる。 これらのスイッチの集まり が入力装置だ。この入力装置を使って2つの8ビット数を 「キーイン」 する。 入力装置は、家の壁にあるスイッチと同じで、 スイッチがオフ (下) なら0、 オ ン (上) なら1となる。 いつも通り、最下位のビット (Least Significant Bit = LSB)は右側に、最上位ビット (Most Significant Bit = MSB) は左側にある。 パネルの下部にある出力装置は9個の電球からなる列だ。 これらの電球が答え を示す。 電球が点いていなければ0点いていれば となる。 8ビットの2つの 数値の和は9ビットの数値になることがあるため、 9個の電球が必要だ。 左端の 電球は、 和が10進数で255 を超えるときにのみ点灯する。

加算機の残りの部分は、 様々な方法で配線された論理ゲートで構成される。 ス イッチが論理ゲートのリレーを作動させ、 適切な電球を点灯させるのだ。 たとえ ば、 01100101 10110110 (先ほどの例で示した2つの数)を足したいとしよ う。 その場合、適切なスイッチを次のように操作する。

8 8 1 T + T 8 8 T ↓ ↓ g меке

228

第14章 論理ゲートによる加算

電球が点灯して、答えの 100011011 を示す (まあ、そうなることを願おう。 まだ作っていないし!)。

前の方の章で、 本書では多くのリレーを使うと述べた。 本章で作る8ビット加 算機には、少なくとも144個のリレーが必要になる。 足し合わせる 8組のビット それぞれに 18個のリレーを使うからだ。 回路の全体図を示したら、誰もがきっ と驚愕するだろう。 144個のリレーを複雑な配線でつないだところで、理解でき る人はいない。 そこで、 より単純なやり方でこの問題に取り組むことにする。 1ビットの数値を2つ足した結果のキャリービットの表を見て、 論理ゲートと

2進数の加算の関連性がすぐにわかったかもしれない。

キャリー 0 1 [ 繰り上がり] 0 0 0 1 0 1

これは、第8章で示した AND という名前の論理演算ならびに、 AND ゲート の出力と同じであることに気づいた人もいると思う。

AND 0 1 0 0 0 1 0 1

あるいは、2つの入力にラベルが付いている場合は、次の

ようになる。

A B AND 0 0 0 0 1 0 1 0 0 1 1 1

229

電気技師なら AND ゲートを、 リレーを何個も描くのではなく、 次のように記 号化する。

入力

AND出力

入力

左側の入力は、 加算される2つのビットを表すA、Bのラベルが付いている。 右側に置かれた AND ゲートの出力は、この2つの2進数を加算するためのキャ リービットだ。

さあ!ここまでは確実に前進している。 もっと難しいのは、 次のような動作を するようにリレーを組み合わせることだ。

サム[和] 0 1 0 0 1 1 1 0

これが、2つの2進数を足す問題のもう半分だ。 サムビットは、キャリービッ トほど簡単ではないが、何とかできるはずだ。 最初に気づくのは、 右下の結果を除けば、 論理 OR 演算にほぼ似ているとい うことだ。

OR 0 1 0 0 1 1 1 1

第 8 章では、 OR ゲートが次のように記号化されていたことを思い出そう。

230

第14章 論理ゲートによる加算

入力

入力B-

・OR出力

これとは別に、 私たちが求める結果に似ているのが、 NAND (すなわち、 Not AND) 論理演算だ。 出力が AND ゲートとは逆になっている。 左上の結果を除 いて、 2つの1ビットのサム (和) と同じである。

NAND 0 1 0 1 1 1 1 0

以下に示すのがNAND ゲートの記号である。

入力 入力B・ -NAND出力

これは、右側に小さな円があること以外、 AND ゲートと同じだ。 つまり、出 力はAND とは逆になる。

OR ゲートと NAND ゲートの両方を同じ入力に接続してみよう。 例によって、 小さなドットは配線がつながっていることを示し、 それ以外は重なっているだけ でつながってはいない。

入力B・ OR出力 -NAND出力

231

232

これらのOR ゲートとNAND ゲートの出力をまとめ、 加算機に求める出力と 比較したのが次の表である。

入力A 入力B OR出力 NAND出力 欲しい出力 0 0 0 1 0 0 1 1 1 1 1 0 1 1 1 1 1 1 0 0

私たちが欲しいのは、 OR ゲートとNAND ゲートの出力が両方とも1のとき のみ、 出力 (サム) が1になる仕組みである。 これは、 2つの出力が AND ゲー トへの入力となることを示唆している。

入力 入力B・ Sum (サム)

この回路では、入力が2つ、 出力が1つしかないことに注目しよう。 2つの入 力は、 OR ゲートとNAND ゲートの両方に入る。 そしてOR ゲートと NAND ゲートの出力が AND ゲートに入ることで、 欲しい結果が得られるのだ。

入力A 入力B OR出力 NAND出力 AND出力 [サム 0 0 0 1 0 0 1 1 1 1 1 0 1 1 1 1 1 1 0 0

第14章 論理ゲートによる加算 233

実はこの回路には、 名前がある。 それは排他的 OR ゲート、 もっと簡単に XOR ゲートと呼ばれる [X は eXclusive = 排他的の略]。 「エクスオア」 と発音する 人もいれば、 「エクスオーアール」という人もいる。 入力Aが1または入力B が1のときに出力が1になり、 両入力が1のときに出力は0になるので、排他 的OR ゲートと呼ばれる。 上記のように OR ゲート、 NAND ゲート、 AND ゲートを使って描く代わりに、 電気技師が使う XOR ゲートの記号を使うことに しょう。

入力 入力B・ ・XOR 出力

これは OR ゲートによく似ているが、 入力側にもう1つ曲線があるところが 違う。 XOR ゲートの動作を次に示す。

XOR 0 1 0 0 1 1 1 0

XOR ゲートは、本書で詳しく説明する最後の論理ゲートだ (電子工学では、時 折別のゲートも見かける。 それは2つの入力が同じ場合にのみ出力が1になるた め、一致ゲートあるいは等価ゲートと呼ばれる。 一致ゲートの出力は XOR ゲー トとは逆で、 その記号は XOR ゲートとほぼ同じだが出力端に小さな円が付く)。 これまでに知ったことを再確認しよう。 2つの2進数を加算すると、サムビッ トとキャリービットが生じる。

サム[和] 0 1 0 0 1 1 0

キャリー 0 1 [ 繰り上がり] 0 0 0 1 0 1

これらの結果は、次の2つの論理ゲートを使って得られる。

XOR 0 1 0 0 1 1 1 0 AND 0 1 0 0 0 1 0 1

2つの2進数の和は XOR ゲートの出力で与えられ、キャリービットは AND ゲートの出力で与えられる。 したがって、 AND ゲートとXOR ゲートを組み合 わせれば、 A、Bという2進数の数字を足すことができる。

入力 入力B サムアウト キャリーアウト

見た目以上に複雑であることを忘れないように! XOR ゲートは、 実は OR ゲート、NAND ゲート、 AND ゲートを組み合わせたもので、さらにそれぞれ のゲートは2つのリレーで構成されている。 しかし、詳細が隠れることによっ て理解が容易になる。このプロセスは、カプセル化と呼ばれることもある。複雑

234

第14章 論理ゲートによる加算 235

な集合体をより単純なパッケージの中に隠してしまうのだ。 細部まで見ようと思 えば、いつでもそのパッケージの包装を解くことはできるが、 実際にそうする必 要はない。

ここで、もう1つのカプセル化を紹介しよう。 AND ゲートと XOR ゲートを 何度も描き直す代わりに、 半加算器 [演算器であるため 「機」 ではなく 「器」を使う] と呼ばれる次のような箱で回路全体を表現するのだ。

入力 A S サムアウト 半加算器 B CO キャリーアウト

SとCOのラベルは、 Sum (サム) と Carry Out (キャリーアウト) の略であ る。 このような箱をブラックボックスと呼ぶこともある。 特定の入力の組み合わ せにより特定の出力が得られるが、 その実装は隠されている。 しかし、私たちは 半加算器の内部で何が行われているかを知っているので、ここではより正確には クリアボックスと呼ぶべきだろう。

このボックスに、 半加算器というラベルが貼られているのには理由がある。 確 かに、これは2つの2進数を加算し、サムビットとキャリービットを出力する。 しかし、1ビットより大きなサイズの2進数を足したい場合に半加算器は、 最下 位の2つのビットを加算するとき以外は不適切だ。 1つ前の1ビット加算から得 られるかもしれないキャリービットを加算できないからだ。 たとえば、以下のよ うな2つの2進数を加算するとしよう。

1111 + 1111 11110

半加算器が使えるのは、 最も右の列の加算だけだ。 1+1は0でキャリーは 1。 右から2番目の列では、キャリーを考慮すると実際には3つの2進数を加算す る必要がある。 これはすべての後続の列に当てはまる。 2つの2進数の各ビット の加算には、前の列からのキャリービットを含める必要があるのだ。

236

3つの2進数を足すには、 2つの半加算器と1つのOR ゲートが必要で、次の ように配線される。

キャリーイン A A 半加算器 入力B B CO 半加算器 B CO ・サムアウト キャリーアウト

これがどうして機能するのかよくわからないかもしれない。 まず、 左側の最初 の半加算器への入力である、 AとBから始めよう。 出力はサムとキャリーだ。

出力されるサムは、 2番目の半加算器の入力となり、 キャリーイン (Carry In) と呼ばれる前の列からのキャリーと足される。 つまり、 そのキャリーインと 最初の半加算器からのサムが2番目の半加算器に入力される。 2番目の半加算器 からのサムが最終的なサムとなる。 2つの半加算器からのキャリーアウト (Carry Out) はOR ゲートの入力となる。ここでもう1つ半加算器が必要だと思うかも しれない、もちろんそれでもうまくいく。 しかし、すべての可能性を検討してみ ると、 2つの半加算器からのキャリーアウトが同時に1になることはないことが わかる。 入力が両方とも1になることがなければ、 OR ゲートは XOR ゲートと 同じなので、ここでの加算にはOR ゲートで十分だ。

この図を何度も描く代わりに、 私たち全加算器と呼ぶ次の図を描くことにする。

キャリーイン CI サムアウト 入力 A 全加算器 CO キャリーアウト 入力B B

次の表は、全加算器への入力とその結果の出力の可能な組み合わせをまとめた ものだ。

第14章 論理ゲートによる加算

入力A 入力B キャリーイン サムアウト キャリーアウト 0 0 0 0 0 0 1 0 1 0 1 0 0 1 0 1 1 0 0 1 0 0 1 1 0 0 1 1 0 1 1 0 1 0 1 1 1 1

本章の冒頭で、 2進数の加算機に 144個のリレーが必要になると書いた。 そ れがどのようにして算出されたかを説明しよう。 それぞれのAND, OR、 およ びNAND ゲートは、2つのリレーを必要とする。 したがって、 XOR ゲートは 6つのリレーから構成される。 半加算器は XOR ゲートとAND ゲートの組み合 わせなので、 半加算器には8個のリレーが必要となる。 全加算器は、2つの半加 算器と OR ゲート、 つまり 18個のリレーで構成されている。 そして8ビット加 算機には、8個の全加算器が必要となる。 つまり、合計で144個となる。

スイッチや電球が付いた元々のコントロールパネルを思い出そう。

1 1 0 1 1 1 1 1

これで、このスイッチと電球を8つの全加算器に配線する準備が整った。 最下位ビットから始めよう。まず、右端の2つのスイッチと右端の電球を全 加算器に接続する。

237

V CI A 全加算器 B CO <W> 次のCIへ

2つのバイナリー数を足そうとするとき、 最初に足す最も右側の桁はほかとは 異なる。 次の桁 (左隣) 以降は前の桁からのキャリービットを含む可能性がある からだ。 最初の桁にはキャリービットは不要である。 それが全加算器のキャリー インがグランドに接続されている理由だ。 これは0ビットを意味している。 最 初の桁のバイナリーペアの加算は、もちろん、 キャリービットを生み出す可能性 がある。 そのキャリーアウトは次の桁への入力となる。

次の桁の2つのビット (AとB) と次の電球については、以下のように配線 された全加算器を使用する。

前のCOから V CI A 全加算器 B CO www 次のCIへ

最初の全加算器からのキャリーアウトは、この2つ目の全加算器への入力と なる。 その後の各桁も同じ方法で配線される。 ある桁からの各キャリーアウト

238

第14章 論理ゲートによる加算

は、次の桁へのキャリーインとなる。

最後に、8番目のスイッチペア (コントロールパネルの左端にあるスイッチペ ア) が、 最後の全加算器に接続される。

V 前のCOから CI A 全加算器 CO B www <W>

最終的なキャリーアウトはここでは9番目の電球に接続されている。 これで完成だ。

全部で8つとなる全加算器の構成を別の視点から見てみよう。 それぞれのキャ リーアウトが次のキャリーインにつながるような形で示されている。

V V V V V V 10 A B CI A B CI A B CI A B CI FA FA FA B CI FA A B C AB CI FA FA CO S CO CO S CO S CO S CO S CO S CO S

これらの全加算器の順序は、コントロールパネル上のスイッチと電球の順序と 同じだ。 最下位ビットは右端にあり、 最上位ビットは左端にある。 これは通常の

239

数字の書き方と同じである。 各桁のキャリーアウトが次の上位ビットのキャリー インになるように配線されていることに注意してほしい。 最初のキャリーインは グランドに接続されていて (0ビットを意味する)、 一方で最後のキャリーアウ トは9番目の電球を点灯させる。

以下に示すのが1つのボックスにカプセル化された完全な8ビット加算器だ。 入力には A A Bo~ B, というラベルが付いており、 また出力には So S, のラベルが付いている (SはサムのS)。

入力 入力B キャリーイン A A6 As As As A2 As Ac B B B B By B2 By Bo CO 8ビット加算器 CI St S6 Ss 54 S2 S1 So キャリーアウト サムアウト

これは、 複数ビットで構成される数値の各ビットにラベルを付ける一般的な方 法だ。 ビット A6, Bo, So は最下位、つまり右端のビットである。 そしてAB7 S, ビットは最上位、 つまり左端のビットとなる。 たとえば、2進数の 01101001 にこれらの添え字を当てはめると次のようになる。

A A6 AS A4 A₁₂ A, A₁ A 0 1 1 0 1 0 0 1

添え字は0から始まり、 より上位の桁ほど大きくなる。 これは2のべき乗の 指数に対応しているからだ。

27 26 25 24 23 22 21 20 0 1 1 0 1 0 0 1

240

第14章 論理ゲートによる加算

241

これらの2のべき乗をその下の桁の数で掛け、それらをすべて足すと、 0110100110 進数に相当する数になる。 64 +32 + 8 + 1 すなわち 105 だ。 8ビット加算器の別の描き方としては、次のようなものもある。

入力B キャリーイン ↓ A7... A By...Bo CO 8ビット加算器 CI S7... So キャリーアウト サムアウト

入力を示す太い矢印の内側に8があるのは、それぞれが8つの個別信号のグ ループであることを表している。 これらは、1バイトのデータパスだ。 また、 8 ビットの数であること示すために、 A7 ... A6, B7... B, S7... So とラベルが付い ている。

一度8ビット加算器を作ってしまえば、 もう1つ作ることもできる。 それら をカスケード [隣接するように] 接続することで、2つの16ビット数を容易に加 算できる。

キャリーアウト 入力 入力B 入力 入力 (上位8ビット) (上位8ビット) (下位8ビット) (下位8ビット) A7... A By...B A7... A By... B CO 8ビット加算器 CI CO 8ビット加算器 CI SS ST...So 16ビットのサム

16ビットの2つの入力値はそれぞれ、ローバイト [下位8ビット] とハイバイ ト[上位8ビット]と呼ばれる2つのバイトに分割される。 右の加算器のキャリー アウトは、左の加算器のキャリーインに接続されている。 左の加算器は、 加算す る2つの数値の上位8桁を入力とし、 結果の上位8桁を出力として生成する。

さて、「これが本当にコンピュータが数値を加算する方法なのか?」 と疑問を 持つ人もいるかもしれない。

素晴らしい疑問だ!

242

第15章

これは本当なのか?

前章では、 リレーを配線して1ビットの加算器を作り、 それを8つ組み合わ せて2つのバイトを加算する方法を紹介した。 さらに、それらの8ビット加算 器を連結して、さらに大きな数を加算できることも見てきた。 そこであなたは疑 問に思ったかもしれない。 これは、 本当にコンピュータが数字を足し合わせる方 法なのだろうかと。

まあ、答えはイエスでもあり、ノーでもある。 大きな違いの一つは、現代の コンピュータはもはやリレーから作られていないということだ。 しかし、 そう だった時期もある。

1937年11月、 ベル研究所の研究者ジョージ・スティビッツ (1904-1995) は、 電話交換回路に使用されるリレーを2つ家に持ち帰った。 彼はキッチンの テーブルで、 これらのリレーを電池、 2つの電球 そしてブリキ缶から切り出し た金属片で作ったスイッチと組み合わせた。 これは前章で見たような1ビット 加算器だった。 スティビッツはこれを Model K [モデルK] と呼んだ。 なぜなら、 彼はそれを自分のキッチンテーブルで作ったからだ。

モデルK 加算器はリレーが算術を実行できることを示したが、これはのちに 「概念の実証(proof of concept)」 「新しいアイデアや技術の試作開発に入る前段階の検 [過程] と呼ばれるものだった。 ベル研究所はこの作業を継続するプロジェクト を認可し、1940年には複素数計算機 (Complex Number Computer) が稼働し た。それは400以上のリレーで構成されており、 複素数 (実部と虚部からなる 数) の乗算に特化していた (虚数は負の数の平方根であり、 科学や工学の応用で

役立つ)。2つの複素数を乗算するには、4つの別々の乗算と2つの加算が必要 だ。 複素数計算機は、10進数で最大8桁の実部と虚部を持つ複素数を扱うこと ができた。 この乗算を行うのには約1分かかった。

だが、これが最初のリレー式コンピュータではない。 時系列的には、 最初のも のはコンラート・ツーゼ (1910-1995) によって作られた。 工学部の学生だった 彼は1935年、ベルリンにある両親のアパートで機械を作り始めた。 彼の最初の 機械Z1はリレーを使用せず、 リレーの全機能を機械的に模倣していた。 続く Z2はリレーを使用し、 35mm 映画フィルムに穴を開けることでプログラミング ができた。

1937年頃、 ハーバード大学の大学院生ハワード・エイケン (1900-1973)が、 大量の繰り返し計算を行う何らかの方法を必要としていた。 これがハーバード大 学とIBMとの共同作業につながり、 自動順序制御計算機 (Automatic Sequence Controlled Calculator, ASCC) と呼ばれる機械が生まれた。 これは のちにハーバード・マークⅠという名で知られるようになった。 1943年に完成 し、動作中のこの機械のリレーのクリック音は、ある人には 「編み物をしている 女性が部屋中にいるような音」 に聞こえたという。次のマークIIは史上最大の リレー式機械で、 1万3000個のリレーを使用していた。 エイケンが指導する ハーバード計算研究所 (Harvard Computation Laboratory) では、最初のコン ピュータ科学のクラスが設けられた。

これらのリレー式コンピュータは、電気と機械装置を組み合わせていたために 電気機械式コンピュータとも呼ばれ、 動作する最初のデジタルコンピュータだっ た。

これらのコンピュータを表現する言葉であるデジタルは、 1942年にジョー ジスティビッツが、 それまで数十年にわたり一般的に使用されていたアナログ コンピュータと区別するために作り出したものだ。

偉大なアナログコンピュータの1つに、 MIT の教授であったヴァネヴァー・ ブッシュ (1890-1974) と彼の学生たちが1927年から1932年にかけて構築し また微分解析器がある。 この機械は、回転する円盤、 軸、 歯車を使用して、 微積分 を伴う方程式である微分方程式を解く。 微分方程式の解は数値ではなく関数であ り、 微分解析器はこの関数のグラフを紙に印刷する。

アナログコンピュータは、さらに歴史を振り返って、 物理学者ウィリアム・ト

244

第15章 これは本当なのか?

ムソン (1824-1907)、のちのケルビン卿が設計した潮汐予報器までさかのぼれ る。1860年代、 トムソンは潮の満ち引きを分析し、そのパターンを様々な周波 数と振幅の正弦波の列に分解する方法を思いついた。 トムソンの言葉を借りれ ば、 彼の潮汐予報器の目的は 「全体の潮汐の昇降の基本成分を計算する大変な機 械的作業を行うために、脳を真鍮で置き換えること」だった。 つまり、 それは滑 車 歯車、 プーリーを使って成分の正弦曲線を足し合わせ、 結果を紙のロールに 印刷し、未来の潮の満ち引きを示すものだ。 しんちゅう

微分解析器も潮汐予報器も、 どちらもグラフを印刷する機能があった。 興味深 いことに、 数値を使わずにグラフの印刷を行ったのだ! これがアナログコン ピュータの特徴である。

少なくとも1879年には、ウィリアム・トムソンはアナログコンピュータとデ ジタルコンピュータの違いを理解していたが、彼は異なる用語を使用していた。 自分の潮汐予報器のような器具を 「連続計算機」 と呼んで、 「純粋に算術的」な 機械、たとえば「バベッジによる、 壮大だが部分的に実現した計算機の概念」と は区別していた。

ここでトムソンが言及しているのは、英国の数学者チャールズ・バベッジ (1791-1871)の有名な計算機である。 振り返ってみると、 バベッジは、アナロ グコンピュータが一般的になるずっと前からデジタルコンピュータを構築しよう とした点で、歴史的には異質な存在だ。

バベッジの時代は (その後も長い間)、コンピュータ算する人間のことだった [日本では「計算手」という職業もるために対数表が頻繁に使われ、 航海術などには三角 関数表が欠かせなかった。 新しい数値表を発表しよう と思ったら、何人ものコンピュータを雇い、 彼らに働 いてもらって、最後に結果を組み上げることになる。 もちろん、 最初の計算から、最終的なページを印刷す るための活字の設定まで、 どの段階でも間違いが発生 する可能性があった。

とは、雇われて数字を計 あった]。 乗算を簡単にす

バベッジは非常に几帳面な人物で、 数値表に間違い があると大きな苦痛を感じざるをえなかった。 1820 年頃から、 彼はこれらの表を自動で作成するエンジン

Bettmann/Getty Images

245

246

[機関] を作ることができるという考えを持っていた。 それは印刷のための活字設 定までをも含んでいた。

バベッジの最初の機械は、 数値表の作成に関連した特定の作業を行うために 「階差機関 (Difference Engine)」と名づけられた。 対数表を作成するためには、 すべての値の対数を計算する必要はないことはよく知られていた。 代わりに、 選 択した値の対数を計算し、それから間の数値を、比較的簡単な計算である「差」 を使用して補間できた。

バベッジは、これらの差を計算するために階差機関を設計した。 それは 10 進 数を表す歯車を使用し、 加算と減算が可能だった。 しかし、英国政府からの一部 の資金援助にもかかわらず完成には至らず、 バベッジは1833年に階差機関を放 棄した。

バベッジはその頃、 さらに優れたアイデアの下、 「解析機関 (Analytical Engine)」と呼ばれる機械を考えていた。 彼は設計と再設計を繰り返し (実際に 作ったのは小さな模型と部品だった)、 それは彼が亡くなるまで幾度となく続い た。 解析機関は19世紀が生み出した、のちのデジタルコンピュータに最も近い 存在だ。 バベッジの設計では、(私たちの考えるメモリーに相当する) 「ストア」 と、算術を行う「ミル」 があった。 乗算は加算の繰り返しにより、 除算は減算の 繰り返しにより、 実行できた。

解析機関の最大の魅力は、穴の開いたカードを使ってプログラミングができる ことだ。 バベッジはこのアイデアを、ジョゼフ マリー ジャカール (17521834) によって開発された革新的な自動織機から得た。 ジャカード織機 (1801 年頃) は、 織り込まれる絹の模様を制御するために、穴が開けられた厚紙を使用 した。 ジャカール自身による力作は、 約1万枚のカードを使った白黒の絹によ る自画像だった。

バベッジは、解析機関で実現したかったものについて、包括的で首尾一貫した 説明を残していない。 彼は、 奇跡を数学的に正当化する文章を書いたり、スト リートミュージシャンを非難する論説を書いたりするときの方がよほど雄弁だっ た。

バベッジの不手際を補ったのは、ラブレス伯爵夫人だったオーガスタ・エイ ダ・バイロン (18151852) だ。 彼女は詩人であるバイロン卿の唯一の正統な娘 だったが、彼女の母親は、娘が危険な詩的気質を父親から受け継いでしまうかも

第15章 これは本当なのか?

と考え、それに対抗すべく娘を数学へと導いた。

ラブレス夫人は、 論理学者のオーガスタス・ド・ モルガン (本書の第6章と第8章ですでに登場し た) とともに学び、 バベッジの機械に魅了された。 そうした中、 「解析機関」に関するイタリア語の 記事を翻訳する機会があり、 エイダ ラブレスが その仕事を引き受けた。 彼女の翻訳は 1843年に 出版されたが、 彼女が多数の注釈を加えたために、 記事の長さは元の長さの3倍にもなった。 これら の注釈の1つには、バベッジの機械のためのサン プルの命令セットが含まれていた。 その結果、 ラブレスは史上初のコンピュータ プログラマではないものの (それはもちろんバベッジ自身だろう)、 最初にコン ピュータプログラムを出版した人物と位置づけられることになった。 雑誌や書籍でコンピュータプログラムのチュートリアルを出版したことがある

人なら、自分自身をエイダの末裔と考えることができるだろう。

私たちは、 エイダ ラブレスがバベッジの機械について書き残した、 「ジャ カード織機が花や葉を織るように、解析機関は代数的なパターンを織るといって 「もよいのです」 という最も詩的な表現を受け取っているのだ。

また、エイダは、コンピューティングが単なる数字の計算を超えて進化すると いう、時代を先取りした視点を持っていた。 数値で表現できるものは何でも、解 析機関が扱える主題だったのだ。 彼女は次のように書き残している。

たとえば、音程を持った音同士の、 和音や作曲の科学における基本的な関係が 多彩な表現と適応を可能にしているのなら、 解析機関はとても複雑で広がりを 持った、 精巧かつ科学的な楽曲を生み出すことができるでしょう。

バベッジとサミュエル・モールスがほぼ同時代の人物であり、 バベッジが ジョージブールの仕事も知っていたことを考えると、バベッジが電信リレーと 数理論理学との間の重要な関連性を見つけ出さなかったことは残念だ。 リレーか らコンピュータを作るようになったのは、ようやく1930年代に入ってからであ る。 ハーバード・マークⅠは最初に数値表を印刷したコンピュータだ。 バベッジ

Hulton Archive/Stringer/Getty Images

247

の夢は100年以上も経ってついに実現したのだった。

こんにち 1930年代の最初のデジタルコンピュータから今日に至るまで、コンピュータ の歴史はすべて「より小さく、 より速く、 より安く」という3つのトレンドに 集約される。

リレーは、コンピュータを構成するのに最適なデバイス [機器] とはいえない。 リレーは機械的なもので、 金属片を曲げて動作するため、 長時間の動作で壊れる ことがある。 また、 接触部間にホコリや紙片が詰まってしまうと動作しなくな る。 1947年に起きた有名な事件だが、ハーバード・マークIIのリレーから蛾が 取り出されたことがある。 1944年にエイケンのスタッフになり、のちにコン ピュータプログラミング言語の分野で非常に有名になるグレース・マレー・ホッ パー (1906-1992) は、 「初めてバグ (虫) が見つかった実例」 というメモとと もに蛾をコンピュータのログブックに貼り付けた。

リレーの代替品として考えられたのが真空管だ (米国では真空 「チューブ」 (tube)、 英国では真空 「バルブ」 (valve) と呼ばれる)。 これは、 無線と関連し ジョン・アンブローズ・フレミング (1849-1945) とリー・デ・フォレスト (1873-1961)によって開発された。 1940年代に至るまで真空管は長い間、 電 話の増幅に使用されており、 また、 ほぼすべての家にはラジオ信号を増幅して聞 こえるようにした、 真空管が光る据え置き型ラジオがあった。 真空管はリレーの ように配線され、 AND OR NAND NOR の各ゲートを形成できる。

論理ゲートがリレーあるいは真空管のどちらで作られているかどうかは重要で はない。 論理ゲートはいつでも加算器やその他の複雑なコンポーネント [部品) に組み込むことができる。

しかし、真空管には問題があった。 高価で、 大量の電気を必要とし、大量の熱 を発生したのだ。 さらに大きな欠点は、結局は焼き切れるということだった。 こ れは当時の人たちが生活の中で仕方なく受け入れていた事実だった。 真空管ラジ オの所有者は、定期的に真空管を交換することに慣れていた。 電話システムは十 分な冗長性を持つように設計されていたので、 たまに真空管が焼き切れても大き な問題ではなかった (それに誰も電話システムが完全に動作することを期待して いなかった)。 しかし、コンピュータ内の真空管が焼き切れたときには、すぐに 故障に気づけないかもしれない。 しかも、 コンピュータはとても多くの真空管を 使用していたために、統計的には数分ごとに焼き切れる可能性があった。

248

第15章 これは本当なのか?

249

リレーよりも真空管を使用する大きな利点は速度だった。 リレーが切り替わる 速度は、せいぜい1000分の1秒、 つまり1ミリ秒程度だ。 一方、 真空管は約 1 マイクロ秒、 つまり 100万分の1秒で切り替わる。 面白いことに、速度の問題 は初期のコンピュータ開発では大きな検討課題ではなかった。 なぜなら、全体的 なコンピューティングの速度は、 機械が紙やフィルムテープからプログラムを読 み込む速度に比例していたからだ。 コンピュータがこのように作られている限 り 真空管がリレーよりもどれだけ速いかはあまり問題ではなかった。

1940年代初頭から、 真空管がリレーに代わって新型コンピュータに搭載され るようになった。 1945年までに、 この移行は完了した。 リレーを使った機械は 電気機械式コンピュータと呼ばれていたが、 真空管は最初の電子式コンピュータ [電子計算機] の基盤となった。

エニアック ペンシルベニア大学ムーア校電気工学科で、 J.プレスパー・エッカート (1919-1995)とジョン・モークリー (1907-1980) が ENIAC (Electronic Numerical Integrator and Computer [電子式数値積分計算機]) を設計した。 それは 1万8000本の真空管を使用し、 1945年末に完成した。 重さ (約30トン)で見 るなら、ENIACはこれまで (おそらくこれからも) 作られた中で最大のコン ピュータだ。 エッカートとモークリーがコンピュータの特許を取得しようとした 試みは、競合するジョンV アタナソフ (1903-1995) による主張により阻止 された。 アタナソフはそれ以前に電子式コンピュー

タを設計していたが、うまく動作はしていなかった。 ENIAC は数学者ジョン・フォン・ノイマン (1903-1957)の関心を引いた。 ハンガリー出身の フォン・ノイマンは、1930年以降アメリカに住ん でいた。 ノイマンは、頭の中で複雑な算術を行うこ とで名高い、華やかな人物だった。 プリンストン高 等研究所の数学教授でもあり、量子力学からゲーム 理論の経済への応用まで、多種多様な研究を行って いた。

エドバック フォン・ノイマンは ENIAC の後継機、 EDVAC (Electronic Discrete Variable Automatic Computer [電子式離散変数自動計算機]) の設計を手助けした。 特に、 1946年にアーサー・W・バークス、ハーマン・

Bettmann/Getty Images

Hゴールドスティンと共著で発表した論文 「電子計算機の論理設計に関する予 備的考察 (Preliminary Discussion of the Logical Design of an Electronic Computing Instrument)」 では、 EDVAC を ENIACより大幅に進歩させるコンピュータの特 徴をいくつか述べている。 ENIACは10進数を使用していたが、EDVAC の設 計者たちはコンピュータが内部で2進数を使うべきだと考えていた。また、可 能な限り多くのメモリーを持つべきであり、そのメモリーはプログラムが実行さ れる際に、プログラムコードとデータの両方を保存するために使用されるべきだ とも考えた(ENIACの場合はそうではなかった。 ENIACにおけるプログラミ ングとは、スイッチを切り替えたりケーブルを差し込むことだった)。EDVAC のこの設計は、のちにプログラム内蔵方式と呼ばれるようになった。 この設計上 の決断は、私たちが現在「フォン・ノイマン・アーキテクチャ」 と呼ぶコン ピュータの重要な進化の一歩だった。

「ユニパック 1948年、 エッカート・モークリー・コンピュータ社 (のちのレミントン・ラ ンド社の一部) は、 初の商用コンピュータとなる 「ユニバーサルオートマチッ クコンピュータ」 UNIVAC) の開発に着手した。 それは 1951年に完成し、 最初の1台が国勢調査局に納品された。 UNIVACは米4大ネットワークの1つ、 CBSのプライムタイムでデビューを果たし、 1952年の大統領選挙の結果予測で 使われた。 アンカーマンのウォルター・クロンカイトはそれを 「電子頭脳 (electronic brain)」 と呼んだ。 そして同年 (1952年) には、 IBM も同社初の 商用コンピュータシステム、 701 を発表した。

こうして、 企業や官公庁におけるコンピューティングの長い歴史が始まった。 この歴史もとても興味深いものだが、 私たちは別の歴史を追いかけよう。 この歴 史は1947年当時、 ほとんど注目されていなかった電子機器の飛躍的な進歩に を発する。 この進歩によってコンピュータのコストとサイズが縮小し、家庭へと 普及する道が開かれたのだ。

ベル電話研究所は、 アメリカ電話電信社 (ATT) が科学技術研究部門を事業部 門から正式に分離し、1925年1月1日に子会社を設立したことにより誕生した。 ベル研究所の主な目的は、 電話システムを改良するための技術開発だった。 幸い なことに、この使命はあらゆるものを含むほど曖昧だったが、 電話システムにお ける永遠の目標の1つは、有線で伝送される音声信号の歪みのない増幅だった。 真空管の改良には相当な研究と技術が注がれた。 1947年12月16日、ベル

250

第 15 これは本当なのか? 251

究所のジョン・バーディーン (1908-1991) とウォルター・ブラッテン (19021987) という2人の物理学者が、 それまでとは異なるタイプの増幅器を作成し た。 この新しい増幅器は、 半導体と呼ばれる元素であるゲルマニウムの板と、 金 箔の短冊から構成されていた。 1週間後、 彼らはそれを上司のウィリアム・ ショックレー (1910-1989) に示した。 それこそが、20世紀で最も重要な発明 と呼ぶ人もいる、 最初のトランジスタだった。

トランジスタは突然出現したわけではない。 その8年前の1939年12月29 日に、ショックレーはノートに 「真空管ではなく半導体を使用する増幅器が原理 的に可能だと思いついた」 と記していた。 最初のトランジスタが実証された後、 それを完全な形にするために何年もの時間が費やされた。 ショックレー、バー ディーン ブラッテンが 「半導体の研究およびトランジスタ効果の発見」 に対し てノーベル物理学賞を受賞したのは1956年のことだった。

本書の前半で、 導体と絶縁体について説明した。 導体は電流の通過 (導通)に 非常に適しているため、 導体と呼ばれている。 銅、 銀、 金が最も優れた導体であ りこれらすべてが周期表の同じ列にあることは偶然ではない。

ゲルマニウムやシリコンなどの元素 (そして一部の化合物) は半導体と呼ばれ る。 これはその導電性が導体の半分という意味ではなく、 その導電性が様々な方 法で操作できるという意味だ。 半導体は最外殻に4つの電子を持っており、こ れは最外殻が持つことができる最大数の半分である。 純粋な半導体では、原子同 士が非常に安定した結合を形成し、 ダイヤモンドに似た結晶構造を持つ。 このよ うな物質は良い導体ではない。

しかし、半導体はドープすることができる。 ドープとは、特定の不純物を組み 合わせるという意味だ。 ある種の不純物は、原子間の結合に必要な電子以上に余 分な電子を加える。 こうしたできたものは、 N型半導体 (Nはネガティブ[負] という意味)と呼ばれる。 また別の種類の不純物を添加すると、 P型半導体が生 まれる (Pはポジティブ [正]という意味)。

P型半導体を2つのN型半導体の間に挟むことで増幅器にすることができる。 これはNPN トランジスタと呼ばれ、 3つの部分はコレクター、ベース、エミッ ターと呼ばれる。

次ページに示すのはNPN トランジスタの回路記号だ。

252

ベース コレクター エミッター

ベースにかかる小さな電圧が、 コレクターからエミッターへのはるかに大きな 電圧を制御できる。 ベースに電圧がない場合、 それは事実上トランジスタをオフ にする。

トランジスタは通常、 直径約1/4インチ [約6.35 ミリメートル] の小さな金属製 の缶にパッケージされ、3本のワイヤーが突き出している

トランジスタは固体電子工学の幕開けとなったが、 これはトランジスタが真空 を必要とせず、もっぱら固体、 具体的には半導体、 そして最も一般的にはシリコ ンから作られることを意味する。 真空管に比べてトランジスタははるかに小さ く、電力の消費も少なく、 発熱も少なく、 寿命も長い。 ポケットに真空管ラジオ を入れて持ち運ぶことは考えられなかった。 しかし、 トランジスタラジオは小さ な電池で動かせるし、 真空管と違って熱くならない。 1954年のクリスマスの朝、 一部の幸運な人たちはプレゼントを開け、ポケットにトランジスタラジオを入れ て持ち歩けるようになった。 最初のポケットラジオは、 半導体革命の重要企業で あるテキサス・インスツルメンツ社製のトランジスタを使用していた。

とはいえ、トランジスタを使った最初の商用製品は補聴器だった。 AT&Tは、 生涯をかけて聴覚障害者のために活動した (AT&T の前身であるベル電話会社 の創業者である) アレクサンダー・グラハム・ベルの遺志を尊重して、補聴器 メーカーがロイヤリティを支払うことなくトランジスタ技術を使用できるように したのだ。

第15章 これは本当なのか?

1960年に初のトランジスタテレビが登場し、現在では真空管式家電はほとん ど姿を消している(ただし、 全くなくなったわけではない。 一部のオーディオ愛 好者やエレキギター奏者の中には、トランジスタアンプよりも真空管アンプの音 を好む者もいる)。

1956年、 ショックレーはベル研究所を離れ、 ショックレー・セミコンダク ター・ラボラトリーズ [ショックレー半導体研究所] を設立した。 そのとき彼は、自 らが育ったカリフォルニア州パロアルトに移り住んだ。 この地域に設立された IT企業では、彼の会社が最初だったのだ。 やがて、ほかの半導体メーカーやコ ンピュータメーカーも進出し、サンフランシスコの南側一帯は現在、「シリコン バレー」 と呼ばれている。

真空管はもともと増幅用として開発されたものだが、 論理ゲートのスイッチに も利用できた。 トランジスタでも同じことだ。 リレー式とよく似た構造のトラン ジスタ式 AND ゲートを以下に示す。

入力 ・出力

V

入力A と入力Bの両方に電圧がかかっているときだけ、両方のトランジスタが 電流を流すので、出力に電圧がかかる。このとき、抵抗がショートを防ぐ。

次ページに示す図のように2つのトランジスタを配線するとOR ゲートにな る。両トランジスタのコレクターは電源に接続され、エミッター同士が接続され ている。

253

入力 入力 出力

リレーから論理ゲートやその他の部品などを構成する際に学んだ知識は、すべ てトランジスタでも使うことができる。 リレー 真空管、 トランジスタは、いず れも当初は増幅を目的として開発されたものだが、 同様の方法で接続すること で、コンピュータを構成する論理ゲートを作ることができる。 最初のトランジス タ式コンピュータは1956年に製作され、 数年で新しいコンピュータの設計から 真空管は駆逐された。

トランジスタは確かにコンピュータをより信頼性が高く、 小型で、電力消費を 抑えるものにしてくれるが、 それがコンピュータを構成する作業を必ずしも簡単 にしてくれるわけではない。 トランジスタを使えば、 より小さな空間に多くの論 理ゲートを詰め込めるが、それでもこれらの部品すべてのつなぎ方を考える必要 がある。 リレーや真空管を配線して論理ゲートを作るのと同じくらい、 トランジ スタを配線するのも困難なのだ。

しかし、すでにおわかりのように、 特定の組み合わせのトランジスタが頻繁に 登場する。 トランジスタのペア [組] はほぼ必ずゲートとして配線される。 ゲー トは多くの場合、 加算器や、 第10章の終わりで見たようなデコーダーやエン コーダーに配線される。 第17章では、ビットを保存する機能を備えた非常に重 要な論理ゲートの組み合わせであるフリップフロップと、 2進数で数えるカウン

254

第15章 これは本当なのか?

ターを見ることになるだろう。 これらの回路の組み立ては、 トランジスタが同じ やり方であらかじめ配線されていれば、 ずっと簡単になるだろう。

この考え方は最初にイギリスの物理学者ジェフリー・ダマー (1909-2002)に よって1952年に提案されたようだ。 「未来を少しだけのぞいてみましょう」と 彼は言った。

トランジスタの出現と半導体の研究によって、いまや電子機器を内部に 電線を持たない固体ブロックとして考えることが可能になりました。 このブロックは絶縁体、 導体、整流体、増幅体の層から 成り立っていて、 電気的な機能は各層から適切に切り出した領域同士を 直接接続することで実現されるでしょう。

しかし、 実際の製品が登場するまでには数年を要した。

ダマーの予測を知らないまま、 1958年7月にテキサスインスツルメンツの ジャック・キルビー(1923-2005) は、複数のトランジスタや抵抗器などの電子 部品を1つのシリコン片から作ることができると考えた。 6か月後の1959年1 月には、ほぼ同じアイデアがロバート・ノイス (1927-1990) の頭にも浮かん だ。 ノイスは元々ショックレーセミコンダクター・ラボラトリーズで働いてい たが、 1957年に彼と7人の科学者がその会社を離れてフェアチャイルド セミ コンダクター・コーポレーションを設立した。

技術の歴史において、 同時に発明がなされることは普通に見られる。 キルビー がデバイスをノイスよりも6か月前に発明し、 テキサスインスツルメンツが フェアチャイルドよりも先に特許を申請したにもかかわらず、 ノイスが最初に特 許を取得した。 法的な争いが続き、一連の紛争がすべての関係者に満足のいく形 で解決されるまでには10年を要した。 キルビーとノイスが一緒に仕事をしたこ とはなかったが、現在では彼らは一般にIC (Integrated Circuit、 集積回路)、一 般名称としてはチップの共同発明者と見なされている。

集積回路は、シリコンの薄いウェハーを重ね、 特定の領域を精密にドープ [不 物を添加する工程] し、 エッチング [回路を作る加工工程] するという複雑なプロセ スによって製造される。 新しい集積回路を開発するのは高価だが、大量生産の利 点がある。 つまり、 作り出す量が増えれば増えるほど単価は下がる。

255

実際のシリコンチップは薄く、壊れやすいため、 チップを保護すると同時に、 チップ内のコンポーネントをほかのチップに接続するために、 適切にパッケージ ングする必要がある。 初期の集積回路はいくつかの方法でパッケージングされた が、最も一般的なものは、 側面から突き出した14 ピン、 16 ピン、あるいは最 大で40ピンを持つ長方形のプラスチック製のデュアルインラインパッケージ (DIP) だ。

ここで示すのは16ピンのチップだ。 図のように小さな凹みが左側になるよう にチップを持つと、ピンは左下から始まり右側を回って左上のピン 16で終わる。 側面に隣り合うピンとピンの間隔は正確に 1/10インチ [約2.5ミリメートル] だ。

1960年代を通じて、 宇宙開発計画と冷戦が初期の集積回路市場を牽引した。 民生用では、 集積回路を内蔵した最初の製品は1964年にゼニスが販売した補聴 器だった。 1971年には、 テキサスインスツルメンツが最初のポケット計算機 を、 パルサーが最初のデジタルウォッチを発売した(もちろん、 デジタルウォッ チ用のICは、先ほど示した例とは大きく異なるパッケージングがなされてい る)。 その後、集積回路を設計に取り入れた多くの製品が続いた。

1965年、 ゴードン・E・ムーア (当時はフェアチャイルドに所属し、のちに インテルの共同創業者となる) は、 1959年以降、 技術の進歩に伴って単一の チップに搭載できるトランジスタの数が毎年2倍になっていることに気づいた。 彼はこの傾向が続くと予測した。 しかし、 実際の傾向はやや遅く、のちに 「ムー 「アの法則」と名づけられたこの法則は、チップ上のトランジスタの数が18か月 ごとに2倍になると予測するように修正された。 これは驚異的な進歩の速さで、 家庭用コンピュータが数年で陳腐化する理由を示している。 21世紀に入って20 年が経ち、 ムーアの法則も成り立たなくなったようにも見えるが、現実は依然と してその予測に近い状態だ。

集積回路を構成するコンポーネントを作成するために、いくつかの異なる技術

256

第15章 これは本当なのか?

ティーティーエルシーモス が使用された。 これらの技術は、それぞれが 「IC ファミリー」と呼ばれること がある。 1970年代半ばまでには、 TTL と CMOS という2つのファミリーが 主流となった。

TTL は Transister Transister Logic [トランジスタトランジスタロジック] の略称だ。 これらのチップは、速度を優先する人たちに好まれていた。 一方、CMOS (Complementary Metal Oxide Semiconductor [相補型金属酸化膜半導体]) チップ は電力消費が少なく、 電圧の変動に対する耐性が高いという特性を持つが、 TTL ほど速くはなかった。

もし1970年代半ばにデジタル設計エンジニアだったなら (ICから大きな回 路を設計する人たちのことを指す)、 あなたの机には必ずといっていいほど The TTL Data Book for Design Engineers [設計エンジニアのための TTL データブック] とい 厚さ 1/4インチ [約6.35ミリメートル] の本が置かれていたはずだ。 これはテキ サスインスツルメンツ社が1973年に初めて出版した、 同社などが販売してい る7400シリーズのTTL 集積回路に関する完全なリファレンスである。このシ リーズのICは、 すべてが74 という数字で始まる番号で識別されることからこ の名がついた。

7400シリーズの各集積回路は、特定の構成で事前に配線された論理ゲートで 構成される。 一部のチップには、大きなコンポーネントを作成するために使用で きる単純な事前配線済みゲートが提供されていて、 そのほかのチップでは一般的 なコンポーネントが提供される。

7400シリーズの最初のICは、もちろん 7400 だ。 このICは、「4つの2入 カポジティブ NAND ゲート (Quadruple 2-Input Positive-NAND Gates)」 とし てTTLデータブックで説明されている。 この集積回路が4つの2入力 NAND ゲートを内包していることを意味する。 これらは正論理 NAND ゲートと呼ばれ る。なぜなら、5ボルト (あるいはそれに近い) の入力が論理」に、 0ボルトの 入力が論理0に対応するからだ。これは14ピンのチップで、データブックの小 さな図では、ピンが入力と出力にどのように対応しているかが示されている。

257

Vcc 4B 4A 4Y 3B 3A 3Y 14 13 12 11 10 9 8 6 A 1B 1Y 2A 2B 2Y GND

この図はチップの上面図で (ピンは下側にある)、 前に示したチップの図のよ うに左側に小さな凹みがある。

ピン14はVccとラベル付けされており、これまで使ってきた電圧を示す V に相当する。 ピン7はGNDとラベル付けされており、 これはグランドを意味 する。 特定の回路で使用するすべての集積回路は、共通の5ボルトの電源と共 通のグランドに接続されなければならない。 7400チップ内の4つのNAND ゲー トそれぞれは、 2つの入力と1つの出力を持つ。 そして、それらは互いに独立し て動作する。

特定の集積回路について知っておくべき重要な事実の1つは伝播時間だ。 こ れは、入力の変化が出力に反映されるまでの時間を指す。

チップの伝播時間は一般にナノ秒で測定され、 これは nsec と略される。 ナ ノ秒は非常に短い時間だ。 1/1000秒は1ミリ秒、 1/100 万秒はマイクロ秒、 そして10億分の1秒がナノ秒となる。 7400 チップの NAND ゲートの伝播 時間は、 22ナノ秒以下であることが保証されている。 これは 0.000000022秒、 つまり22 × 10億分の1秒のことだ。

ナノ秒の感覚がつかめないのは、 あなただけではない。 たとえば、本書を から1フィート [約30センチメートル] 離したとき、 1ナノ秒は光がページから目 まで移動する時間と等しい。

しかし、このナノ秒級の動作があるからこそ、コンピュータが実現できるの だ。 コンピュータが行う各ステップは非常に単純な基本操作にすぎず、それでも

258

第15章 これは本当なのか?

259

コンピュータで何か実質的なことが達成される唯一の理由は、これらの操作が非 常に速く行われるからだ。 ロバート・ノイスの言葉を借りれば、 「ナノ秒に慣れ れば、コンピュータの操作は概念的にはかなり単純だ」といえるだろう。

それでは、 TTL データブックを引き続き見ていこう。 この書籍には見覚えの ある小さな項目がたくさん載っている。 7402 チップには4つの2入力 NOR ゲートが含まれ、 7404には6つのインバーターが、 7408には4つの2入力 AND ゲートが、 7432には4つの2入力OR ゲートがあり、 7430は8入力 NAND ゲートで構成さる。

VCC NC H G NC NC Y 14 13 12 11 10 9 8 3 4 5 6 A B C D E F GND

略語の NC は、 no connection (接続なし) を意味する。 TTL データブックをさらに読み進めると、 7483 チップが4ビットの2進全 加算器で、 74151は8入力1出力データセレクター [3ピットの指定により、8ビッ トの入力のどのビットを出力するかを決める]、 74154は4入力16出力デコーダー [4 ピットの入力により、 16ビットのどこに出力するかを決める] であることがわかる。

これで、 私が本書で示してきた様々なコンポーネントをどのようにして得たか がわかったはずだ。 要するに TTL データ

ブックから拝借したということだ。 この中で出会う面白いチップの1つが、 ルックアヘッド・キャリージェネレー タと呼ばれる 74182 だ。 加算などの算術演算を行う別のチップ74181 と一緒に 使うことが想定されている。 第14章で8ビット加算器を構築したときに見たよ うに、 2進数加算器の各ビットは前のビットからのキャリーに依存する。 これは リップルキャリー [リップルはさざ波を意味し、 キャリーがさざ波のように次々と上位ビッ

260 |

トへ送られる様子から] と呼ばれる。 足したい数字が大きければ大きいほど、 結果 が出るのが遅くなる。

ルックアヘッド・キャリージェネレータは、この状況を改善するために、 加算 器がキャリービットを計算するよりも短時間でキャリービットを計算する、専用 回路を提供する。 この特殊な回路はもちろん、より多くの論理ゲートを必要とす るが、全体の加算時間を速くする。 論理ゲートを減らすように設計し直すことで 回路を改善できる場合もあるが、 特定の問題に対処するために論理ゲートを追加 することで回路を高速化できる場合がとても多いのだ。

論理ゲートは比喩や想像の産物ではない。 それらはリアルな存在である。 論理 ゲートや加算器はかつてリレーから作られ、 その後リレーは真空管に置き換えら れ、 真空管はトランジスタに置き換えられ、 トランジスタは集積回路に置き換え られた。 しかし、 基礎となる概念は全く同じなのだ。

第16章

でも、減算はどうする?

リレーや真空管、 トランジスタを配線して2進数の加算ができることを納得 したところで、 「でも、 減算はどうする?」 と聞きたくなるだろう。 このような 質問をすることは決して迷惑ではない。むしろ非常に洞察力があるといえる。 加 算と減算はある意味で補完しあうが、 それぞれの操作の仕組みはかなり異なる。 加算は一貫して右端の桁から左端の桁へと進行する。 各桁からの繰り上げは次の 桁に加えられる。 一方、減算ではキャリー [繰り上げ] を行わない。 代わりにボ ロー [桁借り] を行う。 これは繰り上げとは本質的に異なる仕組みであり、 行った り来たりの面倒な操作だ。

たとえば、 桁借りが多い典型的な減算問題を見てみよう。

000253220

176

???

私と同じように、 一番右の桁を見て、 6が3より大きいことにすぐに気づくだ ろう。 そして、 「ヤバい」 と思う。 次の桁から借りる必要がある。 しかもその次 の桁も借りが必要だ。 細かい詳細は省くが、 正しく行うと、答えは77 になるは ずだ。

253

|- 176

77

しかし、どうやって一連の論理ゲートを組み合わせれば、 結果を得るために必 要なややこしい論理を実行できるのだろうか?

実際のところ、私たちはこの方向には進まない。 代わりに、 桁借りを行わずに 減算する小技を使う。 これは初めて見るとあまりにも技巧的に思えるかもしれな いが、コンピュータ内で負の数がどのように扱われるかを理解するための重要な 第一歩だ。

おそらく初等教育では、減算は負の数の加算と同じだと教えられたことだろ う。ある意味、これは無用の情報だ。 何しろ減算を少しも簡単にはしてくれない のだから。 それでも、 減算を、 負の数に正の数を足すものとして書き換えられる ことは示している。

-176+253=

ここで、もう2つ、 プラスとマイナスの数字を追加して、4つの数字を加算す ることにしよう。

1000-176+253-1000=

1000を足して1000を引いているのだから、 結果に違いはないはずだ。 1000 999に1を足したものだとわかっているので、1000から始めるのではなく、 999 から始めて、あとから1を足すことができる。 数字の列はさらに長くなる が、それでも等価のままだ。

999-176+253+1-1000=

確かに雑然としているが、左から右へとこの式を解いてみよう。 最初のステッ プは減算だ、 999 から 176 を引く。 驚くべきことに、 桁借りする必要がない! 999 から 176 を引いた結果、 823 になることは容易に計算できる。

823+253+1-1000=

9が連続した数からほかの数を引くと、 9の補数と呼ばれる数になる。 176 の 9の補数は 823 である。 そして逆も同様で、 823の9の補数は176になる。 こ れがよい点だ。 どんな数であっても、 9の補数を計算するために桁借りする必要 はない。

262

第16章 でも、減算はどうする? 1263

次の2つのステップはただの加算である。 まず823 に 253 を足し、結果とし て1076 を得る。

1076+1-1000=

そして、1を足して1000を引く。

1077-1000-77

これは前と同じ答えだが、 厄介な桁借りを1回もせずに達成できた。 ここで重要なのは、 9の補数を用いて減算を簡単にする場合、 取り扱う数字の

桁数を知っておく必要があることだ。 片方または両方の数が4桁の場合は、

9999 を使って9の補数を計算し、 最後に 10000 を引く必要がある。 しかし、 小さい数から大きい数を引く場合はどうなるだろう? たとえば、次の ような減算問題があるとする。

176 - 253 ???

普通なら、これを見て、「うーん、 大きな数を小さな数から引くことになって いるから、2つの数を入れ替えて減算を行い、結果が実際には負の数であること を覚えておく必要があるな」 と考えるだろう。 あなたは頭の中でこれらの数を入 れ替えて、答えを次のように書くかもしれない。

176 - 253 -77

この計算を桁借りなしで行うには、 先ほどの例とは少し異なるが、 まず2つ の数を入れ替えて、 最初に 999 を足し、 最後に999 を引く。

999-253+176-999=

先ほどと同じように、 999 から 253を引いて9の補数を求めるところから始 めよう。

264

746+176-999=

今度はこの9の補数と176を足す。

922-999=

この時点で、 先ほどの問題では1を足して1000 を引くことで最終結果が得ら れたが、その戦略はここではうまくいかない。 その代わり、 プラスの922 とマ イナスの999 が残された。 それがマイナスの922 とプラスの999 だったら、 922 の9の補数を求めればよい。 それが77 となる。 しかし、この9の補数の計 算を行うために符号を入れ替えたので、 本当の答えは77だ。 最初の例のよう に簡単にはいかないが、ここでも桁借りは必要なかった。

同じ手法は2進数にも適用でき、 実際には10進数よりもシンプルだ。 その様 子を見てみよう。

元の減算の問題を振り返ろう。

253 - 176 ???

数値を2進数に変換すると、この問題は次のようになる。

11111101 10110000 ????????

まず、これらの数を入れ替えて問題をプラスの数とマイナスの数の加算問題に する (2進数の下に10進数としての等価値を示す。

-10110000+11111101 = -176 + 253 =

では、最初に 11111111 (10進数で255に相当)を加え、 後半で00000001 (10進数でちょうど1) を加えて100000000(256に相当)を引いてみよう。

1111111110110000+11111101 +00000001 - 100000000 = 255 - 176 + 253 + 1 256 ==

第16章 でも、減算はどうする? |265

2進数でのその最初の減算は、 11111111 から減算されるため、 桁借りは不要 だ。

11111111-10110000+11111101+00000001-100000000=

01001111

+11111101+00000001-100000000=

10進数では、9の連続から数が引かれた結果は9の補数と呼ばれる。 2進数 では、1の連続から何かを引いた結果を1の補数と呼ぶ。 しかし、 1の補数を計 算するために、 減算をする必要はないことに注意しよう。 これら2つの数を見 てみよう。 10110000の1の補数は01001111 で、 01001111の1の補数は 10110000 だ。

10110000 01001111

つまりビットがただ反転するだけである。 ある数の1の補数では、 元の数で 0 のビットはすべて1のビットになり、 1のビットはすべて0のビットになる。 こ のため、1の補数は逆数とも呼ばれることがある (第8章で0を1に1を0に 変えるインバーターという論理ゲートを作ったことを思い出そう)。 問題は次のようになる。

01001111+ 79 + 11111101 + 00000001 - 100000000 = 253 + 1 256

では、最初の2つの数字を足そう。

01001111+11111101 +00000001-100000000=

101001100

+00000001-100000000=

結果は9ビットの数になるが、 それは構わない。 これで問題は次の略化される。

ように簡

101001100+00000001-100000000=

332 +

1 を加算するのは簡単だ。

256 =

266

101001101-100000000= 333 256 =

そして、あとは2進数の256を引くだけだが、これは単に左端のビットを取 り除けばよい。

01001101 77

最終結果は、 うれしいことに、10進数で問題を解いたときに得られた答えと 同じになった。

る。 2つの数字を逆にして、もう一度やってみよう。 10進数では、次の減算にな

176 - 253 ???

2進数では次のようになる。

10110000 11111101 ????????

10進数のときと同様に、その順番を入れ替えてみよう。 最初に1足し、 最後に 11111111 を引く。

11111111-11111101+10110000-11111111=

255- 253 +

255

まず、 11111101の1の補数を求める。

176

11111111-11111101 +10110000-11111111=

00000010

それを次の数字に足す。

+10110000-11111111=

を

第16章 でも、減算はどうする? 267

10110010-11111111= 178 - 255 =

次に、 ここまでの結果から 11111111 を何らかの方法で引く必要がある。 大 きな数から小さな数を引く場合、1を足して100000000を引くことでこの計算 が行える。 しかし、この方法では桁借りしないと減算ができない。 そこで、代わ りに、この結果を 11111111 から引くことにする。

11111111-10110010-01001101 255 - 178 = 77

繰り返すが、この戦略の本当の意味は、すべてのビットを反転させるだけで結 果を得たということだ。 答えは再び10進数で77となるが、この問題の本当の 答えは77である。

小さな数字から大きい数字を引くときに遭遇するこのちょっとした工夫は、 私 たちがまだ問題を完全に解けていないこと示唆している。 この問題はまだ完全に は解決していないのだ。

とはいえ、 第14章で開発した加算機を、 加算だけでなく減算もできるように 改造するために必要な知識は、これですべて出揃った。 複雑になりすぎないよう に、この新しい加減算機は、 結果が正の数のときだけ減算を行うようにする。

加算機の核心は、 論理ゲートから組み立てられた8ビットの加算器だった [本 書ではパネルにつながった機械としての計算機全体を 「加算機 (adding machine)」、論理ゲー トで構成された部品を 「加算器 (adder)」 とする]。

入力 入力B キャリーイン Az A As A A₁ A₂ A₁ Ao B B B B By B. By Bo CO 8ビット加算器 CI S₁ Se S₁ S. S: S ST Sp キャリーアウト サムアウト

次のことを覚えているだろう。 入力 A ~ A7, Bo ~ B, は、 加算される2つ の8ビット値を示すスイッチに接続されていた。 キャリーインはグランドに接 続され、0のビットと等価だった。 S ~ S7 の出力は8個の電球に接続され、 加 算の結果を表示するようになっていた。 加算すると9ビットの値になる可能性 があるため、 キャリーアウトは9個目の電球に接続されていた。 コントロールパネルは次のようだった。

P. B ↓ & Pa 8: 8: 8: 0 0 1 + P P P ↓ 0 P. 4: 4 pl 0

この図では、スイッチは183 (つまり100110111) 22 (つまり00010110) を加算するように設定されており、結果として電球の点灯で示されるように 11001101 つまり 205 が得られた。

2つの8ビット数を加算して減算するための新しいコントロールパネルは、わ ずかな修正でよい。 大きなプラス記号の代わりに、 加算 (Add) するのか減算 (Sub) するのかを示すスイッチが加えられているだけだ。

Sub 4 p 4 4 p 4: 4; 4; 0 1 1 1 1 Add 0 0 1 4 7 4; 4; 7: Overflow HA

268

第16章 でも、減算はどうする? 269

このスイッチは、 ラベルに表示されている通り、 加算のためにはオフにし、減 算のためにはオンにする。

もう1つの違いは、 結果を表示するために右側の8つの電球だけが使われる ことだ。9つ目の電球は今、 「Overflow [オーバーフロー、桁あふれ]」 とラベル付け されている。この用語は、コンピュータプログラミングでは、 様々な文脈で遭遇 し、ほとんどの場合で何らかの問題を示している。 このコントロールパネルは、 2つの8ビット数を加算するように設定されており、 多くの場合、 結果も8ビッ トになる。しかし、 結果が9ビットの長さになったとき、 それがオーバーフロー だ。 その結果は、 表示するための割り当てを超え、 あふれている。 また、 小さな 数から大きな数を引いたときにも、オーバーフローが発生する。 オーバーフロー ランプは、 結果が正しくないこと、 そして、 その結果の表示に十分に対応できて いないことを意味する。

加算機に対する加減算機の大きな変更は、8ビットの数値に対する 1 の補数を 計算する回路が追加されている点だ。 1の補数は各ビットを反転させることと等 価であることを思い出そう。 したがって、8ビット数値の1の補数を計算する回 路は、 とても単純な8つのインバーターとして見なせるだろう。

YYY 入力 出力 YYY

この回路の問題点は、入ったビットをいつでも反転させてしまうことだ。 加算 と減算の両方を行う機械を作ろうとしているので、回路は減算が行われる場合の みピットを反転させる必要がある。よりよい回路は次ページのようになる。

反転 入力 出力

反転 [Invert、 インパート] とラベル付けされた1つの信号が、8つのXOR ゲー トのそれぞれに入力されている。 XOR は次のような振る舞いであったことを思 い出そう。

XOR 0 1 0 0 1 1 1 0

反転信号が0の場合、 XOR ゲートの8つの出力は8つの入力と同じになる。 たとえば、 01100001 が入力された場合、 01100001 が出力される。 反転信号が 1の場合、8つの入力信号は反転される。 01100001 が入力されると、 10011110 が出力されるのだ。

この8つのXOR ゲートを、 「1の補数」 と書かれた箱にまとめてみよう。

入力 入力 入力5 入力 入力3 入力2 入力 入力0 反転 1の補数 出力7 出力6 出力5 出力4 出力3 出力2出力1出力0

この 「1の補数」 「8ビット加算器｣、 そして 「排他的 OR ゲート」 を次のよ うに配線できる。

270

第16章 でも、減算はどうする? 271

入力 入 反転 1の補数 A7 A6 As As A A2 A Ao B B6 B5 B4 B3 B2 By Bo CO 8ビット加算器 CI S7 S Ss S4 S₁ S₂ S₁ So オーバーフロー サムアウト 波算

右上の「減算」と書かれた線に注目しよう。 これは、パネル上の Add/Sub ス イッチにつながっている。 この信号は、 加算を行う場合は0、 減算を行う場合は になる。 加算の場合、 「1の補数」 回路への反転信号は0となり、 回路は何の 効果も持たない。 キャリーイン (CI) も0だ。 これは単純な加算回路と同じで ある。

しかし、減算の場合は、入力B (コントロールパネルの2列目のスイッチ)は、 加算器に入る前に、すべて1の補数回路で反転される。 また、減算の場合は、 加算器のキャリーインを1にすることで、加算結果に1を加算する。

また、加算器の減算信号とキャリーアウト (CO) は、オーバーフローランプ を点灯させるためのXOR ゲートに入る。 減算信号が0 (加算が行われているこ とを意味する) の場合、 加算器のキャリーアウトが1であれば電球は点灯する。 これは、 加算の結果が 255より大きいことを意味する。

減算が行われていて、 B の数値がAの数値より小さければ、加算器からのキャ リーアウトは通常1となる。 これは、 最後のステップで差し引かなければなら

ない 100000000 を表している。 減算の場合、 加算器からのキャリーアウトが0 の場合のみ、オーバーフローランプが点灯する。 これは、 小さい数から大きい数 を引こうとしていることを意味する。 上に示した機械は、負の数を表示するよう には設計されていない。

ここまで読み進んできたならきっと、 「でも、 減算はどうする?」 と聞いてよ かったと思っているに違いない。

本章では負の数について話してきたが、 まだ負の2進数がどのように表現さ れるかを示していない。 2進数でも10進数と同じように伝統的なマイナス記号 が使われると思うかもしれない。 たとえば、 77は2進数で1001101と表 記できる。 確かに可能だが、 2進数を使う目的の1つは、マイナス記号のような ちょっとした記号さえも0と1で表現することだ。

もちろん、マイナス記号のためにさらに別のビットを使うこともできる。その 追加のビットを負の数のために 1、 正の数のために0として、それ以外のものは すべて同じようにすることもできる。 これは機能するが、 十分とはいえない。 実 際には、コンピュータで負の数を表現するためのまた別の解決策が標準化されて いる。 そのように標準化された主な理由は、 負の数と正の数を足し合わせるため の手間のかからない方法を提供しているからだ。 一方、 そのやり方の最大の欠点 は、出会う可能性のあるすべての数値の桁数をあらかじめ決めておく必要がある ということだ。

少し考えてみよう。 私たちが通常の方法で正の数と負の数を書く利点は、それ らをずっと続けられることだ。 0を中心として一方向には無限の正の数が続き、 もう一方向には無限の負の数が続くと考えられる。

... -1,000,000-999,999...-3-2-10123 ... 999,999 1,000,000...

だがここで、 無限個の数は必要でないと仮定しよう。 私たちが出会うすべての 数字が、 特定の範囲内にあることが最初からわかっているとする。

当座預金口座を考えてみてみよう。 時折負の数を見る場所の1つだ。 当座預 金口座に 500ドル以上入っていることはなく、 銀行から500ドルのノーバウン スチェック限度 [小切手の引き落としが行われる際に残高が不足しても500ドルまでは銀行 が立て替えてくれること] を設定されていると仮定しよう。 これは、 当座預金口座 の残高が常に499ドルから500ドルのどこかの数値であることを意味する。

272

第16章 でも、減算はどうする? 273

また、500ドルを預け入れることはなく、 500ドルを超える小切手を書くことも なく、 ドルのみを取り引きし、 セントは扱わないとしよう。

この一連の条件は、 あなたが預金口座で取り扱う数値の範囲が500から 499 までであることを意味する。 つまり、 合計 1000個の数値を扱う。 この制約 からわかることは、必要なすべての数値を表現するには、 3桁の10進数があれ ば十分で、負の符号は不要ということだ。 その秘密は、 実際には 500から999 までの正の数は必要ないという点にある。 なぜなら、必要な最大の正の数は 499 であることがすでに確定しているからだ。 そこで、 500から999までの3桁の 数値を使って負の数を表現できる。 その仕組みはこうだ。

-500 を意味するためには、 500 を使用する。 499 を意味するためには、 501 を使用する。 498 を意味するためには、 502 を使用する。

(以下同様)

-2を意味するためには、 998 を使用する。 -1を意味するためには、 999 を使用する。 0 を意味するためには、 000 を使用する。 1 を意味するためには、 001 を使用する。 2 を意味するためには、 002 を使用する。

(以下同様)

497 を意味するためには、 497 を使用する。 498 を意味するためには、498 を使用する。 499 を意味するためには、 499 を使用する。

つまり、5、6、7、8、9で始まる3桁の数字はすべて、 実は負の数なのだ。 以下に示す 0 を中心にした負の数と正の数という2方向の広がりの列

-500-499-498...-4-3-2-101234 ... 497 498 499

の代わりに、次のように書くことができる。

500 501 502 ... 996 997 998 999 000 001 002 003 004... 497 498 499

これが一種の円を形成していることに注目しよう。 最小の負の数 (500) は、 最大の正の数 (499) から続いているように見える。 そして、 999 の数(実際に は-1)は0よりも1少ない。 999に1を加えると、 通常は1000になる。 しか し、ここでは3桁の数値しか取り扱わないので、 実際には000 となる。

このような表記を10の補数と呼ぶ。 3桁の負の数を10の補数に変換するに は、 999 から引いて1を足す。 つまり、 10の補数とは、 9の補数に1を足した ものだ。 たとえば、 255を10の補数で書くには、 999 から引いて744 を得 て 1を足して745 とする。

本章の前半で、 「減算は負の数の加算と同じである」と述べたが、 「そうだけ ど、やっぱり減算をする必要があるね」 と返したくなるかもしれない。 だが、 10の補数を使用すると、 減算は一切不要になる。 すべては加算だけで求められ るのだ。

いま、 当座預金の残高が143ドルあり、 そこから78 ドルの小切手を切る (残 高から引かれる) としよう。 通常、 新たな残高を計算するときは次のように行う。

143 - 78 65

これは2回の桁借りを伴う減算だ。 しかし、 10の補数では、 -78 は999078 + 1 すなわち 922 と書かれる。これにより、 この計算は加算となる。

143

+922

1065

オーバーフローを無視すると、 結果はやはり65ドルになる。 続いて、 150ド ルの小切手を書く場合を考えよう。 150を加えることになるが、 これは10の 補数で850 になる。

65 +850

915

結果は9で始まるので、これは負の数であり、 実際には-85 ドルに相当する。 こうした2進数の記数法は2の補数と呼ばれ、 コンピュータで正と負を表現

274

第16章 でも、減算はどうする? 275

する標準的な方法だ。

ここで仮に、 バイトを扱っているとしよう。 つまり、すべてが8ビットの数 で表現されているとする。 範囲は 00000000 から 11111111 までだ。 これまで は、これらの数を 10 進数の0から255に対応するものと考えてきた。 しかし、 負の数も表現したい場合、 以下に示す表のように、 1で始まるすべての8ビット の数は実際には負の数を表現することになる。

2進数

10000000

10000001

10進数

128

127

10000010

10000011

- 126

11111101

- 125

11111110

11111111

-3

00000000

00000001

-1

00000010

0

01111100

01111101

2

01111110

1

2

124

125

01111111

126

127

表現できる数の範囲は、128 から + 127 までに限定される。 最上位 (左端) のビットは、 符号ビットと呼ばれる。 符号ビットは、 負の数の場合は 1、 正の数 の場合は0となる。

2の補数を計算するには、まず1の補数を計算し、それに1を加える。 これ は、すべての数字を反転させて1を加えることと同じだ。 たとえば、10進数の 125は、01111101 だ。 125を2の補数で表現するには、 01111101 の数字を

反転して10000010を得て、 そこに1を加えて10000011 とする。 先に示した 表を使って結果を確認できる。 逆方向 (10000011125) の場合も全く同 じだ。 すべてのビットを反転させて1を足せばよい。

この記数法の大きな利点は、 正と負の数をマイナス記号を使わずに表現できる ことだ。 さらに、より大きな利点として、 加算のルールだけで、 正と負の数を足 せることがある。 たとえば、 127124の2進数を足してみよう。 前出の表 カンニングペーパー代わりにすると、 簡単に以下が得られる。

10000001 +01111100 11111101

この結果は、10進数で-3に相当する。

ここで気をつけなければならないのは、オーバーフローだ。それは、加算の結 果が127より大きいときに発生する。 たとえば、 125に自分自身を足すとしよ う。

01111101 +01111101 11111010

和の最上位ビットが1になっているため、 結果は負の数、 具体的には2進数 で-6に相当すると解釈する必要がある。 もちろん2つの正の数を足しても負 の数にはならないのは明らかだが、 まさにこのようなことが起こるのだ。それは 奇妙で、明らかに間違っている。

似たようなことは、125に自分自身に足したときにも起こる。

10000011 +10000011 100000110

これも問題を示している。 私たちは最初から8ビットの数に制限することを 決めていたので、結果の最左端の桁は無視されなければならない。 残る右側の8 ビットは正の数である6に等しくなる。

正と負の2の補数を加算する場合は一般に、 2つのオペランド [被演算子] の符

276

第16章 でも、減算はどうする?

277

号ビットが同じなのに結果の符号ビットが異なる場合は、その計算は無効であ る。 正の数と負の数を加算するときの結果は常に有効となる。 なぜなら、結果は 常に- 128 から 127の範囲にあるからだ。

以下に、8ビットの2の補数を2つ足すための改造版加算器を紹介する。

入 Az A6 AAA A2 A. Ao B B By B. B, B, B Bo CO 8ビット加算器 CI S S So S₁ S₁ S2 S₁ So サムアウト オーバーフロー

8ビット加算器は、もうおなじみだろう。 オーバーフローを検知するための ゲートがいくつか追加されている。 最上位ビットは数値の符号を表し、負の場合 は 1. 正の場合は0であることに留意しよう。 入力側では、 符号ビットはA7 と B7 になる。 サムの符号ビットはS7 だ。 このサムの符号ビットは、 AND ゲー トとNOR ゲートで使用される前に反転されることに注意してほしい

AND ゲートは、負の数に対するオーバーフロー条件を検出する。 入力Aと 入力Bの符号ビットがともに1(2つとも負であることを示す) で、サムの符号 ピットが0 (正の結果を示す) であれば、明らかに何かが間違っていることにな る。それは2つの負の数の和が、 割り当てた8ビットに収まりきらないほどの 大きさの負の数となったことを意味する。

NOR ゲートは、 正の数に対してオーバーフローを検出する。 A、Bの符号 ビットがともに0で、 サムの符号ビットが1なら、 2つの正の数の合計が、 負の 数として表現されるほどに大きなものになったことを意味する。 そのとき NOR ゲートの3つの入力はすべて0になり、その結果 NOR ゲートの出力は1になっ てオーバーフローを示すことになる。

本章の冒頭では、 2進数はかなり単純なものだった。 10進数と直接的に対応 していた。 8ビットの2進数は、0から255の範囲となり得る。 このような2 進数は、常に正であるため、 符号なし (unsigned [アンサインド]) と呼ばれる。

2の補数により、 符号付き (signed [サインド]) 2進数を扱うことができるよう になった。 これらは、正にも負にもなりうる。 8ビット値の場合、 その値は一 128 から 127 の範囲となる。 表せる数の個数 (256個) は同じでも、 範囲が違 うのだ。

ここで扱ってきたのは、 正式な数学用語では整数と呼ばれる。 正負のどちらに もなりうる数で、 小数部分を持たないものだ。 実用上、8ビット整数では不十分 な場合が多く、 プログラマは代わりに16ビット整数 (1つの数値に2バイトが 必要)、 32 ビット整数 (同4バイト)、 あるいは64ビット整数 (同8バイト) を使用する。

いずれの場合も、符号付き、 符号なしのいずれかになる。 これらの整数サイズ で可能な10進数値の範囲を次の表に示す。

整数のサイズ

8ビット

符号なし範囲 0~255

16ビット

0 65,535

32 ビット

符号付き範囲

-128 127

0 4,294,967,295

64 ビット

-32,768 32,767

0 18,446,744,

- 2,147,483,648 ~

073,709,551,615

2,147,483,647

-9,223,372,036,854,775,808~

9,223,372,036,854,775,807

範囲は2のべき乗を基準としている。 たとえば、 16ビットは2の16乗 つ まり 65,536 通りの数を表現できる。 これらの数字は、0から65,535 まで、 ま たは、 - 32,768 から 32,767 までの範囲と解釈できる。

278

第16章 でも、減算はどうする? 279

数字そのものを見ても、 符号付きか符号なしかはわからない。 たとえば誰か が、 「8ビットの2進数 10110110 を 10 進数に換算するとどうなる?」 と言っ たとしよう。 その場合はまず、「それは符号付きの数字? それとも符号なしの数 字?」と尋ねる必要がある。 「-74かもしれないし、 182 かもしれないけどね」。 ビットは0と1しかない。 自分自身については何も語ってくれないのだ。 そ の情報は、 使用されている文脈から得なければならない。



第 17 章 フィードバックと フリップフロップ

電気が物を動かす力を持つことは、誰もが知っている。 平均的な住宅をちらっ と見るだけで、 電気モーターが様々な用途で使われているのは明らかだ。 時計や 扇風機、フードプロセッサー、 あるいは何かしらのディスクを回転させる機器か もしれない。 さらに、 電気はスピーカーやヘッドホン、イヤホンの振動を制御 し、多くの機器から音楽や音声を再生する役割を果たしている。 そして、たとえ 家の外に停まっている車が電気自動車でなくても、 電気モーターは従来の内燃エ ンジンの始動を担っているのだ。

懐かしい電気ブザーやベルのような、 電気が物を動かす最も単純で洗練された やり方は、 電子化の進展によって急速に姿を消しつつある。

ここで、次のようにスイッチと電池が接続されたリレーを考えてみよう。

282

この図は少し奇妙に見えるかもしれない。 ここまでは、このような配線のリ レーを見てこなかったからだ。 通常、 リレーは入力と出力を分離するように配線 されている。 しかし、ここでは、すべてが1つの大きなループになっている。 スイッチを閉じれば、 回路が閉じてつながる。

回路が閉じると、 電磁石が接点を引き下げる。

電磁石が接点を引き下げると、 回路は閉じた状態ではなくなる。 そのため、電 磁石は磁力を失い、 接点は再び上に戻る。

第17章 フィードバックとフリップフロップ

しかし、これで回路が再び閉じてしまう。 スイッチが閉じている限り、 金属接 触部は行ったり来たりし、 回路を開いたり閉じたりする。 これにより、 反復的な (そして時には気に障る) 音が出ることになるだろう。 接触部がバタバタした音 を出したら、それはブザーだ。 これにハンマーを取り付け、 金属のゴングを用意 すれば、 電気ベルの出来上がりとなる。

このリレーをブザーにするための配線方法はいくつかある。 以下は、一般的な 電圧とグランドの記号を使った、別のやり方だ。

このように図示すると、 第8章で説明したインバーターを思い出すかもしれ ない。 回路はさらに単純化して次のように描ける。

出力

283

インバーターの出力は入力が0のとき1、 入力が1のとき0となることを思い 出そう。この回路のスイッチを閉じると、インバーター内のリレーやトランジス タが交互に開閉する。 また、スイッチを使わずにインバーターが絶えず動作する ように配線することもできる。

出力

この図は一見、 論理的な矛盾を描いているように見えるかもしれない。なぜな ら、インバーターの出力は入力と逆になるはずだが、ここでは出力が入力になっ ているからだ。 ただし、リレー、 真空管、 トランジスタからなるインバーター は、 ある状態から別の状態へと切り替わるのに少し時間がかかることを覚えてお こう。 入力が出力と同じであっても、 出力はすぐに反転し、入力の反対になる。 当然、 それでまた入力は変化し、 結果としてこの動作を繰り返し続けるのだ。

この回路の出力はどうなっているのだろう? 出力は素早く電圧の供給と非供給 状態、言い換えれば0と1の間で交互に変化する。

この回路はオシレーター [発振器] と呼ばれる。 オシレーターは、これまでに見 てきた回路とは本質的に異なる。 従来の回路は、スイッチを閉じたり開いたりす る人の介入によってのみ、 その状態を変化させてきた。 しかし、 オシレーターは 人を必要とせず、 基本的には自己駆動する。

もちろん、 単体のオシレーターはあまり役に立つようには思えないかもしれな い。 しかし、 本章の後半や次の数章では、 このような回路がほかの回路に接続さ れると、 自動化で重要な役割を果たすことを見ていく。 すべてのコンピュータに は、ほかの部品を同期して動かす何らかのオシレーターが内蔵されている(ただ し、実際のコンピュータ内にあるオシレーターは、 それなりにもっと洗練されて いて、一定かつ非常に速く振動するよう水晶の結晶が使われている)。

オシレーターの出力は0と1の間で交互に変化する。 それを表すために、 のような図が一般に使われる。

284

第17章 フィードバックとフリップフロップ

これは一種のグラフだ。 水平軸は時間を表し、垂直軸は出力が0 あるいは 1 を示す。

時間

この図は、時間の経過とともに、オシレーターの出力が0と1の間を定期的に 交互に変化することを意味している。このため、オシレーターはクロック [時計] と呼ばれることもある。 振動の回数を数えることで (ある意味で) 時間を知るこ とができるからだ。

オシレーターはどれくらいの速度で動くのだろう? 出力が0と1の間を1秒 間に何回交互に変わるのだろう?それは明らかに、 オシレーターの作り方に依存 する。 大きくて頑丈なリレーがゆっくりと行き来する様子や、 小さくて軽いリ レーが素早く振動する様子は、 容易に想像できるだろう。 トランジスタのオシ レーターは1秒あたり数百万回から数十億回ほど振動する。

オシレーターの1サイクルは、オシレーターの出力が変化し、それが開始し た地点に戻る間隔と定義される。

0. 1サイクル

時間

サイクルに必要な時間をオシレーターの周期という。たとえば、周期が0.02 のオシレーターを観察しているとしよう。 横軸は秒でラベル付けされ、0と表 示されている任意の時間から始まる。

1サイクル 0. 時間 0 0.01 0.02 0.03 0.04 0.05 0.06

285

オシレーターの周波数は1を周期で割ったものだ。 この例では、オシレーター の周期が 0.02 秒なら、その周波数は10.02、 つまり1秒あたり50サイク ル/秒となる。 つまり、オシレーターの出力は1秒間に50回変化して元に戻る。

サイクル/秒はマイル / 時間やポンド/平方インチ、カロリー / 食などと同

様、自己説明的な用語である。 しかし、サイクル/秒は現在、 あまり使われてい ない。その代わり、初めてラジオ波を送受信したハインリッヒ・ルドルフ・ヘル ツ (1857-1894) を記念して、 ヘルツという単語が使われている。 この用語の使 用は1920年代のドイツから始まり、その後数十年かけてほかの国にも広まった。 こうして、 私たちのオシレーターの周波数は、50ヘルツ、 または (略して) 50Hz ということができるようになった。

もちろん、ここでは特定のオシレーターの速度を推測しただけだ。 本章の最後 までには、 オシレーターの速度を実際に測定する何かを作り上げることができる だろう。

この挑戦を始めるために、 特定の方法で配線されたNOR ゲートのペアを見て みよう。 NOR ゲートは、両方の入力に電圧がかかっていない場合にのみ電圧が 出力されることを思い出そう。

NOR 0 1 0 1 0 1 0 0

NOR ゲート 2個、 スイッチ2個、 電球1個の回路を以下に示す。

曲

V <W>

286

第17章 フィードバックとフリップフロップ

回路の配線に注目してみよう。 左側のNOR ゲートの出力は右側のNOR ゲー トの入力に接続されており、 その NOR ゲートの出力は最初のNOR ゲートの入 力に接続されている。 これは一種のフィードバックだ。 実際、 オシレーターと同 様、 出力が戻って入力になっている。 この特徴は、本章で説明する大部分の回路 に見られるものだ。

この回路を使用する際の単純なルールがある。 上のスイッチか下のスイッチの どちらか一方を閉じることはできるが、 同時に両方のスイッチを閉じることはで きない。 これから述べる説明は、 そのルールに基づいている。

まず、この回路で流れている電流は、 左側のNOR ゲートの出力からのものだ けである。 なぜなら、 そのゲートの両方の入力が0だからだ。 ここで上のスイッ チを閉じると、 左側のNOR ゲートからの出力は0になり、それによって右側の NOR ゲートからの出力は1になり、 電球が点灯する。

ww

امرها

魔法が起きるのは、 次に上のスイッチを開けたときだ。 NOR ゲートはどちら かの入力がであれば出力は0になるので、 左のNOR ゲートの出力は変わら ず、 電球は点灯したままとなる。

www

287

288 |

なんと奇妙なことだろう。 両方のスイッチが開いている。 これは最初の状態と 全く同じだが、今度は電球が点灯している。これまでに見てきたものとは全く違 う現象だ。 通常、 回路の出力は入力にのみ依存する。 だが、 この場合はそうでは ないようだ。 さらに、 今の状態では、上のスイッチを閉じたり開いたりしても電 球は点灯したままとなる。 上のスイッチはもう、 回路に影響を与えない。 なぜな ら、 左側のNOR ゲートの出力は0のままだからだ。

ここで下のスイッチを閉じると、 右側のNOR ゲートの入力の1つが1とな るため、出力は0になり、 電球は消える。 左側の NOR ゲートの出力は1とな る。

V لم من V <W>

ここで、下のスイッチを開けても電球は消えたままだ。

<W>

ام حب

これで最初の状態に戻ったことになる。このとき、下部のスイッチを閉じたり 開いたりしても、 電球に影響を与えない。 まとめると次のようになる。

●上のスイッチを閉じると電球は点灯し、 その後に上のスイッチを開けても電 球は点灯したままである。

●下のスイッチを閉じると電球は消灯し、その後に下のスイッチを開けても電

V

第17章 フィードバックとフリップフロップ |

球は消灯したままである。

この回路の不思議な特性は、 両スイッチが開いている場合に、電球が点いてい ることもあれば、 消えていることもあるということだ。 つまり、この回路は両方 のスイッチが開いているときに2つの安定状態を持つ。 このような回路はフリッ プフロップと呼ばれる (ビーチサンダルや政治家の策略を表すために使われる言 葉でもある)。 フリップフロップは1918年、 英国の無線物理学者ウィリアム・ ヘンリー・エクルズ ( 1875-1966) と F.W. ジョーダン (1881-1941) の業績に 由来する。 フリップフロップ回路は情報を保持する。 つまり 「記憶」 する。 記憶 するのは直近に閉じられたスイッチだけだが、 それは重要な情報だ。もし旅行中 にこのようなフリップフロップに遭遇し、 電灯が点いているのを見つけたら、最 後に閉じられたのは上のスイッチであったと推測できる。 もし電灯が消えている のなら、 最後に閉じられたのは下のスイッチだったのだ。

フリップフロップは、シーソーによく似ている。 シーソーは2つの安定した 状態を持ち、 揺らぎやすい中間位置に長くとどまることはない。 シーソーを眺め れば、どちらの側が最近押し下げられたかを常に判断できる。

まだ実感が湧かないかもしれないが、 フリップフロップは極めて重要な道具 だ。回路に記憶を与え、 過去の出来事を提供する。 何も覚えられない状態で数え ることを想像してほしい。 何番まで数えたか、 次にどの番号がくるのかが全くわ からなくなるだろう! 同じように、 (本章の後半で説明する) カウンター回路も フリップフロップを必要とする。

フリップフロップには、いくつかの種類が存在する。 先に示したものは最も単 純なもので、R-S (リセット - セット) フリップフロップと呼ばれる。 2つの NOR ゲートは、 対称的な外観であるため、一般的には以下の図のように描かれ、 ラベル付けされる。

R

289

290

電球に使用した出力は、伝統的に Q と呼ばれる。 さらに、 Qの反対の値を持 つ第二の出力が存在し、それはQ(Qバーと発音する)と呼ばれる。 もしQが0 なら、Qは1であり、 その逆も同様だ。 2つの入力は、 セットを表すSとリセッ トを表す R と呼ばれる。これらの動詞は「Qを1にセットする｣｢Qを0にリ セットする」という意味だと理解できる。 Sが1 (先の図で上のスイッチを閉じ ることに相当する) の場合、 Qは1となり、夏は0となる。 Rが1 (先の図で下 のスイッチを閉じることに相当する) の場合、 Qは0となり、夏は1となる。 両方の入力が0の場合、出力はQが最後にセットされたかリセットされたかを 示す。 これらの結果を表にまとめてみよう。

入力 出力 S R Q Q 1 0 1 0 0 1 0 1 0 0 Q Q 1 1 不許可

この表は関数表、あるいは論理表や真理値表と呼ばれ、 特定の入力の組み合わ せから生じる出力を示す。 R-S フリップフロップには入力が2つしかないため、 入力の組み合わせは4つとなる。 表の見出し部分の下の4行だ。

SとRがともに0のときの、下から2番目の行に注目しよう。 このときの出 力はQとだ。 つまり、 Q と夏の出力は、 SとRの入力がともに0になる前 の状態のままに保たれるということだ。 表の最後の行は、 SとRの入力をとも に1にすることが許されない、あるいは規則違反であることを示している。 別 にそれを行うと罰を受けるわけではないが、 この回路では、両方の入力がの 場合、両方の出力は0となってしまう。 これは夏がQの反対であるという定義 に反する。そのため、 R-S フリップフロップを使用した回路を設計しているな ら、SとRの入力がともに1となる状況は避ける必要がある。

R-S フリップフロップは、2つの入力と2つの出力を次のようにラベル付けし

第17章 フィードバックとフリップフロップ

た小さな箱として描かれることが多い。

R Q

R-S フリップフロップは、 2つの入力のどちらに最後に電圧がかかっていたか を「覚えている」ような回路の最初の例として、確かに興味深い。 しかし、実際 には、特定の信号が特定の時点で0か1だったのかを覚えている回路の方がずっ と役に立つ。

実際に作ってみる前に、 そのような回路はどのような挙動を示すべきかを考え てみよう。それは2つの入力を持つはずだ。 1つをデータと呼ぼう。 ほかのデジ タル信号と同じように、データの入力は0または1になる。 もう1つの入力を ビット保持 (Hold That Bit) と呼ぶことにする。 これは、人が「それを覚えて いて (Hold that thought)」 という場合に相当するデジタル表現だ。 通常、 ビッ ト保持信号は0であり、このときデータ信号は回路に影響を与えない。 ビット 保持が1のとき、データ信号の値が回路に反映される。 その後、 ビット保持信 号は0に戻り、このとき回路はデータ信号の最後の値を記憶する。 この場合デー タ信号を変更しても、それ以上の変化はない。 つまり、 次の関数表を持つ回路が必要だ。

入力 出力 データ ビット保持 Q 0 1 0 1 1 1 0 0 Q I 0 Q

最初の2つのケースでは、ビット保持信号が1のとき、 Qの出力はデータの

291

入力と一致している。 一方、 次の2つのケースでは、ビット保持信号が0のと き、Qの出力はデータの入力にかかわらず、その前の状態と同じだ。この関数 表は、次のように少し単純化できる。

入力 出力 データ ビット保持 Q 0 1 0 1 1 1 X 0 ○

ここで、Xは「どちらでもよい」を意味している。 それは、 ビット保持入力 が0なら、 データ入力が何であろうと、 Q の出力はそれまでと同じだからだ。 既存の R-S フリップフロップに基づいてビット保持信号を実装するには、次 この図のように入力端に2つのAND ゲートを追加する必要がある。

リセット ビット保持 セット Q

この図にはデータ入力が含まれていないことはわかっているが、これは間もな く修正される。

AND ゲートの出力が1になるのは、両方の入力が1のときだけであることを 思い出そう。 つまり、ビット保持がでない限り、 リセットとセットの入力は 回路のほかの部分に影響を与えないのだ。

回路は、Qの値と、その反対の の値でスタートする。 この図では、Qの出

292

第17章 フィードバックとフリップフロップ

力は0の出力は1である。 ビット保持信号が0である限り、 セット信号は 出力に何の影響も与えない。

リセット ビット保持 セット Q Q

同様に、リセット信号も効果がない。

リセット ビット保持 セット Q

ビット保持信号が1のときだけ、 この回路は先に示した通常のR-S フリップ フロップと同じように機能する。

リセット ビット保持 セット -Q

R-S フリップフロップのように動作するのは、上のAND ゲートの出力はリ

293

セット信号と同じで、下のAND ゲートの出力もセット信号と同じになるからだ。 しかし、私たちの目標はまだ達成できていない。 必要とするのは2つの入力 だけで、3つではない。 これはどうやって達成するのだろう?

R-S フリップフロップの関数表を思い出してみよう。 セットとリセットが両 方とも1であった場合は禁止されていたので、 その状態は避けたい。 また、 セッ トとリセットの信号がともに0であることはあまり意味がない。 それは単に出 力が変化しないケースだからだ。 ビット保持を0に設定することで、同様の結 果が得られる。 これは、セットとリセットが互いに反対であることにしか意味が ないことを意味する。 セットが1のときにリセットは0となり、 セットが0の ときにリセットは1となる。

この回路に2つの変更を加えよう。 セットとリセットの入力は、単一のデー タ入力に置き換えられる。これは以前のセット入力と等しい。 そのデータ信号を 反転させてリセット信号の代わりにできる。

2つ目の変更は、 ビット保持信号にもっと伝統的なクロックという名前をつけ ることだ。 これは本当のクロックではないため、少し奇妙に思えるかもしれな い。 しかし、それが時々時計のような特性を持つ可能性があるということが、す ぐにわかるだろう。 つまり、定期的に0と1の間を行ったり来たりする可能性 があるということだ。 だが今のところ、クロック入力はデータ入力が保存される べきタイミングを示しているにすぎない。

修正後の回路は以下のようになる。 データ入力が下のAND ゲートのセット入 力に取って代わり、 同時にインバーターがその信号を反転させて上のAND ゲー トのリセット入力を置き換える。

クロック Q Q データ

294

第17章 フィードバックとフリップフロップ

ここでも、両方の入力を0に設定した状態でスタートする。 Qは0、つまり Qが1ということだ。 クロック入力が0である限り、 データ入力は回路に影響 を及ぼさない。

クロック データ Q Q

しかし、クロックが1になると、 データ入力の値が回路に反映される。

-Q クロック データ -o

Qがデータ入力と同じになり、 Qが逆になる。 そしてクロックは再び0に戻 る。

クロック データー Q

295

この回路は、クロックが最後に1だったときのデータの値を記憶するように なった。 そして、データがどう変わろうと影響されない。 たとえば、 データ信号 が0に戻っても、 出力には影響しない。

クロック データ Q Q

この回路はレベルトリガー型Dタイプフリップフロップと呼ばれる。 Dはデー タ (Data) の略だ。 レベルトリガー型とは、 クロック入力が特定のレベル(こ の場合は1)になったときに、 フリップフロップがデータ入力の値を保存するこ とを意味する (レベルトリガー以外のフリップフロップについては、後ほど説明 する)。

次の関数表では、データをD、 クロックを Clk と略記する。

入力 出力 D Clk Q Q 0 0 1 1 1 1 0 X 0 Q

この回路はレベルトリガー型Dタイプラッチとも呼ばれる。 簡単にいえば、 1ビットのデータをラッチ [施錠] しておいて、 それを次に使うまで保持し続け る回路という意味だ。 この回路は、1ビットメモリーと呼ぶこともできる。 第 19章では、これらのフリップフロップを多数接続して、 大量のビットとバイト

296

第17章 フィードバックとフリップフロップ

で構成されるメモリーを作る方法を示す。

とりあえずここでは、1バイト分だけデータを保存してみよう。 8つのレベル トリガー型D タイプフリップフロップを1つにまとめ、すべてのクロック入力 を単一の信号に集約する。 次のようになる。

Ꭰ Ds Ds Da D Ꭰ D₁ D 8ビットラッチ Clk O Q6 Os Q4 Q3 Q2 Q1 Qo A

このラッチは、 一度に1バイト全体を保存できる。 上部に配置された8つの 入力は Do ~D, とラベル付けされていて、 下部の8つの出力は Q Q7 とラベ ル付けされている。 右側にあるのがクロック入力 (Clk) だ。 クロック信号は通 常は0である。 クロック信号が1になると、入力Dの8ビット値全体がQの出 力に転送される。 クロック信号が再び0に戻ると、 その8ビット値は次にクロッ ク信号が1になるまで保持される。 各ラッチからの の出力は無視される。 8ビットラッチは、8つのデータ入力と8つのQの出力を次の図のように

1つのデータパスにまとめて描くことも可能だ。

Dy... Do 8ビットラッチ Clk Q7...Qo

また、単に入力をD、 出力をQと表記することで、さらに簡略化できる。

297

298

8ビットラッチ Clk

第14章の終わりの方では、8つの1ビット加算器を集約し、 配線を接続して バイト全体を加算するようにした。

A7... Ao B7... Bo CO 8ビット加算器 CI S So

第14章では、8つあるAの入力とBの入力をスイッチに接続し、 CI (キャ リーイン) の入力をグランドに接続した。 そして8つあるS (サム) の出力と CO (キャリーアウト) の出力を電球に配線した。

ラッチと加算器は、 より複雑な回路を組む際の基本単位として活用できる。 た とえば、8ビット加算器の出力を8ビットラッチに保存できる。また、8つのス イッチの並びの1つを8ビットラッチに置き換えることで、 ラッチの出力を加 算器への入力にすることも可能だ。 この2つの概念を組み合わせて、複数の数 値を連続的に合計する 「累積加算器」 とでも呼ぶべきものを紹介しよう。

第17章 フィードバックとフリップフロップ

8つのスイッチ 8ビット加算器 CI D 8ビットラッチ Clk Q 8つの電球 加算

ラッチのクロック入力を制御するスイッチが 「加算」 とラベル付けされている 点に注目してほしい。

この構成では、スイッチの数を半分に減らせるだけでなく、 中間結果を再度入 力することなく、 2つ以上の数を加えることが可能だ。 ラッチの出力はすべてゼ ロから始まり、これが加算器への入力Aとなる。 最初の数値を入力し、加算ス イッチを切り替える。 つまり、 スイッチを閉じてから開く。 そのときの値はラッ チに保持され、 電球に表示される。 次に、 2つ目の数値を入力し、 再度加算ス イッチを切り替える (閉めて開く)。 新しくスイッチで設定した数値が前回の合 計に加算され、それが電球に表示される。 さらに数値を入力し、 加算スイッチを 切り替えていけばよい。

ただし、これは残念ながら期待通りには動作しない。 遅いリレーで加算器を作 り、加算スイッチを素早く切り替えて加算器の結果をラッチに保存することが可 能なら、うまくいくかもしれない。 しかし、 加算スイッチが閉じられていると ラッチのデータ入力に起きるすべての変化が直接出力Qに伝わり、 それが 再び加算器に戻ってしまう。 その値はスイッチの値に加えられ、その和が再び

299

ラッチに戻り、再び循環してしまう。

この循環は 「無限ループ」 と呼ばれる現象だ。 これは、私たちが設計したD タイプフリップフロップがレベルトリガー型だからだ。 クロック入力のレベルを 0から1に変化させることで、 データ入力の値がラッチに保存される。 しかし、 クロック入力が1である間にデータ入力が変更されると、 それらの変更は出力 に反映されてしまうのだ。

アプリケーションによっては、レベルトリガー型クロック入力でも十分だ。 し かし、 累積加算器には使えない。 累積加算器では、 クロック入力が1の間にデー タが通過し続けるラッチは望ましくない。 クロックが0から1に (あるいは逆 に1から0に) 変わる瞬間にデータを保存するラッチが望ましい。 この遷移の 瞬間は視覚的に 「端」 のように見えるため、 「エッジ」 と呼ばれる。

Clk

10

0から1への遷移は正の遷移またはポジティブエッジ、1から0への遷移は負の 遷移またはネガティブエッジと呼ばれることがある。

先ほどのレベルトリガー型フリップフロップは、クロック入力が1のときに データをラッチしていた。一方、ポジティブエッジトリガー型フリップフロップ は、クロックが0から1に遷移した瞬間にのみデータをラッチする。 レベルト リガー型フリップフロップと同様に、クロック入力が0の場合、 データ入力を 変更しても出力には影響しない。 ポジティブエッジトリガー型のフリップフロッ プが違う点は、クロック入力が1のときも、データ入力の変化が出力に影響を 与えないことだ。データ入力は、クロックが0から1に変化する瞬間にのみ出 力に影響を与えるのである。

今までに出てこなかった概念なので、 実現が難しく感じるかもしれない。 そこ で、一工夫が必要だ。 エッジトリガー型Dタイプフリップフロップは、2段重 ねのレベルトリガー型Dタイプフリップフロップから構成され、 次のように接 続される。

300

第17章 フィードバックとフリップフロップ

クロック データ -ē

ここでの考え方は、クロック入力が第一段階と第二段階の両方を制御するとい うことだ。しかし、 第一段階ではクロックは反転されていることに注意してほし い。 第一段階はDタイプフリップフロップと全く同じように動作するものの、 クロックが0のときにデータ入力が保存されることを意味する。 第一段階の出 力は第二段階の入力となり、これらはクロックが1のときに保存される。 全体 としての結果は、クロックが0から1に変わるときだけデータ入力が保存され

もっと詳しく見てみよう。 次の図は、 データ入力とクロック入力の両方が0 で、Qも0である状態のフリップフロップを示している。

る。

クロック データ・ Q

ここで、 データ入力を1に変更する。

301

クロック

データ Q

この操作は、 反転されたクロック入力が1であるため、 第一段階のフリップ フロップを変化させる。 だが、 反転していないクロック入力は0であるため、 第二段階は変わらないままだ。 さて、ここでクロック入力を1に変えてみよう。

クロック データ Q Q

これにより、 第二段階は変化し、 Qが1になる。 ここで注目すべき違いは、 データ入力が(たとえば0に戻るなど) 変化しても出力 Qには影響がないこと だ。

クロック・

データ

302

第17章 フィードバックとフリップフロップ 303

QとQの出力は、クロック入力が0から1に変化した瞬間にのみ変化する。 エッジトリガー型Dタイプフリップフロップの関数表には、新たに上を向い た矢印 (↑)の記号が必要になる。 これは、0から1への信号の遷移を示す記号 だ。

入力 出力 D Clk Q 0 0 1 1 ↑ 1 0 X 0 Q

上向きの矢印は、 クロックが正の遷移 (0から1への遷移) をしたときに、出 カQがデータ入力と一致することを示す。 このフリップフロップは次のような 図になる。

D Clk

Clk 入力の小さな山括弧 (>) は、 このフリップフロップがエッジトリガー であることを示す。 同様に、 新規に組み立てられた8つのエッジトリガー型フ リップフロップは、 クロック入力に小さな山括弧を添えて示す。

8ビットラッチ Clk < °

304

このエッジトリガー型ラッチは、 累積加算器にとって理想的だ。

8つのスイッチ CI 8ビット加算器 Sum D B 8ビットラッチ Clk 加算 °

8つの電球

この累積加算器は、 キャリーアウト信号をうまく処理できていない。 2つの数 値の合計が255 を超える場合、 キャリーアウトは無視されるだけで、 電球は本 来の数値よりも少ない合計を表示する。 1つの解決策として、 加算器とラッチを すべて16ビット幅にする、 あるいは少なくとも最大の合計値より広い幅にする ということが考えられる。 だが、その問題解決はとりあえず先延ばしにしよう。

また、加算器をリセットし、 新しい集計を開始する方法が存在しないという 題もある。 しかし、間接的な方法でそれを達成することが可能だ。 前章で学んだ 1の補数と2の補数を利用できる。 たとえば、 集計値が 10110001 である場合、 スイッチに1の補数 (01001110) を入力して加算する。 その結果として得られ る合計は11111111 となる。 今度はスイッチに 00000001 と入力し、再度加算 する。 これですべての電球が消え、 加算器がクリアされる。

ここで、エッジトリガー型Dタイプフリップフロップを使った、異なる回路 を考えてみよう。 本章の冒頭で構築したオシレーターを思い出そう。 オシレー ターは、0と1を交互に出力する。

第17章 フィードバックとフリップフロップ 305

出力

オシレーターの出力をエッジトリガー型Dタイプフリップフロップのクロッ ク入力に接続しよう。 そして、 Q 出力をD入力に接続する。

Clk

フリップフロップの出力自身が、 フリップフロップの入力となる。 フィード バックにフィードバックを重ねているのだ! (実際には、 これは問題を引き起こ す可能性がある。 オシレーターはリレーやそのほかのスイッチング部品から成り 立っており、これらが可能な限り高速に反転を繰り返している。 オシレーターの 出力はフリップフロップを構成する部品に接続されている。 こうしたほかの部品 がオシレーターの速度に追従できないかもしれない。 この問題を避けるために、 オシレーターは回路の中で使われるフリップフロップよりもはるかに遅いと仮定 しよう)。

この回路で何が起こるかを理解するために、 様々な変化を示す関数表を見てみ よう。 少し難しい部分もあるので、一歩ずつ進めていこう。 まず、クロック入力 が0でQ が0の状態から始める。 これはQ (Dに接続されている) が1である ことを意味する。

入力 出力 D Clk Q 1 0 0 1

クロック入力が0から1に変わると、 Qは入力Dと同じ値になる。

入力 D Clk Q 出力 Q 1 0 0 1 1 ↑ 1 0

今のクロック入力は1だ。 しかし、Qが0に変わるので、入力Dも0 に変わ る。

入力 出力 D Clk 1 0 00 Q Q 1 1 ↑ 0 0 1 1 0

クロック入力は出力には影響を与えず、 0に戻る。

入力 出力 D Clk Q Q 1 0 0 1 1 ↑ 1 0 0 1 1 0 0 0 1 0

クロック入力が再び1に変わる。 入力Dが0であるため、 Qは0になり、Q はになる。

306

第17章 フィードバックとフリップフロップ

入力 出力 D Clk Q Q 1 0 0 1 1 ↑ 1 0 0 1 1 0 0 0 1 0 0 ↑ 0 1

よって、入力Dも1になる。

入力 出力 D Clk Q 10 1 0 0 1 1 ↑ 1 0 0 1 1 0 0 0 1 0 0 ↑ 0 1 1 1 0 1

ここで起こっていることはとても単純にまとめることができる。 クロック入力 が0からに変わるたびに、 Qが0から1へ、あるいは1から0へ変化する。 この状況は、タイミングチャートを見ることでより明確になる。

307

Clk D/Q Q

クロック入力が0から1になると、Dの値 ( と同じ) がQ に転送される。 これにより次のクロック入力が0から1へ遷移する際にQとDも変化する。

本章の前半で、 信号が0と1の間で振動する速さを周波数 (1秒あたりのサイ クル数)と呼び、 ヘルツ (Hz) で測定されることを説明した。 オシレーターの 周波数が20Hz (1秒間に20サイクルするという意味) だとすると、Qの周波数 はその半分の10Hz となる。 そのため、 Q の出力をフリップフロップのデータ入 力に戻す回路は、分周器 (周波数を整数分の1に落す装置) とも呼ばれる。

もちろん、分周器からの出力を別の分周器のクロック入力として、 もう一度分 周することも可能だ。 ここでは、このカスケード接続されたフリップフロップを 3つだけ並べているが、 列をさらに増やすこともできる。

Clk Q2 Clk > Clk Q Clk D

図の上部にラベルを付けた4つの信号を見てみよう。

308

第17章 フィードバックとフリップフロップ

Clk Q1 Q2 Q3

この図を都合のよいところで開始および終了させていることは認めるが、 不正 直な点はない。この回路はこのパターンを何度も繰り返すだろう。 だが、何か見 覚えのあるものはないだろうか?

ヒントを出そう。これらの信号に0と1のラベルを付けてみよう。

Clk 0

0 1 0 1 0 1 0 1 0 1

Qi

0 1

0

1

0

0

1

0

0

1

0

1

1

1

0

1

Q2 0 0

1

1

1

1

0

1

0

0

0

0

0

0

1

Q 0 0 0 0

1

1

1 1

0

0 0 0 0 1

1

1

1 1 1

1

もうおわかりだろう。 図を時計回りに90度回転させて、4ビットの数字を横 向きに読んでほしい。 それらは、0から15までの10進数に対応しているのだ。

309

2進数

0000

10進数

0001

0

1

0010

2

0011

3

0100

0101

0110

0111

1000

1001

4

1010

1011

1100

1101

1110

1111

5678910112131415

したがって、 この回路がしていることは、 2進数で数えることにほかならない。 そして、フリップフロップを増やせば増やすほど、より大きな数を数えることが できる。 第10章で指摘したように、 増加する2進数の列では、各桁は右の桁の 周波数の半分で0と1を交互に繰り返す。 このカウンターはそれを模倣してい るのだ。 クロック信号が正の遷移を行ったときに、カウンターの出力はインクリ メント [増加] する。 つまり1つ増えるのだ。

フリップフロップを8つ連ねて箱に入れてみよう。

8ビットリップルカウンター Clk Q7 06 Qs Q4 Q3 Q2 QF Qo

これはリップル [さざ波] カウンターと呼ばれ、 各フリップフロップの出力が

310

第17章 フィードバックとフリップフロップ

次のフリップフロップのクロック入力になる。 変化がさざ波のように順次各段を 伝わり、 末端のフリップフロップが変化するまでに若干時間がかかることもあ る。 より洗練されたカウンターは同期型で、 すべての出力が同時に変化する。

出力を Q Q7 とラベル付けした。 これらは、 連鎖する最初のフリップフロッ プからの出力 (Q) が最も右側になるように配置されている。 したがって、こ れらの出力に電球を接続すれば、8ビットの数値を読むことができる。

本章の冒頭で、 オシレーターの周波数を決定する何らかの方法を紹介すると述 べた。 それがこれだ。 オシレーターを8ビットカウンターのクロック入力に接 続すれば、カウンターがオシレーターが何周期進んだかを示してくれる。合計が 11111111 (10進数で255) に達すると、 00000000 に戻る (これはロールオー バーやラップアラウンドとも呼ばれる)。 おそらく、 オシレーターの周波数を決 定する最も簡単な方法は、 この8ビットカウンターの出力に8つの電球を接続 することだ。 すべての出力が0 (つまり、 電球が1つも点いていない状態) にな るまで待って、 ストップウォッチをスタートしよう。 すべての電球が再び消えた ときにストップウォッチを止める。 これが、オシレーターが256サイクルする のに必要な時間だ。 たとえば10秒としよう。 したがって、 オシレーターの周波 数は 256 10、 つまり 25.6Hz となる。

現実世界では、振動する水晶から作られるオシレーターはこれよりもずっと速 く、低速でも 32,000Hz (または32キロヘルツ [kHz]) から始まり、 1秒あたり 100万Hz (メガヘルツ [MHz]) 以上、さらには1秒あたり10億Hz (ギガヘル ツ [GHz]) に達する。

オシレーターの一般的な種類の1つは、周波数が32,768Hzだ。 これは決し て勝手な数字ではない! これが連なる分周器に渡されると、 16,384Hz、 8192Hz、 4096Hz、 2048Hz、 1024Hz 512Hz、 256Hz、 128Hz、64Hz、 32Hz、 16Hz、8Hz、 4Hz、 2Hz、 そして最後は1Hz(1秒に1回の周期)とな りデジタル時計で秒をカウントできるようになる。

リップルカウンターには実用上の問題が1つある。 それは必ずしもゼロから スタートしないことだ。 電源が入ったとき、 個々のフリップフロップのQは1 か0かのどちらかになる。 フリップフロップの一般的な機能強化が、 クロック やデータの入力に関係なくQを0にするクリア信号だ。

より単純なレベルトリガー型Dタイプフリップフロップの場合、 クリア入力 を追加するのはとても簡単で、 OR ゲートを追加するだけでよい。 クリア入力は

311

312

通常は0だが 1になると、 次のようにQは0となる。

クリア クロック データ Q

このクリア信号は、ほかの入力信号に関係なくQを0にする、 エッジトリガー型フリップフロップの場合、 クリア信号はより複雑で、 クリア 信号を追加するのなら、プリセット信号の追加も検討してよいかもしれない。 ク リア信号ではクロックやデータの入力に関係なくQが0になるのに対して、 プ リセットではQが1になる。 デジタル時計を作るなら、このクリア信号とプリ セット信号は、時計を最初の時刻に設定するのに便利だろう。

以下に、3入力のNOR ゲート6個とインバーター1個で構成されるプリセッ トクリア付きエッジトリガー型Dタイプフリップフロップを紹介する。 単純 ではない分、 対称性で補っている。

クリア プリセット クロック データ XXXX Q Q

-

7313 プ

第17章 フィードバックとフリップフロッ

プリセットとクリアの入力は、クロックとデータの入力を上書きする。 通常、 プリセットとクリアの入力はどちらも0だ。 プリセット入力が1の場合、 Q は 1になり、Qは0になる。 クリア入力が1の場合、 Qは0となり、Qは1とな ある (R-S フリップフロップのセットとリセットの入力のように、プリセットと クリアは同時に1にすべきではない)。 それ以外の場合、 通常のエッジトリガー 型のDタイプフリップフロップのように動作する (Pre はプリセット)。

入力 出力 Pre Clr D Clk Q Q 1 0 X X 1 0 0 1 X X 0 1 0 0 0 0 1 0 0 1 ↑ 1 0 0 0 X 0 Q Q

プリセットとクリアを持つエッジトリガー型Dタイプフリップフロップの図 は次のようになる。

Pre Clk D Clr

第15章では、 TTL (トランジスタ トランジスタロジック) と呼ばれるファ ミリーに属する集積回路のいくつかの例を説明した。 もしTTLで回路を組んで いて、このようなフリップフロップが必要だとしても、ゲートレベルから構築す る必要はない。 7474 チップは、「プリセットとクリアを持つデュアルDタイプ ポジティブエッジトリガー型フリップフロップ」 と説明されていて、「設計エン ジニアのためのTTLデータブック」 では次のように示されている。

314

VCC 2Clr 2D 2Clk 2Pre 2Q 2Q 14 13 12 11 10 9 8 Clr Q Clk PRE PRE D Q Clk Q Clr 1 5 6 7 1Clr 1D 1Clk 1Pre 1Q 1Q GND

これまでの取り組みによって、 リレーとトランジスタを用いて2進数での加 算、減算、カウンターを実現できるようになった。 さらに、 フリップフロップが ビットやバイトを保持する方法も学んだ。 これは、 メモリーとして知られるコン かなめ ピュータの要となる部品を製作するための初歩的なステップだ。 だが、 まずは一息ついておこう。

ܚܐ

第 18 章 時計を作ろう!

時計作りは楽しいプロジェクトに違いない! 大きくて古風な振り子時計を想像 してほしい。 複雑に彫り込まれた木製の外枠と、 ゆっくりと大きく揺れる振り子 が見えるガラスのドアを備えたものだ。 華やかな金属文字盤の裏側には、エス ケープメント [脱進機] と呼ばれる巧妙な機構で時を刻む歯車があり、 その音は 家中に響き渡って毎正時に荘厳なチャイムを鳴らす。

だが、私たちが作ろうとしているのはそういう時計ではない。 本章で作成する 時計は、文字盤の上を針が回転する代わりに、 時間、 分、 秒を数字で表示するデ ジタル時計だ。 実のところ、この時計の最初のバージョンでは、 通常の10進数 の数字を表示する代わりに、 点滅するライトを使って2進数で表示する。

わかっている。 確かに時刻表示が2進数なのは、ちょっと厳しいかもしれな い。 だが、それは見慣れた 10進数で時刻を表示するために必要な一歩だ。 さら に、 使用する2進数は純粋な2進数と10進数の中間的な形式である。

まず、時刻を構成する数字を見てみよう。 秒も含めると、 時刻表示には10進 数で6桁が必要だ。 たとえば、次のように。

12:30:47

これは12時、30分、 47秒で、 深夜か正午をすぎてから約30分後を示してい る。 AM または PM を示す表示があれば、これらの情報がさらに明確になる。 2進法を使うと、この時刻は数字 12 30 47の2進数で表現できる。

1100 11110 101111

ほかの人がどうかは知らないが、私はこの形で時刻を見ることはうれしくな い。 このような2進数を 10 進数に変換し終える頃には、 時間が1分経っている かもしれないからだ。

だから、そうした方法は採用しないことにしよう。 代わりに、 10 進数の各数 字をそれぞれ2進数で表示しよう。 そうすれば、 12:30:47 という時刻は、1、2、 3、0、4、7という数字をそれぞれ2進数にして、 次のように表示できる。

0001 00100011 0000: 0100 0111

この方法なら、 頭の中で変換すべき4桁の2進数が6つあるだけだ。 さらに、 10 進数の数字はすべて0から9の間であるから、 変換がはるかに簡単になる。 この時計で秒が経過するのを見ていると、 2進数を素早く読み解くことができる ようになるだろう。

このような表現方法には名前があり、 BCD (Binary-Coded Decimal [2進化 10 [進表現]) と呼ばれる。 BCD では、10進数の各桁の数字を次の表のように4桁 の2進数として符号化する。

BCD

0000

10進数

0001

0010

0

0011

2

0100

3

0101

4

20110

0111

1

1000

1001

5

6

7

8

9

前にもこのような表を見たことがあると思うが、 通常は 1001 (10進数で9)

316

第18章 時計を作ろう! 317

を超えてこの先に 1010 1011 1100 1101 1110 1111 と続き、10進数の 10~15に相当する2進数が示される。 しかし BCD ではこれらの追加の2進 数は無効だ。BCD で使われるのは100までで、それ以外のビットの組み合わ せは使用されない。

これは、ビットが自己について何も教えてくれないという、 また別の事例だ。 たとえば、10011001 という数に遭遇したとき、 何らかの文脈がなければ、それ が何を意味するのかはわからない。 符号なし整数として見れば、 それは 153と いう 10 進数だ。 しかし、 2の補数符号付き整数 (第16章で学んだ)として見 れば、 103 だ。 そしてBCD なら、 99 となる。

BCD は、 コンピュータ内部での基本的な算術操作、たとえば加算や減算を複 雑にするため、 あまり使用されない。 だが、 10進数を表示する際には、BCD が しばしば中間ステップとして用いられる。

本章で最初に紹介する時計は、必ずしも正確な時刻を表示しない。 しかし、秒 00 から 59 まで、 次に分が00から59まで、 そして時が進む様子を示す。 時 刻を BCD で表示するという決定は、 時刻を示す6つの10進数の各桁が、秒か ら始めてそれぞれ個別に計算できることを意味する。 以下に、 時刻を構成する6 つの数字とその有効な範囲を示す。

・秒 (下位桁)、 範囲は0~9 ・秒 (上位桁)、 範囲は0~5 •分 (下位桁)、 範囲は0~9 •分 (上位桁)、 範囲は0~5 ・時 (下位桁)、 範囲は0~9 ・時 (上位桁)、 0 または 1

秒の下位桁は、0から9まで着実に増えていく。 その下位桁は9になるたびに ロールオーバー(またはリセット) して0になり、秒の上位桁が1ずつインクリ メント(つまり増加) する。 この値は0から1、2、3、4、 そして最後に5とな る。 秒が59 になると次の値は00に戻り、 分が1つ増える。

時刻の6つの桁のそれぞれには、別々の回路が必要で、それが次の回路に影 響を与える。

まずは秒の下位桁から始めてみよう。 4つのエッジトリガー型フリップフロッ

プを1列に配線することから始めればよいだろう。 これは、 第17章の308ペー ジでリップルカウンターを作るためにフリップフロップを配線した方法と似てい る。 フリップフロップの各出力 Qは、 電球に接続されている。

Q Clk Q Clk Q Clk QClk 1秒周期 Clr D Clr D Clr D Clr D

第17章では、 フリップフロップは左から右に配線されていたが、ここでは右 から左に配線されている。 後述するが、この配置により、電球が読み取り可能な 2進数を表示できるようになる。

最も右側の入力は、 周波数が1ヘルツ、 つまり1秒に1サイクル回る何らか のオシレーターだ。 このオシレーターの周期 (1サイクルに必要な時間) は、 1 を周波数で割ったもの、つまり1秒だ。 この1秒オシレーターは、毎秒 0から 1になり、 そして0に戻る。

各フリップフロップの出力はQとで、これらは反対の値を持つ。 Q が 0 な ら、Qは1だ。 各フリップフロップは、 出力 を入力D (データ) に接続して いる。 クロック入力が0から1に変化すると、 その入力Dが出力 Q となる。 そ の出力 Qが0から1に変化すると、次の左側のフリップフロップの状態も変化 する。

右端にある1つ目のフリップフロップの出力Qは、1秒間は0、 次の1秒間 は1となるので、 電球は1秒間消灯し、1秒間点灯することになる。 周期は2 秒で、 周波数は半分に分割されている。 右から2番目のフリップフロップがそ の周波数を再び半分にしてライトを2秒間点灯したままにし、 次に2秒間消す これが続いていく。

その結果、4つの点滅する電球が2進数で秒を数えることになる。

318

第18章 時計を作ろう!

0000

0001

0010

0011

0100

1110

1111

0000

ライトは0000 から 1111まで数え、 その後 0000 に戻り、 16秒ごとに1周期を 完了する。

しかし、これは私たちが望んでいることではない! 望んでいるのは、電球が 10秒毎に0000から1001まで数えることだ。 それが1001 (10進数で9) に達 したら、 次は 0000 に戻るようにしたい。

幸い、下部に Clr と書かれたクリア入力があるフリップフロップを使用してい る。このクリア入力を1にすると, ほかの入力に関係なくフリップフロップの 出力 Qは0になる。 さらに、 すべてのクリア入力を同時に1に設定すると、表 示されている数を 0000 に戻すことができる。

これらのクリア入力は、 どのような場合に1に設定すべきだろう? 表示値が 1001 (10進数で9) は有効だが、 次の値1010 (10進数で10) は無効だ。 した がって、4つのフリップフロップの出力が1010(10進数で10) である場合、 す べてのフリップフロップを0にクリアしたい。 つまり、4つのフリップフロップ の出力が 1010(10進数で10) であるとき すべてのフリップフロップをゼロ クリアしたい。

これは、フリップフロップの出力 Qのうちの2つに AND ゲートを接続する ことで実現できる。

| 319

Q Clk Q Clk Q Clk Q Clk< 1秒周期 Clr D Clr D Clr D DP Clr

実際には、 フリップフロップを構成するトランジスタは非常に高速であるた め、 1010 から 0000 への遷移を目で見ることはできないだろう。4つのフリッ プフロップの出力Q が 1010 となると同時に、 AND ゲートの出力が1になり、 フリップフロップがクリアされ、 すべての値がゼロに戻る。 視覚的には、 1001 から 0000へとスムーズに遷移する。

0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 0000

フリップフロップの出力を利用してフリップフロップをクリアすることに少し 不安を覚えたとしても、その心配は全く役に立たないわけではない。 もっとよい やり方もあるが、 少々複雑だ。 実際に「バイナリー時計」を製作しているのな ら、0000 から 1001までカウントし、その後スムーズに 0000 に戻るディケー ドカウンター [10進カウンター] と呼ばれる集積回路が存在することを知っておく

320

第18章 時計を作ろう!

べきだ。

| 321

現在は0から9までの秒をカウントしているが、 すぐに秒の上位桁を0から 5までカウントする別の回路が登場する。下位桁の4つのライトが1001 から 0000 に戻るとき、 上位桁は増える。 それは、その時点で0から1に変化する 信号が必要だということだ。

その目的のために AND ゲートの出力を使うことも可能だが、ここではこの回 路に NAND ゲートを追加することで少し異なったアプローチを試みよう。

周期 Clk Clk Q Clk Q Clk 1秒周期 Clr D Clr

10秒

NAND ゲートの出力は、 AND ゲートとは逆だということを思い出してほし い。 出力は通常1だが、2つの入力が1である場合のみ、 出力は0となる。 こ のNAND ゲートは、表示される数字が1001、 つまり10進数で9のときに、 2 つの入力がとなるように配線されている。 NAND ゲートの出力は、表示され る数字が1001のときに0になり、 その後1に戻る。 これは10秒ごとに起こり、 0から1への遷移は別のエッジトリガー型フリップフロップの入力にすることが できる。

次のタイミング図では、1秒周期の信号、4つ (右から左へ) のフリップフ ロップの出力 Q10 秒周期の信号が示されている。

1秒周期 フリップフロップ1 0 1 0 フリップフロップ2 0 0 1 1 1 0 0 0 0 フリップフロップ3 0 0 0 0 1 1 1 1 0 0 0 0 フリップフロップ4 0 0 0 0 0 0 0 0 1 1 0 0 10秒周期

図を時計回りに90度回転させると、4つのフリップフロップが0000 から 1001 までカウントし、また最初に戻っていることがわかる。

そのNAND ゲートの出力は、 バイナリー時計の秒の上位桁 (0、 1、2、3、4、 5)をカウントするための入力となる。 この上位桁は3つのフリップフロップで 構成できるが、110 (10進数で6) になったときに、すべてのフリップフロップ をクリアする必要がある。

1分周期 Clk Q Clk Q Clk 10秒周期 Clr 'Clr

この回路のNAND ゲートの出力は、 表示数字が 101 すなわち 10進数で5 のときに0となる。 前の4つのフリップフロップと組み合わせると、クロック は今、0000000 から 101 100 まで、 つまり 10進数で59までカウントし、そ の時点で全7つのフリップフロップが0に戻る。 次ページに、 これら3つのフ リップフロップのためのタイミングダイアグラムを示す。

322

第18章 時計を作ろう!

10秒周期 フリップフロップ1 0 フリップフロップ2 0 0 0 0 0 0 フリップフロップ3 0 0 0 0 1 0 0 1分周期

ここでも、図を90度時計回りに回転させれば、 フリップフロップが000 から 101 までカウントし、そこから最初に戻る様子を見ることができる。 ここまでで1分周期の信号が得られた。 これで分単位のカウントを始めるこ とができる。 さらに4つのフリップフロップが、 先の4つと同様に、0から9 までの分をカウントするように構成されている。

10分周期 Clk Clk Clk Q Clk 1分周期 Clr Clr D

この10分周期の出力は、 秒の上位桁と同じような、 分の上位桁のための3つ のフリップフロップからなる別のグループへの入力にすることができる。

00:00:00

323

1時間周期 Clk Q Clk Q Clk ・10分周期 Clr D Clr D Clr D

さて、バイナリー時計の構築も佳境に入ったように思われるものの、 何やら不 穏な予感がする人もいるかもしれない。

24時間制の時計では、時間は0から始まり23まで進む。 だが、 英語圏の国々 では一般に 12 時間制を使用し、 それが問題を引き起こす。 時は秒や分と同様に 2桁だが、 時はゼロから始まらない。 慣習的に、 正午や真夜中は12時であり、 その次は1時となる。

まあ、この問題はいったん無視しよう。 12時間制の時計では時が0、1、2、 3、4、5、6、7、8、9、10、 11 と進み、 そこから再び0に戻ると仮定し、 00:00:00 という時刻を真夜中または正午と呼ぶことにする。

しかし、時にはまた別の特性がある。 秒や分では、下位桁と上位桁のクリアは 互いに独立している。 下位桁は 1010(10進数で10) になったときにクリアさ れなければならず、 上位桁は110 (10進数で6) になったときにクリアされなけ ればならない。

時でも、下位桁が1010になったときにクリアしなければならない。 それが 9:59:59 から 10:00:00 への移行だ。 ただし、 上位桁が1、 下位桁が0010(10進 数で2) の場合は、 両桁ともクリアする必要がある。 それが、 11:59:59 から真 夜中もしくは正午への移行である。 ここでは一時的に 00:00:00 と表現すること にしよう。

これは時の下位桁と上位桁を一緒に考える必要があることを意味する。 次に示 す5つのフリップフロップは、2つの桁が2つの異なる条件下でどのようにクリ アされるかを示している。

324

第18章 時計を作ろう!

12時間周期 ① ① ① Q Clk Q Clk+ Q Clk Q Clk Q Clk ・1時間周期 Cir D C D Qar D QCr D Clr D

右側の4つのフリップフロップは、秒や分の下位桁と非常に似た構成で接続 されている。 AND ゲートは、 数値が1010 になるとフリップフロップをクリア し、その時点で NAND ゲートが0から1への遷移信号を出力する。

しかし、 左上にあるもう1つの3入力 AND ゲートは、 時の上位桁が1で下 位桁が0010 (10進数で2) つまり、これらを組み合わせたBCD 値が12にな るときに動作する。 この時点で12を表示したいと思うかもしれないが、そうす ると次の値を1と表示する問題に直面することになる。 そこで、この3入力 AND ゲートは5つの全フリップフロップをクリアし、表示される時を0にす る。

こうしてこの回路は、0から11までの時を順序通りに表示する。 あと1つだ け問題を解決する必要がある。 全フリップフロップの出力 Qが0のとき、表示 される時は 12、 つまり 10010 になることだ。

これは、次ページに示すように、右端に示された5入力のNOR ゲートを使用 することで実現できる。

|325

326

12時間周期 ① Do. Q Clk Q Clk Clr D Q Clk Cr D Q Clk- Clr D Q Clk Clr D 1時間周期

NOR ゲートの出力はOR ゲートの反対であることを思い出してほしい。 この NOR ゲートの出力は、5つの全入力が0のときだけ1になる。 そのNOR ゲー トの出力は、2つの桁のOR ゲートへの入力になる。 したがって、5つのフリッ プフロップの出力が00000のとき、 表示灯は10010、 すなわち 10進数の12 を表示する。

まだ言及していなかった、 左端にあるNAND ゲートについて説明しよう。 こ のゲートの出力は通常1だが、 時間が10001 すなわち 10進数で11のときだ け0になる。 時が11でなくなると、 出力は再び1に戻る。 この出力は、午前午 後を示す AM/PMインジケーターの役割を果たす別のフリップフロップへの入 力として利用できる。

Q Clk 12時間周期 Clr D

これまで見てきたすべてのコンポーネントを組み合わせた完全なバイナリー時 計は、ウェブサイト(www.CodeHiddenLanguage.com)で見ることができる。 この時計の6桁それぞれがNAND ゲートを使って次の桁のクロック信号を生

第18章 時計を作ろう! 327

成することは、すでに示した通りだ。 NAND ゲートの出力は、2つの入力がと もにでない限り、 通常は1である。 これは、 時計が最初に起動したときに特 異な状況を引き起こす。 このとき、 各NAND ゲートの出力は1になり、次のグ ループの最初のフリップフロップのクロック入力をトリガーする [引き起こす ] 。 このため時計が始動すると、 初期の時刻は次のように設定される。

1:11:10

それがまさに時計を立ち上げた時刻であればよいのだが、そうでない場合は、現 在の時刻に設定できるようにしたいはずだ。

デジタル時計の中には、インターネットやGPS衛星から時刻を取得したり、 無線信号から時刻を取得するものもある。 しかし、 手動で時刻を設定する必要が ある時計の中には、操作が複雑で詳細な指示が必要になるほど複数のボタンを備 えたものに遭遇したことがあるかもしれない。

人へのインターフェースは常にチャレンジングだが、ここではとても単純なも のを実装してみよう。

バイナリー時計の秒、 分、 時は、 次のブロック図で示すように、 右から左へと 接続されている。

1時間周期 1周期 1秒周期 時 分 秒

この回路に2つのスイッチを追加してみよう。 これらのうち1つ目のスイッ チを押すと手動で分が増加し、 2つ目のスイッチを押すと手動で時が増加する。 このアプローチは最適解ではない。 たとえば、表示時間が2:55 でそれを 1:50 に設定する必要がある場合、 分ボタンを55回、時ボタンを11回押す必要があ る。しかし、この方法の単純さは利点となる。 時刻を設定するための詳細な説明 は不要だからだ。

通常、秒が59に達すると分が増え、 00 に戻る。 「1分周期」 と書かれたその 信号は、 通常は1だが、秒の上位桁が5のときは0になる。 同様に、 「1時間周 「」 と書かれた信号も通常は1だが、 分の上位桁が5の場合は0となる。

時刻を設定するスイッチが押されたとき、この2つの信号を変化させたい。

たとえば、 「1分周期」の信号が1 (ほとんどの場合) であれば、 スイッチを押す と0になり、スイッチを離したら1に戻るようにする。 同様に、この信号が0 の場合 (つまり秒が50~59の場合)、 このスイッチを押すと信号が1になり スイッチを離すと 0 に戻る。

つまり、時刻を手動で設定するためのスイッチは、 「1分周期」 と 「1時間周 期」 の信号を通常の反対にするべきなのだ。

これは排他的論理和、 つまり XOR ゲートの応用の1つである。 第14章では このゲートを2つの数を加算するために使った。 XOR の出力は、 両方の入力が 1のときを除いて、 OR ゲートと同じである。

XOR 0 1 0 0 1 1 1 0

加算における重要な役割のほかにも、 XOR ゲートは信号を反転させることも できる。1つの入力 (A) が0の場合、 XOR ゲートの出力はほかの入力 (B) と同じになる。しかし、1つの入力 (A) が1の場合、 出力はほかの入力 (B) の反対になる。

XOR ゲートを使えば、 手動で時間を設定するためのスイッチを追加するのは とても簡単だ。

時 V 分 V 秒

バイナリー時計で秒と分がすぎていく様子は、 とても催眠的な効果がある。

328

第18章 時計を作ろう! 329

1970年代から、 フラッシングライト付きのバイナリー時計が、 ノベルティアイ テムとして製造・販売されるようになった。 これらの商品は、しばしば基礎とな る回路の単純さを反映していない価格で販売されていた。 しかし、 2進数、 少な くとも2進数で符号化された10進数を学びたい人にとっては、 教育的な価値が ある。

通常の10進数の表示を好む人のためには、 代替案もある。 最も美しい (技術 的にレトロな意味で) ものの1つは、冷極陰管ディスプレイと呼ばれ、 ほぼネ オンで満たされたガラス管だ。 内部には数字の形をした配線が重なっており、 そ れぞれの配線は左端の0から始まる下部の10本のピンのいずれかに接続されて いる。

図には示されていないが、 もう一つグランド用ピンがある。 また、 これらの 配線を取り囲み、そのグランドに接続されたワイヤーメッシュも図には示されて いない。

あるピンに電圧をかけると、 その数字を囲むネオンが光る。

330

バローズ社がこのタイプのディスプレイ管を1955年に導入し、それに神話上 の水の精霊の名前をつけた。 ニキシー管という名前だ。

時刻表示の6桁それぞれに、この管が1つずつ必要だ。 概念的には、ニキシー 管は簡単に使える。 それぞれの数値を光らせるために、 10本のピンの1つに電 力を適用する回路を設計するだけでよい。 実用上は、一般的に集積回路のトラン ジスタから得られる以上の電力が必要となるため、 少し難しくなる。 とはいえ、 ニキシー管用に必要な電流を供給するドライバーと呼ばれる特別な回路が利用可 能だ。

ニキシー管のデジタル回路は、 フリップフロップから出力される BCD 化され た10進数を、10本のピンそれぞれに振り分ける必要がある。 数値が0000のと きは、0を表す最初のピン用の信号が必要だ。 数値が0001のときはのピンを、 そして数値が1001のときは9を表す最後のピンを表す信号が必要になる。

第10章の終盤、 153ページでこのような回路を見たことがある。 そこでは8 進数が、8つのライトのうちの1つを点灯する信号に変換された。 そのような回 路はデコーダーと呼ばれ、 ここでは BCD 数に対応できるよう少しだけ拡張され ている。 したがって、この回路は BCD デコーダーと呼ばれる。

第18章 時計を作ろう!

BCD化された10進数

この回路は一見混乱しているように見えるかもしれないが、極めて体系的だ。 4つのフリップフロップから出力される BCD 数値は下からやってくる。 図の赤 い線は、現在この数値が2進数で0101 つまり 10進数で5を表していること を示す。 この4つの信号はそれぞれインバーターで反転され、 元の信号と反転 された信号の様々な組み合わせが、10個の4入力 AND ゲートに入力される。 に対応する AND ゲート (中央のすぐ右側のAND ゲート) の場合、4つの入

331

力は次のようになる。

・BCDの最下位(右端)のビット

・BCDの最下位から2番目のビットを反転させたビット ・BCD の最上位から2番目のビット ・BCDの最上位 (左端) のビットを反転させたビット

これら4つの入力は、 BCD 数が 0101 の場合のみ、 すべて1となる。 10 進数を表示するより一般的な方法は、 7セグメントディスプレイを利用す るものだ。 これは、シンプルなパターンで配置された7つの細長いライトで構 成されている。

この種のディスプレイが製造されるときには、 通常は背面に7つのピンが存 在し、それぞれが7つのセグメント [区画] の1つに対応している。 また8番目 のピンはグランドに接続される。7つのピンに電圧を組み合わせて適用すること で、特定の10進数を表示するための適切なセグメントが点灯する。

332

第18章 時計を作ろう!

88888 58889

7セグメントディスプレイの配線を簡単にするために、各セグメントには特定 の識別文字が割り当てられている。

f g 8

次ページの表は、10進数の0から9までの各桁の数字に対して、 どのセグメ ントを点灯させなければならないかを示したものだ

333

数字 a b C d e f g 0 1 1 1 1 1 1 0 1 0 1 1 0 0 0 0 2 1 1 0 1 1 0 1 3 1 1 1 1 0 0 1 4 0 1 1 0 0 1 1 5 1 0 1 1 0 1 1 6 1 0 1 1 1 1 1 7 1 1 1 0 0 0 0 8 1 1 1 1 1 1 1 9 1 1 1 1 0 1 1

10 進数の数字に対応する信号はすでに手に入っている。 それらは、ニキシー 管を点灯させるために使用したばかりのBCD デコーダーのAND ゲートの出力 だ。

まずは 「a」 セグメントに着目しよう。 このセグメントは、 10進数の 0,2,3, 5, 6, 7, 8, 9 のときに点灯しなければならない。 つまり、これらの数字に対応す る8つのAND ゲートの出力が、 8 入力 OR ゲートの入力となる。

6 7 8 9 a

同様のことが 「b」から「g」のセグメントにも行える。 だが、もう少しシンプルな方法を採用したいかもしれない。 「a」 セグメントは、 数字が 0, 2, 3, 5, 6, 7, 8, 9のときに点灯する。 これは、I

334

第18章 時計を作ろう! 335

と4のときには点灯しないことを意味する。 したがって、1と4に対応する2 つのAND ゲートの出力を、 通常の2入力 NOR ゲートの入力として使うことが できる。

4 x- a

このNOR ゲートの出力は、 1または4の入力が1のときを除いて、常に1と なる。 1または4の入力が1のときには上部のセグメント (a) は点灯しない。

これら2つのアプローチは完全に同一ではない。 たとえば7セグメントディ スプレイが10進数のいずれかの数字を表示するのではなく、完全にブランク [空白] にしたい場合があるかもしれない。 これは、 BCD デコーダーのAND ゲートからの10個の信号のいずれもが1でない場合に実現できる。 8入力 OR ゲートはそうした状況で正しく動作するが、 2入力 NOR ゲートは上部のセグメ ントを点灯し続けることになる。

7セグメントディスプレイが常に数字を表示するのであれば、ここで示すよう に BCD デコーダーから7セグメントデコーダーを構築できる。

ZIMA

336

BCDデコーダーからのANDゲート

5つのセグメントに対しては NOR ゲートが使用され、残りの2つに対しては OR ゲートとインバーターが使用されていることに注意してほしい。 また、最も右側のAND ゲートが何にも接続されていないことにも注意しよ う!このAND ゲートは数字9の表示に対応し、 その数字のすべてのセグメン トはNOR ゲートとインバーターによって点灯される。

7セグメントディスプレイに、 16進数用の追加の数字を表示するように配線 することも可能だが、 16進数のBと8を、 そして 16進数のDと0を区別する 何らかの方法が必要だ。 1つの解決策としては、 大文字と小文字を混ぜるやり方 がある。ここでは、 文字 A, b, C, d, E, F が使われる。

第18章 時計を作ろう!

888888

すべての 26文字を表現するには、 対角線のセグメントを含むいくつかの追加 のセグメントが必要だ。 一般的な解決策としては、14セグメントディスプレイ や16セグメントディスプレイがある。

表示するすべての数字ごとにデコード回路が必要なのかと思うかもしれない。 もちろん、そうもできるが、 回路の量を減らす代替案がある。 マルチプレクシン グ [多重化]と呼ばれる技術を使えば、デコード回路を複数の数字で共有できる。 デコーダーの入力は異なる数字間を素早く切り替えることが可能で、 デコーダー の出力はすべてのディスプレイに同時に出力できる。 その際に、デコーダーが各 種のソース間でシフトするのと同期して、ディスプレイのうちの1つだけが接 地 (グランド) される。 ある時点では、 1つの数字だけしか点灯していないが、 ディスプレイ間のシフトが非常に素早く行われるので、 通常、 人は切り替えに気 づかないのだ。

さらに別のアプローチとして、 数字と文字を表示するためのドットマトリクス という方式がある。 これは、 水平および垂直に配置された丸いライトの集合体 だ。 すべての数字、 句読記号、 アクセントのつかないラテンアルファベットの文 字を扱える最小のグリッドは、 幅5ドット、 高さ7ドットのもので、5×7ドッ トマトリクスと呼ばれる。 数字の3を表示した例を示す。

337

これらの小さなライトも、先ほどの7セグメントディスプレイの例で示した 技術を用いて独立して制御できると思うかもしれない。 しかし、 それはうまくい かない。これらの小さな光は35個あるので、 それぞれを個別にオンオフしよう とすると、回路はかなりの量となる。 そこで、別のアプローチが用いられる。

それらの35のライトは、 発光ダイオード、つまりLEDだ。 ダイオードは小 さな電子部品で、次のように記号化される。

ダイオードは、電流を一方向 (この場合は左から右) にしか流せない。 右側に ある垂直線は、ダイオードが右から左へ流れる電流を遮断することを意味する。

発光ダイオードは、 電流が流れるときに光子を放出するダイオードだ。この光 子は、私たちの目に光として認識される。 LEDは通常、 光線を表す小さな矢印 が添えられたダイオードに似た記号が使われる。

ここ数十年、 LED が明るく安価になってきた結果、 ほかの種類の電球よりも 少ない電力と熱で、 私たちの家を照らせるようになった。

5×7のドットマトリクスディスプレイを構成する 35個のLED は、次のよ うに配線されている。

338

第18章 時計を作ろう!

4 [肉] ZE

各LED は行と列の交点にある。 LED の各行には、ダイオードの入力が接続 され、各列には出力が接続される (代替案としては、列で入力し、 行で出力する こともできるが、 全体的な動作には大きな違いはない)。

この構成にすることで、 本来なら35個のLED それぞれに必要だった配線の 数を 7行 5列の、わずか12個に減らすことができた。

欠点として、 一度に1列または1行しか光らせることができないことだ。 こ れは一見、恐ろしいほどの制約に思えるが、 ちょっとしたトリックがある。 ドッ トマトリックスの行と列を順番に素早く表示していくと、あたかもディスプレイ 全体が一度に点灯しているように見えるのだ。

ドットマトリクスによって数字3がどのように表示されるかを再考してみよ う。 最も左側の列では、1番上の行のライトと下から2番目の行のライトの2つ が点灯している。 これは、これら2つの行に電圧を供給し、 1番左の列に接地 (グランド) を提供することで実現できる。

|339

340

V

V.

電圧からグランドへのすべての可能な接続を調べてみれば、 ダイオードが2 つの点灯しているライト以外のすべてのパスを遮断していることがわかるだろ う。

数字の3に対する2列目では、1番上と1番下のライトが点灯する。 そのた めには、この2行に電圧をかけ、2列目にグランドを接続する。

第18章 時計を作ろう!

V 4 4

ほかの列も同様に動作する。 数字の3を表示する際には、 右端の列について は、3つのライトを点灯させる必要がある。 それらの行に電圧をかけ、 1つの列 にグランドを接続する。

341

4

V.

V

兵

4

あとは、 ドットマトリックスの行に電圧を供給し、列の1つにグランドを接 続するプロセスを自動化する方法を考えなければならない。

今回もダイオードの出番だが、 発光タイプではなく、 普通のダイオードが使わ れる。ここでは、数字の 「3」 を模したダイオードの配線方法を紹介する。

342

第18章 時計を作ろう!

ここに3という数字があるのがわかるだろうか?このダイオードは、先に紹 介した3を表示する点灯ライトにそっくり対応している。 しかし再度強調する が、これらは LED ではない。 ただの通常のダイオードだ。 数字3は基本的に、 このダイオードの集合に符号化されている。

このようなダイオードの配置をダイオードマトリクスと呼ぶ。 これは情報、 具 体的には数字3を表示するために点灯しなければならない光の位置、 を格納し ている。 そのため、このダイオードマトリクスは一種のメモリーとも考えられ る。ダイオードの配線を変更しなければこのダイオードマトリクスの内容は変更 できないため、より正確には、一種の読み取り専用メモリー、 すなわち ROM (リードオンリーメモリー)といえる。

このダイオードマトリクス ROM は、 ドットマトリクスLEDディスプレイで 数字3を表示するのに役立つ。 一番上の行の各列に対応する電線に注目してみ よう。 これらはドットマトリクスディスプレイの5列に対応している。 次ペー ジの図は、 左端にある垂直の電線に電圧が供給されている様子を示す。

343

344

ダイオードの配置によって、 右に向かって2行分の電圧が供給される。 これ らは、数字の3を表すLEDの1列目に点灯させるべきライトに対応する。

残りの列に順次 (かつ迅速に) 電圧を供給することで、 LED ドットマトリク スディスプレイで3を表示するのに必要なすべての電圧の組み合わせを生成で きる。

次の図は、ダイオードマトリクス ROM とドットマトリクスディスプレイが、 いくつかの補助回路とともに配線されている様子を示している。 ダイオードマト リクス ROM は、 先ほどの図からわずかに再配置されているが、 機能的には同 じだ。

第18章 時計を作ろう!

4

4

4

4

Q2

3-to-5 デコーダー

Qi

Qo

4

1

2

Q2

0

3-to-5 シンカー

3

Q₁

3

Qo

高速なオシレーター

Qo Q Q

Clk

0-to-4 カウンター

回路の検討を左下の角から始めよう。 まず、人の視覚システムが気づかないほ どの速さで光を点滅させるため、非常に高速なオシレーターが必要だ。 このオシ レーターは、3つのフリップフロップから構成されるカウンターへの入力となる。 このような回路は以前にも見たことがあるだろう。

345

Q0 Q Q2 > Clk Q Clk Q Clk D D Clr Clr D Clr

このカウンターは時計で使われていたものと似ているが、 0から4まで、 つま り2進数でいうと000001、010、011, 100 までしかカウントしない。 101 に達すると、 AND ゲートが3つのフリップフロップを0にリセットする。

これらの2進数は左側にある 3-to-5 デコーダーへの入力となる。 これは第10 章の153ページに示された3-to-8 デコーダーや本章の前半で示した BCD デコー ダーの単純なバージョンだ。 シンプルになっているのは、 000 から 100までの 3桁の2進数を5つのシグナルの1つにデコードするだけでよいからだ。

0 Q2

3桁の2進数が000 から 100までカウントされると、 デコーダーの出力は順

346

第18章 時計を作ろう! 347

0、 1、2、3、4となり、 次のサイクルのために0に戻る。 「4」 とラベル付け された出力には ANDゲートが必要ないことに注意しよう。 なぜなら、2進数が 100 つまり4のときだけQ2は1になるからだ。

これら5つの出力、 0から4までが、 大きな図の左側にあるダイオードマトリ クスROM の5つの列に対応し、 それから右側のドットマトリクスディスプレ イの7つの行に電圧を供給する。 実際には、 電流を制限し、 LED を焼き切らな いように、 ダイオードマトリクスとドットマトリクスディスプレイの間に抵抗が 挿入される。

そして、その電圧は、 「3-to-5 シンカー」 と書かれた不思議な箱に流れ込む (この回路で新しく出現した部品だ)。

この回路は、 少し変わった動作を必要とする。 ダイオードマトリクスを上って いく5つの信号と同期して、 ドットマトリクスディスプレイの5つの列の1つ をグランドに接続する方法が必要なのだ。 本書を通じて、 私たちは電圧を供給す る回路と論理ゲートを構築してきた。 そのような回路は電流源として記述するこ とができる。 しかし、 今必要なのはその反対だ。 私たちは電流を吸収する何か、 つまり自動的にグランドに接続する何かが必要なのだ。

ここで、 第15章で学んだトランジスタを使ってみよう。 以下に、(少なくと もその象徴的な形で) その1つを紹介する。

E

3つの文字はベース (B)、 コレクター (C) エミッター(E) を表している。 ベースに電流を適用すると、 コレクターからエミッターへ電流が流れる。つま り、エミッターをグランドに接続することができる。

先の大きな図の下部にある 「3-to-5 シンカー」 は 「3-to-5デコーダー」とよ く似ている。 実際、両方とも同じ回路を使用できる。 唯一の違いは、上部の

AND ゲートの出力 (および Q2 入力)が5つのトランジスタのベース入力に接 続されていることだ。

ドットマトリクスディスプレイの5つの列から下に流れてくる電流は、これ らのトランジスタによって順次グランドに接続される。

さあ、これでドットマトリクスディスプレイに数字の3を表示する回路が完 成した。 もちろん、 これはまだ望むものではない。 ニキシー管や7セグメント ディスプレイと同様、 この回路でも時計からやってくる 0~9の数字を選択で きるようにしたい。 これには、ほかの9つの数字を含めてダイオードマトリク スを拡張し、 BCD デコーダーを使ってもう一段階の選択を実装する必要がある。 0から9までの数字を表示する、この回路のアニメーション版を、ウェブサイ

ト(www.Code HiddenLanguage.com) で見ることができる。

しかし、いくら2進数に対応した数字をアニメーションで表示するのが楽し いといっても、 本書の目的は時計を作ることではない。

348

第 19 章

メモリーの組み立て

私たちが毎朝眠りから覚めるとき、 記憶が空白を埋めてくれる。 自分がどこに いて、昨日何をしたのか、 そして今日何をするつもりかを思い出す。 これらの記 憶は突如として蘇ったり、 徐々に戻ることもあるだろう。 数分後、いくつかの忘 れ物が残るかもしれない (「おかしい、 寝るときに靴下を履いていた記憶がな い」)。 それでも総じて私たちは、 自分の人生を再構築し、 新たな1日を始める のに十分なつながりを取り戻すことができる。

もちろん、 人間の記憶は必ずしも整然としているとはいえない。 高校時代の幾 何学について何かを思い出そうとすると、 教師が QED [ラテン語の 「quoderat demonstrandum (以上で証明された)』 の略] の意味を説明しようとしたときに火災訓 練のベルが鳴った日のことが頭に浮かんでくるかもしれない。

いずれにせよ、 人間の記憶は完全無欠ではない。 実際、 書き記す行為はおそら く私たちの記憶の不完全さを補うために発明されたのだろう。

私たちは書き、それをあとで読む。 私たちは保存して、 それをあとで回収す る。私たちは貯蔵して、それをあとで取り出す。 記憶の機能は、 それらの行為の 間で情報を損なうことなく維持することだ。 情報を保存するときには、 私たちは 様々な形式の記憶を使う。 先の世紀だけでも、情報を保存するメディアには紙、 プラスチックのディスク、 磁気テープ、さらには各種のコンピュータメモリーが あった。

さらに、電信リレーでも、それが論理ゲートやフリップフロップに組み込まれ ると、情報を保存することができる。 すでに見たようにフリップフロップは

1ビットの情報を保存する能力がある。 これは多くの情報とはいえないが、始ま りにはなる。 1ビットを保存する方法を一度知れば、2ビットや3ビット、 それ 以上を容易に保存できるのだ。

第17章の294ページで、 インバーター、 2つのAND ゲート、 2つのNOR ゲートからなるレベルトリガー型Dタイプフリップフロップを紹介した。

クロック データ Q

クロック入力が1のとき、出力Qはデータ入力と同じだ。 だがクロック入力 が 0 になると、Qはデータ入力の最後の値を保持する。 データ入力をさらに変 更しても、クロック入力が再び1になるまで、 出力は影響されない。

第17章では、 このフリップフロップを何種類かの回路で紹介したが、 本章で は基本的に1ビットの情報を保存するためにしか使用しない。 そのため、入力 と出力の名称を、 それらの目的により適したものに改名しよう。

書き込み データ入力 ・データ出力

これは同じフリップフロップだが、 出力Qは 「データ出力」 と名づけられ、 クロック入力(第17章ではビット保持) は 「書き込み」 と名づけられている。 私たちが紙に情報を書き留めるように、 書き込み信号によって 「データ入力」 信

350

第19章 メモリーの組み立て 351

号が回路に書き込まれる、つまり保存される。 通常、 書き込み信号は0で、 「データ入力」は出力に影響を与えない。 しかし、 フリップフロップに1ビット のデータを保存したいときには、 書き込み信号を1にしてから再び 0 にする。 以下の論理表では、データ入力、 書き込み、 データ出力がDI、 W, DO と略さ れて示されている。

入力 出力 DI W DO 0 1 0 1 1 1 X 0 DO

第17章で述べたように、 この種の回路はデータをラッチ [施錠] するのでラッ チとも呼ばれるが、 本章ではメモリーと呼ぶことにする。 ここでは、1ビットの メモリーを、 個々の部品を描かずに表現する方法を示す。

DI 1ビットメモリー DO W

あるいは、お好みで次のような向きにもできる。

DI

1ビットメモリー

W

DO

入力と出力の位置は問題ではない。

もちろん、1ビットのメモリーは大したことをできないが、8ビットのメモ リーを配線して1バイトのメモリーを組み立てるのはとても簡単だ。 やること は8本の書き込み信号をつなぐだけである。

書き込み

入力 W DI W DI W DI W DI W DI W DI W DI W DI DO DO DO DO DO DO DO DO 出力

この8ビットメモリーは、8つの入力と8つの出力、 そして通常は 0 である 「書き込み」 という1つの入力を備える。 バイトをメモリーに保存するには、 書 き込み信号を1にして、もう一度0にする。 この回路は、次のように1つの箱 として描くこともできる。

↓ ↓ ↓ ↓ ↓ ↓ DIZ D16 DIS DI4 D13 D12 DI DI W 8ビットメモリー DO DO6 DOs DO4 DO; DO2 DO₁ DO

例によって添え字で8つのビットを区別している。 添え字の0は最下位ビッ ト、 添え字の7は最上位ビットを表している。

1ビットメモリーとの整合性を取るため、8ビットメモリーは入出力に8ビッ トのデータパスを用いて表現できる。

352

第19章 メモリーの組み立て 353

データ入力 DI 8ビットメモリー DO ・データ出力 書き込み W

8個のフリップフロップを組み立てるやり方には、これほど簡単ではない別の 方法がある。 たとえば、 1つのデータ入力信号と1つのデータ出力信号だけが必 要だとする。 しかし、1日のうちに8回、 あるいは次の1分間のうちに8回、 データ入力信号の値を保存する機能がほしいとする。 また、 1つのデータ出力信 号を見るだけで、 その8つの値をあとから読み取れるようにもしたい。

つまり、1つの8ビット値を保存するのではなく、8つに分けた1ビット値を それぞれ保存したいのだ。

8つの別々の1ビット値を保存するにはより複雑な回路が必要だが、 一方では メモリーを単純化する。 8ビットメモリーの外部接続を数え上げると、 合計で 17あることがわかるだろう。 それが1ビットの値を8つ別々に保存する場合、 外部接続はわずか6つに減る。

それがどのように実現されるかを見てみよう。

1ビットの値を8つ保存する場合、8つのフリップフロップが必要なことに変 わりはないが、先ほどの構成とは異なり、 データ入力は1つに接続され、書き 込み信号は別々になっている。

データ入力

D DI W DI W DI W DI W DI W DI W DI W DI DO DO DO DO DO DO DO DO

すべてのデータ入力信号が接続されているとはいえ、すべてのフリップフロッ

プが同じデータ入力値を保存するわけではない。 書き込み信号は別々であるた め、特定のフリップフロップは対応する書き込み信号が1になったときにのみ データ入力値を保存する。 そのフリップフロップが保存する値は、 その時点の データ入力値だ。

8つの書き込み信号を別々に操作するのではなく、 1つの書き込み信号を用意 し、3-to-8 デコーダーを使ってどのフリップフロップを制御するかを決めること ができる。

書き込み

Sp S1 S2

フリップフロップへの書き込み

これに似た回路を以前に見たことがあるだろう。 第10章の終盤153ページで、 3つのスイッチを使用して8進数を指定し、 各 AND ゲートが電球に接続されて いる回路を紹介した。 指定した8進数に応じて、8つの電球のうちの1つ (1つ だけ) が点灯する。 同様の回路は、第18章で時計の数字を表示するために重要 な役割を果たしていた。

So SSのSはセレクト (選択) を意味する。 各AND ゲートの入力には、 これらのセレクト信号またはその反転した信号が1つずつ含まれる。 この 3-to-8 デコーダーは、書き込み信号が S S S の入力と組み合わされている ので、 第 10 章のものよりもやや多目的に使用できる。 書き込み信号が0であれ ば、すべての AND ゲートの出力は0となる。 書き込み信号が1の場合、 So

354

第19章 メモリーの組み立て 355

のAND ゲートのみからが出力される。

S S2 信号の状態に依存して、1つ8つのフリップフロップからのデータ出力信号は、 フリップフロップからの8 つのデータ出力信号のうち1つを選択する 「8-to-1 セレクター」という回路へ の入力とすることができる。

フリップフロップからの8つのデータ出力

So-

S₁

S2

データ出力

ここでも、3つのセレクト信号とその反転信号が8つのAND ゲートに入力さ れる。 So S S2 信号に基づき、 1つだけのAND ゲートが出力1を持つこと ができる。 しかし、 フリップフロップからのデータ出力信号もまた8つのAND ゲートへの入力となる。 選択された AND ゲートの出力は、 フリップフロップか ら対応するデータ出力信号となる。8つの入力を持つOR ゲートが、 8つの中か ら選ばれた最終的なデータ出力信号を提供する。

3-to-8 デコーダーと8-to-1 セレクターは、次のように8つのフリップフロッ プと組み合わせることができる。

356

アドレス 書き込み データ入力 入力 3-to-8 デコーダー O- Og 0. 04 0 0, O W DI W DI W DI W DI W DI W DI W DI W DI DO DO DO DO DO DO DO DO • 1- 16 Is 14 I₁ 12 I₁ To So S1 8-to-1 セレクター 出力

データ出力

デコーダーとセレクターへの3つのセレクト信号が同じであることに注目し てほしい。 また、セレクト信号のラベルに重要な変更を加えた。 それらは、アド レスとラベル付けされている。 なぜなら、それはメモリー内でビットがどこに存 在するかを特定する数値だからだ。 郵便局が使う住所 (アドレス) のようなもの だが、 可能な3ビットのアドレス値は8つだけである。 000,001,010011、 100, 101, 110, 111 E.

入力側では、 アドレス入力が、 どのフリップフロップにデータ入力を、 書き込 み信号の合図に従って書き込むべきかを決定する。 出力側 (図の下部) では、ア ドレス入力が8-to-1 セレクターを制御して、8つのラッチのうちの1つの出力 を選択する。

たとえば、3本のアドレス信号を010に設定し、 データ入力を0または1に 設定して、 書き込み信号を1にしてから0に戻す。 これをメモリーへの書き込

曲

第19章 メモリーの組み立て

みと呼び、 データ入力の値がアドレス010のメモリーに保存されたという。

3本のアドレス信号を別のものに変更しよう。 さて、翌日に戻ってきたとする。 電源がずっと入ったままであれば、3本のアドレス信号を再び010に設定すれ ば、データ出力は、データ入力をメモリーに書き込んだときの値になる。 これを メモリーからの読み出し、 またはメモリーへのアクセスと呼ぶ。 それから、書き 込み信号を 値を書き込むことができる。 そのアドレスのメモリーに別の 設定してから0に戻すことで、

アドレス信号を8種類の値のどれかに設定することで、いつでも8個のビッ ト値を記憶できる。 このフリップフロップ、デコーダー、セレクターの構成は、 値を保存し(つまり書き込み)、 あとでその値が何であるかを知ることができる (つまり読み出し) ことから、 読み出し / 書き込みメモリー(リード/ライトメ モリー) と呼ばれることもある。 アドレス信号を自由に8つの値のいずれにも 変更できるため、このタイプのメモリーは一般にランダムアクセスメモリー ま たは RAM (ラムと発音する) として知られている。

すべてのメモリーがランダムアクセスメモリーというわけではない! 1940年 代後半、 まだ真空管からメモリーを構築することが可能になる前、 そしてもちろ んトランジスタが発明されるはるか前には、ほかの形式のメモリーが使用されて いた。 ある奇妙な技術では、長い水銀の管を用いて情報のビットを保存した。 管 の端から発生したパルスは、池の波のようにもう一方の端へ伝播したが、これら のパルスはランダムではなく順序に従って読み取らなければならなかった。 こう した種類の遅延線メモリーは1960年代まで使用されていた。

先に構築した RAM は、1ビットの値を8つ別々に保存する構成になってい る。これは、次ページのように表現できる (外部接続数が6になったことがこ の図からわかる)。

357

358

データ入力 書き込み DI W アドレス Addr 8 x 1 RAM DO データ出力

特定のRAM の構成はしばしば RAMアレイと呼ばれる。 この特定の RAM アレイは、 8×1 (エイト・バイ・ワンと発音する) と呼ばれる方式で構成され ている。 アレイ内の8つの値はそれぞれ1ビットだ。 RAMアレイで保存でき るビットの総数は、 この場合は8と1を掛けることで求めることができる、 つ まり8ビットだ。

小さいアレイを連結して、より大きなメモリーアレイを作ることが可能だ。 た とえば、8つの8 × 1RAMアレイを持っていて、 すべてのアドレス信号と書き 込み信号を連結すると、 8×8RAM アレイを作ることができる。

データ入力 書き込み DI W アドレス Addr 8 x 8 RAM DO データ出力

データ入力とデータ出力の信号が両方とも8ビット幅になっている。この RAM アレイは8つの異なるバイトを保存し、 それぞれが3ピットのアドレス によって参照される。

しかし、この RAM アレイを8個の8×IRAMアレイから組み立てるとする

第19章 メモリーの組み立て 359

と、デコードロジックとセレクトロジックがすべて重複することになる。さら に、 3-to-8 デコーダーと8-to-1 セレクターには似ている部分が多いことに、 気 がついた人もいるかもしれない。 どちらも4人力のAND ゲートを8個使用し、 3本のセレクトまたはアドレス信号に基づいて選択される。 現実のメモリー構成 では、デコーダーとセレクターはこれらのAND ゲートを共有することになる。

より効率的な方法で RAM アレイを組み立てられるかどうかを見てみよう。 8 バイトを保存する 8 × 8RAM アレイの代わりに、 メモリーを倍増させて 16バイトを保存する 16×8 RAM アレイを作ってみよう。 最終的には、次の ものができるはずだ。

データ入力 書き込み DI W アドレス Addr 16 x 8 RAM DO データ出力

16バイト分のメモリーのアドレスを指定するためには、 4ビット幅のアドレ スが必要だ。 このRAM アレイで保存できるビットの総数は16×8、 つまり 128 であり、 これは 128個の別々のフリップフロップが必要なことを意味する。 明らかに、本書のページ内で完全な 16 × 8RAM アレイを示すのは困難なので、 いくつかの部分に分けて示そう。

本章の冒頭で、 1ビットを保存するのに使うフリップフロップが、 データ入力 と書き込み信号、 データ出力を持つ箱で記号化されることを紹介した。

DI W ビットメモリー DO

1ビットのメモリーはメモリーセルと呼ばれることがある。 こうした 128個 のセルを 8列16行のグリッドに配置しよう。 各行の8個のセルがメモリーの 1バイトである。 (ここでは3行しか示されていないが) 16行で16バイトを表す。

DI- DIG DIS DI4 DI3 DI . DI₁ Dlo Wo DI W DI W DI W DI W DI W DI W DI W DI W W. DI W DI W DI W DI W DI W DI W DI W DI W DI W DI W DI W DI W DI W DI W DI W DI W

いったんデータ出力部分は無視しよう。 各バイトについては、それぞれのバイ トに対して、 一度にメモリー書き込みを行うために書き込み信号が接続されてい る。こうした書き込み信号は、 左端の縦にW。 から Ws とラベル付けされてい る。これらは利用可能な 16個のアドレスに対応する。

データ入力信号は異なる方法で接続されている。 各行とも、バイトの最上位 ビットが左端、最下位ビットが右端となる。 各バイトの対応するビットが接続さ れている。 すべてのバイトが同じデータ入力信号を持つことは問題ではない。な

360

第19章 メモリーの組み立て 361

ぜなら書き込み信号が1のときにのみ、 そのバイトがメモリーに書き込まれる からだ。

16 バイトのうちの1つに書き込むには、 16の異なる値を作り、 メモリーに保 存したい 16個のバイトの中から1つを選択できる4ビット幅のアドレスが必要 だ。 先ほど示したように、 16 × 8RAM アレイのアドレス入力は実際には4 ビット幅だが、そのアドレスを適切な書き込み信号に変換する方法が必要にな る。 それが、 4-to-16 デコーダーの目的だ。

A3 A2

AL

Ao

15 14 13 12 11 10 9 87 6 5 4 3 2

1 0

これが本書で紹介する最も複雑なデコーダーだ! 16個のAND ゲートの各々 は、4つのアドレス信号とその反転信号に対応する4つの入力を持つ。 これらの

AND ゲートの出力を、4つのアドレスビットの値に対応する数字で示している。 このデコーダーは、16×8RAM アレイの 16バイトの書き込み信号を生成 するのに役立つ。 デコーダーのAND ゲートの各出力は、単一の書き込み信号が つながった別のAND ゲートへの入力になる。

4-to-16 デコーダーから

書き込み

15 14 13 12 11 10 9 8 7 6 5 4 3 2 0 W15 W14 W13 W12 W11 W10 W, W W, W Ws W4 W3 W2 W, Wo

これらは、360ページの図でメモリーにデータ入力バイトを書き込むための信 号である。

入力についてはこれで終わりだ。 残るのは 128個のメモリーセルからのデー タ出力信号だけである。 これはなかなか難しい。 なぜなら8列のビットそれぞ れを別々に処理しなければならないからだ。 たとえば、 360ページの16×8 RAM アレイの最左列を扱う簡略化した回路を次ページに示す。 これは、16個 のメモリーセルのデータ出力信号が、 4-to-16 デコーダーの16個の出力とどの ように組み合わされて、 ただ1つだけが選択されるのかを示している。

362

第19章 メモリーの組み立て

4-to-16 デコーダー から DO 0 1 DO 2 15- DO DO- ... DO

4-to-16 デコーダーの16個の出力は左端に表示されている。 各々はAND ゲー トへの入力となる。 AND ゲートへのもう1つの入力は、360ページの図の左端 の列の16個のメモリーセルの1つから出てくるデータ出力だ。 これら16個の AND ゲートの出力は、巨大な16入力OR ゲートに入る。 結果は DO, となり、 これはデータ出力バイトの最上位ビットとなる。

最悪なのは、 バイトを構成する8つのビットそれぞれに対して、 この回路を 複製しなければならないことだ!

幸運なことに、もっとよい方法がある。

どの時点でも、 4-to-16 デコーダーの16の出力のうち1つだけが1の出力を 持つ (実際には電圧がかかっているということだ)。 残りは、 グランドを示す 0 が出力される。 その結果、 AND ゲートのうちの多くても1つだけが (対応する メモリーセルのデータ出力が1の場合に限り) 1の出力を持つことになり、残り の出力はすべて0になる。 巨大な OR ゲートが必要な唯一の理由は、その入力 のいずれかがかどうかを検出するためだ。

もしAND ゲートのすべての出力を直接つなげることができれば、 巨大な OR ゲートを取り除くことができるだろう。しかし、 論理ゲートの出力を直接接続す

| 363

364

るのは通常、禁止されている。 電圧がグランドに直につながる、つまりショート する可能性があるからだ。 しかし、 トランジスタを使用することで、 次のように することができる。

DO 4-to-16 デコーダー・ から データ出力

4-to-16 デコーダーからの信号が1であるならば、 トランジスタのエミッター からのデータ出力信号はメモリーセルからのDO (データ出力) 信号と同じにな る。 それは電圧またはグランド (接地レベル) だ。 だが、 4-to-16 デコーダーか らの信号が0であるなら、 トランジスタは何も通過させない。 その結果、トラ ンジスタのエミッターからのデータ出力信号は何でもなくなる (電圧でもなくグ ランドでもない)。 これは、これらのトランジスタの行からのすべてのデータ出 力信号を、ショートさせることなく接続できることを意味する。

データ出力の接続だけに簡略化したメモリーアレイを再度示そう。 4-to-16デ コーダーの出力は左からきて、 完全なデータ出力信号は下から出る。これらの データ出力信号には、 信号が1または0のいずれかであることを確実にする小 さな抵抗が接続されているが、ここでは示されていない。

第19章 メモリーの組み立て

DO DO DO DO DO DO DO DO DO DO DO DO DO DO DO DO DO DO DO DO DO DO DO 15 DO7 DO6 DOs DO4 DO3 DO2 DOL DOO

16 × 8 RAM のインタラクティブ版は、ウェブサイト (www.Code Hidden Language.com)で見ることができる。

これらのトランジスタは、 トライステートバッファ [3状態バッファ] と呼ばれ る回路の基礎だ。 トライステートバッファの出力は、3つうちの1つとなる。 1 つはグランドで論理0を示す。 もう1つは電圧で論理1を示す。 あるいは何で もない (グランドでも電圧でもなく、 まるで何も接続されていないかのような) 状態を示す。

単一のトライステートバッファは、次のように記号化される。

入力 イネーブル 出力

365

バッファのように見えるが、イネーブル信号 [制御入力信号] が追加されている。 イネーブル信号が1であれば、 出力は入力と同じになる。 それ以外の場合、 出 力は何もつながっていないかのように 「浮く」 といわれる。

トライステートバッファを使うことで、 論理ゲートの出力同士を接続してい けないというルールを破ることができる。 複数のトライステートバッファの出力 は、一度に1つだけがイネーブルされる限り、 ショートさせることなく接続で きる。

トライステートバッファは通常、 単一のイネーブル信号でバイト全体を処 理するとき、より有用だ。

イネーブル 入力 出力

そのトライステートバッファの構成を次のような箱で記号化する。

入力 ル トライステートバッファ EN 出力 イネーブル

今後の図では、 箱にフルネームで表示するスペースがない場合は、「トライス テート」 (Tri-State) または 「トライ」 (TRI) とだけ書くことにする。 トライステートバッファが、16×8 メモリーアレイ内の16バイトのうち 1バイトを選択するのに役立つことは理解できたと思う。 ここで、この16×8

366

第19章 メモリーの組み立て

メモリーアレイに独自のイネーブル入力を持たせたい。

データ入力 書き込み イネーブル DI W アドレス Addr 16 x 8 RAM EN DO データ出力

このイネーブル信号が1のとき、 データ出力信号は指定されたアドレスに格 納されているバイトを示す。 イネーブル信号が0のときには、 データ出力は無 効となる。

さて、16バイトを格納する回路を構築したので、これを倍にしよう。 いや、 4 倍にしよう。いやいや、8倍にしよう。 いやいやいや、メモリー量を16倍に増 やそう!

そのためには、この16×8のメモリーアレイを16個、 次ページのように配 線する必要がある。

1367

A4-A7 Select 4-to-16-- 012... データ入力 DI DI DI Al-A3 アドレス アドレス ⇒ アドレス 16x8 16x8 16x8 Wr Wr Wr En En En DO DO DO 書き込み イネーブル

データ出力

16個の RAM アレイのうち3個のみが表示されている。これらはデータ入力 を共有している。 16個の RAMアレイのデータ出力の接続は、 出力がトライス テートバッファを使用しているため安全だ。 4ビットのアドレスが2組あること に注目しよう。 A ~ A3 のアドレスビットは、RAM アレイの16個すべてのア ドレスをカバーする。 A 〜Aのアドレスビットは、 4-to-16 デコーダーのセレ クト入力となる。 これは16個の RAM アレイのうち、 どのアレイに書き込み信 号を与え、 どのアレイにイネーブル信号を与えるかを制御するために使用され る。

メモリーの総容量が16倍になったので、 256バイトを記憶できることになり、 この回路を次のようなラベルの付いた別の箱に入れることができる。

368

第19章 メモリーの組み立て データ入力 書き込み イネーブル DI アドレス Addr 256 x 8 RAM EN DO データ出力

アドレスが8ビット幅になったことに注目してほしい。 256 バイトを格納す るRAMアレイは、 256個の私書箱がある郵便局のようなものだ。 それぞれの 箱の中に別々の1バイトの値が入っている (迷惑メールよりマシかもしれない し、そうでないかもしれない)。

再度やってみよう! この256 × 8のRAM アレイを16個使い、 さらに 4-to16のデコーダーを使って、 加えて4つのアドレスビットで選択することにしよ う。 メモリー容量は16倍になり、 合計 4096 バイトになる。 その結果を以下に 示す。

データ入力

DI

書き込み イネーブル

アドレス Addr

W

4096 x 8 RAM 1090 DO

0001

EN

データ出力

アドレスは 12ビット幅になった。 では、もう一度やろう。 この4096 x8のRAM アレイ16個と、 4-to-16 の デコーダーがもう1個必要となる。 アドレスは16ビット幅となり、メモリー容 量は 65,536 バイトになった。

370

データ入力 書き込み イネーブル DI W アドレス16 Addr 65,536 × 8 RAM EN DO データ出力

このまま続けることもできるが、 とりあえずここでやめておこう。 RAM アレイが記憶する値の数は、アドレスビットの数に直接関係しているこ とに気づいただろうか? アドレス入力がない場合には、1つの値しか保存できな い。 4アドレスビットでは16個の値が格納され、 16アドレスビットでは 65,536 個の値が保存できる。 その関係は、 次の式に集約される。

RAM アレイに保存される値の数=2アドレス入力数

65,536 バイトを記憶する RAM は、 64 キロバイト(または64K、 または 64KB) を記憶するともいうが、 初めて見ると不可解に思えるかもしれない。 65,536 バイトが64キロバイトになるのは、 どんな奇妙な算術なのだろう?

2は1024で、一般に1キロバイトと呼ばれる値だ。 キロ (ギリシャ語で 1000 を意味する khilioi から) という接頭辞は、 メートル法で最もよく使われる。 たとえば、 1キログラムは1000グラム、 1キロメートルは1000メートルだ。 しかし、ここで私は、1キロバイトは1000バイトではなく、 1024 バイトだと 言っているのだ。

問題は、 メートル法は10のべき乗、 2進数は2のべき乗を基準としていて 両者が一致することはないということだ。 10のべき乗は、 10, 100, 1000、 10000,100000... となる。 2 のべき乗は、2、4、8、16、32、 64、... となる。 10の整数乗が2の整数乗に等しくなることはない。

しかし時々それらは近づく。 そう、 1000は1024にかなり近い。 「ほぼ等しい」 という記号を使って、 より数学的に表現すれば、次のようになる。

第19章 メモリーの組み立て

210 = 10³

この関係性には何も神秘的なものはない。 特定の2のべき乗が特定の10のベ きに近似することだけを示している。 このちょっとした特性のおかげで、 1024バイトを便宜上キロバイトと呼んでいる。

64K の RAM アレイは 64,000 バイトを保存してはいない。 それは 64,000 以 上で、 実際は 65,536 バイトだ。 何について話しているかがわかるように、 「64K [ケイ]｣、 ｢64キロバイト」、 「6万5千5百36」 のいずれかの言い方を採用する。 アドレスビットが増えるごとに、 メモリー量が2倍になる。 次の各行は、そ の2倍になる様子を示す。

1キロバイト=1024バイト=21バイト=103バイト 2キロバイト=2,048 バイト=2"バイト 4キロバイト=4,096 バイト=212バイト 8キロバイト = 8,192 バイト = 213 バイト 16キロバイト=16,384 バイト= 214 バイト 32キロバイト=32,768 バイト= 255 バイト 64キロバイト=65,536バイト=2バイト 128キロバイト=131,072バイト=2" バイト 256キロバイト= 262,144バイト = 28 バイト 512キロバイト=524,288 バイト = 21 バイト 1,024 キロバイト= 1,048,576 バイト= 22 バイト10°バイト

なお、 左端のキロバイトの数字も2のべき乗であることに注意しよう。 1024バイトを1キロバイトと呼ぶのと同じ理屈で、 1024キロバイトを1メ ガバイトと呼ぶこともできる(ギリシャ語の megas は 「偉大な」を意味する)。 メガバイトは MB と略される。 そして、 メモリーの倍増は続く。

1371

1メガバイト= 1,048,576 バイト = 220 バイト 10° バイト 2メガバイト=2,097,152 バイト=22 バイト 4 メガバイト=4,194,304 バイト = 22 バイト 8 メガバイト= 8,388,608 バイト = 223 バイト 16メガバイト= 16,777,216 バイト = 224 バイト 32メガバイト=33,554,432バイト=225 バイト 64 メガバイト= 67,108,864 バイト = 226 バイト 128 メガバイト=134,217,728 バイト= 227 バイト 256メガバイト=268,435,456 バイト= 228 バイト 512 メガバイト=536,870,912 バイト= 229 バイト 1,024 メガバイト=1,073,741,824 バイト = 230 バイト 10°バイト

ギリシャ語の gigas は巨人を意味するので、 1024 メガバイトは1ギガバイト と呼ばれ、 これは GB と略される。

同様に、 テラバイト (teras は怪物を意味する)は2バイト (おおよそ 10'2) つまり 1,099,511,627,776 バイトに等しい。 テラバイトはTBと略され る。

キロバイトは約1000バイト メガバイトは約100万バイト、 ギガバイトは 約10億バイト、 テラバイトは約1兆バイトだ。

ほとんど訪れることのない領域へと上ってみると、1ペタバイトは 25 バイト、 つまり 1,125,899,906,842,624バイトで、 これは約 10 つまり 1000兆に相当 する。 1エクサバイトは2% バイトに相当し、 1,152,921,504,606,846,976 バイ ト、 約 10 つまり 100京に相当する。

少し基礎知識を提供するなら、 本書の初版が書かれた 1999年当時に売られて いたデスクトップコンピュータは、 通常は 32MB か 64MB のランダムアクセス メモリー(RAM) を持っていた。 時折 128MB のものも見られた。 本書の第2 版が書かれている現在 (2021年) では、 デスクトップコンピュータは通常 4GB 8GB 16GB の RAM を持っている (間違えないでほしいのだが、 電源 が切られたときに保存されるストレージ、つまりハードドライブやソリッドス テートドライブ [SSD] についてはまだ何も触れていない。 ここでは RAMにつ いてのみ話している。

372

第19章 メモリーの組み立て 373

もちろん、 人は省略形で話す。 65,536 バイトのメモリーを持っている人は、 「私のメモリーは64 キロだ (そして私は1980年からの訪問者だ)」と言う。 33,554,432 バイトを持っている人は、 「私のメモリーは32メガだ」 と言う。 そ して 8,589,934,592 バイトのメモリーを持っている人は、 「私のメモリーは8ギ ガだ」 と言うのだ。

時々、 キロビットやメガビット (バイトではなくビットであることに注意)に ついて話す人もいるが、これはメモリーについて語るときには稀だ。 メモリーに ついて語るときには、ほとんどの場合、 ビット数ではなくバイト数を指す。 一般 に、キロビットやメガビットが話題になるのは、 電線や空気を通じてデータが送 信されるときである。 通常は「ブロードバンド」 と呼ばれる高速インターネット 接続に関連しての表記で、 「キロビット/秒」 や 「メガビット/秒」 などのフレー ズが出てくる。

これで、(少なくとも頭の中では) 好きなアレイサイズでRAM を構築する方 法がわかったと思うが、私は65,536 バイト (64KB) のメモリーで止めておい た。

なぜ64KB なのか? なぜ32KB や 128KB ではないのか? それは 65,536 とい う数がきれいなキリのよい数だからだ。 つまり、 2 である。 この RAMアレイ のアドレスは 16ビットで、2バイトちょうどだ。 16進数では、 アドレスは 0000h から FFFFh までの範囲になる。

先に述べたように、1980年頃に購入したパソコンでは64KB が一般的なメモ リー容量だったが、 ここで紹介したようなものではなかった。 フリップフロップ ダイナミック スタティック から構成されたメモリーは、より正確には静的 RAM (SRAM) と呼ばれる。 そ れが1980年までには、 動的 RAM、 または DRAM が主流となり、やがて主要 な地位を占めるようになった。 DRAMは、各メモリーセルに対して1つのトラ ンジスタと1つのコンデンサのみを必要とする。 コンデンサは、電子機器で使 用される部品であり、 2つの分離した電気導体を含む。 コンデンサは電荷を蓄積 できるが、それは無期限ではない。 DRAMを機能させる鍵は、これらの電荷が

毎秒何千回もリフレッシュされるということだ。

静的 RAMと動的 RAM はいずれも揮発性メモリーと呼ばれる。 データを保 持するためには、 常に電源が必要だ。 電源が切れると、揮発性メモリーは一度覚 えたすべてのことを忘れてしまう。

この64KBのメモリーを管理し、 メモリーに値を書き込んだり、 調べたりで きるコントロールパネルがあると便利だ。 そのようなコントロールパネルには、 アドレスを示す 16個のスイッチ、 メモリーに書き込む8ビット値を定義する 8 個のスイッチ、 書き込み信号そのものを示す1つのスイッチ、そして特定の8 ビット値を表示する8個の電球が装備される。

64-KB RAM Control Panel 0 A15 A14 A13 A12 A11 Aio Ag Ag A7 A6 As A4 A3 A₂ A₁ Ao 1 D7 D6 Ds 1 1 Do 0 Write Takeover 書き込み] [テイクオーバー] [

すべてのスイッチはオフ (0) の位置にある。 また、 「テイクオーバー [独占制 「御]」のスイッチも用意した。 このスイッチの目的は、 コントロールパネルが接 続されているメモリーを、ほかの回路が使用できるようにすることだ。 スイッチ が0に設定されているとき (図の通りの場合)、 コントロールパネルのほかのス イッチは何も行わない。 しかし、 「テイクオーバー」スイッチが1に設定される と、コントロールパネルはメモリーを独占的に制御する。

このテイクオーバースイッチの実装は、たくさんの2-to-1 セレクターを使っ て行われる。 本章に登場した大きなデコーダーやセレクターに比べれば、 非常に 単純だ。

セレクト B

374

第19章 メモリーの組み立て

セレクト信号が0のとき, OR ゲートの出力は入力Aと同じになる。 そして セレクト信号が1のとき、 入力Bが選択される。

この2-to-1 セレクターは、 アドレス信号用に16個、 データ入力スイッチ用に 8個、さらに書き込みスイッチとイネーブル信号用に2個、 合計 26個が必要と なる。 回路は次のようになる。

コントロールパネル 電球 アドレス データ 書き込み イネーブル アドレス データ 書き込み テイクオーバー 26個の2-to1 セレクター セレクト 出力 Addr DI W En 64K x 8 RAM DO データ出力

テイクオーバースイッチが開いている (オフの)場合、 64K×8 の RAM ア レイへのアドレス、データ入力、 書き込み、 イネーブル入力は、2-to-1 セレク ターの左上に表示される外部信号からやってくる。 テイクオーバースイッチが閉 じている (オンの) 場合、 RAM アレイへのアドレス、データ入力、書き込み信 号は制御パネルのスイッチからきて、イネーブルは1に設定される。 いずれの 場合も、RAM アレイからのデータ出力信号はコントロールパネルの8つの電球 に戻り、場合によってはほかの場所にも送られる。

375

テイクオーバースイッチが閉じているとき、 16個のアドレススイッチを使っ て 65,536個のアドレスの中から任意のアドレスを選択できる。 電球はそのアド レスに現在格納されている8ビット値を表示する。 8つのデータスイッチを使っ て新しい値を定義し、 書き込みスイッチを使ってその値をメモリーに書き込むこ とができる。

64K × 8 RAM アレイとコントロールパネルを使うことで、 65,536 個の 8 ビット値を手元で扱うことができる。 しかし、ほかの何か (おそらく他の回路) がメモリーに保存されている値を使用したり、 ほかの値を書き込んだりする機会 も残されている。

このシナリオがあり得ないと思う人は、 有名な 『Popular Electronics [ポピュ ラー・エレクトロニクス] 』 1975年1月号の表紙を見てみよう。 この号の特集は、 史上初のホームコンピュータ、 Altair8800 [アルテア 8800] である。

HOW TO "READ" FM TUNER SPECIFICATIONS Popular Electronics

• WORLD'S LARGEST SELLING ELECTRONICS MAGAZINE JANUARY 1975/756

PROJECT BREAKTHROUGH!

World's First Minicomputer Kit to Rival Commercial Models... "ALTAIR8800" SAVE OVER $1000

ALTAIR8800

ALSO IN THIS ISSUE:

An Under-$90 Scientific Calculator Project ●CCD's-TV Camera Tube Successor ? Thyristor-Controlled Photoflashers

TEST REPORTS:

Retro AdArchives/Alamy Stock Photo

Technics 200 Speaker System Pioneer RT-1011 Open-Reel Recorder Tram Diamond-40 CB AM Transceiver Edmund Scientific "Kirlian" Photo Kit Hewlett-Packard 5381 Frequency Counter

BOO

376

第19章 メモリーの組み立て 377

このコンピュータの前面はスイッチとライトだけが置かれたコントロールパネ ルで、 下部にあるスイッチの長い列を数えると、 それが16個であることがわか る。

偶然の一致?もちろん、 そんなことはない。



第20章 計算の自動化

私たち人類は驚くほど創造的で勤勉である一方、極度に怠け者だ。 人が働くこ とを好まないことは明白である。 この働きたくないという極端な感情と、鋭い創 造性が合わさると、ほんの数分だけ労働時間を削減できる巧妙な装置の設計と製 造に大量の時間を投入しても惜しくなくなる。 自ら作り上げた新しい装置が芝生 を刈る様子をハンモックに揺られながら眺めるという想像ほど、 人間の快楽中枢 をくすぐるものはないだろう。

残念ながら、 本章では自動芝刈り機の設計図は紹介しない。 代わりに、加算と 減算を自動化し、より高度な機械へと進化できる一連の設計について説明する。 これが大したことに聞こえないのはわかる。 だが、 この機械は徐々にその用途を 広げ、 加算と減算、 そしてブーリアン論理を使用したほぼすべての問題を解決で きるようになる。 そして、そこには多くの課題があるのだ。

もちろん、高度な技術は複雑さを伴うため、理解が難しい個所もあるかもしれ ない。 苦痛を伴う詳細な説明を読み飛ばしても問題ない。 時折、 頭に来て、 二度 電子的な助けを求めずに数学の問題を解こうと誓うかもしれない。 だが、ぜひ ついてきてほしい。 最終的には、私たちが本当の意味でコンピュータと呼べる機 を発明することになるのだから。

第17章で紹介した加算器には、一連の8つのスイッチに入力された数値の累 計を保持する 8ビットエッジトリガー型ラッチが使われていた。

8つのスイッチ

CI 8ビット加算器 Sum D 8ビットラッチ Clk - Add [加算 Q

8つの電球

ご記憶の通り、8ビットラッチはフリップフロップを使用して8ビットの値を 保存する。 はじめは、ラッチの内容はすべて0で、 出力も同様に0である。 ス イッチを使用して最初の数値を入力する。 加算器は単純にこの数値をラッチの内 容 (0) に加えるので、 結果は入力した数値と同じになる。 Add スイッチを閉じ ると、 その数値がラッチに保存され、 それを表示するためにいくつかの電球が点 灯する。 エッジトリガー型ラッチなので、 Add スイッチを開いて再度閉じるま で、新しい値は保存されない。

次に2番目の数値をスイッチで設定する。 加算器はこの数値をラッチに保存 されていた数値に加える。 再度 Add スイッチを閉じると、 合計がラッチに保存 され、 電球に表示される。 この方法で、 一連の数値を加算し、 累計を表示できる。 そもそもの制限として、8つの電球では、 255を超える合計値は表示できない。

数値を累積するために使用されるラッチは、 しばしばアキュムレータと呼ばれ る。 しかし、あとで説明するように、 アキュムレータは単純に累積を行うだけで はない。 アキュムレータは通常、1つの数値を算術的または論理的に別の数値と 組み合わせた結果を保持するラッチなのだ。

380 |

第20章 計算の自動化

381

先に示した加算器には、明らかに大きな問題がある。 たとえば、 100 バイトの リストを合計したいとする。 加算器に向かって地道にそれぞれの数値を入力し、 合計を累積していく。 だが、その作業が終わったとき、リスト上の数値がいくつ か間違っていたことに気づく。そうなれば、すべての作業を再度行わなければな らなくなる。

しかし、解決策があるかもしれない。 前章では、 フリップフロップを使用して 64KBのメモリーを含む RAMアレイを構築する方法を紹介した。 スイッチや 電球が並べられたコントロールパネルも説明した。

64-KB RAM Control Panel C Ais A14 A13 A12 A11 Aro Ag Ag A7 A6 As A4 A3 A2 A1 Ao D, D6 DS D4 D D2 D₁ Do 1 Write Takeover 書き込み] [テイクオーバー]

「テイクオーバー」 とラベル付けされたスイッチをオンにすると、文字通りこ のRAM アレイの書き込みと読み取りをすべて引き継ぐことができる。

YAMA

382

コントロールパネル 電球 アドレス データ書き込み イネーブル アドレス データ 書き込み テイクオーバー 26個の2-to1 セレクター セレクト 出力 + Addr DI W En 64K x 8 RAM DO データ出力

もし、100バイトすべてを加算器に直接入力するのではなく、 この RAM ア レイに入力していたなら、 値のチェックと多少の修正はずっと容易だっただろ う。

本書の今後の図を簡略化するため、 64K × 8 RAMアレイは、 読み書きを引 き継ぐために必要なコントロールパネルや 26個のセレクターを伴わずに、 単体 で示すことにする。

第20章 計算の自動化 383

データ入力 書き込み イネーブル DI W アドレス16 Addr 65,536 x 8RAM EN DO データ出力

コントロールパネルのようなもの、つまり人間がメモリーアレイにバイトを書 き込み、それを読み出せるようにする「何か」の存在は、この単純な図に示唆さ れている。 時々イネーブル信号も省略することがある。 この信号が図示されてい ない場合は、 データ出力用のトライステートバッファが有効になっていると考え てよい。

たとえば、 16進数で35h、 1Bh、 09h、 31h、 1Eh、 12h、 23h OCh という 8 バイトを加算したいとする。 WindowsやMac の計算アプリを 「プログラマー 「モード」 で使うと、 それらの和がE9h であることはわかる。 だがここでは、 こ れらの数値を足してくれるハードウエアを作ることに挑戦してみよう。

コントロールパネルを使えば、この8バイトをアドレス 0000h から始まる RAM アレイに入力できる。 入力が終わったら、RAM アレイの内容は次ページ のように図式化できる。 MAR

384

0000h:35h |1Bh 09h |31h| |1Eh |12h |23h [0Ch 0008h: 00h ここに合計値が入る

これからはこのような形でメモリーの一部を示そう。 各ボックスはメモリーの 内容、つまり各バイトを表している。 そのボックスのアドレスが左側にある。 す べてのアドレスを示す必要はない。 なぜならアドレスは順番に並んでおり、特定 のボックスに適用されるアドレスを把握できるからだ。 右側にはメモリーについ てのコメントがある。 この図のコメントは、 「最初の8バイトを加算して、その 合計値をバイト 00h を持つ最初のメモリー位置に書き込みたい」 という意思を 示唆している。 この図では、 アドレス 0008hの場所だ。

もちろん、8つの数値の保存だけとは限らない。 もし 100個の数値があれば、 それらの数値をアドレス 0000h から 0063h に保存することになる。 こうして私 たちは、このRAM アレイと第17章の累積加算器 (次ページの図) を接続する という課題に直面することになる。

第20章 計算の自動化

8つのスイッチ CI 8ビット加算器 Sum D 8ビットラッチ Clk Add [加算] Q 8つの電球

メモリーアレイに接続されたコントロールパネルにスイッチや電球が並んでい るので、 別途スイッチや電球を用意する必要はない。 私たちは加算器へのスイッ チ入力を RAM アレイからのデータ出力信号 (DO) に置き換えることができる。 また、ラッチからの出力で電球を点灯させる代わりに、 その出力をRAMのデー タ入力 (DI) に送り込むことができる。

385

Addr 64K x 8 RAM DO DI Write 8ビット加算器 Sum D B 8ビットラッチ CIk <

もちろん、この図にはいくつか欠けた部分がある。 累積された合計値を格納す るために大切なラッチのクロック信号 (Clk) に何が接続されているかが示され ていない。 また、 最終結果を格納するために大切な RAM の書き込み信号 (Write) に何が接続されているかも示されていない。 また、 RAM の内容にアク セスするために必要な16ビットのアドレス (Addr) も欠けている。

そのRAMへのアドレス入力は、 0000h から始まり、 その後は0001h. 0002h0003 と順番に増えていく必要がある。 これは、 第17章の310ページ で見たような、フリップフロップの列からなるカウンターの役割だ。

386

第20章 計算の自動化

16ビットカウンター CIk < Output

カウンター出力からのデータパスは、8ビットではなく16ビットを表現するた めに、 少し幅広くなっていることに注意しよう。 このカウンターが RAMのアドレス入力を提供する。

Addr DO 64K x 8 RAM DI Write 16ビットカウンター Clk Output 8ビット加算器 Sum D 8ビットラッチ Clk Q

387

この機械を私は「自動累積加算器」と呼んでいる。

もちろん、RAMのアドレスを提供するカウンターを追加したことで、カウン ターの値を増加させるための別のクロック信号も必要になった。 しかし、私たち はまだ作業の途中である。 主な8ビットと16ビットのデータパスはすべて定義 されている。 今必要なのは次の3つの信号だけだ。

●カウンターへのクロック (Clk) 入力

●ラッチへのクロック (Clk) 入力

・RAM への書き込み (Write) 入力

このような信号はしばしば制御信号と総称され、 回路の中で最も複雑な部分に なる。これら3つの信号は協調し、 同期する必要がある。

カウンターへのクロック入力は、カウンター出力を次のアドレス、つまり 0000h から 0001h、 次に 0001h から 0002h、 というように増加させる。 そのア ドレスは特定のメモリーのバイトにアクセスし、 それがラッチの出力とともに加 算器に入る。次に、 ラッチのクロック入力は、その新しい合計値を格納しなけれ ばならない。 実際には、 メモリーアクセスと加算には少し時間がかかる。 これ は、ラッチのクロック入力はカウンターのクロック信号の少しあとに発生しなけ ればならないことを意味する。 同様に、 その次のカウンターのクロック信号は、 ラッチのクロック信号の少しあとに発生しなければならない。

これを実現するために、 2つのフリップフロップを次ページのように配線して みよう。

388

第20章 計算の自動化

オシレーター Clk Clk フリップフロップ1 フリップフロップ2

カウンターのクロック入力 (Clk)

パルス

左端のオシレーターは、0と1を交互に繰り返すだけだ。 時計やコンピュータ に使われる水晶オシレーターのように非常に高速なものから、指で押すスイッチ やボタンのような単純なものまで、いろいろな種類がある。

フリップフロップ1は、 第17章の終盤で見たように、 与えられた周波数を半 分にする (分周する) ように配線されている。 このフリップフロップの出力Q がカウンターのクロック入力 (Clk) となり、 0から1へ遷移するごとにカウン ターの値がインクリメントされる。 フリップフロップ1のタイミングチャート を以下に示す。

フリップフロップ Clk フリップフロップ 1D フリップフロップ 1Q カウンターの出力 0000h 0001h 0002h

タイミングチャートの最下段は、カウンターの出力がどのように変化するかを示 している。 け

フリップフロップ2のクロック入力はフリップフロップ1と逆で、入力Dは フリップフロップ1の出力Qであり、フリップフロップ2の出力 Qはフリップ

389

フロップ1の出力 Qから1周期分ずれることになる。 比較のために、 次の図に は、前の図のカウンター出力が含まれている。

カウンター出力 0000h 0001h 0002h X フリップフロップ2 Clk フリップフロップ2D フリップフロップ2Q バルス

AND ゲートは、フリップフロップ1からの出力Qとフリップフロップ2か らの出力 Q を合わせる。 このAND ゲートからの出力をパルスと呼ぶことにし よう。

このパルス信号がラッチのクロック入力となる。

フリップフロップからのパルス信号 D 8ビットラッチ Clk < Q

カウンターからの値がメモリーのアドレスを指定し、 メモリーからのデータが 以前の合計値に加算されてラッチに保存されるまで、 十分な時間があるようにし たい。 この目的は、 ラッチが新しい合計値を保存しようとする前に、すべてが安 定しているようにすることだ。 つまり、不具合は避けたい。 現時点で、パルス信 号が1のとき、 カウンター出力が一定に保たれていることは実現できている。

自動累積加算器に必要なもう1つの信号は、 メモリーの書き込み信号である。 先ほど、「合計値をバイト 00hを持つ最初のメモリー位置に書き込みたい」と書

390

第20章 計算の自動化 391

いた。 そのメモリー位置は、RAM からのデータ出力信号を取り込んで8ビット NOR ゲートに入力することで検出できる。 このNOR ゲートの出力は、 個々の データ出力値がすべて0の場合に1となる。 その出力は、 フリップフロップか らのパルス出力と組み合わせることができる。

フリップフロップからのパルス信号

RAMからのデータ出力

RAMへの書き込み

自動累積加算器のこの回路のインタラクティブ版は、ウェブサイト (www. Code Hidden Language.com) で見ることができる。

自動累積加算器が永遠に続くのを止める仕組みはまだない。 オシレーターが 0と1の信号を交互に生成し続ける限り、 カウンターはメモリーにアクセスし続 ける。 メモリーのほかのバイトが00hに等しい場合、 回路は求めた合計値をそ れらの位置に書き込んでいく。

オシレーターが動き続けると、 最終的にカウンターはFFFFhに達し、それか ら値が0000h に戻って累積加算を再開する。 しかし、 今回は、 すでに計算され た合計値にメモリー内のすべての値を加えていくことになる。

このプロセスをコントロールするためには、 「クリア」というラベルの付いた ボタンやスイッチを追加しよう。メモリーアドレスを提供するカウンターは、 エッジトリガー型フリップフロップで構築されているので、おそらくクリア入力 があると思われる。 ラッチもエッジトリガー型フリップフロップで構成されてお り、制御信号の生成にはエッジトリガー型フリップフロップのペアが使用されて いる。 このクリアボタンは、カウンターとラッチをクリアし、2つのフリップフ ロップの動作を止めることができる。 そして、 新しい値をメモリーに入力し、再 び加算作業を始めることができるのだ。

自動累積加算器の最大の問題は、単なるバイトの加算に限定されていること

だ。 バイトの値は 00 から FFhまで、 つまり 10進数で255までしかない。

この自動累積加算器の動作例として示した計算は、 35h、 1Bh、 09h、 31h、 1E 12h、 23h 0Chの8バイトを加算するもので、 合計するとE9、 つまり 10進数で233になるものだった。 しかし、 仮に9バイト目の20h があったとし よう。 そのとき、合計値は 109h になったはずだ。 しかし、それはもはやバイ トの値ではない。 8ビット加算器の出力は単に 09h となり、 それがメモリーに 保存されることになる。 加算器のキャリーアウト信号は、合計が FFh を超えた ことを示すはずだが、 自動累積加算器はその信号に対して何もしていない。

当座預金の入金を確認するために、 自動累積加算器を使うとする。 米国では、 お金はドルとセントで計算される。 たとえば、 1.25 ドル (1ドル25セント)の ような表記が使われる。 ほかの多くの国々も同様だ。 その値をバイトに格納する には、100を掛けて完全な整数、 すなわち 125セントに変換する必要がある。 これは16進数で7Dh だ。

つまり、バイトで金額を保存しようとすると、 FFh、 10進数で255、つまり わずか2.55 ドルまでの値に制限されてしまう。

より大きな金額のためには、 より多くのバイトを使用する必要がある。 2バイ トならどうだろう? 2バイトの値は0000h から FFFFh まで、 または10進数で 65,535 つまり655.35 ドルまでの値を扱える。

ずいぶんマシだ。 しかし、 正の金額と同様に、 負の金額も表現したいはずだ。 たとえば、 当座預金口座でお金を引き出しすぎてマイナスになったときである。 それは、第16章で議論した2の補数を使用することを意味する。 2の補数を用 いると、 最大の正の16ビット値は 7FFFh、 すなわち10進数で 32,767 最小 の負の値は8000h で、 これは 32,768 だ。 これにより、 -327.68 ドルから 327.67 ドルまでの金額を表せる。

3バイトで試してみよう。 2の補数を使用すると、 3バイトの値は800000h か ら7FFFFFhまで、 または10進数で- 8,388,608 から 8,388,607 まで、 つまり 金額でいうと- 83,886.08 ドルから83,886.07 ドルまでの範囲になる。 ほとん どの人の当座預金口座にとってかなり安全な範囲だと思えるので、これを採用し よう。

自動加算器を使って、 1バイトの値ではなく、 3バイトの値を加算するように するには、どのように拡張すればよいだろう?

392

第20章 計算の自動化 393

簡単なのは、 24ビットの値を格納できるようにメモリーを拡張し、 24ビット の加算器やラッチを作る方法だ。

しかし、それは現実的ではないかもしれない。 すでに64K × 8 のRAM アレ イを作成するための投資をしていたり、すでに8ビットの加算器を持っていて 簡単には取り替えられないかもしれない。

8ビットのメモリーにこだわるとすれば、 24ビットの値は3つの連続するメ モリー位置に分割して保存できる。 しかし、 重要な疑問は、 「それをどの方向に 保存するか?」 だ。

これは何を意味するのだろう?

たとえば、 10,000.00 ドルの値を保存したいとする。 これは1,000,000 セン ト または 16進数ではOF4240h であり、 3 バイトの0Fh、 42h、 40h に該当す る。これらの3バイトは、 「ハイ」 バイト、 「ミドル」 バイト、 「ロー」 バイトと 呼ぶことができる。 これらをメモリーに保存するには、 2通りの方法がある。 3 バイトをどの順番で格納するのかだ。 以下の順番で格納すればよいのか?

0000h: OFh ハイバイト 142h ミドルバイト |40h ローバイト

それとも次の順番で格納するのか?

0000h: 40h ローバイト |42h ミドルバイト | OFh ハイバイト

次のように尋ねる人がいるかもしれない。 「どのように格納するのが一般的な の?」とか、「昔からある業界標準は?」 とか、 である。 しかし、残念ながら、 それらの問いへの答えは 「両方」 だ。一部のコンピュータは一方の方法で、それ 以外のコンピュータはもう一方の方法でバイトを格納する。

これらのマルチバイト値を保存する2つの手法は、 ビッグエンディアンとリ トルエンディアンという名前で知られている。 第13章のUnicode についての 議論の際に、この差異について触れた。 この用語は、ジョナサン・スウィフトの 風刺小説 『ガリバー旅行記』 に由来する。 そこでは第1部第4章以降に登場す リリパットの人々が、卵を小さい方 (リトルエンド) から割るか大きい方 (ビッグエンド) から割るかという長い論争に巻き込まれている様子が描かれて いる。 コンピュータ業界では、 それは大きな論争というよりは、みなが共存する ために学び取った基本的な違いとなっている。

一見すると、 ビッグエンディアン方式は通常バイトを書き記す順序と同じであ り、感覚的に理解しやすいように見えるかもしれない。 一方、 リトルエンディア ン方式は最下位のバイトから始まるため、 反転しているように見える。

しかし、メモリーから複数バイトの値を読み出して足し算をする場合、おそら く最下位バイトから始めたいはずだ。 最下位バイトの加算でキャリーが発生し、 次の上位バイトの加算に使用されるかもしれないからである。

この理由から、ここではバイトをリトルエンディアン形式、 すなわち最下位バ イトからメモリーに格納することにする。 だが、 これはメモリーに保存する順序 にのみ適用する。 16進数の値をほかの形式で示す際には、引き続き最上位バイ トを先に表示する。

この新しい機械の動作を説明するときには、銀行口座の残高を計算するよう に、 「入金」と「出金」 という言葉を使うことにしよう。 とはいえ、 中小企業を 経営する際の経費と売上、 あるいは資産と負債を使っても同じように当てはめる ことができる。

まず、 450.00ドルと350.00ドルの2つの入金から始めよう。 16進数では、 これらは次のように加算される。

00 AF C8 + 00 88 B8 01 38 80

右から順にバイトのペアを加算していくと、 次のバイトのペアに影響を与える キャリーが生まれる。

394

第20章 計算の自動化 395

では、今度は合計から500.00 ドル (16進数で00C350h) を出金してみよう。

01 38 80 -00 C3 50

第16章では、2進数の引き算を説明した。 まず減算したい数値を2の補数に 変換してから加算する。 00C350hの2の補数を求めるには、 すべてのビットを 反転させて (0ビットを1に、1ビットを0に) FF3CAFh とし、 1を足して FF3CB0h とする。 今度はそれを加えよう.

01 38 80 + FF 3C BO 00 75 30

10進数では、その合計は30,000、 つまり300ドルだ。 では、 もう1度500 ドルの出金をしてみよう。

00 75 30 + FF 3C BO FF B1 E0

結果は負の数となる。 残高がゼロを割ってしまった! その負の値を求めるに は、再びすべてのビットを反転させて 004E1Fh とし、 1を加えて004E20h、つ まり 10進数で20,000 とする。 残高は200.00ドルだ。 幸いなことに、 さらにお金が入ってくることになった。 今回の入金はなんと 2000.00 ドル つまり 030D40hだ。 それを前の負の残高に加えよう。

FF B1 E0 + 03 OD 40 02 BF 20

うれしいことに、 結果は10進数で180,000、 つまり180000ドルとなる。 この新しい機械には、 次のような仕事をさせるとしよう。 メモリーに格納され ている3バイトの値を加算あるいは減算し、 その結果をメモリーに書き戻す処 理だ。

私としては、機械に引き算をしてほしい。 500 ドルの出金額を2の補数では なく3バイトの 00h、C3h50h として保存したい。 2の補数の計算は機械に やってもらいたいのだ。

しかし、すべての数値が正の値としてメモリーに保存されているなら、入金と 出金は同じに見える。 それらをどのように区別すればよいだろうか?

メモリー内の数値をどう扱いたいかを特定するためには、 数値に伴う「何か」 が必要だ。 この問題を考えた結果、 たとえば一晩考えてみて、 メモリー内の各数 値の前に何らかのコードを付けるという素晴らしいアイデアが浮かぶかもしれな い。 あるコードは「次の3バイトの値を加算する」 という意味を表し、 別のコー ドは「次の3バイトの値を減算する」 という意味を表す、 といった具合だ。 で は、先ほど説明した例題が、この方法を採用したときにメモリー上でどのように 表現されるかを示そう。

396

第20章 計算の自動化

0000h: 02h| 4 次の値を加算するコード

C8h

00AFC8hまたは $450.00

AFh

|00h

0004h: 02h 次の値を加算するコード

B8h

88h

100h

0088B8h または $350.00

0008h:03h

次の値を減算するコード

|50h

|C3h

00C350 または $500.00

00h

000Ch:03h 次の値を減算するコード

|50h

C3h

|00h

0010h:02h

00C350 または $500.00

140h

次の値を加算するコード

0Dh

|03h

030D40 または S2000.00

ここでは、次の3バイトの値を実行中の合計値に加算することを示すコード として02h を、減算を示すコードとして03h を選んだ。 これらのコードは多少 恣意的に見えるが、 全く恣意的というわけではない (すぐにその意味がわかるは ずだ)。

こうしたコードは、 命令コード、 操作コード、 オペコードと呼ばれることもあ る。それらはメモリーを読み込む機械に対して何をすべきかを命令し、 機械は加 算や減算などの特定の操作を実行することでその命令に応答する。

以上でメモリーの中身は、コードとデータに区別できるようになった。 この例 では、各コードのバイト (コードバイト)は3つのデータバイトに先行してい る。

397

値を加算したり減算したりするためのコードが手に入ったので、 次に、これら の直後のメモリーに現在の合計値を保存する別のコードを考えてみよう。 さら に、何もすることなく動き続けるのを防ぐために、 機械を停止するもう一つ別 のコードも考えよう。

0014h: 04h 計算中の合計値を保存するコード |00h 100h 合計値を保存する場所 200h 0018h:08h停止コード

この不思議な芸当を行う機械を「3バイト累積加算器」 と呼ぶことにしよう。 自動累積加算器と同様に、 これは 64K × 8 メモリーアレイにアクセスし続けて 8ビット加算器を使って累計を蓄積することができる。 しかし、ラッチの数は4 つに増やさなければならない。 1つは命令コードを格納するため、 残りの3つは 累計を格納するためだ。 次ページの図で、 主要なコンポーネントとデータパスを すべてそう。

398

第20計算の自動化

Addr DO DI カウンター 1の補数 D 命令ラッチ 加算器 Q Sum D ハイラッチ Q ミドルラッチ Q ローラッチ Q トライステート トライステート トライステート

RAM

図が過度に煩雑になるのを避けるため、 多数ある制御信号は示していない。 本 章の残りの部分でそれらの制御信号を見ていこう。 また、このすでに複雑な図に は表示されていないものとして、 制御信号が接続されている各ボックスの入力が ある。 たとえば、カウンターやラッチへのクロック入力、 トライステートバッ ファへのイネーブル信号、 RAM の書き込み信号などだ。

自動累積加算器と同様に、 3バイト累積加算器には、ランダムアクセスメモ リーのアドレスを提供する16ビットカウンターがある。 このカウンターのク ロック入力は、先に示したのと同じ構成の2つのフリップフロップから得られる。 3バイト累積加算器は4つのラッチを備えており、 最初のラッチには「命令 ラッチ」 というラベルが付いている。 このラッチはメモリーアドレス 0000h、

399

0004h0008h などからの取り出した命令コードを保持するために使用される。 ほかの3つのラッチには、 「ハイ」、 「ミドル」、 「ロー」 と書かれている。 これ らは、累計中の合計値の3バイトを格納するために使用される。 これら3つの ラッチの入力は、 加算器からのサム (Sum) 出力だ。 ラッチの出力は 「トライ ステート」 と書かれた3つのボックスに入るが、これは前章で説明したトライ ステートバッファだ。 これらのボックスには、 図示されていないがイネーブル信 号が入る。 通常のトライステートバッファと同様に、イネーブル信号が1のと き、出力は入力と同じになる (入力が0のときに出力は0、 入力が1のときに出 力は1になる)。 しかし、 イネーブル信号が0のときは、 出力は0でも1でもな い (電圧でもグランドでもない) 「浮いている」 状態だ。 それが第3の状態(ス テート) なのだ。

3バイト累積加算器にある3つのトライステートバッファは、それぞれ独自の イネーブル信号を持つ。 どの時点でも、これら3つのイネーブル信号のうちの、 1つだけが1に設定される。これにより、3つのトライステートバッファの出力 は、 電圧とグランドが競合することなく、 互いに接続されることになる。 イネー ブル信号は、3つのラッチ出力のうち、 どのラッチ出力をRAM データ入力 (DI)と加算器の入力Bに送るかを制御する。

これら3つのイネーブル信号は、カウンターが生成するメモリーアドレスの 最下位2ビットに依存する。 メモリー内のバイトは、 形式に従って整然と格納 される。 まず命令バイトがあり、 次に3バイトの数値の下位 (ロー)、中位 ( ドル)、 上位 (ハイ) のバイトが格納される。 この4バイトの役割は、 メモリー アドレスの最下位2ビットに対応する。 この2ビットは00から01、10、日へ と繰り返し増加し、 それぞれの値がメモリー内の特定のタイプのバイトに対応す る。

アドレスの下位2ビットが00であれば、そのアドレスのバイトは命令コー ドである。

アドレスの下位2ビットが01の場合、 そのアドレスのバイトは、加減算す る数値の最下位バイト (ローバイト) であることを意味する。 ・同様に、下位2ビットが10であれば、それはミドルバイトである。

・そして下位2ビットが11であれば、それはハイバイトである。

400

第20章 計算の自動化 401

トライステートバッファのための3つのイネーブル信号は、 メモリーアドレ スの最下位2ビット (ここではAとA) から、 2-10-4 デコーダーで生成でき る。

AL Ao フリップフロップからのパルス信号 Bit 1 Bit 0 2-to-4 デコーダー 11 10 01 00 イネーブルローバイト イネーブルミドルバイト イネーブルハイバイト 命令ラッチクロック

この図には、命令ラッチのクロック入力も示した。 このクロックは、 アドレス の下位2ビットが00 で、 デュアルフリップフロップ構成からのパルス信号が1 であるときに発生する。 次の3バイトがアクセスされる間、命令はそのラッチ に留まっている。 ほかの3つのラッチへのクロック信号はもう少し複雑だが、 このあとに紹介する。

それでは、3バイト累積加算器の仕組みを説明しよう。 最初にすべてのラッチ がクリアされ、 何も値を保持していないと仮定する。 まずカウンターは、 RAM アドレス 0000h を出力する。 そのアドレスのバイト (この例では 02h) が、命 令ラッチに格納される。

次にカウンターはRAM アドレス 0001hを出力する。 これは最初の数値の ローバイト (下位バイト) が置かれたメモリーの位置だ。 そのバイトは加算器に 入る (今のところ 「1の補数」 とラベル付けされたボックスは無視してよい。 加 算が行われているとき、 これは何もしないと考えていい)。 アドレスの下位 2 ピットは 01 で、 そのためローバイトのトライステートバッファが選択される。 しかしローバイトラッチはクリアされているため、 加算器の入力 B は 00h だ。 加算器の合計出力は最初の数のローバイトとなる。 その値はローバイトラッチに

格納される。

次にカウンターは RAM アドレス 0002h を出力する。 それは、最初の数値の ミドルバイト (真ん中のバイト) だ。 これは、 ミドルラッチの値 (00h) ととも に加算器に入る。 サムアウトはメモリーから得られたミドルバイトと同じ値にな り、 それをミドルバイトラッチに格納する。

次にカウンターはRAM アドレス 0003h を出力する。 これはハイバイトで、 加算器を経てハイバイトラッチに格納される。

次にカウンターはRAM アドレス 0004h を出力する。 それは、 02h という命 令コードで、 加算を意味する。

次にカウンターはRAM アドレス 0005h を出力する。 これは2番目の数値の ローバイトだ。 これは加算器の入力Aに入る。 ローバイトのトライステート バッファがイネーブル [有効化] される。 ラッチには最初の数値のローバイトが 格納されているので、それが加算器の入力Bとなる。 この入力Aと入力Bの2 バイトが加算され、 ローバイトラッチに格納される。

この作業はミドルバイト、ハイバイトと続き、 さらに次の数値へと進む。 さて、3バイト累積加算器を設計する際に、 次のような4つの命令コードを定 義した。

・02h:次の3バイトの数値を加算する

03h:次の3バイトの数値を減算する

・04h:3 バイトの累計をメモリーに書き込む ・08h 機械を停止させる

命令ラッチに格納するのは4ビットだけでよい。 これらのビットが4つの命 令にどのように対応しているかを次に示す。

402

第20章 計算の自動化

RAMからのデータ出力 D 命令ラッチ Q1 Q2 Q Q 0 0 1 0 = 次の値を加算 0 0 1 1 = 次の値を減算 0 1 0 0 100 0 = 累積した合計値をメモリーに書き込む 機械を停止させる

次の3バイトがこの機械に読み込まれている間、 命令コードは命令ラッチに 留まり続ける。 命令コードのビットは、3バイト累積加算器のほかの部分を制御 するために使用される。

たとえば、次の3バイトが累計に加算または減算される場合、 Q ビットは1 である。 つまり、このビットを使って、 3つのデータバイトのラッチに対するク ロック入力を決めることができる。これらの出力が命令ビット Q, とフリップフ ロップからのパルス信号とどのように組み合わされるかを示すために、 2-to-4 デコーダーを再度示そう。

AL Ao フリップフロップからのパルス信号 命令ラッチからの出力Q Bit 1 Bit 0 2-to-4 デコーダー 11 10 01 00 ・ローバイトラッチクロック ・ミドルバイトラッチクロック ハイバイトラッチクロック

403

先ほど見たように、アドレスの下位2ビットが00 のとき、 命令バイトがラッ チされる。 その命令バイトは、 この2つのアドレスビットが01、10、11 とな るときに、3つのデータバイトをアクセスするために使用できる。 命令が加算 (Add)または減算 (Subtract) の場合、 命令ラッチのQ出力は1になり、こ れら3つのAND ゲートはクロック信号を生成して3バイトを順次取り込む。

加算命令を02h、 減算命令を03h と定義したのはなぜなのか? なぜ01hと 02h ではないのか? あるいは 23h と7chでもよかったのでは? 実は 02hや03h のようにしたのは、 加算と減算の命令コードが、 ラッチのクロック信号を制御す るために使用するビットを共有できるようにするためだ。

命令コードのQ ビットは、続く3バイトの数が減算される場合のみ1になる。 そのとき、その値の2の補数が必要だ。 2の補数は、 まず1の補数を求め、 それ に1を加算することで算出される。 1の補数は、単純にすべてのビットを0から 1、 1から0に反転させたものだ。 これを実現する回路は、 第16章ですでに紹 介した。

インバート 入力 出力

入力は、 RAM のデータ出力から得られる。 出力は8ビット加算器の入力A に送られる。インバート信号は、命令ラッチの出力 Qから直接得られる。これ は、数値が足されるのではなく、 引かれることを示すビットだ。

2の補数は、1の補数に1を加えたものである。 加算器へのキャリーイン (CD) を1に設定することで、1の加算を実行できるが、これは3バイトのうちの最初 のバイトに対してのみとなる。

404

第20章 計算の自動化

A Ao 命令ラッチのQより Bit 1 Bit 0 2-to-4 デコーダー RAMからのデータ出力 Input 11 10 01 00 Inv 1の補数 Output pł A 8ビット加算器 Sum B

トライステートバッファからのキャリー信号

命令ラッチからの最下位ビットが1であるときは、常に減算が行われている ことになる。 RAM から送られてくるデータのバイトはすべて反転させる必要が ある。 それが、 「1の補数」 と書かれたボックスの目的だ。 また、 加算器のキャ リーインは1に設定する必要があるが、 それは1バイト目のみだ。 それがこの AND ゲートの目的だ。 2-to-4 デコーダーの出力01は、 最初のデータバイトに 対してのみとなる。

OR ゲートがあるのは、 2番目と3番目のデータバイトを加算または減算する ときに、加算器へのキャリーインも設定する必要があるからだ。 図をシンプルに するために、キャリーの件はすべて無視してきたが、 勇気を出して直接向き合お う。

3バイト累積加算器は、3つのラッチと3つのトライステートバッファを含み、 3バイトの値の累計を保持する。

405

406

A B CI 加算器 CO Sum D D ハイラッチ Q ミドルラッチ Q ローラッチ トライステート トライステート トライステート

RAM DI

しかし、それだけでは不十分だ。 キャリービットに対応させるために、 これら のラッチのうち2つは9ビットを保存する必要がある。 サム (Sum)の8ビッ トと加算器からのキャリーアウト (CO) だ。 トライステートバッファの2つも また、9ビットを扱うことが求められる。 というのも、ローバイトの加算からの キャリーがミドルバイトの加算で利用され、 ミドルバイトの加算からのキャリー がハイバイトの加算に使用される可能性があるからだ。

第20章 計算の自動化 407

A В CI 加算器 CO Sum D D D ハイラッチ ミドルラッチ ローラッチ Q トライステート トライステート トライステート

RAM DI

加算器からのキャリーアウト信号は、ローバイトとミドルバイトのラッチに格 納されるが、これらの値は、それからミドルバイトとハイバイトのトライステー トバッファに入ることに注意してほしい。 これはとても奇妙に思えるかもしれな い。 なぜそうなのかを説明しよう。

ローバイトが加算されるとき、 加算器のキャリーインは、加算の場合は0、 減 算の場合は1となる(これはOR 論理ゲートへの入力だ)。 その加算の結果、 キャリーが生じるかもしれない。 加算器のキャリーアウトはローバイトのラッチ に保存される。 しかし、 そのキャリービットはミドルバイトを加算するときに使 用されなければならない。 これが、ローラッチ内のキャリービットの値がミドル バイトのトライステートバッファへのもう1つの入力となる理由だ。 同様に、 ミドルバイトの加算から生じるキャリーはハイバイトを加算するときに使用され なければならない。

いよいよ最後の頑張りだ。 ここまでで、 すべての加算と減算が処理されるよう になった。 まだ処理されていないのは、 命令コード 04h だ。 これは3バイトを

メモリーに書き込む命令である。この回路は、命令ラッチに格納されているQ ビットを使用する。

A1 Ao フリップフロップからのパルス信号 命令ラッチのQ2 Bit 1 Bit 0 2-10-4 デコーダー 11 10 01 00 イネーブルローバイト イネーブルミドルバイト イネーブルハイバイト ・RAMへの書き込み

RAMへの書き込み信号は、 RAMアドレスの下位2ビットが3データバイト に対応する01、10、11のときのみ生成される。 それがインバーターの目的だ。 これらのアドレスビット01、10、11のとき、3つの連続したトライステート バッファがイネーブルになる。 Q2 ビットが1 (書き込み命令を示す) で、 フリッ プフロップからのパルス信号が1であれば、 3バイトが連続してメモリーに書き 込まれることになる。

最後の命令は 08h で、 これは停止 (Halt) を意味する。これは簡単だ。 命令 ラッチからのQ, が1になったら、 ずっと動いていたオシレーターの動作を停止 させればよい。

オシレーター

・フリップフロップへのコンフィグ

命令ラッチからのQ」 ビット

408

第20章 計算の自動化 409

また、フリップフロップやカウンター、 ラッチの内容をクリアして、次の累計 を行うための「クリア」 ボタンもあると便利だろう。

3バイト累積加算器のインタラクティブ版は、ウェブサイト (www.Code Hidden Language.com) で見ることができる。

今では、私がなぜ4つの命令コードをあのように定義したかが明らかになっ たはずだ。 回路内でビットを直接使用したかったからだ。 すなわち、 あるビット に加算もしくは減算を示させ、 別のビットには減算を示させ、 また別のビットに 結果をメモリーに書き込むことを示させ、 さらに別のビットに停止を示させた かったのだ。 もし単純に 01h、 02h、 03h, 04h という数値を使用していたなら、 それらの値を別々の信号にデコードする追加の回路が必要だっただろう。

また、各数値の保存に4バイトではなく3バイトを使用することにした理由 も明らかだろう。 これにより、 メモリーアドレスのAとAのビットを使って、 ダイレクトに各種ラッチを制御できるようになった。 もし各数値に対して4バ イトを使用していたら、 命令コードはメモリーアドレス 0000h、 0005h、 000Ah 000Fh 0012h などに保存されることとなり、すべてを正しいラッチ に保存するのがより困難になっただろう。

これで、 本書のタイトルに登場する2つの言葉、ハードウエアとソフトウエ アを定義する準備ができた。 3バイト累積加算器はその違いを明確に示している。 ハードウエアとはすべての回路のことで、ソフトウエアはメモリーに保存された コードとデータだ。 それらが 「ソフト「柔らかい」」 と呼ばれるのは、簡単に変更 できるからだ。数値の1つの入力を間違えたり、 加算と減算のコードを間違え たりしても、簡単に変更できる。 一方、 回路は変更するのがはるかに困難だ。 そ れは、回路がウェブサイト (www.CodeHiddenLanguage.com) のようにシミュ レートされている場合でも、 現実のように電線やトランジスタからなる場合で も、同様に難しい。

それでも、3バイト累積加算器は、ハードウエアとソフトウエアの非常に密接 な関係を示している。 コードと数値はメモリー内のフリップフロップに保存さ れ、これらの値を構成するビットは残りのハードウエアと統合される信号にな る。 最も基本的なレベルでは、 ハードウエアもソフトウエアも、ただの電気信号 が論理ゲートと相互作用しているだけだ。

仮に自分で3バイト累積加算器を作り、それを使って小規模ビジネスの財務

を管理しているとしたら、 ビジネスが予想以上に成功し始めると、不安を感じる かもしれないことは容易に想像できるだろう。 収入や支出が3バイトの容量を 超える場面が容易に想像できる。 なのに、 この機械は簡単には拡張できない。 3 バイトの制限はハードウエアに組み込まれてしまっているからだ。

私たちは3バイト累積加算器の命運がここで尽きることを受け入れなければ ならない。 しかし幸いなことに、 作り上げる過程で得た知識は1つも無駄には ならない。 実際、私たちはとても重要なことを発見できた。

私たちは、機械はメモリー内に保存されたコードに応答して動作するように構 築できるという驚くべき事実を発見した。 3バイト累積加算器は4つのコードし か使っていないが、 命令コードがバイトで保存される場合、 256種類の異なる コードを定義して、 様々な処理が行える。 256種類の異なる処理はかなり単純な ものかもしれないが、 より複雑な処理を仕組むくらいの汎用性はありそうだ。

ここでの鍵は、単純な処理はハードウエアで実装され、 複雑な処理は命令コー ドの組み合わせとしてソフトウエアで実装されるということだ。

もし1970年にそんな汎用的な機械を作ることを決めたなら、 目の前には大仕 事が待っていただろう。 しかし、 1980年になると、そうした機械を作る必要は 一切なくなった! 64KBのメモリーにアクセスし、 256種類近くの異なる命令 コードを解釈できるマイクロプロセッサというチップが購入できたからだ。

1971年11月、 史上初の「チップ型コンピュータ」 が発売された。 それはイ ンテルの製品で、4004 と呼ばれる。 4004 は 2250 個のトランジスタを搭載し、 4KBのメモリーにアクセスできる4ビットプロセッサだった。 1972年半ばま でにインテルは、 16KB のメモリーにアクセスできる最初の8ビットマイクロ プロセッサ 8008 を発表した。

これらのチップは、 キーボードやディスプレイを持つパーソナルコンピュータ を作るのに十分な多機能性とメモリー容量を備えてはいなかった。 主に組み込み システム用に設計されており、ほかのデジタルロジックと協調して何らかの機械 を制御したり、 専用の処理を実行したりするためのものだった。

そして1974年4月、 インテル 8080 が登場した。 これは約4500個のトラン ジスタを持つ8ビットプロセッサで、 64KBのメモリーにアクセスできた。 イ ンテル 8080 は 40ピンのチップにパッケージングされていた。

410

第20章 計算の自動化

インテル 8080 は大舞台に登場する準備ができていた。 最初のホームコン ピュータである Altair 8800 [アルテア 8800] (第19章の最後で示したように Popular Electronics の表紙に掲載された) に使用されたのだ。 さらに 8080 は、 1981年8月に発売された最初の IBM パーソナルコンピュータ (PC) に使用さ れたインテルの16ビットマイクロプロセッサの先駆けになった。

一方、 モトローラもマイクロプロセッサを製造していた。 1974年に発売され たモトローラ 6800 は、 64KB のメモリーにアクセスできる8ビットマイクロプ ロセッサという点ではインテル8080と同じだった。 1975年には、この6800 の簡略版が MOS テクノロジーからリリースされ、 MOS 6502 と名づけられた。 これが、1950年生まれのスティーブ・ウォズニアックが Apple II コンピュータ に使ったチップだ。 Apple II は 1977年6月に発売された。

インテル 8080 とモトローラ 6800はいくつかの面で似ていた。 どちらも 64KBのメモリーにアクセスでき、 40 ピンのチップにパッケージされた8ビッ トのマイクロプロセッサだった。 しかし、 彼らが実装した命令コードは全く異 なっていた。 さらにもう1つ、 基本的な仕組みが異なっていた。 本章の前半で、 マルチバイトの数値の格納方法として、 ビッグエンディアンとリトルエンディア ンを説明した。

モトローラ 6800 は最上位バイトを先に格納するビッグエンディアン方式で、イ インテル8080 は最下位バイトを先に格納するリトルエンディアン方式だったのだ。 次章からは、論理ゲート、 フリップフロップ、 加算器、 ラッチ、 トライステー トバッファなど、 すでに紹介した基本部品だけを使用して、 インテル 8080 の構 築に挑戦する。

しかし、この野心的なプロジェクトは完成しない。 私のバージョンのインテル 8080 は、 本物ほどパワフルにはならない。 それでも説明を終える頃には、読者 はコンピュータの内部で何が起こっているのかを深く理解するだろう。

411



第21章

算術論理演算装置 (ALU)

現代のコンピュータは無数の部品が複雑に組み合わさっており、 それらの部品 は大きく分けて3つに分類できる。

・メモリー ・中央演算処理装置 (CPU) ・入出力 (I/O) デバイス (周辺

機器とよく呼ばれる)

第19章では、 ランダムアクセスメモリーがどのように構成され、各バイトが アドレスを通じてどのようにアクセスされるかを学んだ。 第20章では、 メモ リーが数値を格納できることや、 メモリーに格納されたコードがこれらの数値を 扱う回路を制御する方法を見てきた。 メモリーの中身は一般に、テキスト、写 真、音楽、 映画など、 デジタルで表現できるもの、つまり0と1で表現できる ものだ。 こうしたメモリーに格納されるもののうち、命令コードは単なるコー ド、 それ以外はデータと総称される。 つまり、 メモリーには、コードとデータが 含まれる。

コンピュータには、 周辺機器とよく呼ばれる複数の入出力 (I/O) デバイスが つながっている。 コンピュータがどのような周辺機器につながっているかは、そ のコンピュータが机の上にあるか、 閉じた状態で腕の下に抱えられているか、ポ ケットやバッグに入っているか、あるいは電子レンジやロボット掃除機、 車の中 に隠されているかにより大きく左右される。

デスクトップコンピュータで最も目立つI/Oデバイスは、ビデオディスプレ

イ、キーボード、マウス、 そして、 部屋の片隅にあるプリンターだろう。一方、 ノートパソコンはマウスの代わりにタッチパッドを備えることが多く、携帯電話 はこれらすべての機能を1つのスクリーンで実現する。こうしたコンピュータ はすべて、 大容量記憶装置 (デスクトップコンピュータではハードディスク [HDD]、 ノートパソコンではソリッドステートドライブ [SSD]、 携帯電話ではフ ラッシュストレージ [microSDなど]) を搭載し、 USB メモリーなどの外部記憶 装置で補強されているかもしれない。

あまり目立たないものの、 そのほかのI/O デバイスもある。 音楽を再生する ための機器、 イーサネットコネクターや Wi-Fi を通じてインターネットに接続 するための機器、 GPS [全地球測位システム] の信号を受信して位置や目的地を知 らせる機器、 さらには重力や動きを検出して携帯電話の向きや動きを判断する機 器などだ。

しかし、本章 (そして、続く3章) の主題は CPUだ。 CPUはコンピュータ の 「心臓」、 「魂」、 「脳」 などと呼ばれる。 その呼び方は人によって異なるだろ う。

第20章では、 メモリーアクセスを行うカウンター、 加算器、 ラッチで構成さ れる「3バイト累積加算器」 を紹介した。 メモリーに格納されたコードを使って 数値の加算や減算を行い、 その累計をメモリーに書き込む回路によってすべ 制御されていた。

CPU はそのときに見た3バイト累積加算器によく似るが、 多種多様なコード に対応できるよう一般化されているところが異なる。 その結果としてCPUは、 前章で紹介した機械よりもはるかに多機能だ。

本書でまず作り始める CPU は、 バイトを扱う。 すなわち、 8ビット CPUや 8ビットプロセッサに分類されるものだ。 ただし、64Kのランダムアクセスメ [モリー [RAM] へのアドレスが可能である、そのためには16ビットのメモリー アドレス、つまり2バイトが必要となる。 8ビット CPU は主にバイトを扱うが、 このメモリーアドレスに関連して、 限定的ながら 16ビット値を扱える必要があ る。

この CPU は現実世界には存在しないが、 (少なくとも理論上は) メモリーか らコードやデータを読み込んで、 様々な種類の算術演算や論理演算を実行でき る。 算術処理能力、 論理処理能力に関しては、どんなに高性能なデジタルコン

414

第21章 算術論理演算装置(ALU)

ピュータが相手だとしても同等だ。

8ビット CPU から 16ビット CPU 32ビット CPU、64ビット CPU と進化 していく過程で、 CPU の処理できる演算の種類が多様化したわけではない。 単 に、 同じ作業を速くこなせるようになっただけだ。 たとえば、 符号化された映画 のデータを再生する場合などで処理速度が大きな違いとなる。 8ビット CPUで もこの処理は可能だが、映画を意図した速度で再生するには遅すぎるだろう。

8ビット CPUはバイトに対して数学的、 論理的な操作を行うが、複数のバイ トを必要とする数値も扱える。 たとえば、 16進数の1388h09C4h (それぞれ 10進数では 5,000 と 2,500) という2つの16ビット数値を足し合わせたいと しよう。 以下の値をメモリーに入力し、 CPU で処理することになるだろう。

0000h:3Eh

88h

C6h

C4h

32h

10h

100h

|3Eh

13h

CEh

09h

32h

11h

0010h:00h

|00h

|76h

100h

100h

415

もちろん、これらすべてのバイトが大きな意味を持っているとは限らない。 な ぜなら、 命令コードとデータが混在しており、 各命令コードの意味がわからない からだ。 注釈付きのバージョンを以下に示そう。

0000h:3Eh 次のバイトをCPUに移動するコード 88h 1388hのローバイト |C6h 次のバイトを加算するコード C4h 09C4hのローバイト 32h 次の2バイトのアドレスに結果を保存するコード |10h -メモリーアドレス0010h 00h 3Eh 次のバイトをCPUに移動するコード | 13h 1388hのハイバイト CEh 次のバイトをキャリーとともに加算するコード 09h 09C4hのハイバイト 32h 次の2バイトのアドレスに結果を保存するコード 11h| メモリーアドレス0011h 00h |76h CPUを停止するコード 100h 0010h:00h 結果を保存する場所 100h

このような命令の羅列を 「コンピュータプログラム」 と呼ぶ (読者はもう知っ ているだろう)。 これはかなりわかりやすいプログラムで、 1388h (10進数で 5,000) 09C4h (10進数で2,500) を加算するものだ。 まず、 CPUは2つの 16ビット値のローバイト (88h と C4h) 同士を加算し、 その結果をメモリーア ドレス 0010h に格納する。 次に、 2つのハイバイト (13h09h) が最初の加 算から生じる可能性のあるキャリーとともに加算される。 その合計はアドレス 0011h に格納される。 そして、 CPU は停止する。 16ビットの合計はアドレス 0010h と 0011h に保存される。

416

第21章 算術論理演算装置 (ALU) 417

3Eh、C6h、32h、CEh、 76h といった特定の命令コードはどこからやってき たのだろう?この時点では、 まだ CPU を作り始めていないので、私はそれらを 単純に仮決めしてもよかったかもしれない。 だが、そうはしていない。 ここで私 は、商業的に成功した史上初のパーソナルコンピュータ MITS Altair 8800 で使 われた、有名なインテル 8080 マイクロプロセッサが採用した実際の命令コード を使用した。 なお、 初代の IBM PC は 8080 マイクロプロセッサではなく、 そ の次世代のプロセッサであるインテル 8088 を使用していた(その数字が次世代 であること示唆している)。

本章と続く数章では、 CPU 設計のモデルとしてインテル 8080 を使用する。 ただし、あくまでも参考モデルとしてだ。 私が作る CPU は、 8080の一部だけ を実装する。 インテル 8080は244個の命令コードを実装していたが、私の CPU が完成したときには、 それらの半分強を実装しているだろう。 それでも、 コンピュータの中心部 (または魂、 あるいは脳) で何が起こるかは、とてもよく 理解できるはずだ。

私はこれらのコードを命令コードや操作コード、あるいはオペコードと呼んで きた。 機械コード (マシンコード) とも呼ばれる。 なぜなら、それらは機械 (CPU を構成する回路) に直接使われるからだ。 先ほど示した小さなコンピュー タプログラムは、 機械コードプログラムの一例である。

8080 のすべての命令コードは1バイトだ。 しかし中には、命令バイトのあと に1バイトまたは2バイトの追加を必要とするものがある。 上記の例では、 命 令コードの3Eh、 C6h、 CEh のあとには常に別のバイトが続く。 これらは2バ イト命令として知られており、命令コードのあとに続くバイトは実際には同じ命 令の一部である。 命令コード 32hのあとにはメモリーアドレスを定義する2バ イトが続く。 これはいくつかある3バイト命令の1つだ。 多くの命令は追加の バイトを必要としない。 たとえば、 CPU を停止するコード 76hなどだ。 こうし た命令の長さのバラツキは、もちろん CPU の設計を複雑にする。

上の例が示すコードとデータの順序は、2つの16ビット数を合計する最良の 方法を示しているわけではない。 命令コードとデータがごちゃごちゃと混在して いるからだ。 多くの場合、 コードとデータはメモリーの別の領域に保持する方が よい。 この仕組みは次章で詳しく説明する。

中央演算処理装置 (CPU) そのものは、いくつかの部品で構成される。 本章

では、 CPU の最も基本部分である算術論理演算装置(ALU)に焦点を当てる。 ALU は CPU の一部で、 加算や減算のほか、いくつかの便利な処理を実行する。 8 ビット CPU では、 ALUは8ビットの加算と減算しか実行できない。 だが、 16ビット幅 24 ビット幅 32ビット幅、 そしてもっと大きな数値を扱う機会 はとても多い。 これまで見てきたように、こうした大きな数字の加算や減算は、 最下位バイトから順にバイト単位で行う必要がある。 それより上位の1バイト の加算または減算は、 前の演算からのキャリーを考慮する必要がある。 つまり、 ALUは次に示す基本的な演算が可能でなければならない。

8ビットの数値を別の数値に加算する。

●8ビットの数値を、 前の加算から発生したかもしれないキャリーとともに別 の数値に加算する。 これを 「キャリー付き加算」という。 ●8ビットの数値を別の数値から減算する。

・ある8ビット数値から別の8ビット数値を、 前の減算から発生したかもしれ ないキャリーとともに減算する。 これは 「キャリー付き減算」、 あるいは、 より一般的には「ボロー付き減算」 と呼ばれる。 これらは同じことを微妙に 違う表現で述べているだけだ。

便宜上、 これら4つの操作の説明を次のように簡略化しよう。

●加算 (Add)

●キャリー付き加算 (Add with Carry)

・減算 (Subtract)

・ボロー付き減算 (Subtract with Borrow)

いずれは、これらの記述をさらに簡略化しよう。 キャリー付き加算とボロー付 き減算は、直前の加算または減算のキャリービットを使用することに留意してほ しい。 そのビットは、 演算の結果としてキャリーが発生したかどうかによって、 0または1になる。 つまり、 ALUはある演算で得たキャリービットを次の演算 で使用するために保存しなければならない。

キャリービットを扱う場合の基本的な算術演算は一般に、 キャリーがない場合 よりもかなり複雑になる。

たとえば、2つの32ビット数 (それぞれ4バイト) を加算する必要があると

418

第21章 算術論理演算装置 (ALU)

419

しよう。 まず、 最下位の2つのバイトを足すことになる。 その加算によってキャ リーが生じるかもしれないし、 生じないかもしれない。 このキャリーは、 加算の 結果としてキャリーが発生したことを意味するので、 キャリーフラグと呼ぶこと にしよう。 キャリーフラグは0か1である。 そして、 そのキャリーフラグと一 緒に、次の上位の2つのバイトを加算し、 さらに次のバイトへと計算を続ける。 32ビットの数値ペアの加算には、4組のバイトペアに対して4回の演算が必 要だ。

・加算 (Add)

・キャリー付き加算 (Add with Carry) ・キャリー付き加算 (Add with Carry) ・キャリー付き加算 (Add with Carry)

このプロセスは減算でも同じように進むが、 減算される数が2の補数に変換 される点が異なる。 これは第16章で議論した。 すべての0ビットは1になり、 すべての1ビットは0になる。 多バイト数の最初のバイトでは、 加算器のキャ リーインを設定することで1が加えられる。 ある32ビット数から別の32ビッ ト数を引き算する場合にも、 次のように4回の演算が必要だ。

・減算 (Subtract) ・ボロー付き減算 (Subtract with Borrow) ・ボロー付き減算 (Subtract with Borrow) ・ボロー付き減算 (Subtract with Borrow)

この加減算を行う回路を、次のような箱にまとめてみよう。

FL Fo A B CY In 加算/減算 CY Our Out

これは特別変わったものには見えないだろう。 2つの8ビット入力を加算また は減算して8ビット出力を得る。 しかし、この箱には、これまで見てきた箱と は、いくつかの違いがある。

これまで、8ビット加算器にラベルを付ける場合、キャリーインは CI、 キャ リーアウトは CO と表記してきた。 でも、この箱では、ラベルが少々違ってい る。ここでは CY という略語を使ってキャリーフラグを表しているのだ。 詳し く見ていくと、 「CY 出力 (CY Out)」 は加算器からのキャリーアウトと同じで あるが、 「CY 入力 (CY In)」 は前回の加算や減算からのキャリーフラグであり、 それは加算器へのキャリーインと同じではないかもしれない。

また、この図では新たに F と F, と書かれた2つの入力が追加されている。 F は function [機能] の略で、この2つの入力が箱の中で何が行われるかを決めて いる。

F, F 命令 0 0 加算 0 1 キャリー付き加算 1 0 減算 1 1 ボロー付き減算

メモリー内の命令コードと連動して動くものを作っていることを意識しよう。 これらの命令コードをうまく設計すれば、 前章の加算コードと減算コードのビッ トのように、コードの2ビットを加算/ 減算モジュールの機能入力に使用できる かもしれない。 この加算/ 減算モジュールの大部分は、見慣れたもののはずだ。

420

第21章 算術論理演算装置 (ALU)

Inv In 1の補数 Out B CI 8ビット加算器 Out CO → CY出力

「1の補数」 のラベルが付いた箱は、 Inv (インバート [反転] の略) 信号が1の ときに入力を反転させる。 これは減算を行うときに2の補数に変換する最初の ステップとして必要だ。

加算器からのキャリーアウトは加算/ 減算モジュールからのCY 出力になる。 しかし、この図に欠けているのは1の補数の箱にある Inv信号と加算器にある CI信号だ。 Inv信号は減算の場合にはでなければならないが、 CIはもう少し 複雑になる。 論理表でこれを明らかにできるかどうか見てみよう。

F, F |機能 Inv CI 00- 0 加算 0 0 1 キャリー付き加算 0 CY 0 減算 1 1 1 1 ボロー付き減算 1 CY

この表からの補数器への Inv信号は F, と同じであることがわかる。 簡単 だ! しかし、 加算器へのCI 入力は少し面倒だ。 これは、 減算 (Subtract) 操作

421

422

の際、1にする。 多バイトの減算の最初のバイトで、 1の補数に1を加えて2の 補数を得るために必要だからだ。 F が1なら、 CI は前の加算または減算からの CY フラグとなる。 これは次の回路で実現できる。

F1 Fo- ・Inv CY入力 ·CI

加算 / 減算モジュールのインタラクティブ版は、 ウェブサイト (www. Code Hidden Language.com) で見ることができる。

算術論理演算装置には、加算や減算のほかにどんなことをさせたいだろう?そ の答えが「乗算と除算」 だとしたら、 がっかりしてしまうかもしれない。 加算と 減算の回路を構築するのがどれほど困難かを考えられるのなら、 乗算と除算の論 理的複雑さがどれほどのものかを想像してみるとよい! そのような回路は可能だ が、本書の控えめな目標をはるかに超える。 さらに、 インテル 8080 は乗算や除 算を実装していなかったので、私のCPUにも実装しない。 しかし、忍耐強く待 てば、第24章の終わりまでには、私たちが作り上げようとしている CPU が乗 算を行う基本的なツールを持つことがわかるだろう。

乗算を心配する代わりに、 「算術論理演算装置」 というフレーズの「論理」に ついて考えてみよう。 本書では論理という言葉は、 しばしばブール演算を指して いる。これらはどのように役立つのか?

たとえば、次の ASCIIコードを任意のアドレスから始まるメモリーに格納し ているとしよう。

第21章 算術論理演算装置 (ALU)

1000h: 54h

423

T

|6Fh 0

|6Dh m

|53h S

161h a

77h

|79h

W

165h e

|72h 「

このすべてのテキストを小文字に変換したいとする。

Y

第13章の205 ページと206 ページに戻ってみると、大文字の ASCIIコード が41hから5Ah の範囲で、 小文字の ASCIIコードが61hから7Ahの範囲であ ることがわかる。 対応する大文字と小文字の ASCIIコードは、 20h 異なる。 あ る文字が大文字であることがわかっているなら、 その ASCIIコードに20h を加 えることで、 小文字に変換できる。 たとえば、大文字のT の ASCIIコードであ る54h に 20h を加えると、 小文字のtのASCIIコードである74h になる。 以下 は2進法で表現した加算の様子だ。

01010100 +00100000 01110100

ただし、すべての文字に当てはまるわけではない。 小文字のo を表す ASCII コードである6Fh に 20h を足すと 8Fh になり、 ASCIIコードではなくなって しまう。

01101111 +00100000 10001111

しかし、ビットパターンをよく見てほしい。 ここに大文字と小文字のAがあ り、 ASCIIコードはそれぞれ41hと61hだ。

A: 01000001 a: 01100001

そして、ここに大文字と小文字のZがある。 これは ASCIIコード 5Ahと 7Ah になる。

Z: 01011010 z: 01111010

すべての文字について、 大文字と小文字の唯一の違いは左から3番目のビッ トだけである。 このビットを1に設定することで、 大文字を小文字に変換でき る。 文字がすでに小文字の場合は、 そのビットはすでに1なので問題ない。 したがって、20h を加えるのではなく、各ビットのペアに対してブールのOR 演算を使用する方が理にかなっている。 第6章で示した次の表を思い出そう。

OR 0 1 0 0 1 1 1 1

2つの被演算子のどちらかが1であれば、 OR 演算の結果は1になる。 再び大文字のTを取り上げよう。 今度は20h を加える代わりに、 54h (T) 20h の対応するビット間でOR 演算を行う。

01010100 OR 00100000 01110100

と

424

第21章 算術論理演算装置(ALU)

425

対応するビットのいずれかが1であれば、 結果は1となる。 この方法の利点 は、小文字には影響しないことだ。 小文字のと20h を使って OR 演算した結 果は次のようになる。

01101111 OR 00100000 01101111

メモリー上の各文字と20h に OR 演算を適用すれば、 すべての文字を小文字 に変換できる。

1000h: 74h t 6Fh 0 6Dh m 73h S |61h a |77h w |79h y 165h e 72h

ここでやっていることには名前がある。 対応するビットペアの間でOR 演算 を行うので、 ビット単位 OR演算と呼ばれる。 実はこれはテキストを小文字に変 換するだけでなく、ほかの演算にも役立つ。そのため、算術論理演算装置に次 ページに示す回路を追加してみよう。

426

A- A6 As A4 A3 A2 B B6 B2 Bs B4 h h h h AL B1 Ao Bo

A、Bのラベルが付いた2つの8ビット入力に対して、この回路は OR 演算 を行う。その回路を簡単なラベルを貼った箱に入れてみよう。

A OR Out B

次に、テキストを大文字に変換する方法を考えてみよう。 ビットを1に設定 する代わりに0に設定したいため、小文字への変換とは少し異なる。 OR 演算で はなく、 AND 演算が必要なのだ。 第6章で示した表を思い出そう。

AND 0 1 0 0 0 1 0 1

20h で OR 演算を行う代わりに、 20hの逆数であるDFh (2進数で 11011111) AND 演算を行う。 ここでは、 小文字のを大文字に変換してい る。

第21章 算術論理演算装置(ALU)

01101111 AND 11011111 01001111

427

ASCIIコード 6Fhは4Fh となり、 大文字の0を表す ASCIIコードとなる。 すでに大文字の場合は、DFh との AND 演算には効果がない。 大文字のTの 場合は次の通りだ。

01010100 AND 11011111 01010100

DFh との AND 演算後もこの文字は大文字のままだ。 テキスト全体を対象に、 AND 演算を用いてすべての文字を大文字に変換できる。

1000h: 54h T 4Fh 0 4Dh M 53h S 41h A 57h W 59h Y 45h E 52h R

もしALU に 8個のAND ゲートがあって、 2バイト間のビット単位AND 演 算を行うことができれば便利だ。

A7 A6 As A4 A3 A2 AL Ao B7 B6 Bs B4 B B2 B₁ Bo

これを小さな箱に入れて、わかりやすくしておこう。

A AND Out B

ビット単位 AND 演算は、 バイトの特定のビットが0か1かを判断するのに も役立つ。 たとえば、 ある文字の ASCIIコードを持つバイトがあり、それが小 文字なのか大文字なのかを知りたいとする。 20h とピット単位 AND を実行しよ う。 その結果が20hであれば、その文字は小文字だったことになる。 もし結果 が00h であれば、 大文字だ。

もう1つ便利なビット単位演算は、 排他的論理和 (XOR) だ。 以下の表は、 第14章で XOR が加算に役立つことを紹介した際に登場した。

XOR 0 1 0 0 1 1 I 0

428

第21章 算術論理演算装置(ALU) 429

2バイト間のビット単位 XOR 演算を行うために、8個のXOR ゲートを配線 したのが次の図だ。

A7 A6 As A4 A3 A₂ AL Ao B7 B6 B5 B4 B B2 B₁ Bo

今度も、その回路を便利な箱に入れておこう。

XOR Out B

XOR 演算はビットを反転させるのに役立つ。 たとえば、 「Tom Sawyer」の各 文字の ASCIIコードと20hでXOR 演算を行うと、 大文字はすべて小文字に変 換され、 小文字はすべて大文字になる! また、 FFh とのビット単位 XOR 演算 は、値の全ビットを反転させる。

先に、加算 / 減算モジュール用に F, とF。 というラベルの付いた2つの機能 ビットを定義した。 ALU 全体では、3つの機能ビットが必要になる。

F2 F, Fo 命令 0 0 0 加算 0 0 1 キャリー付き加算 0 1 0 減算 0 1 1 ボロー付き減算 1 0 0 ビット単位AND 1 0 1 ビット単位XOR 1 1 0 ビット単位OR 1 1 1 比較

これらの機能コードは恣意的に割り当てているわけではない。 やがてわかるよ うに、コードはインテル 8080 マイクロプロセッサに実装された命令コードに影 響されている。 ビット単位のAND XOR OR のほかに、別の操作である「比 較」 が追加されている。これについては追って説明しよう。

本章の冒頭で、 C6h と CEhの命令コードを持つ小さなプログラムを示した。 これは、命令コードのあとに続くバイトとの加算を実行する。 コード C6h は通 常の加算、 コード CEhはキャリー付き加算となる。 命令コードに続くバイトを 使うので、 即値命令と呼ばれる。 インテル 8080では、この2つのコードは、次 ページに示す8つのオペコード [命令コード] ファミリーの一部となっている。

430

第21章 算術論理演算装置 (ALU)

命令 即値加算 オペコード C6h キャリー付き即値加算 CEh 即値減算 D6h ボロー付き即値減算 DEh 即値AND E6h 即値XOR EEh 即値OR F6h 即值比較 FEh

これらのオペコードは通常、次のような形をとる。

11F2F, F, 110

F2 FFは2つ前の表に示したビットだ。 この3ビットは、ビット単位の AND、 XOR OR の箱を組み合わせた次の回路で使用される。

F2 F1 Fo A 35 A A B A AND XOR OR Out Out Out In In In En TRI En TRI En TRI Out Out Out B

431

432 |

A、Bの入力は3つのAND XOR OR の箱すべてに接続されている。 全部 が同時に与えられた仕事をこなす。 ただし、 出力として選択されるのは1つだ けだ。これが､ TRIとラベル付けされた3つの箱の目的で、 これらは8ビット のトライステートバッファである。 トライステートバッファは、 Fo、Fi、F2の3 つの機能信号に基づいて、 その中の1つを選択する (あるいはどれも選択しな い)。 F2 が0である場合、 または、 F2, F, F, すべてが1である場合、 どの出 力も選択されない。

この図をまた別の箱にカプセル化しよう。

F2 F1 Fo 論理 Out B

それが算術論理演算装置の 「論理」 モジュールだ。

先に示した表は、 F2、 F, F, がすべて1の場合、 比較演算が行われることを 示す。 これはどういう意味だろう?

ある数値がほかの数値より小さいか、大きいか、 等しいかを判断できると、 便 利なときがある。 これはどのように行うのだろう? 基本的には減算だ。 バイト AからバイトB を引く。 結果がゼロなら、 2つの数値は等しい。 それ以外の場 合、 キャリーフラグが設定されていれば、 バイトBはバイトAより大きく、 キャリーフラグが設定されていなければ、 バイトAの方が大きい。

比較命令は減算命令と同じだが、 結果がどこにも保存されないという重要な違 いがある。 その代わりに、 キャリーフラグが保存される。

しかし、比較命令を行う際には、 演算結果がゼロであったかどうかも知る必要 がある。 ゼロの場合は、 2つのバイトが互いに等しいことを示す。 これには、 ゼ ロフラグと呼ばれる別のフラグが必要で、 キャリーフラグとともに保存されなけ ればならないことを意味する。

第21章 算術論理演算装置(ALU)

ついでに、サインフラグ [符号フラグ] と呼ばれる別のフラグも追加しておこ う。 これは演算結果の最上位ビットが1である場合に設定されるフラグだ。 数 値が2の補数なら、サインフラグは数値が負か正かを示す。 数値が負ならフラ グは1、 正ならフラグは0となる。

(インテル 8080では、 実際には5つのフラグが定義されている。 なお、加算 器の下位4ビットから上位4ビットへのキャリー結果を示すハーフキャリーフ ラグ (Auxiliary Carry flag) はここでは実装しない。 これは、インテル 8080 のDAA (Decimal Adjust Accumulator) という命令を実装するために必要な、 アキュムレータ内の値を2進数から2進化 10進数 (BCD) に変換するもので、 第18章でクロックを作るときに説明した。 私のCPUではその命令を実装しな い。 また、 私が実装しないもう1つのフラグがパリティフラグだ。 これは算術 演算または論理演算の結果において、 1となるビットの数が偶数なら1となる。 7つのXOR ゲートで簡単に実装できるが、 ほかのフラグよりも役に立つことは 少ない)。

実は、ある種のプログラミング処理では、比較命令が加算や減算よりも重要に なる。 たとえば、ウェブページ上の特定のテキストを探すプログラムを書くとし よう。これには、ウェブページ上のテキストの文字と、 探したいテキストの文字 を比較する処理が含まれる。

算術論理演算装置全体は、次ページに示すように、 加算 / 減算モジュールと論 理モジュール、 そして、 ちょっと面倒なサポート回路で構成される。

433

434

F2FiFo B F1 Fo A B F2 F1 Fa A В CY In 加算/減算 CY Out 論理 Out Out イネーブル In TRI En Out In Clk ラッチ Out クロック Clk ラッチ En TRI Out フラグ 出力

#

TRI と書かれた2つの箱はトライステートバッファだ。 論理モジュールは、 AND OR XOR 演算を選択する F, F, F2 の3つの組み合わせに対しての み, 出力 (Out) を有効にする。 加算 / 減算モジュールの出力の先にあるトライ ステートバッファは、 加算または減算を示す F2 が0の場合にのみ有効になる。

図の下方を見ると、 2つのラッチのClk入力がALUに適用される左下のク ロック入力に接続されている。 もう1つのトライステートバッファは、 ALUの 入力でもある左下のイネーブル信号によって制御される。 これは、 加算 / 減算と 論理モジュールからの出力を合成する。

図に示された論理ゲートのほとんどは、 キャリーフラグ (略称 CY) のために 使われている。 キャリーフラグは、 F2 信号が0 (加算または減算を示す) か、 F,

第21章 算術論理演算装置(ALU)

435

およびF が 1 (比較を示す) に設定する必要がある。

3つのフラグは、 下部中央のラッチに入力される。 8入力のNOR ゲートが、 演算結果がすべてゼロかどうかを判定する。 それが、 ゼロフラグ (略称Z) だ。 またデータ出力の最上位ビットが Sign フラグ (略称S) だ。 ここにはフラグは 3つしかないが、 ALU から出力されるときに、 1バイト中の3ビットとして扱 われる。 キャリーフラグはその後、 上部に戻り、 加算 / 減算モジュールのCY 入 力となる。

次のステップは、これらの面倒な論理をシンプルな箱の中に隠してしまうこと だ。

F2 F, Fo クロック 算術論理演算装置 (ALU) イネーブル フラグ 出力

算術論理演算装置 (ALU) が完成した!

ALU は CPU を構成する部品として、 算術演算や論理演算といった非常に重 要な処理を行う。 そのためには、 ALUに数値を取り込む方法や結果を保存して 適切な場所に移動する方法が必要になる。 それが次のステップだ。



第 22 章

レジスターとバス

コンピュータの日常的な操作の多くには、モノを動かすことが含まれる。もち ろん、ここでいうモノとはバイトのことだ。 ファイルの読み出しや保存、音楽や 映画のストリーミング、テレビ会議など、 私たちはあらゆる場面でこのバイトの 動きを体験している。 バイトが十分な速度で移動できないと、 音や映像がフリー ズしたり、文字化けしたりする。 誰しもが経験することだ。

さらに細かく見ると、 バイトは中央演算処理装置 (CPU) 内部でも移動して いる。 バイトはメモリーから CPUへ、そして算術論理演算装置 (ALU)へと 移動する。 ALUでの演算結果は、 最終的にメモリーに移動する前に、さらなる 算術論理操作のため、 再度 ALU に戻ることもある。

こうした CPU 内部でのバイトの移動は、ALUの数値演算ほど華やかではな いが、 同じくらい重要だ。

バイトが CPU 内部で移動する際、 それらは複数のラッチに保存される。これ は第20章で説明した3バイト累積加算器でおなじみの概念だ。 その加算器には、 命令コードを保存するラッチが1つ、 データバイトを保存するラッチが3つ、 合計4個の8ビットラッチが含まれていた。

本章で作る CPU はインテル 8080 マイクロプロセッサをベースにしているの で、4つのラッチでは足りない。 ただ、すべてのラッチを直ちに見ていくわけで はない。 まずは、 CPU の命令で直接制御できる7つの特別な8ビットラッチに 焦点を当てよう。 これらのラッチはレジスターと呼ばれ、 その主な目的は ALU によって処理されるバイトを保存することだ。

7つのレジスターはすべて重要だが、 特に重要なのがアキュムレータと呼ばれ るレジスターだ。

アキュムレータはどのように特別なのだろう? 前章で説明したように、 ALU にはAとBという2つの入力がある。 インテル 8080 (つまり、 私がここで作っ ている CPU)では、ALUへの2つの入力のうち最初の入力は常にアキュムレー タに蓄えられている値であり、 ALUの出力は常にアキュムレータに戻される。 アキュムレータを通して、 出力がほかのレジスターに移動したり、 メモリーに保 存されるのだ。

7つのレジスターは文字で識別される。 アキュムレータはレジスターAとも 呼ばれ、ほかの4つのレジスターはB、C、D、Eという平凡な名前がついてい るが、最後の2つのレジスターの名はFとGではない。これら2つのレジス ターはともに、 メモリーにアクセスするための16ビットアドレスを構成するた めに使われる。そのため、 「ハイ (High) バイト」 と 「ロー (Low) バイト」の 頭文字をとって、 HとLと呼ばれる。

まとめると、インテル8080 (と私のCPU) は、 A、B、C、D、E、 H、 Lと 呼ばれる7つのレジスターを備える。

前章の416ページで、 私は命令コード [オペコード] 3Eh を 「次の (続く) バイ トをCPUに移動するコード」 と定義した。 より正確にいうと、それはメモリー 内の次に置かれたバイトをアキュムレータ (レジスター A) に移動するコード だ。 そのコード 3Eh は、 8080 が実装している類似のコード群の一部である。

オペコード 意味 06h OEh 16h 1Eh 次のバイトをレジスターBに移動 次のバイトをレジスターCに移動 次のバイトをレジスターDに移動 次のバイトをレジスターEに移動 26h 次のバイトをレジスターHに移動 2Eh 次のバイトをレジスターLに移動 36h 3Eh 次のバイトをアドレス [HL] のメモリーへ移動 次のバイトをレジスターAに移動

コード 3Ehはこの表の一番下にある。 このコードの数字順とレジスターのア

438

第22章 レジスターとバス

ルファベット順は一致していないが、まあそれは仕方のないことだ。

コード 36hに注目しよう。 このコードは、表のほかのコードとは異なる。 オ ペコードに続くバイトを7つのラッチのいずれかに移動させるわけではない。 代わりにそのバイトは、 HとLのレジスターで構成される16ビットのメモリー アドレス [HL] が示すメモリーに格納される。

私はまだこの命令を理解できる CPU を作り終えていないが、もし目の前にそ のようなCPU (あるいはインテル 8080 を使ったコンピュータ) があれば、これ らの命令コードを3つ使った次のような小さなコンピュータプログラムを実行 できるはずだ。

0000h:26h 次のバイトをレジスターHに移動 |00h 2Eh 次のバイトをレジスターLに移動 08h 36h 次のバイトをアドレス[HL] のメモリーへ移動 55h 76h 停止するためのコード 100h 0008h: 00h バイト55hが格納される場所

このうち26h, 2Eh、 36hの3つが、 先ほどの表にあるコードだ。 1つ目は、 メモリーの次のバイト (00h)をレジスターHに移動させ、 2つ目は、バイト 08h をレジスターLに移動させる。 レジスターのHとLを合わせて、 メモリー アドレス 0008h が構成される。 3つ目の命令は36hで、 これは次のバイト (55h) を、HとLで形成されるアドレス [HL] が示すメモリーの位置 (0008h) に格納 することを意味する。 最後にコード 76hに到達し、 CPUが停止する。

HとLのレジスターを使用して16ビットのメモリーアドレスを構成するやり 方は間接アドレッシングと呼ばれ、 まだこの時点ではあまり感じられないかもし れないがとても便利な方法だ。

前の表の8つのオペコードのビットを調べると、 あるパターンが見いだせる。 これら8つのコードはすべて、次のようなビットで構成されているのだ。

439

440

00DDD110

ここで、 DDD は、 次の表に示すように、 バイトの送り先を表す3ピットコード だ。

コード レジスターまたはメモリーメモリー 000 B 001 C 010 011 100 101 110 111 D E H L [HL] (またはM) A

この表のコード110は、HとLの16ビットの組み合わせで表されるメモリー 位置を示す。 個人的にはこのメモリレジスターを [HL] と表記したいが、インテ ルの8080 のドキュメントではM (もちろんメモリーの略)と表記している。 ま るでMが別のレジスターであるかのようだ。

8ビットプロセッサがサポートするすべてのオペコードが1バイト長である場 合、オペコードは何個ありうるか? もちろん256個だ。 インテル8080 では、 244個の命令コードしか定義されておらず、 12個の8ビット値が未定義である ことが判明した。 これまでに、各章では8つずつの命令コードを2回見てきた。 1つ目は第21章の431ページの表、2つ目は438ページの表である。 また、 第21章の416ページでは、命令コードに続くメモリーアドレスにバイトを保存 する32h と プロセッサを停止する 76h というコードも紹介した。

驚かないでほしいのだが、 次の表には64個のオペコードが載っている。

第22章 レジスターとバス

算術または論理演算 ソース ADD ADC SUB SBB ANA XRA ORA CMP B C D E HLM 80h 88h 90h 98h A0h A8h BOh B8h 81h 89h 91h 99h Alh A9h Blh B9h 82h 8Ah 92h 9Ah A2h AAh B2h BAh 83h 8Bh 93h 9Bh A3h ABh B3h BBh 84h 8Ch 94h 9Ch A4h ACh B4h BCh 85h 8Dh 95h 9Dh A5h ADh B5h BDh 86h 8Eh 96h 9Eh A6h AEh B6h BEh A 87h 8Fh 97h 9Fh A7h AFh B7h BFh

この表には、インテル 8080 が実装している全オペコードの4分の1以上が含ま れる。これらの命令は、この CPU がサポートする算術または論理演算の中核を なす。

8列のオペコードの最上部には、それぞれ3文字の略称が並ぶ。 それらの意味 は 「ADD [加算、 Add]」、 「ADC [キャリー付き加算、 Add with Carry] 」、 「SUB [減算、 Subtract]」 「SBB [ボロー付き減算、 Subtract with Borrow]」、 「ANA [論理AND]」 「XRA [論理 XOR]」 「ORA [論理 OR]」、 「CMP [比較、 Compare]」 だ。 これらは、インテ ルが 8080 マイクロプロセッサのドキュメントで使用している略語である。 長い 命名を覚えるための簡潔な名称 (ニーモニックと呼ばれる) だが、 8080用の プログラムを書くときに重要な役割を果たす。

左端の列に示されたソース [転送元] と組み合わせることで、8つの算術およ び論理それぞれを実行できる。 この列には、7つのレジスターと [HL] によって アクセスされるメモリー (M) がリストアップされている。

これらの略語は、 命令コードを参照するのに便利な方法だ。 たとえば、 「レジ スターEの内容をアキュムレータに加算するコード」 とか 「オペコード 83h」 という代わりに、次のように簡単に表現できる。

441

ADD E

これによってレジスターEとアキュムレータの和がアキュムレータに戻される。 また、「アキュムレータと [HL] に格納されているメモリーのバイトとの間で 排他的論理和演算を行う」 とか 「オペコード AEh」 という代わりに、 次のよう に簡単に表現できる。

XRA M

この結果はアキュムレータに戻される。

これらの略語は、 正式にはアセンブリ言語命令と呼ばれる。 この用語は1950 年代初頭に使われ始め、 もともとはコンピュータプログラムを組み立てる [アセ ンブル] プロセスを指していた。 上で示したニーモニックは、CPUによって実装 されている特定の命令コードを簡潔に参照する方法だ。 アセンブリ言語命令 XRAM はオペコード AEhと同じであり、 その逆も同様である。 前表の64個の命令は、すべて次のようなビットパターンを持つ。

10FFFSSS

FFFは第21章の ALUで実装した算術または論理演算のコードである。 SSS は ソースレジスターまたはメモリーを参照しており、 これは440ページの表のコー ドと同じだ。

先に438ページで命令コードの表を紹介した。 それらは、 命令コードに続く バイトをレジスターの1つまたはメモリーに移動するものだった。 これらは、 即値転送命令 (Move Immediate Instruction) と呼ばれ、 MVI と略される。今 こそ、説明的な名称で呼ぶのをやめて、 公式のアセンブリ言語による名称を使い 始めるときだろう。

442

第22章 レジスターとバス

アセンブリ言語命令 オペコード MVI B, data 06h MVI C, data OEh MVI D, data 16h MVI E, data IEh MVI H, data 26h MVI L, data 2Eh MVI M, data 36h MVI A, data 3Eh

アセンブリ言語命令の優先性を強調するために、オペコードを最後の列に移動 している。 表中の data は、 オペコードに続くバイトを指している。 416ページで紹介したコード32hは、 アキュムレータの内容を、 命令コード に続くアドレス位置のメモリーに保存するものだった。 次に示すのは、それに似 たコードだ。コード 3Ah は、指定されたアドレスのバイトをアキュムレータに ロードする。

アセンブリ言語命令 オペコード STA addr LDA addr 32h 3Ah

ニーモニックの STA は 「store accumulator (アキュムレータをストア[保存] する)」 LDA は 「load accumulator」 (アキュムレータにロード [読み出し] する) を意味する。 また addr は、 オペコードに続く2バイトで与えられる 16 バイト のアドレスを指す。

ニーモニックのHLT は、 CPU を停止させるオペコード 76hに対応する。 次ページに示すのは、これらの命令を使用した小さなコンピュータプログラム だ。オペコードとアセンブリ言語命令の対応を示す。

443

444

0000h: 3Ah LDA 2044h 44h |20h 06h MVI B, 33h |33h 80h ADD B 32h STA 2044h |44h |20h |76h HLT :66h合計値が格納さ

2044hれる場所

LDA 命令は、アドレス 2044h の値をアキュムレータにロードする。 その値は 66hだ。 MVI 命令はレジスターBに値33hをロードし、 ADD 命令はレジス ターBの値をアキュムレータの値に加算する。 この時点でアキュムレータには 値99h が入っている。 そして、 次のレジスターのSTA命令は、 その合計値をア ドレス 2044h に保存する。 つまり、最初の値66h を新しい値99h で上書きする。 第21章で431ページに示した表にある8つのオペコードは、 命令コードに続 くバイトを使って算術演算と論理演算を行うものだ。 それらの命令を、 インテル 8080 の公式なニーモニックとして以下に示す。

アセンブリ言語命令 オペコード ADI data C6h ACI data CEh SUI data D6h SBI data DEh ANI data E6h XRI data EEh ORI data F6h CPI data FEh

第22章 レジスターとバス 445

第21章で、 これらの命令が即値 (immediate) 命令と呼ばれる理由は、 オペ コード直後に続くバイトを使用して算術または論理操作を実行するからだと説明 した。 これらは ADI (add immediate [即値加算])、 ACI (add with carry immediate [キャリー付き即値加算])、 SBI (subtract immediate [即値減算]) などと 呼ばれる。 命令は常にアキュムレータに関わり、 結果はアキュムレータに戻され る。

先に示した小さなプログラムは、次のように簡略化できる。

A

0000h: 3Ah LDA 2044h

da

44h

Do

|20h

O

C6h ADI 33h

Ela

33h

3

HCE

410

32h STA 2044h

44h

C

|20h

VOM W

76h HLT 0808

204h: 66h 合計値が格納される場所

J VON

今度は、 レジスター Bに値33h をロードしてアキュムレータに加算するのでは なく、 ADI命令で値33hをアキュムレータに加算している。 インテル 8080 ではさらに、 あるレジスターから別のレジスターへ、あるいは メモリーアドレス [HL] からレジスターへ、 あるいはレジスターからメモリーア ドレス [HL] ヘバイトを移動する63個の命令が定義されている。

「MOV デスティネーション, ソース」 のオペコード

デスティネーション [転送先] ソース B C D E H L M A [転送先] B 40h 48h 50h 58h 60h 68h 70h 78h C 41h 49h 51h 59h 61h 69h 71h 79h D 42h 4Ah 52h 5Ah 62h 6Ah 72h 7Ah E 43h 4Bh 53h 5Bh 63h 6Bh 73h 7Bh H 44h 4Ch 54h 5Ch 64h 6Ch 74h 7Ch L 45h 4Dh 55h 5Dh 65h 6Dh 75h 7Dh M 46h 4Eh 56h 5Eh 66h 6Eh 7Eh A 47h 4Fh 57h 5Fh 67h 6Fh 77h 7Fh

これらはムーブ命令といい、8080 のニーモニックでは MOV と表記される。 これら63個の命令は、 デスティネーション [転送先] レジスターと、ソース [転 [送元] レジスターの両方を用いて記述される。 たとえばコード 69hは、

MOV L,C

であり、 デスティネーションレジスターが最初に書かれ、 ソースレジスターが2 番目に書かれる。 ここで注意が必要だ!この慣習に最初はとまどうかもしれな い。 この命令は、 レジスターCのバイトをレジスターLに移動させることを意 味する。 バイトの移動を示す小さな矢印で、 このように視覚化してもいいだろ う。

Move L←C

レジスターLの内容がレジスターCの値で置き換えられる。 レジスターCの内 容は変わらず、 その後のCとLは同じ値を保持する。

これらの命令のうち7つは、ソースレジスターとデスティネーションレジス

446

第22章 レジスターとバス

|447

ターが同じであるため、 実際には何もしていないことに注意しよう。 たとえば、 次のように、

MOV C, C

レジスターCの内容を自分自身に移動させても、何の意味はない。

ただし、 MOV M.M 命令は存在しない。 ここに入るべきオペコードは76h だ が、 実際にはコンピュータを停止させる命令であるHLT に使われる。 ここで、 メモリー位置 2044h の値に加算を行う、 小さなプログラムの例を示 そう。

0000h: 26h MVI H, 20h |20h |2Eh MVI L,44h |44h 7Eh MOV A, M |CE ADI 33h |33h |77h MOV MA 76h HLT 2044h: 66h合計値が格納さ

れる場所

これは、レジスターのHとLを使用した間接アドレッシングの利便性を示す 例だ。 メモリーアドレス 2044h を指定する際に一度だけHとLが設定される。 最初の MOV 命令は、 そのアドレスに格納された値をアキュムレータに移動さ せる。 アキュムレータには、値66h が格納される。 そして、それに値33h が加 算される。 2番目の MOV 命令では、 転送先アドレスを再度指定することなく、 アキュムレータの値をメモリー位置 2044h に移動させている。

この63個の MOV 命令を構成するビットを調べると、次のようなパターンに 気づくだろう。

448

01DDDSSS

DDD はデスティネーションレジスター、 SSS はソースレジスターである。 これ は、以前に見た以下の表と同じだ。

コード レジスターまたはメモリー

000

001

010

C

011

100

101

B

D

E

110

L

H

111

M

A

CPU を設計する方法の1つは、まず CPU に実装させたい命令を決めて、そ のために必要な回路を考えるやり方だ。 ここでの私の取り組みはそのやり方に近 い。 まずインテル 8080 の命令のサブセットを選んで、回路を組んでいるからだ。 7つのレジスターを使うすべての命令コードを実現するには、 CPUは7つの ラッチにバイトを格納し、 そのバイトを3ビットコードに基づいて取り出す方 法が必要となる。 コード110は特殊なケースとして扱わなければならないので、 とりあえず無視しよう。 残りの7つのコードは、 3-to-8 デコーダーの入力とし て使用できる。

次の回路は、7つのラッチと7つのトライステートバッファを持つ。 左側の 3-to-8 デコーダーは、入力された値をレジスターの1つにラッチするために使 用され、 右側の3-to-8 デコーダーは、レジスターから出力する値を選択するた めに、トライステートバッファにイネーブル信号を送るのに使われる。

第22章 レジスターとバス

入力 入力 クロック セレクト In S2 St So 3-to-8 01234567 A B C D E H L 出力 イネーブル セレクト In S2 S₁ So 3-to-8 01234567 TRI TRI TRI TRI TRI TRI TRI

Acc (アキュムレータ) 出力

出力

これはレジスターアレイと呼ばれ、 本章で見る最も重要な回路だ。 最初は少々複 雑に見えるかもしれないが、 実際にはとても素直な回路である。

回路の上部には、 「入力」 と書かれた8ビットのデータパスがある。 これは、 レジスターアレイに保存されるバイトだ。 A~Lのラベルで示されている7つ の箱は8ビットラッチだ。 明示されていないが、これらのラッチには、値を保 存するクロック入力が左側にある。

図の上部の左右には、 S2、 Si, So と書かれた入力/出力セレクトを持つ2つ の3-to-8 デコーダーがある。 これらのセレクトの値は、 前表に示した7つのラッ チのコードに対応する。 そのため、 6と書かれた出力は未使用となっている。こ の出力は、セレクト値110に対応していて、 ラッチではなくメモリーを指す。

左上の3-to-8 デコーダーは、これらのラッチのクロック入力を制御する。 そのク ロック信号は、 So, S, S2 の値に応じて、 7つのラッチのいずれかにルーティング される。この処理によって、 入力されたバイトはいずれかのラッチに保存される。

1つのラッチの下には、それぞれトライステートバッファが置かれている。こ

☐

|449

450 |

れもまた明示されていないが、これらのバッファはそれぞれイネーブル入力を持 つ。 右上にはもう1つの3-to-8 デコーダーがある。 このデコーダーが7つのト ライステートバッファの1つを有効にし、 ラッチに格納されたバイトが下部の 出力データパスに現れる。

ここで、 アキュムレータがやや特別扱いされていることに注意しよう。 アキュ ムレータに格納された値は、 常に図の下部に示されている Acc 出力として利用 可能だ。

このレジスターアレイに入力される8ビット値は、 複数のソースからやって くる可能性がある。 すなわちメモリー、ほかのレジスター、 または ALU からだ。 また、このレジスターアレイから出ていく8ビット値は、 メモリーに格納した り、ほかのレジスターに格納したり、 ALUに入力したりできる。

木ばかり見て森を見失わないように、これらのデータパスを簡略化したブロッ ク図を見てみよう。

DO RAM DI In レジスターアレイ Acc Out 算術論理演算装置 (ALC) Out

この図には多くのものが欠けている。 示されているのは主要な8ビットデー

第22 レジスターとバス 451

タパスのみだ。 レジスターアレイのAcc 出力から算術論理演算装置 (ALU) の 入力Aに至る経路を除いて、ほかのすべての入出力は相互に接続されている。 RAMのデータ出力 (DO) も、 RAMのデータ入力 (DI) に接続されている!

これは、コンポーネント [部品] のすべての出力がトライステートバッファを 経由していて、そのうちイネーブルになっているのは常に1つだけなので可能 だ。イネーブルされて利用可能になった値を、 書き込み信号を使ってメモリーに 保存したり、 レジスターアレイの7つのレジスターのいずれかに格納したり、 算術論理演算の結果を ALUに格納したりできる。

これらすべての入出力間の接続をデータバスと呼ぶ。 データバスは、すべての コンポーネントの入力と出力に共通するデータの通り道だ。 データバスに接続さ れたトライステートバッファがイネーブルになると、そのバイトはデータバス全 域でアクセス可能となり、 データバス上のほかのコンポーネントで利用できる。 このデータバスは8ビットデータ専用である。 様々なソースからくる可能性が ある16ビットのメモリーアドレスには、別のバスが必要だ。 その16ビットバ スはアドレスバスと呼ばれ、 すぐに目にすることになる。

さて面倒な詳細に踏み込むことにしよう。 実のところ、レジスターアレイが 449ページに示した回路ほど単純であればと心から願うものの、 実際にはもっと 強化する必要がある。

これまでに紹介してきたレジスターアレイは、あるレジスターから別のレジス ターにバイトを移動させる MOV 命令にとって好都合だ。 実際、 3-to-8 デコー ダーは、 MOV 命令を意識してレジスターアレイで実装されている。 あるレジス ターの内容をデータバス上で有効 (イネーブル) にして、その値を別のレジス ターに格納できるのだ。

しかし、このレジスターアレイはSTA命令や LDA命令の役には立たない。 これらの命令は、 アキュムレータからメモリーに値を保存したり、 メモリーから アキュムレータに値をロードしたりする。 ほかの命令もアキュムレータを使用す る。 すべての算術および論理命令は、その結果をアキュムレータに格納する。

よってレジスターアレイのアキュムレータ部分を多少強化し、 3-to-8 デコー ダーとは無関係にアキュムレータに値を格納したり、 アキュムレータから値を取 り出せるようにする必要がある。 これは、 アキュムレータのラッチとトライス テートバッファだけを含むレジスターアレイにほんの少しロジックを追加するだ

452

けで実現できる。

アキュムレータクロック アキュムレータイネーブル 入力セレクト デコーダーから Acc Clk A TRI En 出力セレクト デコーダーから

左側に、2つの OR ゲートの入力となる信号が追加されている。 これらの信号 により、入力セレクトデコーダーとは無関係にデータバスの値をアキュムレータ (ラッチA) に保存し、 出力セレクトデコーダーとは無関係にアキュムレータの 値をデータバス上で有効できる。

レジスターHとレジスターLを組み合わせて RAMアドレスを指定するには、 レジスターアレイにもう1つの強化が必要だ。 だが、 その強化ははるかに面倒 なので、ほかの必要事項に集中しながら、できるだけ遅らせることにしよう!

さらに3つの8ビットラッチをデータバスに接続する必要がある。 これらは、 命令バイトを格納するラッチだ。

22章 レジスターとバス

DO RAM 命令ラッチ1 命令ラッチ2 命令ラッチ3 トライステートバッファ

オペコードは常に命令ラッチに格納される。 オペコードがラッチに格納 されたなら、それは CPU を制御するほかのすべての信号を生成するために使用 できる。この仕組みは次章で紹介しよう。

命令ラッチ2は、 追加のバイトを伴う命令に使用される。 たとえば、即値転 送命令 (MVI)は直後にバイトが続き、 そのバイトがレジスターの1つに転送 される。また算術論理即値命令、 たとえばADIなども、直後にバイトが続く。 たとえば ADI の場合、 そのバイトはアキュムレータに加算される。 したがって、 命令ラッチ2の値をデータバス上で有効にする必要があるが、 それがトライス テートバッファの目的だ。

命令ラッチ2と命令ラッチ3は、 3バイト長の命令 (たとえば STA や LDA など) に対して併用される。 これらの命令では、2バイト目と3バイト目が16 ビットの値を構成し、 メモリーのアドレスとして使用される。

8ビットのデータバスとは別に、 CPU が最大64Kのメモリーにアクセスする ためには 16ビットのアドレスバスが必要だ。 ここまででわかっていることは、 メモリーアクセスで使われるアドレスは、3つの異なるソースからやってくる可 能性があることだ。

・プログラムカウンターと呼ばれる値。 命令にアクセスするための16ビット 値だ。これは0000h から始まり、 HLT 命令に出会うまで順次増加していく。 ・STA または LDAのオペコードに続く2バイト。 2つを合わせて16ビット

453

のアドレスが構成される。

・HとLのレジスターが構成する16ビットアドレス。 たとえば、 これは MOV A,M 命令で使われる。 このように使用される場合、 HLはレジスター ペアと呼ばれる。

3 バイト累積加算器では、 16ビットのカウンターを用いてメモリーを順次ア クセスする方式を使った。 私が作っている CPU では、こうしたカウンターは使 わないつもりだ。 第24章で説明するように、 一部の命令はプログラムカウン ターを別のアドレスに設定できる。 このような理由から、プログラムカウンター は16ビットラッチとする。 ただし通常はメモリーから命令バイトが取り出され たあとに値が1つ増加するように振る舞う。

プログラムカウンターの全体像を示そう。

クロック Clk 16ビットラッチ 16ビットトライステートバッファ En イネーブル

これらのデータパスは、 16ビット値を表すため、 以前の図よりも広く表現さ れていることに注意しよう。 上部の入力と下部の出力の両方がアドレスバスに接 続されている。 アドレスバス上の任意の値をクロック入力でラッチに保存し、 ラッチ内の値をイネーブル信号によりアドレスバス上で読み取り可能にできる。 STA 命令とLDA 命令の場合、 オペコードに続く2バイトが命令ラッチ2と 命令ラッチ3に格納される。 つまり、 それらのラッチもトライステートバッファ を介してアドレスバスに接続する必要がある。

レジスターペアHLによるメモリーアドレス指定が行われる MOV 命令の場 合には、ラッチHとラッチLの値もアドレスバスに接続する必要がある。 レジ

454

第22章 レジスターとバス 455

スターアレイを構築したときには、 この要件は全く考慮しなかった。 よって私の 設計したレジスターアレイは今のところ、レジスターHとレジスターLはデー タバスにしか接続していない。

さらに、もう2つの命令を紹介しよう。

命令

説明

オペコード

INX HL HL レジスターペアの値を1増加 [インクリメント] させる 23h DCX HL HL レジスターペアの値を1減少 [デクリメント] させる 2Bh

A

INX 命令は、レジスターペアHLの16ビットの値に1を加算 [インクリメント] する。 DCX 命令は、値から1を減算 [デクリメント] する。

これらの命令はどちらも便利だが、 特に INX が非常に有用だ。 たとえば、 メ モリーにアドレス 10000h から順に格納されている5バイトがあり、それらを足 し合わせたいとする。 HとLのレジスターを一度設定し、各バイトにアクセス したあとに値をインクリメントするだけでよい。

456

0000h: 2Eh MVI L, 00h

100h

|26h MVI H10h

10h

7Eh MOV A, M

23h INX HL

| 86h ADD M

|23h INX HL

86h ADD M

|23h INX HL

86h ADD M

23h INX HL

86h ADD M

32h STA 0011h

11h

00h

|76h HLT

0011h:

合計値が格納される場所

ALU には、 結果がゼロの場合、 結果がマイナスの場合、 加算や減算により キャリーが発生した場合などを示すフラグがあったことを思い出そう。 INX 命 令と DCX 命令の影響を受けるフラグはない。

(インテル 8080 では、 BC とDEのレジスターペアに対するINX 命令と DCX 命令も実装されているが、 これらはあまり有用ではないので、 私のCPU には実装しない。 インテル 8080 にはまた、 HLでアドレス指定されたメモリー と、7つのレジスターとメモリーのすべてに対して、8ビットのインクリメント とデクリメントを行う INR 命令と DCR 命令も実装されているが、これらも実 装しない。)

INX 命令と DCX 命令が 16ビットのインクリメントとデクリメントを実行す るには、いくつかの回路の追加が必要だ。

プログラムカウンター (メモリーの命令にアクセスするための16ビットの値

第22章 レジスターとバス 457

を格納するラッチ) も、 メモリーから命令を読み出すたびにインクリメントする 必要があることは前述した通りだ。 ここでも16ビット値のインクリメントが必 要になる。

インクリメントとデクリメントの回路は、1を足したり引いたりするだけなの で、加算器や減算器よりも単純だ。 どのようなものかを想像してもらえるよう に、8ビット版を示そう。 添え字のあるIは入力、 添え字のある0は出力だ。 Dec 入力信号を0にすると値がインクリメントされ、 1にすると値がデクリメン トされるように設定されている。

16 14 13 12 Io Dec 07 06 Os 04 03. O₂ 0₁

では、このXOR ゲートとAND ゲートの集合体を、 1ずつ増減する値を格納 する 16ビットラッチと、 増減した値を提供するトライステートバッファを含む、 より大きなコンポーネントで置き換えることにしよう。

458 |

クロック Clk 16ビットラッチ 16ビットインクリメンタ・ デクリメンタ回路 Dec 16ビットトライステートバッファ En デクリメント インクリメント

このコンポーネントをインクリメンタ・デクリメンタと呼ぶことにしよう。 プ ログラムカウンターと同様、 ラッチへの16ビット入力とトライステートバッ ファからの16ビット出力は、いずれもアドレスバスに接続されている。デクリ メントまたはインクリメントのどちらの入力信号もトライステートバッファを有 効にできるが、 デクリメント信号はラッチの値をデクリメントし、インクリメン ト信号はラッチの値をインクリメントする。

16ビットアドレスバスは、 主にRAMにアドレスを提供するが、 CPU の構成 要素間で16ビット値を移動させる機能も必要になる。

たとえば、 プログラムカウンターは、メモリーから命令をアクセスする際、 RAM のアドレスを指定するために使われる。 プログラムカウンターの値に基づ いて命令にアクセスしたのち、 その値をインクリメンタデクリメンタに転送し てインクリメントし、プログラムカウンターラッチに書き戻す必要がある。

もう1つ例を挙げるなら、 MOV A,M 命令は、レジスターペアHLを使用し て、メモリーのバイトにアクセスする。 しかし、 しばしばこのあとに INX HL 命令が続き、 HLの値がインクリメンタデクリメンタに入力されてだけ増加 し、 レジスターペア HLに書き戻される。

ついに、ここまで避けてきた問題から逃れられなくなった。 先ほどお見せした レジスターアレイはとてもすっきりしていてエレガントで素敵だったが、Hと

曲

第22章 レジスターとバス 459

Lの値を16ビットアドレスバスに乗せる方法はなかった。 次の図はそれを修正 したものだ。

入力セレクト デコーダーから 45 出力セレクト デコーダーから 45 16 TRI TRI TRI HLセレクト H Latch L Latch HLクロック TRI TRI TRI ┣HLイネーブル

右端の上下にある16ビットの入力と出力に注目しよう。 その両方がアドレス バスに接続され、 HとLのレジスターに16ビットの値を保存したり、 それを取 り出したりできる。

HとLのレジスターを強化するこの図には、 レジスターアレイに追加された いくつかの新しい信号とコンポーネントが示されている。

右側のHL セレクト信号は、 最上段の新しいトライステートバッファを制御 する。 この信号は、HとLのレジスターへの入力がレジスターアレイへの通 常の入力からくるのか、 16ビット入力からくるのかを決定する。

右側のHL クロック信号は、 アドレスバスからの値を保存できるようにラッ チのクロック入力に追加された2つのOR ゲートに入る。

・右側のHL イネーブル信号は、新しい16ビットトライステートバッファを 有効にし、 HおよびLラッチの合成出力がアドレスバス上に表示されるよう にする。

なんて複雑なんだ! しかし、 コンピュータを構築するのが簡単だとは、 これま で誰も言ってはいない。

レジスターアレイのインタラクティブ版は、 ウェブサイト (www. Code Hidden Language.com) で見ることができる。

これらの16ビットコンポーネントを16ビットアドレスバスに接続しよう。 次のブロック図は、 上部のデータバスの一部が命令ラッチと命令ラッチ3に 入力され、その出力がアドレスバスに接続されたトライステートバッファに合成 される様子を示している。

DO 命令ラッチ2 命令ラッチ3 トライステートバッファ RAM Address プログラムカウンター インクリ・デクリメンタ レジスターアレイ

見た目にも幅が広い16ビットのアドレスバスは、入力と出力の両方で図下部 のコンポーネントを回り、 RAMへのアドレスも提供する。

460

第22章 レジスターとバス 461

先ほどのデータバスのブロック図と同様、 このアドレスバスのブロック図で も、重要な信号がいくつか省略されている。 トライステートバッファを有効にす る信号と、このバスの値を各種ラッチに保存する信号だ。

これらの信号が適切に連携し同期されることで、 CPU は命令を実行する。 こ れらの信号こそがコンピュータの脈動する生命力であり、1つの章をまるごと使 うのにふさわしい。 それが次の話題だ。



第23章 CPU 制御信号

エンジニアの世界には、「プロジェクトの最後の1割には、 全体の9割の作業 が必要だ」という古い格言がある。 気が重くなる格言だが、 ぜひ心に留めてほし い。 さて、ここまででコンピュータの構築はかなり進んだが、まだ完成はしてい ない。 残された仕事は9割ではないが、 ゴールは見かけよりももう少し遠いか も知れない。

ここまで設計してきた中央演算処理装置 (CPU) は、 インテル 8080 マイク ロプロセッサをベースにしている。 この CPU の主要部分を構成するのが、 前2 章で説明した算術論理演算装置 (ALU) とレジスターアレイだ。 ALU は、 バイ トに対して算術演算と論理演算を行う。 レジスターアレイは、 A、B、C、D、 E、 および H L という文字で識別される7つのレジスター用のラッチを持つ。 加えて、 命令バイトと、いくつかの命令に続く1バイトまたは2バイトの追加 バイトを保存するために、 3つのラッチを追加する必要があることも見てきた。

これらのコンポーネント [部品] はランダムアクセスメモリー(RAM) と2つ のバスで接続される。 8ビットのデータバスはコンポーネント間でバイトを運ぶ もので、16ビットのアドレスバスはメモリーアドレスに使用される。 前章では、 RAMのアドレスを保持するプログラムカウンターや、 16ビットのメモリーア ドレスをインクリメントしたりデクリメントするインクリメンタ・デクリメンタ も説明した。

2つのバスは、コンポーネント間の主要な接続を提供するが、 これらのコン ポーネントはまた、 より複雑な制御信号にも接続されている。 制御信号と呼ぶの

は、メモリーに格納された命令を実行する際、 コンポーネントが連携して動作す るための制御を行うからだ。

制御信号の多くは一般に、 次の2種類に分けられる。

・2つのバスのうちの1つに値を乗せる信号

●2つのバスのうちの1つから値を保存する信号

本章では、バスに乗せる値とバスから取り出して保存する値を説明する。

バスに値を乗せる信号は、 トライステートバッファのイネーブル入力に接続さ れる。 トライステートバッファは様々なコンポーネントの出力をバスに接続する ためのものだ。 一方、バスから値を取り出して保存する信号は通常、 バスとコン ポーネントを接続する様々なラッチのクロック入力を制御する。 唯一の例外は、 データバス上の値を RAM 書き込み信号でメモリーに保存する場合である。

これらの信号が同期することで、 CPU は、 メモリーに格納された命令を実行 できる。これが、8ビットや16ビットの値が、 CPU の各コンポーネントやメモ リーの間を移動する仕組みだ。 メモリーに格納されたコードがコンピュータの ハードウエアを制御するための基本的な方法でもある。このプロセスを、本書の サブタイトルでほのめかしたように、 算術と論理で精緻に制御された踊りを舞う からくり人形およびその使い手として視覚化できるかもしれない。 CPU の制御 信号は、その操り糸なのだ。

ここでは、6つの主要なコンポーネントをデータバスとアドレスバスに接続す る方法と、それらが必要とする制御信号を説明する。

最初のコンポーネントのメモリーについて見ていこう。 メモリーのアドレス入 力は、 16ビットのアドレスバスに接続されている。 また、 メモリーはデータ入 力 (Data In) とデータ出力 (Data Out) を通じて、8ビットのデータバスに接 続されている。

464

第23章 CPU 制御信号

Write アドレスバス データバス ↓ Address 64 x 8 RAM Data In Data Out データバス Enable

2つの制御信号は、データバス上の値をメモリーに書き込む 「書き込み (Write)」 と、 RAM データ出力のトライステートバッファを有効にしてデータ バス上に値を乗せる「イネーブル (Enable)」 だ。 このメモリーアレイにコント ロールパネルを付けて、 人間がメモリーにバイトを書き込んだり調べたりするこ ともできる。

最も複雑な構成要素は、 間違いなく第22章に登場したレジスターアレイだ。 これはRA と略されることもある。

データバス アドレスバス S12 S1 Slo In SO2SO SO In 16 RA Clock HL Select RA Enable レジスターアレイ (RA) HL Clock Acc Clock Acc Enable HL Enable Acc Out Out 16 ALU データバス アドレスバス

レジスターアレイの上部には、 2組のセレクト信号 (SIとSO) がある。 SI 信号は、どのレジスターがデータバスの値を保存するかを決定する。 その値がい つ保存されるかは、左側のRA クロック (RA Clock) 信号で決まる。 一方、 SO 信号と左側のRA イネーブル (RA Enable) 信号により、 どのレジスターの 値がデータバスに乗せられるかが決まる。

465

前章で見たように、このレジスターアレイは2つの意味で複雑だ。 まず、 ア キュムレータ用に2つの追加制御信号を実装しなければならない。 これらは Acc と略されることがある。 Acc クロック (Acc Clock) 信号は、 データバス 上の値をアキュムレータに保存し、 Accイネーブル (Acc Enable) 信号は、 ア キュムレータの値をデータバスに出力するトライステートバッファを有効にす る。

次に、レジスターアレイのレジスターHとレジスターLも、右側に示されて いる3つの制御信号によりアドレスバスに接続されている。 HL セレクト (HL Select)は、レジスターHとレジスターLへの入力としてアドレスバスを選択 する。 HL クロック (HL Clock) は、 アドレスバスの内容をレジスターHとレ ジスターLに保存する。 HL イネーブル (HL Enable) は、 レジスターHとレ ジスターLの内容をアドレスバスに出力するトライステートバッファを有効に する。

第21章で紹介した ALU には、F、Fi、F2 の入力があり、 ALUが加算、減 算、 比較、 論理機能のどれを実行するかを制御する。

RAから データバス F2 F1 Fo A B クロック 算術論理演算装置 (ALU) イネーブル フラグ Out CY,Z, S データバス

ALUの入力 B と出力 (Out) はともにデータバスに接続されているが、入力 Aはレジスターアレイ (RA) の Acc に直接接続されていることに注目しよう。 ALU は、 実行されている算術または論理演算に基づいて設定されるキャリーフ ラグ (CY) ゼロフラグ (Z)、およびサインフラグ (S) を保存するために、や や複雑になっている。

ALUはまた、算術・ 論理の結果をラッチに保存する (フラグは別のラッチに

466

第23章 CPU 制御信号 467

保存する) クロック信号を実装し、 ALUの結果をデータバスに乗せるトライス テートバッファを有効にするための、イネーブル信号を実装している。

また別の16ビットラッチには、 メモリー内のバイトのアドレスを指定するた めに使われるプログラムカウンターの現在値が保持される。

アドレスバス

→ クロック

In

プログラムカウンター(PC)

リセット

イネーブル

Out

アドレスバス

プログラムカウンターは、PCと略されることもある。 PCは、3つの制御信号 を備える。 クロック信号は、 アドレスバスの16ビット値をラッチに保存する。 イネーブル信号は、 トライステートバッファを有効にして、 ラッチの内容をアド レスバスに乗せる。 左のリセット信号は、 ラッチの内容をすべて0にして、アド レス0000h で指定されるメモリーからバイトのアクセスを開始させる。

さらに3つの8ビットラッチで、 最大3バイト長の命令を保存する。 これら は、次のような箱に収められている。

データバス

ラッチクロック ラッチ2クロック ラッチ3クロック

In

ラッチ2イネーブル

命令ラッチ

ラッチ10ut

ラッチ20ut

ラッチ23イネーブル

オペコード

ラッチ2&30ut

データバス

アドレスバス

命令の中には、命令コードだけで構成されるものもあるが、 そのほかには 1バイトまたは2バイトの追加バイトが続く。 左の3つのクロック信号は、命令 を構成する最大3バイトを保存する。

1バイト目が命令コードで、 しばしばオペコードと呼ばれる。 命令が2バイト 目を持つ場合、 そのバイトは右の「ラッチ2イネーブル」 信号でデータバス上 に出力することができる。 命令コードのあとに2バイトが続く場合、 それは 16 ビットのメモリーアドレスとなり、 右の 「ラッチ2&3 イネーブル」 信号でア ドレスバス上に置くことができる。

最後のコンポーネントは、 16ビットの値をインクリメントまたはデクリメン トできる回路だ。 Inc-Dec と略記されることもある。

アドレスバス

→ クロック

In

インクリメンタ・デクリメンタ

インクリメントイネーブル

デクリメントイネーブル

Out

アドレスバス

クロック信号は、アドレスバスから16ビットの値をインクリメンタデクリ メンタラッチに保存する。 右側の2つのイネーブル信号は、 アドレスバス上で インクリメント値またはデクリメント値のいずれかを有効にする。

これらの制御信号がどのように調整されなければならないかを実感してもらう ために、6つの命令からなる小さな8080 プログラムを考えてみよう。 1バイト だけの命令もあれば、オペコードに続いて1バイトまたは2バイトの追加を必 要とする命令もある。

468

第23章 CPU 制御信号

0000h:3Eh MVI A,27h |27h 0002h: 47h MOV B, A. 0003h: C6h| ADI 61h |61h 表 0005h: 80h ADD B 0006h:32h STA 000Ah 0Ah 100h 0009h: 76h HLT 0000Ah: 合計値が格納される場所

このプログラムはあまり意味のある仕事をしない。 最初の命令は、 値27hを レジスターA (アキュムレータ) に移動する。 MOV 命令により、 その値がレジ スターBにコピーされ、 次に値61hがアキュムレータに加算されて、結果とし て値 88h がアキュムレータに保存される。 そこにレジスターBの値が加算され、 アキュムレータの値は AFh になる。 STA 命令は、その値をメモリー上のアドレ コス000Ah に保存する。これ以上何もすることはないので、 HLT 命令で CPU を 停止する。

この命令を実行するために、 CPU が何をする必要があるのかを考えよう。 CPUはプログラムカウンターと呼ばれる値を使って、 メモリーのアドレスを決 止め、命令を命令ラッチに移動させる。 プログラムカウンターは、メモリーの最初 の命令にアクセスするために、 値 0000h に初期化される。 最初の命令は MVI (即値転送) で、 続く値 27h をアキュムレータに移動させる。

最初の命令 (MVI A, 27h) を処理するだけで、合計5つのステップが必要と なる。 各ステップでは、アドレスバスに何かを乗せて別の場所に保存したり、 データバスに何かを乗せて別の場所に保存したり、あるいはその両方を行う。

最初のステップでは、プログラムカウンターの値0000h で示される RAM に アクセスして、メモリーから値 3Ehを読み出して命令ラッチに格納する。 こ のためには、アドレスバスとデータバスの両方を含む4つの制御信号が必要に なる。

469

470 |

●プログラムカウンターイネーブル:プログラムカウンター値をアドレスバス 上に乗せる。 その値は0000h である。

・RAM データ出力イネーブル: そのアドレスに保存された RAM の値をデー タバスに出力する。 その値は3Eh である。

●インクリメンタ・デクリメンタクロックアドレスバス上の値をインクリメ ンタデクリメンタに保存する。

命令ラッチクロック:データバスの値を命令ラッチに保存する。

第2ステップでは、プログラムカウンターをインクリメントする。 これには アドレスバスだけが関係する。

インクリメントイネーブル: インクリメンタ デクリメンタのインクリメン トされた値 (1増加した値)をアドレスバスに乗せる。 その値は現在0001h である。

●プログラムカウンタークロック: そのインクリメントされた値をプログラム カウンターに保存する。

この段階ですでに、 最初の命令バイトは命令ラッチに保存されていて、 後 続のステップを制御するのに使用できる。 この場合、 第3ステップと第4ステッ プは、メモリーアドレス 0001hのバイトにアクセスして命令ラッチ2に保存す る以外は、 第1ステップおよび第2ステップと同じだ。

このようなメモリーから命令バイトを読み出すステップを命令フェッチと呼 ぶ。 命令フェッチの目的は、 メモリーに置かれた命令バイトにアクセスし、命令 ラッチに保存することだ。 命令MVIA, 27h を読み込んだことにより、 命令ラッ チ2には値 27h がある。 その値をアキュムレータに移動させる必要がある。 こ れが第5のステップで、 命令の実行と呼ばれる。

・命令ラッチ2イネーブル: 命令ラッチ2の値をデータバスに乗せる。 ●アキュムレータクロック:データバスの値をアキュムレータに保存する、

これらの5つのステップはいずれも、多くてもアドレスバスで1つ、データ バスで1つの値だけを扱っていることに注意しよう。 2つのバスのうちどちらか 1つに置かれた値は、別の場所に保存される。

第23章 CPU 制御信号 471

2つ目の命令である MOV B,A を見ていこう。この命令は1バイトの長さし かないので、命令フェッチに必要なのは次の2ステップだけだ。

・レジスターアレイイネーブル: レジスターアレイの値をデータバスに乗せ る。

・レジスターアレイクロック:データバスの値をレジスターアレイに保存す る。

ちょっと待った! この実行ステップの説明では、レジスターアレイにのみ言及 していて、 レジスターAやレジスターBには言及していない! それはなぜか? 実は単純な話だ。 8080 の MOV 命令を構成するビットを次に示そう。

01DDDSSS

DDDはデスティネーションレジスター、 SSSはソースレジスターだ。 オペコー ドは命令ラッチに保存されている。 レジスターアレイには2組の3ビットセ レクト信号があり、 どのレジスターがソースで、 どのレジスターがデスティネー ションかを決定する。 もうおわかりのように、これらの信号は命令ラッチに 格納されたオペコードからくるので、レジスターアレイを有効にしてラッチする だけで、 実行が完了する。

次に即値加算命令 (ADI) がくる。

ADI 61h

これは、次のビットからなる8つの命令のうちの1つだ。

11FFF110

FFFはその命令が実行する機能を意味する。 加算、キャリー付き加算、減算、 ボロー付き減算、 AND XOR, OR、 そして比較だ。 ALU には、これらの値 に対応する3ビットの機能入力があったことを思い出そう。 つまり、命令ラッ チ」の中のオペコードから、3つの機能ビットを直接ALU に送り込むことがで きる。

ADI命令の2バイトがフェッチされたのち、この命令の実行にはさらに2つ のステップが必要となる。 以下がステップ1だ。

・命令ラッチ2イネーブル: 61hの値をデータバスに乗せる。 •ALU クロック: ALUの結果とフラグを複数のラッチに保存する。

その結果をアキュムレータに移動させるために、 実行のステップ2が必要だ。

・ALU イネーブル ALUの結果をデータバスに乗せる。

・アキュムレータクロック その値をアキュムレータに保存する。

次にくる ADD命令も同様に、 2つの実行ステップが必要となる。 第1ステッ プが以下である。

・レジスターアレイイネーブル レジスターB をデータバスに乗せる。 •ALU クロック: 加算結果とフラグを保存する。

第2の実行ステップは、 ADI命令の実行と同じだ。

さて、 STA命令は、 命令フェッチに6つのステップを必要とする。 STA 命令 に続く2バイトは、命令ラッチ2と命令ラッチ3に格納される。 実行ステップ では、以下の制御信号が必要となる。

•命令ラッチ 2&3 イネーブル:2番目と3番目の命令バイトをアドレスバス 上に置き、 RAM をアドレス指定する。

アキュムレータイネーブル: アキュムレータの値をデータバスに乗せる。 ・RAM 書き込み: データバス上の値をメモリーに書き込む。

HLT 命令は、 CPU がそれ以上の命令を実行するのを止めるという意味で、 ユ ニークに振る舞う。 その実装は本章の後半に回そう。

これまで説明してきたステップは、サイクルとも呼ばれる。 ちょうど洗濯機の 「洗い」「すすぎ」 「脱水」 のようなイメージだ。 専門的には、これらはマシンサイ クルと呼ばれる。 私が作っている CPU では、命令バイトをメモリーからアクセ スする1サイクルのあとで、 必ずプログラムカウンターをインクリメントする 別のサイクルが続いている。 したがって、 命令が1バイト、 2バイト、3バイト のいずれかによって、 CPUは2サイクル、 4サイクル、 6サイクルを実行しな ければならない。

命令の実行には、 命令の種類によって、 1または2マシンサイクルが必要とな

472

第23章 CPU 制御信号 1473

る。 これまで紹介したすべての命令の最初の実行サイクルで起こることを以下に 示す。

第1実行サイクル 命令 16ビットアドレスバス 8ビットデータバス MOV r,r MOV r,M HLイネーブル MOV M, r HLイネーブル |MVI r, data MVI M, data HLイネーブル LDA 命令ラッチ23イネーブル STA 命令ラッチ23イネーブル ADD ... ADD M... HLイネーブル ADI data ... レジスターアレイイネーブル レジスターアレイクロック RAMデータ出力イネーブル レジスターアレイクロック レジスターアレイイネーブル RAM 書き込み 命令ラッチ2イネーブル レジスターアレイクロック 命令ラッチ2イネーブル RAM 書き込み RAMデータ出力イネーブル アキュムレータクロック |アキュムレータイネーブル RAM書き込み |レジスターアレイイネーブル ALU クロック RAMデータ出力イネーブル ALU クロック 命令ラッチ2イネーブル ALU クロック INX/DCX HL HLイネーブル インクリメンタ・デクリメンタクロック

474

3列のうち、1列目の…」に注目してほしい。 ADD 命令が書かれた行には、 実は ADC SUB、 SBB、 ANA、 XRA、 ORA CMP も含まれ、 ADI命令が 書かれた行には、 実は ACI SUI SBI、 ANI XRI ORI CPI も含まれてい る。

表の下の4行は、2つ目の実行サイクルも必要とする命令だ。 次の表は、それ らの第2実行サイクルで行わなければならないことを示したものだ。

第2実行サイクル 命令 16ビットアドレスバス ADD ... ADD M... ADI data 8ビットデータバス ALUイネーブル アキュムレータクロック ALUイネーブル アキュムレータクロック ALUイネーブル アキュムレータクロック INX HL インクリメントイネーブル HLセレクト HLクロック DCX HL デクリメントイネーブル HLセレクト HLクロック

これらをすべて実現するには、 オペコードをデコードして、すべてのコンポー ネントとRAM を操作する制御信号に変換する必要がある。 こうした制御信号 は、トライステートバッファ、 各種ラッチのクロック入力、 RAMの書き込み入 力、その他のいくつかの入力をイネーブルにする。

本章の残りの部分では、この方法を紹介しよう。 いくつかのステップといくつ かの異なる戦略を必要とするプロセスとなる。

まずは、すべての命令のオペコードを次ページに示す。

第23章 CPU制御信号

オペコード

命令

475

MOV r, r

MOV r, M

MOV M, r

HLT

MVI r, data

MVI M, data

LDA addr

01DDD SSS

01DDD110

01110 SSS

01110110

0 0 DDD110

ADD, ADC, SUB, SBB, ANA, XRA, ORA, CMP r

ADD, ADC, SUB, SBB, ANA, XRA, ORA, CMP M

INX HL

00110110

ADI, ACI, SUI, SBI, ANI, XRI, ORI, CPI data

10 FFFS SS

STA addr

10 FF F110

DCX HL

11 F F F 110

0 0 1 0 0 0 1 1

0010 101 1

00111010 0 0 1 100 10

これらのオペコードのSSSとDDD は、 次の表に示すように、 特定のソース またはデスティネーションのレジスターを参照していることを思い出そう。

SSS DDD レジスター 000 B 001 C 010 Ꭰ 011 E 100 H 101 L 111 A

ビット列110がこのリストにないのは、このビット列はレジスターHLによっ てアドレスされるメモリーを意味しているからだ。

算術論理命令では、FFF ビットは機能を表し、8つの算術論理演算のうち

476

の1つを指す。

CPU の制御回路の中で簡単なのは、 命令ラッチとレジスターアレイ (RA) の入力セレクト、 出力セレクト、 ALUの機能セレクトを接続する部分だ。

命令ラッチオペコード C C6 C C C Cz CI C RA出力セレクトやALU機能セレクトへ RA入力セレクトへ

Cは 「code [コード]」 の意味である。 このラッチの出力ビットCo Ci、C2は、 レジスターアレイの入力セレクトに直接送られ、 ビット C3 Ca、 Csはレジス ターアレイの出力セレクトとALUの機能セレクトに送られる。 これは、オペ コードのパターンを利用する1つの方法だ。

ほかにもオペコードにはいくつかのパターンが見いだせる。 たとえば、ビット 01 で始まるオペコードは、 HLT 命令である76h を除いて、 すべて MOV 命令 だ。 すべての算術命令と論理命令 (ADI、 ACI などの即値命令を除く)は、ビッ ト10で始まる。

オペコードのデコードの最初のステップは、上に示した命令ラッチの出力 ビットを、 1つの2-to-4 デコーダーと2つの3-to-8 デコーダーという3つのデ コーダーに接続することだ。 これらのいくつかは命令に直接対応し、いくつかは 命令のグループに対応した追加の信号を生成するために使用される。

第23章 CPU 制御信号

C7 C6 C5 C C C2 C1 Co 2-to-4 3-to-8. 3-to-8 01234567 01234567 ・転送グループ 算術・論理グループ メモリーソース メモリーデスティネーション 即值転送 -ADI data,... INX HL - DCX HL LDA -STA

右上の転送グループ信号は、ビット01から始まる命令のグループに対応し、

算術論理グループ信号は、 ビット 10から始まる命令のグループに対応する。 レジスター間でバイトを移動させる MOV 命令と、レジスターとメモリー間 で値を移動させる MOV 命令を区別することが重要だ。 これらのメモリー関連 の命令は、ソースとデスティネーションの値が110 であることで識別される。 この回路のメモリーソースとメモリーデスティネーションの信号は、ソースビッ トとデスティネーションビットが110になったことを示す。 最後に、 即値転送 は、00で始まり 110で終わる命令だ。

回路図の右上にあるこれら5つの信号は、さらにデコードされる。

477

転送グループ メモリーソース メモリーデスティネーション 即値転送 -MOV r, r -MOV r,M. MOV M, г. HLT MVI r, data 算術・論理グループ MVI M, data ・ADD r,... ・ADD M...

これで すべての命令または類似の命令のグループが、 信号で表現されるよう になった。これらの信号は、オペコードが命令ラッチに保存されるときに利 用でき、 その命令処理を制御するためにさらに使用することもできる。

次に、このオペコードを使用して、 メモリーから何バイトの追加命令をフェッ チしなければならないか、 また、 命令の実行に何マシンサイクルが必要かを決め なければならない。

478

第23章 CPU 制御信号

479

MVI R, data MVI M, data ADI data, ... LDA STA ADDr. ADD M, 2バイトフェッチ 1バイトフェッチ 1バイトフェッチ ・3バイトフェッチ ・2サイクル実行 ・1サイクル実行

あるオペコードがこれらの命令のいずれにも該当しない場合はどうなるだろ う?たとえば、 NOP という 8080 特有の命令についてはまだ触れていないが、 これは「何もしない」という意味で、 オペコードは 00h となる。

もし、左側の入力信号がどれも1でなければ、 OR ゲートの出力はすべて0 と なり、 右側の信号は1バイトのフェッチと1サイクルの実行を示すことがわか る。

CPU の基本的なタイミングは、 第20章の389ページで紹介した小さな回路 を拡張したものだ

480 |

リセット Reset 停止 Clk Q フリップフロップ D Reset Reset • Clk Clk オシレーター フリップフロップ フリップフロップ

サイクルクロック

パルス

左側のオシレーターは、0と1を交互に、 通常はとても高速に出力する装置だ。 これが CPU を動かしている。 CPU の鼓動みたいなものだ。

上部に表示されているリセット信号は、 CPU の外から送られてくる。 通常は、 CPU を再起動するために、 コンピュータを使っている人間が操作する。 リセッ ト信号は通常0だが、 これが1になると (たとえば人がリセットと書かれたボ タンを押したときなど)、 CPUは停止し、 すべてが最初に戻る。

この回路では、リセット信号により3つのフリップフロップがリセットされ、 すべてのQ出力が0、 すべての出力Qが1になる。 そしてリセット信号が0に 戻ると、 フリップフロップは正常に動作するようになり、 CPU が動作を開始す る。

CPU がリセットされたあとは、一番上のフリップフロップの出力は1にな る。これはAND ゲートの2つの入力のうちの1つで、オシレーターが図の下 側にある2つのフリップフロップのクロック入力を制御できるようにする。

上部の停止信号は、 HLT 命令が実行されたことを示す。 これにより、 一番上の フリップフロップの出力が0になり、オシレーターによる CPU の制御が実質

第23章 CPU 制御信号 481

的に停止する。 CPU はリセット信号で 「非 『停止』 状態」 にすることができる。 CPU が停止していない場合には、図の下にある2つのフリップフロップは、 次のタイミング図に示されているサイクルクロックとパルスと書かれた2つの 信号を生成する。

オシレーター サイクルクロック パルス

サイクルクロックの各サイクルは、マシンサイクルに対応する。 サイクルク ロックがローからハイになる (0から1になる) たびに、 新しいマシンサイクル が始まる。

たとえば、 先に示した小さなサンプルプログラムでは、 最初の命令は MVI だった。 この命令には5マシンサイクルが必要だ。

オペコードを取得する (Fetch 1) ・プログラムカウンターをインクリメントする (PC Incr.) • オペコードに続くバイトを取得する (Fetch 2) プログラムカウンターをインクリメントする (PC Incr.) ・命令を実行する (Execute)

以下に5つのサイクルを、 上で示したラベルとともに示す。

オシレーター クロックサイクル パルス Fetch 1 PC Incr. Fetch 2 PC Incr. Execute

これらのサイクルではすべて、 異なるトライステートバッファがイネーブルに なる。 これにより、アドレスバスとデータバスに異なる値が乗ることになる。 た

とえば、フェッチサイクル1では、アドレスバス上でプログラムカウンターが イネーブルになり、 データバス上でRAMデータ出力がイネーブルになる。 パ ルス信号は、命令バイト1ラッチのクロック入力と、インクリメンタ・デクリ メンタのクロック入力を制御するために使用される。

プログラムカウンターのインクリメントサイクル中、 インクリメンタ・デクリ メンタの出力はアドレスバス上にあり、 パルス信号はそのインクリメントされた 値をプログラムカウンターに保存するために使用される。

先ほど、 命令が1バイト、2バイト、 3バイトのいずれで構成されているか、 命令が1サイクルまたは2サイクルのどちらで実行する必要があるかを示す回 路を紹介した。

次のステップでは、オペコードのデコードから現在のサイクルの種類を示す信 号を生成する。 それが1回目、2回目、 または3回目のフェッチサイクルなの か、もしくはプログラムカウンターのインクリメントサイクルなのか、あるいは 1回目または2回目の実行サイクルなのかを示す信号だ。

この仕事は、次のようなやや複雑な回路が担っている。

482

リセット

第23章 CPU 制御信号

サイクルクロック -

Reset

24ビットカウンター

Q3

Qo

Q2 Qi

D

D2 D₁ Do

4-to-16 デコーダー

9876543210

1バイトフェッチ

3バイトフェッチ

・フェッチサイクル 1

2バイトフェッチ・

フェッチサイクル2

1バイトフェッチ

・フェッチサイクル3

・PCインクリメント

2サイクル実行

Clk

1 サイクル実行

-実行サイクル 1

・実行サイクル2

左側が入力、右側が出力となる。これらの入力と出力は、 時折似たような名前 を持つため、この図を初めて見たときに少々混乱するかもしれない。 たとえば、 「2バイトフェッチ」 入力は、命令が2バイトの長さであることを示す。 そして 「フェッチサイクル2」出力は、命令の2番目のバイトが現在フェッチされてい ることを示す。

483

一番上のリセット信号は、 前の回路のリセット信号と同じで、 CPU を使う人 間が最初から起動するために使う。 また、4ビットカウンターは、回路下部から くる信号でリセットすることも可能だ。

サイクルクロックは、カウンターを進める。 4ビットカウンターなので、 2進 数の0000 から 1111 まで、 つまり10進数の0から15まで数えることができ る。この出力は、カウンターの下にある 4-to-16 デコーダーに直接送られる。 カ ウンターからの2進数は、16個の異なる連続した出力としてデコードされうる が、この回路では最初の9つだけを使用する。 これらの出力はそれぞれ、フェッ チサイクル、 プログラムカウンターインクリメントサイクル (図では 「PC イン クリメント」と略記)、 実行サイクルなどの、 新しいマシンサイクルを示す。 デコーダー出力が0、 1、2、3･･ と進むにつれて、 次の信号が生成される。

0.フェッチサイクル1

1.プログラムカウンターインクリメント

2.フェッチサイクル2 (ただし、 命令が1バイトフェッチでない場合のみ) 3.2または3バイトフェッチ時のプログラムカウンターインクリメント 4.フェッチサイクル3 (ただし、 3バイトフェッチ信号が1の場合のみ) 5.3バイトフェッチ時のプログラムカウンターインクリメント

フェッチサイクル信号と最初のプログラムカウンター(PC) インクリメント 信号は常に生成される。 その後、 オペコードがフェッチされ、 命令ラッチに ロードされ、部分的にデコードされて、 左側の入力信号はすべて利用可能とな る。

1つの命令には、最大で3回のフェッチサイクルと、 それぞれに続く各1回の PC インクリメントサイクル、 そして2回の実行サイクルの合計8回が必要で、 これらはデコーダー出力0~7に対応する。

複数バイトのフェッチと複数の実行サイクルの組み合わせを考慮するため、ロ ジックはやや複雑だ。 たとえば、 右側の 「実行サイクル1」 信号は、1バイトの フェッチを必要とする命令の第3サイクルになるか、または2バイトのフェッ チを必要とする命令の第5サイクルになるか、 または3バイトのフェッチを必 要とする命令の第7サイクルに対応する。

一番下にあるリセットロジックが一番複雑だ。 これは、1回のフェッチサイク

484

第23章 CPU 制御信号 485

ルと1回の実行サイクルを必要とする命令では4サイクル目、 3回のフェッチサ イクルと2回の実行サイクルを必要とする命令では9サイクル目で発生する可 能性がある。

3回のフェッチサイクルの間、 プログラムカウンターは16ビットバス上で、 RAM データ出力は8ビットバス上で有効になる。 パルス信号は、 アドレスバス 上の値をインクリメンタデクリメンタに保存し、 データバス上の値を3つの 命令ラッチのうちの1つに格納するために使用される。 この目的のため、以下 の回路で、命令フェッチサイクル (ただしPC インクリメントサイクルは除く) 用のすべての信号を生成している。

フェッチサイクル1 フェッチサイクル2 フェッチサイクル3 PCイネーブル TRI RAM DO イネーブル TRI Inc-Decのクロック ・命令ラッチクロック 命令ラッチ2クロック ・命令ラッチ3クロック

1回目、2回目、3回目のフェッチにかかわらず、 アドレスバスではプログラ ムカウンターが、 データバスでは RAM データ出力がイネーブルになる。 3つの 場合とも、パルス信号は常にインクリメント・デクリメントラッチのクロック入 力を制御する。 3回のフェッチサイクルの間、 パルス信号は対応する命令ラッチ のクロックも制御する。

これらの信号のうちの2つにトライステートバッファ (TRI) があることに注 目しよう。 これは、ほかの回路 (これから出てくる回路) もまた、 RAM データ 出力 (RAM DO) トライステートバッファのイネーブル信号とインクリメン

パルス

ト・デクリメント (Inc-Dec) ラッチのクロック信号を制御しているかもしれな いからだ。 トライステートバッファの左側の信号は、入力信号とイネーブル信号 の両方を兼ねている

プログラムカウンターのインクリメントサイクルに必要な信号は、すべて次の 回路で処理される。

PCインクリメントサイクル

TRI

インクリメントイネーブル

パルス

TRI

PCクロック

これで、 命令フェッチサイクルとPC インクリメントサイクルに必要なすべて の信号が作成された。 残るのは、 実行サイクルの信号だけだ。 これらは、実行さ れるそれぞれの命令に依存するため、 より複雑になる。

483ページの大きな回路には、 「実行サイクル1」 と 「実行サイクル2」とラ ベルの付いた2つの出力信号がある。 この2つの実行サイクルは、以下の回路 に示すように、 EC1、 EC2 と略記できる。

実行サイクル1 (EC1) パルス 実行サイクル2 (EC2) 実行パルス1 (EP1) 実行パルス2 (EP2)

これらの2つの信号は、パルス信号と組み合わされ、 EP1 EP2 と略される2 つの実行パルス信号になる。

次の命令の処理は比較的単純だ。 CPU を停止させる HLT 命令である。

HLT

EP1

Halt

486

第23章 CPU 制御信号

左側のHLT 信号は478ページの命令デコーダーから、右側の停止信号は480 ページのオシレーター付き回路に送られる。

そのほかの命令と生成すべき信号の関係はかなり複雑なので、 面倒な論理ゲー トの多用は避けて、 第18章で見たようなダイオードマトリクス ROM をいくつ か使って処理するのが適切だろう。

最初のダイオードマトリクス ROM は、 第1 実行サイクルと第2実行サイク ルの両方で、 16ビットアドレスバスに関連するすべてのイネーブル信号とクロッ ク信号を処理する。

MOV r, M. MOV M, r MVI M, data・ ADD M ... INX HL DCX HL LDA STA + EC1 TRI EP1 TRI EC2- TRI EP2 TRI T HL 命令 Inc-Dec イネーブル ラッチ 2&3 クロック HL インクリメント デクリメント セレクト イネーブル イネーブル HL クロック イネーブル

下部の信号は、アドレスバス用のみであることに注意しよう。 8ビットデータ バス用の信号については、このあとすぐに説明する。 この図は、473ページと

487

474 ページの表にある16ビットアドレスバスの列に対応する。

図の左下にあるトライステートバッファ (TRI) は、 実行サイクル信号で有 効になる。 これは、最初の実行サイクルにおけるアドレスバス上の値を有効にす る。 レジスターHLでアドレス指定されたメモリーに関わる MOV MVI、算 術命令のすべては、 当然ながらレジスター HLを利用する。

INX 命令と DCX 命令で、 レジスター HL が有効になる。 これらはレジスター HLのインクリメントとデクリメントを行う命令だ。 LDA 命令と STA命令で は、バイトをロード [読み出し] またはストア [保存] するためのメモリーアドレ スは、命令ラッチ2および命令ラッチ3から取得する。

INX 命令と DCX 命令の場合、実行パルス 1 (EP1) 信号はレジスター HLの 値をインクリメンタ・デクリメンタラッチに保存する効果がある。

INX 命令と DCX 命令だけが、2回目の実行サイクルでアドレスバスに関与 する命令だ。 この2つの命令は、 レジスター HLのインクリメント値またはデ クリメント値がアドレスバス上に置かれることになる。 そして、実行パルス2 信号により、HLの新しい値がレジスター HおよびレジスターLに保存される。

8ビットデータバス用のダイオードマトリクスROM は、 もう少し複雑だ。 2 つの命令サイクルに対応する形で、 2つの図に分けて示そう。 次ページに示すの が最初の命令サイクルだ。

488

第23章 CPU 制御信号

MOV r, r MOV r, M. MOV M, r MVI r, data MVI M, data ADD r ADD M... ADI data LDA STA EC1- T TRI T RAM DO 命令 Acc EP1- TRI RA RA RAM ALU Acc イネーブル イネーブルラッチ イネーブル 2 クロック書き込み クロッククロック イネーブル

この回路は、 473 ページの表の8ビットデータバスの列を実現したものだ。 下部の2つのトライステートバッファは、 実行サイクル1 (EC1) 信号と実行バ ルス 1 (EC2) 信号でイネーブルになる。1つ目のトライステートバッファはど の値がデータバスに乗せられるかを制御し、2つ目のトライステートバッファは その値が格納される場所を制御する。

上部に3種類の MOV 命令が置かれ、 その後にデスティネーションとソース が続く。 これらのデスティネーションとソースは、レジスターのいずれか1つ、

489

またはレジスター HLによってアドレス指定されたメモリーにすることができ る。ソースがレジスターの場合、 レジスターアレイ (図ではRA と略記) がデー タバス上でイネーブルになり、 ソースがメモリーの場合、 RAM のデータ出力が イネーブルになる (この間、 RAMは16ビットバスでアドレス指定され、 アド レスバス用のダイオードマトリクス ROM がその値をレジスター HL に設定す ることに留意しよう)。 デスティネーションがレジスターの場合、2番目のトラ イステートバッファはレジスターアレイのクロック入力を制御する。 保存先がメ モリーの場合、 RAM 書き込み信号でその値をメモリーに保存する。

2種類のMVI命令では、 命令ラッチ2の内容がデータバス上でイネーブルに なり、 その値はレジスターアレイに格納されるか、 メモリーに保存される。

この図では、すべての算術命令と論理命令を ADD と ADI命令で代表させて 表現している。 データバス上でイネーブルになる値は、使われる命令によって、 レジスターアレイ、 RAM データ出力、 または命令ラッチ2のいずれかになる。 いずれの場合も、その値は算術論理演算装置 (ALU) にラッチされる。これら の命令は、程なく説明する2回目の実行サイクル中に追加の作業を必要とする。

LDA 命令と STA命令では、アドレスバス用のダイオードマトリクス ROM により、 命令ラッチ2および命令ラッチ3の内容でRAM がアドレス指定され るようにする。 LDA命令の場合、 データバス上でRAM データ出力がイネーブ ルになり、 その値がアキュムレータに保存される。 STA命令では、データバス 上でアキュムレータが有効になり、 その値がメモリーに保存される。

算術命令と論理命令は、 データバスを使う2回目の実行サイクルが必要とな る。これらの場合のダイオードマトリクス ROM は、ほかのものに比べて非常 に単純だ。

490

第23章 CPU 制御信号

ADD r ADD M... ADI data EC2 TRI EP2 TRI ALU イネーブル アキュムレータ クロック

これらの命令で、 ALUからの値がデータバス上でイネーブルになり、 その値 は 474 ページの表の8ビットデータバスの列にも示されているように、 アキュ ムレータに保存する必要がある。

これで、これまで3章にわたって構築してきた 8080 マイクロプロセッサのサ ブセットが完成した。 動作するシミュレーションはウェブサイト(www. Code HiddenLanguage.com) で見ることができる。 コンピュータを設計するエ ンジニアは、そのコンピュータができるだけ速く動作するように、 しばしば多大 な時間を費やす。 デジタル論理回路はその設計の出来により、 高速になったり低 速になったりする。 デジタル回路を高速化するには、 論理ゲートを増やす必要の ある場合がとても多い。

ここまで説明してきたCPUを高速化しようと思ったら、 私ならまず命令 フェッチに注目する。 各命令フェッチには、プログラムカウンターをインクリメ ントすることだけを目的とした2番目のマシンサイクルが必要となってい そこで、まずはこの2つを同時に行うために、 命令フェッチサイクル自体にそ のロジックを組み込もうと考えるだろう。 おそらく、 専用のインクリメンタが必 要になるはずだ。 この改良を行えば、メモリーから命令を読み込むのに要する時 間が半分に短縮される!

小さな変更でも大きな効果がある。 あなたが何百万台ものコンピュータで使わ れるかもしれない CPU を設計していて、それぞれのコンピュータが毎秒何百万 もの命令を実行する可能性があるとしたら、 マシンサイクルを減らすことは、す べてのユーザーにとって大きなメリットになる。

491

このCPUで実行できそうな簡単なプログラムを見てみよう。 たとえば、アド レス1000h から始まるメモリーに5バイトが格納されていて、それらを加算す るプログラムが欲しいとする。 以下がそのプログラムだ。

0000h: 2Eh MVI L, 00h

|00h

26h MVI H, 10h

10h

7Eh MOV A, M

23h INX HL

|86h ADD M

|23h INX HL

86h ADD M

|23h INX HL

86h ADD M

|23h INX HL

86h ADD M

32h STA 0011h

11h

00h

76h HLT

0011h:

合計値が格納される場所

最初の2つの命令は、HとLのレジスターの値を設定する。 そして、 プログ ラムはHL を使用してバイトにアクセスし、 メモリーをアクセスするたびにHL をインクリメントしながら累計を行う。

明らかに、ここには繰り返しがある。 INX命令のあとに ADD 命令が続く場 合が4回繰り返されている。 この特定のプログラム向けには悪くはないが、も し20個の値を加算したい場合はどうだろう? あるいは 100個の場合は? また、 加算するのがバイトではなく、 16ビットや32ビットの値で累計を求めるため に、さらに多くの命令を必要とするとしたらどうだろう?

492

第23章 CPU 制御信号 493

ここで見たような繰り返しは避けられるのだろうか? 一連の命令を繰り返すよ うな命令はありうるのだろうか?あったとしたら、 どのようなものだろう?そし て、それはどのように動作するのだろう?

このテーマは1章をまるごと割いて説明できるほど重要だ!

ループ、ジャンプ、コール



第24章

ループ、 ジャンプ、 コール

私たちの生活は、 繰り返しにあふれている。 地球の自転、 月の公転、 地球の公 転など、 自然のリズムで月日を数えている。 一日一日は違うものの、 私たちの生 活は日ごとに似た、いつも通りの行動で成り立っている。

ある意味、 繰り返しはコンピューティングの本質でもある。 2つの数字を足す のにコンピュータを必要とする人は (あまり) いない。 でも、 1000個とか 100 万個の数字を足したいときはどうだろう? それが、コンピュータの仕事だ。

このコンピューティングと繰り返しの関係は、早い段階から明らかだった。 エ イダ・ラブレスによる、 1843年のチャールズ・バベッジの解析機関に関する有 名な論考には、こう書かれている。

簡潔かつ明確にするために、繰り返されるグループをサイクルと呼ぶ。 つまり、 操作のサイクルとは、2回以上繰り返される一連の操作を意味することを理解 しなければならない。 2回だけ繰り返されようが、 不定回数繰り返されようが、 どちらも同じサイクルである。 なぜなら繰り返しが起こっているという事実そ のものが、その成立要件だからだ。 多くの分析事例では、1つまたは複数のサ イクルで構成される繰り返しグループが存在する。 すなわち「サイクルのサイ クル」、あるいは「サイクル群のサイクル」だ。

現代の用語では、このようなサイクルをループと呼ぶことが多い。 彼女がサイク ルのサイクルと呼んでいるものは、現代ではネステッドループ[入れ子ループ] と

いう。

ここまでの数章にわたって作ってきた中央演算処理装置 (CPU) は、 その点 では欠陥があるようだ。 前章の最後で、 アドレス 1000h から始まるメモリーに 格納されている5バイトを足し合わせる小さなプログラムを紹介した。

0000h: 2Eh MVI L, 00h

100h

|26h MVI H,10h

|10h|

|7Eh MOV A,M

23h INX HL

| 86h ADD M

|23h INX HL

| 86h ADD M |23h INX HL

86h ADD M

|23h INX HL

86h ADD M

32h STA 0011h

11h

200h

76h HLT

0011h:

合計値が格納される場所

レジスターペアHL は、 メモリーのアドレス指定に使用される。 最初のバ イトが MOV 命令によってメモリーからアキュムレータに読み込まれ、 そのあ とに続く ADD 命令がほかの4バイトをアキュムレータに累計していく。 各バ イトがメモリーから読み出されたのち、 INX 命令でレジスターペア HLの値が インクリメントされる。 最後に STA命令が、結果をメモリーに保存する。

では、100 バイトや1000バイトを加算するには、 このプログラムをどのよう に拡張すればよいだろう? 追加するバイト数に合わせて、INX 命令と ADD命

496

第24章 ループ、ジャンプ、コール 497

令をひたすら追加していくのだろうか? あまり正しいやり方とは思えない。 ニー ズに対応したうまい解決策ではなく、 一般化された解決策でもない。

あれば便利かもしれないのは、 INX 命令や ADD命令といった一連の命令を 繰り返せる新しい命令だ。 しかし、 それはどのようなものだろう?

最初は、そのような命令は既存の命令とは非常に異なるため、 CPU の徹底的 な見直しが必要になるのでは、と恐れるかもしれない。 しかし、 絶望するにはま だ早い。

プログラムカウンターは通常、 CPU が各命令バイトをフェッチしたあとに増 加する。 これにより、 CPUは次の命令へと進む。 ループを実行する命令も、何 らかの方法でプログラムカウンターを変更する必要があるが、 通常とは異なる方 法で行う。

LDA や STA といった命令に、 16ビットのメモリーアドレスを形成する2バ イトが続くことはもう学んだ。 これらのように、あとに2バイトが続く命令を 考えてみよう。ただし、 命令に続く2バイトは、 メモリーアドレスの指定には 使われない。 その代わり、 2バイトはプログラムカウンターにラッチされる。 こ のような命令は、プログラムカウンターを異なるアドレスへ実質的にジャンプす るように設定するので、 実行の進行過程が変更されるのだ。

この命令を 「ジャンプ (JUMP)」 を意味するJMP と呼ぶことにしよう。 イ ンテル 8080 マイクロプロセッサではそう呼ばれている。 なおモトローラ 6809 では、同様の命令をBRA と呼ぶ。 これは 「ブランチ (BRANCH)」 を意味す る。

JMP命令のあとには、 16ビットのアドレスを構成する2バイトが続く。 次 ページに示す例では、このアドレスは 0005h だ

498

0000h: 2Eh MVI L, 00h 100h |26h MVI H,10h |10h 7Eh MOV A, M 0005h: 23h INX HL 86h ADD M C3h JMP 0005h |05h 100h

INX 命令と ADD 命令が実行されるたびに、このJMP命令はアドレス 0005h

へと実行を継続し、 INX 命令と ADD 命令をもう一周させる。 これがループだ。 このJMP命令を CPU に追加するのは驚くほど簡単だ。 しかし、 まず問題を 認識するために、追加を少し先延ばしにしよう。 このJMP命令を持つ小さなプ ログラムは永遠に続いてしまう。 このループを止める方法はないため、 無限ルー プと呼ばれる。 HLの値は増加し続け、 そのアドレスにあるバイトはアキュム レータ内の合計に加算され続ける。 最終的に HL は、 メモリーの最後のFFFFh に等しくなる。 そして再びインクリメントされると、 0000h になり、 命令バイ トをアキュムレータに加算し始める!

プログラミングではループは非常に重要だが、それと同じくらい重要なのが、 時にはループするが、 いつもループするわけではないということだ。 ジャンプが発生するか否かを制御できそうなものは、 すでに CPU にあるだろ うか?

もちろん、 ある。 第21章で作った算術論理演算装置 (ALU) がラッチの中に いくつかのフラグを保存することを思い出してほしい。 これらは、キャリーフラ グ、 ゼロフラグ、サインフラグで、 それぞれ ALU 演算でキャリーが発生したか、 か、 結果の上位ビットが1(負の2の補数) かを示す。

結果がゼロに等しいここで、 ゼロフラグが設定されている場合 (値が1の場合) のみ、 もしくは

第24章 ループ ジャンプ、コール 499

ゼロフラグが設定されていない場合 (値が0の場合) のみ、 ジャンプする命令 を考えることができる。 実際、 ジャンプ命令に関する、 次のような小さなグルー プを定義できるだろう。

オペコード

命令 JMP addr JNZ addr JZ addr JNC addr JC addr JP addr JM addr

說明

ジャンプ

C3h

ゼロフラグが設定されていない場合はジャンプ ゼロフラグが設定されている場合はジャンプ C2h CAh キャリーフラグが設定されていない場合はジャンプ キャリーフラグが設定されている場合はジャンプ 正ならジャンプ (サインフラグが設定されていない) D2h DAh F2h 負ならジャンプ (サインフラグが設定されている) FAh

これらの命令やオペコードは私が創り出したものではない! インテル 8080 に 実装されているものだ (本書では8080 をベースのそのサブセットを構築してい る)。 最初の列の addr は、 オペコードに続く2バイトのメモリーアドレスであ る。

JMP命令は、無条件ジャンプと呼ばれる。 ALU フラグの設定に関係なく、 CPU の正常な実行順序を変更する。 そのほかは条件ジャンプと呼ばれ、 ALU で特定のフラグが設定されているか、 設定されていない場合にのみ、 プログラム カウンターを変更する (8080 は加えて、パリティフラグに基づく2つの条件 ジャンプを実装している。 第21章ではそのフラグに触れたが、 本書の CPU で は実装しない)。

これらの条件ジャンプがプログラムでどのように機能するかを見てみよう。 た とえば、アドレス 1000hから始まるメモリーに保存されている200 バイトの値 を合計することを考えてみよう。

ここでのコツは、レジスターの1つに、カウンターと呼ばれる値を格納して おくことだ。 カウンターは、 加算するバイト数である200から始まる。 バイト がアクセスされ加算されるたびに、このカウンターはデクリメントされる。 いつ でも、カウンターの値は加算すべき残りのバイト数を示している。 ゼロに達する と、 作業は完了する。

これは、プログラムが2つの算術操作を同時に行う必要があることを意味す る。合計しているバイトの累計を維持し、 新しいバイトを加算するたびにカウン ターをデクリメントする必要があるのだ。

このことはちょっとした問題を生じさせる。 おわかりのように、 すべての算術 および論理演算はアキュムレータを使用するため、 プログラムはレジスターから アキュムレータにバイトを移動させなければならず、 続いて新しいバイトをレジ スターに戻す必要がある。

バイトの累計値をレジスターBに、カウンターをレジスターCに格納するこ とにしよう。 これらの値は、 任意の算術演算のためにアキュムレータに移動さ れ、繰り返し続く命令のためにBとCに戻される必要がある。

このプログラムは、これまでのものより少し長いので、 3部に分けよう。 第1部は、一般に初期化と呼ばれる。

0000h: 2Eh MVI L, 00h. |00h |26h MVI H, 10h |10h OEh MVI C, 200 C8h | 46h MOV BM

ここでは、 レジスターペア HLの16ビット値を、 加算される数値が置かれた 位置である 1000h に設定する。 またレジスターCは10進数 200 (16進数C8h) に設定する。 これは何個の数字を加算しなければならないかを表している。 最後 に、レジスターBには加算される数のリストの最初の数字を設定する。 このプログラムの第2部には、 繰り返される命令が含まれている。

500 |

第24章 ループ ジャンプ、コール |

0007h: 79h MOV A, C. D6h SUI 1 01h |CAh JZ 0015h 15h 00h 4Fh MOV C, A 23h INX HL 78h MOV A, B 86h ADD M 47h MOV B, A C3h JMP 0007h 07h 100h

第2部では、 まず、カウンターの値をアキュムレータにコピーする。 続く SUI 命令は、その数から1を引く。 初回は、 値200が199になる。 この値が0 である場合 (明らかにまだ0ではないが)には、JZ命令はこのブロックの次の アドレスである 0015h にジャンプする。 このような命令は、ループからの脱出 と呼ばれる。

そうでない場合 (0でない場合) は、 アキュムレータの値 (初回通過時には 199になっている) をレジスターCに戻す。 この時点で、 INX によってHL を インクリメントできるようになった。 現時点の累計値 (レジスターBに格納さ れている) がAに移動し、 メモリーアドレス HL に置かれた値がそれに加算さ れ、新しい累計値がレジスターBにコピーバックされる。 そして、無条件ジャ ンプ命令 JMP によって、 第2部の先頭にジャンプし、 次の繰り返しに入る。

このように実行されるコードの各回を一般に、反復と呼ぶ。 最終的に、レジス ターCの値は1になり、 そこから1を引くことで0となり、そのあとでJZ命 令はアドレス 0015hにジャンプする。

501

502 |

0015h: 78h MOV A, B

32h STA 001Ah

1Ah

00h

|76h HLT

001Ah:

合計値が格納される場所

レジスターB には、 全200個の数値の最終的な合計値が格納されている。 こ こでは合計値をメモリーに保存する STA 命令に備えて、 まずアキュムレータに 移動させている。 その後、 プログラムが停止される。

このプログラムは、 加算する数字がメモリー上の異なる位置にあったり、数が 200より多かったり少なかったりする場合でも、 とても簡単に修正できることに 注意してほしい。 これらの情報はすべてプログラムの最初の部分で設定され、 簡 単に変更できる。 コンピュータのプログラムを書くときには常に、 将来どのよう に変更される可能性があるかを考えておくとよい。

コンピュータプログラムが一通りにしか書けないということはほとんどない。 このプログラムには、ジャンプ命令を1つだけ使うという、 少し異なる書き方 がある。 このバージョンは、ほぼ最初のプログラムと同じように始まる。

0000h: 2Eh MVI L, 00h |00h |26h MVI H,10h |10h OEh MVI C, 199 |C7h 46h MOV B, M

唯一の違いは、レジスターCの値が200 ではなく 199 に設定されていることだ。 この理由はすぐにわかる。

プログラムの第2部はもっと変更されている。 今度はHL をインクリメント

第24章 ループ ジャンプ、 コール

して、リストの次の値を加算するところから始まる。

0007h: 23h INX HL 78h MOV A,B 86h ADD M 47h MOV B, A 79h MOV A, C D6h SUI 1 01h 4Fh MOV C, A C2h JNZ 0007h |07h 100h

次の値を加算したのち、 レジスターCのカウンター値をAに移動し、1つ減 らして、 新しい値をレジスターCに戻す。 SUI 命令の結果が0でなければ、 JNZ 命令はループの先頭にジャンプする。

もし SUI命令の結果が0なら、 プログラムはJNZ命令の次の命令を続行する。 これで累計値をメモリーに保存して停止するプログラムの完成だ。

0012h: 78h MOV A, B 32h STA 0017h |17h 100h 0017h: |76h HLT 合計値が格納される場所

ジャンプ命令を1つ削除したことで、プログラムは3バイト短縮されたが、 少し複雑な印象を受けたかもしれない。 レジスターCを200ではなく、 199 に 設定する必要があることを理解できるだろうか? メモリーからの値が加算された のちに、カウンターの値が変更されて調べられているからだ。 もし、 加算するリ ストに値が2つしかなければ、JNZ 命令の最初の反復の前に、 その両方の数字

503

にアクセスすることになる。 したがって、 Cは2ではなくに初期化する必要 がある。

ループを何回反復させなければならないかを判断する際に、 間違いは起きがち だ。プログラミングではよくある問題なので、名前がついている。オフバイワン [1つズレ] エラーと呼ばれる。

おそらく、数字をいくつ足す必要があるかはわからないが、リストの最後の数 字が 00hであることはわかっている場合もあるだろう。 この00h の値は、リス トがそこで終わることをプログラムに知らせる。 このような値をセンチネル [番 兵] と呼ぶこともある。 この場合、 比較命令でメモリー値と00h を比較し、 ルー プから抜け出すタイミングを判断することになる。

このセンチネルを使ったバージョンのプログラムからは、 メモリー上の値を見 せるのをやめて、 命令だけを示すことにする。 メモリーアドレスの代わりに、 ラ ベルと呼ばれる文字列を使おう。 ラベルは、メモリーの中の場所を表している。 ラベルのあとにはコロン (:) が付く。

Start:

MVI L, 00h

MVI H, 10h

MVI B, 00h

Loop:

MOV A,M

CPI 00h

JZ End

ADD B

MOV B, A

INX HL

JMP Loop

End:

MOV A, B

STA Result

Result:

HLT

MOV A,M 命令でメモリーの次の値をアキュムレータにロードしたのち、CPI

504

第24章 ループ、ジャンプ、 コール

命令で 00h と比較する。 Aが00hに等しい場合、 ゼロフラグが設定され、 JZ命 令はラベル End にジャンプする。 そうでない場合は、その値はBの累計に加算 され、 次の反復のために HL がインクリメントされる。

ラベルを使うことで、 命令のメモリーアドレスを考えずに済むが、このラベル のメモリー位置はいつでも計算できる。 たとえば、プログラムがメモリー位置 0000h から始まる場合、 最初の3つの命令はそれぞれ2バイトを必要とするの で、 ラベル Loop はメモリーアドレス 0006h を表す。 次の7つの命令は合計 12 バイトを占有するので、 ラベル Endはメモリーアドレス 0012h Result は 0017h となる。

まだ明確に認識していないかもしれないが、 条件ジャンプは CPU のとても大

切な機能であり、 おそらく想像よりもずっと重要だ。 その理由を説明しよう。 1936年、 ケンブリッジ大学を24歳で卒業したアラン・チューリングは、ド イツの数学者ダフィットヒルベルトによって提起された、 数学的論理における 問題「 Entscheidungsproblem」 (またの名を 「決定問題」) を解決しようとした。 決定問題とは、数理論理学における任意の文が決定可能であるかどうかを判断で きるプロセスは存在するか、 すなわち、 その文が真または偽であるかを判断でき るか?という問題だ。

この問いに答えるにあたって、 アラン・チューリングは極めて異例のアプロー チをとった。 彼は、 簡単なルールで機能する単純な計算機の存在を仮定した。 実 際にこの機械を作ったわけではない。 想像上のコンピュータだった。 しかし、彼 は決定問題が偽であることを証明しただけでなく、 この数理論理学の問題をはる かに超える影響を与えたデジタルコンピューティング の基本概念を確立した。

チューリングが発明した空想の計算機は、現在では チューリングマシンと呼ばれる。 計算能力という点で は、それ以降に作られたすべてのデジタルコンピュー タと機能的に同等である。 (チューリングが発明した 架空の計算機を説明した論文の原本を読みたい読者 は、拙著『 The Annotated Turing: A Guided Tour through Alan Turing's Historic Paper on Computability and the Turing Machine 』 [邦訳『チューリングを読むコンピュータサ

Group/Getty Images

Pictures from History/Universal Images

505

イエンスの金字塔を楽しもう』 日経BP] が参考になるかもしれない)。

デジタルコンピュータの種類が異なれば、それらは異なる速度で動作する。 異 なる量のメモリーとストレージにアクセスできる。 さらに、 異なる種類のハード ウエアに接続されている。しかし、それらはすべて、 「機能的には」 同等である。 それらはすべて、 算術演算の結果に基づいて条件ジャンプを行うという非常に特 別な特性を持つために、 同等の処理を実行できるのだ。

条件ジャンプ (またはそれに相当するもの) をサポートするすべてのプログラ ミング言語は、基本的に同等だ。 こうしたプログラミング言語は、チューリング 完全であるといわれる。 ほぼすべてのプログラミング言語がこの条件を満たす が、ウェブページに使われる HTML (Hypertext Markup Language)などの マークアップ言語は、チューリング完全ではない。

本章で先に挙げたジャンプ命令のほかに、 ジャンプを実行するために便利な命 令がある。 これは、 レジスター HL の中の値を使う。

命令 説明

PCHL HL をプログラムカウンターにコピーする

オペコード

E9h

7つのジャンプ命令と PCHLは、前章で示したタイミング回路にとても簡単 に組み込める。 第23章477ページの回路では、3つのデコーダーがオペコード の8ビットに対応する入力を備えていたことを思い出そう。

506

第24章 ループ ジャンプ、 コール

C7 C6 C5 C4 C3 C2 C1 Co 2-to-4 3-to-8 3-to-8 0 1 2 3 01234567 01234567 -JMP ・JNZ -JZ JNC JC JP -PCHL

オペコードがジャンプ命令に対応するとき、これらのデコーダーの出力の様々な 組み合わせが、 信号を生成するために使われる。

PCHL を除くすべてのジャンプ命令は、7入力のORゲートでまとめること ができる。

JMP JNZ JZ JNC ・ジャンプグループ JC JP JM

これは、 第23章479 ページの回路にジャンプ命令を統合するために使用でき る。 メモリーから取得する必要がある命令バイトの数と、 各命令を実行するのに 必要なサイクル数を決定する。 ジャンプグループの信号は、 メモリーから (命令

507

コードと2バイトのアドレスの) 3バイトを取得する必要があることを示す。 PCHL 命令は長さが1バイトしかない。 これらの命令はすべて実行するのに 1 サイクルしか必要とせず、 アドレスバスだけに関与する。

ジャンプ命令の実行のために、 条件ジャンプすべきか否かを示す信号を生成し よう。 デコードされた命令バイトのための信号は、 第21章の ALUからのフラ グと組み合わされる必要がある。

JNZ Zero Flag JZ JNC Carry Flag JC JP Sign Flag JM 条件ジャンプ

そして、これらの信号は、第23章487ページにあるダイオードマトリクス ROM に簡単に組み込める。

508

第24章 ループ、ジャンプ、コール

JMP 条件ジャンプ PCHL EC1 TRI EP1-TRI HLを イネーブルに する 命令ラッチ 2と3を イネーブルに する プログラム カウンター クロック

JMP命令と条件ジャンプ命令は、アドレスバス上の命令ラッチと命令ラッ チ3をイネーブルにし、 PCHL命令はアドレスバス上のHLをイネーブルにす る。 いずれの場合も、 そのアドレスはプログラムカウンターに格納される。

強化された CPU のインタラクティブバージョンは、 ウェブサイト www. Code Hidden Language.com) で見ることができる。

コンピュータプログラムでは、ほとんどの場合で繰り返しが必要となり、 ルー プの格好の候補となる。 乗算がよい例だ。 第21章で、 この CPUがどのように して乗算を行うかを示すと約束したが、 その仕組みを見るときがきた。

最も単純な場合、 すなわち2つのバイトの乗算を見ていこう。 たとえば、 132 掛ける 209 または 16進数で84h 掛ける D1h を行うとする。 この2つの数字 を被乗数と乗数と呼び、 それらを掛けた結果を積と呼ぶ。

一般に、1バイトをほかのバイトと掛け合わせると、2バイトの大きさの積 が生じる。 この例の場合、 積を手動で計算して、 27,588 あるいは 6BC4h とい う解を得るのは簡単だが、 それを CPUにやらせてみよう。

これまで、 HとLのレジスターを16ビットのメモリーアドレスに使用してき たが、HとLを通常の8ビットレジスターとして使用することもできるし、HL のレジスターペアを使用して2バイトの値を格納することもできる。 この例で は、HL を使って積を格納することにしよう。 2つのバイトを乗算するコードは、 レジスターのBに乗数、 Cに被乗数、 HとLにゼロを設定して始めよう。

509

510

Start: MVI B, D1h ;B を乗数として設定する MVI C, 84h ;Cを被乗数として設定する MVI H, 00h ; HL をゼロに初期化する MVI L, 00h

ここでは、 セミコロン (;) の右側に、 簡潔な説明文を追加している。 これら はコメントと呼ばれる。 コメントを示すのにセミコロンを使うのは、インテル 8080 のオリジナルドキュメントに見ることができる。

まずは、 加算を繰り返すだけで2つの数字を掛け合わせる、 簡単な方法を紹介

する。 被乗数をレジスター HLに乗数と同じ回数だけ加算していく。 まず、 乗数 (レジスターBに格納されている) がゼロか否かをチェックする。 ゼロであれば、乗算は完了だ。

Loop:

MOV A,B

CPI 00h

;Bがゼロかどうかをチェックする

JZ AllDone ; もしそうであれば、ここで終了する

ゼロでない場合は、 被乗数 (レジスターCに格納されている) がレジスター HとLの内容に加算される。 これは本質的に16ビット加算であることに注意し てほしい。 まずLの内容をアキュムレータに移動して、 Cの値をアキュムレー タに入ったLの値に加算する。 次にHに ACI でゼロを加算することで、最初の 加算から生じる可能性のあるキャリーが加算される。

MOV A, L

;CをHL に加算する

ADD C

MOV L,A

MOV A, H

ACI 00h

MOV H, A

ここでレジスターBの乗数がデクリメントされ、 HLに加算される数値の数

24 ループ、ジャンプ、コール

が1つ減ったことになり、 プログラムは再びLoopにジャンプして次の反復を行 う。

MOV A, B ;Bをデクリメントする SBI 01h MOV B, A JMP Loop 計算を繰り返す

先の AllDone ラベルへのジャンプが発生した時点で、乗算は終了し、 HLレ ジスターには積が格納されている。

AllDone: HLT

HL には結果が入っている

以上は、2つのバイトの乗算方法としては最適とはいえないが、わかりやすい という利点がある。 こうした解決法は、 ブルートフォースアプローチ [力まかせ アプローチ] と呼ばれることもある。 ここでは、乗算をできるだけ早く実行する ことは考慮されていない。 上のコードでは、2つの数字を比較して、小さい方の 数字をループに使用することも行っていない。 プログラムにほんの少しコードを 追加するだけで、 132 を209回加算するのではなく、 209132回加算するよ うにできる。

この乗算を行うのに、もっとよい方法はあるのだろうか? 10 進数の乗算を紙 の上でどのように行っているかを考えてみよう。

132

x209

1188

264

27588

最初のアンダーラインの下にある2つの数字は、 132 ×9、 そして 132×2 左に2スペース分シフトしたもの (実質的には132×200) だ。 132×0は ただの0なので、書く必要すらないことに注意しよう。 このように、209 回の

511

加算や132回の加算を行うのではなく、 2つの数字を加算するだけでよいのだ! この乗算は2進数ではどうなるだろう? 被乗数 (10進数で132) 2進数で 10000100 となり、 乗数 (10進数で209) 2進数で11010001 となる。

10000100 x 11010001 10000100 10000100 10000100 10000100 110101111000100

乗数 (11010001) の右側から始まる各ビットについて、 そのビットに被乗数 (10000100)を乗算する。 もしビットが1であれば、 各ビットを左にシフトし た被乗数が結果となる。 ビットが0であれば、 結果は0なので無視してよい。

最初のアンダーラインの下には、 被乗数 (10000100) (がシフトされたもの) が4つだけ置かれる。 乗数 (11010001) には1が4つしかないためだ。

この手法により、 加算の数を極限まで減らすことができる。 16ビットや32

ビットの数値を掛け合わせる場合は、 このような乗算がより重要になる。 しかし、ちょっと複雑な感じもする。 被乗数のどのビットが1で、 どのビッ トが0かをテストする必要があるからだ。

ビットのテストには、 8080のANA (AND with accumulator) 命令を利用す る。この命令は2バイト間でビット単位のAND 演算を行う。 得られる結果の 各ビットは、2つのバイトの対応するビットが1のときはになり、 それ以外の ときは0になるため、 ビット単位のAND と呼ばれている。

では、乗数をレジスターDに入れよう。 この例では、 D1h という値のバイト だ。

MVI D, D1h

レジスターDの最下位ビットが1であるか否かは、 どのように判断するのだ ろう?レジスターDと値01hでANA 演算をすればよい。 まず、 レジスターE

512

24 ループ、ジャンプ、コール

にこの値 (01h) を設定する。

MVI E, 01h

ALUはアキュムレータに対してのみ動作するので、まず数字の1つをアキュ ムレータに移動する必要がある。

MOV A, D ANA E

このAND 演算の結果は、 Dの右端のビット (最下位ビット) が1であれば 1、 それ以外は0となる。 つまり、Dの最下位ビットが0であれば、 ゼロフラグ が設定される。 そのフラグにより、 条件ジャンプが可能になる。

次のビットは01h ではなく 02h との AND 演算が必要となり、 さらに残りの ビットは 04h 08h、 10h、 20h、 40h、 80h との AND 演算を行うことになる。 この列を少し眺めれば、 01hの2倍は02h、その2倍は04h、 その2倍は 08h といった具合に、それぞれの値が前の値の2倍になっていることに気づくだろ う。これは有益な情報だ!

レジスターEは01hでスタートする。 自分自身を加算することで2倍にでき る。

MOV A, E ADD E MOV E, A

これで、Eの値は 02h となった。 これらの3つの命令をもう一度実行すると、 04h となり、 次は 08h となる。 この単純な操作がしていることは 01 から 80h になるように、最下位から最上位までビットを段階的にシフトすることだ。

また、被乗数をシフトして結果に加算することも必要になる。 つまり、 被乗数 はもはや8ビットレジスターに収まらなくなり、 何らかの方法で16ビット値と して扱わなければならない。 被乗数は、 まずレジスターCに格納されるが、レ

513

514

ジスターBは0に設定される。 レジスターBとレジスターCを、この16ビッ トの被乗数を格納するペアとして扱い、 16ビット加算のためにシフトさせるよ うにする。 このレジスターBとレジスターCの組み合わせを、 BC と呼ぼう。 次に、この改良された乗算器のレジスターの初期化方法を説明しよう。

Start: MVI D, D1h ; 乗数 MVI C, 84h ; BC に被乗数を格納する MVI B, 00h MVI E, 01h ; ビットテスター MVI H, 00h ; 2バイトの結果にはHL を使用する MVI L, 00h

ループ部では、まず乗数のビットが1か0かをテストする。

Loop: MOV A, D ANA E JZ Skip

; ビットが0か1かをテストする

ビットが1の場合 (結果は0ではない場合)、 次のコードを実行して、 レジス ターペアの BC値をレジスターペアHL に加算する。 だが、8ビットレジスター は個別に処理する必要がある。 下位バイトには ADD が使われ、 上位バイトには キャリーを考慮して ADC が使用されていることに注意しよう。

MOV A, L ADD C MOV L, A MOV A, H ADC B MOV H, A

HLにBC を加算する

第24ループ、ジャンプ、コール |

ところで、もし私が、本書で構築しているサブセットではなく本物のインテル 8080 を使っていたなら、この6つの命令を DAD BC で置き換えることが可能 だ。 これにより、 簡単にBCをHLに加算できる。 DAD は、 16ビット値を操 作する 8080 命令のうちの1つだ。

続く処理は、 BC の値を2倍にすることだ、 次の加算のために値を左にシフト することに相当する。 このコードは、 BC がHLに加算されたか否かにかかわら ず実行される。

Skip:

MOV A, C

ADD C

; BC (被乗数) を2倍にする

MOV C, A

MOV A,B

ADC B

MOV B,A

次に、ビットテスターであるレジスターEの値を2倍にする。 値が0でない 場合は、 Loop ラベルにジャンプして戻り、次の反復を行う。

MOVA,E

ADD E

MOV E, A

;E (ビットテスター) の値を2倍にする

JNZ Loop

Loop ラベルに続くコードは、ちょうど8回実行される。Eが8倍されたのち、 8ビットレジスターがオーバーフローし、Eは0になる。 乗算は完了だ。

HLには結果が入っている

Done:

HLT

2つの16ビット値あるいは32ビット値を乗算する場合、 その処理は明らか に複雑になり、 より多くのレジスターを使う必要がある。 中間値を格納するため のレジスターが足りなくなったら、メモリーの領域を利用して一時的に格納す

515

る。 そのように使用されるメモリー領域は一般に、スクラッチパッドメモリーと 呼ばれる。

このようなことをお見せする目的は、読者を怖がらせることではないし、読者 にコンピュータプログラミングのキャリアを思いとどまらせることでもない。 目 的は、メモリーに保存されたコードに応答して動作する論理ゲートの集合が、と ても単純な操作を組み合わせて複雑な処理を実行できることを示すためだ。

現実のコンピュータプログラミングでは、(いわゆる) 高水準言語を使用すれ ば、 乗算はずっと簡単だ。 これについては第27章で議論する。 ほかの人が厄介 な仕事をしてくれたおかげで、 読者自身がそれをする必要はないという点がソフ トウエアの魔法なのだ。

機械語での乗算にはビットのシフトが必要だが、先述のように、 値にそれ自体 を加算することで実現した。 本書のサブセットではなく、 実際のインテル 8080 を使った場合には、ビットをシフトするにもっとよい手段がある。 8080 には、 それ自体にレジスターを加算するという厄介なことをせずにビットシフトを実行 する4つの命令が存在する。 それらはローテート命令と呼ばれる。

命令 説明 Aレジスターを左ローテート [左回転] する 07h Aレジスターを右ローテート [右回転] する OFh RAL キャリーとAレジスターを結合して左ローテートする 17h RAR キャリーとAレジスターを結合して右ローテートする 1Fh

RLC

RRC

オペコード

これらの命令は、 常にアキュムレータの値に対して演算を行い、 キャリーフラ グに影響を与える。

RLC 命令は、 アキュムレータのビットを左にシフトする。 ただしこのとき、 最上位ビットが、 キャリーフラグと最下位ビットの両方の設定に使われる。

CY-7-6--5--4-3-2-1-04

RRC 命令は、 ビットを右にシフトすること以外は、同様に振る舞う。 最下位

516

第24章 ループ ジャンプ、 コール 517

ビットは、キャリーフラグと最上位ビットの両方の設定に使われる。

RAL 命令は、キャリーフラグが最下位ビットの設定に使われることを除けば、 アキュムレータの値を2倍にすることと同じだ。 これはマルチバイトの値をシ フトする場合に便利である。

RAR 命令は、RAL と似ているが、ビットを右に回転させる命令だ。

7 →6-5-4-3-2-1-0→CY

これらのローテート命令は状況によっては確かに便利だが、 必須ではなく、 本 書で作ってきた CPU に追加することもない。

さて、ここまでで、 ジャンプやループを使って一連の命令を何度も繰り返し実 行する方法を理解できただろう。 しかし、 もっと柔軟に一連の命令を実行したい 場合も多いはずだ。 ひょっとするとこれまでに、コンピュータプログラムの様々 な部分から実行できる一連の命令を書いたことがあるかもしれない (おそらく汎 用の乗算ブロックもその1つだ)。 このような一連の命令は、関数、 手続き サ ブルーチン、 または単にルーチンと呼ばれることが多い。

インテル 8080 は、 CALL という命令でサブルーチンを実装している。 CALL 命令の構文は、メモリーアドレスが続くという点で、JMP とよく似ている。

CALL addr

JMP命令と同様に、 CALL文は与えられたアドレスにジャンプして実行を継続 する。 しかし、 CALL は、 ジャンプ元の場所の情報をまず保存するという点で JMPとは異なる。 保存されるのは、 CALL 命令に続く命令のアドレスだ。 この

アドレスはとても特別な場所に格納されることがすぐにわかるだろう。 また別の、RET (「return [戻る]」の意味)という命令もJMP と似ているが、 ジャンプ先のアドレスは CALL命令の際に保存したアドレスだ。 サブルーチン は、 RET文で終わることが多い。

以下がインテル 8080のCALL命令とRET 命令である。

命令 説明 オペコード CALL RET サブルーチンにジャンプする サブルーチンから戻る CDh C9h

8080 は、 条件付き CALL や条件付きRET もサポートしているものの、 CALL やRET に比べると使用頻度はかなり低い。

実例を見てみよう。 バイトの値を表示するプログラムを書くとする。 たとえ ば、あるバイトの値 「5B」 を表示したい。 第13章で、 ASCII を使用して文字 数字、記号を表示する方法を説明した。 しかし、 ASCIIコード 5Bh を直接使用 して 「5B」 という表示を行うことはできない。 それは左角括弧を表す ASCII コードだからだ! その代わり、 5Bhのようなバイトを、2つのASCIIコードに 変換する必要がある。 かっこ

・35h 文字 「5」 に相当する ASCIIコード • 42h 文字 「B」 に相当する ASCIIコード

この変換は、(少なくとも16進数を知っている) 人が理解できるような形式で バイトの値を表示する。

ここでは、まずバイトを上位4ビットと下位4ビット (それぞれニブルと呼 ばれることもある) の2つに分ける戦略をとる。 この例では、5Bh というバイ トが 05h と OBh に分割される。

次に、4ビットの値のそれぞれを ASCII に変換する。 ASCII コードは30hか ら39h で 「0」から 9 までの文字を表す (ASCII の復習が必要な場合は、 第 13章204ページと205 ページの表を参照しよう)。 また ASCII コードの41h から46h が 「A」 から 「F」 の文字に対応する。

ここでは、 アキュムレータに置かれた4ビット値を ASCII に変換する小さな

518

第24章 ループ、ジャンプ、 コール

サブルーチンを紹介しよう。

1532h:FEh Digit: CPI 0Ah [0Ah DAh JC Number 39h |15h C6h ADI 07h 07h 1539h: C6h Number: |30h C9h ADI 30h RET

何が起こっているかを示すことが重要なので、ここでは再びメモリーの位置を 表示している。 このサブルーチンはたまたま1532hのメモリー位置から始まる が、それが特別なわけではない。 サブルーチンがメモリー内のどこにあるかを決 めたにすぎない。

このサブルーチンは、アキュムレータに変換する値が入っている前提だ。 この ように想定された値は、 しばしばサブルーチンの引数またはパラメーターと呼ば れる。

サブルーチンは直値比較命令 (CPI) で始まり、 減算を実行したときと同様の ALU フラグ群を設定する。 たとえばアキュムレータの値が 05h の場合、その数 値から 0Ah を引くにはボロー [借り] が必要となるため、 この命令によってキャ リーフラグが設定される。 キャリーフラグが設定されているため、 JC 命令は Number というラベルの命令にジャンプする。 そこではアキュムレータに 30h を加算し、これにより35hになり、 数字 「5」 を表す ASCIIコードになる。

もしアキュムレータに OBhのような値が格納されているなら、 0Ah を減算す る際にボローは必要ない。 つまり、最初のCPI命令ではキャリーフラグが設定 されないため、ジャンプは発生しない。 まず、 アキュムレータに07h を加え(こ の例では OBh +07h、 つまり 12h となる)、 さらに2番目のADI命令で30hを 加え、 文字 「B」 の ASCIIコードである42h とする。 2つの値を加えるのは、

519

文字変換と数字変換の両方で2番目のADI命令を共通利用するちょっとしたコ ツだ。

いずれの場合も、次の命令はRET なので、 サブルーチンは終了する。 先に、1バイトを2つのASCIIコードに変換するサブルーチンを書くと述べ た。この2番目のサブルーチンは、Digit を2回 CALL 命令で呼び出している が、1回目は下位ニブル、そしてもう1回は上位ニブルに対する処理を行う。 サ ブルーチンの始めでは、 変換対象のバイトがアキュムレータに置かれていて、 結 果はHとLのレジスターに格納される。 このサブルーチンは ToAscii [ASCIIへ [変換] と呼ばれ、 たまたまメモリーアドレス14F8hで始まっている。

14F8h:47h ToAscii: MOV B,A

E6h

OFh

|CDh|

32h

ANI OFh

CALL Digit

|15h

14FEh: 6Fh

|78h

OFh

OFh

OFh

MOV L, A

MOV A, B

RRC

OFh

RRC

RRC

E6h

RRC

ANI 0Fh

OFh

CDh

32h

15h

1509h: 67h

CALL Digit

MOV H, A

| C9h

RET

このサブルーチンは、まず元のバイトをBに保存し、 ANI

(AND Immediate)

520

第24章 ループ、ジャンプ、 コール

命令で OFh とのビット単位のAND 演算を行い、 下位4ビットのみをアキュム レータに保存する。 そして、 アドレス 1532h にある Digit サブルーチンの CALL を行う。 その結果はレジスターLに保存される。 元のバイトはレジス ターBからアキュムレータに取り出され、4つの RRC 命令で上位ニブルを下位 ニブル (下位4ビット) の場所までシフトダウンする。 別の ANI命令を呼び出 し、再び Digit への CALL を行う。 その結果がレジスターH に格納され、 RET 命令でサブルーチンが終了する。

その働きがどのようなものかを見てみよう。 14F8h にある ToAscii サブルー チンへの CALL 命令を含む小さなコードの断片が、 どこかに置かれているかも しれない。

0623h:3EhMVI A,0x5B 5Bh CDh CALL ToAscii F8h 14h 0628h:

プログラムがアドレス 0628hにまで進んだときには、HとLには5Bhの2 桁を表す ASCII コードの値が保存されている。

CALL と RETはどのような仕組みになっているのだろうか?

先ほど、 CALL 命令が実行されたときには、 サブルーチンが終了したあとに コードが再開できるよう、 とても特別な場所にアドレスが格納されると説明し た。 そのとても特別な場所はスタックと呼ばれる。 スタックは、ほかから可能な 限り離れた場所にあるメモリーの領域だ。 インテル 8080 のような8ビット CPUでは、スタックはメモリーの最後の部分にある。

インテル 8080 には、スタックポインターと呼ばれる16ビットのレジスター がある。 8080 がリセットされると、 スタックポインターはアドレス 0000hに初 期化される。とはいえ、プログラムは、SPHL (HLからスタックポインターを 設定する) 命令またはLXI SP (即値アドレスからスタックポインターをロード する) 命令により、 そのアドレスを変更できる。 しかし、今はデフォルトの値で

521

ある 0000hのままにしておこう。

インテル 8080 が CALL ToAscii 命令を実行すると、 次の処理が順番に起こ る。

●まずスタックポインターがデクリメントされる。 初期値は 0000h だったの で、これをデクリメントすると16ビットの最大値であるFFFFh となり、 16ビットメモリーの最後のバイトを指すことになる。

・CALL 命令の次のアドレス(この値は0628h で、 プログラムカウンターの 現時点の値でもある) の上位バイトが、 スタックポインターが指すアドレス の位置のメモリーに保存される。 そのバイトの値は 06h である。 ・スタックポインターはデクリメントされ、 その値が FFFEh となる。

・CALL 命令の次のアドレスの下位バイトが、 スタックポインターのアドレス が指す場所のメモリーに保存される。 そのバイトの値は28h であ。

・CALL文に指定されたアドレス (14F8h) がプログラムカウンターにロード され、結果としてそのアドレスにジャンプする。 これは ToAscii ルーチンの アドレスだ。

RAM の最後尾の領域は現時点で、 次のようになっている:

FFFEh: 28h ToAscii後に戻るアドレス 06h

CALL 命令は、事実上、 帰り道を探すための小さなパンくずのような痕跡を 残している。

ToAscii ルーチンが現時点で実行されているが、このルーチンも内部に Digit ルーチンへのCALL 命令を持っている。 ToAscii ルーチン内のその CALL Digit 命令に続くメモリー位置は14FEh なので、 CALL 命令が実行されると、 そのアドレスがスタックに格納されて次のようになる。

522

第24章 ループ、ジャンプ、コール

FFFCh:FEh Digit後に戻るアドレス |14h 28h ToAscii後に戻るアドレス 06h

スタックポインターの値はFFFCh となり、現時点では Digit ルーチンが実行 されている。 Digit ルーチンのRET 命令が実行されると、 次の処理が実行され る。

・スタックポインターの値によってアドレスが決まるメモリー位置のバイトが 読み出される。そのバイトの値はFEhである。

・スタックポインターがインクリメントされる。

・スタックポインターの値によってアドレスが決まるメモリー位置のバイトが 読み出される。 そのバイトの値は 14h である。

スタックポインターがインクリメントされる。

・読み出された2バイトはプログラムカウンターにロードされ、結果として ToAscii ルーチン内のメモリー位置である 14FEhへのジャンプが起こり、 Digit を呼び出したルーチンに戻る。

これでスタックは、最初の Digit を呼び出す前の状態に戻った。

FFFEh: 28h ToAscii後に戻るアドレス 106h

スタックポインターは現時点でFFFEhだ。 14FEh というアドレスはまだメモ リーに格納されているが、もはや無関係になった。 次に Digit を呼び出すと、新 しいリターンアドレスがスタックに格納される。

523

524

FFFCh: 09h Digit後に戻るアドレス |15h |28h ToAscii後に戻るアドレス 106h

これは ToAscii ルーチンの中の2つ目の CALL Digit 命令に続くアドレスだ。 Digit が再び RET 命令を実行すると、 ToAscii ルーチン内のアドレス 1509hに ジャンプする。 これでスタックは次のようになる。

FFFEh: 28h ToAscii後に戻るアドレス 06h

これで ToAscii ルーチン内の RET 命令を実行できるようになった。 これはス タックから0628h というアドレスを取得し、そのアドレスに分岐する。 CALL ToAscii 命令に続くアドレスだ。

以上がスタックの仕組みである。

形式的には、スタックは 「後入れ先出し」 (Last-In-First-Out、 またはLIFO) 形式のストレージに分類される。 スタックに追加された最新の値が、 スタックか ら次に取り出される値となる。 スタックというと、 カフェテリアで見られるよう な積み上がった皿のイメージがある。 重なった皿の上に皿を積み上げていくが、 取り出すときは逆の順番、 つまり上の皿からとなる。

スタックに何かを追加することをプッシュ (PUSH) スタックから何かを取 り除くことをポップ (POP) という。 インテル 8080 は、 スタックにレジスター を保存し、あとから取り出すために、 いくつかの PUSH と POP 命令もサポー トする。

説明

命令

第24章 ループ、ジャンプ、コール 525

オペコード

PUSH BC

C5h

PUSH DE

PUSH HL

PUSH PSW

D5h

E5h

レジスターBとCをスタックに保存する レジスターDとEをスタックに保存する レジスターHとLをスタックに保存する プログラムステータスワード (PSW) を スタックに保存する

F5h

POP BC POP DE POP HL POP PSW スタックからレジスターBとCへ取り出す スタックからレジスターDとEへ取り出す スタックからレジスターHとLへ取り出す スタックからプログラムステータスワード を取り出す Clh Dlh Elh Flh

PSW という略語は、プログラムステータスワード (Program Status Word) の 略で、内容は目新しいものではない。 アキュムレータに対応する!バイトと、 ALU フラグに対応するもう1バイトにすぎない。

PUSH 命令と POP 命令は、 サブルーチンを呼び出す際に、 レジスターの内容 を保存する便利な方法だ。 サブルーチンを呼び出すコードは、 CALLの前にレ ジスターの内容をプッシュし、 呼び出し後にポップすることがある。 これによ り、サブルーチンは呼び出した側のコードへの影響を気にすることなく、レジス ターを使用できる。 あるいは、 サブルーチン自身がレジスターを先頭でプッシュ し、RET の直前にポップする方法もある。

PUSH 命令と POP 命令は、 CALL 命令や RET命令と同様に、 バランスをと る必要がある。 サブルーチンが PUSH を2回､ POPを1回だけ呼び出し、その あとで RET命令を実行すると、 コードはおそらく望まない場所にジャンプする ことになる!

もしくは誤ったコードがスタックを何度もポップしてしまい、 スタックポイン ターがメモリーの末尾ではなく先頭を指すようになってしまうこともある! この 問題はスタックアンダーフローと呼ばれ、 スタックの中身がコードを上書きして しまうことがある。 関連する問題として、スタックに多くのものがプッシュされ すぎて、サイズが大きくなり、 コードが上書きされることもある。 これはスタッ クオーバーフローと呼ばれる。 なおこの名前は、技術的な問題に対する答えを求

めるプログラマに人気がある、 インターネットフォーラム [https://stackoverflow. com/] の名前にもなっている。

CALL 命令と RET 命令は、 CPU がチューリング完全であるために必要なも のではないが、実用上はかなり便利であり、 必要不可欠という人もいる。 サブ ルーチンは、 アセンブリ言語プログラムを構造化するのに大事であり、ほかの多 くの種類のプログラミング言語でも重要な役割を担っている。

だが、この数章で設計してきたCPU に CALL RET PUSH、 POP を追加 することはしない。 大変申し訳なく思うものの、 今回紹介したものよりもさらに 汎用性の高い設計が必要になる。

しかし、どのように実装されるかは容易に想像できるだろう。 まずスタックポ インターと呼ばれる16ビットのラッチをアドレスバスに新たに追加する。これ は、プログラムカウンターを格納するラッチとよく似ている。 ここまでは簡単 だ。 しかし、 CALL 命令でプログラムカウンターをスタックにプッシュし、 RET 命令でスタックからポップする必要がある。 そのためにはプログラムカウ ンターの値の2バイトもデータバスに乗せる必要がある。 現在の設計ではこれ に対応できない。

本書で作成している CPUにはスタック関連の命令は追加されていないが、 ウェブサイト(www.Code Hidden Language.com) には完全な8080エミュレー ターを用意している。

これまでの数章で、 インテル8080 のような8ビットマイクロプロセッサがど のように命令コードを実行するのかを見てきた。 インテルが8080 を発表したの は 1974年のことで、今ではかなり原始的なプロセッサと考えられている。 CPU 16ビット 32ビット、 そして64ビットと大きくなるにつれ、 その仕組みも とても複雑になっている

しかし、どの CPU も基本的には同じように動作をする。すなわち、 メモリー からバイトを取り出し、 算術演算や論理演算を行い、 メモリーに戻すという命令 を実行しているのだ。

さて、 本物のコンピュータを作るためには、ほかに何が必要なのかを探る段階 にきたようだ。

526

第25章

周辺機器

中央演算処理装置 (CPU) は確かにコンピュータの最も重要な部品だが、ほ かのハードウエアで補完する必要がある。 これまで見てきたように、コンピュー タは、プロセッサが実行する機械コード (マシンコード) の命令と、これらの命 令がアクセスするデータの両方を保持するための、ランダムアクセスメモリー (RAM) を必要とする。 また、 RAM は揮発性であるため、 電源がオフになると 内容が失われる。 したがって、 コンピュータのもう1つの有用な部品は、電源 がない状態でコードとデータを保持できる長期大容量記憶装置だ。

コンピュータにはまた、 命令をRAMに取り込む機能と、プログラムの結果 を取り出す機能も必要になる。 現代のコンピュータには、 マイク、カメラ、ス ピーカーも備わり、 Wi-Fi や Bluetoothのデバイス [装置] GPS (全地球測位シス テム] の衛星に接続するための無線送受信機も組み込まれている。

これらは入力装置ならびに出力装置と呼ばれ、 通常はI/Oという略称で総称 される。 より一般的には、 周辺機器とまとめて呼ばれる。

最も目立つ周辺機器は、 デスクトップコンピュータ、ノートパソコン、タブ レット、携帯電話のいずれかに関係なく、よく見ているビデオディスプレイだろ う。 本書を読むときにもビデオディスプレイを見つめているかもしれない!

今日一般に使用されているすべてのビデオディスプレイは、 小さな色付きの ドット [点であるピクセル [画素] を横と縦に並べて画像を構成する (ピクセル は、拡大鏡を使ってディスプレイを見るとわかる)。 横と縦に並んだピクセルの 合計数は、 しばしばディスプレイ解像度として参照される。

たとえば、標準のハイデフィニションテレビ (HDTV) の解像度は1920× 1080 と表記され、 水平方向に 1,920ピクセル、 垂直方向に 1,080 ピクセル、合 計約200万ピクセルで構成される。 しかも各ピクセルをそれぞれ異なる色にでき る。 これは、コンピュータディスプレイの最小解像度として、 ほぼ定着している。

これらのピクセルは、すべて一度に点灯するわけではない。 ディスプレイの内 容は、特別なメモリー領域に保存され、 ディスプレイの個々のピクセルは、ディ スプレイの一番上の行から下へ向かって、 各行が左端から右端へと順次リフレッ [シュ [更新] される。 ちらつきを防ぐため、この処理は非常に速く行われ、通常 1秒間に60回以上ディスプレイ全体が更新される。この処理を制御する回路を ビデオディスプレイアダプターという。

1920 × 1080 のディスプレイの内容を保存するために必要なメモリーはどの くらいだろう?

200万個の画素は、それぞれ赤 緑 青 (Red Green Blue) の3原色を組 み合わせた特定の色で、 RGB カラーとも呼ばれる (芸術家なら、 異なる一連の 基本色に精通しているかもしれないが、 RGBはビデオディスプレイで使用され る3色だ)。 これらの個々の基本色の強度を変えることで、 ビデオディスプレイ 上で表示可能なすべての色が生成される。 強度は通常、 各基本色に対して1バ イトで制御され、 色がない場合は 00h、 最大強度の場合は FFh に設定される。 この方式では、 ビデオディスプレイは赤、緑、 青の256の異なるレベルで、合 計 256 × 256 × 256 つまり 16,777,216 の異なる色を持つことができる (コ ンピュータに関するあらゆることを改善するという哲学に基づいて、 一部の企業 は色域と解像度を高めるために邁進している。 そのためには、 基本色ごとに8 ビット以上が必要となる)。

ウェブページをデザインする際に HTML (Hypertext Markup Language) で 作業を行うことがあれば、 色はシャープ記号 (#) に続いて6桁の16進数で指定 できることを知っているかもしれない。 ["#" は本来 「パウンド記号」 だがここではなじ み深さを優先して「シャープ記号」 と呼んでいる]。 以下は、1999年の HTML 4.01 仕 様で確立された、 16の標準色だ。

528

第25章 周辺機器 529

カラー ブラック (黒) 16 進数値 カラー "#000000" グリーン(緑) 16進数値 "#008000" シルバー(銀) グレー(灰) #COCOCO" ライム (黄緑) "#00FF00" "#808080" オリーブ (深黄緑) #808000" ホワイト (白) マルーン (栗) レッド(赤) "#FFFFFF" イエロー(黄) "#FFFF00" "#800000" "#FF0000" ネイビー (濃紺) ブルー(青) "#000080" "#0000FF" パープル (紫) "#800080" フクシャ (赤紫) "#FF00FF" ティール ( 青緑) アクア (淡緑) "#008080" "#00FFFF"

そのほかの色は、 異なる値で定義されている。 シャープ記号に続くのは、3組 の16進数の数字だ。 1番目は00 から FFhで表現した赤のレベル、 2番目は緑 のレベル、3番目は青のレベルとなる。 3要素とも 00h の場合は黒、 3要素とも FFh の場合は白となる。 3つの要素の値が同じであれば、グレーの濃淡を表現で きる。

1920 × 1080のディスプレイの場合、200万ピクセルそれぞれに赤、緑、青 の3バイトが必要で、 合計600万バイト、つまり6メガバイトが必要となる。

前章では、 CPU がアクセスする RAM をひとかたまりのメモリーとして扱っ た。 RAM は実際、コードやデータを含む領域と、 映像表示に充てられる領域を 共有する。 この構成により、 コンピュータは RAMにバイトを書き込むだけで 映像表示を高速に更新でき、 非常に高速なグラフィックスアニメーションが可 能になる。

これまでの数章で作ってきた8ビット CPUは、16ビットのメモリーアドレ スで64KB [キロバイト] のメモリーを扱える。 6MB [メガバイト] のビデオメモ リーを64KBのメモリーに収められないのは明らかだ! (実際には、 CPU のメ モリー空間から複数のメモリーチャンク [断片] をスワップイン/アウトする [一 部のデータを出し入れすることで少ないメモリーで大きなデータを使える〕 ような仕組みを 作ることはできるかもしれないが、 確実にスピードが落ちるだろう)。

以上が、 高解像度のビデオディスプレイが、 メモリーが安価になり、より強力 な CPU がこのメモリーに敏捷にアクセスできるようになって初めて実現できた 理由だ。 32ビット CPU は一度に32ビット (4バイト) のデータをメモリーに

出し入れできる。 このため、 ビデオディスプレイメモリーは赤、緑、青の3要 素に必要な3バイトだけでなく、 しばしばピクセルあたり4バイトで展開され る。これにより、 1920 × 1080 のディスプレイのビデオメモリーは、6MB では なく8MBのメモリーを必要とするようになる。

このビデオメモリーは通常、ディスプレイがリフレッシュされる順序と同じ順 序で配置される。 最初の行 (一番上の行) の左端のピクセルから始まる。 つまり、 赤、緑、青の3要素に対する3バイト、 さらに、 未使用の1バイトだ。 画面上 に何かを描くには、 テキストであろうとグラフィックスであろうと、 グラフィッ クスメモリーのどのピクセルを設定するかをプログラムで決める必要がある。

コンピュータグラフィックスはしばしば、 解析幾何学に関連した数学的表現に 基づいて描画される。 ディスプレイ全体、 またはディスプレイ上の小さい長方形 の領域は、すべてのピクセルを水平および垂直座標 (x,y) の点として表現でき る単純な座標系で扱える。 たとえば、 座標位置 (10,5)のピクセルは、左から 10ピクセル、上から5ピクセルの場所を指す。 その点から (15,10)の位置ま で対角線を引くと、 (10,5)(116) (127) (13,8)、(14,9)(1510) の 各ピクセルに色をつけられる。 もちろん、ほかの種類の線や曲線はより複雑にな

るが、 それらの描画を支援するソフトウエアツールはたくさんある。

テキストはグラフィックスのサブセットだ。 特定のフォントの各文字は、テキ ストを最大限に読みやすくレンダリング [表示] するための「ヒント」 と呼ばれ る) 追加情報を持つ直線と曲線の集まりで定義される。

3Dグラフィックスは、 光と影の効果を表現するために様々な種類のシェー ディング [濃淡あるいは陰影づけ] を使用し、 より複雑になる。 最近では、 3D グラ フィックスに必要な大量の計算を処理するために、 GPU (Graphics Processing Unit) を活用することが多い。

パソコンが普及し始めた当時、 高解像度のディスプレイは実現不可能だった。 IBM PC で最初に採用されたグラフィックス・ディスプレイは、 CGA (Color Graphics Adapter) と呼ばれ、3つのグラフィックス・フォーマット(または モード) に対応していた。 160 × 100ピクセルで16色 (ただしピクセルあた り1バイト) 320 × 200 ピクセルで4色 (1ピクセルあたり2ビット) 640× 200 ピクセルで2色 (1ピクセルあたり1ビット) の3種類だ。 モードに関係な く 16,000 バイトのメモリーしか必要としなかった。 たとえば、 横320ピクセ

530

第25章 周辺機器 531

ル×縦200ピクセル×1ピクセルあたり1/4バイトで、 16,000 バイトとなる。

初期のコンピュータのディスプレイには、グラフィックスをまったく表示でき ず、 文字だけに限定されたものもあった。 これはメモリー容量を削減する別の方 法で、 初期の IBM PC で利用可能だったもう1つのディスプレイである、モノ クロームディスプレイアダプター (MDA) を生み出した。 MDA は、 黒い背景 の上で緑色の1色を用いて、 横80文字のテキストを25行しか表示できなかっ 文字は8ビットのASCIIコードで指定され、 明るさ、 反転、 下線、 また は点滅を指定できる 「属性」 バイトが付随していた。 したがって、 ディスプレイ の内容を保存するために必要なバイト数は、 25 × 80 × 2 つまり 4,000 バイ トだった。ビデオアダプターには、 各 ASCII 文字をピクセルの行と列に変換す るための読み取り専用メモリーを使用する回路が含まれていた。

CPU の内部に、 CPU の部品間でデータを移動させるための内部バスがあるよ うに CPU 自身も通常、 CPUやメモリー 周辺機器との間でデータを移動させ ある外部バスに接続されている。 ビデオディスプレイ用のメモリーは、 CPU の通 常のメモリー空間を占有する。 ほかの周辺機器もおそらくそうだ。 このやり方は メモリーマップド I/O と呼ばれる。 しかし、 CPU は、 メモリーは共有する一方、 周辺機器にアクセスする別のバスを備え、これらの入出力デバイスを操作する特 別な機能を持つこともある。

ここまでの数章で、 インテル 8080 マイクロプロセッサをベースにした CPU を作ってきた。 8080 が実装している 244個の命令の中に IN と OUT という 名前の命令がある。

命令 IN port OUT port

オペコード

説明 入力ポートから1バイトを読み出す 出力ポートに1バイトを書き込む DBh D3h

どちらの命令にも、8ビットのポート番号が続く。 これはメモリーアドレスに 似ているが、幅は8ビットであり、I/Oデバイス用に使われることが意図されて いる。 IN 命令はそのポートからデータを読み出し、 結果をアキュムレータに保 存する。 OUT 命令は、 アキュムレータの内容をそのポートに書き込む。8080 からの特別な信号が、 RAM にアクセスしているのか (通常の場合)、 それとも

532

I/Oポートにアクセスしているのかを示す。

たとえば、デスクトップパソコンやノートパソコンのキーボードを考えてみよ う。キーボードの各キーは、キーが押されると閉じるシンプルなスイッチだ。 各 キーは固有のコードで識別される。 このキーボードは、 ポート番号25h として アクセスされるように設定されているとしよう。 すると、 プログラムは次のよう に命令を実行する。

IN 25h

これによりアキュムレータには、どのキーが押されたかを示すコードが格納され る。

このコードがキーに割り当てられた ASCIIコードだと思いたいところだ。し かし ASCIIコードを返すハードウエアを設計することは現実的ではなく、望ま しくない。 たとえば、キーボードの 「A」 キーは、ユーザーが Shiftキーを押し たかどうかに応じて、 ASCIIコードの41h または 61h に対応しうる。 Shiftキー は、入力された文字が小文字か大文字かを決定するキーだ。 また、 コンピュータ のキーボードには、 ASCII 文字に全く対応していないキー(機能キーや矢印キー など) も多い。 短いコンピュータプログラムを用意すれば、 キーボードで押され た特定のキーに対応する ASCIIコード (もしあれば)を把握できる。

プログラムは、 キーボード上でキーが押されたことをどうやって知るのだろ う? 1つの方法は、プログラムがとても頻繁にキーボードをチェックするやり 方だ。 このアプローチをポーリングと呼ぶ。 しかし、 よりよいアプローチは、 キーが押されたときに何らかの方法でCPUに通知することだ。 一般的なケース では、 I/O デバイスは、インタラプト [割り込み] と呼ばれる特別な信号を CPU に送ることで、そのようなイベントを CPUに通知できる。

割り込みを支援するために、 8080CPUはリスタート命令と呼ばれる8つの命 令を実装している。

第25章 周辺機器

説明

命令

オペコード

533

RST 0

RST 1

RST 3

アドレス 0000h をコール C7h

アドレス 0008h をコール CFh

RST 2 アドレス 0010h をコール

RST 4

D7h

アドレス 0018h をコール DFh

アドレス 0020h をコール E7h

RST 5

アドレス 0028h をコール EFh

RST 6 RST 7 アドレス 0038h をコール FFh

アドレス 0030h をコール F7h

これらの命令が呼ばれると、 いずれの場合も CPU は現在のプログラムカウン ターをスタックに保存し、 メモリーアドレス 0000h, 0008h, 0010hにジャ ンプする。 RST 0 は基本的に CPU のリセットと同じだが、 そのほかの場所には ジャンプ命令やコール命令が含まれている場合がある。

仕組みはこうだ。 8080CPUには、外部からの割り込み信号が定義されている。 周辺機器(物理キーボードなど) がこの割り込み信号を発生させると、 リセット 命令で処理するためのバイトもデータバスに置かれる。 その割り込み信号によっ て実行されるメモリー位置には、特定のI/Oデバイス (この例では物理キーボー ド) を処理するためのコードが置かれている。

これを割り込み駆動型 I/O と呼ぶ。 CPU はわざわざI/Oデバイスをポーリン グする必要から解放される。 I/O デバイスが割り込み信号を使って CPU に新し いイベントの発生を知らせるまでは、CPUはほかの処理を行える。 このように してキーボードは、キーが押されたことを CPU に知らせることができる。

また、デスクトップパソコンやノートパソコンのマウス、ノートパソコンの タッチパッド、 タブレットや携帯電話のタッチスクリーンなどにも、 割り込み信 号を使うことが望ましい。

マウスはビデオディスプレイに直接接続されているように見える。 何しろ、机 上でマウスを上下左右に動かすと、 画面上のマウスポインターがそれに応じて動 くからだ。 しかし、それはただの幻想にすぎない。 マウスは、移動した方向を示 す電気パルスを送信する。 マウスポインターを異なる場所に再描画するのは、ソ フトウエアの責任だ。 マウスはその動きだけでなく、マウスボタンが押されたと

534

きや離されたとき、 またはスクロールボタンが回されたとき、コンピュータに信 号を送る。

タッチスクリーンは通常、 ビデオディスプレイ上にあるレイヤー []により、 指で触れたときの電気容量の変化を検出できる。 タッチパネルは、 プログラムが 画面にグラフィックスを表示する際に使用するのと同じ (x,y) 座標を使用して、 1本または複数の指の位置を示すことができる。 また、 指が画面に触れたとき、 画面から離れたとき、 画面に触れているとき、といった動きなどをプログラムに 通知できる。この情報は、画面をスクロールさせたり、 グラフィカルなオブジェ クト [操作対象] を画面上でドラッグしたりといった様々な指示を実行する際、 プログラムを支援するために利用できる。 また、ピンチやズームなどの2本指 のジェスチャーの動きをプログラムが解釈することも可能だ。

コンピュータの内部は、すべてデジタルだ。 すなわち、 すべてが数字である。 だが、現実の世界はアナログであることが多い。 私たちの光や音に対する感覚 は、離散的な数値ではなく、 連続的なものとして捉えられる。

そこで、 現実のアナログデータを数値に変換したり、 数値からアナログデータ に変換するために、 2つのデバイスが考案された。

・アナログ/デジタルコンバーター (ADC) ●デジタル/アナログコンバーター (DAC)

ADCの入力は2値の間で連続的に変化する電圧で、 出力はその電圧を表す 2進数となる。 ADCの出力は8ビットまたは16ビットが一般的だ。 たとえば、 8ビット ADCの出力は、 入力電圧が0ボルトなら 00h 2.5 ボルトなら80h、 5 ボルトならFFh といった出力となる。

DACは反対の動作を行う。 入力は2進数、 データの幅は8ビットか16ビッ トで、 出力はその数字に対応する電圧となる。

DAC は、 ビデオディスプレイにおいて、 ピクセルのデジタル値を電圧に変換 し、各ピクセルの赤、緑、青の光源の強さを制御するために使用される。

デジタルカメラでは、光に反応して電圧を発する APS (アクティブピクセル センサー)アレイを使い、 ADC で光の強さをデジタル数値へと変換する。 その 結果、ビットマップと呼ばれるデータが生成される。 ビットマップは、各ピクセ ルが特定の色である2次元の配列だ。 ビットマップのピクセルは、 ビデオディ

第25章 周辺機器 535

スプレイのメモリーと同様に、 最上段から最下段まで、各行内では左端から右端 へ順次格納される。

ビットマップは巨大化する可能性がある。 私の携帯電話のカメラは、 横4,032 ピクセル 縦 3,024ピクセルの画像を作成する。 しかし、そのデータのすべて が、画像を再現するために必要なわけではない。 そこで、 技術者や数学者は、 ビットマップの保存に必要なバイト数を減らすために複数の技術を考案してき た。 この技術は圧縮と呼ばれる。

ビットマップを圧縮する簡単な方法の1つに、ランレングスエンコーディン グ (RLE) がある。 たとえば、 同じ色のピクセルが10個並んでいる場合、 ビッ トマップはそのピクセルと数字の10を保存すればよい。 しかし、これが有効な のは、 同じ色が広範囲に含まれる画像に対してだけだ。

一般によく使用されるもっと洗練されたファイル圧縮方式は、 GIF (Graphics Interchange Format ジフと発音する) だ。 これは、かつて存在していたオン ラインサービス CompuServe [コンピュサーブ]によって1987年に開発された。 GIF ファイルは、LZW (その開発者である Lempel、Zif、Welch の頭文字に由 来する)と呼ばれる圧縮手法を使用し、 連続する同じ値のピクセルではなく、異 なる値のピクセルのパターンを検出する。 また GIF ファイルは、 複数の画像を 使用した初歩的なアニメーション機能も組み込んでいる。

GIFよりも高機能な圧縮技術が、1996年に登場した PNG (Portable Network Graphics)だ。 PNG は、 画像を隣接するピクセルの値の差分に変換する、これ は通常小さい数値になるため、 より効果的な圧縮が可能になる。

GIF や PNG のファイルは、 必ずしも非圧縮のオリジナルビットマップより小 さくなるとは限らない! 圧縮処理によって、 ある画像のサイズは小さくなって も、別の画像ではサイズが大きくなるかもしれない。 この現象は、 色数の多い画 像や細かく入り組んだ画像で発生することがある。

そうした場合には、別の圧縮技術が有効だ。 1992年に登場した JPEG (ジェ イペグと発音する) ファイル形式は、現実世界の画像をビットマップする手法と して絶大な人気を誇る。 たとえば、 現代の携帯電話のカメラは、 JPEGファイル を作成して、 共有したりダウンロードしたりできる。

JPEG は Joint Photographic Experts Group の略で、 これまでの圧縮技術と は異なり、 人間の目が画像を認識する方法を利用する視覚心理学の研究に基づい

たものだ。 特に JPEG 圧縮は、 色の急激な変化を切り捨てられるので、画像を 再現するのに必要なデータ量を削減できる。 ここには、かなり高度な数学が使わ れている!

JPEGの欠点は、可逆性がないことだ。 つまり、 一度圧縮してしまうと元の画 像に正確に戻せない。 一方、 GIF と PNG は可逆的であり、 圧縮の過程で失われ るものはない。このため、 GIF や PNG はロスレス (可逆) 圧縮技術、 JPEGは ロッシー(非可逆) 圧縮の一種に分類される。 情報が失われると、 極端な場合、 視覚的な歪みが生じることもある。

コンピュータの多くには、 現実世界の音を検出するマイクと、 音を出すスピー カーが搭載されている。

音は、 振動だ。 人間の声帯は振動し、 楽器のチューバも振動し、 森で倒れる木 も振動する。 これらの物体が空気の分子を動かす。 空気は、 1秒間に数百回、 あ るいは数千回、押したり引いたり、 圧縮されたり薄くなったりを繰り返す。 その 空気が鼓膜を振動させることで、 私たちは音を感じる。

マイクロホンは、この振動に反応して、音波に比例するように電圧が変化する 電流を発生させる。 この音の波に似たものに、 1877年にトーマス・エジソンが 初めての蓄音機で録音と再生に使用したスズ箔シリンダー表面の小さな丘と谷、 そして、 現代のオーディオ愛好者やレトロ技術の愛好者にいまだに愛されている ビニールレコードの溝をなす丘と谷がある。

しかし、コンピュータでは、こうした電圧をデジタル化、 つまり数値にする必 要がある。 これもADCの仕事だ。

デジタル化された音は、 1983年にコンパクトディスク (CD) として消費者 に大きな衝撃を与え、 家電史上最大のサクセスストーリーとなった。 CD はフィ リップスとソニーが開発し、 直径12cmのディスクの片面に74分のデジタル化 された音声を保存する。 74分という長さは、ベートーヴェンの交響曲第九番が 1枚のCDに収まるように、 と選ばれたものだ (という説がある)。

CDの音は、パルス符号変調 (PCM) と呼ばれる技術でエンコードされる。 PCM は、その派手な名前とは裏腹に、 概念的には極めて単純な処理だ。 音波を 表す電圧を一定の間隔でデジタル値に変換して保存する。 再生時には、DACを 使ってデジタルの数値を再び電流に変換する。

音波の電圧は、サンプリングレートと呼ばれる一定の速度で数値に変換され

536

第25章 周辺機器 537

る。 1928年にベル電話研究所のハリー ナイキストは、サンプリングレートは 記録/再生が必要な最大周波数の少なくとも2倍でなければならないことを示し た。 人間は通常20Hzから20,000Hzの音を聞いているとされる。 CD に使われ るサンプリング周波数は、 その最大値の2倍強、 具体的には1秒間に 44,100 回 のサンプルが行われる。

1 サンプルあたりのビット数は、CDのダイナミックレンジを決定する。 これ は、録音 / 再生可能な最も大きな音と最も小さな音の差であり、 やや複雑だ。 音 の変化に伴って電流が変化し、 電流が達するピークは波形の振幅を表す。 私たち が音の強度として知覚するものは、 振幅の2倍に比例する。 強度を表すには、1 ベル (bel アレクサンダー・グラハム・ベルの苗字に由来する) を10分の1 にしたデシベルを使用する。 1 デシベルは、人が知覚できる最小の音量の増加を おおよそ表す。

結果として、サンプルあたり 16ビットを使用することで、 96 デシベルのダ しきいち イナミックレンジの表現が可能になる。これが、聴覚の閾値 (これ以下では何も 聞こえない)と痛みの閾値 (これ以上だと耳を塞ぐかもしれない)との差だ。コ ンパクトディスクは、サンプルごとに16ビットを使用している。

ということで、コンパクトディスクには、1秒間の音に対して、 2バイトのサ ンプルが44,100個入っている。 しかし、 おそらくステレオである必要があるの で、合計はその2倍の176,400 バイト / 秒になる。 これは1分間に10,584,000 バイトの音が入っていることになる。 CDに収録されている74分のステレオサ ウンドには、 7億8321万6000 バイトが必要だ。 1980年代までデジタル録音が 一般的でなかった理由が理解できただろう。 のちの CD では、その容量が多少 増えている。

近年、 メディアとしてのCDの重要性は薄れてきているが、デジタルサウン ドのコンセプトは変わらない。 家庭用パソコンで録音/再生する場合には、必ず しもCD 品質は必要ではないため、 22,050Hz、 11,025Hz、 8,000Hz などの低 いサンプリングレートが用意されていることも多い。 8ビットという少ないサン プルサイズで録音することもでき、モノラルで録音すればデータ量をさらに半分 にできる

ビットマップと同様に、オーディオファイルも圧縮することで、ストレージを 減らし、 コンピュータ間のファイル転送に必要な時間も短縮できる。 音声の一般

的な圧縮手法としてMP3が有名だが、これは映画用の圧縮技術である MPEG (Moving Picture Experts Group) の一部として始まった。 MP3 はロッシー圧 縮だが、音楽の知覚に大きく寄与しないデータを減らすために音響心理学解析を 利用している。

GIF、PNG、JPEGで圧縮されたビットマップやMP3 で圧縮されたオーディ オは、 特にプログラムが情報を扱っている間はメモリーを占有するが、 何らかの 記憶装置にファイルとして保存されることがほとんどだ。

思い出してほしい。 リレーや真空管、 トランジスタなどで構成されたランダム アクセスメモリーは、電源を切ると内容が消えてしまう。 そのためコンピュータ には、長期保存できる 「何か」が必要だ。 古典的な方法の1つは、IBMのパン チカードなど、紙やダンボールに穴を開けるやり方だ。 小型コンピュータの黎明 期には、プログラムとデータを保存し、 あとでメモリーに再ロードするために、 紙テープのロールに穴を開けていた。 それよりも一歩進んだのが、1980年代に 音楽の録音と再生にも人気だったオーディオカセットテープの利用だ。 これは、 大型コンピュータがデータの大量保存に使用していた磁気テープの小型版にすぎ なかった。

しかしテープは、 任意の位置に素早く移動できないため、保存と検索のために は理想的な媒体ではない。 早送りや巻き戻しにも時間がかかる。

これに対して幾何学的に高速アクセスが可能な媒体として、ディスクがある。 ディスク本体は軸を中心に回転し、 アームに取り付けられた1つまたは複数の ヘッドがディスクの外側から内側へ移動する。 ディスク上のどの領域にも高速に アクセスできる。 ディスク上の小さな領域を磁化することで、 ビットが記録され る。コンピュータに使われる最初のディスクドライブは、1956年にIBM で発明 された。 そのRAMAC (Random Access Method of Accounting and Control) には、 直径2フィート (約61センチメートル) の金属製ディスクが50枚入っ ていて、 5メガバイトのデータを保存できた。

一方パソコンでは、 厚紙やプラスチックでできた保護ケースの中に、コーティ ングされた小さなプラスチックシートが1枚入ったものが主流だった。 これは フロッピーディスクまたはディスケットと呼ばれるもので、最初は直径 8イン チ、 次に 5.25インチ、 さらに3.5インチとなった。 フロッピーディスクはディ スクドライブから取り出せて、パソコンからほかのパソコンへのデータ転送にも

538

第25章 周辺機器

539

利用できた。 また、ディスケットは市販ソフトの重要な配布媒体でもあった。 ディスケットは、3.5インチのそれを描いた小さな絵が、 多くのコンピュータプ リケーションの 「保存」 アイコンとして残っている以外は、すべて姿を消した。

現在も一部のパソコンに搭載されているハードディスクは通常、 複数の金属製 円盤がドライブ内に恒久的に内蔵されている。 ハードディスクは一般的にフロッ ピーディスクよりも高速で、 より多くのデータを保存できるが、 ディスク自体を 簡単に取り外すことは不可能である。

最近のストレージは、 コンピュータ (あるいはタブレットや携帯電話)に内蔵 されたSSD (ソリッドステートドライブ) や、 携帯用 USBメモリー内のフラッ シュメモリーという形態で使われることが多くなってい

大容量記憶装置は、コンピュータ上の様々なソースから発生する様々なサイズ のファイルを収容する必要がある。 これを容易にするために、 大容量記憶装置は セクターと呼ばれる一定の大きさの領域に分割されている。 フロッピーディスク やハードディスクのセクターサイズは512バイトであることが多かった。 SSD のセクターサイズは512バイトや4,096 バイトであることが多い。

すべてのファイルは1つまたは複数のセクターに保存される。 セクターサイ ズが512バイトでファイルが512 バイト未満の場合、 ファイルの保存には1セ クターしか必要としないが、 余ったスペースをほかの用途には使えない。 513 バ イトのファイルには2つのセクターが必要であり、1メガバイトのサイズのファ イルには 2,048 個のセクターが必要となる。

特定のファイルに関係するセクターは連続である必要はない。 ドライブのあち こちに散らばることもありうる。 ファイルが削除されると、ほかのファイルのた めにセクターが解放される。 新しいファイルが作成されると、 利用可能なセク ターが使用されるが、 セクターは必ずしもグループ化されていない。

ファイルの保存や取り出しなど、これらすべてを管理するのが、オペレーティ ングシステムと呼ばれる非常に重要なソフトウエアだ



第26章

オペレーティングシステム

私たちはついに、少なくとも私たちの想像の中では、 完全なコンピュータと思 えるものを作り上げた。 このコンピュータは、 中央演算処理装置 (CPU) ラン ダムアクセスメモリー(RAM)、 キーボード、 RAMの一部をメモリーに使うビ デオディスプレイ、 そして、 何らかの大容量記憶装置を備えている。 ハードウエ アはすべて揃っており、 電源を入れ、 命を吹き込むオンオフスイッチをワクワ クしながら見つめている。 もしかしたら、このプロジェクトは、ヴィクター・フ ランケンシュタインが怪物を組み立てた作業や、 ゼペットがピノキオと名づけた 木製の人形を作った作業を思い起こさせたかもしれない。

しかし、私たちはまだ何かを欠いている。 それは雷の力でも、星に対する純粋 な願いでもない。 さあ、 この新しいコンピュータをオンにして、 何が見えるか教 えてほしい。

画面が点滅してオンになると、ランダムなゴミが表示される。 グラフィックス アダプターを実装した場合には、 多くの色の点が映るものの、何1つ首尾一貫 していない。 テキストのみのビデオアダプターの場合、 ランダムな文字が表示さ れる。これは予想通りだ。 半導体メモリーは、電源が切れるとその内容を失い、 最初に電源を入れたときはランダムで予測不可能な状態で始まる。 マイクロプロ セッサ用に構築された RAM はランダムなバイトを含んでいる。 マイクロプロ セッサは、これらのランダムなバイトを機械コード (マシンコード)として実行 し始める。これによって何か悪いことが起こるわけではない。 たとえば、 コン ピュータが爆発するわけではない。 だが、 生産的でもないだろう。

ここに足りないのはソフトウエアだ。 マイクロプロセッサは最初にオンになる かリセットされたとき、特定のメモリーアドレスから機械コードを実行し始め る。 インテル8080 の場合、 そのアドレスは 0000h だ。 適切に設計されたコン ピュータでは、そのメモリーアドレスには、コンピュータの電源を入れたときに CPU が実行する機械コード命令 (多くの命令のうちの最初の1つ)が含まれて いるはずだ。

だが、その機械コードの命令は、 どのようにそこに置かれるのだろう? 新しく 設計されたコンピュータにソフトウエアを入れる作業は、手間のかかることの多 い作業だ。 それを行う1つの方法は、 ランダムアクセスメモリーにバイトを書 き込んで、 読み取れるようにするために、 第19章で使用したものに似たコント ロールパネルを使うことだ。

1 1 64-KB RAM Control Panel TTTTTT ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ A15 A14 A13 A12 A11 Aro Ag Ag A7 A6 As A4 A3 A2 A1 Ao 1 D7 D D D4 D3 D2 D Do 0 MAR Reset Write Takeover

先に示したコントロールパネルとは異なり、 「リセット (Reset)」 と書かれた スイッチがある。 リセットスイッチは、 CPU のリセット入力に接続されている。 そのスイッチがオンである限り、 マイクロプロセッサは何もしない。 スイッチを オフにすると、 マイクロプロセッサはアドレス 0000h から機械コードの実行を 開始する。

このコントロールパネルを使用するには、 リセットスイッチをオンにしてマイ クロプロセッサをリセットし、 機械コードの実行を停止させる。 テイクオーバー (Takeover) スイッチをオンにすると、 アドレスバスとデータバスの信号にアク セスできるようになる。 このとき、 A6 ~ Ais と書かれたスイッチで、 16ビット のメモリーアドレスを指定できる。 DD, と書かれた電球は、そのメモリー

542

第26章 オペレーティングシステム

アドレスの8ビットの内容を示している。 そのアドレスに新しいバイトを書き 込むには、 スイッチ D ~D, でバイトを設定し、 書き込み (Write) スイッチを オン (1) にして、 またオフ (0) にする。 メモリーにバイトを入れ終わったら、 テイクオーバースイッチをオフにして、リセットスイッチをオフにすると、マイ クロプロセッサがプログラムを実行する。

こうして、ゼロから作ったばかりのコンピュータに、 最初の機械コードのプロ グラムを入力する。 もちろん、 それは耐え難いほど骨の折れる作業だ。 言うまで もない。 当然、時折小さなミスが起きる。 指にマメができたり、 脳がとろけそう になったら、 職業病だ。

しかし、それらの入力に価値を見いだすのは、 ビデオディスプレイにプログラ ムの結果が表示され始めたときだ。 ここでは、 数字をASCIIに変換する小さな サブルーチンを書いてみよう。 たとえば、 結果が4Bh になるプログラムを書い た場合、ディスプレイに 「4B」 を表示するために、 単純にその値をビデオディ スプレイメモリーに書き込むことはできない。 それだと画面に表示されるのは、 ASCIIコード 4Bh に対応する 「K」 という文字だ。 そうではなく、 2つの ASCII 文字を表示する必要がある。 「4」 を示す ASCIIコードの34h と 「B」 を 示す ASCIIコードの42hだ。 すでにそのような動作をするコードを見たことが あるはずだ。 第24章520ページにある ToAscii ルーチンである。

最優先事項の1つはおそらく、このばかげたコントロールパネルを取り除く ことだ。 そのためにはキーボードハンドラーを書く必要がある。 キーボードハン ドラーとは、キーボードから入力された文字を読み取り、メモリーに保存し、 画 面にも書き込むプログラムだ。 キーボードから画面に文字を転送する動作はエ コーとも呼ばれ、 まるでキーボードとディスプレイが直接つながっているように 錯覚させる。

このキーボードハンドラーを拡張して、単純なコマンドを実行するのはどうだ ろう。 つまり、キーボードハンドラーに有用な何かを行わせるのだ。 これらのコ マンドを処理するために書かれたコードは、 コマンドプロセッサと呼ばれる。最 初は単純さを重視して、3つのコマンドだけを決めよう。 次ページに示す3つの コマンドは、 行の最初に入力された文字に対応する。

543

Wは書き込み (Write) ・D は表示 (Display) ・R は実行 (Run)

コマンドの入力が終了したことを知らせる Enter キーを押すと、 キーボードハン ドラーはこれらのコマンドを実行する。

行頭がW の場合、 このコマンドは 「メモリーに何バイトか書き込む」 という 意味になる。 画面に入力する行はこんな感じになる。

W1020 35 4F 78 23 9B AC 67

このコマンドは、 メモリーにアドレス 1020hから16進数のバイト 35h、 4Fh、 ・・・・・などを書き込むようにコマンドプロセッサに指示するものだ。 この作業で は、キーボードハンドラーは ASCIIコードをバイトに変換する必要があるが、 これは先に示した ToAscii 変換の逆バージョンである。

テキスト行がDで始まる場合、 そのコマンドはメモリー内のバイトの表示を 意味する。 画面に入力する行は次のようになる。

D 1030

コマンドプロセッサは、 アドレス 1030hに格納されたバイトを表示する。 Dコ マンドを使うことで、 メモリーの中身を調べることができる。

テキスト行がRで始まる場合、 そのコマンドは実行を意味する。 次のように なる。

R 1000

このコマンドは、 「アドレス 1000h 以降に格納されているプログラムを実行せよ」 という意味だ。 コマンドプロセッサは、レジスターペア HL に 1000h を格納し、 その後、 レジスターペアHLからプログラムカウンタをロードする命令PCHL を実行して、 そのアドレスにジャンプすることができる。

このキーボードハンドラーとコマンドプロセッサを動作させることが重要なマ イルストーン [中間目標] だ。 これさえあれば、もうコントロールパネルごとき に悩まされることはない。 キーボードからの入力がより簡単に、 より速く、 より

544

洗練される。

第26章 オペレーティングシステム

もちろん、 電源を切ると入力したコードがすべて消えてしまうという問題は残 る。このため、おそらくこの新しいコードをROM (Read Only Memory [ 読み出 専用メモリー]) に保存したいと思うだろう。 インテル 8080 などの初期のマイ クロプロセッサの時代になると、 ROMチップを自宅でプログラミングできるよ うになった。 PROM (Programmable read-only memory [プログラム可能な読み出 し専用メモリー]) チップは、 一度だけプログラムをすることができる。 また EPROM (Erasable Programmable Read Only Memory [消去可能な読み出し専用メ モリー]) チップは、 紫外線を照射して完全に内容を消去したのち、 再プログラミ ングが可能だ。

キーボードハンドラーの入った ROM は、 以前は RAMで占められていた 00000 から始まるアドレス空間を占有することになる。 もちろん、これまでの RAM もメモリー空間のやや上のアドレスに置かれることになる。

コマンドプロセッサの誕生は、 メモリーへのバイト入力の高速化だけでなく、 コンピュータがインタラクティブ [対話的] になったという意味でも重要なマイ ルストーンとなった。

コマンドプロセッサをROM化したら、 メモリーからディスクドライブにデー タを書き込んだり、 反対にデータをディスクドライブからメモリーに読み出した りする実験に取りかかろう。 プログラムやデータをディスクに保存することは、 RAM に保存するよりもずっと安全で(何しろ RAM は電源が落ちると消えてし まうのだから)、 ROM に保存するよりもずっと柔軟にデータを扱える。

いずれは、コマンドプロセッサに新しいコマンドを追加したいと思うだろう。 たとえば、 Sコマンドは、 特定のディスクセクターのグループにメモリーをスト ア [保存] することを意味し、 Lコマンドは、そうしたディスクセクターの内容 をメモリーにロード [読み出し] することを意味するようにできるだろう。

もちろん、どのディスクセクターに何を保存しているかを把握しておく必要が ある。そのために、 メモ帳と鉛筆を準備しようとしているかもしれない。 だが、 ここで注意が必要だ。 あるアドレスに置かれていたコードをディスクに保存し、 それをあとで別のアドレスのメモリーにロードし直しても、そのまま機能するこ とは期待できないのだ。 何しろジャンプとコールの命令は、すべて古いアドレス を指しているので、 間違っていることになる。 また、 ディスクのセクターサイズ

545

546

よりプログラムが長い場合もあるので、 その場合は複数のセクターに分割して格 納する必要もある。 ディスクのセクターには、ほかのプログラムやデータで占有 されているものと空いているものがあるため、長いプログラムを格納しようとす るとそのセクターがディスク上で連続しない場合がある。

結局、 ディスクのどこに何が保存されているかを把握するための、 手作業によ る事務作業が過剰な負担になるかもしれない。 そうなったら、 ファイルシステム の出番だ。

ファイルシステムとは、データをファイルとして整理するソフトウエアのこと だ。 ファイルとは、ディスク上の1つまたは複数のセクターを占有した、 関連 データの集まりにすぎない。 最も重要なのは、 各ファイルがファイル名で識別さ れ、そこに何が含まれるかを思い出すのに役立つことだ。 ディスクは、それぞれ のファイルに名前を示す小さなタブ [つまみ] がついた、 ファイルキャビネット のようなものなのだ。

ファイルシステムは、ほとんどの場合、 オペレーティングシステムとして知ら れる、より大きなソフトウエアの集合体の一部だ。 本章で構築してきたキーボー ドハンドラーとコマンドプロセッサは、オペレーティングシステムへと確実に進 化できる。 しかし、 その長い進化の過程を長々と歩んでいく代わりに、 実際のオ ペレーティングシステムを見て、それが何をし、 どのように動作するのかを感じ てみよう。

歴史的に見ると、8ビットマイクロプロセッサ用の最も重要なオペレーティン グシステムは CP/M だ。 もともとは Control Program/Monitor [コントロールプロ グラム/モニター] の略で、のちに Control Program for Microcomputers [マイクロ コンピュータ用コントロールプログラム] の略となった。 これは、のちにDRI (デジタ ルリサーチ) を創業するゲイリー・キルドール (1942-1994) が 1970年代半ば にインテル 8080 向けに書いたものだ。

CP/M はディスクに格納されていたが、ディスクの大部分はユーザーのファイ ルを格納するために利用できた。 CP/M ファイルシステムはかなりシンプルだ が、2つの主要な要件を満たしている。 第1に、 ディスク上の各ファイルは、 ディスク上に保存された名前で識別される。 第2に、 ファイルはディスク上で 連続したセクターを占有する必要はない。 様々なサイズのファイルが作成され、 削除されると、 ディスク上の空き領域が断片化することがよくある。 非連続のセ

第26章 オペレーティングシステム

クターに大きなファイルを保存できるファイルシステムの能力は非常に便利だ。 ファイルとディスクセクターを対応づける表もディスク上に保存される。

CP/M では、各ファイルは2部構成の名前で識別される。 最初の部分はファ イル名として知られ、 最大8文字である。 2番目の部分はファイルタイプまたは 拡張子として知られ、 最大3文字だ。 いくつかの標準的なファイルタイプがあ る。 たとえば、 TXT はテキストファイル (ASCIIコードのみを含む、 人間が読 めるファイル)、COM (コマンドの略) は8080の機械コード命令を含むファイ ル (すなわちプログラム) を表す。

このファイル命名規則は、 ピリオドの前に最大8文字、 後ろに3文字という 意味で、8.3 (エイトドットスリー [はってんさん]) と呼ばれるようになった。 最 近のファイルシステムには、8文字や3文字という制限は存在していなが、この ようなファイル名のつけ方は、今でもごく一般的だ。

CP/M を使用したコンピュータには、ブートストラップローダーとして知られ る小さなコードの断片が ROMに含まれていた。 そう命名された理由はそのコー ドが、ブーツのブートストラップ [つまみ革] のように、オペレーティングシス テムの残りの部分を 「引っ張り上げる」 ために使われたからだ。 ブートストラッ プローダーは、 ディスクから最初のセクターをメモリーにロードし、 実行する。 このセクターには、 CP/M の残りの部分をメモリーにロードするコードが含まれ る。この全プロセスは、オペレーティングシステムをブートすると呼ばれ、今で も広く使用されている用語だ。

CP/M自体は階層構造で構成されていた。 最下層にはBasic Input/Output System、 つまり BIOS (バイオスと発音する) があった。 ここには、コンピュー タのハードウエアに直接アクセスするコードや、 ディスクセクターの読み書きを 含むコードが含まれていた。 CP/M を実行するコンピュータのメーカーはそれぞ れ、各社固有のハードウエア用に自分たちのBIOS を提供していた。

最下層の次の層が、 BDOS (Basic Disk Operating System、 ビードスと発音 する)だ。 BDOS の主な機能は、 BIOS が扱うディスクセクターをファイルと して整理することである。

CP/Mはメモリーへのロードが終わると、 CCP (Console Command Processor) と呼ばれるプログラムを実行し、 画面にプロンプト [入力を促すしる L] を表示する。

547

A>

複数のディスクドライブを持つコンピュータでは、 この 「A」 は最初のディス クドライブ、 つまり CP/Mのロードが行われたディスクドライブを指す。 プロ ンプトは、 「何かを入力して Enter キーを押してください」 という合図だ。 ほと んどのコマンドは、 ファイルを扱うためのものだった。 たとえば、 ファイルの一 覧表示(「ディレクトリ」 を意味する DIR) 消去 (「イレース」のERA)、名前 の変更(「リネーム」 のREN)、 内容の表示 (「タイプ」 の TYPE) などである。 CP/M が自分のコマンドとして認識しない名前は、ディスクのどこかに保存され ているプログラムの名前であると見なされる。

CP/M には、各プログラムが使用できるサブルーチンのコレクションも含まれ ていた。 たとえば、 キーボードからの読み出し、 ビデオディスプレイへの文字の 書き込み、 ディスク上のファイルへのデータの保存、 そのファイルの内容のメモ リーへの読み出し、 などである。

CP/M で実行されるプログラムは、 CP/M の BDOS 部分が下働きとしてハー ドウエアにアクセスするため、 プログラム自体がコンピュータのハードウエアに 直接アクセスする必要はなかった。 これは、 CP/M 用に書かれたプログラムは、 下位のハードウエアについて知らなくても、 CP/M を実行している任意のコン ピュータ上で動くことを意味する。 これはデバイス独立性として知られる原則 で、商業ソフトウエアの開発には不可欠だった。のちに、 このようなプログラム はアプリケーションまたはアプリとして知られるようになった。

オペレーティングシステムが提供するサブルーチンの集合体は、 アプリケー ションプログラミングインターフェース (API、 エーピーアイと発音する) と呼 ばれる。 理想的な世界では、 アプリケーションプログラムのプログラマは API についてだけ知っていればよく、 APIがどのように実装されているか、 また、 APIがアクセスするハードウエアについて知る必要はない。 ただし、 現実には、 少しばかり知識があると便利な局面はある。

コンピュータを使う人にとって、オペレーティングシステムはユーザーイン ターフェース、つまりUIだ。 CP/M の場合は、 CCPが実装したコマンドライ ンインターフェース (CLI) がこれに相当する。 プログラマにとって、 オペレー ティングシステムはAPIでもある。 すなわちアプリケーションプログラムが利

548

第26章 オペレーティングシステム

用できるサブルーチンの集合体なのだ。

CP/M の場合、これらのサブルーチンはメモリーの 0005h という場所に共通 のエントリーポイントを持ち、 プログラムはそのメモリーロケーションをコール する [呼び出す] ことで、 これらのサブルーチンのいずれかを使用することになっ ていた。

CALL 0005h

あるいは、もっと単純に次のように呼び出す。

CALL 5

これは「コール5」 インターフェースとして知られていた!

具体的なルーチンは、レジスターCの値で指定されていた。 以下にいくつか 例を示そう。

レジスターC CP/M コール5 ファンクション Olh コンソール入力 (キーボードから1文字読み出す) 02h 09h コンソール出力 (ディスプレイに1文字書き込む) 文字列表示 (文字列を表示する) 15h ファイルを開く (既存のファイルを使う) 16h ファイルを閉じる (ファイルの利用を終了する) 20h シーケンシャルリード (ファイルから複数バイトを読み出す) 21h 22h シーケンシャルライト (ファイルに複数バイトを書き込む ) 新規ファイル (新規にファイルを作成する)

これらの機能の中には、 さらに多くの情報を必要とするものがよくある。 たと えば、Cが09h の場合、 レジスターペアDEには、ディスプレイに書き込む ASCII 文字のアドレスが格納される。 ドル記号 ($) が、 文字列の終わりを示す ために使用される。

CALL 5は実際にはどのような動作を行うのだろうか? 0005hのメモリー位 置には、 CP/M によってJMP命令が設定されており、 CP/M の BDOS 部分の 位置にジャンプして、レジスターCの値をチェックし、適切なサブルーチンに

549

550 |

ジャンプする。

CP/M はかつて8080のオペレーティングシステム (OS) として非常に人気 があり、歴史的に重要であることに変わりはない。 CP/M は、 シアトル・コン ピュータ・プロダクツ (SCP) のティム・パターソンが16ビット CPU の 8086 と 8088用に書いた QDOS (Quick and Dirty Operating System) という 16 ビットオペレーティングシステムに大きな影響を及ぼした。 QDOSは最終的に 86-DOS と改名され、マイクロソフトにライセンスされた。 このオペレーティ ングシステムは、MS-DOS (Microsoft Disk Operating System、 ドイツ語の冠 詞das のように em ess dahsエムエスダスと発音する) という名前で、 1981年 に発売された最初の IBM パーソナルコンピュータ用にライセンスされた。 IBM PC用には 16 ビット版の CP/M (CP/M-86 と呼ばれる) も利用できたが、 MSDOS がすぐに標準になった。 MS-DOS (IBM のコンピュータでは PC-DOS と 呼ばれる) は、 IBM PC と互換性のあるコンピュータを作成したほかのメーカー にもライセンスされた。

名前が示すように、 MS-DOS は主としてディスクオペレーティングシステム であり、これは Apple II用に 1978年に作成された Apple DOS と同様のもの だった。 ディスクにファイルを書き込み、 それらのファイルを読み出す機能以外 は、ほとんど提供されていなかった。

理論的には、 アプリケーションプログラムは、オペレーティングシステムに よって提供されるインターフェースを通じてのみ、 コンピュータのハードウエア にアクセスすることになっている。 しかし、 1970年代と1980年代の多くのプ ログラマは、 特にビデオディスプレイの処理に対しては、 オペレーティングシス テムを迂回することが多かった。 ビデオディスプレイメモリーにバイトを直接書 き込むプログラムは、そうでないプログラムよりも高速に実行できたからだ。 実 際、 ビデオディスプレイにグラフィックスを表示する必要があるアプリケーショ ンなどでは、オペレーティングシステムは全く不向きだった。 多くのプログラマ が初期のオペレーティングシステムで最も気に入っていた点は、それらが 「邪魔 をしない」 ことで、ハードウエアが許す限り速く動くプログラムを書けること だった。

家庭用コンピュータが、 大型で高価なコンピュータと大きく異なるものになる ことを最初に示したのは、おそらくアプリケーションの VisiCale [ビジカルク]

第26章 オペレーティングシステム

だっただろう。 ダン・ブリックリン (1951年生まれ) とボブ・フランクストン (1949年生まれ) が設計とプログラミングを行い、1979年にApple Ⅱ向けに発 売された VisiCale は、 スクリーンを使ってユーザーにスプレッドシートの2次 元ビューを提供した。 VisiCalc 以前のスプレッドシートは、 行と列を描いた紙 で、一連の計算処理によく使用されていた。 VisiCale は、 紙をビデオディスプ レイに置き換えた。 そして、 ユーザーがそのスプレッドシート上に数字や数式を 入力することで、 それらが変更されるごとに再計算できるようにした。

VisiCalc がすごかったのは、大きなコンピュータでは真似できないアプリケー ションだったことだ。 VisiCalcのようなプログラムは、画面を非常に速く更新 する必要がある。 そのために、 Apple II のビデオディスプレイに使われている ランダムアクセスメモリーに直接書き込みを行っていた。 このメモリーは、マイ クロプロセッサのアドレス空間の一部である。 大型コンピュータはこうしたやり 方を採用していなかったので、 真似することができなかったのだ。

コンピュータがキーボードに反応し、ビデオディスプレイを変更する速度が速 ければ速いほど、ユーザーとコンピュータの関係はより緊密なものになる。 パー ソナルコンピュータの最初の 10年間 (1980年代まで) に書かれたソフトウエ アのほとんどは、 ビデオディスプレイメモリーに直接書き込むものだった。 IBMがハードウエアの標準仕様を定め、ほかのハードウエアメーカーがそれに したがったため、ソフトウエアメーカーは、 一部のマシンでプログラムが正しく 動作しない (あるいはまったく動作しない) ことを心配することなく、オペレー ティングシステムをバイパス [迂回] してハードウエアを直接使用できた。もし、 PC クローン [IBM PC の互換パソコン] のビデオディスプレイのハードウエアイン ターフェースが異なっていたら、ソフトウエアメーカーが異なるハードウエア設 計に対応するのは難しかっただろう。

しかし、アプリケーションが増えるにつれて、 問題が表面化した。 最も成功し たアプリケーションは、画面全体を占領し、キーボードを中心として洗練された UIを実装していた。 しかし、 アプリケーションごとにUIに対する考え方が異 なるため、 ユーザーはあるアプリケーションで学んだスキルをほかのアプリケー ションに生かすことができなかった。 また、 プログラム同士もうまく共存するこ とができなかった。 あるプログラムから別のプログラムへの切り替えには、 通 常、実行中のプログラムを終了して次のプログラムを起動する必要があった。

551

552 |

一方、1970年に Xerox が設立した Palo Alto Research Center (PARC [パー ク]) では、異なるビジョンに基づいたパーソナルコンピューティングの開発が 進んでいた。

PARC での最初の大きなプロジェクトは、 1972年と1973年に設計・製造さ れた Alto [アルト] だった。 フロア設置型のシステムユニットは、 16ビット処理 が可能で、 3メガバイト (MB) のディスクドライブを2台、 128キロバイト (KB) のメモリー(512KBまで拡張可能)を搭載し、 当時としては卓越したも のだった。 Alto は、 16ビットシングルチップマイクロプロセッサの登場以前に 開発されたため、 約200個の集積回路からプロセッサを作る必要があった。

画面表示は、 Alto のいくつかの変わった点の1つだった。 スクリーンは、幅 8インチ、高さ10インチの、 紙のような大きさと形をしていた(いわゆるレ ターサイズの紙の大きさに近い)。 水平606 ピクセル×垂直 808 ピクセル、合計 489,648 ピクセルのグラフィックスモードで動作した。 1ピクセルに1ビットの メモリーが割かれていたので、 各画素は黒か白のいずれかだった。 ビデオディス プレイに充てられるメモリーの総量は 64KB で、 これはプロセッサのアドレス 空間の一部だった。

このビデオディスプレイメモリーに書き込むことで、ソフトウエアは画面に絵 を描いたり、異なるフォントやサイズのテキストを表示できた。 キーボードで入 力されたテキストを単にオウム返しするのではなく、 画面は2次元の高密度な 情報表示場所となり、 より直接的なユーザー入力の起点となった。

Alto には、3つのボタンを備えた、テーブルの上を転がるマウスという小さ な装置も付属していた。 エンジニアで発明家のダグラス・エンゲルバート (1925-2013) がスタンフォード研究所在籍中に発明したものだ。 Altoのユー ザーは、机の上でマウスを転がすことで、 画面上のポインター [マウスの位置を示 [すカーソル] を動かして画面上を操作できたのだ。

70年代、 Alto のために書かれたプログラムは、 非常に興味深い特徴を持つよ うになった。 複数のプログラムがそれぞれのウィンドウを持ち、 同じ画面に同時 に表示できたのだ。 Altoのビデオグラフィックスは、 テキストだけでなく、 ユー ザーの想像力を直接反映させるソフトウエアを可能にした。 グラフィカルなオブ ジェクト (ボタンやメニュー、アイコンと呼ばれる小さな画像など) がユーザー インターフェースの一部となった。 マウスは、ウィンドウを選択するためや、グ

第26章 オペレーティングシステム

ラフィカルなオブジェクトにプログラム機能を適用するきっかけを与えるために 使われた。

これは、単なるユーザーインターフェースを超えて、ユーザーとの親密さを創 出するソフトウエアであり、 コンピュータを単なる数値計算の域を超えた領域に 拡張することを促進するソフトウエアだった。 1963年にダグラス・エンゲル バートが書いた伝説的論文のタイトルを引用するなら、 「人間の知性を増強する ために」 作られたソフトウェアだったのだ。

Alto はグラフィカルユーザーインターフェース、 またはGUI (しばしばグー イと発音される) の始まりであり、 先駆的な概念的作業の多くはアラン・ケイ (1940年生まれ) に帰される。 しかし、 ゼロックスは Alto を販売せず(もし販 売していたら価格は3万ドル以上になっただろう)、 成功したコンシューマ製品 として Alto のアイデアが具現化されるまで10年以上を必要とした。

1979年、 スティーブ・ジョブズと Apple Computer [現 Apple] の一団が PARC を訪れ、そこで見たものに大きな感銘を受けた。 しかし、 彼らがグラフィ カルインターフェースを持つコンピュータを発表するのには3年以上かかった。 それが1983年1月に発売された失敗作、 Apple Lisa [リサ] だった。 しかし、1 年後、 Apple ははるかに成功する Macintosh [マッキントッシュ] を発売した。

オリジナルのMacintosh は、 Motorola 68000 マイクロプロセッサ、オペレー ティングシステムを含む64KB の ROM、 128 KBのRAM、3.5インチのディ スケットドライブ (ディスケットあたり400 KB の保存が可能)、 キーボード、 マウスを備え、 ビデオディスプレイは水平方向に512ピクセル、 垂直方向に 342 ピクセル表示 (サイズは対角で9インチ) で、 合計 175,104 ピクセルだっ た。 各ピクセルはメモリーの1ビットと関連づけられ、 黒または白のいずれか にできたので、ビデオディスプレイ RAMには約22KB が必要だった。

初代 Macintoshのハードウエアは、エレガントではあるものの、革命的とは 言い難かった。 1984年に発売された Mac がほかのコンピュータと大きく異な るのは、 当時は一般にシステムソフトウエアと呼ばれ、のちに Mac OS、 現在 は macOS と呼ばれるようになった Macintoshのオペレーティングシステムだ。

CP/M や MS-DOS、 Apple DOS のようなテキストベースのシングルユーザー 向けオペレーティングシステムはそれほど大きくはなく、 APIのほとんどをファ イルシステム関連の機能が占める。 しかし、 macOS のようなグラフィカルな

553

OS は、 もっと大規模で、 何百もの API関数を備える。 それぞれの関数が何を するのかを説明する名前で識別される。

MS-DOS のようなテキストベースのオペレーティングシステムでは、アプリ ケーションプログラムがテレタイプライターのように画面にテキストを表示する ための、簡単な API関数がいくつか用意されている。 macOS のようなグラフィ カルなオペレーティングシステムでは、プログラムが画面にグラフィックスを表 示する方法を提供しなければならない。 理論的には、 特定の水平/垂直座標上に あるピクセルの色をアプリケーションから設定できる API関数を1つ実装すれ ば、 実現可能だ。 しかし、 これはとても非効率的で、 とても遅いグラフィックス になることが判明した。

むしろオペレーティングシステムが完全なグラフィックスプログラミングシス テムを提供する方が理にかなっている。 つまり、オペレーティングシステムに、 テキストだけでなく、 線、 長方形、 曲線を描くためのAPI関数を含めるのだ。 直線は実線、 あるいは破線や点線で構成できる。 長方形と楕円は様々なパターン で塗りつぶすことができる。 テキストは、 太字や下線などの効果とともに、 様々 なフォントとサイズで表示できる。 グラフィックシステムは、これらのグラフィ カルオブジェクトをディスプレイ上の点の集合として、 どのようにレンダリング [表示] するかを決定する。

グラフィカルなオペレーティングシステムで動作するプログラムは、コン ピュータのビデオディスプレイとプリンターの両方で、 グラフィックスを描画す るために同じ API を使用する。 ワードプロセッシング [ワープロ] アプリケー ションは、プリンターで印刷される文書と同じように見えるように、 画面上に文 書を表示できる。 これは WYSIWYG (ウィジーウィグ[ウィジウィグ] と発音す る)として知られる特徴だ。 "What you see is what you get" [見たものが得られる もの] という意味で、 元々コメディアンのフリップ・ウィルソンがジェラルディ ン [フィリップ・ウィルソンが、 ジェラルディン・ジョーンズという南部出身のアフリカ系ア メリカ人女性に扮した] を演じて流行らせた言葉で、 結果的にコンピュータ用語に 貢献することになった頭字語だ。

グラフィカルユーザーインターフェースの魅力の1つは、異なるアプリケー ションが同じようなUI を持つことで、 ユーザーの経験を活かせることだ。 オペ レーティングシステムが、 ボタンやメニューなどのユーザーインターフェースの

554

第26章 オペレーティングシステム 555

様々なコンポーネント [部品] を実装するための API関数もサポートしなければ ならないことを意味する。 GUIは一般にユーザーにとって簡単な環境と見なさ れるが、同様にプログラマにとっても重要で、 よりよい環境である。 プログラマ は、車輪の再発明をせずに、 モダンなユーザーインターフェースを実装できる。

Macintosh が登場する以前から、 IBM PC や互換機用のグラフィカルなOS を作ろうという動きは数社で始まっていた。 ある意味、ハードウエアとソフトウ エアを一緒に設計していた Appleの開発者の仕事は楽だったかもしれない。 Macintosh のシステムソフトウエアは、1種類のディスケットドライブ、 1種類 のビデオディスプレイ、 2種類のプリンターしかサポートしていなかったのだ。 PC用のグラフィカルなオペレーティングシステムを実装するには、 多くの異な あるハードウエア部品をサポートする必要があった。

IBM PC はその数年前 (1981年) に導入されたばかりだったが、 多くの人々 はお気に入りのMS-DOS アプリケーションを使用することに慣れていて、それ らをあきらめる気になれなかった。 そのため、 PC用のグラフィカルなオペレー ティングシステムは、 新しいオペレーティングシステム用に明示的に設計された アプリケーションだけでなく、 MS-DOS アプリケーションも実行できることが 非常に重要とされた (Macintosh は、Apple II ソフトウエアを実行できなかっ た。これは主に異なるマイクロプロセッサを使用していたことが理由だ)。

1985年、 CP/M を開発した Digital Research が GEM (Graphical Environment Manager) を VisiCalc を販売する VisiCorp が VisiOn を、 そして Microsoft が Windows バージョン 1.0を発表したが、ほどなく Windows が 「ウィンドウ 「戦争」 の勝者となる可能性が高いとされた。 1990年5月に Windows 3.0 がリ リースされるまでは、 Windows は多くのユーザーを魅了できなかったが、 最終 的にはパソコンのオペレーティングシステムの主流となった。 Macintosh と Windows は、 表面的な外観は似ているものの、それらのAPIは全く異なるもの だ。

しかし、電話とタブレットはまた別の話だ。 スマートフォン、タブレット、 よ り大型のパーソナルコンピュータのグラフィカルインターフェースの間には、多 くの類似点があるものの、 APIは異なっている。 現在、スマートフォンとタブ レットの市場は、 Google と Apple によって生み出されたオペレーティングシス テム (Android と iOS) で支配されている。

コンピュータを使う多くのユーザーにはあまり見えていないが、 OS である UNIX [ユニックス] の遺産と影響力は依然として強力だ。 UNIX は、1970年代 前半にベル電話研究所で、 コンピュータ業界最高のヒゲを持つケントンプソン (1943年生まれ) とデニス リッチー (1941-2011) が中心となって開発された。 このオペレーティングシステムの不思議な名前は、 言葉遊びに由来する。 UNIX はもともと、 ベル研究所が MIT や GE と共同開発していた Multics (Multiplexed Information and Computing Services)というオペレーティングシステムの、 簡素化バージョンとして書かれたものだ。

UNIX は、ハードコアなコンピュータプログラマの間で最も愛されているオ ペレーティングシステムだ。 多くのオペレーティングシステムが特定のコン ピュータのために書かれているのに対し、 UNIX はポータブル [移植性] を重視 して設計されているため、 様々なコンピュータで動作するように適応させること が可能だ。

UNIX が開発された当時のベル研究所は、 American Telephone & Telegraph (AT&T)の子会社であったため、 電話業界における AT&T の独占的地位の抑制 を目的とした裁判所の判決を受けていた。 AT&Tは UNIX の販売を禁じられて おり、他社へのライセンス供与を義務づけられていた。 そのため、 1973年から UNIX は、大学や企業、政府などに広くライセンスされるようになった。 1983 年、 AT&Tはコンピュータ事業への復帰を許され、 独自バージョンの UNIX を 公開した。

結果として、 UNIX の単一のバージョンは存在しない。 代わりに、異なる名 前を持ち、 異なるベンダーによって販売され、 異なるコンピュータ上で実行され る様々なバージョンがある。 多くの人が UNIX に手を入れ、 その痕跡を残して いる。 しかし、それでも一般的な 「UNIX の哲学」 が、 人々が UNIX に部品を 追加する際の指針となっているようだ。 そうした哲学の1つが、 テキストファ イルを使用することである。 多くの小さなUNIXコマンドラインプログラム (ユーティリティと呼ばれる) はテキストファイルを読み、それらに何かを行い、 別のテキストファイルに書き込む。 UNIX のユーティリティは、これらのテキ ストファイルに対して異なるタイプの処理を行うチェーン [連鎖] として実現で きる。

近年、 UNIX にとって最も興味深い展開は、 リチャード・ストールマン (1953

556

第26章 オペレーティングシステム

年生まれ) が設立したフリーソフトウェア財団 (FSF) と GNU プロジェクト だ。 GNU (動物のヌーではなく、 Gを発音してグヌーと発音する) は “GNU's Not UNIX" [GNU は UNIX ではない] という意味で、もちろん GNU は UNIX で はない。代わりに、 GNU は UNIX と互換性を持たせ、ソフトウエアが独占さ れないように配布されることを意図している。 GNU プロジェクトは、 多くの UNIX 互換ユーティリティとツール、 および Linux [リナックス] の誕生に結びつ いている、 なお Linux は UNIX 互換のオペレーティングシステムのコア(また はカーネル) である。

フィンランドのプログラマ、 リーナス・トーバルズ (1969年生まれ) が中心 となって書いた Linux は、 近年とても人気がある。 Android は Linuxカーネル をベースにしているし、 大型スーパーコンピュータでは Linux が当然のように 使われている。またインターネットサーバーでも Linuxはかなり普及している。 なお、インターネットは本書の最終章のテーマだ。

4557



第27章 コーディング

すべてのコンピュータは機械コード (マシンコード) を実行するが、 機械コー ドでのプログラミングは爪楊枝で食事をするようなものだ。 一口が小さすぎる し、口に運ぶのも難儀なので、 食べ終えるまでに永遠とも思える時間が必要にな る。 また、 機械コードのバイトは、想像しうる最も小さくて単純な計算処理 (つ まり、 メモリーからプロセッサに数値をロードし、 別の数値に加え、その結果を メモリーに戻す) を実行するため、 それらが全体の処理にどう関係しているのか を想像するのが難しい。

少なくとも、 前章の冒頭で紹介した、 コントロールパネルのスイッチを使って バイナリーデータをメモリーに入力していた段階からは進歩した。 前章では、 キーボードとビデオディスプレイで機械コードの16進バイトを入力して確認で きる、単純なプログラムを記述した。 スイッチを使うよりは進歩したが、改善の 最終地点ではない。

もう知っているように、 機械コードのバイトには、 MOV ADD JMP、 HLTなどの短いニーモニックがつけられている。 そのため、 機械コードを何と なく英語に近い形で参照できる。 これらのニーモニックは、 しばしば、 機械コー ド命令が何をするのかをさらに示すオペランド [被演算子] とともに書かれる。 たとえば、 インテル 8080の機械コードのバイト 46h は、 マイクロプロセッサ に対して 「レジスターペア HLにある16ビット値で参照されるメモリーアドレ スに格納されたバイトを、 レジスターBに移動させる」ように指示する。 これ は、次ページに示すように簡潔に書ける。

MOV B,M

ここで、Mは「memory [メモリー]」 の略である。 こうしたニーモニック (と付 加機能)を集めたものが、 アセンブリ言語と呼ばれるプログラミング言語だ。 ア センブリ言語でプログラムを書くのは、 機械コードで書くよりもずっと簡単であ る。 しかし、 CPUはアセンブリ言語を直接は理解できない。

原始的なコンピュータを扱っていた黎明期には、アセンブリ言語のプログラム を紙で書くために、 多くの時間を費やしたことだろう。 「うまく動くかもしれな いプログラムができた」 と満足したときにだけ、 それをハンドアセンブルする [手動で組み立てる] ことになる。 これは、 アセンブリ言語のステートメント [命令 文] を、 図表やほかの参考資料を使いつつ、 機械コードのバイトに手作業で変換 し、 メモリーに入力することを意味する。

ハンドアセンブルがとても困難なのは、 ジャンプとコールに起因する。 JMP 命令または CALL 命令を手動で組み立てるには、 その目的地の正確な2進アド レスを知る必要があり、 それはほかのすべての機械コード命令が正しく配置され ていることが前提となる。 この変換はコンピュータに任せる方がずっとよい。 し かし、どうしたらそれをできるのだろう?

最初にテキストエディターを書くといいかもしれない。 テキストエディター は、行単位で入力したテキストをファイルとして保存できるプログラムだ (残念 ながら、このプログラムはハンドアセンブルしなければならない)。 そうすれば、 アセンブリ言語命令を書き込んだテキストファイルを作成できる。 また、アセン ブラと呼ばれる別のプログラムも、 ハンドアセンブルする必要がある。 このプロ グラムはアセンブリ言語の命令を含むテキストファイルを読み取り、 それらの命 令を機械コードに変換し、 別ファイルとして保存する。 生成されたファイルは実 行時にメモリーにロードできる。

もし8080 を搭載したコンピュータ上で CP/M オペレーティングシステムを 実行していたなら、この作業に必要なツールは、すべて揃っているはずだ。 テキ ストエディターは ED.COM という名前で、テキストファイルの作成と変更がで きる (現代の単純なテキストエディターには、Windows の 「メモ帳」 や、 AppleのmacOSの「テキストエディット」などがある)。作成するテキスト ファイルには PROGRAM1.ASM という名前をつけるとしよう。 ASM という

560

27 コーディング

ファイルタイプは、 このファイルがアセンブリ言語プログラムであることを示 す。 その内容は次のようになる。

ORG 0100h LXI DE, Text MVI C, 9 CALL 5 RET Text : DB 'Hello!$' END

このファイルには、 今まで見たことのないステートメントがいくつか含まれて いる。 1つ目は、 ORG (Origin という意味) だ。 実はこのステートメントは 8080 の命令には対応していない。 その代わり、次のステートメントのアドレス 0100h から始めることを示している。 この0100h は、 CP/M がプログラムを メモリーにロードするためのアドレスだ。

次は LXI (Load Extended Immediate) で、 16ビット値をレジスターペア DE にロードする。 これは、本書の CPU が実装していない、いくつかの8080 命令の1つだ。この例では、 16ビット値はラベル Text として与えられている。 ラベル Text は、 プログラムの最下部付近に、 DB (Data Byte) ステートメント の前にある。 DB ステートメントもこれまで見たことのないものだ。 DB ステー トメントのあとには、カンマで区切られた複数のバイト、または(ここでそうし ているように) シングルクォーテーション () で囲まれた文字列を続けること ができる。

MVI (Move Immediate [即値転送]) は、 値9をレジスターCに転送する。 続 < CALL5は、 CP/M オペレーティングシステムの呼び出しを行い、レジスター Cの値を見て、 適切な関数にジャンプする。 この関数は、レジスターペア DE で与えられるアドレスから始まり、ドル記号 ($) までの文字列を表示する(こ の Text: の行のテキスト部分が、 ドル記号 ($) で終わっていることに気がついて いるだろう。 文字列の終わりを意味するのにドル記号を使うのは非常に奇妙だ が、CP/M ではたまたまそうなっている)。 最後のRET はプログラムを終了し、 制御を CP/M に戻す。 END は、 アセンブリ言語ファイルの終わりを示す。

561

これで、 7行のテキストからなるテキストファイルができた。 次は、 組み立て (アセンブル) だ。 CP/M には ASM.COM というプログラムがあり、これがア センブラである。 ASM.COM は CP/M のコマンドラインから次のように実行す る。

ASM PROGRAM1.ASM

ASM プログラムは、 ファイル PROGRAM1. ASM の内容を調べ、 私たちが 書いたアセンブリ言語のステートメントに対応する機械コードを含んだ新しい ファイル、 PROGRAM1.COM を作成する。

PROGRAM1.COM ファイルには、 次の16バイトが含まれる。

110901 0E 09 CD 0500 C948656C6C 6F 21 24

最初の3バイトがLXI命令、 次の2バイトがMVI 命令、 その次の3バイト が CALL 命令、 さらにその次がRET 命令だ。 最後の7バイトは、 "Hello" の 5 文字、 感嘆符(!)、 そして、 ドル記号 ($) を表す ASCII 文字である。 CP/M の コマンドラインから PROGRAM1 プログラムを実行できる。

PROGRAM1

オペレーティングシステムはプログラムをメモリーにロードして実行する。 画 面に表示されるのは、次のような挨拶文だ。

Hello!

ASM.COM のようなアセンブラがやっているのは、アセンブリ言語のプログ ラム(ソースコードファイルとよく呼ばれる) を読み込んで、 機械コードの入っ たファイル (実行可能ファイル) を書き出すことだ。 アセンブリ言語のニーモ ニックと機械コードは1対1で対応しているので、アセンブラは比較的単純な プログラムである。 アセンブラは、テキストの各行をニーモニックと引数に分解 し、これらの小さな単語や文字を、 アセンブラが保持するすべての既知のニーモ ニックや引数のリストと比較することで動作する。 これはパース [構文解析] と 呼ばれる処理で、条件ジャンプを伴う CMP命令を多用する。 この比較によっ て、それぞれのステートメントがどの機械コード命令に対応するかが明らかにな

562

第27章 コーディング

る。

PROGRAMI.COM ファイルに含まれるバイト列は、 LXI命令である 11hで 始まる。 このあと、 09hと01hが続き、 16ビットアドレスの 0109h を構成す る。このアドレスを割り出してくれたのはアセンブラだ。 LXI命令が 0100hに ある場合 (CP/M がプログラムをメモリーにロードして実行するときと同じ)に は、テキスト文字列 (Hello!) の開始位置はアドレス 0109h となる。 一般に、 アセンブラを使用するプログラマは、プログラムの様々な部分に関連する特定の アドレスを気にする必要はない。

もちろん、最初にアセンブラを書いた人は、 プログラムを手動でアセンブルす る必要があった。 同じコンピュータのために新しい (おそらく改良された) アセ ンブラを書く人は、 それをアセンブリ言語で書き、 最初のアセンブラを使ってア センブルできる。 新しいアセンブラは一度組み上がると、 それ自体をアセンブル できるわけだ。

新しいマイクロプロセッサが開発されるたびに、 新しいアセンブラが必要にな る。 しかし、この新しいアセンブラは、既存のコンピュータ上でそのコンピュー タのアセンブラを使って書ける。 これをクロスアセンブラと呼ぶ。 コンピュータ A で動作するアセンブラが、 コンピュータBで動作するコードを生成するのだ。

アセンブラは、アセンブリ言語プログラミングの創造性の低い部分 (手作業と なるハンドアセンブル部分)を肩代わりしてくれる。 しかしながら、 アセンブリ 言語にはまだ2つ、大きな問題が残っている。 もうお気づきのように、第1の 問題は、 アセンブリ言語によるプログラミングが非常に面倒なことだ。 CPUレ ベルまで降りて処理しているので、徹底的に細かいところまで気にしなければな らない。

2つ目の問題は、アセンブリ言語がポータブル [移植性がある] ではないことだ。 8080のアセンブリ言語プログラムを書いたとしたら、それはモトローラ 6800 では動作しない。 6800のアセンブリ言語でプログラムを書き直す必要がある。 大まかな構造やアルゴリズム面での課題はすでに解決しているので、おそらくオ リジナルのプログラムを書くほどは難しくないだろう。 それでも大変な作業であ ることに変わりはない。

コンピュータが処理することの多くは数学的な計算だが、 それをアセンブリ言 語で行うのは厄介だ。 それよりも計算を、たとえば次のように、おなじみの代数

563

表記法を使用して表現できる方がはるかに好ましい。

Angle = 27.5 [角度=27.5]

Hypotenuse=125.2 [斜辺 = 125.2]

Height = Hypotenuse × Sine (Angle) [高さ=斜辺×サイン (角度)]

これらのテキストがコンピュータプログラムの一部なら、3つの行はそれぞれス テートメントと呼ばれるものになる。 プログラミングでは、 代数学と同様、 Angle、Hypotenuse、Height にそれぞれ異なる値を設定できることから、これ らは変数と呼ばれる。 等号は代入を表す。 これにより、変数 Angle には値 27.5 が、Hypotenuse には 125.2 が設定される。 また、 Sine は関数だ。 コードのど こかに、指定された角度に対する三角関数の sine [サイン値、 正弦値] を計算して その値を返す部分があるはずだ。

また、これらの数値はアセンブリ言語で一般に見られる整数ではなく、 小数点 や小数部を含む数値であることに注意しよう。 コンピュータ用語では、浮動小数 点数と呼ばれるものだ。

このようなステートメントがテキストファイルにあるなら、 そのテキストファ イルを読み込んで、 代数式を機械コードに変換して計算を行うアセンブリ言語プ ログラムを書けるはずだ。 もちろん、 そのようになっている。

ここで必要なのは、高水準言語と呼ばれるものだ。 アセンブリ言語は、 コン ピュータのハードウエアに非常に近いため、低水準言語と呼ばれる。 アセンブリ 言語以外のプログラミング言語は高水準と呼ばれるが、 ある言語がほかの言語よ りも高水準と見なされることもある。 会社の社長が、 コンピュータに向かって 「今年のすべての利益と損失を計算し、 年次報告書を作成し、 数千部印刷して、 全株主に送れ」 と入力して (それどころか、 足を机に載せながら指示するだけ で)、実行されるなら、 非常に高水準な言語で作業しているといえるだろう! 現 実世界では、 プログラミング言語はその理想にはほど遠い [本書が書かれたのは生 成AIがブームになる約1年前の2021 年末頃である]。

人間の言語は、何千年にもわたる複雑な影響、 ランダムな変化、 適応の産物 だ。 エスペラントのような人工言語さえ、現実の世界ではその起源からの差異が 生じている。 しかし、 高水準言語は、 もっと意図的かつ計画的な産物だ。 プログ ラミング言語の発明は、 人がコンピュータに指示を伝える方法を定義するもので

564

第27章 コーディング

あり、一部の人々にとって非常に魅力的な仕事となる。 本書の初版を執筆した 1993年当時の推定では、1950年代初頭から1000以上の高水準言語が発明され、 実装されたという。 2021 年末時点には「オンライン歴史的プログラミング言語 百科事典 (hopl.info)」 によると、合計で8.945 となっている [2024年1月時点で も同じ。

もちろん、やりたいことすべてを表現できるシンタックス [構文] を開発して 高水準言語を定義するだけでは不十分だ。 加えて、コンパイラ (高水準言語のス テートメントを機械コードに変換するプログラム) も書く必要がある。 アセンブ ラのように、コンパイラはソースコードファイルを1文字ずつ読み、 短い単語 や記号、 数字に分解しなければならない。 しかし、 コンパイラはアセンブラより もはるかに複雑だ。 アセンブラは、アセンブリ言語のステートメントと機械コー ドが1対1対応するため、比較的簡単といえる。 一方のコンパイラは通常、高 水準言語の1つのステートメントを多くの機械コード命令に翻訳しなければな らない。 コンパイラは簡単には書けない。 コンパイラの設計や構造を知るには、 丸々1冊の本が必要だ。

高水準言語には、 利点と欠点がある。 主な利点は、アセンブリ言語よりも学習 とプログラミングが容易なことだ。 高水準言語で書かれたプログラムは、明確か つ簡潔であることが多い。 高水準言語はポータブルであることが多く、 アセンブ リ言語とは違って特定のプロセッサに依存しない。 プログラマは高水準言語を使 うことで、プログラムが動作するマシンの基本構造を知らなくても、 プログラミ ングができる。 もちろん、異なる種類のプロセッサで同じプログラムを実行する 場合は、各プロセッサ用の機械コードを生成するコンパイラが必要だ。 その場 合、実行ファイルも個別のプロセッサに特化したものとなる。

一方、優れたプログラマがアセンブリ言語を使うことで、 コンパイラよりも高 速かつ効率的なコードを書ける場合も多い。 これは、高水準言語で書かれたプロ グラムから生成された実行可能ファイルが、 アセンブリ言語で書かれた同じ機能 のプログラムよりも大きく、遅くなりうることを意味する (ただし、近年マイク ロプロセッサが複雑になり、 コンパイラもコードの最適化で洗練されてきたた め、この欠点は目立たなくなってきた。

高水準言語は通常、 プロセッサの使い勝手を格段に向上させるが、より高性能 にしてくれるわけではない。 高水準言語の中には、ビットシフトやビットテスト

565

といった、CPUでは一般的な演算をサポートしていないものがある。 こうした 処理は、 高水準言語ではより難しくなりうる。

家庭用コンピュータの黎明期には、ほとんどのアプリケーションプログラムが アセンブリ言語で書かれていた。 しかし最近では、アセンブリ言語は特殊な用途 を除いてほとんど使われなくなっている。 プロセッサにパイプライン (複数の命 令を同時に実行すること) を実現するハードウエアが追加されるようになって、 アセンブリ言語はますます複雑で難しくなった。 同時に、コンパイラもより高度 になってきた。 現代のコンピュータが備える大容量のストレージとメモリーも、 この傾向に一役買っている。 プログラマはもはや、少量のメモリーで動作し、 小 さなディスケットに収まるコードを作成する必要性を感じなくなったのだ。

初期のコンピュータ設計者は、問題を代数的表記で定式化しようと試みた。 そ のように動作する最初のコンパイラは、 1952年に Remington Rand [レミントン ランド] でグレース・マレー・ホッパー (1906-1992) によって UNIVAC向けに 作成された Arithmetic Language [算術言語] バージョン 0 (または A-0 system) とされる。 ホッパー博士は「コンパイラ」 という用語も生み出した。彼女は 1944年にハワード・エイケンの Mark I [マークⅠ] のために働いており、 コン ピュータにいち早く取り組んでいた。 80歳を超えてなお、 彼女は Digital Equipment Corporation [ディジタル・イクイップメント・コーポレーション] (DEC) の広報として、コンピュータ業界で働いた。

現在も使われている最も古い高水準言語 (ただし長年にわたって大幅に改訂さ れている) は FORTRAN [フォートラン] だ。 初期のコンピュータ言語には、頭 文字をとって大文字で書かれた造語が多い。 FORTRAN は、 FORmula [数式] の最初の3文 字と TRANslation [翻訳] の最初の4文字を組み 合わせたものだ。 最初のFORTRAN は、 1950 年代半ばにIBM704 用に開発された。 この FORTRAN は長年、 科学者や技術者向けの言語 と考えられていた。 浮動小数点のサポートが極め て充実しており、 実数と虚数の組み合わせである 複素数もサポートするからだ。

COBOL (COmmon Business Oriented

Interim Archives/Getty Images

566

第27章 コーディング 567

Language [コボル、 共通事務処理用言語]) も古いプログラミング言語で、 金融機関 を中心に現在も使われている。 COBOL は、 1959年に創設された米国の産業界 や国防総省の代表者からなる委員会により策定されたが、グレース・ホッパーの 初期のコンパイラに影響を受けている。 COBOL は、 組織の管理職が実際にコー ディングはしないまでも、少なくともプログラムコードを読んで、それがやるべ きことをしているかどうかを確認できるように設計された (しかし現実にはほと んど行われていない)。

現在では (おそらく趣味で使っている人を除いて) 使われていないものの、 非 常に影響力のあるプログラミング言語が ALGOL [アルゴル] だ。 ALGOLは ALGOrithmic Language [アルゴリズム言語] の略だが、ペルセウス座で2番目に 明るい星も ALGOL という名前である。 1957年と1958年に国際委員会によっ て初めて設計された ALGOL は、 過去半世紀における多数の有名な汎用言語の 直接の先祖である。 最終的に構造化プログラミングとして知られるようになった 概念の先駆けでもあった。 現在も、 「ALGOL風」 のプログラミング言語という 表現をする人がいる。

ALGOL は、 現在のほぼすべてのプログラミング言語に共通して見られるプ ログラミング構造を確立した。 これらの構造は、 特定のキーワード [後述する や for など] と関連づけられた特有の操作を示す。 複数の文はブロックとして組み 合わされ、 特定の条件下または特定の反復回数で実行される。

if ステートメントは、論理的な条件 (たとえば、 変数 height が55より小さい 場合など) に基づいて、 ステートメントやステートメントのブロックを実行す る。 for ステートメントは通常、 インクリメントされる変数に従って、 ステート メントまたはステートメントのブロックを複数回実行する。 配列は、同じ型を持 つ値の集合で、たとえば都市の名前の集まりなどだ。 ALGOLのプログラムは、 ブロックと関数で構成される。

家庭用コンピュータで利用できる FORTRAN や COBOL、 ALGOL も存在 したが、いずれも BASIC のようにはインパクトを与えることはできなかった。

BASIC (Beginner's All-purpose Symbolic Instruction Code [ベーシック、初心

者向け汎用記号式命令コード]) は、1964年にダートマス数学科のジョン・ケメニー とトーマスカッツが、 タイムシェアリングシステム上で開発した。 ダートマス の学生の多くは数学や工学を専攻していなかったので、コンピュータの複雑さや

568

難しい構文に手を出すことは期待できなかった。 端末の前に座っているダートマ ス大学の学生は、 数字に続けてBASIC のステートメントを入力するだけで、 BASIC プログラムを作成できた。 プログラムにある、 各行の先頭の数字は、プ ログラム中のステートメントの順番を示す。 最初に出版された BASIC の教本に 載っていた BASIC プログラムを以下に示す。

10 LET X = (7+8)/3 20 PRINT X 30 END

BASIC の多くの実装は、コンパイラではなくインタープリタの形態だった。 コンパイラがソースコードファイルを読んでから機械コードの実行ファイルを作 成するのに対し、 インタープリタはソースコードを読みつつ、 実行ファイルを作 成せずに、 直接実行する。 インタープリタでは、コンパイラよりもプログラムを 書きやすいが、逐次解釈 [インタープリト] されるプログラムの実行時間は、 コン パイルされたものよりも遅いことが多い。 家庭用コンピュータ用の BASIC は、 ビル・ゲイツ (1955年生まれ)とポール・アレン (1953-2018) が1975年に Altair8800 用に BASIC インタープリタを書いたときに始まった。 それは、 彼 らの会社である Microsoft を急成長させた。

プログラミング言語 Pascal [パスカル] は、 その構造の多くを ALGOL から受 け継いだが、 COBOL からの機能も含まれていた。 Pascal は、 1960年代後半に スイスのコンピュータ科学者ニクラウス・ヴィルト (1934-2024) によって設計 された言語だ。 Pascal は初期の IBM PC プログラマにとても人気があったが、 それは特定の製品のおかげだった。 1983年に Borland International [ボーランド・ インターナショナル] によって 49.95 ドルというお買い得価格で発売された Turbo Pascal [ターボ・パスカル] がそれだ。 Turbo Pascal はデンマーク人学生アンダー ス・ヘルスバーグ (1960年生まれ) によって書かれ、 統合開発環境付きで提供 された。 テキストエディターとコンパイラが1つのプログラムに組み合わされ、 非常に高速なプログラミングを実現した。 統合開発環境は大型のメインフレーム コンピュータで人気があったが、 Turbo Pascal はそれを小型マシンへと持ち込 んだ。

Pascal はまた、 米国防総省が開発した言語 Ada [エイダ] にも大きな影響を与

*27*3-5475

えた。 この言語名は、チャールズ・バベッジの解析機関の翻訳および解説者とし 第15章で登場したオーガスタ・エイダ・バイロンに由来する。

1969年から1973年にかけて、 ベル電話研究所のデニス M リッチーが中 心となって作り上げ、 多くの人に愛されるプログラミング言語Cが登場した。 なぜCと呼ばれるのかという質問がしばしば出るが、シンプルな答えは、 先行 した言語 B の派生だからだ。 なおB は BCPL (Basic CPL) の簡略化版であり、 そのBCPL は CPL (Combined Programming Language) から派生したものだ。

ほとんどのプログラミング言語は、 メモリーアドレスなどのアセンブリ言語の 名残りを排除しようとする。 しかし、Cは違う。 Cにはポインターと呼ばれる 機能があり、 それは基本的にメモリーアドレスだ。 ポインターは、その使い方を 知っているプログラマにはとても便利だったが、それ以外のほぼすべての人に とっては危険だった。 ポインターは、重要なメモリー領域を上書きできる機能に より、バグの一般的な原因となった。 プログラマのアレン・ホルブが、Cについ て 『Enough Rope to Shoot Yourself in the Foot [自分の足を撃ち抜くのに十分な道具]』と いう本を書いたほどだ。

Cは、 Cよりも安全な一連の言語の祖父母となり、 オブジェクト (コードと データを高度に構造的に組み合わせたプログラミング要素) を扱う機能を追加し た。 そうした言語で最も有名なのは、1985年にデンマークのコンピュータ科学 者ビャーネストロヴストルップ (1950年生まれ) によって作成された C++、 1995年に Oracle [オラクル] のジェームズ・ゴスリング (1955年生まれ)によっ て設計された Java [ジャパ]、 および Microsoft のアンダース・ヘルスバーグに よって2000年に設計された C# [シーシャープ] だ。 この文章が書いている時点 で、最も使われているプログラミング言語の1つは、オランダのプログラマ、 グイド・ヴァン・ロッサム (1956年生まれ) によって1991年に最初に設計さ れた Python [パイソン] である (Cに影響を受けた言語だ)。 しかし、2030年代 や2040年代に本書を読んでいるなら、 書籍執筆時にはまだ発明されていない言 語に親しんでいるかもしれない!

異なる高水準プログラミング言語は、プログラマに異なる考え方を迫る。 たと えば、 新しいプログラミング言語の中には、 変数よりも関数を操作することに焦 点を当てているものがある。 それらは関数型言語と呼ばれ、 従来の手続き型言語 に慣れたプログラマは、最初は違和感を覚えるかもしれない。 しかし、関数型言

569

570 |

語はプログラマによる問題への取り組み方を新しい方向へと変える、 代替的な解 決策を提供する。 しかし、 どの言語を使うかにかかわらず、 CPU は相変わらず、 毎度おなじみの機械コードを実行するだけである。

しかし、ソフトウエアが様々な CPU とそのネイティブな [本来の] 機械コード の違いを埋め合わせてくれる方法がある。 ソフトウエアは様々な CPU をエミュ レート [模倣]でき、 古いソフトウエアや大昔のコンピュータゲームを現代のコ ンピュータで実行できるようにする (これは何も新しいやり方ではない。ビル・ ゲイツとポール・アレンが Altair8800 用の BASIC インタープリタを書くこと を決めたとき、彼らはまずハーバード大学の DEC PDP-10 メインフレームコン ピュータ上で動くインテル 8080エミュレータプログラムを書き、その上で BASIC インタープリタをテストした)。 Java と C#のプログラムは、まず機械 コードに似た中間コードにコンパイルされ、 実行時に機械コードに変換される。 LLVM という名のプロジェクトは、 任意の高級プログラミング言語と、 CPU に よって実装された任意の命令セットとの間に、実質的な変換機能を提供すること を目的としている。

これがソフトウエアの魔法だ。 十分なメモリーと速度があれば、 どんなデジタ ルコンピュータでも、ほかのデジタルコンピュータができることなら何でもでき る。これが、1930年代にアラン・チューリングが行った計算可能性の研究が意 味することなのだ。

しかし、アラン・チューリングは同時に、 デジタルコンピュータには永遠に手 が届かない アルゴリズムの問題があることも示した。 その問題の1つは驚く べき意味を持つ。 別のコンピュータプログラムが正しく動作しているか否かを判 断するコンピュータプログラムを書くことはできないのだ! [正確には「あるプロ グラムが有限時間で停止できるか否かを判定できるアルゴリズムは存在しない」 というもので、 別名「停止性問題」と呼ばれる] つまり、 プログラムが本来の機能を発揮しているか どうかは、 決して保証できないということだ。

これは厳しい制約だ。 ソフトウエアを開発するプロセスの中で、 徹底的なテス トとデバッグが非常に重要な部分を占める理由である。

Cの影響を受けた言語の中で最も成功しているのがJavaScript [ジャバスクリプ ト] だ。 元々はNetscape [ネットスケープ] のブレンダン・アイク (1961年生ま れ)が設計し、1995年に登場した。 JavaScript は、 HTML (Hypertext Markup

27章 コーディング イング 571

Language) が提供するテキストとビットマップによる単純な表現を超えて、イ ンタラクティブな機能をウェブページに提供するために使われる。 本書を書いて いる時点では、 上位 1,000万サイトのほぼ98%が、 少なくとも何らかの形で JavaScriptを使用している。

現在一般的に使用されているすべてのウェブブラウザが JavaScript を解釈で きる。 つまり、デスクトップコンピュータやラップトップコンピュータに追加の プログラミングツールをダウンロードしてインストールすることなく、 JavaScriptによるプログラムを作成できる。

ということで･･････ JavaScript をいくつか試してみよう。

やることは、Windows のメモ帳や macOS のテキストエディットを使って、 JavaScript を含む HTML ファイルを作成するだけ。 テキストをファイルに保存 して、 Edge や Chrome, Safari などのお気に入りのウェブブラウザに読み込ま せよう。

Windows の場合は、 メモ帳を起動しよう (スタートメニューの検索機能で探 す必要があるかもしれない)、 そうすればテキストを入力する準備が整う。

macOS の場合は、テキストエディットを実行しよう (Spotlight検索で探す 必要があるかもしれない)。 最初に表示される画面で、 「新規書類」 ボタンをク リックしよう。 テキストエディットは、テキストの書式情報を含むリッチテキス トファイルを作成するためのものだ。 ここではリッチテキストは不要だ。 プレー ンテキストのファイルがほしいので、「フォーマット」メニューの「標準テキス トにする」を選択しよう (macOSのバージョンによっては最初から標準テキス トモードになっていることがある、その場合は 「フォーマット」 メニューの中に 「リッチテキストにする」 というメニュー項目が表示される)。 また、 「編集」 メ ニューの「スペルと文法」 セクションで、「入力中にスペルチェック」や「スペ ルを自動的に修正」 の選択を解除する。

それでは、次ページに示すように入力しよう。

<html>

<head> <title>My JavaScript</title> </head> <body> <p id="result">Program results go here!</p> <script> // JavaScript programs go here </script> </body>

</html>

これはHTML で、 ファイルの様々な部分をタグで囲んだものだ。 ファイル全 体は<html> タグで始まり、 最後に </html>タグで終わる。 その中で、 <head> [ヘッド] セクションは、ウェブページのトップに表示される <title> [タイトル] を 囲んでいる。 <body> [ボディ] セクションは、 "Program results go here!" [プロ グラムの結果がここに入る!] というテキストを含む <p> [パラグラフ、 段落] を囲ん でいる。

また、 <body> セクションは<script> [スクリプト] セクションも囲んでいる。 ここに、JavaScript プログラムが置かれる。 そこにはすでに、2つのスラッシュ (//) で始まる1行だけで構成された小さなプログラムが書かれている。この2 つのスラッシュは、 この行がコメントであることを示している。 2つのスラッ シュから行末まではすべて、 プログラムを読む人間のために書かれていて、 JavaScript の実行時には無視される。

これらの行をメモ帳やテキストエディットに入力する際は、上で示したように すべてをインデントする必要はない。 同じ行に多くの内容を書くこともできる。 しかし、わかりやすさのために、 <script>と</script> タグは独立した行にして おこう。

次に、そのファイルをどこかに保存しよう。 メモ帳もしくはテキストエディッ トで、 「ファイル」メニューから 「保存」を選んで、 保存場所を指定する。 とり あえずパソコンのデスクトップが便利だ。 MyJavaScriptExperiments.html など

572

第27章 コーディング 573

のファイル名をつけよう。 ピリオド (.)に続くファイル名の拡張子 (.html) は 非常に重要だ。 きちんと html になるようにしよう。 テキストエディットは、 拡 張子を本当に.html にしたいかを確認してくる。 もちろんOKだ!

ファイルを保存しても、 まだメモ帳やテキストエディットを閉じないでほし い。 内容を変更できるよう開いたままにしておこう。

ここで、 先ほど保存したファイルを探して、 ダブルクリックしてみよう。 Windows あるいは macOS では、そのファイルがデフォルト [標準設定] のウェ ブブラウザに読み込まれるはずだ。 ウェブページのタイトルは "My JavaScript"、 ウェブページの左上には "Program results go here!" と書かれて いるだろう。そうでない場合は、すべてが間違いなくファイルに入力されている かを再確認しよう。

JavaScript を使った実験の流れを紹介しよう。 メモ帳やテキストエディット で、 <script>タグと</script> タグの間に JavaScript を入力し、 再びファイルを 保存する。 保存したら、ウェブブラウザで、 おそらく円形の矢印アイコンをク リックして、ページを更新しよう。 次のように、 2つのステップで、別の JavaScript プログラムを実行できる。 (1) 新しいバージョンのファイルを保存 する、(2) ウェブブラウザのページを更新する、 である。

ではここで、 <script>タグと</scripタグの間の領域に入力する、 最初のプ ログラムを紹介しよう。

let message = "Hello from my JavaScript program!"; document.getElementById("result").innerHTML = message;

このプログラムには2つのステートメントがあり、それぞれ別の行に書かれて いて、セミコロンで終わっている。

最初のステートメントのletという単語はJavaScript のキーワード(JavaScript 内で意味を持つ特別な言葉という意味) 、 message は変数だ。 let キーワード を使えば、変数に値を設定し、 あとで別の値に設定することができる。 別に message という単語を使わなければならないわけではない。 たとえばmsg など、 普通の文字で始まり、スペースや区切り文字を含まないものであれば何でも使え る。このプログラムでは、 変数 message に、 引用符 () で始まり引用符で終わ る文字列が設定されている。 2つの引用符の間には、 好きなメッセージを入れる

ことができる。

2番目のステートメントは、間違いなくよりわかりにくく複雑だが、 JavaScript が HTML と対話できるようにするために必要なものだ。キーワード document は、表示されているウェブページを指している。 getElementById は、 このウェブページの中で、 "result" という名前の HTML 要素を検索する。 見つ かるのは <p>タグで、 innerHTMLに代入することで、 <p> タグと</p> タグ の間に、あたかも元々そこに入力されたかのように message 変数の値を設定で きる。

この2番目のステートメントは長くて面倒だ。 しかし JavaScript は、 ウェブ ページ上のあらゆるものにアクセスしたり変更したりできなければならず、 十分 な柔軟性が求められる。 そのために必要なのだ。

コンパイラやインタープリタは、昔ながらの英語の先生よりもスペルにうるさ いので、2番目の文は必ず上記のように入力してほしい! JavaScript は、 大文 字と小文字を区別するケースセンシティブ言語だ。 InnerHTML や innerHtml では動作しないので、 innerHTMLと正しく入力するようにしよう! それが、 macOS のテキストエディットではスペルチェックをオフにしておきたい理由 だ。 そうしておかないと、 テキストエディットはlet を Let に変えてしまい、う まくいかない。

この新しいバージョンのファイルを上書き保存して、ウェブブラウザのページ を更新すると、左上に入力したメッセージが表示される。 もしそうでない場合 は、 作業内容を確認してみよう!

では、同じファイルを使って、 別の簡単なプログラムを試してみよう。 すでに 書いたプログラムを消したくない場合は、この2つの特殊な記号の並びの間に 挟んでおこう。

1*

let message = "Hello from my JavaScript program!";

document.getElementById("result").innerHTML = message: *1

JavaScript では、 /* と */ の間はコメントとして扱われ、 無視される。 Cの影 響を受けた多くの言語と同様、 JavaScript には、 /* */ を使った複数行コメン

574

27 コーディング 575

と、 // を使った1行コメントという、2種類のコメントがある。 次のプログラムでは、少し計算してみよう。

let a = 535.43; let b = 289.771; let c = a * b; document.getElementById("result").innerHTML = c;

多くのプログラミング言語と同様に、掛け算は乗算記号ではなくアスタリスク (*)で指定する。 これは、標準的な乗算記号が ASCII 文字セットに含まれてい ないためだ。

最後の文は、 <p>タグの間の innerHTMLに、2つの数値の積である変数c の値が設定されていることを除けば、前のプログラムと同じであることに注意し てほしい。 JavaScript では、 innerHTMLに文字列や数値を設定できる。

高水準言語における最も重要な機能の1つにループがある。 アセンブリ言語 では、JMP命令や条件付きジャンプを使って、 ループがどのように行われるか を見てきた。 高水準言語の中には、 ジャンプによく似た goto というステートメ ントを持つものがある。 しかし、 goto ステートメントの使用は、 特別な目的以 外では推奨されない。 多くのジャンプが含まれたプログラムは、すぐに管理がと ても難しくなる。 専門用語ではスパゲッティコードというように、ジャンプがス パゲッティの麺のように互いに絡み合って見えるからだ。 このため、JavaScript では goto は実装すらされていない。

現代の高水準プログラミング言語は、あちこちにジャンプすることなくループ を管理している。 たとえば、1から10までの数字をすべて足したいとしよう。 以下は、そのプログラムをJavaScript のループで書く方法の1つだ。

let total = 0; let number = 1;

while (number <= 100) { } total = total + number; number = number + 1;

document.getElementById("result").innerHTML = total;

空行は気にしなくていい。 私が空行を入れているのは、プログラムをわかりや すく区切っているだけだ。 まず、 初期化セクションで、 2つの変数 (total と number) に初期値を設定している。 ループは、 while ステートメントと中括弧 ({}) 間のコードブロックから構成されている。 number 変数の値が100以下 の間、コードのブロックが実行される。 1回実行されるたびに、 total に number の値を加え、 number の値を1つ増やす。 number の値が 100より大きくなると、 プログラムは右中括弧 (}) に続くステートメントへと実行を続ける。 そのス テートメントが、 結果 (total の値) を表示する。

以下の2つのステートメントに出会ったときには、 代数問題に遭遇して迷っ たかもしれない。

total = total + number;

number = number + 1;

total が total + number に等しい (=) のはどうして? それって number がゼロ ということ?それにも増して、 どうして number が number + 1 と等しくなる の?

実は JavaScript では、 等号 (=)は「値が等しい」 という意味ではない。これ は代入演算子なのだ。 等号の左側にある変数に、 等号の右側で計算された値が設 定される。 つまり、 等号の右側の値が、 左側の変数に「入る」 のだ。 JavaScript では (C言語と同様に)、 2つの変数が等しいかどうかを調べるには、 2つの等

576

第27章 コーディング T

号 (==) が必要だ。

これら2つのステートメントには、 JavaScript がCから借用したいくつかの ショートカットを適用できる。 次のように省略することが可能だ。

total += number; number += 1;

プラス記号とイコール記号の組み合わせ (+=) は、 左の変数に右のものを足すこ とを意味する。

またここで示されている number のように、 変数が1つインクリメントされ ることはよくあることなので、 number をインクリメントする文は次のように省 略できる。

number++;

さらに、2つの文は1つにまとめられる。

total += number++;

この式は、 number の値を total に加え、 そのあとで numberの値を1つ増やす のだ! しかし、この書き方は、プログラミングに熟練していない人にとっては、 少し不明瞭でわかりにくいかもしれないので、一般には避けた方がいいかもしれ ない。

このプログラムのもう1つの一般的な書き方は、 for というキーワードを使う ループを使うやり方だ。

let total = 0;

for (let number = 1; number <= 100; number++) { total += number; }

document.getElementById("result").innerHTML = total;

for ステートメントには、セミコロンで区切られた3つの場所がある。 1つ目は、

577

number 変数を1に初期化する。 中括弧の中のコードブロックは、2つ目の部分 が真である場合、 つまり number が100以下である場合にのみ実行される。 そ のブロックのコードが実行されたあとで、 number がインクリメントされる。 さ らにこのブロックには1つのステートメントしか含まれていないため、 中括 弧を省略することができる。

次に示すのは1~100までの数字をループして、 それぞれの平方根を表示す る小さなプログラムだ。

for (let number = 1; number <= 100; number++)

{

document.getElementById("result").innerHTML += "The square root of " + number + is Math.sqrt(number) + "<br />"; " +

}

ループ内で実行されるコードブロックに含まれるステートメントは1つだけ だが、長いので3行に分けて書いている。 3行のうち、 最初の行が += で終わっ ていることに注目しよう。 これは、次の行が<p>タグの内側のHTML (innerHTML)に追加され、 ループが繰り返されるたびに、 テキストが付け加 えられて長くなっていくことを意味している。 innerHTMLに追加されるのは、 テキストと数字の組み合わせだ。 特に Math.sqrt は、 平方根を計算する JavaScript の関数だ。 これは JavaScript 言語の一部である(このような関数は、 組み込み関数 [ビルトイン] と呼ばれることもある)。 また、 HTML の改行である <br />タグにも注意しよう。

プログラムが終了すると、 長いテキストのリストが表示される。 全部見るに は、ページをスクロールする必要がありそうだ!

ふるい 次に紹介するプログラムは、エラトステネスの篩と呼ばれる、 素数を求める有 名なアルゴリズムを実装したものだ。 エラトステネス (176-194) は、 伝説的な アレクサンドリア図書館の司書であり、地球の円周を正確に計算したことでも知 られる。

ここで素数とは、 自分自身とによってのみ割り切れる整数のことだ。 最初 の素数は2 (唯一の偶数の素数) 以降素数は3、5、7、11、13、17、19、

578

27 コーディング

23 29 と続く。

エラトステネスの手法は、まず2から始まる正の整数のリスト [一覧表」から 始まる。 2は素数なので、 2の倍数の数字をすべて消そう (つまり2以外の偶数 を消すことになる)。 それらはみな、 素数ではない。 次に、3は素数なので、3 の倍数である数字をすべて消そう。 4が素数でないことは、 すでに消されている ので、もうわかっている。 次の素数は5なので、5の倍数をすべて消そう。 この まま続けていくと・・・・・・ 残っているのが素数の一覧となる。

このアルゴリズムを実装した JavaScript のプログラムでは、配列と呼ばれる 一般的なプログラミング要素を利用する。 配列は変数と同じように名前を持つ が、配列の中には複数の項目が格納され、 各項目は配列名のあとに角括弧で囲ま れたインデックスを与えて参照される。

このプログラムで使う配列には primes という名前がついていて、 10,000個 のブール値が含まれている。 JavaScript では、 ブール値は true か false のどちら かであり、これは JavaScript のキーワードでもある(この概念にはすでに 第6章からおなじみのはずだ)。

まず primes という名前の配列を作成し、 その配列の中のすべての値をtrueに 初期設定する方法を説明する。

let primes = [];

for (let index = 0; index < 10000; index++) { primes.push(true); }

実はもっと短い方法もあるのだが、 ちょっとわかりにくい。

let primes new Array(10000).fill(true);

主な計算には2つの forループが使われる、 1つのループが別のループの内側 に入っている(この場合、最初のループは2番目の for ループの中にネストされ ているといわれる)。 配列のインデックスを表現するための変数が2つ必要にな るが、 index という単語のバリエーションを使う代わりに、ここではili2 とい

579

580

う短い単語を使うことにする。 変数名には数字を含めることができるが、 変数名 は普通の文字で始まる必要がある。

for (let i1 = 2; i1 <= 100; i1++)

{

if (primes[i]) { for (let i2 = 2; i2 < 10000 / i1; i2++) { primes[i1 * i2] = false;

}

最初の for ループでは、 i1 変数を2から 100 (すなわち 10,000の平方根) ま で増やしていく。 If ステートメントは、見ている配列要素 (primes[il]) が true である場合のみ (つまり素数であるときのみ)、 次の部分を実行する。 2番目の ループは、 変数 i2を2から増やしていく。 したがってilとi2の積は、 il ×2、 il × 3 il × 4 ･････ となり、 これらの数はもちろん素数ではないので、配列の 要素 (primes[i] * i2]) には false が設定される。

i1 は 100 まで、 そしてi2 は 10,000 をil で割った値までしか増やさないのは おかしいと思うかもしれない。 しかし、 10,000 までのすべての素数を網羅する ためにはこれで十分なのだ。

プログラムの最後に、 結果を表示する。

for (let index = 2; index < 10000; index++)

{

if (primes[index])

document.getElementById("result").innerHTML +=

{

index +

}

第27章 コーディング 581

JavaScript のプログラミングに興味を持ったなら、 メモ帳やテキストエディッ トを使い続けないように! スペルが間違っていたり、 何か不手際があったときに 教えてくれる、もっとよいツールがある。

もし、チュートリアルのために丁寧にコメントした簡単な JavaScript プログ ラムを見たい場合は、ウェブサイト (www.CodeHiddenLanguage.com) の本 章のセクションを参照してほしい。

プログラミングはアートなのかサイエンスなのかで揉めることがある。 たとえ ば大学のカリキュラムはコンピュータサイエンス [計算機科学] と呼ばれているが その一方で、 ドナルド・クヌースの有名な 『The Art of Computer Programming』 [同 名の邦訳がある] シリーズのような本もある。 プログラミングは、サイエンスと アートの両方の要素を持つが、 本当は別のものである。 物理学者リチャード・ ファインマンは、「むしろ、 コンピュータサイエンスはエンジニアリングのよう なものだ。 何かに何かをさせることについてのすべてを含んでいる」 と書いてい る。

ほとんどの場合、プログラミングは厳しい戦いだ。 お気づきのように、コン ピュータのプログラムでは簡単にエラーが発生し、そのエラーの追跡に多くの時 間を費やすことになる。 デバッグはそれ自体がアート (あるいはサイエンス、 も しくはエンジニアリングの偉業)だ。

ここまで見てきたのは、JavaScript プログラミングという氷山の一角にすぎな い。しかし、歴史は、氷山の周りでは用心するようにと教えている! コンピュー タ自体が予期せぬ動きをすることもある。 たとえば、この小さなJavaScriptの プログラムを試してみよう。

let a = 55.2; let b = 27.8; let c = a * b;

document.getElementById("result").innerHTML = c;

このプログラムは、 1534.56000000002 を表示する。 その結果の見た目から しておかしいし、事実正しくない。 正しい結果は、 単純に 1534.56のはずだ。 何が起こったのだろう?

浮動小数点数はコンピューティング [数値演算] において非常に重要である。

そのため、1985年に IEEE (Institute of Electrical and Electronics Engineers [米国電気電子技術者協会]) が規格を制定し、 ANSI (American National Standards Institute [米国家規格協会]) でも認められた。 ANSI/IEEE Std 754- 1985 は、 IEEE Standard for Binary Floating-Point Arithmetic [2進浮動小数点演算のた [めの IEEE 標準]と呼ばれる。 この規格は、 18ページとそれほど長くはないが、 浮動小数点数のエンコードに関する詳細がわかりやすく書かれている。 最も重要 な規格の1つであり、ほぼすべてのコンピュータおよびコンピュータプログラ ムで使用されている。

IEEE の浮動小数点標準は2つの基本形式を定義している。 1つの数値あたり 4バイトを必要とする単精度と、1つの数値あたり8バイトを必要とする倍精度 だ。 プログラミング言語によっては、 どちらを使うか選択できるものもあるが、 JavaScript は倍精度のみを使用する。

IEEE 規格は、科学的記数法による数値の表現に基づいており、 数値は2つの 部分から構成される。 仮数部と、 10の整数乗の数値として与えられる指数部で ある。

仮数部

42,705.7846=4.27057846 x 10

指数部

仮数部が小数点の左側に1桁しか持たないこの特殊な表現は、 正規化形式と呼 ばれる。

IEEE 規格では、 浮動小数点数を同じように、ただし2進数で表現している。 本書でこれまで見てきた2進数はすべて整数だったが、 分数にも2進数表記を 使用できる。 たとえば、 次の2進数を考えてみよう。

101.1101

このピリオドを 「デシマルポイント [小数点]」 と呼んではいけない! これは2進 数なので、このピリオドは正しくはバイナリーポイントと呼ばれる。 バイナリー ポイントの左側の数字が整数部、 バイナリーポイントの右側の数字が小数部だ。

第10章で2進数を 10 進数に変換した際、 各桁が2のべき乗に対応すること を確認した。 バイナリーポイントの右側の桁は、2の負のべき乗に対応する以外 は同様の形をしている。 たとえば2進数の1011101 は、 左側から右側へと対応 する2の正および負のべき乗にビットを掛けることで10進数に変換できる。

582

27 コーディング

1×22+

0×2′ +

1×2+

1× 2-1.

1× 2-2+

0×2-3 +

1 x 2-4

これらの2の負のべき乗は、 1から始めて、2で繰り返し割ることにより、 計 算できる。

1×4+ 0×2+ 1×1+ 1 x 0.5 + 1 x 0.25 + 0 x 0.125 + 1 x 0.0625

この計算では、101.1101 の 10 進数換算は5.8125 となる。 10 進数の科学表記の正規化形式では、 仮数には小数点の左に1桁しかない。 同様に、2進数の科学表記でも、 正規化された仮数にはバイナリーポイントの左 には1桁しかない。 数値 101.1101 は次のように表現される。

1.011101 x 22

この規則の興味深い特徴は、 正規化された2進浮動小数点数は、 バイナリー ポイントの左に1があって、それ以外は何もないということだ。

IEEE 規格の倍精度浮動小数点数には8バイトが必要だ。 構成する 64 ビット はこのように割り振られる。

583

584

s=1ビットの符号 e=11ビットの指数 f=52 ビットの仮数

正規化された2進数の浮動小数点数の仮数は常にバイナリーポイントの左側 に1があるため、 IEEE 形式の浮動小数点数の保存にはそのビットは含まれてい ない。 仮数のうち、 52ビットの小数部分だけが保存される。 そのため、 仮数の 格納に 52 ビットしか使われていないにもかかわらず、 精度は53ビットとされ る。 53ビット精度の意味については、 このあとすぐに実感できる。

11ビットの指数は、0から2047の範囲で使用できる。 実際に適用される符 号付き指数には、 指数からバイアスと呼ばれる数値を差し引く必要があるため、 これをバイアス付き指数と呼ぶ。 倍精度浮動小数点数の場合、 このバイアスは 1023 だ。

これらの符号ビット)、e(指数)、f(仮数の小数部) の値で表される数値は 以下のような形になる

(-1)* × 1.f × 2-1023

この(-1)の 乗は、 数学者の得意な、そして、いやらしいほど巧妙な「sが 0ならその数は正 (0乗したものは1に等しいから)、 sが1ならその数は負 (-1の1乗は1だから)」という意味だ。

次に1.fという部分があるが、これは1のあとにバイナリーポイントが続き、 そのあとに仮数の小数部の 52 ビットが続くという意味だ。 これが2のべき乗に 乗じられる。 指数は、 メモリーに格納されている11ビットのバイナリーポイン トから 1023 を引いたものである。

いくつかの詳細は説明していない。 たとえば、 私の説明では、ゼロを表現する 方法がない! これは特殊なケースだが、 IEEE 標準では、負のゼロ (非常に小さ な負の数を表現するため)、 正および負の無限大、 そして Not a Number[数値で はない]という意味の NaN として知られる値も表現できる。 これらの特殊なケー スは、 浮動小数点標準の重要な部分だ。

先ほど例に挙げた 101 1101 という数字は、次のような52ビットの仮数で格 納されている。

27 コーディング 585

0111 0100 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000

なお、読みやすくするために、4桁ごとにスペースを入れている。 バイアス付 き指数は 1025 なので、 結局数字は次のようになる。

1.01110121025-1023= 1.011101 x 22

最小の正または負の倍精度浮動小数点数は次のようになる。

1022

1.0000000000000000000000000000000000000000000000000000 x 21 バイナリーポイントに続くゼロは52個ある。 最大の値は次の表現となる。

1.1111111111111111111111111111111111111111111111111111 x 23

10進数でいうならば約2.2250738585072014×10-308~1.7976931348623158 × 10308 の範囲となる。 10の308 乗はとても大きな数だ。 1のあとに10進数で 308のゼロが続く。

仮数部の 53 ビット (含まれないピットを含む) は、10進数16桁にほぼ相 当する分解能だが、 限界もある。 たとえば、 140,737,488.355,328.00 と 140,737,488,355,328.01 という2つの数値は全く同じように保存されてしまう。 コンピュータのプログラムでは、この2つの数値は同一のものとして扱わ

れる。

もう1つの問題は、大多数の小数の端数が正確に保存されないことだ。 たと えば、10進数の1.1 という数字を考えてみよう。 この53ビットの仮数部は次の ようになる。

0001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010 これはバイナリーポイントの右側にある小数部分だ。 10進数の 1.1 を表現する 完全な2進数はこうなる。

1.0001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010

この数字を10進数に変換し始めると次のようになる。

586

1+23+2+27 +28 +211 +....

これは以下と等価だ。

1+0.0625+0.03125 + 0.00390625+ 0.001953125 + 0.000244140625+....

そして、最終的には、これが10進数の1.1 と等しくならず、 その代わりに、 次 のようになることがわかるだろう。

1.10000000000000008881...

正確に表現されていない数に対して算術演算を始めると、 正確でない結果が得 られることになる。 これが JavaScript で、 55.2 27.8 を掛けたときに 1534.56000000002 と表示される理由だ。

私たちは「数字が隙間なく連続的に存在している」と考えることに慣れてい る。 しかし、コンピュータは必然的に、 離散的な値を扱う。 離散数学の研究が、 デジタルコンピュータの数学に理論的な裏付けを与えている。

浮動小数点演算にはまた、根や指数、 対数や三角関数のような、 複雑かつ楽し い計算も含まれる。しかし、これらはすべて、 加算、 減算、 乗算、 除算という4 つの基本的な浮動小数点演算で行うことができる。

たとえば、 三角関数の sin は、 次のように級数展開で計算できる。

sin(x)=x- - + - +...

引数xの単位はラジアンだ (2ラジアン=360度である)。 感嘆符 (!) は階 乗記号である。 1から指定された数までの整数をすべて掛け合わせることを意味 する。 たとえば、 5! は 1 ×2×3×4×5に相当する。 また、 各項の指数も乗 算だ。 あとは、 除算、 加算、 減算となる。 本当に怖いのは最後の省略記号 (...) だけで、 これは永遠に計算を続けろという意味だ。 しかし、 実際には、0から /2までの範囲に限定すれば (そこからほかのすべてのサイン値を導き出せる)、 永遠というほど続ける必要はない。 十数項程度を並べれば、 倍精度数値の53 ビット程度の分解能になる。

第27章 コーディング

もちろん、コンピュータは人間のために物事を簡単にするものなので、 浮動小 数点演算を行うルーチンを何個も書くというなら、 その目的とは相反するように 思える。ここでソフトウエアのよさが生きてくる。 一度誰かが、 特定のマシン用 の浮動小数点ルーチンを書けば、 ほかの人はそれを使うことができるのだ。浮動 小数点演算は、 科学や工学のアプリケーションにとって非常に重要であるため、 従来からとても高い優先順位が与えられてきた。 コンピュータの黎明期には、新 しい種類のコンピュータが作られた際、 常に最初に取り組むソフトウエア関連の 仕事の1つが、 浮動小数点ルーチンを書くことだった。 プログラミング言語に は通常、 数学関数のライブラリー式が含まれる。 すでに JavaScript の Math.sqrt 関数を目にしたはずだ。

浮動小数点演算を直接行う特別なハードウエアを設計することも理にかなって いる。 浮動小数点ハードウエアをオプション [選択肢] として搭載した最初の商 用コンピュータは、 1954年に登場したIBM 704 だった。 704 はすべての数値 を36ビット値として記憶していた。 浮動小数点数の場合は、 27ビットの仮数、 8ビットの指数、 そして符号ビットに分解されていた。 その浮動小数点ハードウ エアは、加算、 減算、 乗算、 除算を実行できた。 そのほかの浮動小数点関数は、 ソフトウエアで実装する必要があった。

ハードウエアの浮動小数点演算がデスクトップに登場したのは1980年だ。 こ のときインテルが 8087 数値演算コプロセッサチップをリリースした。 このチッ プは、現在では数値コプロセッサまたは浮動小数点演算装置 (FPU) と呼ばれ る集積回路だ。8087 がコプロセッサと呼ばれるのは、 それ単体では使用できな かったからだ。 8087 は、 インテルの最初の16ビットマイクロプロセッサであ る 8086 および 8088 とのみ連携して使用できた。 当時 8087 は、 それまでに作 られた最も高度な集積回路と見なされていたが、最終的にこうした数値コプロ セッサは CPU 自体に組み込まれることとなった。

今日のプログラマは、 浮動小数点数を単にコンピュータの一部であるかのよう に扱っているが、 実際そうなのだ。

587



第28章 世界頭腦

イギリスの作家ハーバート・ジョージ・ウェルズは1936年と1937年、ちょっ と変わったテーマで一連の公開講演を行った。 このときに彼H.G. ウェルズは、 70歳代初めだった。 ウェルズの有名なSF小説『タイムマシン』、『モロー 博士の島』、『透明人間』、 『宇宙戦争』は1890年代に出版され、彼を作家と して有名にした。 しかし、 ウェルズは、社会や政治の問題について深く考え、そ れを公の場で共有する知識人へと歩んでいた。

彼が 1936年 1937年に行った講演は、 1938年に 『World Brain』 [邦訳『世界 の頭脳』 思索社] というタイトルで書籍化された。 この講演でウェルズは、一種の 百科事典を提案したが、それは商業目的で作成され戸別訪問で販売されるような ものではなかった。 提案された 「世界百科事典」は、これまでにない方法で世界 の知識を集約するものだった。

当時のヨーロッパは、不安定な時代を迎えていた。 20年前の第一次世界大戦 の記憶はまだ新しいのに、 再び大陸を巻き込む紛争へと突き進んでいるように思 えた。 楽観主義者であり、 ユートピア主義者でもあったウェルズは、科学、 合理 性、 知識こそが世界を未来へと導く最良のツールであると信じていた。 彼が提案 した世界大百科事典は、次のような内容を含んでいた。

......私たちの社会秩序の支配的な概念、 知識の全分野での概要と主な詳細 宇 宙の正確かつ合理的で詳細な見取り図、世界の一般的な歴史、そして……知識 の一次情報源への信頼性のある完全な参照システム。

要するに、「現実の共通の解釈」 と 「精神的な融和」 を提供するものだった。 このような百科事典は、 世界規模で拡大する知識とともに継続的に更新される 必要があるが、その開発の過程で百科事典は次のようになる。

......マインド [心、 知性] のための一種の精神的交換所となり、 知識とアイデア が受け取られ、 整理され、 要約され、 消化され、明確化され、 比較される倉庫 ......となるだろう。それが本物のワールドブレイン (世界頭脳) の重要な 始まりを構成するだろう。

1930年代は最初のデジタルコンピュータが作られ始めたばかりで、ウェルズ がそれらについて何か知識を持っていた可能性は低い。 そのため、 彼はこの百科 事典を書籍の形式で考えるしかなかった。 「その巻数は20巻か30巻か40巻か」。 しかし、彼は、マイクロフィルムという新しい技術には精通していた。

近い将来、 世界中の重要な書籍や文書の写真が保管され、 学生が容易に検証で きるようになる、マイクロな記録の図書館が存在する可能性がある・・・・・・。 世界 のどこにいる学生でも、 自分の都合に合わせて自らの書斎でプロジェクターを 使い、 どんな書籍でも、 どんな文書でも、 正確な複製を用いて調べられる時代 が近づいている。

なんという未来予想図なのだろう!

それから10年も経たない1945年、 技術者であり発明家でもあったヴァネ ヴァー・ブッシュは、似たような、だがもう少し進んだビジョン [未来像] を抱 いていた。

ヴァネヴァー・ブッシュは、すでにコンピューティングの歴史にその名を刻ん でいた。 1927年、 ブッシュはマサチューセッツ工科大学(MIT) 電気工学科の 学生たちとともに、 微分方程式を解く画期的なアナログコンピュータ 「微分解析 機」を開発した。 1930年代初頭には、 MIT の工学部長で副学長となっていた。

1974年にニューヨーク・タイムズ紙で掲載されたブッシュの死亡記事では、 彼を 「典型的エンジニア物事を成し遂げる人」 (それが技術的な問題を解決 することであれ、 政府の官僚主義を切り抜けることであれ) と称した。 第二次世

590

第28章 世界

591

界大戦中、 ブッシュは世界初の原爆を生み出したマンハッタン計画を含む、 3万 人以上の科学者とエンジニアを戦争のために統括する責任を担っていた。 数十年 にわたって、 ブッシュは科学者とエンジニアが公共政策に関与することを提唱者 する主要な人物だった。

第二次世界大戦末期、 ヴァネヴァー・ブッシュはアトランティック・マンス リー誌の1945年7月号に、 今では有名となった記事を書いている。 「As We May Think [考えてみるに]」 と題されたこの文章は、 今から思えば実に予言的だ。 ライフ誌の9月号に掲載されたその記事の要約版には、 空想的なイラストが添 えられていた。

H・G・ウェルズのように、 ブッシュは、情報および情報を追いかけ続けるこ との難しさに焦点を当てた。

こんにち 研究は山のように膨大だ。 しかし、 専門化が進むにつれて、私たちは今日、 沼 地にはまり込んでいるという証拠が増えている。 研究者は、ほかの何千人によ る発見と結論に圧倒されている。 理解する時間を見つけることも、ましてや覚 えることもできない･･････。 困難なのは、 現代の興味の範囲と多様性を考えると、 無闇に出版されることよりも、 出版が私たちの現実の記録の利用能力をはるか に超えていることであるようだ。 人間の経験の集大成は驚異的な速度で拡大し ているのに、その結果として生じる迷路を通ってその瞬間に重要な項目にたど り着く手段は、 帆船時代に使われたものと同じままだ。

ブッシュは、未来の科学者に役立つ可能性のある、 急速に進化する技術に気づ nxt いていた。 彼は何かを記録する必要があるたびに起動される、額に固定されたカ メラを想像していた。 また、 マイクロフィルム、文書の「ファクシミリ送信」、 人間の音声を直接録音してテキストに変換する機械についても語っている。

しかし、記事の最後にブッシュは、「・・・・・・私たちは記録を膨大に拡張できるが、 たとえ今の量であっても、 その内容を調べることはほとんど不可能だ」と、残さ れた問題を指摘した。 ほとんどの情報はアルファベット順に整理され、 索引もあ る。 しかしながら、それでは明らかに不十分なのだ。

人間の心はそのようには働かない。 心は連想によって動作する。 1つの項目を

手にすると、 思考の連想によって提案される次の項目に、 脳の細胞によって運 ばれる複雑な軌跡の網に沿って瞬時に移動する。

ブッシュはある種の機械を構想した。 それはすなわち、 「機械化された個人の 「ファイルと図書館」であり、マイクロフィルムを保管して容易にアクセスできる 精巧な机である。 彼は、 それに memex [メメックス] という名前をつけた。

memex のコンテンツ [情報の中身] のほとんどは、 機械に挿入可能なマイクロ フィルムとして購入される。 様々な種類の本、 写真、 定期刊行物 新聞がこの ような形で入手され、 所定の位置にセットされる。 ビジネスでのやり取りも同 じ道を歩む。 そこには直接入力するための規定がある。 memex の上には、透 明な板が備えつけられている。 この上に、 手書きのメモや写真、 備忘録など、 様々なものが置かれる。 何かが置かれているときに、レバーを押すことで撮影 が行われ、 memex の空いた部分に保存される・・・・・・。

だが、最も重要なのは、こうした文書に余白メモやコメントを追加し、「連想 「インデックス」 で統一できることだ。

これが、 memex の本質的な特徴だ。 2つの項目を結びつけるというプロセスが 重要なのだ･･････ さらに、 このように多数の項目を結合して関係を形成した場合、 本のページをめくるときのようにレバーをたわませることで、 順番に、 速く、 またはゆっくりと内容を見直すことができる。 それはまさに、 広く離れた情報 源から物理的な項目が集められ、 新しい書籍を形成するために結びつけられた かのようだ･･････。 こうして完全に新しい形式の百科事典が現れるだろう。 連想 の軌跡がそれらをつなぎ、 memex に保存されて活用される準備が整うのだ。

ヴァネヴァー・ブッシュは、この機械のユーザーは 「何も覚えなくていい」と いう怠惰な利便性さえも予測していた。 なぜならユーザーは、 「すぐに必要のな い様々な事柄を忘れることができ、 重要ならあとで再び見つけられるという安心 がある」 からだ。

ブッシュが memex について書いてから20年後の1965年、 この夢をコン

592

第28 世界頭 593

ピュータで実現できる見通しが立ってきた。 コンピュータのビジョナリー [先見 の明がある人物であったテッド・ネルソン (1937年生まれ) は、 『Complex Information Processing: A File Structure for the Complex, the Changing and the Indeterminate [複雑な情報処理 複雑で、変化し、 不確定なもののためのファイル構 造]』 と題した論文で memex の現代化に挑戦した。 この論文は、米国の計算機 協会 (ACM) の会議である ACM '65 の予稿集に掲載された。 論文の概要は次 のように始まる。

私たちがコンピュータを個人のファイル用に、 また創造性の補完として使用する ために必要なファイル構造は、ビジネスや科学的データ処理で一般的なものと は全く異なる特徴を持つ。 そのファイル構造は、 複雑で特異な配置、 全面的な 修正可能性、 未決定の選択肢、徹底した内部文書化などを提供する必要がある。

memex に関するブッシュの記事を参照しつつネルソンは、 「ハードウエア準備はできている」 と断言した。 彼が提案するファイル構造は野心的かつ魅力、それを説明するために新しい言葉を発明する必要があった。

の 的 で

「ハイパーテキスト」 という言葉を紹介したい。 それは、紙の上ではうまく提 示または表現できないほど複雑に相互につながった、文章または図式化された 素材を意味する。 その内容には要約や解説が含まれることもある。それを調査 した学者たちによる注釈や追加情報 脚注も含まれるかもしれない。そのよう なシステムが適切に管理されれば、 教育においても大きな可能性を持つ。 学生 の選択肢や自由な感覚、 動機づけ、知的理解を高めることができるだろう。 だし、 その内部のファイル構造は、発展や変化、複雑な情報の配置を受け入れ られるように構築されなければならない。

H・G・ウェルズ、ヴァネヴァー・ブッシュ、 テッド・ネルソンのこれらの文 章を読むと、少なくとも一部の人々は、インターネットが実現可能になるずっと 前から、 インターネットについて考えていたことがわかる。

コンピュータ同士による長距離間通信は、 大変な作業だ。 インターネットその ものは、1960年代の米国防総省の研究が発端である。 1971年に運用が開始さ

れた ARPANET (Advanced Research Projects Agency Network) [アーパネット] は、インターネットの概念の多くを確立した。 おそらく最も重要だったのはパ ケット交換だ。これは、データをヘッダーと呼ばれる情報を伴う小さなパケット [小包、 塊] に分割する技術である。

たとえば、 コンピュータ Aに30,000 バイトの大きさのテキストファイルがあ るとしよう。コンピュータBはコンピュータ Aと何らかの手段で接続されてお り、接続を通じて送られる信号によって、 コンピュータ Aに対してテキストファ イルの取得要求を出す。 コンピュータ Aはそれに呼応して、 まず、このテキス トファイルを 1,500 バイトずつ20個のパート (パケット) に分割する。これら のパケットの中には、送信元 (コンピュータA)、 送信先 (コンピュータB)、 ファイル名、パケットを識別する番号 (たとえば 20個中7個目とか) が記載 されたヘッダー部が含まれる。 コンピュータB は、各パケットの受信を確認し、 それからファイルを再び組み立てる。 あるパケットが紛失した場合には (おそら く送信中に紛失したのだろう)、 そのパケットのコピーを再度要求する。

ヘッダーにはチェックサムが含まれることもある。 チェックサムは、ファイル の全バイトから何らかの標準的な方法で計算された数値だ。 コンピュータBは パケットを1つ受信するたびに算出し、 その結果を元のチェックサムと照合す る。両者が一致しない場合は、 パケットが送信中に破損したと判断しなければな らない。 そのときはパケットの再送信を要求する。

パケット交換には、 ファイルをそのまま送信するよりも、いくつかの利点があ る。 まず、 2つのコンピュータ間の接続路を、ほかのコンピュータがパケットを 交換する際に共有できるようになる。 1台のコンピュータが大きなファイルを要 求してシステムを麻痺させることはない。 また、パケットにエラーが検出された ときには、ファイル全体ではなく、そのパケットのみを再送すればよい。

本書を通じて、 デジタル情報が電線を経由して伝達される様子を見てきた。 電 線に電流が流れている状態を2進数の1 電流が流れていない状態を2進数の 0 としていた。 しかし、 本書で紹介した回路の配線はかなり短いものだ。 デジタル 情報をより長い距離で伝えるには、 異なる仕組みが必要になる。

固定電話が最も早く長距離デジタル通信の手段となったのは、固定電話がすで に存在し、 便利に利用できたからだ。 しかし、 電話というシステムは、 人と人が 話したり聞いたりするために作られたものだ。 技術的には、 電話システムは人の

594

28 世界頭脳

595

会話に十分とされる 300~3,400Hz の音声信号を伝える。

2進数の0と1を音声信号に変換する単純な方法の1つは、 変調 [モジュレー [ション]というプロセスを通じて行う。 これは、アナログ音声信号を何らかの方 法でデジタル化した情報をコードにするやり方だ。

たとえば、 初期の変調装置としては、 1962年から AT&T社で製造され、 1990年代に至るまで長く影響を及ぼした Bell 103 がある。 このデバイスは全二 重モードで動作した。 つまり、 情報を同時に送受信できた。 電話線の一端には発 信局があり、 もう一端には応答局があった。 この2つの局は、毎秒300ビット の速度で通信を行った。

Bell 103 は、 周波数偏移変調 (FSK) という技術を使って、0と1を音声信 号に符号化していた。 発信局では、 2進数の0を 1,070Hz、 2進数の1を 1,270Hz として符号化していた。この2つの周波数で符号化された8ビット ASCIIコードの 「W」 を以下に示す。

1 0 1 0

この図ではわかりにくいかもしれないが、ビット0はビット1よりも周波数 が低いので、 サイクル間のスペースが少し広くなっている。 応答局は、 2,025Hz 2,225Hzの周波数を使う以外は、発信局と同様の変調を行う。 また、 簡単な エラーチェックのために、パリティビットを含むことが多かった。

音声を変調して2進データを符号化する装置は、入力された音声を復調(デモ ジュレーション] して0と1に戻す機能も備える。 そのため、これらの装置は変調 復調器 [モジュレータデモジュレータ]、 またはモデムと呼ばれている。

Bell 103 のモデムは、 毎秒300ビットの速度でデータを送信できた。 このた め 300 ボーデバイスとも呼ばれた。 この単位は第13章で紹介したエミール・ボ ドーに由来する。 ボーレートはシンボルレートとも呼ばれ、1秒あたりのビット 数に一致する場合と、そうでない場合がある。 たとえば、4つの異なる周波数を 用いてビット列 0001, 10, 11 を表現する FSK 方式を考案したとする。 この

596

音を表す波形が1秒間に1,000回変化した場合には、 1,000 ボーに分類される が、伝達されるビットは1秒間に2,000ビットになる (1回の変化で2ビット が送信されるため)。

300 ボーのモデムは、 2台のコンピュータを接続するとき、 かなりうるさい音 を発する。 このため1980年代から1990年代にかけてのホームコンピューティ ングをイメージさせる音として、 テレビ番組や映画などでよく使われる。

デジタル電話回線を利用したモデムは、 最終的には、 1秒あたり56キロビッ トの速度を実現した。 56K モデムと呼ばれ、 今でも一部地域で使われている。 さらに、デジタル加入者線 (DSL)、 同軸ケーブル、 衛星などを利用することで、 より高速に接続できる。 これらは無線周波数で波形を伝え、 非常に精巧な変調技 術によって波形内にさらに多くのデジタル情報を符号化することで、はるかに大 きな速度のデジタル伝送を達成できる。

大陸間のインターネット接続や沿岸部での接続には、別の通信媒体が使われて いる。 海中には無数ともいえる光ファイバーケーブルが敷設または埋設されてい る。ガラスやプラスチックの細いファイバー (繊維)でできたケーブルの中に 赤外線を通して情報を伝送する。 通常光は曲がらないが、 ファイバー内面では跳 ね返るので、 ファイバーが曲がっていても伝送は可能だ。

ケーブルはファイバーが数百本ほど束ねられたもので、 各ファイバーは別々に 伝送を行える。 ファイバーの中には、それ自体が複数の信号を伝送できるものも ある。 この光ファイバーケーブルでは、 光をパルス [矩形波] にすることでデジ タル情報を符号化する。 光は、 オフが0、 オンが1というように、 非常に速くオ フとオンを繰り返す。 これが、 現代のインターネットに求められる高速通信を可 能にする。

トポロジー [配線形態] も重要だ。 インターネットは、世界のどこかに巨大なコ ンピュータを1台用意して、 その1台にほかのすべてのコンピュータを接続す ることでも実現できただろう。 ある意味、これでインターネットははるかにシン プルになる。 しかし、この単純な仕組みには明らかに欠点がある。 中央のコン ピュータから遠く離れた場所に住む人は、より大きな遅延に悩まされる。 また、 その巨大なコンピュータがクラッシュしたら、 世界中のインターネットがダウン してしまう。

その代わりに、 実際のインターネットは分散型で、 多くの冗長性を持ち、 単一

第28章 世界頭脳 597

障害点 [障害が起きることでシステム全体が止まってしまう個所] が存在しない。 たくさ んのデータを保存する非常に大きなコンピュータは実在する。 こうしたコン ピュータをサーバーと呼び、 サーバーのデータにアクセスする小型のコンピュー タをクライアントと呼ぶこともある。 しかし、私たちが使っているクライアント コンピュータは、直接サーバーに接続しているわけではない。 その代わり、イン ターネットサービスプロバイダー (ISP) を通じてインターネットにアクセスす る。 おそらく ISPに月々の利用料を支払っているので、 ISP がどこなのかは知っ ているはずだ。 携帯電話からインターネットにアクセスする場合には、 携帯電話 会社が ISP を兼ねている。

電線やケーブル、 電波のことは脇に置くとして、 インターネット上のあらゆる ものは、ルーターを介して相互に接続されている。 ルーターは、クライアントと サーバーの間にルート [経路] を提供することから、そう呼ばれている。 ルーター は、おそらくインターネットにアクセスするためのモデムの一部として、あるい は Wi-Fi ハブの一部として自宅内に置かれているだろう。 ルーターにはイーサ ネットケーブル用の端子があり、コンピュータやプリンターを物理的に接続でき る。

かなめ インターネットの連動部分を構成する要のルーターは、こうした家庭用ルー ターよりも高機能だ。 これらのルーターの多くは別のルーターに接続され、 別の ルーターがパケットを伝達し、 さらに別のルーターに接続されて、 というよう に、複雑なメッシュ [網] を構成している。 ルーターは、ルーティングテーブル [経路表] や、 パケットが宛先に到達するための最適な経路を記述するアルゴリズ ムによるルーティングポリシーを保存するために、 独自のCPUを搭載している。

普遍的に存在しているもう1つのハードウエアは、 ネットワークインター フェースコントローラ (NIC) である。 すべてのNICは、ハードウエアに組み 込まれた、 不変で一意の識別子を持っている。 この識別子は、 メディアアクセス コントロール (MAC) アドレスと呼ばれる。 MAC アドレスは、合計 12桁の 16進数で構成され、2桁ずつ6つのグループに分かれている場合もある。

インターネットに接続されているハードウエアには、それぞれ独自の MAC アドレスが設定されている。 デスクトップパソコンやノートパソコンには、イー サネット接続用、 Wi-Fi用、 近くの機器と電波で接続できる Bluetooth用といっ たように、複数の MAC アドレスが与えられているかもしれない。 このMAC

アドレスは、パソコンの設定情報から取得できる。 モデムや Wi-Fi ハブにも MACアドレスがあり、 おそらくこれらの機器のラベルに印刷されている。 携帯 電話にも、 Wi-Fi や Bluetooth の MAC アドレスが登録されているはずだ。 MACアドレスには16進数の12桁が使われていることから、 今すぐ世界で枯 渇することはないだろう。 地球上のすべての人間に対して、 3万個以上のMAC アドレスが存在するからだ。

インターネットは、電子メールやファイル共有など、いくつかの異なるサービ スをサポートしているが、ほとんどの利用者は、1989年にイギリスの科学者 ティム・バーナーズ=リー (1955年生まれ) が中心となって考案した World Wide Web [ワールドワイドウェブ] を通じてインターネットと接している。 ウェブ を作るにあたってバーナーズ・リーは、 彼が10歳のときにテッド・ネルソンが 作った「ハイパーテキスト」 という言葉を採用した。

ウェブ上の文書の基本形はページまたはウェブページと呼ばれ、 ハイパーテキ ストマークアップ言語 (HTML) を用いたテキストで構成される。 前章で一部 見たように HTML文書には、 段落を表す <p>、 トップレベルの見出しを表す <h1>、 ビットマップ画像を表す <img> などのテキストタグが含まれる。

HTML タグの中で最も重要なものの1つが、アンカー [猫] を意味する <a> だ。 アンカータグはハイパーリンクを囲んでいる。 ハイパーリンクは通常、 短い テキスト文字列で、 異なる書式 (多くの場合は下線) で表示され、そこをクリッ クまたはタップすると別のウェブページが表示される。 これが複数のウェブペー ジをリンクさせる方法だ。 リンクは、本の目次のようにより大きな文書の一部に なることもあるし、 トピックを深く掘り下げられるように参考文献や追加情報を 提供することもある。

誕生して数十年で、 ウェブは巨大な成長を遂げた。 H.G. ウェルズやヴァネ ヴァー・ブッシュには、オンラインでの調査、 ショッピング、エンターテインメ ントの潜在能力を想像することはおろか、 猫の動画を楽しんだり見知らぬ人との 激しい政治的論争に没頭したりする奇妙な魅力を考えることもできなかっただろ う。 実際、 インターネット以前のコンピュータ革命は、 今振り返ると不完全にも 思える。 インターネットはコンピュータ革命の頂点であり、集大成である。 この 革命の成功は、 インターネットがどれだけ世の中をよくしたかという点で判断さ れなければならない。 それは、私よりもずっと深い思考ができる人のためのテー

598

マだ。

第28章 世界頭脳

599

ウェブ上のページは、 ユニフォームリソースロケーター(URL) で識別され る。 本書のために用意したウェブサイトのあるページは、次のようなURLでア クセスできる。

www.Code HiddenLanguage.com/Chapter24/index.html

このURLは、ドメイン名 (www.CodeHiddenLanguage.com)、 ディレクト リ名 (Chapter24)、HTML ファイル名 (index.html)で構成されている。 URL は、プロトコルと呼ばれる部分から始まる。 http は Hypertext Transfer Protocol [ハイパーテキスト転送プロトコル] の略で、 https は HTTP のセキュア [安 [全] なバリエーションだ。 これらのプロトコルは、ウェブブラウザなどのプログ ラムがウェブサイトからページを取得する方法を記述する。

(混乱するかもしれないが、 Uniform Resource Identifier (URI) と呼ばれるも のもある。 これは URL とほぼ同じ形式を持つが、 ウェブページを参照するので はなく、 固有の識別子として使用できる)。

最新のコンピュータで動作するアプリケーションは、 HTTPリクエストを開始 するために、 オペレーティングシステムを呼び出す。 プログラムがやることは、 URL を https://www.Code HiddenLanguage.com のようなテキスト文字列で指 定するだけだ。 しばらくして (それほど長くはないことを期待しよう)、アプリ ケーションはリクエストしたページをHTTPレスポンスとして受信する。 リク エストが失敗した場合は、エラーコードが応答として返ってくる。 クライアント が存在しないファイル (たとえば、 https://www.CodeHiddenLanguage.com/ FakePage.html など) を要求した場合、 レスポンスはおなじみの404 コードと なり、ウェブページが見つからなかったことを示す。

そのリクエストとレスポンスの間に起こるのは、リクエストをするクライアン トとそれに応答するサーバーの間の、 かなり手の込んだやり取りだ。

ウェブサイトのURLは、 ウェブサイトの本当の識別子であるインターネット プロトコル (IP) アドレス (たとえば、 50.87.147.75) に、 人間が読みやすい ように仮の名前をつけただけのものだ。 この50.87.147.75 はバージョン4のIP アドレスで、32ビットの数字である。 バージョン6のIPアドレスは128ビッ トを使用する。 ウェブサイトのIPアドレスを取得するために、ウェブブラウザ

(やほかのアプリケーション) は、 URL と IP アドレスを対応づける大きなディ レクトリのような、 ドメインネームシステム (DNS) にアクセスする。

ウェブサイトのIPアドレスは固定されている。 クライアントコンピュータに もIPアドレスがあり、 おそらく ISPからそのコンピュータに割り当てられたも のだ。 家電製品にIPアドレスを持たせて、 自分のコンピュータからアクセスで きる場合が増えている。 そうした家電は、 IoT (Internet of Things [モノのインター ネット]) の例だ。

いずれにせよ、ウェブブラウザがウェブページにHTTPリクエストを行う際、 クライアントはサーバーと通信するために Transmission Control Protocol (TCP) および Internet Protocol (IP) として知られるプロトコルを用いる。 こ の2つは合わせて TCP/IP と呼ばれる。 これらのプロトコルはファイルをパケッ トに分割し、 データの先頭にヘッダー情報を追加する。 ヘッダーには、パケット が様々なルーターを移動する途中にも変わらない送信元および宛先のIPアドレ スが含まれる。 ヘッダーには送信元と宛先のMACアドレスも含まれるが、こ ちらはパケットがルーターからルーターへと移動するにつれて変化する。

これらのルーターのほとんどは、クライアントからサーバーへのリクエストの 旅、およびサーバーからクライアントへの応答の旅を行う際の、 最も効率的な経 路を示すルーティングテーブルやルーティングポリシーを備える。 ルーターを通 じたパケットのルーティングが、 インターネットの最も複雑な側面であることは 間違いない。

Code Hidden Language.com のサイトに初めてアクセスするときには、おそら く次のようにウェブブラウザに入力するはずだ。

CodeHiddenLanguage.com

このとき、私が書いたように、ドメイン名の一部を大文字にする必要はない。 ド メイン名の大文字と小文字は区別されないからだ。

ウェブブラウザがHTTPリクエストを行う際には、そのドメイン名の前に https を前置きする。 ここでは、ファイルが指定されていないことに注意してほ しい。 サーバーが Code HiddenLanguage.com というウェブサイトへのリクエ ストを受信したときには、 そのウェブサイトに関連する情報に、 どのようなファ イルを返すべきかを示すリストがすでに指定されている。 このサイトの場合、 リ

600

第28章 世界頭脳

601

ストの一番上に default.html というファイルがある。 そのため、次のようにウェ ブブラウザに入力したのと同じになる。

CodeHiddenLanguage.com/default.html

これがウェブサイトのホームページだ。 ウェブブラウザでは、「ページソースを 表示する」 などのオプションを指定して、 HTML ファイルを直接見ることがで きる。

ウェブブラウザが default.html ファイルを受信すると、 第27章で説明した パース [構文解析] を開始する。 パースは、 HTML ファイルのテキストを1文字 ずつ読み取り、すべてのタグを識別し、ページをレイアウトする。 CPU レベル では、パース処理には一般に、 多くのCMP命令とそれに続く条件ジャンプが含 まれる。 これは通常、 HTML エンジンと呼ばれる、 おそらく C++ で書かれた ソフトウエアの塊に任されている仕事だ。 ページを表示する際には、 ウェブブラ ウザはオペレーティングシステムのグラフィックス機能を使用する。

ウェブブラウザは default.html をパースして、このファイルが style.css とい う名前の別ファイルを参照することを発見する。 style.css はページの整形方法 の詳細を記述した CSS (Cascading Style Sheets [カスケーディングスタイルシー ト]) 情報を記載したテキストファイルだ。 ウェブブラウザは、 style.css ファイ ルを取得するために、 再度HTTPリクエストを発行する。 default.html ファイ ルのさらに下の方には、 Code2Cover.jpg という名前のJPEGファイルへの参照 がある。 それは本書の表紙のイメージだ。 ウェブブラウザは、別のHTTP リク エストを発行して、 Code2Cover.jpg ファイルを取得する。

さらにその下には、 本書の一部の章のリストと、それに関連づけられたウェブ サイト内のほかのページへのリンクがある。 ウェブブラウザはほかのページをま だ読み込まずに、ハイパーリンクとして表示する。

たとえば第6章(Chapter 6) のリンクをクリックすると、ウェブブラウザは、 https://www.codehiddenlanguage.com/Chapter06 への HTTPリクエストを行 う。ここでもファイルは指定されていないが、サーバーは自身のリストをチェッ クする。 default.html というファイルは一番上のフォルダーにはあるものの、 Chapter06 のフォルダーには存在していない。 リストに載っている次の名前は index.html で、これが返されるファイルとなる。

その後、ウェブブラウザは index.html ファイルのパースを開始する。 その ページでは再び style.css ファイルが参照されているが、ウェブブラウザはそれ をキャッシュ [一時保存] している。 これはつまり、 将来使用するためにそのファ イルをローカル [手元のコンピュータ] に保存して、 再度ダウンロードする必要が ないようにすることを意味する。

その index.html のページには、ほかの HTML ファイルを参照するための <iframe> タグがいくつか書かれている。 それらのファイルもまたダウンロード される。 ファイルには、いくつかの JavaScriptファイルをリストアップした <script>セクションがある。 これらの JavaScriptファイルも、JavaScript コー ドをパースして実行できるよう、 ダウンロードされる。

以前は、JavaScript のコードを、 ウェブブラウザがパースしながらインタープ リト[逐次解釈]していた。 だが、 最近のウェブブラウザには JavaScript エンジ ンが搭載されていて、ファイルすべてを一度にではなく、必要なときに必要な分 だけコンパイルするようになっている。 これは、JIT (ジャストインタイム)コ コンパイルと呼ばれる手法だ。

Code Hidden Language.com のウェブサイトは、 インタラクティブなグラ フィックスを提供しているが、 HTML ページ自体は静的 [前もって書かれていて変 [化しない] なものだ。 サーバーは、 動的 [アクセスごとに変化する] なウェブコンテ ンツも配信できる。 クライアントから要求があったときに、 その場でHTML ファイルを作成して送り返すことができるのだ。

URL に一連のクエリー文字列が添付されていることもある。 これらは通常、 ク エスチョンマーク (?) に続き、 アンパサンド (&) で区切られた文字列だ。 サー バーはこれらも解析して解釈できる。 また、 サーバーは REST (representational state transfer)と呼ばれるURLスタイルにも対応する。 こうした仕掛けは、 サーバー上で動作するプログラムを含むため、 サーバーサイドと呼ばれる。 一方 JavaScript は主にクライアントサイドのプログラミング言語だ。 そして、 JavaScript で書かれたクライアントサイドプログラムは、サーバー上のサーバー サイドプログラムと対話することができる。

無数のウェブサイトが証明しているように、 ウェブプログラミングには驚くほ ど豊富なオプションが用意されている。 多くの処理やデータストレージがサー バーに移され、これらのサーバーはクラウドと総称されるようになった。 ユー

602

第28章 世界頭脳 603

ザーの、 より多くの個人データがクラウド上に保存されるようになると、その データを作成したりアクセスしたりするために人が使用する実際のコンピュータ の重要性は低くなる。 クラウドは、 コンピューティング体験をハードウエア中心 ではなく、 ユーザー中心にするのだ。

H・G・ウェルズやヴァネヴァー・ブッシュならインターネットについてどう 考えたか気になるはずだ。

ウェルズやブッシュは、世界中の知識や知恵によりよくアクセスできることが 不可欠であると楽観的に考えていた。 この考えに反論するのは難しい。 しかし、 このようなアクセスを提供したからといって、 文明が自動的に黄金時代に進んで いけるわけではないことも、同様に明らかだ。 人々は今、 かつてないほどの情報 量に圧倒され、 それでも何とか管理できると感じられなくなりつつある。

インターネットは多くの異なる人々、 性格、 信念、興味をサンプリングしてい るという意味で、確かに何らかの 「世界頭脳」 だ。 だがそれは、 ウェルズが願っ ていた「現実の共通の解釈」 では決してない。 本物の知識と同じくらい広まって いるのは、不安を引き起こす奇妙な科学や陰謀論の登場だ。

ウェルズならGoogle ブックス (books.google.com) のアイデアを気に入っ たと思う。これは、 異なる図書館の書籍や雑誌をスキャンしデジタル化して構築 されている。 これらの書籍の多くは、 著作権保護が消滅していて、 完全なアクセ スが可能だ。 残念ながら、 Google ブックスの制作者はカタログカードのことを 忘れてしまったようで、 利用者は検索機能に全面的に頼らざるをえない (これは 重大な欠陥だ)。この基本的な問題は、 Google ブックスで特定のものを見つけ ることをしばしば苛立たしいものにしている。

Google ブックスとほぼ全く対照的なのが、 JSTOR (www.jstor.org) である。 Journal Storage [雑誌倉庫] の略で、記事が非常に丁寧に整理・分類された学術雑 誌のコレクションだ。 JSTORは当初、 利用制限のあるサイトとしてスタートし たが、 JSTOR のコンテンツをもっと自由に利用できるようにしようと決意した プログラマが起訴され、悲劇的な自殺を遂げたという残念な事件を経て、一般の 人々も広く利用できるようになった。

伝統的な西洋音楽の楽譜を読むことができる人にとって、 IMSLP [国際楽譜ラ イブラリープロジェクト〕 (imslp.org) は、 Google ブックスの楽譜版のようなもの だ。 IMSLP は、著作権が切れてデジタル化された楽譜の膨大なリポジトリ 倉

庫] で、幸いなことに、それらはカタログ化されて、 利用価値の高い索引がつけ られている。

私たち自身のドキュメントのウェブ [網の目] を作る能力を、 ヴァネヴァー・ ブッシュとテッド・ネルソンの考えに照らしてみると、 何かが欠けているように 思える。 Google Books、 JSTOR IMSLP などのウェブサイトは、 彼らが思い 描いていたような自在なリンクにはそぐわない。 最近のワープロや表計算のアプ リケーションは、情報源へのリンクの保存を可能にしているが、 あまり柔軟な方 法とはいえない。

H・G・ウェルズが提唱した 「世界百科事典」 のコンセプトに最も近いウェブ サイトは、明らかに「ウィキペディア」 (wikipedia.org) だ。 ウィキペディアの 基本コンセプトである 「利用者が編集できる百科事典」 は、容易にカオスにな り、結果的に使い物にならないものになる可能性があったはずだ。 しかしそうは ならず、ジミー・ウェールズ (1966年生まれ) の研究熱心で良心的な指導の下 で、インターネット上で代わるもののない最も重要なウェブサイトとなった。 著書 『World Brain』 の中で、 H・G・ウェルズはこう書いている。

全人類に訴えかける 「百科事典」 は、 狭量なドグマ [教義] を認めず、同時に正 しい批判を受け入れる。 編集においては、最大限の猜疑心を持って、狭量なプ ロパガンダの絶え間ない侵入に対して守られなければならない。 百科事典は、 多くの人々が懐疑主義と呼ぶであろう特性を持つだろう。 神話は、どれほど尊 敬されていても、 より高い真理の象徴的な表現や逃避手段としてではなく、 あ くまでも神話として扱わなければならない。 希望や計画や理論は、 基本的な事 実とは区別しなければならない。 百科事典は必然的に、 国家的な誇大妄想や、 あらゆる宗派の思い込みに強く抵抗することになる。 それは、自身が最終的に 不可欠な一部となるべき世界共同体のためであり、 無関心でいることはできな い。 それが偏見と呼ばれるのなら、 世界百科事典は確実に偏見を持つことにな る。整理、比較、構築、 創造に偏見を持つことになるし、 そうせざるを得ない のだ。 それは基本的に創造的なプロジェクトである。 そして、 新しい世界の成 長を指導する主要な要因でなければならない。

これは野心的な目標であり、 ウィキペディアがこれらの要件にどれだけ近づい

604

第28章 世界頭脳

605

たかを考えると感慨深い。

私たちは、知識が単に存在するだけで世界をよりよい未来へと導けると信じて いたウェルズほど、 楽観的ではないのだろう。 「作り上げれば、手に入る」とは いうものの、それをどれほど願っても、保証されているわけではない。 人間の性 質は、めったに期待通りにはならないものだ。

それでも私たちはみな、 自分にできることをしなければならない。

索引

頻出する用語は初出あるいは 詳しく述べているページを示す。

人名

F.W. ジョーダン..

Jプレスパー・エッカート。

289

249

ア行 アーサー・W・バークス アイザック・ニュートン アラン・チューリング アリストテレス.. .249 .62 .505, 570 .61 アルフレッド・ヴェイル ヴァネヴァー・ブッシュ ヴァランタン・アユイ ウィリアム・トムソン 19 244, 590 .27 .244 ウィリアム・ヘンリー・エクルズ .289 ウォルター・ クロンカイト。 .250 ウォルター・ブラッテン .251 エイダラブレス 246, 495 エミール・ボドー .200 オーガスタ・エイダ・バイロン(エイダ・ラブレス) .246, 495

オーガスタス・ド・モルガン

.62, 247

.249

カ行 サ行

グイド・ヴァン・ロッサム. グレース・マレーホッパー

.569

.248, 566

クロードエルウッド シャノン ゴードンE・ムーア

.256

251

249

.155

. ゴットフリート ヴィルヘルム・フォン・ライブ ニッツ .62

コンラート・ツーゼ、

サミュエル・フィンリーブリース・モールス

244

ジーンシスケル

19, 83

ジェームズ・クラークマクスウェル..

.162

ジェームス・ゴスリング

ジェームズ・ワット ジミー・ウェールズ

.84

569

ジャック・キルビー

ジョージブール

ジョセフ・スワン

604

ジョン・アンブローズフレミング ジョン・バーディーン

255

.62,247

.248

ジョン・フォン・ノイマン

ジョン・モークリー

ジョン・ワイルダーテューキー

スティーブ・ジョブズ

553

ソクラテス

タナ・ハ行

61

ダグラス・エンゲルバート

ダンブリックリン...

552

チャールズ・ドジソン (ルイス・キャロル)...61

チャールズ・バベッジ

551

ティム・バーナーズ=リー

147, 245, 495

ティム・パターソン

テッド・ネルソン トーマス・エジソン

-598

550

593

-589, 604

ハーバート・ジョージ・ウェルズ

.37

ハーマン・H・ゴールドスティン

ハーマン・メルヴィル

. ジョゼフ マリー・ジャカール

ハリー・ナイキスト。

212

250

ハワード エイケン

.95 ブレンダン・アイク.

.537

244

ハンス・クリスティアン・エルステッド ブラハム・リンカーン

ヘンリーワズワースロングフェロー ボブ・フランクストン

84

.84

570

158

551

マ・ヤ・ラ・ワ行

マイケル・ファラデー +84 ムハンマド・ブンムーサー・アル=フワーリズ ミー 127 リーデ フォレスト 248 リーナス トーバルズ 557 .46 リチャードストールマン。 556 リチャード・ファインマン 581 ルイ・ダゲール、 83 ルイ・ブライユ 27 ロバート・エバート 162 ロバート・ノイス 255

ジョン・V・アタナソフ.

.38

.246

.249

索引

607

2对数 2進法.

数字

2の補数

142, 304, 317, 392

.164

274

154,354

4-to-16 デコーダー。

361

259

410.430

259

3-to-8 デコーダー

6502.

6800.

.141

.411

7400.

74151.

8-to-3 エンコーダー

154

.411

257

8進法

9の補数

10進法

134

262

259

10の補数

16進法。

A B

ADC.

ALGOL.

英文字

567

Altair 8800

74154

74182

8080

8-to-1 セレクター

355

4

124

274

534 FORTRAN.

376, 411

Alto..

F.G.H.I

552

566

418

ALU

AND..

.69

101, 117, 230

Android

AND ゲート

582

ARPANET

FPU

548

594

ANSI

API.

BASIC.

.201

ASCII.

BCD デコーダー。

567

GNU

BCD

binary digit...

GND

330

155, 158

.155, 158

C D E

bit

C#

CMOS

COBOL

CP/M

DAC.

587

413, 417

Digit.

DIP EDVAC..

ENIAC

EPROM.

C

188

GUI

555

316

HTTP

I/O.

IBM PC.

IC

IEEE

569

.124

IMSLP

569

257

256

iOS.

555

J K L M Java.......... 569 JavaScript 570 JIT.. 603 JSTOR 603 LED.. 37 Linux 557 LSB. 178, 228 MAC.. 597 546 Macintosh 553 macOS 553 memex 592 MSB 178, 218, 228 MS-DOS. 550

CPU.

258

HTML

192, 212, 506 528 570

566

534

249

249

557

553

413

545

NO.P.Q

NAND .116 NAND ゲート 116, 117, 230 NIC 597

608

113

NOR

NOR ゲート NOT

113, 117

OR

.69

69

OR ゲート

Overflow

PARC.

106. 117

R・S・T・U・W・X

552

Pascal.

PROM

Python.

269

QED

ROM.

357, 373

TTL

.343

568

545

569 UNIVAC

349

QR コード

RAM.

SOS コード

TRI

257

UI

Unicode.

175

548

UNIX

216

250

UTF

Xerox

カタカナ・漢字

アース...

アキュムレータ

Windows

ア行

.54

.380

XOR ゲート

アキュムレーター

アセンブリ言語命令

アドレスバス

.556

438

442

アプリケーションプログラミングインターフェース

451

548

アメリカ手話

アライメントパターン

177

イネーブル (信号)、

14

458

インクリメント...

366

317

インクリメンタデクリメンタ

インタープリト

.602

インタラクティブ [対話的]

.545

インバーター

107

英国放送境界 (BBC)

エクサバイト

エクリチュール・ノクターン [夜間書法].

.28

16

.372

エスケープコード

エッチング

エニアック

エミッター

エラー

.17

ートランスミッションエラー.

エンディアン

エンディアン

オシレーター[発振器]

オペコード

オペランド (破演算子]

366

219

555

233

552

539

オペレーティングシステム オンオフ

カ行

階差機関

解析機関

カウンター

.251, 347

.31

218

.47

カウンター回路。

.31

ディケードカウンター

.394

リップルカウンター

.289

拡張 ASCII 文字セット

拡張 BCD 交換コード

.35

255

.63

320

加算器。

加算機

カスケード接続

オペレーター[演算子]。

カプセル化

246

246

255

関数。

310

214

.148

.284

210

.267

225

397

.98

.517,564

関数表

234

間接アドレッシング

キーボードハンドラー

290

439

機械コード (マシンコード)

ギガバイト

543

記数法

63

.417

キャリー付き加算・減算

キロビット

372

組み込み関数

組み込みシステム

124

位取り

418

373

グランド

結合法則 [結合律]

578

410

127

決定問題..

ケベック 手話

.54

.63

505

14

ゲレオタイプ写真 [銀板写真]

索引

216

609

交換法則 [交換律]

.63

高水準言語

413

コード

コール

.83

564

コマンドプロセッサ

コモン [共有部]

ダブルバイト文字セット

短格

テイクオーバー

低水準言語:

ディスクオペレーティングシステム

.543 ディスプレイアダプター

データ

データバス

データバス

タ行

374,381

45

564

550

517

528

コレクター

...51

コンパイル

251.347

413

451

コンピュータ

コンピュータグラフィックス,

602

379

530

デシマル

デバイス独立性

241

コンピュータサイエンス... 581 サ行 サイクル 285 サインフラグ [符号フラグ] 433 サブルーチン 517 サンプリングレート 536 自動累積加算器. 388 シフトコード 34, 200 ジャカード織機 -246 ジャンプ。 497 無条件ジャンプ 499 周波数. 286 周波数偏移調 (FSK) 595 常閉 (ノーマリークローズ) 出力 .106 周辺機器 .527 出力デバイス. .94 常開 (ノーマリーオープン) 出力 .106 シリコンバレー 253 シンタックス [構文]. 565 真理値表.. 290 スイッチ .38 スタック 521 トランジスタ ステートメント 573 スワップ 529 制御信号。 388, 463 正極 [カソード] 41 静電気 40 セクター 539 絕禄体 43 ゼロ (0) 124 ゼロ電位点 56 遷移 (正の、負の~) 300 全加算器 236 全二重。 595 操作コード 397 ソースコードファイル 562

124

デバッグ..

548

581

デュアルインラインパッケージ

テレグラフ [電信]

テレタイプライター。

電圧

200

電荷。

電気

84

45

256

電気機械式コンピュータ

電子。

電磁気現象

40

電子式コンピュータ。

電子論:

40

244

電信.

40

249

84

伝播時間

電流

電源

ドモルガンの法則

導体、

ドットマトリクス

トポロジー [配線形態]

120

トライステートバッファ [3状態バッファ].

337

ドライバー

347

365

330

トランジスタトランジスタロジック

ナハ行 ニーモニック 入力デバイス 94 ネットワーク 92 ネットワークインターフェースコントローラ (NIC). 597 ノーブレークスペース [改行禁止スペース] 215 パース 562, 601 ハードディスク 539 ハーバード・マークし 148 244 排他的 OR ゲート 233 バイト 186 バイトオーダーマーク 218 バイナリー 29 バイナリーデジット 155 バイナリーポイント 582

ダイオードマトリクス

大容量記憶装置..

414

43

596

343

84

ハイパーリンク

ハイバイト

発行ダイオード (LED)

バリティ

242

.37

.172

バルス符号変調

半加算器

536

パンチカード

235

反転

半導体

ピクセル

ビットマップ

211 メガバイト

.251

ビット保持

107, 113, 270 メガビット

527

ファインダパターン

534

.291

フィードバック

.177

287

ブール代数

インターセクション [交わり]

プーリアンテスト [真偽テスト]

.63

64

.70

ブール式 [真偽を表現する式]

―ユニオン [和]

フォン・ノイマンアーキテクチャ

.67

負極 [アノード]

.64

複素数計算機

復調 [デモジュレーション]

符号付き/なし

マ・ヤ・ラ・ワ行

250 ユニバーサルプロダクトコード [UPC]

41

.595

符号ビット

浮動小数点数

278

275

浮動小数点演算装置

ブランチ

フリップフロップ

R-S フリップフロップ

レベルトリガー型Dタイプフリップフロップ

.453, 467

プロトコル

分周器

並列 [パラレル]

マスクパターン

.308

ベース

ヘッダー

ベル電話研究所

マイクロプロセッサ.

マルチプレクシング [多重化].

命令コード

410

179

337

メッシュ []

397.

371

373

メディアアクセスコントロール (MAC)

メモリー

597

597

8ビットメモリー

351

メモリーセル

メモリーマップド I/O.

モールスコード、

352

.360

.531

コードの数(ドットとダッシュの数)

.12

樹形図 (モールスコードの解読)、 モジュロチェックキャラクター。

564

.587

497

296, 312

24

23

ユーザーインターフェース..

243

ラッチ

173

ラベル..

296, 351

289

168

ランレングスエンコーディング

離散数学

リッチテキスト。

リップルキャリー

289

リレー

プレーンテキスト

ブログラムカウンター

ブログラム内蔵方式

フロッピーディスク

210 レジスター

250

538

累積加算器.

分配法則 分配律]

ルーター

ループ

599

.304

.63

ヘキサデシマル

.43

251, 347

.250

变数

188

216

変調 モジュレーション)

595

ボーコード

ポータブル [移植性がある」

補數

.200

無限ループ。

563

ポテンシャル

548

586

冷極陰管ディスプレイ

レジスターアレイ

ボルテージ 電

495

レジスターペア。

535

ローバイト

210

ロールオーバー。

.89

ロジックゲート [論理ゲート]

597

498

.329

.437

.564

449

242

504

論理 AND

317

論理 OR

論理ゲート

論理表・

ワイヤー [電線]

ロー付き算

454

.91

.78

91.95

78

ワット.

割り込み駆動型 I/O

290

44

38

56

46

533

418

259

-

610

著者について

チャールズ・ペゾルド (Charles Petzold)

35年以上にわたりプログラミングとコンピュータについて書き続けている。 12 冊を超えるプログラミングの入門書や『チューリングを読む コンピュータサイ エンスの金字塔を楽しもう』(日経BP、 2012年) などがある。 歴史家で小説家 の妻ディアドラ シノット (Deirdre Sinnott) およびハニーとハイディという 名の2匹の猫と一緒にニューヨーク市に住む。

ウェブサイト: www.charlespetzold.com

訳者について

酒匂寛 (さこうひろし)

東京大学農学部畜産獣医学科卒。 1980年代初頭にソフトウエア業界に就職した ことから、ソフトウエア開発とコンサルティングの道を歩む。 大規模な事務処理 系のソフトウエアや、 組み込み系と呼ばれる人の目に直接触れないソフトウエア を多く手掛けてきた。 1990年代までは開発ツールとオブジェクト指向、 21世紀 になってからはこれに加えて形式手法を中心に扱ってきた。 主なテーマは開発に おける情報の整理と共有、 検証と正しさの担保。 最近の興味は専門的作業に対す る生成 AIの活用。 並行して専門書籍の翻訳を行っている。

主な著書は 『課題 仕様・設計 不幸なシステム開発を救うシンプルな法則』 (イ ンプレス、2003年)、 主な訳書は 『オブジェクト指向入門 第2版 原則コンセ プト』 (翔泳社、2007年)、 『ソフトウェア要求と仕様 実践、 原理 偏見の辞典 (エスアイビーアクセス、 2014年)、 『作ることで学ぶ Maker を育てる新しい教 育のメソッド』 (オライリージャパン、2015年)、 『ライフロング・キンダーガー テン 創造的思考力を育む4つの原則』 (日経BP、2018年)、 『教養としてのコン ピューターサイエンス講義 第2版 今こそ知っておくべき 「デジタル世界」の基 礎知識』 (同、2022年) など。

611

ハイパーリンク

242

ハイバイト

発行ダイオード (LED)

.37

パリティ

.172

バルス符号変調

536

半加算器..

パンチカード

反転。

235

半導体。

マ・ヤ・ラ・ワ行

211 メガバイト

ピクセル

ビットマップ

ビット保持

251

527

534

291

107, 113, 270 メガビット

.177

ファインダパターン。

フィードバック

287

ブール代数

.63

インターセクション [交わり]..

ープーリアンテスト [真偽テスト].

..64

.70

ブール式 [真偽を表現する式]

――ユニオン [和]..

フォン・ノイマンアーキテクチャ

.67

負極 [アノード]

.64

複素数計算機

.250 ユニバーサルプロダクトコード [UPC]

.41

復調 [デモジュレーション ]

符号付き/なし

.373

.243

.371

.595

符号ビット

浮動小数点数。

278

275

浮動小数点演算装置。

ブランチ

フリップフロップ

-R-S フリップフロップ

レベルトリガー型Dタイプフリップフロップ

プレーンテキスト

プログラムカウンター

.337

.597

453, 467

プログラム内蔵方式。

フロッピーディスク

.250

プロトコル

分周器

分配法則 [分配律]

並列 [パラレル]

ベース

ヘキサデシマル。

ヘッダー

ベル電話研究所

変数。

ボーコード

ポータブル [移植性がある]

マイクロプロセッサ.

マスクパターン......

マルチプレクシング [多重化].

補數

ポテンシャル

.179

命令コード

.410

397.

メッシュ []..

メディアアクセスコントロール (MAC) メモリー...

597

-8ビットメモリー

.351

-

メモリーセル

.352

メモリーマップドI/O

モールスコード.......

.360

.531

コードの数(ドットとダッシュの数).

一樹形図 (モールスコードの解読). モジュロチェックキャラクター。

.24

ユーザーインターフェース...

23

173

ラッチ

ラベル

548

.168.

.296, 351

.564

.587

.497

.296, 312

ランレングスエンコーディング

289

289

離散数学..

リッチテキスト..

12

リップルキャリー

.538

リレー

.504

.535

累積加算器

ルーター

.586

ループ.........

.89

.304

.210 レジスター

.437

.599

.308

.63

.43

無限ループ..

冷極陰管ディスプレイ

レジスターアレイ

レジスターペア

210

.259

ローバイト

597

495

.498

ロールオーバー

.329

449

454

242

ロジックゲート [論理ゲート]

.251, 347

.188

216

.250

564

595

200

論理 AND

317

論理 OR.

論理ゲート

563

論理表.

ワイヤー [電線]

91.95

変調 [モジュレーション ] .

ワット

ボルテージ [電圧]

ボロー付き減算

.91

.78

.78

290

割り込み駆動型 I/O

.38

44

46

.533

.56

418

610

| 611

著者について

チャールズ・ペゾルド (Charles Petzold)

35年以上にわたりプログラミングとコンピュータについて書き続けている。 12 冊を超えるプログラミングの入門書や『チューリングを読む コンピュータサイ エンスの金字塔を楽しもう』(日経BP、2012年) などがある。 歴史家で小説家 の妻ディアドラ シノット (Deirdre Sinnott) およびハニーとハイディという 名の2匹の猫と一緒にニューヨーク市に住む。

ウェブサイト: www.charlespetzold.com

訳者について

酒匂寛 (さこうひろし)

東京大学農学部畜産獣医学科卒。 1980年代初頭にソフトウエア業界に就職した ことから、ソフトウエア開発とコンサルティングの道を歩む。 大規模な事務処理 系のソフトウエアや、 組み込み系と呼ばれる人の目に直接触れないソフトウエア を多く手掛けてきた。 1990年代までは開発ツールとオブジェクト指向、 21世紀 になってからはこれに加えて形式手法を中心に扱ってきた。 主なテーマは開発に おける情報の整理と共有、 検証と正しさの担保。 最近の興味は専門的作業に対す る生成 AIの活用。 並行して専門書籍の翻訳を行っている。

主な著書は 『課題・仕様・設計 不幸なシステム開発を救うシンプルな法則』 (イ ンプレス、2003年)、 主な訳書は『オブジェクト指向入門 第2版 原則・コンセ プト』 (翔泳社、2007年)、 『ソフトウェア要求と仕様 実践、 原理、 偏見の辞典』 (エスアイビーアクセス、2014年)、 『作ることで学ぶ Maker を育てる新しい教 育のメソッド』 (オライリージャパン、2015年)、『ライフロング・キンダーガー テン 創造的思考力を育む4つの原則』 (日経BP、2018年)、 『教養としてのコン ピューターサイエンス講義 第2版 今こそ知っておくべき 「デジタル世界」の基 礎知識』 (同、2022年) など。

CODE コードから見たコンピュータのからくり 第2版

2024年2月26日 第1版第1刷発行

著者 チャールズ・ベゾルド 記者 酒匂 寛 発行者 中川 ヒロミ 発行 株式会社日経BP 発売 株式会社日経BPマーケティング 制作 福集 〒105-8308 東京都港区虎ノ門4-3-12 坂本 充宏 (クニメディア株式会社) メディア株式会社 田島 篤 印刷 製本 図書印刷株式会社

本書の無断複写・複製(コピー等)は著作権法上の例外を除き、禁じられています。 購入者以外の第三者による電子データ化および電子書籍化は、私的使用を含め一切認められて おりません。 本文中に記載のある社名および製品名は、それぞれの会社の登録商標または商標です。 本文中では および を明記しておりません。 本書に関するお問い合わせ、ご連絡は下記にて承ります。

ntps://nkbp.jp/booksQA SBN 978-4-296-08024-3 Printed in Japan

