O'REILLY オライリー・ジャパン

バイブコーディングを 超えて

AI時代を生き抜く開発者の未来

AIと協働する

新しい開発の形を探る

急速に進化する世界で成長し続ける開発者になるために



バイブコーディングを超えて

AI時代を生き抜く開発者の未来

Addy Osmani

佐藤直生沢

O'REILLY オライリー・ジャパン

本文中の製品名は、一般に各社の登録商標、商標、または商品名です。 本文中では、 ®, マークは省略しています。

Beyond Vibe Coding From Coder to AI-Era Developer

Addy Osmani

O'REILLYⓇ

©2025 O'Reilly Japan, Inc. Authorized Japanese translation of the English edition of "Beyond Vibe Coding" ©2025 Addy Osmani. This translation is published and sold by permission of O'Reilly Media, Inc., the owner of all rights to publish and sell the same.

本書は、株式会社オライリー・ジャパンがO'Reilly Media, Inc. の許諾に基づき翻訳したものです。 日本語版についての権利は、 株式会社オライリー・ジャパンが保有します。

日本語版の内容について、株式会社オライリー・ジャパンは最大限の努力をもって正確を期していますが、本書の内容に基 づく運用結果については責任を負いかねますので、ご了承ください。

日本の読者のみなさんへ

「Beyond Vibe Coding」 が日本の読者のために翻訳されることは、私にとって大きな名誉です。 日本のソフトウェアエンジニアリングコミュニティの品質へのこだわり、 細部への注意、そして厳 格な基準を保ちながら新しいツールを積極的に取り入れる姿勢に、常に深い感銘を受けてきました。 日本を訪れ、 開発者の方々とお話しするたびにそのことを実感しています。 まさにこれらの資質こそ が、「バイブコーディング」 を超えて、本番環境対応のAI支援エンジニアリングに進むために必要と されるものです。

日本は長らく、精緻な 「ものづくり」から、継続的改善を追求する 「カイゼン」の哲学まで、工学と 人の技を思慮深く融合させる先駆者でした。 その原則は、 「AI支援開発が最も力を発揮するのは、 人 の判断を置き換える時ではなく、 それを増幅する時だ」という本書の中心的なメッセージと深く共鳴 します。

AIの能力が進化し続ける中で、 世界中の開発者が同じ根本的な問いに直面しています。 こういっ たツールをどう効果的に活用しますか? 優れたソフトウェアを特徴づける職人技をいかに維持しま すか? 速度を追求するあまり、 信頼性を犠牲にしないためにはどうすべきでしょうか?

本書が、こうした問いに向き合う日本の開発者にとって実践的な指針となることを願っています。 AI支援による最初のプロトタイプを構築する場合でも、 AIと協働してエンタープライズシステムを 設計する場合でも、ここで示す原則は、ユーザーが当然期待する品質を守りながら、 より賢く仕事 を進めるための助けとなるはずです。

丁寧な翻訳をしてくださった佐藤直生さん、 そして本書を新しい読者へ届けてくださる赤池涼子 さんとオライリージャパンのチームに、心からの感謝を捧げます。

アディオスマニ 2025年12月



はじめに

私たちは今、ソフトウェアの作り方における重大な転換の中にいます。 プロフェッショナルな (A と協働してソフトウェアを作成する) 「バイブコーディング」は、開発者をコード職人からプロダクト のビジョナリー(先見の明のある人) やオーケストレーター (調整役、 統括者) に変えつつあります。

バイブコーディングとは、 AIの能力を活用してコーディングの重労働に対処することであり、開 発者はアイデアや設計、高レベルの問題解決により集中できるようになります。 アンドレイ・カルパ シーが指摘した (https://oreil.ly/Ki6iJ) *「ように、これは「コードの存在すら意識せず」 単に構築 する、 つまり、必要なものを説明し、 AIに実装の詳細を埋めてもらうようなものです。 これによっ て、 生産性が桁違いに向上し、 神話的な 「10倍エンジニア」 が現実に100倍になる可能性があります (https://oreil.ly/8UGID)。

本書の対象者

本書は3つの主な読者に向けて書かれています。 まず、自分の影響を倍増させたいと考えている、 経験豊富な開発者やエンジニアリングのリーダーです。 もしあなたが長年コーディングをしていて、 繰り返しのタスクの重みを感じているなら、 本書は、 あなたの役割をアーキテクトとストラテジスト に引き上げながら、ありふれたタスクをAIに委ねる方法を教えます。 これまでのキャリアで培って きた品質基準を犠牲にすることなく、 より速く構築する方法を学べます。

第二に、 本書はコードを目的そのものではなく、 目的を達成するための手段と考えるプロダクト志 向のエンジニアに役立ちます。 構想を持ってからその構想を実装するまでのギャップに不満を感じ ているなら バイブコーディングはそのギャップを劇的に圧縮できます。 従来のアプローチでは数ヶ 月かかっていたようなプロダクトのプロトタイピング、イテレーション、リリースを素早く行う方法 がわかるでしょう。

AIツールについて私が見つけた、最も直感に反することがあります。 それは、 AIツールは、初 心者よりも経験豊富な開発者にとって役立つということです。 これは退化しているように見えます。

1 注:アンドレイ・カルパシーは計算機科学者でありOpenAIの共同設立者。 テスラのAIディレクターを務めたこともあり

ます。

はじめに

|

AIはコーディングを民主化してくれるのでしょうか?

現実には、 AIは、 あなたのチームに非常に熱心なジュニア開発者がいるようなものです。 AIはす ぐにコードを書けますが、 常に監督と修正が必要です。 AIを知れば知るほど、 より良く導くことが できます。

これは、私が「知識のパラドックス」と呼んでいるものを引き起こします。 シニアエンジニア/開 発者は、すでにやり方を知っていることを加速させるためにAIを使いますが、ジュニアは「何」をす べきかを学ぶためにAIを使おうとし、その結果は劇的に異なります。

シニアエンジニアが次のことを行うためにAIを使うのを、 私は見てきました。

● すでに理解しているアイデアを素早くプロトタイピングする

基本的な実装を生成し、それを改良する

・既知の問題に対する代替アプローチを探る

・定型コーディングタスクを自動化する

一方、ジュニアは往々にして次のようなことをします。

間違った解決策や時代遅れの解決策を受け入れる

● 重要なセキュリティやパフォーマンスの考慮事項

AIが生成したコードのデバッグに苦労する

• 完全に理解していない脆弱なシステムを構築する

を見落とす

第三に、 本書は、AIがチームやプロセスに及ぼす影響に取り組むエンジニアリングマネージャー やCTOを対象としています。 かつてはチーム全体が必要だった作業を1人のエンジニアが行える時 代に、どのようにチームを構成し、人材を評価し、 コード品質を維持するかについての知見を得る ことができます。 本書の戦略は、エンジニアリング文化を維持しながら移行を乗り切るのに役立つ でしょう。

本書は、プログラミングの初心者向けガイドではありません。 AIによってコーディングがより身 近になったとはいえ、AIを効果的に使いこなすには、依然として経験から来る判断力が必要です。 本書を、従来のプログラミングを超えて、ソフトウェア作成の新しいパラダイムを受け入れる準備が できている人向けの上級トレーニングだと考えてください。

期待すること

本書は、開発者の役割がどのように、キーボードを使ったプログラミングからプロダクトエンジニ アリングに進化しているかを探ります。 これは、AIを導くために人の判断を用いることを意味して おり、品質、 アーキテクチャ、 ユーザーニーズが満たされるようにします。 機能するプログラムを れたプロダクトに変える創造性、システム思考、 そして共感を提供するのは、依然として私たちで す。AIは、私たちに取って代わるものではなく、 (賢く使いこなせば) 私たちを増幅させるものなの

viii

です。

はじめに

| ix

「Ⅰ部 基礎」では、バイブコーディングが得意とする領域を特定します。 新しいプロダクトの立 ち上げ、プロトタイピング、 標準的なCRUDアプリや統合コードの量産など、速度とバターン一致 が深い独創性に勝るすべての領域です。 逆に、AIに頼ることに慎重であり続けなければならない点 にも目を向けます。 真に複雑な、 低レベルの、あるいは新しいアルゴリズムの場合、 AIはつまずく 可能性があります。AIの現在の限界を認識することで、挫折や失敗を防げます。 人の創意工夫にし か成し遂げられないことが、まだたくさんあります。

人の要素は、依然として要です。 私たちは、アーキテクチャが健全であることを確認し、扱いに くいバグをデバッグし、 「動作する」以上のコード品質を判断します。 これらは、AIにはできないこ とです。 ソフトウェアが動作するだけでなく、 「ユーザーにとって」 意味のある形で動作するように することは、私たち次第なのです。 要するに、 開発者は、 AI出力を常に実世界のニーズや高い基準 に合わせるようにする、 AI出力のキュレーター、編集者になるのです。

「I部 AIコーディングの実践」 では、 バイブコーディングの実践的な側面について見ていきます。 新しいワークフローを受け入れることが、極めて重要です。 「修正」 ではなく 「進める」といったテク ニックは、 行き詰まらないようにすることを思い出させています。 コードの再生成が、コードのデ バッグより速い場合もあるのです。 並列プロンプティングを使えば、一度に複数の角度から問題を 解決できます。 素早い反復と最終的な改良のバランスをとり、持続不可能な混乱を蓄積しないよう にしなければなりません。 AIコードのモジュール化、徹底的なテスト、 反復的な改良といったベス トプラクティスは、高速な開発にもかかわらずコードベースをクリーンで堅牢な状態に保つのに役立 ちます。

プロジェクトの規模が大きくなるにつれて、私たちは、加速度的に流入するコードと潜在的な技 術的負債を管理しなければなりません。 AIはあなたのリポジトリをコードで溢れさせる可能性があ ります。 規律、優れたエンジニアリングプラクティス (そして、AI支援のリファクタリング)だけ が、リポジトリを保守可能な状態を保てます。 人材面では、 AIツールを使いこなすエンジニアを探 用、調練し、適応性とシステム設計スキルを重視します。 そして、長期保守のためにプロダクトを 固めるときや、慎重さがベロシティ (開発速度)に勝る重要なシステムを扱うときなど、従来のモー ドに戻るタイミングを見極めるのです。

「Ⅲ部 信頼と自律性」 では、セキュリティと信頼性、 倫理、そして今日のバイブコーディングを 可能にするツールの数々を取り上げます。 Anthropic, Google Gemini, OpenAI のモデルを統合 し、コードベース全体を理解し、あらゆる場面で支援する、 Cursor や WindsurfのようなAI拡張 IDEです。 異なるタスクに Claudeのどのバリエーションを使い、一般的なQ&A に ChatGPTを使 うといった)どのソールとモデルを適用するかを知ることは、 新しい開発者のスキルセットの一部で す。 対話型の編集にはCursor. コンテキストの多いタスクにはWindsurf、 ブレインストーミング やトラブルシューティングにはチャットインターフェイスなど、それぞれに強みがあります。

未来に目を向けると、ソフトウェアの構築方法はさらに抽象化され (GUIやより高度な人力によ

| はじめに

る 「バイプ設計」)、 AIがよりオーダーメイドのコードを生成するにつれて汎用ライブラリへの依存 度は低下し、さらにはAIのフィードバックループに基づいて自ら進化するソフトウェアも登場する と予想されます。 このような未来では、 コーディングの力ずくの障壁が非常に低くなるため、 ソフト ウェアにおける成功は、人の創造性、流通の知識、 ネットワーク効果を活用する能力に大きく依存 することになるでしょう。 会話型インターフェイスからアダプティブUI、 そしてそれ以上に至るま で、AIの普及によって新たなユーザー体験 (UX) のパラダイムが生まれるかもしれません。

これらすべてで、 1つのテーマが際立っています。 それは、 人とAIの強みの融合です。 どちらか 一方だけでは、両方が一緒になったときほど強力ではありません。 AIは、速度、 幅広い知識、不断 の実行をもたらします。 人は、 方向性、 理解の深さ、価値観をもたらします。 未来の最適なワーク フローは 「共生」 です。 熟練した職人が、 どんな道具や参考資料でもすぐに手に入れることができる 超能力を持った見習いとペアを組むようなものだと考えてください。 真に優れたものを作るには、職 人の専門知識が不可欠であることに変わりはありません。

これを読み進めている開発者のみなさん、 今こそこういったツールやパラダイムを受け入れる時 です。 本書は、次のプロジェクトでAIコーディングアシスタントを試し、AIが問題の一部を解決で きるように問題を分解することを実践し、プロンプトを作成し結果をキュレーションするスキルを養 うことを勧めます。 また、 本書は、 あなた自身の価値を高めるもの、つまりシステムを設計し、ユー ザーに共感し、ソフトウェアを現実に合わせる判断を下す能力を強化するよう促します。

本書の表記法

本書では次の表記法を使います。

ゴシック (サンプル) 新しい用語を示す。

等幅 (sample)

プログラムリストに使うほか、本文中でも変数、 関数、 データ型 環境変数、文、 キーワードな どのプログラムの要素を表すために使う。

一般的な注意を表す。 注釈を表す。

X

はじめに

|

オライリー学習プラットフォーム

オライリーはフォーチュン100のうち60社以上から信頼されています。 オライリー学習ブラット フォームには、6万冊以上の書籍と3万時間以上の動画が用意されています。 さらに、業界エキス パートによるライブイベント、インタラクティブなシナリオとサンドボックスを使った実践的な学習、 公式認定試験対策資料など、 多様なコンテンツを提供しています。

https://www.oreilly.co.jp/online-learning/

また以下のページでは、 オライリー学習プラットフォームに関するよくある質問とその回答を紹介 しています。

https://www.oreilly.co.jp/online-learning/learning-platform-faq.html

連絡先

本書に関するコメントや質問については下記にお送りください。

株式会社オライリージャパン 電子メール japan@oreilly.co.jp

本書には、 正誤表、 追加情報等が掲載されたWebページが用意されています。

https://oreil.ly/BeyondVibeCoding (英語)

https://www.oreilly.co.jp/books/9784814401420 (日本語)

本講座、カンファレンス、ニュースの詳細については、当社のWebサイト (https://www. oreilly.com) を参照してください。

その他にもさまざまなコンテンツが用意されています。

LinkedIn

https://www.linkedin.com/company/oreilly/

YouTube

https://www.youtube.com/oreillymedia

xi



❘ xiii

目次

日本の読者のみなさんへ はじめに

Ⅰ部 基礎

1章 序論 : バイブコーディングとは何か?

vii

1.1 AIコーディングの範囲: バイブコーディングからAI支援エンジニアリングまで 1.1.1 バイブコーディングのアプローチ 会話によるコーディング 1.1.2 AI 支援エンジニアリングのアプローチ AIパートナーとの構造・ 1.1.3 異なる考え方、 異なる期待・ 7 10 1.1.4 幅広い範囲の中で自分の位置を見つける 12

3

1.2 コードの行を超える 意図を持ったプログラミング

1.2.1 プロンプトの台頭 指示から説明へ

13

1.2.2 どのように動作するか: 反復サイクルとコード生成におけるAIの役割 1.3 生産性、 近づきやすさ、プログラミングの本質の変化

14

14

17

1.4 ツールを垣間見る 新しいエコシステム 19 1.4.1 VSCode + GitHub Copilot Microsoftの統合AI開発プラットフォーム 1.4.2 VSCode + Cline: オープンソースの自律型コーディングエージェント 1.4.3 Cursor: AI駆動コードエディター 20 21 22 1.4.4 Windsurf: 完全なコードベースインデックスを備えたAI駆動IDE･･ 24

1.5 AI モデル:コード生成の状況

1.5.1 モデルのカテゴリーを理解する

26

1.5.2 タスクに適したモデルを選択する

1.5.3 どのモデルでも使える実践的なヒント

27

1.6 主なモデル

26

27

28

xiv | 目次

1.6.1 Google Gemini マルチモーダルコーディングの強力なモデル 1.6.2 Claude: 推論の名人

1.6.3 ChatGPT: 多用途のコーディングコンパニオン

1.7 ニーズに合ったモデルを選択する

1.8 バイブコーディングの利点と限界 微妙に異なる見解・ 1.8.1 バイブコーディングの理想的なユースケース

1.8.2 AIがまだ苦労している点

1.9 まとめと次の一歩

2章 プロンプトの芸術 : AIと効果的にコミュニケーションする

2.1 プロンプトエンジニアリングの基礎

2.2 具体性と明確さ 伝わるプロンプトを書く

2.4 2つのプロンプトを比較する

2.4.1 悪いプロンプト

2.4.2 改善されたプロンプト

29

29

2.3 反復的な改良 AIとのフィードバックループ

31

35

41

39

2.5 プロンプトのテクニック 効果的なコミュニケーションのためのツールボックス 2.5.1 ゼロショットプロンプティング

2.5.2 ワンショットプロンプティングとFew-Shot プロンプティング

2.5.3 思考の連鎖 (CoT) プロンプティング

2.5.4 役割プロンプティング

2.5.5 コンテキストに応じたプロンプティング･

2.5.6 メタプロンプティング・

2.5.7 自己一貫性 (複数の出力と多数決)

2.5.8 ReAct (Reason + Act) プロンプト

2.6 高度なプロンプティング2.6.1 モデルの限界を知る 62 63 2.6.2 ステートフルな会話とワンショットプロンプティングとの比較 2.6.3 よくあるプロンプトのアンチパターンと、それを避ける方法

2.7 まとめと次の一歩

........ 59

テクニックを組み合わせ、 複雑さに対処する

Ⅱ部 AI コーディングの実践

70% 問題: 実際に動作するAI支援ワークフロー

3.1 開発者は実際にどのようにAIを使っているか

57

66

58

30

53

48

31

49

28

50

51

55

69

51

56

42

45

61

3章

43

49

71

目次 | xv

72

3.1.1 よくある失敗パターン

3.1.2 実際に動作するもの 実践的なワークフローのパターン。

78

3.2 バイブコーディングの黄金律

3.3 まとめと次の一歩

74

80

4章 70%を超えて: 人の貢献を最大化する

4.1 シニアエンジニアと開発者: AIの経験を活かす 4.1.1 アーキテクトになり、 編集長になる

4.3 ジュニア開発者: AIとともに成長する

4.3.4 保守性の目を養う

4.3.7 コミュニケーションと協働

83

83

4.1.2 大きなイニシアチブの 「力を増強させるもの」として、 AIを使う 4.1.3 指導し、基準を設定する

84

84

4.1.4 ドメインへの精通と先見性を養い続ける

4.1.5 ソフトスキルとリーダーシップを磨く

4.2 ミドルエンジニア: 適応と特化

4.2.1 システム統合と境界の管理を学ぶ

4.2.2 ドメインの専門知識を築き上げる

4.2.3 パフォーマンス最適化とDevOpsを習得する 4.2.4 コードレビューと品質保証に注力する

4.2.5 システム思考を学ぶ

4.2.6 適応力を持ち、 学び続ける

4.2.7 機能横断的なコミュニケーションが得意になる

4.2.8 システム設計とアーキテクチャを学ぶ・

4.2.9 AI を使う!

4.2.10 UI/UX デザインに挑む・

90

4.3.1 基礎を学ぶ: 「なぜ」を省略しない

4.4 まとめと次の一歩

91

4.3.2 AIの安全網なしで問題解決とデバッグを実践する 4.3.3 テストと検証に集中する

93

93

93

4.3.5 プロンプティングとツールのスキルを (賢く)養う

94

4.3.6 フィードバックと指導を求める

4.3.8 考え方を変える 消費から作成へ

95

95

96

96

5章 生成されたコードを理解する レビュー、 改良、所有

97

5.1 意図から実装へ AIの解釈を理解する・・ 5.2 「多数派」の問題 「最も一般的」 は 「最も適切」を意味しない 99 100

99

:

xvi | 目次

5.3 コードの可読性と構造: パターンと潜在的な問題点

5.4 デバッグ戦略エラーの発見と修正

5.5 保守性のためのリファクタリング AIコードをあなたのコードにする 5.6 テストの重要性:単体テスト、 統合テスト、エンドツーエンドテスト 105 106

5.7 まとめと次の一歩

107

6章 AI駆動プロトタイピングツールとテクニック

101

6.1 AIアシスタントによる素早いプロトタイピング

6.2 AIプロトタイピングツール

7.1 プロジェクトをセットアップする: AIによるスキャフォールディング 7.1.1 AI を使ったフロントエンド開発パターン 7.1.2 AIを使ったバックエンド/API開発パターン 123 126 128

7.2 データベースの設計と統合・

103

6.3 コンセプトからプロトタイプへ 反復的な改良

6.6 まとめと次の一歩

109

109

111

6.4 本番に向けてプロトタイプを進化させる

6.5 AIプロトタイピングの課題に取り組む・・

112

115

7章 AIでウェブアプリケーションを構築する

119

7.2.1 ORM を使う

7.2.2 データベースクエリ

7.2.3 AIが生成したクエリを確認する

7.3 フルスタックの統合 フロントエンドとバックエンドの融合 7.3.1 フロントエンドとバックエンドの契約を合わせる 7.3.2 AI を使ったリアルタイムの協働・

7.4 AI生成ウェブアプリケーションのテストと妥当性確認 7.5 AIが構築したウェブプロジェクトの成功例 139 141

7.6 まとめと次の一歩

Ⅲ部 信頼と自律性

セキュリティ、 保守性、信頼性

8.1 AIが生成するコードに共通するセキュリティ脆弱性・

133

8.1.1 不適切な認証認可

147

132

151

133

134

135

135

136

143

147

120

123

8章

目次 | xvii

153

8.1.2 パッケージ管理の問題

8.2 セキュリティ監査

8.2.1 自動セキュリティスキャナーを活用する

8.2.2 別のAIをレビュアーとして使う

154

8.2.3 セキュリティチェックリストを使って人によるコードレビューを行う

8.2.4 ペネトレーションテストとファジングを行う

154

154

155

155

8.2.5 セキュリティに焦点を当てた単体テストを追加する

8.2.6 8.2.7 ロギングの最適化 トレーニングカット

156

オフを補う更新を提供する

8.2.8 セキュリティに重点を置いた、更新されたモデルやツールを使う 8.2.9 コンテキストにおける警告に注意を払う

156

157

157

8.2.10 速度を落とす

8.3 AI生成システムのための効果的なテストフレームワークの構築

8.4 パフォーマンス最適化・

158

8.5 AI駆動コードベースにおける保守性の確保

8.5.1 プロンプトの作成中

8.5.2 コード出力を扱う

158

158.

8.5.3 フォローアップ

163

8.6 コードレビュー戦略・

166

166

8.7 信頼できるデプロイのためのベストプラクティス

8.7.1 デプロイ前とデプロイ中･･

8.7.2 継続的なベストプラクティス

8.8 まとめと次の一歩

171

173

173

177

176

9章 バイブコーディングの倫理的課題

9.1 知的財産に関する考慮事項・・

168.

169

9.1.1 疑わしい出力を受け取った場合の対処法・

9.1.2 グレーゾーン

179

179

9.2 透明性と帰属表示

9.4 責任あるAI利用のための黄金律・

183

9.3 バイアスと公平性

184

9.5 まとめと次の一歩

185

186

189

194

10章 自律型バックグラウンドコーディングエージェント

10.1 コパイロット型から自律型エージェントへ: バックグラウンドコーディングエージェントとは何か? 195

195

xviii | 目次

10.2 自律型コーディングエージェントはどのように動作するか?

10.2.1 計画 197 10.2.2 実行 198. 10.2.3 検証する 198 10.2.4 レポート 199

10.3 バックグラウンドエージェントはIDEAIアシスタントと比較してどうなのか?

10.4 複数のAIモデルを組み合わせて強みを最大化する

10.4.1 タスクの種類によってモデルを差別化する

...200

10.4.2 オーケストレーションシステムを使う

10.4.3 人とAIのハイブリッドチーム

10.5 自律型コーディングエージェントの主要プレイヤー

10.6 課題と限界

10.7 AIコーディングエージェントを効果的に使うためのベストプラクティス 10.7.1 自律型エージェントが実装するタスクを戦略的に選択する 211 211 10.7.2 エージェントに特化した計画と監視の機能を活用する 211 10.7.3 エージェントの同時操作を管理する 212 10.7.4 エージェントを統合するためにチームのプラクティスを進化させる 212 10.7.5 自律システムでフィードバックループを構築する 212

10.8 まとめと次の一歩・

11章 コード生成を超えて AI拡張開発の未来

11.1 テスト、 デバッグ、 保守におけるAI・

11.1.1 テストの自動生成

11.1.2 知的なデバッグ

203

204

204

205

206

208

215

11.1.3 予知保全 (予測的な保守) とリファクタリング・

11.2 AI駆動デザインとユーザー体験 (UX) のパーソナライゼーション

11.2.1 生成デザインツール

215

217

11.2.2 UXリサーチのためのAI

216

218.

11.2.3 パーソナライズされたユーザー体験 (UX)

11.3 AIによるプロジェクト管理の進化

219

11.4 自律型エージェントはソフトウェアエンジニアリングをどう変えるか

11.5 プログラミング言語の未来 自然言語駆動開発?

11.6 バイブコーディングはどのように業界を再構築しているのか

218

219

11.7 まとめと次の一歩

220

223

228

索引

213

231

233

237

215

196

基礎



| 3

1章

序論 バイブコーディングとは何か?

AIは、自由形式のプロンプティングから構造化された支援まで、コーディングのための新しいパ ラダイムを導入し、ソフトウェアの構築方法を新たにしています。(ほとんどチームメイトと会話す るように)単にやらせたいことを「説明」 するだけで、 AIがそのアイデアをコードに変換し、ソフト ウェアを作成することを想像してみてください。 これが、「バイブコーディング」の本質です。 自然 言語で欲しいものを説明し、大規模言語モデル (LLM) に空白を埋めさせる、プロンプトファースト の探索的アプローチです。 この用語は、AIのパイオニアであるアンドレイ・カルパシーによって最 近作られたものであり (https://x.com/karpathy/status/1886192184808149383) 開発者がAI 支援の 「バイプスに完全に委ねる」 という、この新しいプログラミング方法を説明しています。

本書では、バイブコーディングがプロ開発者にとってどのような意味を持つのか、そしてそれが (私が 「AI支援エンジニアリング」と呼ぶ)より体系的な拡張コーディングプロセスとどのように比較 され、それをどのように補完するのかについて、深く掘り下げていきます。 このAIファースト時代 に、開発者の役割はどのように進化しているのか、 どのようなツールやワークフローがあなたの効果 を最大化できるのか、 そしてAIをコードベースに解き放つというユニークな課題にどのように対処 するのかを探ります。 また、バイブコーディングがどこで輝き、どこで苦戦し、 AI生成の速度と人 の監視の知恵のバランスをどう取るかについても見ていきます。 本書を読み終えると、単にコーダー としてより速くなるだけでなく、 AI時代に、より創造的で影響力のあるソフトウェアプロダクトエン ジニアになるために、あなた自身のコーディングプラクティスでの(責任を持った効果的な)「パイプ ス」の活用方法を理解できるようになっているはずです。

本章では、開発者の役割が、 マシンに詳細な指示を書くことから意図を表現することでAIと協働 することに、どのように変わりつつあるかを探ります(図1-1 を参照)。 プログラミングにおけるこの 「パイプシフト」がなぜこれほど大きな意味を持つのか、それが高レベルでどのように機能するのか、 そしてそれがどのような機会と課題をもたらすのかを見ていきます。

4章 序論 バイブコーディングとは何か?

開発者

意図

Al

コード

図1-1 意図を持ったプログラミングの概念的図解。 開発者が高レベルの仕様(「意図」) を提供し、 AIがそれをコードに 変換する。これは、コードを一行一行書くことから、高レベルでコード生成を導くことへの転換を強調している。

1.1 AI コーディングの範囲:

バイブコーディングからAI支援エンジニアリングまで

この1年で、 開発者 (特にミドル/シニアのウェブ開発者) がワークフローでAIをどのように受け 入れるかについて、 興味深い二極化を観察してきました。 一方の端には、 「バイブコーディング」 が あります。 もう一方の端は、 私が 「AI支援エンジニアリング」 と呼んでいるものです。 これは、明確 な制約のもと、設計からテストまでソフトウェア開発の各段階にAIを織り込む、 規律を守る方式で す。 どちらのアプローチも強力なAIを活用しますが、その目標、 対象者、 期待は著しく異なります。 本書を通して、極端なこれら2つのアプローチと、それらが現代のウェブ開発にとって何を意味する のかを探っていきます。

1.1.1 バイブコーディングのアプローチ 会話によるコーディング

バイブコーディングでは、強力なLLMをコーディングパートナーとして活用し、コード生成の 重労働を任せることで、より高レベルの目標に集中できます。 「Business Insider」のまとめ記事 (https://oreil.ly/nveFW) では、 バイブコーディングは「ソフトウェアを素早く構築するために、 コーディングの重労働のためにAIツールを使うことを意味する」とされています。 NVIDIA CEO のジェンスン・フアンが言うように、AIのおかげで、 「最もホットな新しいプログラミング言語」 は Java でも Python でもなく英語です。 すべての関数やバグ修正を手動で入力する代わりに、 自然言 語でAIと対話し、機能の概略を述べ、 提案を再検討し、 AIの出力に基づいて反復します。

このアプローチは、従来のプログラミングからAI支援開発への劇的な転換を示しています。 従 来のコーディングでは、入念な計画、 正確な構文、 そして多くの場合、 骨の折れるデバッグが求 められます。 バイブコーディングは、その台本をひっくり返します。 アンドレイ・カルバシーは 「Business Insider」 に 「コーディングというより、見て、言って、実行して、コピー&ペーストす るだけで、ほとんど動作する」と語り、 最小限の手作業でAIが高レベルの指示を動作するコードに 変換できることを強調しました。

1.1 AI コーディングの範囲 バイブコーディングからAI支援エンジニアリングまで | 5

開発者は、コンピューターに詳細な指示を書くことから、 AIの助けを借りて 「成果をオーケスト レーション (調整) する」ことに移行します。 例として、 アンドレイ・カルパシーは、AIの提案を受 け入れ続けることでウェブアプリを構築することを説明しています (https://oreil.ly/Ki6iJ)。 「常 に 「Accept All」 します (すべてを受け入れます)。 もはや差分を読むことはありません･･･エラーメッ セージが出たら、それをコピー&ペーストするだけです･･･ LLMがバグを修正できないこともあるの で、単にそのバグを回避したり、 そのバグがなくなるまでランダムな変更を求めたりします」。 コー ドは、いつも彼が自分で書く以上に「成長」しますが、プロンプティングと修正を繰り返すことで、 プロジェクトはすぐに良い方向に進みます。 基本的に、バイブコーディングでは、コーディングは、 構文やスタックトレースに1人で苦労して取り組むのではなく、 AIペアプログラマーとの対話型の会 話として扱われます。 目標は速度と探求であり、最小限の摩擦で動作する解決策を得ることです。

いくつかのトレンドが収束し、 バイブコーディングを可能にしました。 第一に、 (OpenAI Codex、 ChatGPT、Anthropic Claude といった) 最新のAIコーディングアシスタントは、コードの生成や 修正が驚くほどうまくなっています。 アンドレイ・カルパシーは同じ投稿で、 「LLMがあまりに優秀 になりつつあるために、 これが可能になった」と指摘しています。 これらのモデルは、 GitHubの膨 大なコードを取り込んでおり、 多くのタスクに対してもっともらしい解決策を作り出せます。

第二に、これらのモデルをコーディングワークフローにシームレスに統合するための、 新しい開発 者ツールが登場したことです(これらのツールについて、 後ほど詳しく説明します)。 最後に、開発 者コミュニティの考え方は、より大きな作業についてもAI支援を信頼するように、進展しつつあり ます。もはや超高性能な自動補完ではなく、 機能やファイル全体をAIに委ねるのです。実際のとこ ろ、バイブコーディングは、クラウドコンピューティングの速度で動作することを除けば、頼んだこ とを何でも実装してくれる熱心なジュニア開発者を無限に抱えているように感じられます。

バイブコーディングの最も目を見張る約束の1つは、 生産性の向上です。 初期導入者の報告による と、ソフトウェアの機能やプロトタイプの作成が、 以前の10倍から10倍速くなったとのことです。 例えば、Windsurfを使っているエンジニアのジョン・フースチェは、 「100倍エンジニアになれるの に、なぜ10倍エンジニアになるのか?」と考えを巡らせています (https://oreil.ly/_nfZn)。 これ は、 適切な AI駆動IDEがあれば、 並外れた生産性に手が届くことを示唆しています。 AI拡張IDE である Windsurfのようなツールは、 「開発時間を劇的に加速させ、100倍の生産性を達成すること を可能にします」。 100倍は極端なシナリオかもしれませんが、 より保守的な研究でも大きな利益が 見られています。

開発者は、数秒でボイラープレートコードを生成でき、瞬く間にバグを修正でき、AIにテストや ドキュメントを書かせることさえ可能です。 これまで数日かかっていたワークフローを、わずか数 時間に圧縮できます。 AIで武装した1人の開発者は、もはや入力速度や記憶に制限されることがな くなり、週末にフルスタックアプリケーションをプロトタイピングできます。 これは、かつては小規 チームが数週間かけて達成していたかもしれないことです。 これは、単なる誇張ではありません。 2025年1月の 「The Pragmatic Engineer」 のブログ記事 (https://oreil.ly/khEfs) で私が述べた

6 | 1章 序論: バイブコーディングとは何か?

ように、調査によると、 75%の開発者がすでに何らかの形でAIをワークフローに統合しており、 多 くの企業がベロシティ (開発速度) の2桁 3桁%の向上を報告しています。 要するに、 AIペアプロ グラマーは、神話的な 「10倍エンジニア」 を、 非常に現実的な (そして到達可能な) 100倍エンジニア の現象に変えつつあるのです。

これがどれほど画期的かを理解するために、具体例を考えてみましょう。 ある開発者が、 ポッド キャストのスクリプトの単語数を数え、 読了時間を推定する単純なウェブアプリを作りたいと考え ています。 ゼロから始めるのではなく、AI駆動コーディング環境を開き、AIに自分のアイデアを 「伝えます」。 数分のうちに、AIは動作するプロトタイプを作成します。 開発者が「統計カウンター を明るい色にして、 PDFエクスポートを追加して」 と言うと、AIはそれに応じてコードを更新しま す。その結果、機能するツールがワンクリックでデプロイされ、すべてが10分以内に実現しました。 (ReplitのAIを使ったクリエイターが報告した*) この実世界のシナリオは、 バイブコーディングが いかに高度な要求に基づく極めて素早い反復開発を可能にするかを示しています。 同様に、 非エン ジニアも飛び込んできています。 同じ記事には、コーディングの素養がない解雇されたマーケティン グ担当者が、 AI コーディングアシスタントを使って100個の単純なウェブツールを構築し、それが まとめてProduct Hunt2のトップになったことが紹介されています。 ソフトウェア作成の障壁がこ れほど低くなれば、 経験豊富な開発者の生産性が向上するだけでなく、 そもそもソフトウェアを開 発できる人が根本的に拡大することになります。

しかし、バイブコーディングには重大な注意点があります。 AIに多くを委ねることになるため、 正常系では 「動作する」 が、 バグや稚拙な設計判断という地雷原が隠されているコードになってし まうかもしれないのです。 確かな計画や制約がなければ、LLMは適切なエラー処理、セキュリティ チェック、スケーラビリティを欠いた解決策を生成するかもしれません。実際、AIが生成したコー ドは、 時に砂上に作られることがあります。 つまり、一見確かなように見えますが、 実世界の条件下 でのみ表面化する問題が隠されているのです。 開発者がバイブコーディングを使って記録的な短時 間で完全な機能を完成させたものの、後になってそのコードが非効率的で保守が困難であることが 判明したケースを、私は見たことがあります。 こういった「砂上の楼閣」 のようなコードは、圧力を 受けると崩壊する可能性があります。

例えば、AIに 「ユーザーログインシステムを作って」と頼んだとしましょう。 AIはすぐに動作する 認証フローを作成するかもしれませんが、おそらく簡素化された暗号化手法や既知の脆弱なライブ ラリを使っているでしょう。 深く検査することなくそれをデプロイすれば、すべてが正常だと信じる ことになります。経験豊富なエンジニアは、これが危険であることを知っています。 本番環境で実 行されるコードは、理解され信頼されなければなりません。 ある専門家 (https://oreil.ly/ppXCO に言わせれば、「本番環境のコードベース向けのバイブコーディングは、明らかに危険です。 私たち

1 https://oreil.ly/guqFZ

2 注:Product Hunt (https://www.producthunt.com/)は、新しいプロダクト(アプリ、ウェブサイトなど)のキュレー ションプラットフォーム。

1.1 AI コーディングの範囲: バイブコーディングからAI支援エンジニアリングまで | 7

がソフトウェアエンジニアとして行う作業のほとんどは、既存のシステムを進化させることです。 そ こでは、基礎となるコード品質と理解しやすさが非常に重要です」。 バイブコーディングは、極端な 場合、これらの品質ゲートを迂回する可能性があります。

もう1つの課題は、 バイブコーディングが先行計画を軽視しがちなことです。 伝統的なソフトウェ アエンジニアリングでは、データモデルを通して考え、 適切なパターンを選択し、少なくとも最小限 の仕様を作成することで、明確さと制約を考慮して設計することを重視します。 バイブコーディン グはこれをひっくり返します。 「足場を組まず」 に始め、 プロンプトから実装に直行します。 これは、 蛇行した開発プロセスにつながる可能性があります。 あなたは、プロンプトを使って自分を隅に追い 込んでしまうかもしれません。 例えば、AIがあなたの意図しないステート管理のアプローチやライ ブラリを選択した場合、 あなたはそれを元に戻すか、 それに耐えるかしなければなりません。 初期 の青写真がなければ、最終的なアーキテクチャは場当たり的になるかもしれません。 手っ取り早く概 実証 (PoC) をするならいいですが、 一貫性が重要な大規模コードベースでは厄介です。

バイブコーディングは、本質的に「悪い」ものではありません。 実際、 その出現は、 現在進行中の プログラミングの民主化の一環です。 初期のローコードプラットフォームやスクリプト言語がそうし たように、ソフトウェア作成の障壁を低くします。 明確なアイデアを持ったやる気のある非エンジニ アが、バイブスだけで簡単なアプリを作れる可能性があります。 経験豊富な開発者にとっては、バ イブコーディングは強力なブレインストーミングツールになります。 それは、擬似コードのようです が、すぐに実行できる結果を得られます。 重要なのは、 その限界を認識することです。 規律なき速 度は、脆弱なソフトウェアにつながる可能性があるため、 バイブコーディングには、慎重なヒューマ ンインザループ (human in the loop、 HITL) が必要です。 私はよく開発者に (そして私自身にも)、 「バイブコーディングは低品質の作業の言い訳ではない」と言い聞かせています。 バイブコーディン グは解決策の 「開始」 であるべきであり、終了ではないのです。

1.1.2 AI支援エンジニアリングのアプローチ AIパートナーとの構造

「AI支援エンジニアリング」 は、AIを副操縦士 (コパイロット) とする、 より構造化された体系的 なソフトウェアの構築方法です。 この場合、 開発者が運転席に座ることになります。 AI 支援エンジ ニアリングには、 AI駆動の自動補完、チャット、コード移行、 バグ検出、 テスト生成、 粒度の細か い (関数、 モジュール、コンポーネント単位の) および完全なコード生成など、 従来のソフトウェア 開発ライフサイクル (SDLC) にわたってAIを利用することが含まれます (図1-2を参照)。

8 | 1章 序論: バイブコーディングとは何か?

開発者が 計画と仕様を作成 開発者がAIに (的を絞った) プロンプトを送る AIがコード 開発者がレビューし、 | スニペットを生成 反復改善する </>

図1-2 計画先行のAI支援エンジニアリングワークフロー 開発者は仕様を作成し、 AIシステムに的を絞ったプロンプ トを提供し、生成されたコードスニペットのレビューを行い、承認された解決策をプロジェクトに統合する。

まず、(たとえ軽量であっても) 計画を立て、 何を構築する必要があるかを概説し、 制約と受け入 れ基準を前もって定義します。 次に、 その計画の一部を加速させて強化するために、 的を絞った方 法でAIツールを組み込みます。 プロンプト先行のバイブコーディングとは対照的に、 私たちはこれ をAIサポートを備えた 「計画先行」 開発と呼ぶかもしれません。 これは、 ミニプロダクト要求仕様書 (機能の短いPRD) のような体系的なものや、タスクのチェックリストのような単純なものです。 決 定的な違いは、AIを解放する前に、 あなたが 「明確な意図と制約」 に基づいた作業を行うことです。

新しい対話型ダッシュボードコンポーネントの作成を行うReact 開発者を、考えてみましょう。 AI 支援エンジニアリングのアプローチでは、 彼らはコンポーネントの責務とAPIを書き出すことか ら始めます。

ダッシュボードコンポーネントは、 分析カードのリストを表示し、 日付範囲によるフィルタリン グをサポートし、更新ボタンとエクスポートボタンを備えています。 (適切なエラー処理を行っ て) APIからデータを取得し、 当社のデザインシステムに従ってスタイルを設定する必要がありま す。

この概要は基本的に仕様です。 開発者は、簡単なデータモデルの概略を説明したり、 再利用する 既存のユーティリティ関数を特定したりするかもしれません。 その時になって初めて、AIを導入し ます。 例えば、 AI対応IDEやコーディングアシスタントを使って、 その説明に基づいてコンポーネ ントのスケルトンを生成します。 AIは、データ取得やイベントハンドラーのスタブのプレースホル ダーを備えた、 React コンポーネントの初期実装を提供します。 開発者が明確な指針を提供したため、 AI の出力は (正しいデザインシステムのクラスを使う、正しいAPIエンドポイントを呼び出すといっ たプロジェクトのニーズに合う可能性が高いでしょう。 コードは驚くべきものではなく、適切に形 成された要求の産物なのです。

1.1 AI コーディングの範囲: バイブコーディングからAI支援エンジニアリングまで | 9

AI支援エンジニアリングは、1つのコンポーネントのコード生成にとどまりません。 制御された 形で、開発ライフサイクル全体に浸透します。 定型コーディングタスクの場合、 GitHub Copilot のようなAI自動補完ツールは、入力中に次の数行を提案し、 既知のパターンを実装する際のキー入 力を省くことができます。 例えば、 単体テストを書く時に、 AIヘルパーが関数名に基づいてアサー ションを自動提案します。 テストといえば、 機能が実装された後に、 AIを使ってテストケースを生 成するかもしれません。 コンポーネントの仕様やコードをプロンプトに入力すると、確認すべきエッ ジケースを得られます。 エンジニアの作業を代替するのではなく、 「拡張」するというアイデアです。 あなたは、依然としてロジックを考え抜き、 正しさを検証します。 AIは、単に雑務の一部を肩代わ りしてくれるのです。

コードの移行やリファクタリングに関しては、 AIは天の恵みとなります。 クラスベースのReact コンポーネントを、フックを備えた最新の関数コンポーネントに変換する必要があることを想像し てください。 すべてを手動で行うよりも、 AIアシスタントにコードの変換か、少なくとも手順の概 要説明を頼めるでしょう。 新旧のパターンをよく理解していれば、LLMはリファクタリングされた コードの下書きを作成し、 あなたはそれをレビューして完成させることができます。 この構造化され たAIの使用では、 AIに 「何でもいいから構築して」 という制約のない命令を渡すのではなく、 (「こ のコードをRedux から React コンテキストAPIに移行して」といった) 明確に定義されたタスクに1 つずつ取り組みます。

おそらく、 AI支援エンジニアリングの最も劇的な形は、 詳細な仕様から完全なミニアプリケー ションや機能を生成するためにAIを使うことでしょう。現在、いくつかのツールでは、アプリの説 明(ミニPRDのようなもの)を入力すると、動作するコードベースやプロトタイプが返されます。 例 えば、開発者は次の仕様を提供できます。

ユーザー認証 リアルタイム更新をサポートする、 React フロントエンドとNode.js バックエン ドを持つTo-Do リストアプリ

AIツールはプロジェクトの足場を組み、 主要コンポーネントを作成し、 データベーススキーマを 設定します。

これは魔法ではありません。 勤勉なエンジニアが新しいプロジェクトを始めるときに行うこと (ディレクトリのセットアップ、 ライブラリの選択、 ボイラープレートコードの作成) を加速させたも のです。 重要なのは、AIの創造性は 「仕様で与えられた制約に縛られる」ということです。その結果、 あなたが提供した要件に準拠した実用最小限のプロダクト (MVP) ができ上がります。 経験豊富な 開発者は、この出力を正しく扱い、 第一世代で本番環境対応だとは考えず、最初の下書きとして扱 うでしょう。 アプリを実行し、 各機能を検証するテストを書いたり再生成したりし、 コードに非一貫 性や安全でない構成がないかレビューし、必要に応じて改良します。 要するに、 通常のエンジニア リングの厳密さをすべて適用しており、AIが青写真から大量のコードを生成する能力によって加速 されるだけなのです。

10 | 1章 序論 バイブコーディングとは何か?

AI 支援エンジニアリングの目標は、バイブコーディングの目標とは異なります。 その目的は、「動 作する」コードを素早く得ることではなく、 「高品質」のコードをより効率的に得ることです。 成果の 信頼性を維持 (あるいは向上すら)させながら、 生産性を高めることです。 AI支援エンジニアリング を実践しているチームは、 「この機能を2倍早く提供したいのですが、 私たちの基準については妥協 しません」と言うでしょう。

通常、このアプローチの対象者は、確立されたプロセス (コードレビュー、テスト、デプロイバイ プライン) を放棄したくないプロの開発者やチームです。 こういったミドル/シニアエンジニアたち は、AIをツールボックスの代替品ではなく、 ツールボックスの中の強力な新しいツールと見なして います。 彼らは、手を抜くとどうなるかを目の当たりにしているため、ソフトウェアの保守性を維持 するプラクティスを重視しています(これに対し、 バイブコーディングの対象者は、デモをハックし ている1人の開発者、ある程度のコーディング知識を持つプロダクト志向の人々、さらには専門知識 のギャップを補うためにAIを活用する比較的新しいプログラマーなどです)。

AI 支援エンジニアリングに期待されるのは、 人が意思決定を制御し続け、 AIが提案やアクセラ レーター (加速器) を提供することです。 コード品質、 パフォーマンス、セキュリティが最重要であ ることに変わりはないため、AIが生成したすべての部分は、ジュニア開発者が書いた場合と同じ精 査を受けることになります。 AIを、 あなたの代わりではなく、あなたのインターンとして扱ってく ださい。 AIにタスクを委ねますが、その作業をレビューしなければなりません。 人のインターンが 書いたコードを、 コードレビューせずにデプロイすることがないのと同様に、 AIが書いたコードを 理解せずにデプロイすべきではありません。 この考え方は、エンジニアリングの規律を常に中心に 置くものです。

1.1.3 異なる考え方、異なる期待

バイブコーディングとAI支援エンジニアリングは、2つの異なる考え方です。 バイブコーディン グは、トップダウンで探索的です。 大まかなアイデアから始めて、 AIとの対話を通して実装を浮か び上がらせます。 最小限の構造、創造的なリフの余地が多く、演奏しながら曲の形を発見していく、 即興的なジャズのようなものです。 AI 支援エンジニアリングは、体系的で反復的です。 テーマやモ チーフ (あなたの要件) から始め、おそらく書かれた楽譜の小節の中で即興演奏 (AIの提案) を使い ながら、それを整然と発展させていくクラシック音楽の作曲に似ています。 どちらも 「音楽」を作り 出せますが、過程と結果の種類が異なります。

ミドル/シニアのウェブ開発者にとって、それぞれのアプローチへの期待が重要になります。も しあなたがバイブコーディングをしているなら、驚きを期待します。 AIは、 あなた自身では書けな かったようなアプローチを思いつくかもしれません。 あまり馴染みのない別のライブラリやプログラ ミングイディオムを使うかもしれません。 そのような驚きから学んだり、面倒だと思うことを素早く 克服したりすることも、魅力の1つです。 しかし、 ちょっとした不都合も想定しておく必要がありま す。 バイブコーディングの熱狂的なファンは、扱いにくい最後の部分の責任を自分が負うことを覚悟

1.1 AIコーディングの範囲: バイブコーディングからAI支援エンジニアリングまで | 11

して臨むべきです。 魔法は本物ですが、 万能ではありません。

もしあなたがAI支援エンジニアリングを実践しているなら、 あなたの期待は、 長期的なプロジェ クトに対してより慎重であり、間違いなくより現実的でしょう。 あなたがAIに期待することは、時 間を節約し、 解決策を1つか2つ引き出してくれることであり、 作業のすべてをやってくれることで はありません。 実際、 優れたAI支援エンジニアは、 より大きなフレームワークの中でバイブ形式の プロンプトを 「微量に」 使うかもしれません。 例えば、 適切な仕様のモジュールを実装している時 に、一瞬 「バイブモード」に切り替えて、 「ねぇ、 AI、 この日付を書式設定するユーティリティ関数 を素早く生成して」と頼み、 すぐにエンジニアモードに戻して、その関数を統合して確認します。 考 え方は、AIはあなたの指針の下で働く協働者だということです。 AIが得意とするタスク(ボイラー プレート、繰り返しのコード、大まかな実装など) をAIに割り当て、 自分で残りのタスク (重要なロ ジック、 統合、 最終レビュー) に対処します。

ここでの期待は、生産性の向上、 暗記ミスの減少 (例えば、 AIは変数名のスペルを間違える可能 性が低いでしょう)、 解決策の検索範囲の拡大 (AIはあなたが思いつかなかったアルゴリズムを提案 するかもしれません)などです。 しかし、妥当性確認に時間を費やすことも予想されます。 AI支援 コードのデバッグは、依然としてデバッグです。 あなたがテストを実行し、必要に応じてデバッガー でコードをステップ実行します。 違いは、AIがあなたに代わって書いたコードを、 あなたがデバッ グすることになるという点です。 これは、学習曲線を伴う新しい体験です。 「5章 生成されたコー ドを理解する レビュー、 改良、 所有」 で、この体験について詳しく説明します。

2つのアプローチの目標は、両者の根本的な違いを浮き彫りにします。 バイブコーディングは 「短 期的なベロシティ」を最適化するのに対し、 AI支援エンジニアリングは 「持続的なベロシティと信 「頼性」を最適化します。 バイブコーダーは、「このアイデアがうまくいくかどうかを確かめるために、 今夜までにこのアプリを動作させる必要があります」 と言うかもしれません。 AI支援エンジニアは、 「この機能を早く構築する必要がありますが、私たちのコードベースに何年も残るような堅牢性が必 「要です」と言うでしょう。 前者は、コードが基本的に機能すれば満足しますが、後者は、 他の人がそ のコード上で構築できるほどに、 十分クリーンなコードであることを気にします。

このような違いは、自然に異なる対象者に訴えます。 経験の浅い開発者やエンジニアリング規律 の専門外の開発者は、バイブコーディングに傾倒するかもしれません。 私は、バイブプロンプトを 通してコードに手を出すプロダクトマネージャーやデザイナーに会ったことがあります。 彼らは、 AI を、完全な解決策を与えてくれる超強力なStack Overflowのように扱っていました。 その一方で、 経験豊富な開発者やエンジニアリングチームは、AI支援エンジニアリングを好む傾向にあります。 彼らは以前、 脆弱なコードによって火傷を負った経験があるため、 「より速くするために新しいツー ルを使うにしても、正しくやろう」 というところから始めます。 彼らは、長期的な見返りと引き換え に、前もって(ミニPRDを書く、 プロジェクト構造をセットアップするなど) もう少し労力をかけま す。

12 | 1章 序論 バイブコーディングとは何か?

1.1.4 幅広い範囲の中で自分の位置を見つける

ついこう聞きたくなります。 どちらのアプローチが優れていますか? 実のところ、 バイブコー ディングとAI支援エンジニアリングは、 相互排他的なカテゴリーではありません。 両者は範囲の 両端を表しており、 実世界のワークフローでは多くの場合、両者の要素が混在しています。 開発者 は、プロジェクトをバイブコーディングで開始し、新しいものの足場を組み、 それから、エンジニア リングモードに切り替えて強化させるかもしれません。 あるいは、通常はAI支援の規律に従いつつ も、時々、些細な1回限りのスクリプトや使い捨てのプロトタイプのために、 「あのね、これをバイ ブコーディングして、 何が得られるか見てみるよ」 と言うかもしれません。重要なのは、トレードオ フを理解し、適切な状況に適切なアプローチを使うことです。

バイブコーディングを、 高速な探索車両だと考えてください。 それはすぐに常道から外れて未知 の道へと導いてくれるので、 発見に最適です。 AI支援エンジニアリングは、線路上を走る信頼でき る列車のようなものです。 最初にレールを敷く (計画を立てる) 必要がありますが、 その方が安全で あり、脱線することなく決められた目的地に到達できる可能性が高いでしょう。 ミドル/シニア開発 者は、両方の乗り物を運転できるはずであり、目の前のタスクに応じて選ぶでしょう。 (ハッカソン やアイデアの実現可能性の検証など) 革新や素早くアイデアを考えることが目標なら、 バイブコー ディングは勢いを与えてくれます。 ただ、そのコードを再利用する計画があるなら、 厳しくするこ とを忘れないでください。 プロの設定で保守可能なプロダクト機能を構築することが目標であれば、 AI 支援エンジニアリングを選ぶことで、 自分のコードベースに誰にも理解されない大量のブラック ボックスコードができてしまうことを防げます。

私が観察した興味深いことの1つは、 開発者がAIツールの経験を積むにつれて、 ツールの使い 方が、バイブ側からエンジニアリング側に自然に転換していくことが多いということです。 初めは、 AIに1つのプロンプトからコードブロック全体を生成させるという新しさは、魅力的です。 基本的に 「話す」だけでアプリを作ることを試したくない人なんていますか?

しかし、 蜜月が過ぎると、 現実主義が始まります。 開発者は、 AIがどこで輝き、 どこでつまずく のかを理解し始めます。 一度に完全な解決策を求めるのではなく、問題を分解し、 断片的にAIに問 題を与えることを学ぶのです。 事実上、 開発者は「プロンプトアーティスト」 からAIの 「オーケスト 「ラ指揮者」に移行します。 私自身のプラクティスでは、プロンプトにより慎重になり、 多くの場合、 単に制約のない質問をするのではなく、小さな擬似コードやコメントを書き、 AIにそれを完成させ るよう求めています。こうすることで、バイブのような流動性の利点が得られますが、それは自分で 制御できる構造の中での話です。

また、ツールが全領域をサポートするように進化しつつあることも、注目に値します。 一方では、 バイブコーディングのために明示的に設計された、チャットベースのインターフェイスや自然言語 コーディング環境があります。 コードは、求めるまで表示されないこともあります。 もう一方では、 IDEが、 従来のコーディングにシームレスに溶け込むAI機能を追加しつつあります。 例えば、改 善を提案するAIリンター、コードを説明するドキュメントジェネレーター、 自動的にプルリクエス

1.2 コードの行を超える: 意図を持ったプログラミング | 13

トを作成し、 レビューのために変更を提案するバージョン管理ポットなどです。 これらのツールは、 AIを活用しながらも、 通常の開発ワークフロー (編集、レビュー、 テストなど) に適合させることで、 エンジニアリングの考え方を促進します。

バイブコーディングとAI支援エンジニアリングとの区別は、ベストプラクティスが現れるにつれ て、時とともに曖昧になっていくかもしれません。 今日 「バイブ」しているように感じられるもの がよりガードレールを獲得していき、 「構造化エンジニアリング」 と感じられるものがより流動的に なっていくことに気付くかもしれません。 実際、 理想的な未来とは、 この範囲を苦もなく上下に移動 できるようなものだと、 私は主張したいのです。 AIを使って創造的な解決策を探りたい時には、そ れを行うが、ソフトウェアを強化してリリースする時には、常に確かなエンジニアリングプラクティ スで物事を抑制するのです。

このようなアプローチの範囲は、 今日のAIツールの扱い方における大幅な進化を表しています。 しかし、素早いバイブコーディングであれ、 構造化エンジニアリングワークフローであれ、私たちが AIと協働するテクニックを改良する一方で、 より根本的な変革が進行しつつあります。 プログラミ ングの本質自体が変わりつつあるのです。 開発者は自分のアイデアを明示的な指示に変換しなけれ ばならないという従来のパラダイムから、 自分の意図を直接表現し、 AIにコードへの変換を任せら れる未来に移行しつつあります。

この転換は、プログラマーであることの意味についての最も基本的な前提に挑戦するものです。 何世代にもわたり、私たちの価値は、マシンのように思考する能力、 つまり、問題をコンピューター が実行できる個別の論理手順に分解する能力と結びつけられてきました。 しかし、 マシンが私たち からの指示だけでなく、 私たちの「望む」ことを理解できるようになったら、どうなりますか? ここ で、「意図を持ったプログラミング」が登場します。 これは、単に新しいツールやテクニックという だけでなく、 開発者の役割の根本的な再考を意味します。

1.2 コードの行を超える: 意図を持ったプログラミング

何十年もの間、 プログラミングは指示を書くことを意味していました。 コンピューターに何かをす る「方法」を伝えるコードを、 何行も書くことでした。 それぞれの関数、 ループ、 条件文は、 人が 意深く作らなければなりませんでした。 意図を持ったプログラミングは、この台本をひっくり返しま す。 開発者は、低レベルの実装に集中する代わりに、 成果や目標に集中します。 あなたはその意図 を高レベルで(多くの場合、 自然言語で) 表現し、 AIシステムはそれを実現させるためのコードを考 え出します。

こう考えてみてください。 従来のコーディングは、誰かに段階的な指示を与えるようなものですが、 意図ベースのコーディングは、誰かに目的地を伝え、 最適なルートを考えさせるようなものです。 開 発者は、「どのように」ではなく「何を」に焦点を当てることで、より高い抽象度で作業できます。 こ のアプローチは、まったく新しいものというわけではありません。 ビジュアルプログラミング、ロー コードブラットフォーム、コードジェネレーターといったツールは、長い間、 抽象度を上げることを

14 | 1章 序論: バイブコーディングとは何か?

約束してきました。しかし、 今日のAIの進歩によって、 平易な言葉で複雑な振る舞いを説明し、そ の見返りとして動作するコードを得ることが、ついに実用的になりつつあります。

1.2.1 プロンプトの台頭 指示から説明へ

この転換の中心にあるのが、控えめながらも重要なプロンプトです。 「プロンプト」とは、 AIコー ディングシステムに与える入力や質問のことです。 要するに、 どのようにそれを行うかの指示ではな く、プログラムに何をさせたいかの説明です。 これは、コードを書くのとはまったく違って感じられ ます。 例えば、 ファイルを解析するループを書く代わりに、次のようなプロンプトで指示するかもし れません。

このCSVファイルを読み取り、 18歳以上の全ユーザーのメールアドレスを抽出して

AIは、その説明を達成するコードを生成しようとします。

なぜ今、このようなことが起きているのでしょうか? プログラミング言語を含む、 テキストの 理解と生成におけるLLMの急速な進歩は、 画期的な転換点となりました。 こういったAIモデルは、 膨大な量のコードと自然言語テキストでトレーニングされてきました。 これらは、ソフトウェアの振 る舞いの説明のようなプロンプトを解釈し、その振る舞いを実装する実際のコードに変換できます。 言い換えれば、 これらは、人がどのようにタスクを説明し、それらのタスクがどのようにコードに変 換されるかのパターンを学習してきたのです。

このプロンプトベース開発の台頭は、 開発者としては、 自然言語や擬似コードで機能やロジック の説明を書くことが増え、 構文的に正しいコードを書くという重労働をAIに任せることを意味しま す。 プロンプトが、 あなたの新しい思考の単位になります。 それは、簡潔な意図の表現です。 私た ちは、 「Xをやって、 次にYをやって、 次にZをやって」とコンピューターに伝えることから、 「X、Y、 乙が行われる必要があります」 と言って、 AIが空白を埋めてくれることを信じるようになってきたの です。

重要なのは、良いプロンプトを書くこと自体がスキルだということです (「3章 70% 問題: 実際 に動作するAI支援ワークフロー」 で詳しく説明します)。 曖昧な要件が人のプログラマーを混乱させ るのと同じように、曖昧なプロンプトは、誤ったコードや非効率なコードにつながる可能性がありま す。 プロンプトであなたの意図をより明確に示すほど、 AIの出力はあなたのニーズにより一致する ようになります。 これが、 多くの人がプロンプト作成を新しいプログラミングリテラシーと呼んでい る理由です。

1.2.2 どのように動作するか: 反復サイクルとコード生成におけるAIの役割

では、AIはあなたの自由形式の説明から、 どのように実際に機能するコードを生成しますか? その魔法は、 LLMがコンテキストを解釈して、 テキストを生成する能力にあります。 「大規模言語

1.2 コードの行を超える意図を持ったプログラミング | 15

「モデル」の「大規模」 は、 自然言語やプログラミング言語の複雑さを捉えられるパラメーター (内 部構成) の数(多くの場合、 数十億以上)を指します。 これらのモデルは、公開コードリポジトリ、 フォーラム、ドキュメント、 Q&Aサイトなどでトレーニングされ、プログラミング言語の構文と、 コードを使って問題を解決する方法のセマンティクスの両方を学習しています。 あなたがAIコー ダーと対話する時、この幅広く学習された知識を利用することになります。 簡単に説明します。

プロンプトを理解する

あなたがプロンプト (例えば 「ある数が素数かどうかをチェックする機能を生成して」) を与える と、AIモデルはそのプロンプトのテキストを分析します。 Google、 OpenAI、 Anthropic の最 新モデルは、数え切れないほどの言語とコードの例でトレーニングされているため、統計的パ ターンを使ってあなたが何を求めているかを推論します。 基本的に、 AIは、 意味をなすコード を備えた、最も可能性が高いプロンプトの補完を 「予測」しようとします。

コンテキストを活用する

このようなAIシステムは多くの場合、 1行のプロンプトだけでなく、 追加のコンテキストを考慮 します。 例えば、あなたがIDEでAIアシスタントと作業しているなら、 モデルは、 現在のファ イル内容、 あなたのコーディングスタイル、コメント、さらには関連ファイルを考慮するでしょ う。こういったコンテキストのすべてが、 AIがあなたのプロジェクトに合ったコードを生成す るのに役立ちます。 これは、 人の開発者が周囲のコードやドキュメントを読み、 次に何をすべき かを理解するのに似ています。

コードを生成する

モデルがあなたの意図を理解すると (あるいは、少なくとも最善の推測をすると)、 コードの生 成に進みます。 内部では、 モデルは、 トレーニングで学習した確率を使って、 トークン (単語や コード記号の一部) を1つずつ処理して、これを行います。 モデルは従来の意味で「考える」の ではなく、コードをチェックするコンパイラーやランタイムを持ちません。 モデルはこれまで多 数の例を見てきたため、単に、正しいコードである可能性が高い方法でテキストを続けるのが 得意なだけです。 プロンプトとコンテキストが明確であれば、モデルが生成するコードは驚くほ ど正確であり、 トレーニングデータで見てきたベストプラクティスに従うことさえあります。

人の監視下で妥当性を確認する

重要なのは、AIがあなたに代わって、アプリケーションを作成しデプロイしてくれるわけでは ないということです。 あなたはループに残ります。 あなたは、生成されたコードをレビューし、 テストし、それを受け入れたり修正したりします。 また、 AIは多くの場合、 あなたが結果を理 解するのを助けるために、 質問されたらコードの説明を提供するでしょう。

AIの役割は、あなたに代わってコードを下書きするアシスタントのようなものです。 しかし、 開発者であるあなたが、 コードが正しく、プロジェクトのニーズに合っていることを確認する意

16 | 1章 序論 バイブコーディングとは何か?

思決定者であることに変わりはありません。

本当に印象的なのは、このプロセスが数秒以内に行われることです。 高レベルの概要としては、 あなたの説明 (プロンプト) が予測エンジン (LLM) に入り、予測エンジンは出力として可能性の高 いコードを生成します。 モデルの内部の仕組みには複雑な数学とニューラルネットワーク層が関わっ ていますが、ユーザーレベルでは、どんなものでも実装方法を瞬時に思い浮かべることができる専 門家と協働しているように感じられます。

バイブコーディング (意図ベースのプログラミング) について理解すべき重要なことの1つは、そ れが人とAIとの間の反復的な協働プロセスだということです。 完璧なプロンプトを1つ書いただけ で、 AIがプログラム全体を完璧に書き上げるのを黙って見ているわけではありません。 実際には、 漠然としたアイデアを徐々に洗練されたコードにしていくフィードバックループを、 行き来するので す。

典型的なサイクルは、次のようなものです。

手順1:あなたが欲しいものを説明する

これが、例えば次のような、 あなたの初期のプロンプトや要求です。

主たる債務者、金利、 期間を指定し、 毎月のローン返済額を計算する関数を生成して。

手順2:AIが初期解決策を提供する

AIが、 ローン支払いに関するパラメーターと数式を備えた、その機能のコードを生成します。 数式を説明するコメントも含まれているかもしれません。

手順3: あなたがレビューしてテストする

あなたは、そのコードを確認します。 それは、理にかなっていますか? エッジケースに対処し ていますか? あなたは、 簡単なテストを実行します。 金利が0の場合は、 どうですか? 正しく 動作しますか? あなたは、 そのコードがうまくそのシナリオに対処できない可能性があること に気付きます。

手順4: あなたが自分の要求やコードを改良する

もしコードが完璧でなければ (多くの場合、 最初の試みではそうなりません)、 それを改良しま す。 AIに再度プロンプトで指示したり(「正常に金利0%に対処するように、 機能を修正して」)、 自分でコードを編集して、 不明点があればAIに 「この部分を説明して」 と伝えます。 この指針 は、誤解を正すのに役立ちます。

手順5:AIが解決策を改良する

AIは、あなたのフィードバックや新しいプロンプトを受け取り、コードを調整します。 今では、 この機能は金利0%をチェックし、 適切に対処するようになります。

1.3 17

生産性、近づきやすさ、プログラミングの本質の変化

手順6: 必要に応じて繰り返す

あなたは、満足するまでこのループを続けます。 おそらく次は、この機能が正しく動作すること を確認するために、この機能の単体テストも生成するようにAIに頼むでしょう。 AIはそれを行 い、あなたはそれを実行して、すべてがうまくいっていることを確認します。

この協働は、一方が人でもう一方がAIアシスタントというペアプログラミングのシナリオに、よ く似ています。人は方向性を定め、高レベルの要件を把握する一方で、AIは提案を行い、ボイラー プレートを書き、面倒な部分を高速化します。 複雑なタスクでは、どちらも単独では効果的ではあり ません。 AIは、方向性と妥当性確認を人に依存し、 人は、 より速く進めるためにAIに一部の作業を 任せます。

重要なのは、反復はエラーを修正するためだけではなく、解決策を進化させるためでもあるとい うことです。 非常に大まかなプロンプトから始めて、AIが作り出すものを見ながら、徐々に意図を 改良していきます。

これは実験的な姿勢を促します。 もし最初の試みが正しくなくても、それほど時間を無駄にする ことはありません。 プロンプトを改良したり、 コードを微調整したりして、 再度試みるだけです。 従 来のコーディングでは、モジュールを書いて、 結局捨てる結果になることはいら立たしいものです。 しかし、AIが生成するコードでは、誤った第一歩のコストは低く、 さまざまなアプローチの探求を 促進します。

1.3 生産性、近づきやすさ、 プログラミングの本質の変化

なぜ、意図を持ったプログラミングがこれほど重要なのでしょうか? この転換には、いくつかの 深い意味があります。

開発者の生産性を高める

おそらく最も直接的な利点は、 速度でしょう。 AIが暗記作業に対処することで、 開発者はより 速くタスクを達成できます。 (データベースモデル、 APIエンドポイント データクリーニング スクリプトのセットアップといった) 手動では何時間もかかるような定型コードを、多くの場 合、 数分で生成できます。 AIコーディングアシスタントに関する初期の研究が、これを裏付け ています。 GitHub Copilot のようなツールを使っている開発者は、大幅に速くタスクを完了す ることが示されています (ある研究 (https://oreil.ly/4Ksmy) では、 GitHub Copilot の支援 によって、特定のタスクにかかる時間が55%短縮されたことがわかりました)。 このような利益 をプロジェクト全体に拡大させると、 ソフトウェア開発サイクルが劇的に短縮され、 チームがよ り素早く反復できるようになる未来を示唆します。

開発者を「流れに乗せたままにする

速度だけでなく、心理的な利点もあります。ボイラープレートを書いたり、 構文を調べたりする

18 | 1章 序論 バイブコーディングとは何か?

ことは、プログラマーの思考の流れを途切れさせる可能性があります。 AIがそのような中断の 多くに対処してくれるため、開発者は問題解決に集中できます。 AIの助けによって、退屈なタ スクにいら立つことが減り、 コーディングの創造的で設計に関する側面に集中できるようになっ たと、多くのユーザーが報告しています (https://oreil.ly/inQHR)。 言い換えれば、退屈な 部分を肩代わりすることでコーディングをより楽しくすることができ、それによって、 作業の品 質を向上できます (多くの場合、 より幸せなコーダーは、より良いコードを生み出します)。

参入障壁を下げる

従来、プログラミングでは、コードの厳密な文法、 さまざまなライブラリやフレームワークの癖 を学ぶ必要がありました。 意図ベースのプログラミングでは、その負担の一部がAIに移ります。 新人は、ファイルを開くための正確な構文や、 グラフ関数のパラメーターを覚えていないかもし れませんが、何をしたいのかを説明できれば、AIがその詳細を埋められます。 これは、誰でも 知識ゼロで複雑なシステムをコーディングできることを意味しているのではなく (依然として、 プログラムが何をすべきかを理解する必要があります)、 有益な結果を生み出すまでの立ち上げ 時間が短くなることを意味しています。 プロ開発者でなくても、 (生物学者や経済学者のような) ドメインの専門家が自分のニーズを説明することで、その分野のプロトタイプを書けることが考 えられます。 この意味で、プログラミングは、アイデアや意図はあっても深いコーディングスキ ルがない人にとって、 より近づきやすくなります。

開発者の役割とスキルを変える

AIがより多くのコード生成を担うようになると、 人の開発者の役割は進化します。 アーキテク チャ設計、問題の分解、 妥当性確認といったスキルが、 さらに重要になります。 あなたは、 構 文を入力することよりも、 「何」 を構築すべきかを決定し、 「なぜ」 コードが動作するのか (ある いはしないのか)をレビューすることに、時間を費やすことになるでしょう。 「コードの書き方 を知る」ことの本質は、 「AIにコードを書かせる方法を知る」ことに転換するかもしれません。 これによって、 ソフトウェア開発のある側面が民主化される一方で、 プロが仕事をするレベル も上がる可能性があります。 AIを効果的に導く方法を中心に、 新たなベストプラクティスが登 場することになるでしょう (「3章 70% 問題: 実際に動作するAI支援ワークフロー」でこのト ピックを紹介し、本書全体を通して再確認します)。

生産性と創造性の比較

興味深いことに、AIが定型コーディングにより対処するようになると、人の開発者は、ユーザー 体験の洗練、 新機能のブレインストーミング、 AIだけではうまく解決できないような扱いにく アルゴリズム問題への取り組みなど、 より高レベルで創造的なタスクに集中できるようになり ます。 この理想的なシナリオでは、 AIは80%の繰り返しのコーディングの生産性を向上させ、 20%の創意工夫のためにあなたの精神的エネルギーを解放します。 これは、私たちの労力の配 分方法の転換です。

1.4 ツールを垣間見る新しいエコシステム | 19

しかし、いいことばかりではありません。 この新しい開発スタイルには、課題もあります。

信頼と正しさ

AIが書くコードを信頼できますか? すべての行を見なければ、間違いに気付かない危険性があ ります。 開発者は、AIが生成したコードを徹底的にテストし、レビューする必要があります。 出力が正しく、安全で、効率的であることを確認する責任は、人にあります。 これから説明す るように、 AIの出力を盲目的に信頼することは危険です。

低レベルのスキルを失う

AIに定型コーディングを頼ってしまうと、ゼロからコードを書いたり、深いところで問題をデ バッグしたりする能力が次第に失われてしまうのではないでしょうか? 電卓に頼りすぎると計 算スキルが弱まるのと同じような懸念です。 開発者は意識的に、利便性と基礎の確かな理解と のバランスを取る必要があるでしょう。

変化する仕事の状況

意図を持ったプログラミングが普及するにつれて、 業界はさまざまなスキルを評価するように なるでしょう。 単にポイラープレートのロジックを量産するのが得意な人の需要は減り、 システ ムを設計し、 コンポーネントを統合し、 正しさを検証できる人の需要が増えるでしょう。 ソフト ウェアの仕事の本質が変化し、 AIが実装を担当するようになり、 人は設計と監視に専念するよ うになるかもしれません。

さらに、「バイブコーディング」で最も重要な要素の1つは、コンテキストウィンドウのサイズです。 Geminiは すべてのAIモデルの中で最も長いコンテキストウィンドウを提供しており、これは大 規模なプロジェクトで作業する際に形勢を一変させる可能性があります。 現在、 一部のモデルは100 万トークンを超えるコンテキストウィンドウをサポートしており、アプリケーション全体の認識を維 持できます。 開発者は、包括的な理解のためにコードベース全体をAIに与えることができます。 これらのトレードオフについて、 本章の最後で詳しく説明します。 しかしその前に、この新しい コーディング方法を可能にする新たなツールについて、 よく理解しておきましょう。

1.4 ツールを垣間見る 新しいエコシステム

バイブコーディングは哲学かもしれませんが、新世代のAI駆動ツールによって実現されています。 このワークフローを受け入れたい経験豊富な開発者は、 AI支援コーディングを効果的にするいくつ かの重要なプラットフォームやモデルに精通する必要があります。

本節では、バイブコーダーのツールキットに不可欠なツールを簡単に紹介します。これには、AI の機能や拡張機能のエコシステムが拡大しているVisual Studio Code (VS Code)、 Cursor やWindsurfのような次世代AI統合IDE, ClaudeのようなLLM(のさまざまなバージョン)、

20 | 1章 序論: バイブコーディングとは何か?

ChatGPTなどが含まれます。 本節では、バックグラウンドコーディングエージェントを取り上げま せんが、10章で詳しく説明します。

本節を読みながら、 具体的なツール名や機能を暗記する心配をしないでください。 状況は急速に 変化しています。 目標は、利用可能な解決策の種類を理解することです。

1.4.1 VS Code + GitHub Copilot: Microsoftの統合 AI開発プラットフォーム

VS Code (https://code.visualstudio.com) は、 GitHub Copilot との深い統合によって、 世界 で最も人気のあるコードエディターから包括的なAI 支援開発プラットフォームに変わってきました。 この進化は、 何百万人もの開発者がすでに日々使っている使い慣れた VS Code環境の中にAI機能を 持たせるという、 Microsoftの構想を表しています。

GitHub Copilot は、 VS Codeに統合されたAI駆動のコーディングアシスタントです。 自然言語 のプロンプトと既存のコードコンテキストに基づいて、 コードの提案、 説明、 自動実装を提供します。 GitHub Copilot は単なるアドオンではなく、エディターそのものの自然な延長のように感じられま す。

VS CodeのAI機能の中核は、3つの主な対話モードにあります。 1つ目は「インラインコード自動 補完」 です。 GitHub Copilot は、1行の補完から関数の実装全体まで、入力中にインラインでコー ドの提案を表示します。 あなたがコードを書くと、 ゴーストテキストが表示され、 タブキーで受け入 れるか、 単語ごとに部分的に受け入れることができます。

2つ目は「チャットインターフェイス」 です。 これにはサイドバーパネルからアクセスでき、コード について会話したり、 質問したり、 特定の実装を要求したりできます。 おそらく最も強力な3つ目は、 「エージェントモード」 です。 これは、 ツール呼び出しを使って、 VS Code から増え続ける一連の機 能にアクセスします。 目標が与えられると、段階的に適切なツールを選択し実行します。 このエー ジェントモードは、コードベースの分析、 複数ファイルにわたる編集の提案、ターミナルコマンドの 実行、 ビルドエラーへの対応、タスクが完了するまでのループ内での自己修正が可能です。

VS Code の GitHub Copilot 実装が特に魅力的なのは、 モデルコンテキストプロトコル (MCP) のサポートです。 MCPは、 AIモデルが外部のツール、アプリケーション、データソースを検出し 対話するための標準化された方法を提供します。 つまり、 VS Code の GitHub Copilot は、 データ ベースに接続し、 APIを呼び出し、 ドキュメントにアクセスし、開発エコシステム全体と統合でき ます。 例えば、 GitHub MCPサーバーを有効にすると、 GitHub Copilot に 「議論した各バグのイ シューを作成して」と頼めます。 GitHub Copilot は、 GitHub の APIと直接対話して、 イシューを 作成します。 MCPによる拡張性は、 GitHub Copilot をコードジェネレーターから、コードだけで なくワークフロー全体を理解する包括的な開発アシスタントに変えます。

プロ開発でVS Code と GitHub Copilotを効果的に活用するには、タスクの複雑さに応じてさま ざまな対話モードを検討することから始めましょう。 簡単なコード補完やリファクタリングには、イ

1.4 ツールを垣間見る 新しいエコシステム |

ンラインの提案と、エラーの近くに表示されるスパークルアイコンを頼り、 それをクリックして、 AI 駆動の修正を行います。

21

より複雑なタスクの場合、 チャットパネルを開き、 ドロップダウンから 「エージェント」 を選択し てエージェントモードに切り替えます。 エージェントモードは、プロジェクト内の複数のファイルを 自律的に編集するために最適化されています。 これは、コードの編集だけでなく、 ツールやターミ ナルコマンドの呼び出しも必要な複雑なタスクに、 特に有効です。 VS Codeの使い慣れたインター フェイスとGitHub Copilot の進化するAI機能の組み合わせは、確立された開発環境を離れること なく企業向けのAI支援を求めるチームにとって、魅力的な選択肢になります。

1.4.2 VSCode + Cline:

オープンソースの自律型コーディングエージェント

専用のAIIDEを検討する前に、 Cline (https://cline.bot) (旧称 Claude Dev) がどのように VS Code を強力なAI支援開発環境に変えるかを検討する価値があります。 Cline は、Microsoft の Copilotとは異なる哲学を表しています。 緊密に統合されたアシスタントになるのではなく、複雑で 多段階の開発タスクを最初から最後まで担当できる自律型コーディングエージェントとして機能しま す。 このオープンソース拡張機能は、 VS Codeユーザーが期待する柔軟性と拡張性を維持しながら、 多くの場合、プロプライエタリなAI エディターを上回る機能をVSCodeにもたらします。

Clineの特徴は、 ソフトウェア開発に対する真にエージェント型のアプローチにあります。 Cline に「認証を備えたユーザー管理のためのREST API を作成して」といった高レベルの要求を与えると、 Clineは単にボイラープレートコードを生成することはありません。 代わりに、プロジェクトの構造 を分析し、複数のファイルにわたる実装を計画し、 適切なフォルダ階層を作成し、必要な依存関係 をインストールし、実装を検証するテストを実行することもできます。 Clineは、 このプロセスを通 して計画された各アクション (ファイルの作成、 修正、 ターミナルコマンド)を表示し、 あなたに 各手順を承認または修正する機会を与えることで、 透明性を維持しています。この「ヒューマンイン 「ザループ」の設計は、 自動化と制御の完璧なバランスを提供し、 開発者は、コードベースの監視を維 持しながら、 AI機能を活用できます。

Clineの技術的能力は、コード生成にとどまりません。 「ブラウザー自動化」 を利用して APIド キュメントを調査したり、 複数のファイルにわたるエラートレースを分析して複雑な問題をデバッグ したり、さらには、 MCPサポートを通して外部サービスと対話したりすることもできます。 デバッ グでは、あなたがエラーメッセージを貼り付けると、 Clineは、コードベースを追跡して根本原因を 特定し、 修正案を提案し、それを実装し、 類似の問題を防ぐために適切なエラー処理を追加します。 MCP統合によって、 Cline は、 クエリを生成する前にデータベースに接続してスキーマを理解した り、プロジェクト管理ツールにアクセスして実装を要件と合わせたり、他のMCP互換サービスと対 話したりすることができます。 この拡張性は、 Clineをコードジェネレーターから、技術エコシステ ム全体を理解する包括的な開発パートナーに変えます。

22 | 1章 序論 バイブコーディングとは何か?

チームにとって、 Clineにはいくつかの魅力的な利点があります。 オープンソースのため、チーム はそのコードを検査し、改善に貢献したり、カスタムのニーズ用にフォークしたりすることができ ます。 これは、特定のセキュリティやコンプライアンスの要件を持つ組織にとって重要です。 Cline は、 Anthropic Claude, OpenAI モデル、 Google Gemini、 さらにはOllamaを通したローカル モデルなど、複数のAIプロバイダーをサポートしているため、チームは、パフォーマンス、コスト、 データレジデンシーの要件に基づいて、柔軟にモデルを選択できます。

Clineを効果的に使うには、プロジェクトのコンテキストと制約を含む詳細なプロンプトを作成し、 変更を加える前にコードベース全体を分析する能力を活用し、 反復開発機能を活用します。 Cline が 機能を実装した後、 あなたは、 同じ会話コンテキストで、 すぐにテストし改良を要求できます。 VS Codeの成熟したエコシステムとClineの自律的な機能の組み合わせは、 既存のツールやワークフ ローを放棄することなく、 強力で柔軟で費用対効果の高いAI支援開発への道を、チームに提供しま す。

1.4.3 Cursor: Al駆動コードエディター

バイブコーディングのムーブメントの代表的なツールの1つが、 Cursorです。 これはAI拡張 IDE であり、 より流れるようなコーディング体験を求める開発者の間で、 急速に人気を集めていま す。 Cursor は、 基本的にAIファーストのコードエディター (実際には、 VS Codeのフォーク) であ り、あなたの開発環境に最先端のコードの生成と理解を組み込みます。

そのキャッチフレーズは「AIコードエディター」 であり、 平易な言葉の指示を使ってコードを書い たり修正したりできるように設計されています。 例えば、 関数をハイライトして、 Cursor に 「この 関数を最適化して」 「ここにエラー処理を追加して」 と頼むと、 Cursorはすぐにコードの変更を提案 してくれます。 CursorのAIはプロジェクトを認識します。 これは、コードベースのインデックスを 作成し、ファイルのコンテキストを理解するため、 (単純な自動補完をはるかに超える) より関連性 の高い提案を行えます。 Cursor IDEはLLMの機能を中心的なインターフェイスに統合していま す。 これは、あなたのコードベースを知っている ChatGPTなのです。

Cursorは、その機能を動かすために、高度な言語モデル (セットアップによりますが、多くの場 合、 Anthropic Claude や OpenAI モデル) を活用しています。 あなたのコードについて会話する ためのチャットサイドバーや、 多段階のコード生成のための「コンポーザー」 モードもあります。 ア ンドレイ・カルバシー自身、 バイブコーディングの実験 (https://oreil.ly/Ki6iJ) で、 Cursor のコンポーザーと 「Claude Sonnet」 モデルを使っています。 このセットアップによって、 彼は (「SuperWhisper」による音声テキスト変換を使って) 文字通りエディターに 「話しかけ」 コードを 生成させ、それを受け入れたり改良したりすることができました。

Cursorはコードを生成するだけでなく、 指示があれば 「既存のコードを編集する」こともできま す。 例えば、次のように頼めます。

1.4 ツールを垣間見る 新しいエコシステム | 23

トランスポートリスナーで、簡単に証明書を切り替えられるようにしてもらえますか?

Cursor は、 あなたがコードを参照していることを理解し、 関連ファイルの直接編集を提案したり、 仕様のMarkdown ファイルなどの関連ファイルを読んだりします (図1-3を参照)。 無料バージョン では、多くの場合、チャットでファイルの差分を提供し、 あなたがそれを承認できます。 プロバー ジョンでは、 あなたのワークスペースに変更を自動適用できます。

AutCab * App-co 1 portat, (state, effect, usecallback) from 'react' vervie 20 ACME camut error settrror) estatecnilis 21 22 23 27 33 try (

図1-3 Cursor のインターフェイスは、AIを統合した新種のIDEの典型例になっている。プロジェクトのインデックス を作成し、プロンプトを反復することで、 Cursorのようなツールは「エディターを実行したままにし、コーヒー を飲み、戻ってきたら、完全に動作する機能ができている」 といったことを可能にし、生産性を飛躍的に向上さ せる。

プロのワークフローでCursorを効果的に使うには、その機能を体系的に活用する必要がありま す。 まず、 Cursorでチャットを開き、欲しい機能や修正を説明することから始めましょう。 例え ば、 「検証とエラーメッセージを含む、電子メールとパスワードを持つユーザーのログインフォーム を追加して」と頼みます。 Cursorは、 (ファイルの新規作成、 または既存のファイルの修正を行う) 必要なコードを、下書き状態で生成します。 (差分やプレビューが表示されるので) これらの変更を レビューし、 「適用」をクリックして、あなたのコードベースに変更をマージできます。 多くの開発 者は、「プロンプトレビュー→受け入れ」というループを辿ります。 提案が完璧でない場合、プ ロンプトを改良したり (例えば、 「フォームのスタイル付けに Tailwind CSSを使って」)、 見つけた問 題を修正するようにCursorに頼んだりすることができます (「電子メールが登録済みの場合に対処 して」)。 要するに、問題がなくなるまで、 自分のコードと会話するのです。

Cursorは、エラーやログを理解することにも優れています。 コードを実行してトレースバック やエラーメッセージが表示されたら、それをCursorのチャットに貼り付ければ、 多くの場合、 AI

24 | 1章 序論: バイブコーディングとは何か?

がそれを分析して修正を提案してくれます。 これは、デバッグを協力的な体験 (https://oreil.ly/ Ki6iJ) に変えます。 あなたがGoogle や Stack Overflow で手動で検索する代わりに、 CursorのAl は多くの場合、問題を特定し、 パッチを書くことさえできます。 とはいえ、AIが最初の試みで正し くやるとは限らないので、 修正を検証するのが賢明です。

もう1つのプロのヒントです。 Cursor の複数ファイルを考慮する機能を利用してください。 一連 のファイルを選択して(あるいは、 プロンプトでプロジェクトのコンテキストを知らせて)、 Cursor がコードを生成する時に自分のコードベース全体を考慮するようにできます。 例えば、 「ログイン フォームをサポートするためにバックエンドに新しいAPIエンドポイントを追加し、 それを先ほど 作ったフロントエンドのフォームに接続して」 と頼みます。 Cursorは、 先ほど書いたフロントエン ドのコードを思い出し、 対応するバックエンドのロジックを作るのに役立てます。 ファイルごとにし か動作しなかった以前のコーディングアシスタントと比べると、 このプロジェクト全体のコンテキス トは画期的な転換点です。

まとめると、 Cursorは、 24時間365日、 IDEの 「中」にAIペアプログラマーがいるようなもので す。 それは直感的であり (平易な言葉でチャットできます)、 自分のコードを直接更新できます。 タ スクを分解して、 Cursorにプロンプトで明確に指示することを実践するほど、 短時間でより多くの ことを達成できることがわかるでしょう。 これは、 特に反復開発に最適です。 少しビルドして、実行 して出力を確認し、すぐにCursorにコードの調整や拡張を頼み、 それを繰り返します。

1.4.4 Windsurf:

完全なコードベースインデックスを備えたAI駆動IDE

バイブコーディングのツールボックスのもう1つの新星は、コード理解を次のレベルに引き上げる AI駆動開発環境である Windsurfです。 Windsurfは Codeiumの開発チーム (https://windsurf. com) によって構築されています。 コードベース全体のインデックスを作成し、 検索テクニック を使って作業中に関連する部分をAIモデルに与えることで、差別化を図っています。 これは実際、 Windsurfが、 あなたの質問に対する回答が多くのファイルに広がっているような大規模プロジェク トに、非常に適していることを意味します。 その中核は、 「検索拡張生成」 (RAG) と呼ばれるものを 使っています。 これは、あなたのプロンプトに関連するコードの部分を検索し、そのコンテキストを AIに提供することで、 その提案があなたの既存のコードと一貫性を持つようにすることの しゃれ た言い方です。

これは、開発者にとってどのようなものでしょうか? 例えば、 あなたが大きなコードベースで新 しく作業し始め、機能を追加する必要があるとしましょう。 Windsurfを使えば、 自然言語で質問で きます。

コードベースのどこで、 ユーザー認証のロジックが処理されていますか?

Windsurfは、 インデックスを検索し、 適切なファイルや関数を指摘してくれます。 そして、

1.4 ツールを垣間見る 新しいエコシステム | 25

(Windsurfでは 「カスケード」 ビューと呼ばれており、 Cmd+Lでトリガーされる) チャットを開い て、次のように言うかもしれません。

ログインフローに電話ベースの2要素認証を追加して。

Windsurfは、 あなたの認証ロジックのコンテキストを持っているので、これを実装するために、 複数のファイル (データベース、 API、 フロントエンド)にわたる変更を生成できます。

Windsurfのライト (Write) モードは、 あなたに代わって大胆に変更を適用できます。 サイド バーで差分を提案するのではなく、自動的にファイルを新規作成したり、既存のファイルを編集した りします。 これは、大幅な時間の節約になります。 提案をコピー&ペーストする代わりに、 自分の プロジェクトがその場で進化していくのを見られます。 Windsurfは基本的に、 自信があればあなた に代わって行動を起こそうとし、コードベース全体に機能を実装する自律的なジュニア開発者のよう に振る舞います (Cursorの哲学はもう少し保守的であり、 確認を求めますが、プロバージョンには 「自動適用」 機能もあります)。

Windsurfを効果的に活用するには、 その強みを理解することが役立ちます。

コードベースのQ&A

ほとんど自分のプロジェクト用のカスタム Stack Overflow のように、 平易な言葉でコードベー スに質問できます。 これは、定義されている箇所を見つけるのに何時間もかかるような大規模 レガシープロジェクトに最適です。 Windsurfは、 インデックスが作成されたコードから引き 出すことで、数秒で回答します。

グローバルコンテキストの提案

Windsurfはモデルに関連するファイルを与えるので、支払いモジュールとロギングユーティ リティの両方について知っており、 「私たちが書いた新しいロギングユーティリティを使うため に、支払いモジュールをリファクタリングして」といったタスクにうまく対処できます。

操作モード

Windsurfには複数のモード (自動補完、 チャット、 コマンド、 (前述の) カスケード) がありま す。 カスケードはスーパーチャットのようなものであり、より幅広いコンテキストを考慮できま す。 (チャット内の) ライトモードは実際に変更を適用します。 エンジニアであるあなたが、 ど の程度の自律性を与えるかを決められます。

チームにとって、 Windsurfは、 Cursor と同様に日々の開発に統合できます。 Windsurf、 Cursorのどちらかを選ぶ場合、 速度と大胆さ (変更の生成と適用がより速く感じられる)、 そして、 インデックス作成機能によって非常に大規模なプロジェクトと連携できる点で、 Windsurfを好む開 発者がいます。 一方、VSCodeユーザーにとっては、 Cursorのインターフェイスの方がなじみがあ るかもしれません。 必ずしもどちらか一方を選ぶ必要はありません。 両方を便利に使っているエン

26 | 1章 序論 バイブコーディングとは何か?

ジニアもいますし、チームでどちらか一方に標準化しているかもしれません。

まとめると、書く前に本当に 「ドキュメントやコードを読んでくれる」 AIコーディングアシスタン トを望むなら、 Windsurfは素晴らしいツールです。 Windsurfはいろいろなことを調べられるため、 関数のハルシネーション (幻覚) や変数名の間違いを最小限に抑えることができます。 この機能を最 大限に活用するには、明確な指示を与えて、 大きなタスクではライトモードで実行します。 しかし、 繊細な変更に対しては、より制御された使い方をしても構いません。 特に重要なコードに対しては、 Windsurfが行った変更を常にレビューしてください。 Windsurfは賢いですが、 完璧ではありませ ん。 賢く使えば、プロジェクト全体を把握し、プロジェクト全体にわたるアイデアを実装できる超知 能を持ったIDEのようになり、 あなたのスループットを大幅に向上させられます*3。

1.5 AI モデル:コード生成の状況

AIのコーディングの状況は、 劇的に変わってきています。 現在、 Claude Gemini, OpenAI の モデルを含む複数の強力なモデルが、 開発者の注意を引くために競合しています。 以前は1つのモデ ルが支配的だったかもしれませんが、 今日のエコシステムは豊富な選択肢を提供しており、 それぞ れが異なるコーディングシナリオに適した明確な強みを持っています。

1.5.1 モデルのカテゴリーを理解する

今日のコーディングモデルは通常、そのアプローチと強みに基づいて、 いくつかのカテゴリーに分 類されます。

最適化された速度

これらのモデルは素早い応答を優先しており、 リアルタイムのコード補完や素早い反復に理想 的です。 通常、複雑なタスクでは精度が若干落ちる代わりに、遅延が短くなります。

深い推論

これらのモデルは、問題を「考え抜く」 ためにより多くの時間を要しますが、 複雑なデバッグ、 アーキテクチャの決定、 多段階の問題解決に優れています。 高度な推論能力を持つモデルは、 複雑なバグを段階的に分解できます。

マルチモーダルの強力なモデル

コードやテキストだけでなく、 画像、 図、さらには動画コンテンツまで処理できるモデルもあり ます。そのため、これらのモデルは、視覚的なドキュメントを理解したり、 UI/UX 要素を扱う のに特に有益です。

*3 2025年7月に、Windsurfは、 (10章で紹介しているコーディングエージェント 「Devin」を開発している) Cognition に買収されました。 この買収の直前に、 Google は、 Windsurf の CEO Varun Mohan, 共同創業者 Douglas Chen ら主要人 材を獲得し、その成果を基にして、2025年11月にAIエージェント対応のIDE 「Google Antigravity」を新たにリリースしま した。

オープンソースの選択肢

1.5 AI モデル:コード生成の状況

27

DeepSeek は、 画像生成やウェブ閲覧機能など、一部の機能が欠けているかもしれませんが、 支払いや登録を必要とせずに、 クローズドソースのモデルに匹敵するレベルのAIの力を提供す ることで、際立っています。

1.5.2 タスクに適したモデルを選択する

成功している開発者は、1つの 「最高」 のモデルを求めるのではなく、現在では特定のタスクにモ デルを適合させています。

素早いプロトタイピングや一般的なコーディングには、速度と幅広い言語サポートに最適化さ れたモデルが効果的です。

複雑なデバッグやシステム設計には、整然とロジックを追跡できる深い推論モデルが適してい ます。

● 大規模なコードベースを扱う場合、 プロジェクト全体の認識を維持できる、 幅広いコンテキス トウィンドウを持つモデルを選択します。

予算重視のチームでは、オープンソースモデルが、サブスクリプションコストのない優れた価 値を提供します。

現在、多くのツールは、 Open Al、 Claude Gemini のバリエーションを含む複数のAIモデルと、 プロプライエタリのモデルをサポートしており、 開発者は手元のタスクに基づいてモデルを切り替え られます。

1.5.3 どのモデルでも使える実践的なヒント

どのAIモデルを選ぶかに関わらず、 一貫性を持って実践することで、結果を改善できます。 まず、 豊富なコンテキストを提供します。 単に「支払い処理関数を作って」と頼まないでください。代わり に、データモデル、既存のコードパターン、エラー処理のアプローチ、具体的な要件を共有します。 提供するコンテキストが多いほど、出力はあなたのコードベースにより合ったものになります。

最新のコーディングモデルのほとんどは、自身の出力をレビューすることに優れています。 生成 されたコードを受け取った後、 潜在的な問題を確認し、改善を提案し、 その推論を説明するように、 モデルに求めます。 多くの場合、この自己批評が、 捉えにくいバグを見つけたり、最適化を提案し たりします。

会話コンテキストを維持するモデルの能力を利用します。 基本実装から始め、その後の要求を通 して徐々に改良します。 多くの場合、この反復アプローチは、 前もってすべてを指定しようと試みる よりも良い結果をもたらします。

各モデルには、問題へのアプローチ方法に微妙な違いがあります。 説明が冗長なものもあれば、 簡潔なものもあります。 新しい構文をデフォルトにするものもあれば、 安全策を採るものもあります。

28 | 章 序論 バイブコーディングとは何か?

これらの傾向を学ぶことで、より良いプロンプトを作るのに役立ちます。

1.6 主なモデル

AIコーディングの状況は毎月進化しており、 定期的に新しいモデルが既存のリーダーに挑戦して います。 競争が激化しているため、 開発者はかつてない選択肢と機能改善から恩恵を受けています。 最も重要なのは、 「完璧」なモデルを選ぶことではなく、 利用可能なあらゆるツールの強みを活用す る方法を理解することです。

現在、多くの開発チームは、 ポートフォリオアプローチを採用しています。 これは、定型タスクに 高速モデルを、 複雑な課題に強力なモデルを、データベースの最適化やフロントエンド開発といっ た特定のドメインに専門モデルを活用するものです。 タスクの途中でモデルをシームレスに切り替え られるIDEもあります。

これらの選択肢を理解し、 戦略的に適用することで、 開発ワークフローを加速させて、 成功がも たらされます。

1.6.1 Google Gemini マルチモーダルコーディングの強力なモデル Google Gemini (https://gemini.google.com) ファミリーは、ネイティブのマルチモーダル機 能を通して、 AI支援開発の根本的な転換を象徴しています。 主にテキストとコードでトレーニング されたモデルとは異なり、 Geminiは、テキスト、コード、 画像、動画、 他のデータ形式をシームレ スに理解して動作するように、 ゼロから設計されました。 そのため、視覚的コンテキストがテキスト 情報と同じくらい重要な最新の開発ワークフローにおいて、 Geminiは非常に強力です。

Gemini のマルチモーダルは、 ウェブ開発のシナリオで特に有益です。 開発者は、デザインモッ クアップのスクリーンショットを共有でき、 Geminiは、 ビジュアルスタイルに一致するピクセル単 位で完璧な実装を生成できます。 Geminiはグラフ、 図, UI要素を理解することに優れており、 ビ ジュアルデザインを機能コードに変換する際の理想的なパートナーになります。 この能力は、単純な 画像認識にとどまりません。 Geminiは、ビジュアル要素を推論し、 デザインパターンを理解し、 プ ロジェクト全体にわたって美的一貫性を維持できます。

Geminiは、 人気のエディター (VS Code, Cursor, Windsurf)、 Cline や Code Assist といっ たプラグインを通して、開発ワークフローと統合されており、開発者は、個人の好みからチーム全 体の基準まで拡張できる強力なカスタマイズのオプションを利用できます。 開発者は、繰り返しのタ スクのためのカスタムコマンドを作成し、 すべてのコード生成に適用される規則を確立し、 大規模 なコードベースにわたって一貫したコーディングパターンを維持できます。 気前の良い無料プランは、 学生、愛好家、スタートアップにGeminiを利用しやすくします。 一方、企業向けの機能は、複雑な 組織要件をサポートします。

コーディングの分野でGemini を際立たせているのは、実用的な速度を維持しながら問題を深く 考える能力です。このモデルは、単純なタスクに対する素早い応答と、 複雑な課題に対する長時間

1.6 主なモデル | 29

の推論を交互に行うことができ、 手元の問題に基づいてアプローチを適応させます。 この柔軟性は、 視覚的理解機能と相まって、 バックエンドロジック、フロントエンドの美しさの両方が等しく重要な フルスタック開発に、特に効果的です。

1.6.2 Claude 推論の名人

Anthropic Claude (https://claude.com/product/overview) のコーディング支援へのアプ ローチは、透明性と深い推論機能を中心としています。 Claude ファミリー、 特にSonnet モデルは、 慎重な分析と段階的な問題解決を必要とする複雑なソフトウェアエンジニアリングのタスクにおいて、 卓越した能力を発揮します。 Claudeを際立たせているのは、その思考プロセスを表示する機能であ り、開発者は解決策を実装する前に、その推論に従ってロジックを検証できます。

アーティファクト機能は、 開発者のAIコーディングアシスタントと対話方法における、パラ ダイムシフトを象徴しています。 単にチャットインターフェイスでコードを提供するのではなく、 Claudeは、コードをリアルタイムで閲覧、編集、 プレビューできる専用ワークスペースを作成しま す。 この対話型環境は、フロントエンド開発、 データ視覚化、 そして、 素早い視覚的フィードバック が開発プロセスを加速させるあらゆるシナリオで、 特に威力を発揮します。 開発者は、 同じ会話の 中で、 設計を反復し、 機能をテストし、 実装を改良できます。

Claude は、 実世界のソフトウェアエンジニアリングベンチマークで、 バグ修正、 機能実装、コー ドのリファクタリングといったタスクで一貫して上位にランクインするなど、 卓越したパフォーマン スを示しています。 Claudeの強みは、コードを生成するだけでなく、 ソフトウェアプロジェクトの 幅広いコンテキストを理解することにあります。 Claude は、 既存のコードベースを分析し、 パター ンやアンチパターンを特定し、 アーキテクチャの改善を提案し、 確立されたコーディングスタイルと の一貫性を維持することができます。 このため、 Claude は、 新規システム開発のプロジェクト、レ ガシーシステムの保守の両方で、 非常に貴重な存在となります。

このモデルのメモリとコンテキスト管理に対するアプローチによって、 長時間のコーディングセッ ションで理解を深めることができます。 大規模なプロジェクトを扱う場合、 Claudeは、コードベー スの構造、設計上の決定、プロジェクト固有のパターンに関する重要な情報を抽出して保持するこ とができます。 この蓄積された知識によって、 開発が進むにつれて、 関連性が高くコンテキストに 沿った提案を提供できるようになります。 これによって、 ステートレスのアシスタントというよりも、 時とともにプロジェクトに精通していくチームメンバーのように感じられるようになります。

1.6.3 ChatGPT 多用途のコーディングコンパニオン

ChatGPT (https://oreil.ly/hZdNC) は、AIコーディングアシスタントのスイスアーミーナイ フとしての地位を確立しており、 専門機能ではなく、卓越した汎用性と幅広い知識ベースで評価さ れています。 開発者ツールキットにおける立場は独特です。他のモデルは、IDEと直接統合したり、 専門コーディング環境を提供したりするのに対し、 ChatGPTは、 開発者が仕事中ずっとブラウザー

30 | 1章 序論 バイブコーディングとは何か?

で開いておく、常に利用可能なプログラミングコンサルタントとして機能します。

ChatGPTの会話型インターフェイスは、 探索的な問題解決や学習に非常に効果的です。 開発者は、 ラバーダックデバッグ、問題のあるコードの貼り付け、 自然な会話での問題解決のために、定期的 にChatGPTを使っています。 ChatGPTは、その豊富なトレーニングにより、 事実上あらゆるプロ グラミング言語、 フレームワーク、 一般的に使われているツールのパターンを認識できます。 正規表 現のデバッグ、不明瞭なエラーメッセージの理解、なじみのないライブラリドキュメントの探索のど れでも、ChatGPTは、その包括的な知識ベースから引き出された関連する知見を提供できます。

ChatGPTの強みは、人の意図とコード実装とのギャップを埋める能力にあります。 自然言語の説 明を動作するコードに変換し、 複雑なコードを平易な言葉で説明するという 「双方向の変換」に優れ ています。 そのため、 ChatGPTは、 ドキュメント作成、 コードレビュー、チーム内での知識の移転 で非常に有益です。 開発者は、なじみのないコードを貼り付けて、その機能の明確な説明を受けた り、望ましい振る舞いを説明して、複数のプログラミングパラダイムにわたる適切な実装を受け取っ たりすることができます。

このモデルの多用途性は、従来のプログラミング言語にとどまらず、 設定ファイル、スクリプト、 データ形式、ドメイン固有言語 (DSL) にまで及びます。 専門コーディングツールは、その焦点を合 わせたドメイン内で優れていますが、 ChatGPTは、 ソフトウェア開発タスクの全領域にわたって有 益な支援を提供します。 この幅広さは、異なる技術問の境界で作業する時や、複数のドメインにま たがる問題に遭遇した時に、 特に役立ちます。 ChatGPTは長時間の会話でもコンテキストを維持で きるため、開発者は、複雑な問題を繰り返し探求し、 協働的な対話を通して解決策を改良できます。

1.7 ニーズに合ったモデルを選択する

これらの強力なAIコーディングアシスタントが利用可能になったことは、 ソフトウェア開発プラ クティスの根本的な転換を意味します。 成功する開発者は、これらのモデルを競合する選択肢と見 なすのではなく、各モデルファミリーが開発プロセスのさまざまな側面に独自の強みをもたらすこ とを認識しています。 Google Geminiは、視覚的コンテキストとマルチモーダルの理解が重要な場 合、 特にUI/UX 開発やデザイン仕様の作業において優れています。 Anthropic Claude は、 深い推 論、複雑なリファクタリング、 透明性の高い問題解決アプローチを必要とするシナリオで輝きます。 OpenAIモデルファミリーは、比類のない多用途性と幅広い知識を提供し、学習、 デバッグ、 ドメイ ン間で共通の課題に理想的です。

現在、多くの開発チームはポートフォリオアプローチを採用しており、同じプロジェクト内の異な るタスクに異なるモデルを活用しています。 典型的なワークフローでは、デザインモックアップを初 期実装に変換するために Geminiを使い、 複雑なアーキテクチャの決定やコードレビューに Claude を使い、一般的な問題解決やドキュメント作成にChatGPTを使います。 この複数モデルアプローチ

*4 訳注:開発者がアヒルのおもちゃ(ラバーダック) に向かってコードの内容を説明しながら、自分の考えを整理し、問題を特 定する手法。

1.8 バイブコーディングの利点と限界 微妙に異なる見解 | 31

は、各ツールの強みを特定の開発課題に合わせることで、 生産性を最大化します。

これらのモデルが進化し続ける中、 効果的なAI 支援開発の鍵は、1つの「最高」の選択肢を選ぶこ とではなく、ソフトウェア開発ライフサイクルのあらゆる側面を加速させて強化するために、 複数の AIアシスタントをオーケストレーションする方法を理解することにあります。

このエコシステムは若く、 急速に変化しています。 数か月ごとに、 新しい企業や機能が登場しつ つあります。 重要なのは、 意図を持ったプログラミングを活用するために、ゼロから独自のAIを構 築する必要はないということです。 この力を手軽に活用できるようにするツールが、豊富に揃ってい ます。 本書では、さまざまなプラットフォームと、 それらがバイブコーディングのワークフローにど のように合うのかについて説明します。

1.8 バイブコーディングの利点と限界 微妙に異なる見解

AI支援開発が真に輝くシナリオと、まだうまくいかないシナリオを認識することが重要です。 バ イブコーディングが得意とする理想的なユースケースと、 今日のAIがまだ苦戦を強いられている あるいは、人の介入が必要な状況を探ってみましょう。

1.8.1 バイブコーディングの理想的なユースケース

特定のアーキテクチャが特定の問題に適しているように、 バイブコーディングには、ソフトウェア 開発における 「スイートスポット」 があります。

1.8.1.1 ゼロからのプロダクト開発

バイブコーディングは、まったく新しいプロジェクトを軌道に乗せるための画期的な転換点です。 (ピーター・ティールによって普及した) 「ゼロトゥワン」という言葉は、 ゼロから新しいものを作成 することを指します。 AIを使えば、真っ白なキャンバスから機能するプロトタイプまで、超高速で 進められます。 今までにないウェブアプリを立ち上げる必要がありますか? プロンプトで指示する 熱狂的なセッションで、フロントエンドからバックエンド、 データベーススキーマ、 デプロイスクリ プトまでのボイラープレートコードを生成できます。 これは、アイデアを素早く検証することが目的 のスタートアップやハッカソンプロジェクトに最適です。 プロジェクトの「スキャフォールディング」 (足場作り) のセットアップ (繰り返しのセットアップコード) に何週間も費やす代わりに、AIにそれ を数分でやらせることができます。

多くの開発者は、AIペアプログラマーの助けを借りて、週末にMVPを構築したと語っています。 これは、以前なら1人で1か月かかっていたかもしれないことです。 アイデアを素早く動作するプ ロダクトにすることで、ユーザーや利害関係者とのテストをより早く始められます。 AIは一般的な こと(ルーティングの設定、 基本的なUIコンポーネント、 標準的なCRUD操作) に優れているため、 あなたはプロダクトの新しい側面に集中できます。

しかし、MVPが軌道に乗り、 製品化に向けて動き出すと、 アプローチを変えなければなりませ

32章 序論 バイブコーディングとは何か?

ん。 ここでは、 AI 支援エンジニアリングが不可欠となります。 バイブコーディングは素早い探索と 検証に役立ってきましたが、スケーリングにはより慎重なプラクティスが必要です。 素早く生成さ れたコードを適切なエラー処理でリファクタリングし、包括的なテストカバレッジを追加し、 明確な アーキテクチャ境界を確立する必要があります。 プロトタイプからプロダクトへの移行は、バイブ コーディングの探索的な自由からエンジニアリングの構造化された規律への、 自然な進化を意味し ます。 賢いチームはこの転換点を認識し、 それに応じてAIの使い方を調整し、 持続可能な成長に必 要なガードレールを導入しながらベロシティ (開発速度) を維持します。

1.8.1.2 機能のプロトタイピングとCRUDアプリケーション

ソフトウェアエンジニアリング、 特にビジネスアプリの多くは、データのCRUD (作成、 読み取り、 更新、削除) 機能を伴います。 これは定型作業であり、 AIは数え切れないほどの例を見てきたた め、これを非常に得意としています。 例えば、システムに CRUD画面とAPIを備えた新しい「在庫」 モジュールを追加する必要がある場合、 バイブコーディングはそれに非常にうまく対処します。 AI は、データベースマイグレーション、 ORM モデル、 API エンドポイント、 検証エラーを備えたUI フォーム (基本的にフルスタック) をエラーなく作成できます。 これは、これらのパターンがトレー ニングデータで非常に一般的だからです。 アプリにカスタム規則がある場合でも、プロンプトでそれ らを指定すれば、 適切な初回実行が可能です。 その結果、 1週間にわたる退屈な配線タスクが、 プロ ンプト作成とテストの午後で済むようになります。 (基本的に大きなCRUDアプリである) 内部ツー ルや管理パネルについては、通常、 非常に単純ながら時間がかかるため、ほぼ完全にAIに頼って、 これらを生成するでしょう。

これらのCRUD操作が、 複雑なビジネスロジック データ検証規則、 既存システムとの統合を含 む場合、エンジニアリングのアプローチが重要になります。 バイブコーディングは基本構造を素早く 生成できますが、 AI 支援エンジニアリングは、 在庫モジュールが同時更新のようなエッジケースに 適切に対処し、参照整合性を維持し、組織の確立されたパターンに従うようにします。 例えば、バ イブコーディングを使って初期のCRUDの足場を生成し、その後、エンジニアリングモードに切り 替えて、 在庫しきい値アラート、 複数倉庫割り当てロジック、 既存の認証認可システムとの統合と いった、ドメイン固有の規則を実装するかもしれません。重要なのは、素早い生成から慎重な改良 に移行するタイミングを見極めることです。

1.8.1.3 グルー (つなぎ) コードと統合

2つのサービスやAPIを統合する必要がありますか? 多くの場合、 ドキュメントを読み取り、 あ る形式から別の形式にデータを変換するコードを書きます。 AIモデルはAPIドキュメントやコード 例でトレーニングされていることが多く、 統合作業を素早く行えます。 ChatGPTに、サービスAの APIを言語Bから呼び出す方法を教えてほしいと頼めば、適切なエンドポイントや認証の例を含む サンプルコードを生成してくれるでしょう。 AIが対処すべきボイラープレートやエッジケースを提 案できるなら、(決済ゲートウェイの注文システムへの接続、サードパーティの分析 SDKの接続と

1.8 バイブコーディングの利点と限界 微妙に異なる見解 | 33

いった) 複数のシステムを組み合わせることが簡単になります。 AIモデルは、こういった標準的な統 合パターンに優れています。

1.8.1.4 最新のフレームワークの活用

AIコーディングアシスタントは、すべての人気のフレームワークのマニュアルを効果的に読み 取っています。 React, Angular, Django、 Rails, Node.js/Express Flutterなど、 何もかも です。 つまり、あなたが有名なフレームワークを使っているなら、 AIはそれらのフレームワーク用 の慣用コードを生成できます。 例えば、フックとステート管理を備えた新しい React コンポーネント や、適切な管理クラスとシリアライザーを備えた新しいDjangoモデルを生成できます。 利点は、細 部まで覚える必要がなく、AIがギャップを埋めてくれることです。 バイブコーディングは、適切な クラスでのHTML/JSXの生成、コントローラーエンドポイントのフックといった、 最新のウェブ開 発タスクで、特にうまくいきます。 これらは、 AIモデルが何度も見てきたタスクだからです。 これ は、フレームワークの専門家が常にあなたの側にいて、 あなたがその機能が何をすべきかを具体的 に決めている間に、その専門家がボイラープレートを書いてくれるようなものです。

1.8.1.5 繰り返しのコード生成

時には、(スキーマの型ごとの多くの類似したエンドポイントやクラスといった) 類似したコード をたくさん作成する必要があります。 これは人にとっては退屈であり、エラーになりやすいもので す。 一方、 AIは繰り返しの構造が大好きであり、 あなたが1つか2つの例を見せれば、あとはAIが 一貫して量産できます。 この一括コード生成によって、時間を大幅に節約できます。 例えば、 50種 類のレコードのデータモデルクラスを書く場合、プロンプトで1つの例を示し、そのパターンに従っ て50種類すべてのクラスを生成するように、 AIに頼めます。 AIは、おそらく数秒で完璧に生成する でしょう。その結果、 単調なコーディングに丸一日を費やす必要がなくなります。

1.8.1.6 AI支援エンジニアリングを優先すべき場合

バイブコーディングが得意とするシナリオがある一方で、 AI支援エンジニアリングが不可欠とな るシナリオもあります。 開発者は、このような状況を理解することで、最初から適切なアプローチを 選択でき、コストのかかる書き換えや技術的負債を避けられます。 複雑なアルゴリズムの実装には、 エンジニアリングアプローチが必要です。 高度なデータ構造を構築したり、パフォーマンスが重要 なアルゴリズムを実装したり、 新しい計算問題を解決したりする場合、 実装のあらゆる側面を正確 に制御する必要があります。

この場合、 AIはコードジェネレーターではなく、知識豊富なアシスタントの役割を果たします。 あなたは、アルゴリズムのアプローチの説明や、実装の正しさのレビューをAIに頼むかもしれませ んが、アーキテクチャや最適化の決定を直接制御します。 AIは、問題を解決するのではなく、問題 を通して考える手助けをするのです。

ミッションクリティカルなシステムには、最初からエンジニアリングの厳密さが求められます。 金

| 1章 序論 バイブコーディングとは何か?

融取引、医療アプリケーション、セキュリティ基盤、他の重要なドメインでは、 バイブコーディング の探索的な性質は許されません。 このような状況では、コードの各行に慎重な検討、包括的なテス ト、そして多くの場合、 規制順守が必要となります。 AIは、ベストプラクティスを提案し、潜在的 な脆弱性を特定し、 基準の順守を保証することで支援しますが、 開発者は実装を厳密に制御します。

このようなシステムで失敗した場合のコストは、素早い生成による速度の利点をはるかに上回りま す。レガシーシステムの統合は、エンジニアリングの規律が不可欠であることを証明する独自の 題を示しています。 何十年も前のコードベース、 独自プロトコル、 技術的負債が大きいシステムを 扱う場合、 バイブコーディングのパターンマッチングはしばしば失敗します。 このようなシナリオで は、既存の制約を深く理解し、 統合点を慎重に計画し、整然とリファクタリングする必要があります。 AIは、レガシーコードパターンの説明や、モダナイゼーション戦略の提案で助けになりますが、実 際の実装には、構造化エンジニアリングだけが提供する正確さが必要です。

パフォーマンス最適化もまた、 エンジニアリングがバイブコーディングに勝るドメインです。 AI は機能するコードを素早く生成できますが、 パフォーマンスが重要なパスにとって最適な解決策を 生み出すことはほとんどありません。 メモリ管理、 キャッシュ最適化、 並列処理、 遅延低減などのタ スクでは、ハードウェア、 OS、 アルゴリズムの複雑さについて、深く理解する必要があります。 こ のような場合、 AIは、 研究アシスタントとして最適化テクニックの探求や異なるアプローチのペン チマークを支援する一方で、 あなたが実装について十分な情報を得た上で意思決定を行います。

このようなシナリオでは、AIのパターン認識と速度が、 タスクに完璧に合っています。 基本的に、 バイブコーディングは、 (CRUD、 典型的なウェブアプリの構造といった) プログラミングで踏みな らされた領域や、(プロトタイプ、 新しいアイデアといった) 素早い試行錯誤から利点が得られるタ スクでうまくいきます。 これは、 GitHubのすべてのリポジトリを読み、 通常どのように行われてい るかをすぐに思い出し、 レビューのためにあなたに代わって書くことができるジュニア開発者がいる ようなものです。 これは、物事を素早く進めるためには、信じられないほど強力です。

1.8.1.7 移行点を認識する

最新のAI拡張開発の極意は、1つのアプローチを選択することではなく、 「それらの間を移行する 「タイミング」 を認識することにあります。 成功する開発者は、こうした移行点の直感を身につけてい ます。 新機能を始めますか? 素早く可能性を探るために、 バイブコーディングから始めます。 コー ドが複雑になってきたり、重要なシステムに触れたりすることに気付きましたか? エンジニアリン グモードに移行します。 顧客デモ用の概念実証 (PoC) を構築しますか? バイブコーディングを使え ば、すぐにできます。 そのPoCを本番システムに変換しますか? エンジニアリング規律の出番です。 この流動性、 つまり、素早い探索と慎重な構築との間をシームレスに行き来できる能力が、真に

効果的なAI拡張開発者の特徴です。 彼らは、バイブコーディングとAI支援エンジニアリングが、 そ れぞれ開発ライフサイクルの異なる段階に適した、 ツールキット内の補完ツールであることを理解し ています。 目標は、どちらか一方を選ぶことではなく、 両方のアプローチを戦略的に活用し, ソフト

34

1.8 バイブコーディングの利点と限界 微妙に異なる見解 | 35

ウェア開発プロセスを通してベロシティと品質の両方を最大化することです。

1.8.2 AI がまだ苦労している点

現在のAIコーディングツールは素晴らしいものですが、 魔法ではありません。 AIが確実に対処す ることがまだ難しい問題の種類も存在しており、多くの場合、 人の知見や伝統的なコーディングテ クニックを必要とします。 これらの限界を知ることで、 適切な期待値を設定し、いつ積極的に関わる べきか、いつ手綱を引いて調整すべきかを計画できるようになります。

限界には、次のようなものがあります。

非常に複雑なシステム

非常に複雑なアルゴリズムや、AIが見たこともないような新しい問題を扱っている場合、 AIは 苦しむ可能性があります。 例えば、研究論文にあるようなまったく新しいアルゴリズムを書いた り、コンパイラーや同時実行性の高いシステムを書いたりすることです。 これらは複雑なロジッ クを含むため、真の理解と、多くの場合、 創造的な飛躍を必要とします。 AIは試みることはで きますが、物事を微妙に間違えてしまうかもしれません。

このような複雑なドメインでは、AIは大体正しいが正確には正しくないコードを作る傾向があ るため、何度も繰り返すことになりがちです。 「3章 70% 問題: 実際に動作するAI支援ワー クフロー」、 「4章 70%を超えて: 人の貢献を最大化する」で説明するように、 最後の30%程 度の正しさは、AIにとって見極めるのが非常に難しいものです。 これは、私が「70%問題」 と呼 んでいるものに関連しています。 AIは、 大部分を素早く解決してくれますが、最後の部分は難 しいのです。 経験豊富な開発者は、このような複雑なタスクのスケルトンやヘルバー関数を生 成するためにAIを使うかもしれませんが、中心的なロジックは自分で行います。

低レベルの最適化とシステムプログラミング

現在のAIモデルは、主に高級言語と抽象化についてトレーニングされています。 低レベルのビッ トをいじったり、 特定のマイクロコントローラー向けに高度に最適化されたCコードを書いた り、ベクトル化されたSIMD命令を生成したりする必要がある場合、 AIは信頼できないでしょ う。もっともらしく見えるが、ハードウェアレベルでは本当に最適ではない、あるいは正しくな いコードを生成するかもしれません。

同様に、メモリ管理やリアルタイム制約のようなものに関しても、AIは、それらの実際の概念 を持っていません(内でCPUキャッシュをシミュレートしていません)。 そのため、パフォー マンスが重要なコードについては、AIの提案を徹底的にテストするか、それらの部分を手動で 書くことになります。 とはいえ、 AIは開始テンプレートの提供やアセンブリの説明で役立つか もしれませんが、これらのシナリオでAIを盲目的に信頼することはできません。

36 | 1章 序論: バイブコーディングとは何か?

独自の、あるいはニッチなフレームワーク

AIのトレーニング中に存在しなかった、 非常に新しい、あるいは無名のフレームワークを使っ ている場合、 AIはそれを知りません。 そのような場合、 AIは一般化しようとする、 あるいは、 合っているように見えるが実際には存在しない関数を呼び出したり(ハルシネーション)、旧バー ジョンのAPIを使ったりするコードを生成したりするかもしれません。 例えば、 先月、 ウェブフ レームワークの新バージョンが出て、 破壊的変更があった場合、 AIはそれらの変更を知りませ ん。 AIは、 旧バージョンのコードを生成するかもしれません。 このような場合、 ドキュメント に頼るしかありません。 おそらく、 あなたのプロンプトで、 ドキュメントからのコンテキストを AIに与えることで、AIのトレーニングを助けなければなりません (基本的には、 その場で教え ています)。

創造的なUI/UX デザイン

完全に新しいユーザーインターフェイス、ユーザー体験を設計するようAIに頼む場合、 AIはそ の創造的な飛躍を得意としていません。 AIは、 (標準的なフォームやダッシュボードといった) 既知のパターンのUIコードを生成できますが、 明確な前例がない革新的なUIを求める場合、 AIは感動的なものを与えてくれないでしょう。 見慣れたコンポーネントをつなぎ合わせるだけ かもしれません。 新しいユーザー体験を考え出すためには、人のデザイナーやフロントエンド開 発者がまだ必要なのです。 コーディング用語で言えば、AIは標準的な外観のインターフェイス を素早く作れますが、 特別なカスタム感を出したいなら、 自分で導いたり手動で微調整すること になります。

意図と要件の解釈

要件が暗黙的だったり矛盾していたりすると、 AIは苦労することがあります。 AIは、 あなたが 明示的に伝えた以上の最終目標について、真の理解を持っていないのです。 要件が曖昧な場合 (「効率的にする」とは、正確には何を意味していますか?)、 AIは、 あなたが何を気にしている のか (例えば、メモリか速度か)を誤って推測してしまうかもしれません。 人は、 特に非技術的 な利害関係者に対しては、 意図を明確にすることに長けています。 また、 AIは、特に (ビジネ ス規則といった) ドメイン固有のコンテキストを知らない場合、 指示を誤って解釈することがあ ります。 変換中にニュアンスが失われたため、 AIは、論理的には正しいが、 実際には本当の問 題を解決していない解決策を生成するかもしれません。

例えば、 新しい3Dグラフィックスエンジン (複雑なシステム) をRust (システムレベル、バ フォーマンスが重要) で開発するシナリオを考えてみましょう。 レンダリングのための新しいアルゴ リズム(独自の問題)があります。 AIはボイラープレートの作成を助けてくれるかもしれませんが、 中心部は人の創意工夫に頼ることになります。 AIは、 ウィンドウと基本的なレンダリングループ(一 般的なタスク) のセットアップから始めるかもしれませんが、 特注の部分については、 従来の慎重な

1.8 37

バイブコーディングの利点と限界 微妙に異なる見解 |

コーディングを進め、おそらく擬似コードの形で、 AIからアルゴリズムの助けを借りることになる でしょう。 また、 アセンブリでホットループの最適化をAIに頼んだ場合、 すべての命令を検証しな ければなりません。

また、AIには、真の問題解決に対する知見も欠けています。 結局は、 パターンマッチングなので す。そのため、問題に 「あっ!」というひらめきが必要な場合、 AIはただ右往左往して、 コードのよ うなものを提示するだけで、 問題解決には至らないかもしれません。 そこで、 人が一歩下がって抽 象的に思考したり、 実際の経験を生かすことで、窮地を脱することができます。 知見が得られれば、 あとはAIを使って素早く実装できます。

これらの強みと弱みを理解することで、 適切な状況でバイブコーディングのテクニックを展開でき ます。 最大限の成功を収めるには、AIが得意とすること (既知のパターン)にAIを活用し、アプリ ケーションに独自の部分にあなたの創造性を発揮します。 AIが苦手とする分野には、 介入できるよ うにしておきます。 例えば、 AIはエッジケースの1つや2つを見逃すかもしれないので、 AIが書く セキュリティ上重要なコードを注意深くレビューします。

人の強みを補うために、 AIを使います。 AIに幅広さ (多くのコード、 ボイラープレート)を任せる 一方で、 あなたは深さ (複雑なロジック、 アーキテクチャ) に対処します。 AIが得意とするところで はAIをブースターとして使い、困難な道ではあなたが恐れずにハンドルを握ります。 そうすること で、両者の強みが発揮され、 最高の成果が得られます。 AIを使うべき時と、 人のスキルに頼るべき 時を知っていることで、この新時代に、 あなたは非常に効果的な開発者になれるのです。

どんな新技術にも、利点と注意点があります。 AI支援開発による生産性と創造性の向上を受け入 れるには、その限界とトレードオフを丁寧に理解した上でアプローチすることが重要です。 主な利 点は、以下の通りです。

より高速な開発サイクル

プロジェクトは、概念からプロトタイプ、完成品まで、より素早く進めます。 AIは (新しいプロ ジェクトのボイラープレートのセットアップといった) スキャフォールディングコードをすぐに 生成できるため、アプリケーションに独自の部分に多くの時間を費やせます。

プロトタイピングと実験の強化

何かを試すコストが低いため (AIに欲しいものを説明するだけで、 すぐに下書きを得られま す)、開発者はより自由に実験できると感じるでしょう。 さまざまな方法でAIにプロンプトで指 示することで、問題に対する複数のアプローチをプロトタイピングし、最適なものを選べます。 このように繰り返しアイデアを考えることは、 より創造的な解決策につながります。

すぐに利用できる知識

LLMは、 膨大なプログラミング知識のコーパスでトレーニングされています。 多くの場合、 LLMは、 曖昧なAPIやエラーメッセージの解決策を 「知って」います。 実際には、LLMはあな

38 | 1章 序論 バイブコーディングとは何か?

たが思いつかなかったような解決策やアイデアを浮かび上がらせ、 あなたをより効果的に問題 解決できる人にします。

一貫性と標準化

チーム環境では、AIアシスタントは、一貫したスタイルでコードを生成することで、 コーディ ング基準やベストプラクティスを施行するのに役立ちます。 プロジェクトのスタイルガイドで構 成すれば、全員のコードが類似のパターンに従うようにできます。 (何百万もの例から学習した ため) 明示的なトレーニングがなくても、 多くの場合、 AI モデルは慣用コードを生成します。 こ れによって、 コードレビューにかかる労力を軽減できます。 なぜなら、 そのコードは見慣れたも のであり、デフォルトで一般的な慣習に従っているからです。

考慮すべき限界、トレードオフをいくつか挙げます。

変わりやすい出力品質

これらのモデルは完璧ではありません。 正しいように見えるものの、微妙なバグや非効率性を 含むコードを作成するかもしれません。 トレーニングデータに多くの古いコードが含まれている ため、時代遅れのアプローチを選択するかもしれません。 開発者として、 あなたは警戒を怠ら ないようにしなければなりません。 インターネット上のコードを理解せずにコピー&ペースト しないのと同様に、AIコードも軽率に受け入れてはなりません。 本書の 「Ⅱ部 AIコーディン グの実践」 では、AIが生成したコードを徹底的に検証しテストするテクニックについて説明し ます。

プロンプトの曖昧さがコードの曖昧さにつながる

プロンプトの仕様が不十分な場合、 AIはあなたの意図を推測しなければならず、 間違った推測 をするかもしれません。 例えば、 あなたが 「名前のリストをソートして」と言った場合、 デフォ ルトではアルファベット順にソートされるかもしれませんが、 (名前の長さでのソートといった) 別の意味だったのかもしれません。 あなたがそれを明確にしない限り、 AIはその違いがわかり ません。 これが、プロンプトの具体性 (「2章 プロンプトの芸術 AIと効果的にコミュニケー 「ションする」のトピック) が重要な理由です。 どんな細部を明確に伝える必要があるか、 予測で きるようになります。

過度の依存とスキルの退化

新人開発者が常にAIに頼ってコードを書いていたら、 彼らはアルゴリズムやデバッグについて 同じように深く理解できるようになるでしょうか? ナビゲーションをGPSに頼っていると自分 の方向感覚が鈍ってしまうのと同様に、スキルが退化してしまう危険性があります。 これを 和するには、AIを学習ツールとして使い (AIが提供するコードに注意を払い、 その理由を質問 します)、 時にはAIなしでコーディングを実践することで、 基礎スキルを確実に維持することが 重要です。

1.9 まとめと次の一歩 |

プライバシーとセキュリティの懸念

クラウドベースのAIコーディングツールの使用は、 多くの場合、 (プロプライエタリ、 あるいは、 機密かもしれない) あなたのコードを分析のためにサードパーティサービスに送信することを意 味します。 企業は、これを考慮する必要があります。 多くのツールは、オンプレミスモデルを許 可したり、コードを保存しないことを保証したりすることで対応していますが、それでも考慮し なければなりません。 また、 AIがトレーニングデータに含まれる何かと非常に類似したコード をうっかり生成してしまうリスクもあり、 それが (GPLなどの) オープンソースライセンスで公 開されている可能性があります。 可能性は低いですが(そして、長い逐語的な出力を防ぐための 対策が講じられています)、 AIを統合する前に、AIが生成するものをレビューして理解する必 要性が浮き彫りになりました。 「8章 セキュリティ、 保守性、信頼性」 は、 セキュリティと信頼 性の問題に踏み込んでいます。

AI出力のバイアス

AIモデルは、 トレーニングデータに存在するバイアスを反映する可能性があります。 コーディ ングでは、これは特定の変数名を好むような無害なものかもしれないし、 特定のユーザー属性 を想定した例を使うような重大なものかもしれません。 例えば、 (多くのサンプルがそうだった ため) すべてのサンプル変数に foo / bar を使い、 あるいはユーザーロケールについて何か仮定す るかもしれません。 他のAIアプリケーションに比べれば、 通常、 コード生成において大きな問 題になることはありませんが、この可能性を認識しておく価値はあるでしょう。もっと微妙なこ とですが、 AIは、 それがあなたのケースに最適でなくても、より頻繁に目にする解決策に偏る かもしれません。 「9章 バイブコーディングの倫理的課題」では、バイアスや他の倫理的な考 慮事項について議論します。

個人的要因と信頼

すべての開発者が、すぐにこのような仕事のスタイルになじめるわけではありません。 コーディ ングにはある種の喜びと芸術性がありますが、 AIが関与することでそれが損なわれると感じる 人がいるかもしれません。 また、 「本当に正しくできたのか?」というような、 初期の信頼の欠 如もあり得ます。 これは、 良いプラクティスと時間をかけることでしか克服できません。 AIを 採用するチームは調整期間を設け、経験やヒントの共有を奨励すべきです。 どんなツールでも そうであるように、時とともにほとんどの人は、AIの貢献が有益なところと、人の専門知識が 人が最も得意とすることに集中するところとのバランスを見つけ出すでしょう。

1.9 まとめと次の一歩

意図を持ったプログラミングへのパイプシフトは、ソフトウェア開発をより速く、 より近づきやす く、多くの点でより楽しくする大きな可能性を秘めています。 しかし、その可能性を実現するには、

39

40 | 1章 序論 バイブコーディングとは何か?

新たな状況を理解する必要があります。 AIと効果的にコミュニケーションする方法、 AIの出力を検 証する方法、責任を持ってAIを開発プロセスに統合する方法などです。

これらのツールを使い、 多くのプロジェクトを観察してきた私の視点によれば、 AIの最良の活用 法は、創造的な「バイブス」 と確かなエンジニアリングの衛生管理を組み合わせることにあります。 AIが提供できる野性的なアイデアや迅速な下書きを奨励します。 それらは、私たちが自由に使える 新しい強大な力です。 しかし、 ソフトウェア開発が何十年もかけて蓄積してきた英知、 つまり、計 画、テスト、そして何を作るかの理解の重要性とともに、それらを活用するのです。

そのバランスを取ることで、私たちは両者の長所を生かせます。 より速く、 より独創的に構築され たソフトウェアを得られるだけでなく、私たちが自信を持って信頼し、維持し、成長させることがで きるソフトウェアを得られるのです。 結局のところ、 それこそが、 エンジニアリングよりもバイブを 選ぶことでもその逆でもなく、その間のすべてを習得することで、 AI時代において私たちの技術を 高める方法なのです。

次の「2章 プロンプトの芸術 : AIと効果的にコミュニケーションする」では、プロンプトの作成 とAIとの協働の技術について探求します。 本章の基礎概念を頭に入れれば、この新しいプログラミ ング時代の実践的な側面を探求する準備が整ったことになります。 これは、以降の章での実践的な 例や、より深いプロンプティングのテクニックの土台となります。

| 41

2章

プロンプトの芸術:

AIと効果的にコミュニケーションする

バイブコーディングでは、プロンプトは新しいソースコードです。

あなたの意図をAIに伝える方法は、 AIが生成するコード品質に直接影響を与えます。 優れたプロ ンプトを書くことは、 芸術であると同時に科学でもあり、 よく 「プロンプトエンジニアリング」と呼 ばれます。 本章では、AIコーディングアシスタントを最大限に活用するためのテクニックを紹介し ます。 なぜプロンプトが重要なのかという基礎から始め、 単純なものから高度なものまで、 プロンプ トテクニックのツールボックスを掘り下げていきます。 効果的なプロンプトを作成する方法と、それ を繰り返し改良する方法 (図2-1) を学ぶことで、より効率的かつ正確にAIと共同作成できるように なります。

プロンプト 配列の合計を求める | Python関数を作成して プロンプト AIの応答 def sun_array(arr): return sun(arr) AIの応答 単体テスト def test sun array(): を追加して assert son array 1, 2, 3, 4, 5 1)-15 assert sun_array()) assert sun_array([7]) 7

2-1 チャットボットによるコーディング支援の例。 開発者とAIは対話を行う。 開発者は指示や質問 (プロンプト) を 提供し、AIはコードや回答で応答する。 よく練られたプロンプトを通してAIと効果的にコミュニケーションす ることが、正確で有益なコード生成を得るための鍵となる。

42 2章 プロンプトの芸術 AIと効果的にコミュニケーションする

2.1 プロンプトエンジニアリングの基礎

バイブコーディングがあなたとAIモデルとの会話なら、「プロンプトエンジニアリング」 は、 最高 の結果を得るためにAIの言語を話すスキルです。 よく練られたプロンプトが、無関係またはバグだ らけのコード提案と完璧な解決策との違いを生み出します。 プロンプトエンジニアリングを習得す ることは、 AIを効果的に導く方法、 コンテキストを提供する方法、 最初の回答がまったく正しくな かった場合にAIと反復作業する方法を理解することを意味します。

あなたがAIを使ってプログラミングする時、本質的に自然言語を使ってAIを 「介して」プログ ラミングしていることになります。 あなたが提供するプロンプトは、AIインタープリターが実際の コードに変換する、高レベルのプログラミング言語のようなものです。 コンパイラーの出力が入力さ れたソースコードの質に依存するのと同様に、AIの出力もプロンプトの質に依存するのです。

なぜ、プロンプトが重要なのでしょうか? LLMは、いくら高度でも人の心を読むことはできませ ん。与えられた入力にのみ応答します。 曖昧なプロンプトや言葉足らずのプロンプトは、無関係な コードや間違ったコードにつながる可能性があります。 一方、明確で具体的なプロンプトは、最初の 試みで的確な解決策を生み出す可能性があります。 従来のコーディングでは、アルゴリズムについ て考え、コードを書くことに時間を費やしますが、 バイブコーディングでは、 AIに要件を伝える方 法を考えることに時間を費やします。 これは 「コードを書く」ことの意味を転換するものです。 あな または関数の代わりに段落を書くかもしれませんが、依然として正確で論理的である必要があります。

プロンプトを書くことは、非常に融通が利かない、 知識をひけらかすジュニア開発者のために、ド キュメントやユーザーストーリーを書くようなものだと考えてください。 彼らは、ドキュメントに書 かれていることを正確に (そしてそれだけを) 実行し、 多くの知識は持っていますが、見たことのあ るパターン以上の常識は持ち合わせていません。 あなたの指示 (プロンプト) に解釈の余地がある場 合、 AIは、あなたの意図しない方法でギャップを埋めるかもしれません。 従って、 AIとの 「コミュ ニケーション」を学ぶことは、かつてプログラミング言語の構文を学んだのと同じくらい重要なので す。

プロンプトが重要なもう1つの理由は、 再現性と将来性です。 あるパターンやタスクに対して確実 に良いコードを生成するプロンプトを見つけた場合、 そのプロンプトは貴重な知識の一部となります (ほとんどスニペットやテンプレートのようなものです)。それを保存し、 類似の状況で再利用できま す。チームでは、コーディングのベストプラクティスを共有するのと同様に、 開発者たちが効果的な プロンプトパターンを共有するでしょう。

最後に、モデルがより良くなり、 より統合されるにつれて、より複雑な対話が可能になるかもしれ ません。 プロンプティングが得意になると、 新機能を素早く利用できるようになります。 例えば、高 度なシステムには、モデルのコンテキストの一部として、幅広い指示を添付したり、 参照ドキュメン ト全体を提供したりできるものもあります。 そのような力を活用するためには、入力をどのように構 造化するかを知ることが重要です。

従って、プロンプトを書くことを新たな必須スキルとして扱います。 多くの点で、プロンプティン

2.2 具体性と明確さ 伝わるプロンプトを書く |

43

グ「は」 プログラミングです。 主な違いは、 (英語などの) 自然言語で書き、AIがそれをコードに変 換することです。 しかし依然として、明確で、論理的で、 エッジケースを想定した説明をしなけれ ばなりません。

2.2 具体性と明確さ 伝わるプロンプトを書く

(「3章 70%問題: 実際に動作するAI支援ワークフロー」で詳しく説明する) プロンプトの黄金 律の1つは、あなたが何を望んでいるかを具体的かつ明確にすることです。 人の協働者とは異なり、 AIは、あなたが提供した言葉以上に、 あなたの目標を真に理解しているわけではありません。 よく ある間違いは、AIに「ウェブサイトを作って」といった非常に高レベルのプロンプトを与え、 魔法を 期待することです。 AIは、 具体的な詳細がある方がうまくいきます。

AIは、 あなたが提供したこと以上については、 何も知らないと思ってください。 プログラミング 言語、 フレームワーク、ライブラリ、 問題の特定の機能やスニペットなど、 関連する詳細を含めます。 エラーがある場合、 正確なエラーメッセージを提供し、 そのコードが何をすることになっているのか を説明します。 曖昧さや解釈の余地があると、 意図しない出力につながる可能性があります。

例えば、「ソート関数を書いて」 ではなく、 次のように言います。

(それぞれがfirst_name, last_name フィールドを持つ) 顧客レコードのリストを受け取 り、 last_name をアルファベット順にソートしたリストを返す、 Python 関数 sort_by_ lastname (customers) を書いて。 簡単なdocstring を含め、 空の文字列として扱うことで、姓が ない場合に対処して。

このプロンプトは、 言語 (Python)、 関数名と目的、 入力構造、 ソートキー、 追加要件 (docstring)、エッジケースについて明確な期待を設定しています。このプロンプトは、あなたが必 要とするもの、もしくはそれに近いものを生成する可能性が高いでしょう。 基本的に、 仕様書作成 者のように考えてください。 あなたがタスクをより正確に指定するほど、AIが行う推測作業は減り、 修正の回数も減ります。

具体性のための戦略には、次のものがあります。

言語や環境について言及する

JavaScript で解決策を作りたい場合、単に「関数を書いて･･･」と言うのではなく、 「JavaScript 関数を書いて･･･」と言います。 特定のフレームワークやバージョンに対応させたい場合、 (「React フックを使って・・・」 や 「Python3で･･･」 のように) その旨を含めます。

出力の範囲を定義する

1つの関数が欲しいですか? ファイルやモジュール全体ですか? テストも含みますか? 例え ば、 「関数の実装だけを提供して」 と 「実行可能なスクリプト一式を提供して」では、 応答が異な ることがあります。

442章 プロンプトの芸術 AIと効果的にコミュニケーションする

要件と制約を含める

ログインの例では、パスワードの長さと試行回数の制限を指定しました。 エッジケースや制約を 考え、それをプロンプトに含めます。 コードのパフォーマンスを最適化する必要があったり、 特 定のアルゴリズムを使う必要がある場合、 「O (n) 時間 0 (1) 空間で」 や 「二分探索を使って」の ように言います。

曖昧な参照を避ける

明確な先行詞なしに「それ」 のような言葉を使わないでください。 「それを処理して結果を返す」 の代わりに、 「配列を処理して結果の配列を返す」 と言います。

望ましい出力形式を指定する

AIにコードだけ、あるいはコメントや説明付きのコードを出力させたい場合、 「説明なしで、 コードのみを出力して」 や 「各手順について、 コードと簡単なコメントを提供して」 のように指 示できます。

明確なプロンプトは、AIを成功に導きます。 AIの回答に多くの修正が必要なことが多いとわかっ た場合、プロンプトの指定が曖昧かどうか調べてください

やってはいけないことは、 次の通りです。

小説を書かない

無関係な情報を含む長ったらしいプロンプトは、モデルを混乱させたり、誤ったことに集中させ たりする可能性があります。 説明は、簡潔ながらも完璧にしてください。 例えば、 通常、 コー ディングのコンテキストで 「あなたは世界一流のプログラマーです･･･」と前置きする必要はあり ません (一般的なChatGPTではそうする人もいますが、コーディングタスクでは不要なことが 多く、ノイズになりかねません)。

AIが細部を正しく埋めてくれると想定しない

(スレッドセーフであること、 特殊文字の扱いなど) 何か重要なことがあれば、それに言及しま す。 言及されていない場合、 AIはそれに対処しないかもしれないと想定します。

決定論的な出力が必要な場合、 制約のない 「創造的な」 プロンプトを避ける

例えば、「データを分析するコードを書いて」と言うと、 AIは、 あなたがどんな分析をしたいの かを推測してしまうかもしれません。 代わりに、 こう指定します。

数値のリストの平均値と標準偏差を計算して。

まとめると、 「言いたいことを正確に言ってください」。 AIは、 あなたが本当に望んでいることを 「知っている」 ほど、より良いものを提供できます。 何度もAIの間違いを修正しなければならないこ とに気付いたら、「最初のプロンプトを、より明確にできなかったか?」と自問します。

2.3 反復的な改良 AIとのフィードバックループ | 45

2.3 反復的な改良 AI とのフィードバックループ

プロンプトが明確であっても、最初の試みで常に完璧な回答が得られるわけではありません。 AI との対話を、会話や反復的な開発プロセスとして考えてみます。 これが、 「1章 序論: バイブコー ディングとは何か?」 で触れたフィードバックループです。

AIからコードをもらったら、 人が書いたコードと同様に、批判的にレビューします。 要件を満た していますか? そうでない場合、 何が足りないのか、 何が間違っているのかを特定します。 そして、 フィードバックや改良されたプロンプトを提供します。 会話型AIでは単に対話を続けることで、エ ディターではAIが応答するように別のコメントを書くことで、 これを行えます。

AIにフィードバックを提供することで、 AIを望ましい成果に近づけられます。 ある意味、 AIを特 定の問題に対してその場で「トレーニング」しているのです。 高度なプロンプトエンジニアリングは、 図2-2のループ (満足するまで、 プロンプト AI出力→レビュープロンプトを改良 AI出力 →･･･) のようになります。 プロンプトを見直しすぎると、 前回の出力の良い部分が失われてしまうこ とがあります。

AIの出力 |プロンプト プロンプト の改善 レビュー 満足するまで繰り返す

図2-2 高度なプロンプトエンジニアリングのループ

例えば、次のプロンプトで指示します。

整数のリストを受け取り、それらの合計を返す関数を書いて。

AIは関数を返しますが、そのコードは空でないリストを想定しており、空のリストにうまく対処 できません。 あなたは、次のように返します。

いい感じ。だけど、リストが空の場合、0を返すように修正して。

AIは、それに応じて関数を更新します。 このように、ゼロからプロンプトで指示する必要はなく、 AIに調整するように伝えるだけでした。 AIはすでに、前のコードのコンテキストを持っているので す。

インラインアシスタントを使っている場合、 コードを編集し、 おそらく 「# TODO: 空のリストに対 処する」のようなコメントを書いて、AIがその修正を提案するかどうかを確認します。

46 | 2章 プロンプトの芸術 AIと効果的にコミュニケーションする

もう1つの改良のアプローチは、最初の出力が適切でなかった場合、 より多くの情報のプロンプト で再度指示することです。 例えば、 あなたが「名前のリストをソートして」 と言って、 AIが大文字と 小文字を区別してソートするコードを出力しました。 あなたは、次のように言い換えられます。

大文字小文字を区別せずに、名前のリストをソートして。

または、次のように言い換えられます。

前のコードは、大文字と小文字を区別してソートしています。 大文字と小文字を区別しないように、 修正して。

デバッグでは、 (明らかなエラーメッセージは送出されませんが、 出力が間違っている) より複雑 なロジックのバグの場合、 コード実行を順を追って確認するように、AIにプロンプトで指示できま す。 例えば、次のようにします。

この関数を1行ずつ順を追って確認し、各手順で合計値を追跡して。 正しく累計されていない。 どこで、ロジックが間違っている?

これは、「ラバーダック」 デバッグのプロンプト例です。 基本的に、 人がプリントやデバッガーを 使って行うデバッグプロセスをシミュレートするように、AIに求めています。 このようなプロンプト は、多くの場合、変数がリセットされない、 条件付きロジックが正しくない、 といった微妙な問題を 明らかにします。 コードの特定の部分が疑わしい場合、 ズームインできます。

ここで、フィルタリングの呼び出しが何をしているか、 また、必要以上に多くのいないかどうかを説明して。

項目を除外して

AIに説明の役割を担わせることで、説明のプロセスでバグを表面化させられます。 説明の後は、多くの場合、 必要なものを直接求めるのが効果的です。

何がこの問題を引き起こしている? どうすれば修正できる?

これによって、 AIは、 診断、 解決策の提案の両方を行うようになります。 AIの最初の回答が不明 確だったり、部分的にしか役に立たなかったりした場合、 ためらわずにフォローアップの質問をして ください

その説明は理にかなっている。 コードの修正方法を教えてくれる? 修正し

たコードを提供して。

チャットの場合、AIは会話履歴を持っているので、 修正したコードを直接出力できます。 チャッ トなしで、 VS CodeのGitHub Copilot や Cursorのようなインラインツールを使っている場合、代 わりに、コードの上にコメントを書けます。

// BUG: NaN を返す。 この関数を修正し、どのように自動補完されるか確認

2.4 2つのプロンプトを比較する |

47

しかし、 一般的には、 対話型チャットの方がより詳細な説明が得られます。

もう1つのフォローアップのパターンがあります。 AIが修正を返しても、 あなたが理由がわからな い場合、 次のように質問してください。

なぜ、 その変更が問題を解決するのか、説明できる?

こうすることで、あなたは次回のために学び、AIの推論が正しいことを再確認できます。 LLMは、例と修正で成長します。 あなたが間違っている点を指摘したり、 簡単な例を挙げたりす れば、AIはそれを取り入れられます。

input が [] の場合、0を返すべきだが、エラーに

なる。

この反復プロセスは、 普通のことです。 実際、1つのプロンプトにすべての詳細を詰め込もうとす るのは、何度か行き来するよりも効果的ではないかもしれません。 それをうまく活用してください。

忍耐強く、 具体的なフィードバックをします。 「いや、それは間違っている」と言うのではなく、 何が間違っているのか、 何が必要なのかを言うのです。

このコードは負の数に正しく対処していない。 合計を計算する際、それらを0として扱うべき。

また、AIが軌道から外れてしまった場合、 あなたはそれを元に戻せます。 かなり間違った試みを 救い出そうとするより、リセットや言い直しの方が簡単なこともあります。 判断力を働かせてくださ い。 AIが出力した結果、完全に誤解していることがわかった場合、 ゼロからプロンプトを明確にし ます。

改良するにつれて、 AIがあなたのプロンプトをどのように解釈したかもわかってきます。 これは、 今後のプロンプトの書き方に役立ちます。 「あ、 AIは、 「ログインシステム」をUI全体だと思ってい る。次回は、バックエンドのみと指定しよう」 と気付くかもしれません。

コードのデバッグのように考えてください。 AIの出力が間違っている場合、その「バグ」はAIの 処理ではなく、 あなたのプロンプトにあるかもしれません。 間違った結果が出た時に、コードを調べ て修正するのと同様に、AIが予期しない、あるいは間違った出力を生成した時には、プロンプトを 改良すべきです。 あなたとAIとの会話はデバッグセッションのようなものであり、 会話内のやり取 りが、問題を特定して修正するのに役立ちます。

2.4 2つのプロンプトを比較する

ユーザーオブジェクトのリストをユーザーIDでルックアップマップに変換する、 単純なNode.js 関数があるとします。 しかし、この関数がエラーを送出しています。 これが、 そのバグのあるコード です。

| 2章 プロンプトの芸術 AI と効果的にコミュニケーションする

48

// バグのある関数 ユーザーの配列をIDでマップに変換 function mapUsersById(users) { const userMap = {}; for (let i = 0; i <= users.length; i++) { // 注 <= を使うと、 最後の反復で範囲外になる const user = users[i]; userMap[user.id] = user; return userMap; } } // 使用例:

const result = mapUsersById([{ id: 1, name: "Alice" }]);

このコードは、ユーザーの配列を反復処理し、ユーザーIDをキーとするオブジェクトを構築 することになっています。 しかし、バグがあります。 ループが< users.lengthの代わりに i <= users.lengthを使っているのです。 このため、 最後の反復でusers[i] が未定義になり、 (undefinedのプロパティ ID にアクセスしようとするなどして) 実行時エラーになる可能性が高くな ります。 この問題に関する2つの異なるプロンプトに対して、 AIアシスタントがどのように反応する かを見てみましょう (図2-3を参照)。

曖昧な 具体的な プロンプト プロンプト 一般的なコード/ 正確なコード 誤ったコード ?! for (int i=0; 1 < n; ++1) 一般的なコード / 誤ったコード 正確なコード

2-3 プロンプトの品質による影響の比較。 曖昧なプロンプトは一般的なコードや誤ったコードを生成するが、 具体的 で構造化されたプロンプトは正確で状況に適した解決策を生成する。

2.4.1 悪いプロンプト

悪いプロンプトの例を示します。

なぜ、 mapUsersByld 関数が動作しない?

2.4 2つのプロンプトを比較する |

悪いプロンプトに対するAIの (シミュレートされた) 応答は、 次の通りです。

詳しい情報がないと、何とも言えません。 関数がユーザーの適切な配列で呼び出されていることは、 確かですか? おそらく、問題は、ユーザーが空であるか、 配列ではないことで、ループが正しく 実行されないことです。 userMapのプロパティを設定する時にエラーが発生している可能性もあ ります。 各ユーザーがidプロパティを持っていることを確認してください。 ユーザーが未定義ま たはnull の場合、 それも動作しない原因となります。

この回答は、かなり曖昧です。 プロンプトが関数名以外の詳細を与えていないので、 AIは一般的 な原因 (「もしかすると、 配列が空か、配列ではない」、 「各ユーザーにIDがあることを確認する」) を 推測しています。 これは、 実際のバグを特定しませんでした。

このような応答は、質問の指定が曖昧な場合に得られるものです。 モデルは、一般的なデバッグ のヒントを返すことしかできません。 あなたが開発者なら、これは本当の間違いに対処していないの で、あまり役に立ちません。 プロンプトにコンテキストと具体性がないため、一般的な回答が返って きます。 基本的に、 「電源を切って、もう一度入れてみましたか?」 に相当するAIです。 これは、曖 昧なプロンプトは無関係または一般的な回答につながるという、コミュニティのアドバイスと合って います。

2.4.2 改善されたプロンプト

再度、 次のものを試してみましょう。

ユーザーオブジェクトの配列をユーザーIDをキーとするmap (object) に変換する、JavaScript 関数 mapUsersByIdがある。 しかし、この関数を実行すると、エラーが送出される。 例え ば、 [{id: 1, name: "Alice"} ]を渡すと、 TypeError: Cannot read property 'id' of undefinedが返される。 以下が、 その関数のコードである。

function mapUsersById(users) { const userMap = {}; users) { for (let i = 0; i <= users.length; i++) { } const user= users[i]; userMap [user.id] = user; return userMap; }

これは、 {"1": {id: 1, name: "Alice"}} を返すべきである。 バグは何であり、そのバグをど のように修正できるか? ow-She

改善されたプロンプトに対するAIのシミュレートされた) 応答は、次の通りです。

Cannot read property 'id' of undefinedというエラーは、ある時点でユーザーが未定義になり、 user.id にアクセスしようとしたことを示唆しています。 あなたのループを見ると、問題はループ

49

| 2章 プロンプトの芸術 AIと効果的にコミュニケーションする

50

の境界にあります。 あなたはi <= users.lengthを使っています。 users.lengthが1 (配列内が 1ユーザー) の場合、ループはi=0とi=1で実行されます。 iが1の場合、 (配列のインデック スが0しかないため) users [1] は未定義となります。 従って、その反復ではユーザーが未定義に なり、 user id は TypeError を送出します。 修正は、ループ条件をi users.length に変更し、 が0からusers.length-1までになるようにすることです。 例えば、次のようにします。

for (leti = 0; i < users.length; i++) {

const user = users[i];

userMap[user.id] = user;

こうすると、最初の (そして唯一の) 要素でiが0になり、 ループが止まります。 この変更によって、 あなたの関数は未定義のユーザーに到達しなくなり、 期待通りに動作し、 与えられた入力に対し て{"1": {id: 1, name: "Alice"}} を返すようになります。

この応答は、 (ループ内で<=を使っているという) バグを直接突き止め、 ユーザーが未定義にな る理由を説明しています。 そして、 正しいコードの解決策 (i users.length) を提供し、期待さ れる成果を確認しています。 改善されたプロンプトが成功したのは、私たちの原則に従っていたか らです。このプロンプトは、言語(JavaScript) を指定し、 関数の目的を説明し、 正確なエラーメッ セージとサンプル入力を含み、 問題のコードスニペットも提供しています。

AIが、エラーメッセージを手がかりにしてループの境界に注目したことに、注意してください。 的 を絞ったプロンプトによって、 AIは真の問題解決に取り組むことができ、人のデバッガーがどのよう に考えるか (「未定義は、 どこから来たのだろうか? たぶん、ループのインデックス処理からだろう」) を効果的にシミュレートができました。 これは、詳細なプロンプトの利点の具体例です。

2.5 プロンプトのテクニック:

効果的なコミュニケーションのためのツールボックス

では、プロンプトのスキルを高める具体的なテクニックを紹介しましょう。 これらはパターンやレ シビのようなものであり、単刀直入な指示では不十分な時や、 AIを特定の方向に導きたい時に使え ます。

これらのテクニックを習得することで、 さまざまな状況に対処できます。 AIに平易な言葉で指示 する、 AIに例を示す、 AIに出力の説明や構造化をさせる、AIをさまざまな考え方や役割に設定する、 といった状況です。 これらはすべて、 あなたが必要とするものを正確に作るように、AIを導くのに 役立ちます。

プロンプトのテクニックは相互排他的ではありません。 特に複雑なタスクでは、多くの場合、最良 の結果を得るために複数のテクニックを併用します。

}

プロンプトのテクニック 効果的なコミュニケーションのためのツールボックス |

スタイルについての注意

これらのテクニックを使う時は、あなたの口調をモデルに合わせてください。 多くのモデルは、丁 寧な指示や中立的な指示によく応答します。 古風な言葉や過度に形式的な言葉を使う必要はありま せん。 多くの場合、 「Xをやってください」 や 「Yをやりましょう」のように、 直接的ながらも丁寧に 伝えるとうまくいきます。 例えば、 思考の連鎖 (CoT) プロンプティングでは、人気の高いフレー ズは「段階的に考えましょう」です。 GPT-4のようなモデルは、これを推論を示す合図として認識 します。

2.5.1 ゼロショットプロンプティング

「ゼロショット」 プロンプティングでは、指示以外に例や追加の指針を提供することなく、 モデル に何かをするように求めるだけです。 基本的に、 モデルは 「ゼロ」の例からタスクを解くことになり ます。

いつ使うか

これは、最も一般的なシナリオです。 平易な言葉で、欲しいものを求めるだけです。 タスクが 標準的であり、プロンプトが明確なら、 多くの場合、 これで十分です。

例

ある数が素数かどうかをチェックする Python 関数を書いて

これが、ゼロショットです。 AIは、おそらくループや試し割り法を使って、 素数チェック関数 を作り出すでしょう。

長所

素早く、モデルが学習した知識に頼れます。 最近のモデルは、多くのプログラミングタスク、 特 (素数チェック、ソート、 文字列操作といった) 一般的なものに対するゼロショットの応答に、 驚くほど優れています。

短所

タスクが特殊だったり、 出力形式が特殊だったりする場合、 ゼロショットは、最初の試みで、必 要なものとまったく合わない結果を出すかもしれません。

通常、簡単なことなら、まずゼロショットを試してみるのが良いでしょう。 その結果がずれていた ら、改良や他のテクニックに移行できます。

2.5.2 ワンショットプロンプティングとFew-Shotプロンプティング 「ワンショットプロンプティング」とは、プロンプトの一部として、あなたが欲しいものの例(入力 と望ましい出力)を1つだけ提供することです。 「Few-Shot プロンプティング」とは、モデルに新し い入力でタスクを実行するように求める前に、 いくつか (通常は2から5) の例を提供することです。

51

2.5

52 2章 プロンプトの芸術 AIと効果的にコミュニケーションする

これは、モデルに「私がある一例を解く方法は、 これです。 さあ、同様に次も解いてください」 と 示すようなものです。

いつ使うか

この種のプロンプトは、モデルがあなたが必要とする形式やスタイルを正確に知らない場合や、 タスクが少し特殊な場合に有効です。 例を示すことで、曖昧さを減らせます。

例 (ワンショット)

あなたが、モデルがあまり見たことのないような言語やスタイルを使っているとします。 特定の 形式の擬似コードが必要だとしましょう。 プロンプトは、次のようになります。

次の日本語の指示を、 Python のような擬似コードに変換して。

指示の例 「nの階乗を計算して」

擬似コードの例:

function factorial(n):

if n <= 1:

return 1

else:

return n factorial(n-1)

指示: "リストの中で一番大きい数を見つけて"

擬似コード:

あなたは、1つの例 (階乗) と望ましい形式を提供しました。 これで、 モデルは、同様の形式 (必 要に応じて if/elseやループのロジックを持つ関数) で 「最大の数」 という指示のための擬似コー ドを生成する可能性が高くなります。

例 (Few-Shot)

AIに特定のアルゴリズムを使わせたいとしましょう。 ヒントとして、 そのアルゴリズムが動作 する小さな例を与えるかもしれません。 あるいは、 タスクに複数の正解があるものの、 あなたが 特定の正解を好む場合、例を示すことで、AIを正解に向かわせられます。 Few-Shot プロンプティングは、 書式設定に威力を発揮します。 例えば、次の通りです。

次の日本語の文をSQLクエリに変換して。 1. 「2020年以降に採用された全社員を取得」 → Select From Employees Where Hire_Date >

*

プロンプトのテクニック 効果的なコミュニケーションのためのツールボックス | 53

'2020-01-01';

2. 「先月購入した顧客名をリスト」 → Select Name From Customers Join Purchases On ... Where Purchase_Date > ...; 3. 「在庫切れの商品をカウント」 →

ここで、あなたが日本語からSQLへの例を2つ与えると、 AIは、 そのパターンに従って3つ目 の質問に回答する可能性が高くなります。 Few-Shot の例は、 コーディングにも応用できます。 AIに小さな例であなたが望むスタイルを示し、さらに求めます。 これは、プロンプトの中で、 ミニトレーニングデータセットを与えるようなものです。

長所

非常に具体的なスタイルで、 出力を得られます。 このテクニックは、モデルが、 パターンに従っ て繰り返し概念を適用するようなタスクを処理するのにも役立ちます。

コンテキストウィンドウ

「コンテキストウィンドウ」という用語は、 言語モデルが1回の対話で処理できる (トークンで測定 される) テキストの最大量を指し、入力プロンプトと生成された応答の両方を含みます。 これは、 現在のAIモデルの限界です。 このしきい値に達すると、モデルは追加情報を処理できなくなりま す。 プロンプトを作成する時、 あなたが含めるすべてのもの (指示、 例、 データ、 応答に必要な領域) は、この固定の容量内に収まらなければなりません。

Few-Shot プロンプティングは特に、プロンプトを長くします (コンテキストウィンドウを使い 果たします)。 非常に大きな例や複雑な例では、モデルの容量の多くを 「消費する」かもしれま せん。 しかし、通常は1つか2つの小さな例で十分です。

短所

ヒント

モデルを特定の出力構造に厳密に従わせたい場合、 あなたが解析しなければならないような、 制約のない応答をさせるのではなく、例を与えることで、その構造に合うことがほぼ保証されま す。

2.5.3 思考の連鎖 (CoT) プロンプティング

「思考の連鎖」 (CoT) プロンプティングでは、最終回答を出す前に、モデルに段階的に考えたり、 その推論を示したりするように求めます。言い換えれば、モデルが問題を分解するように促すので す。

いつ使うか

これは、推論や多段階の計算を伴う複雑な問題や、モデルが回答にいきなり飛びつくと間違え る可能性があると思われる場合に有効です。 また、 出力に説明が欲しい場合にも便利です。

2.5

54

2章 プロンプトの芸術 AIと効果的にコミュニケーションする

組合せ論 (組合せ数学)

「組合せ論」 は、 特定の規則や制約に従って、ものを数える、配置する、選ぶことを扱います。 一般 的な問題には、順列 (順序が重要な配置)、 組合せ (順序が重要でない選択)、 他の数え上げの原理 があります。 主な表記法には、 (C(n,k)、 またはnCkと表記される) 「n choose k」があります。 こ それは、n個のうちk個を選ぶ方法の数を表し、n!/(k!(n-k)!) という式を使って計算されます。これら の計算は、確率 統計 離散数学の応用で頻繁に登場します。

例

「 12 choose 4は何か?」といった組合せ論の問題 (https://oreil.ly/vI3V5) を単に尋ねて答え を得る代わりに、次のように言うかもしれません。

12 choose 4 を、 段階的に解いて。

モデルが、次のように要点を説明するかもしれません。

= 12 choose 4 12!/(4!*8!)= = 495

コーディングでは、 CoTは、扱いにくいアルゴリズムのタスクに役立ちます。 次のようなプロ ンプトを試してみましょう。

2つのソートされたリストをマージする方法を、段階的に説明して、それからPythonコードを提 供して。

モデルは、まず次のように要点を説明するでしょう。

それぞれのリストの先頭から始まる2つのポインタを使い、 要素を比較し、 小さい方を結果のリ ストに追加し、そのポインタを移動します...

次に、AIはコードを返すかもしれません。 これによって、 AIが、 コーディングの前に解決策を 正しく構造化するようにします。 もう1つの使い方は、デバッグや出力の理解です。

数19が素数かどうかを判定するロジックを順を追って確認し、結果を返して。

モデルは、素数による除算をリストして、次の結論を出すかもしれません。

19は素数です。

長所

推論を必要とするタスクの正しさが向上します。 モデルに 「声に出しながら考える」ようにプロ ンプトで指示することで、数学やロジックのタスクでより良い結果が得られるという研究の証拠 (https://oreil.ly/t7fF) があります。 また、これによって、 モデルのプロセスについての知見 を得られます。 これは教育的であり、 あなたがモデルをより信頼するのに役立ちます。

短所

出力が長くなります(これは、最終的なコードとしては、望ましくないかもしれません)。

また、

プロンプトのテクニック 効果的なコミュニケーションのためのツールボックス | 55

(典型的なコード補完のような) いくつかのインターフェイスは、コードと別に推論を表示する ように設定されていません。 このテクニックは、 Q&Aやチャットのシナリオでより一般的です。 しかし、 あなたは、コード内のコメントとして推論を含めるように、 モデルに指示できます。 こ れは、しっかりコメントされたコードを得る、 巧みな方法です。

2.5.4 役割プロンプティング

「役割プロンプティング」とは、AIの応答に影響を与える可能性がある特定のアイデンティティや 役割を想定するように、 AIに求めることです。

いつ使うか

回答のスタイルや詳細に影響を与えたり、 特定の視点を得たい場合に、 有効です。 例えば、 AI が 「専門家」の役割を引き受けると、より高度な解決策やさらなる説明を返すかもしれません。 一方、「初心者」の役割を引き受けると、より基本的な概念を説明するようになるかもしれません。

例

・あなたはPythonのインストラクターです。 次のコードを説明して、 より Python 流になるよう に修正して。 ・あなたはセキュリティアナリストです。 ここにコードがあります。 セキュリティ脆弱性を特定 して。 スタイルに問題がないかコードをチェックする、リンターになって。

これは、 応答に大きく影響します。 AIにセキュリティアナリストの役割を割り当てると、(デー タの妥当性確認、 安全なコーディングのプラクティス、潜在的な脆弱性といった)そうでなけれ ば言及しないようなことに焦点を当てさせられます。 インストラクターの役割によって、より明 確な説明を提供するようになり、 予備知識を想定しなくなるでしょう。 コーディングでは、コードを求める前に、次のよう言うかもしれません。

あなたは、最適化に精通したC++の専門家プログラマーであり、ジュニア開発者を指導していま す。

その結果、より高度なC++の機能を使い、 特定の選択がなされた理由を説明し、技術的な精巧 さと教育的な明確さとのバランスを取ることになるでしょう。

長所

このテクニックは、 回答のトーンと深さを導きます。 これによって、解決策を、 あるレベルの複 雑さや徹底さに調整できます。 非常に単純な解決策 (初心者になりきって、複雑なやり方を避け るように、 AIに指示する) や、 非常に最適化された解決策 (パフォーマンスの達人として行動す るように、 AIに指示する) を望む場合に、 これは便利です。

2.5

56

2章 プロンプトの芸術: AI と効果的にコミュニケーションする

例

短所

モデルが、必要以上にペルソナに焦点を当てることがあります (「インストラクター」は、あなた がすでに知っていることを説明し始めるかもしれません)。 また、 特定の役割の説明に敏感な、 AIの安全システムもあります。 特に、 ごまかし、 権力者へのなりすまし、潜在的に有害な活動 を示唆するような役割の説明には敏感です。 「データアナリスト」や「ソフトウェアエンジニア」 といったわかりやすい技術的、専門的な役割は通常、 問題なく動作します。

2.5.5 コンテキストに応じたプロンプティング

「コンテキストに応じたプロンプティング」とは、AIにタスクの説明以外の追加のコンテキストや 情報を与えることです。 AIモデルは、 あなたがプロンプトで (または、 高度なIDE 統合で統合され たコンテキストウィンドウを通して) 提供しない限り、プロジェクト全体の永続記憶を持っていませ ん。そのため、AIに既存のコードベースに合ったコードを書かせたい場合、 そのコンテキストを与 える必要があります。 基本的には、プロンプトの一部として関連データや背景を与えます。

いつ使うか

問題解決時に、モデルが知らなかったりトレーニングから正しく思い出せなかったりする、 特定 のデータや定義を知っている必要がある場合に使います。 あるいは、 (API仕様、 以前の会話の 一部などの) 外部情報との一貫性を確保したい時に使います。

データ構造があり、それを扱うコードが欲しい場合、 その定義を貼り付けるかもしれません。

次のクラスを前提にして、関数Xを実装して。

class Node: def __init__(self, value, next=None): self.value = value self.next = next

# ここで、 headから始まる連結リストのノード数を先頭から数える関数を書いて

クラス定義を含めることで、 AIがコード内でNode.value や Node.nextを適切に使う可能性が 高くなります。

特定のAPIを使いたい場合、 プロンプトにドキュメントのスニペットを含めます。

requests ライブラリを使って、 APIからデータを取り出して。 (APIは次の形式のJSONを返す: (...))

2.5 プロンプトのテクニック 効果的なコミュニケーションのためのツールボックス | 57

ドキュメントにAPIの短い使用例も含めれば、 AIはそれをまねられます。 曖昧さの除去:

高校生を指す 「student」 という用語を使って、 次のような関数を書いて・・・

コンテキストで 「student」 が曖昧である可能性がある場合、 この例のように、それを明確にし ます。

長所

AIを、 あなたが気にかけているコンテキストに基づかせます。 あなたが事実を与えれば、AIが 間違った推測をする可能性は低くなります。 AIが、 あなたの具体的なユースケースの詳細を覚 えていなかったり、 知らなかったりする可能性がある場合、 これは非常に役立ちます。

短所

このテクニックを使うと、 プロンプトが長くなります。 また、 モデルは時折、 (ドキュメントの スニペットからコードに行をコピーするなど) 提供されたコンテキストを回答におうむ返しする かもしれません。 しかし、 通常は適切に使います。

ヒント

(大きなスキーマや、 多くの行のコードといった) 大きなコンテキストがある場合、 すべてを一 字一句そのまま含めるのではなく、 モデルにとって重要な要素を要約した方が良いことがありま す。このアプローチは、モデルが最も関連性の高い情報を受け取れるようにしながら、コンテキ ストの制限内に収めるのに役立ちます。 しかし、 コンテンツが十分小さければ、そのまま含めて ください。

パフォーマンスの制約 (「O (n log n)以上に最適化して」)、 互換性の制約 (「Python 3.8 で実行し なければならない」)、 ライブラリの選択 (「外部の依存関係なしで、 標準ライブラリだけを使って」) などの制約も有益です。 これらは、ガードレールのように機能し、AIが許容範囲外のことを提案し ないようにします。

2.5.6 メタプロンプティング

「メタプロンプティング」とは、解決策が何をすべきかだけでなく、 出力自体について指示を与え ることです。 これは、解決策の形式やアプローチ方法をAIに伝えるようなものです。

いつ使うか

特定の形式やスタイルでの回答が必要な場合や、 AIが問題に取り組む方法を制御したい場合に 役立ちます。

58 | 2章 プロンプトの芸術 AI と効果的にコミュニケーションする

例

まず、アプローチを2文で説明し、 次に、 コードを提供して。 これによって、 AIがそのままコーディングを始めないようになります。 解決策で、 ライブラリを使わないようにして。 解決策に制約を与えます。 出力をJSONで書式設定して。 これは、AIを使ってコードではなくデータを生成する場合に便利です。 定義行なしで、 関数の本体だけを提供して。 これは、関数を既存のコードに挿入したい場合に便利です。 入力が無効な場合、エラーの代わりに Noneを返してや これは正確には出力形式ではありませんが、 AIに特定の場合の動作を指示しています。

長所

余計な編集なしで、 必要なものを必要な方法で正確に得られます。 これは、シナリオによって は非常に重要です。 パイプラインでAIの出力を自動的に使うつもりなら、 一貫した書式設定が どうしても必要です。

短所

指示がモデルのデフォルトのスタイルと矛盾する場合、 モデルが一部それに従ってしまう可能 性があったり、あなたが指示を強調しなければならなかったりすることがあります。 例えば、 あ なたが 「コードのみ、 説明なし」 と言ったとしても、モデルは時折、 小さなコメントなどを含む かもしれません。 通常、直接的な命令文として表現することが助けになります。

説明を含めないで。 1つのコードブロック内のコードのみを出力して。

GPTのようなモデルは、 これによく従います。

2.5.7 自己一貫性 (複数の出力と多数決)

「自己一貫性」は、プロンプトのスタイルというよりは戦略です。 同じプロンプトに対して複 数の出力を取得し、最良のもの、あるいは最も一般的なものを決めるというものです。 Learn Promptingのサンダー・シュルホフが指摘している (https://oreil.ly/fHABW) ように、自己一 貫性では、あなたが (ちょっとしたランダムさを加えて) 複数回、モデルに質問し、その回答の多く が一致すれば、その意見の一致は正しい可能性が高い、 という考え方を活用します。

2.5 プロンプトのテクニック 効果的なコミュニケーションのためのツールボックス |

いつ使うか

モデルの最初の回答が正しいかどうか確信が持てないような複雑な問題で、 特に自分で簡単に 検証できない場合や、AIが同じ回答を繰り返すかどうかを見て信頼性を確認したい場合に役立 ちます。

手動で使う方法

(ChatGPTなど) 一部のプラットフォームでは、 「回答を再生成」 をクリックできます。 また、 新しいセッションにプロンプトをコピーして、 同じ結果が出るかどうかを確認できます。 (その 問題の正解が1つだと仮定した場合) もし3つの回答が返ってきて、2つが同じで1つが違うな ら、その2つを信用してもいいかもしれません。

プログラミングのコンテキストでは、決定論的なもののコードを生成する場合、 通常、 (変数名や スタイルに多少の違いはあっても) 毎回、 AIは非常に似たコードを返すでしょう。 しかし、 (「この コードの出力は何か」 といった) アルゴリズム的な質問の場合は、複数回の実行を確認できます。 このテクニックは、(ロジックパズルなどの) コーディング以外のタスクでより威力を発揮します

が、 注目に値します。

別の観点: アンサンブルプロンプティング

実は、1つのプロンプトの中で、 複数の可能性を考慮するようにモデルに求められます。

この問題に対する2つの異なる解決策を返して。

そうすれば、どちらが好きか見てみたり、両方をテストしたりできます。 あなたは複数の回答を 得るので、これはワンショットでの自己一貫性のようなものです。

長所

このテクニックでは、 複数の試みが収束すれば、 解決策の信頼性を高められます。 また、バリ エーションがあるかもしれません (これは、 多くの中から最も的確な解決策を選びたい場合に は、良いものです)。

短所

複数回の呼び出しと出力の比較に、時間がかかります。

実際には、回答に確信が持てない場合、 同じ回答が得られるかどうか確認するために、多くの場 合、私は質問を別の形に置き換えます。 同じ回答を得れば、それが正しいという信頼性が高まるか らです。

2.5.8 ReAct (Reason+ Act) プロンプト

「ReAct」は、「推論」と「アクション」を組み合わせた (https://arxiv.org/abs/2210.03629)、

59

60 | 2章 プロンプトの芸術 AIと効果的にコミュニケーションする

より高度なプロンプティングのテクニックです。 これは、 モデルに、 CoTのように考えさせる だけでなく、計算、 API の呼び出し、 ツールの使用といったアクションを取らせます(詳しくは、 Prompt Engineering GuideのReAct (https://oreil.ly/P_KIV) を参照) *1。 現在のプラクティス では、これは、 LangChain のようなフレームワークでよく使われています。 そこでは、 AIは、プロ グラムが (実行するコマンドやクエリといった)アクションとして解釈するような特殊形式を出力し、 その結果のフィードバックを受けられます。

(ループ内にこのような実行環境を持たない) 私たちのスコープでは、まず計画の要点を説明して からその結果を出力するように、AIに指示することで、一種のReAct を行えます。 これはCoTに似 ていますが、 ツールの使用やサブタスクの実行に特化しています。

例

Pythonを使って、パリの現在の天気を調べて、出力して。

AIに閲覧機能がない限り、 現在の天気を知ることはできません。 ReActアプローチでは、次のよ うに言うことで、まずAIに問題を推論させます。

パリの現在の天気データにアクセスする必要があります。 これは、 天気 APIを呼び出す必要があ ります。

次に、 AIは利用可能なツールを使って、 API呼び出しを試みます。 成功した場合、 実際の天気 データを受け取ります。 そのようなツールが利用できない場合、 制限を認識するか、 仮想データを 扱います。 最後に、 AIは、 この推論とアクションのプロセスを通して取得できたあらゆるデータを 組み込んで、天気情報を表示する Python コードを書くでしょう。

外部ツールにアクセスできなければ、 ReAct は、 単純なプロンプティングのタスクには特に関連 しないでしょう。 しかし、 組織でAIツールを評価する際、インターネットからの最新情報にアクセ スできるかどうかを判断することは、重要な能力評価になります。 多くのAIモデルは、 ナレッジ カットオフで動作します。 つまり、 トレーニングデータが特定の日付までになっているため、 急速に 変化するトピックでは時代遅れの情報になる可能性があります。

あなたが、 (Jupyter 統合や、 類似のプラットフォームなど) AIがコードを実行できるような環境 を使っている場合、システムに指示することでReActを実装できます。

まず、この関数のテストを書いて、 それを実行し、それに応じてコードを調整して。

これは、推論手順 (テストの作成)、 アクション (テストの実行)、 そして結果に基づくコードの調 整というReActパターンを示しています。 しかし、 純粋なプロンプトによってこのようなワークフ ローをオーケストレーションするには、 高度なプロンプティングのテクニックと適切な技術基盤が必

*1 訳注:日本語訳 (https://www.promptingguide.ai/jp/techniques/react)があります。

要です。

2.6 高度なプロンプティングテクニックを組み合わせ、 複雑さに対処する | 61

より単純な使い方

AIがアクションをまねた中間手順を持つQ&Aを、 シミュレートできます。

段階的に考えて、必要であれば計算して。

これは事実上CoTですが、 より命令口調です。

長所

利用可能な場合、 外部情報や反復試行を必要とする問題を解決できます (AIが実際にコードを 実行することで、自らを修正できるようなものです)。 デバッグのコンテキストでは、コードを 実行してテストできるAIは、 素晴らしいものです。

短所

このテクニックは、特定のツールなしでは幅広く利用できません。 また、 普通のChatGPTでそ のようにプロンプトで指示すると、 ChatGPTはアクションを想像するか、単にCoTをするだけ になってしまいます。

プロンプト作成における私たちの目的のためには、 (OpenAIのツールを使うエージェントなど) いくつかのシステムが存在しますが、素のプロンプティングでは、私たちは主にCoTを行い、 コー ドやテストの実行のようなアクションには、私たち自身が対処することを覚えておいてください。

2.6 高度なプロンプティング: テクニックを組み合わせ、 複雑さに対処する

プロンプトのテクニックを組み合わせられます。 例えば、 Few-Shot プロンプトを行って、 例の中 でCoTを示せます。 あるいは、 役割とCoTを組み合わせられます。

シニアエンジニアとして、 問題を段階的に考えて、 次にコードを返して。

さて、さまざまなプロンプトのテクニックを探ってきたので、1つか2つのシナリオで実際にそれ らの動きを確認し、 AIの出力をどのようにレビューして改良するかについて議論しましょう (これは、 生成されたコードを理解して所有することに関する、 次章につながります)。

機能していない関数があるとします。 あなたは、 役割プロンプティングとCoT プロンプティング を組み合わせて使うかもしれません。

あなたはPython のデバッガーです。 次のコードのバグを見つけるために、段階的に考えましょう。

その後に、コードが続くでしょう。 AIは、各行を分析して、 バグを特定します。 あるいは、あなたが、 やや複雑なアルゴリズムのコードを生成し、きちんとコメントされているこ

62 | 2章 プロンプトの芸術 AI と効果的にコミュニケーションする

とを確認し、そのテストケースを取得したいとしましょう。 これらを組み合わせたプロンプトは、次 のようになります。

あなたは、 Python のエキスパートです。段階的に解決しましょう。 2つのソートされたリストを 1つのソートされたリストにマージする関数merge_sorted_lists (list1, list2) が必要です。 まず、アプローチを説明して、 次に、 コメント付きのPython コードを提供して。 その後、 それが 動作することを示すために、2、3のテスト例をコードで返して。

このプロンプトは非常に包括的です。 最初の文は、 役割を設定しています。 2つ目の文は、段階的 な推論を要求しています。 3つ目の文は、 主なタスクを与えています。 4つ目の文は、説明コメント 付きのコードを要求し、5つ目の文は、テストまでも要求しています。

次に、AIは説明を出力し、 インラインコメント付きのコードを出力し、 最後に、いくつかのテス トケースを出力するかもしれません。 これは高度な使い方ですが、 多面的な応答を通してあなたが AIに指示する方法を示しています。

2.6.1 モデルの限界を知る

プロンプトエンジニアリングには、 何を求めては 「いけない」 か、 どうすれば落とし穴を避けられ るかを知ることも含まれています。 プロンプトが大きくなりすぎたり、指示が多すぎたりすると、モ デルは混乱したり、 出力を切り捨ててしまうかもしれません。 AIがプロンプトの一部を無視し始め たら、プロンプトを単純化したり分解したりする必要があるでしょう。 AIモデルがときどき間違っ た事実やコード (「ハルシネーション」)を生成する場合、再確認することを学んで、それを事実に基 づく神託として使わないようにします。 AIモデルが過度に冗長なコードを出力する傾向を見つけた 場合、 「解決策をできるだけ簡潔にして」 と先手を打てます。 存在しない関数を使うことがある場合、 「以下にリストしたAPI関数だけを使って」と指示して、それをリストできます。 AIの振る舞いをよ りよく理解するほど、弱点を回避するためにプロンプトを型にはめられます。

また、タスクが非常に複雑な場合、 それをAI用のサブタスクに分割できます。 例えば、 まず、次 のようにプロンプトで指示します。

単純な数式言語向けの基本的なコンパイラーを実装する手順をリストして。

AIが手順を返したら、 あなたは、(恐らく、別々のファイルやセッションで) 各手順に別々のプロ ンプトで取り組みます。

手順1:トークン化を実装して。

これは、AIとともにシステム設計をするようなものです。 あなたは、各部分の要点を説明してか ら改良できます。これは、(コーディングだけでなく) 計画を支援するAIの能力を活用するものです。

2.6 高度なプロンプティングテクニックを組み合わせ、 複雑さに対処する | 63

2.6.2 ステートフルな会話とワンショットプロンプティングとの比較

チャットでは、「ステート」として知られている会話履歴があります。 AIと議論することで、コン テキストを構築できます。 IDEでの補完では、コンテキストは、 主にあなたのファイル内容とコメン トです。どちらも、異なる方法でコンテキストを蓄積できます。 (回答を改良するなど) AIが言われ たことをAIに記憶させる必要がある場合、会話を使います。 今関連することだけに集中させたい場 合、新しいプロンプトやファイルのコンテキストを使います。 時には、 コンテキストを消去すること ます。

で、モデルが間違っている可能性のある以前の想定に固執するのを防ぎ

さまざまな例でこれらのテクニックを練習することで、 いつ、 どのアプローチを使うべきかを熟知 できるようになるでしょう。

・出力形式が重要な場合、 例 (Few-Shot) や明示的な書式設定の指示を与えます。

ロジックが扱いにくい場合、 CoTや段階的な推論を使います。

解決策の品質にばらつきがある場合、 (「経験豊富なエンジニア」といった) 役割を設定して、よ り良いスタイルを得ます。

●モデルが従わない場合、 プロンプトを分割したり、単純化したり、 制約のためにより強い表現 を使ったりします。

2.6.3 よくあるプロンプトのアンチパターンと、 それを避ける方法

すべてのプロンプトが、同じように作成されているわけではありません。 これまで、 効果的なプロ ンプトの例を数多く見てきましたが、 アンチパターン、 つまりAIの応答が悪くなるようなよくある 間違いを認識することも、同様に有益です。 本節では、よくあるプロンプトの失敗例とその修正方 法について説明します。

2.6.3.1 曖昧なプロンプト

これは、古典的な 「動作しません。 直してください」 や 「Xをする何かを書いて」 といったものであ り、 十分な詳細がありません。 「なぜ、 私の関数は動作しないのですか?」という質問は、 通常、役 立たない回答を得ることになります。 曖昧なプロンプトは、AIにコンテキストを推測させ、 多くの 場合、一般的なアドバイスや無関係なコードになります。

解決策は簡単です。 コンテキストと詳細を追加してください。 あなたが質問して、その回答がマ ジック8ボールの応答 (「Xを確認してみましたか?」) のように感じられたら、一旦立ち止まって、 (エラーメッセージ、コードの引用、期待される成果と実際の結果などの)さらなる詳細を含むよう に、あなたの質問を書き直します。 良いプラクティスは、プロンプトを読み、「この質問は、 何十も の異なるシナリオに適用できますか?」と尋ねることです。 答えが「はい」なら、それは曖昧すぎま す。 あなたのシナリオにしか当てはまらないような、 具体的な内容にします。

2 :質問に対してランダムな答えを返してくれる、 占いのおもちゃ。

64 | 2章 プロンプトの芸術 AI と効果的にコミュニケーションする

2.6.3.2 過剰なプロンプト

これは、逆の問題です。 一度に多すぎることをAIに求めることです。 例えば、 次の通りです。

認証を備えた完全なNode.js アプリ、 Reactのフロントエンド、デプロイスクリプトを生成して

あるいは、より小規模なものとしては、次の通りです。

これら5つのバグを修正して、さらに、これら3つの機能を一度に追加して。

AIはそれを試みるかもしれませんが、ごちゃ混ぜで不完全な結果が返されるか、要求の一部を無 視するかもしれません。 すべてに対応したとしても、応答は長くなり、 検証も難しくなります。

解決策は、タスクを分割することです。 優先順位をつけ、 前に強調したように、一度に1つのこと を行います。こうすることで、間違いを見つけやすくなり、 モデルが集中力を保てるようにします。 指示の中で 「and」 (そして) を複数回使う段落を書いていることに気付いたら、 それを別のプロンプ トや一連の手順に分割することを検討します。

2.6.3.3 質問を見落とす

ユーザーが、大きなコードスニペットをダンプし、単に「これが私のコードです」 と言うように、 多くの情報を提示しながらも、明確に質問したり必要なものを指定したりしないことがあります。 こ れは、AIを混乱させる可能性があります。 AIは、 あなたが欲しいものがわかりません。 常に明確な依頼を含めます。

• 上記のコードのバグを特定して。

このコードが何をしているのかを説明して。

コード内のTo-Doを完了させて

プロンプトには、目的があるべきです。 質問や指示なしに単にテキストを提供すると、 AIは、 (コードを修正する代わりに要約するといった) 間違った想定をするかもしれません。 AIが、 なぜあ なたがコードを示したのかを理解できるようにします。 「このコードのどこが問題ですか?」 や 「この 関数の実装を続けてください」といった簡単な追加でも、AIに方向性を与えられます。

2.6.3.4 曖昧な成功基準

これは、微妙な問題です。 最適化や改善を求めることがありますが、成功がどのようなものかを 定義していません。 例えば、 「この関数をより速くして」では、どのメトリクスで速くするのですか? AIがあなたのパフォーマンス制約を知らない場合、 AIは、 どうでもいいことをマイクロ最適化する かもしれないし、理論的には速くても実際には無視できるようなアプローチを採用するかもしれませ ん。 あるいは、「このコードをよりクリーンにする」 では、「よりクリーン」は主観的なものです。 私 たちは、 「重複を減らす」 や 「変数名を改善する」 などの目標を明示的に示すことで、これに対処しま

2.6 高度なプロンプティングテクニックを組み合わせ、 複雑さに対処する | 65

した。

これを修正するには、 改善を定量化、 または定性化します。

この関数を、線形時間で実行できるように最適化して (現在のバージョンは、 2次時間)。 グローバル変数を除去し、 代わりにクラスを使うように、リファクタリングして。

基本的に、 リファクタリングや機能追加でどのような問題を解決するのかを明確にすることです。 未定のままにしすぎた場合、 AIは、 あなたが気にかけている問題とは別の問題を解決してしまうか もしれません。

2.6.3.5 AI の明確化や出力を無視する

時には、 AIは、明確にするための質問や想定で応答するかもしれません。

• React のクラスコンポーネントか、 または関数コンポーネントを使っていますか? ● 入力は文字列だと想定しています。 確認してください。

これらを無視してあなたの要求を繰り返すだけだと、 プロンプトを改善する機会を逃してしまい ます。AIは、さらに情報が必要だというサインを送っているのです。 AIからの質問に必ず答えるか、 プロンプトにその詳細を含めるように改良してください。

さらに、質問を誤解しているなど) AIの出力が明らかにおかしい場合、 同じプロンプトをそのま ま再試行しないでください。 少し時間を置いて、表現を調整します。 あなたのプロンプトに曖昧な 表現があったかもしれないし、 重要なことが抜けていたかもしれません。 会話と同じように扱います。 人が誤解していたら、 あなたは違う説明をするでしょう。 AIにも同様にしてください。

2.6.3.6 非一貫性

質問の仕方を変え続けたり、 一度に異なる形式を混ぜたりすると、モデルは混乱してしまいます。 例としては、指示の中で一人称と三人称を切り替えたり、 擬似コードと実際のコードを混ぜて混乱 させたりすることが挙げられます。

1つのプロンプトの中で一貫性を保つようにします。 例を提供する場合、 (コードにはMarkdown の三重バッククォート (```) を使い、 入出力の例には引用を使うなど) それらが明確に区別されて いることを確認します。 一貫性は、モデルがあなたの意図を正しく解析するのに役立ちます。また、 好みのスタイル (例えば、 ES6やES5の構文) がある場合、 一貫してそれに言及します。 そうしない と、モデルはあるプロンプトではある方法を提案し、後で別の方法を提案するかもしれません。

2.6.3.7 「上記のコード」のような曖昧な参照

チャットを使う際、 「上記の関数」 や 「前の出力」 と言う場合、 参照が明確であることを確認します。 会話が長くなって、 「上記のコードをリファクタリングして」と言う場合、 AIはわからなくなったり、 リファクタリングするコードスニペットを間違って選んだりするかもしれません。

66 | 2章 プロンプトの芸術 AIと効果的にコミュニケーションする

再度コードを引用するか、 リファクタリングしてほしい関数を具体的に指定する方が、安全です。 モデルには限られた注意ウィンドウしかありません。 多くのLLMは前の会話の一部を参照できます が、再度明確なコンテキストを与えることで、混乱を避けることができます。 これは、コードが示さ れてから時間 (いくつかのメッセージ) が経過した場合に、 特に当てはまります。

2.7 まとめと次の一歩

プロンプトの芸術は、反復的かつ創造的です。 モデルが進化するにつれて、プロンプトのベスト プラクティスは変わるかもしれません(例えば、 将来のモデルは、より少ない表現でより良く意図を 理解するかもしれません)。 しかし、 基本原理は変わりません。 効果的にコミュニケーションすれば、 AIはより良いサービスを提供してくれるでしょう。

要するに、プロンプトエンジニアリングを習得することは、新しいプログラミング言語 (AI向けの指 示の言語) を習得するようなものです。 これは、 テクニカルライティング、 先見性、そして「プロンプ ト」自体の対話型デバッグの融合です。 しかし、 ひとたび熟達すれば、AIが本当にあなたの心の延長 のように感じられるようになります。 なぜなら、 自分が思い描く解決策 (あるいは、 まだ完全には思い 描いていないが、AIに発見させるよう導ける解決策) を、最小限の摩擦で確実に引き出せるからです。 このスキルは、Googleの使い方やデバッガーの使い方と同じくらい、 基本的なものになるでしょう。 これは、バイブコーディング時代における、 最新の開発者のスキルセットの一部なのです。

AIが問題の約70%を解決できる場合、 コーディングのパートナーとして、どのようにAIにアプ ローチしますか? 「3章 70% 問題: 実際に動作するAI支援ワークフロー」 では、 開発者が 「実際 に」 AIをどのように使っているのかに注目し、 バイブコーディングのいくつかの 「黄金律」 を定めま す。

Ⅱ部

AIコーディングの実践



| 69

3章

70% 問題:

実際に動作する AI支援ワークフロー

AIベースのコーディングツールは、特定のタスクにおいて驚くほど優れています。ボイラープ レートの作成、 定型関数の作成、プロジェクトの 「大部分」を完了させることなどが、得意です。 実 際、 多くの開発者は、 AIアシスタントが要件のおよそ70%に対応する初期の解決策を実装できるこ とに気付いています。

ピーター・ヤンは、Xの投稿 (https://oreil.ly/i9qwq) で、私が現場で観察してきたことを完璧 に捉えています。

非エンジニアとしてAIを使ってコーディングしてきた、 率直な感想です。 AIは70%の道のりを歩ませてくれるが、 最後の30%はいら立たしいものです。 新しいバグや問 題などで、 一歩進んで二歩下がることを繰り返しています。 コードの仕組みがわかっていれば、 自分で直せるかもしれません。 しかし、そうではないので、 本当に多くのことを学んでいるのかどうか、疑問です。

AIをコーディングに使う非エンジニアは、自分たちがいら立ちの壁にぶつかっていることに気付 きます。 彼らは驚くほど早く70%を達成できますが、 最後の30%は収穫減の練習になってしまい ます。

この 「70%問題」 は、 AI 支援開発の現状について、 重要なことを明らかにしています。 初期の進捗 は、 魔法のように感じられます。 欲しいものを説明すれば、 v0 や BoltのようなAIツールが動作する 印象的なプロトタイプを生成してくれます。 しかしその後、現実に直面します。

その70%は、 しばしば単純でパターン化された作業、 つまり、人のよく通る道や共通のフレー ムワークに従うコードのようなものです。 「Hacker News」 のあるコメントで述べられている (https://oreil.ly/Ff3Ts) ように、 AIはソフトウェアの 「偶有的な複雑さ」 (繰り返しで機械的なも の)を扱うことに長けていますが、本質的な複雑さ」 (問題の本質的な複雑さを理解して管理するこ と)は人の肩にかかっています。 フレッド・ブルックスの古典的な言葉を借りれば、AIは偶有的な

1 本章は、私のSubstackニュースレターに最初に掲載したエッセイを基にしています。 「70%問題:AI支援コーディングに関 する厳しい真実」 (https://oreil.ly/aRKIJ) (アディオスマニ著 Elevate with Addy Osmani, 2024年12月4日) を参照。 2 : 米国のソフトウェア技術者、計算科学者 は、本質的な複雑さ、 偶有的な複雑さを議論しています。 「銀の弾などない」で 「人月の神話」、論文「銀の弾などない」が有名。

70 | 3 章 70% 問題: 実際に動作する AI 支援ワークフロー

ものには取り組むが、 開発における本質的な困難には取り組まないのです。

これらのツールはどこで苦労しているのでしょうか? 経験豊富なエンジニアは、 一貫して「ラス トワンマイル」のギャップを報告しています。 AIはもっともらしい解決策を生成できますが、最後の 30%には、 つまり、 エッジケースをカバーし、 アーキテクチャを改良し、 保守性を確保するために は、 「人の専門知識が必要」 なのです。

例えば、AIは、基本的なシナリオに対して技術的に動作する関数を与えるかもしれませんが、 明 示的に指示されない限り、 通常とは異なる入力、 競合条件、 パフォーマンス制約、 将来の要件を自 動的に考慮することはありません。 AIは大体のことをやってくれますが、 最後の重要な30% (エッ ジケース、 保守性の維持、確かなアーキテクチャ) には、 人の専門知識が必要です。

さらに、AIには、説得力はあるが正しくない出力を生成する傾向があることが知られています。 微妙なバグを導入したり、 存在しない関数やライブラリの「ハルシネーション」を起こすこともあり ます。 スティーブイェッゲ (https://oreil.ly/hjv8f) は、顔をしかめて、 今日のLLMを、信じら れないほど高速で熱心ですが、 「向精神薬でハイになっている可能性がある、 熱狂的に生産的なジュ 「ニア開発者」になぞらえています。

スティーブイェッゲの言葉 (https://oreil.ly/yPMPO) を借りれば、 LLMは、一見洗練され たコードを生成できますが、経験の浅い開発者が素朴に「良さそうですね!」 (LGTM) と言ってそれ に同調すると、その後数週間、 ばか騒ぎ (あるいは大惨事) が続きます。 AIは、問題を真に「理解」 しているわけではなく、 「通常は」 意味をなすパターンをつなぎ合わせているのです。 一見良く見え る解決策に長期的な地雷が隠されているかどうかを見分けることができるのは、人だけです。 サイ モン・ウィリソン (https://oreil.ly/sLzFY) は、AIが魅惑的に巧妙な設計を提案して、「問題を深 く理解しているシニアエンジニアだけ」 が欠陥を認識できたのを目の当たりにした後、 この言葉を繰 り返しました。 教訓は、 「AIの自信は、 AIの信頼性をはるかに上回っている」ということです。

重要なのは、現在のAIはトレーニングデータを超えて、根本的に新しい抽象化や戦略を作成する ことはない (https://oreil.ly/HkwVF) ということです。 AIは、 あなたに代わって新しいアルゴリ ズムや革新的なアーキテクチャを発明することはありません。 既知のことをリミックスするだけで す。 また、 AIは、意思決定に責任を持つこともありません。 あるエンジニアが指摘するように、「AI は、トレーニングデータに含まれている以上の「より良いアイデア」を持っているわけではありませ ん。 AIは、 自分の作業に責任を持ちません」。

これらのことは、創造的で分析的な思考、 つまり 「何」 を構築し、 「どのように」 それを構造化し、 「なぜ」 そうするのかを決定することは、依然として人のドメインであることを意味しています。ま とめると、 AIは、 開発者にとって 「力を増強させるもの」であり、繰り返しの70%に対処し、生産性 を「ターボブースト」 してくれます。 しかし、それは、 人の判断に取って代わる銀の弾丸ではありま せん。 ソフトウェアエンジニアリングの残りの30%、 つまり難しい部分には、トレーニングされた思 慮深い開発者だけがもたらすことのできるスキルが、依然として必要なのです。 それらは、焦点を 当てるべきである持続的なスキルであり、 「4章 70%を超えて: 人の貢献を最大化する」 はそれだ

3.1 開発者は実際にどのようにAIを使っているか | 71

けを扱います。 ある議論 (https://oreil.ly/QXYsj) では、こう言われています。 「AIは強力なツー ルですが、魔法の弾丸ではありません・・・ 人の判断力と優れたソフトウェアエンジニアリングのプラク ティスは、依然として不可欠です」。

3.1 開発者は実際にどのようにAIを使っているか

私は、チームが開発にAIを活用する方法について、 2つの異なるパターンを観察してきました。 それらを「ブートストラッパー」、「イテレーター」 と呼びましょう。 どちらも、エンジニアが(そして、 非技術者のユーザーさえもが) アイデアから実行 (またはMVP) までのギャップを縮めるのに役立っ ています。

まず、「ブートストラッパー」 は、 通常、新しいプロジェクトをゼロからMVP まで持っていく人

たちです。 Bolt v0 screenshot-to-code といったツールは、このようなチームが新しいプロジェ クトを立ち上げる (ブートストラップする) 方法に革命をもたらしています。 このようなチームには、 通常次のようにしています。

●デザインや大まかなコンセプトから始める

AI を使って、 完全な初期のコードベースを生成する

数週間ではなく数時間から数日で、 動作するプロトタイプを得る

• 素早い検証と反復に焦点を当てる

結果は印象的なものになります。 私は最近、1人の開発者がBoltを使って、ほとんど時間をかけ ずにFigmaのデザインを動作するウェブアプリに変換するのを目撃しました。 それは本番環境対応 ではありませんでしたが、 初期のユーザーフィードバックを得るには十分でした。

2番目の陣営である「イテレーター」 は、 Cursor、 Cline、 GitHub Copilot Windsurf といった ツールを日々の開発ワークフローに使っています。 これは派手さはありませんが、 より変革を起こす 可能性があります。 このような開発者は、次のようにしています。

•コード補完とコード提案に、 AIを使う

複雑なリファクタリングタスクにAIを活用する

• テストとドキュメントを生成する

問題解決のための 「ペアプログラマー」として、AIを活用する

しかし、ここで落とし穴があります。 どちらのアプローチも開発を劇的に加速させることができま すが、 すぐにはわからない隠れたコストがかかります。

シニアエンジニアがCursor や GitHub Copilot といったAIツールを使っているのを見ると、まる で魔法のように見えます。 彼らは、数分で、 テストとドキュメントを完備した機能全体の足場を組め ます。 しかし注意深く見ていると、 重要なことに気付くでしょう。 彼らは、単にAIの提案を受け入 れているわけではありません。 彼らは常に、生成されたコードのリファクタリングを行い、 より小さ

72 | 3 章 70% 問題: 実際に動作する AI 支援ワークフロー

く、焦点を絞ったモジュールにしているのです。 彼らは、AIが見逃した包括的なエラー処理やエッ ジケースの処理を追加し、 AIによる型定義やインターフェイスを強化し、 AIによるアーキテクチャ の決定に疑問を投げかけているのです。 言い換えれば、 彼らは、 AIの出力を形作り、 制約するため に、長年の苦労の末に獲得したエンジニアリングの知恵を適用しているのです。 AIは彼らの実装を 加速させていますが、 彼らの専門知識こそがコードを保守可能にしているのです。

3.1.1 よくある失敗パターン

ジュニアエンジニアは、 多くの場合、こういった重要な手順を見逃してしまいます。 彼らはAIの 出力を安易に受け入れてしまい、 私が 「砂上の楼閣コード」 と呼んでいるようなコード、 つまり、 完 成しているように見えますが、 実世界の圧力で崩壊してしまうようなコードにつながるのです。

3.1.1.1 二歩下がる

通常、次に起こることは、 (図3-1に示した) 私が「二歩下がる」 パターンと呼んでいる予測可能な アンチパターンに従います。

あなたは、 小さなバグを修正しようとする。

AIは、妥当と思われる変更を提案する。

この修正によって、 別の何かが壊れてしまう。 ● あなたは、AIに新しい問題の修正を頼む。

その結果、さらに2つの問題が作成される。 ●これを繰り返す。

小さなバグの修正を 試みる 新たな問題の修正を AIに依頼 何度も 繰り返す AIが良さそうな 変更を提案 その結果、さらに2つの 問題が発生

図3-1 「二歩下がる」 アンチパターン

このサイクルは、非エンジニアにとって特に苦痛です。 なぜなら、 彼らは、 実際に何が間違って いるのかを理解するためのメンタルモデルを持っていないからです。 経験豊富な開発者がバグに遭

3.1 73

開発者は実際にどのようにAIを使っているか |

過した時、 彼らは長年のパターン認識に基づいて、潜在的な原因と解決策を推論できます。 このよ うな経歴がなければ、 本質的に、 あなたが完全に理解していないコードでモグラたたきをしている ようなものです。 これは、本書の序文で述べた 「知識のパラドックス」 です。 シニアエンジニア/開 発者は、すでに知っていることを加速させるためにAIを使いますが、 ジュニアは、 「何」 をすべきか を学ぶためにAIを使おうとします。

このサイクルは、「ブートストラッパー」 パターンでAIを使う非エンジニアにとって、 特に苦痛で す。 なぜなら、彼らはMVPを構築する際に、これらの問題に対処するために必要なメンタルモデル を持ち合わせていないからです。 しかし、経験豊富な「イテレーター」 でも、深い検証なしにAIの提 案に過度に依存すると、このモグラたたきの罠に陥る可能性があります。

ここに、より深い問題があります。 非エンジニアにAIコーディングツールを利用しやすくしてい るもの、つまり、あなたに代わって複雑さに対処する能力は、 実際には学びの妨げになる可能性が あるのです。 あなたが基本原理を理解しないまま、 コードがただ「現れる」だけでは、デバッグスキ ルを養えません。 基本パターンを学べないのです。 あなたはアーキテクチャの決定について推論で きないので、コードの保守や進化に苦労することになります。 これは、 自分で問題に対処する専門 知識を養うのではなく、問題を修正するためにAIモデルに戻り続ける必要があるという依存関係を 生み出します。

この依存関係のリスクは、 「10章 自律型バックグラウンドコーディングエージェント」で詳し く取り上げる) 自律型AIコーディングエージェントの出現によって、 新たな局面を迎えます。 コード スニペットを提案する現在のツールとは異なり、 これらのエージェントは、ソフトウェア開発方法の 根本的な転換を示しています。 この原稿を書いている今、私たちは、人の監視を最小限に抑えなが ら、開発タスク全体を独立して計画、実行、 反復できる初期システムがデプロイされつつあるのを 目の当たりにしています。

支援型AIから自律的AIへの進化は、 開発者の専門知識と制御に関する深い問題を提起します。 AIシステムが初期実装からテスト、 デプロイまで、 開発ワークフロー全体に対処できるようになる と、スキルが萎縮するリスクが深刻になります。 基礎知識を維持せずにこれらのエージェントに大き く依存する開発者は、AIの決定が意図した成果と異なる場合、 自分が効果的に監査、指導、介入を できないことに気付くかもしれません。

このような自律システムが、プロジェクト全体を通してどのように連鎖的な意思決定を行っている かを考えると、課題はさらに大きくなります。個々の選択は単独では合理的に見えるかもしれません が、累積的な効果が開発を意図しない方向に誘導する可能性があります。 このような軌道のずれを すぐに認識して修正する専門知識がなければ、チームは、十分に理解していない基礎の上に、 ます ます複雑になるシステムを構築するリスクを負うことになります。

後ほど詳しく検討しますが、 自律型コーディングエージェントの出現は、ソフトウェアエンジニア リングの基礎の重要性を低下させるものではなく、むしろ増幅させるものです。 AIツールが強力に なるほど、 単なるコーダーではなくシステムアーキテクトであり続けるための専門知識の維持が、 よ

74 | 3章 70% 問題: 実際に動作する AI 支援ワークフロー

り重要になります。 ソフトウェアの原理を深く理解することによってのみ、 この驚くべきツールが私 たちの能力を低下させるのではなく、むしろ向上させるようにすることができるのです。

3.1.1.2 デモ品質の罠

チームがAIを使って印象的なデモを素早く構築するのが、 パターンになりつつあります。 正常系 は見事に動作します。 投資家やSNSは驚嘆します。 しかし、実際のユーザーがクリックし始めると、 どうでしょうか? その時、 物事は崩壊します。

普通のユーザーには意味不明なエラーメッセージ、アプリケーションをクラッシュさせるエッジ ケース、クリーンアップされない混乱したUIステート、完全に見落とされたアクセシビリティ、 低 速デバイスでのパフォーマンス問題を、私は目の当たりにしてきました。 これらは単なる優先度の低 いバグではなく、人々が我慢するソフトウェアと人々が愛するソフトウェアとの違いなのです。

ユーザーがサポートに連絡する必要がないような、真にセルフサービスのソフトウェアを作成する には、失われた仕上げの技術に関する異なる考え方が必要です。 エラーメッセージにこだわり、 低 速接続や非技術者の実際のユーザーを使ったテストを行い、機能を見つけやすくし、 あらゆるエッ ジケースを正常に処理する必要があります。 このような細部へのこだわりは、 (おそらく) AIは生成 できません。 共感、 体験、 そしてものづくりへの深いこだわりから生まれるものなのです。

3.1.2 実際に動作するもの: 実践的なワークフローのパターン

本書の「Ⅱ部 AIコーディングの実践」 でコーディングを扱う前に、 最新の開発プラクティスと、 AI支援コーディングがチームのワークフローにどのように収まるかについて話す必要があります。 結局のところ、 ソフトウェア開発はコードを書くこと以上のものです。 計画、 協働、テスト、 デプロ イ、保守を含む、ワークフロー全体なのです。 バイブコーディングは、目新しい独立したものではあ りません。 それはアジャイル手法やDevOpsプラクティスに組み込むことができ、品質と信頼性を 維持しながらチームの生産性を高めます。

本節では、チームメンバーが互いに足踏みすることなくバイブコーディングツールを集団で使う方 法、AIの提案と人の洞察とのバランスを取る方法、 継続的インテグレーション / 継続的デリバリー (CI/CD) パイプラインにAIを組み込み、 AIが生成したコードに適応する方法を探ります。 バー ジョン管理戦略といった重要な考慮事項についても触れます。

何十ものチームを観察した結果、単独、チームワークフローの両方で一貫して機能するのを見た、 3つのパターンを紹介します。

最初の下書き作成者としてのAI

AIモデルが初期コードを生成し、 開発者がそれの改良、 リファクタリング、テストを行います。 ペアプログラマーとしてのAI

開発者とAIは、緊密なフィードバックループ、 頻繁なコードレビュー、 提供される最小限のコ コンテキストで、常に会話しています。

検証者としてのAI

3.1 開発者は実際にどのようにAIを使っているか | 75

開発者が初期コードを書き、 AIを使って検証、テスト、 改善を行います (図3-2を参照)。

開発者が AIがコードを分析 コードを書く AIがコードを分析 バグ、セキュリティ、テスト) 開発者が レビューと適用を行う "! #

図3-2 AIによる検証ワークフロー。 開発者が初期コードを書く。 AIシステムがバグやセキュリティ問題を分析し、改 善を提案する。 開発者が推奨された変更をレビューして適用する。

本節では、各パターンを順に説明し、ワークフローと成功のためのヒントについて議論します。

3.1.2.1 最初の下書き作成者としてのAI

AIモデルにコードの下書きを頼む前に、チーム全員が同じ考えを持っているようにすることが、 重要です。 開発者がAIアシスタントに重複したタスクを行ったり、矛盾する実装を生成したりする ように頼まないようにするには、コミュニケーションが重要になります。

デイリースタンドアップ(アジャイルワークフローの必需品) では、あなたが取り組んでいること だけでなく、 特定のタスクにAIを使う計画があるかどうかについても、議論する価値があります。 例えば、2人の開発者が異なる機能に取り組んでいて、どちらも日付の書式設定のユーティリティ関 数を必要としているとします。 両者がAIに formatDateヘルバーを作成するように頼んだ場合、類 似した2つの関数ができてしまうでしょう。 前もって調整しておけば (「私が、 両者が使える日付 ユーティリティを作成します」)、 重複を防げます。

AIツールの統合に成功しているチームは、多くの場合、コーディング基準やプロンプティングの プラクティスについて合意することから始めています。 例えば、 チームは、一貫したスタイル (リン ティング規則、 プロジェクト規約) を決め、そのガイドラインをAIツールに反映させるでしょう (ス タイル設定やコード例を提供することで、 出力を制御するアシスタントもあります)。 Codacyのプ ログで述べられている (https://oreil.ly/FeEN_ ように、AIにチームのコーディング基準を慣れ 親しませることで、より均一で誰もが作業しやすいコードが生成されます。 実践的なレベルでは、プ ロジェクトのREADME に 「AI使用のヒント」 セクションを設け、 そこで「私たちは関数コンポーネ

76 | 3 章 70% 問題: 実際に動作する AI 支援ワークフロー

「ントのみを使います」 や 「Axios ではなく Fetch APIを使うことを好みます」といったことを明記し、 開発者がAIにプロンプトで指示する際に留意できるようにします。

もう1つのプラクティスは、もし利用可能なら、ツールの 「協働機能」を使うことです。 ユーザー がAIセッションや、少なくとも使ったプロンプトを共有できるAI支援IDEもあります。 開発者Aが 複雑なコンポーネント向けのプロンプトで素晴らしい結果を得た場合、 (おそらく、 課題管理システ ムやチームチャットを通して) そのプロンプトを開発者Bと共有することで、時間を節約し、 一貫性 を確保できます。

バージョン管理の使用に関しては、基本は変わりませんが、ひねりがあります。 Git (または、他 のバージョン管理システム) を使うことは、現代の開発では譲れないことであり、 それはバイブコー ディングでも変わりません。 実際、AIが素早くコードを生成するようになると、 バージョン管理は さらに重要になります。 コミットは、AIの誤りを捕捉する安全網として機能します。 AIが生成した 変更が何かを壊した場合、 あなたは以前のコミットに戻せます。

AI支援を使う場合、 より頻繁にコミットするのも、 1つの戦略です。 AIが (機能の生成や大規模 なリファクタリングといった) 重要なコード群を生成し、 それをあなたが受け入れるたびに、明確な メッセージを添えてコミットすることを検討します。 頻繁にコミットすることで、問題を切り分けた り、AIが導入したコードの一部を元に戻したりする必要が生じた時に、 履歴が十分に粒度が細かい ものになります。

また、AIが導入したさまざまな変更を分離するようにします。 AIに異なる領域にわたって多くの 変更を行わせ、 それらをまとめてコミットすると、 何か問題が発生した時に整理するのが難しくな ります。 例えば、パフォーマンスを最適化するためにエージェントを使い、そのエージェントがUI のテキストも調整する場合、 それらを別々にコミットします(2つのコミットメッセージは、「リスト 表示のパフォーマンス最適化 [AI支援]」 と 「ワークアウト完了メッセージのUIコピーの更新 [AI支 援]」かもしれません)。 説明的なコミットメッセージは、重要です。 チームによっては、追跡可能性 のために、AIが大きく関与したコミットにはタグを付けることさえあります。 「AI」 とタグ付けされ たコミットは、 レビュアーに対して、 そのコードがエッジケースについて特に徹底的なレビューが必 要であることを示すでしょう。

基本的に、チームは、 AIの使用を開発における会話の一部として扱うべきです。 体験や成功した テクニック、(「GitHub Copilot は Xに時代遅れのライブラリを使うことを提案しているので、注意 してください」といった) してはいけないことの警告を共有します。

このパターンでは、レビューとリファクタリングが重要です。 開発者は、手動でコードをレビュー し、モジュール性を高めるためにコードをリファクタリングし、包括的なエラー処理を追加し、 徹底 的なテストを書き、コードを改良する時に重要な決定を文書化しなければなりません。次章で、これ らのプロセスについて詳しく説明します。

3.1 開発者は実際にどのようにAIを使っているか | 77

3.1.2.2 ペアプログラマーとしてのAI

従来のペアプログラミングでは、2人の人が1つのワークステーションで協働します。 AIの出現に よって、人の開発者1人がAIアシスタントとともに作業するという、ハイブリッドなアプローチが登 場しました。 このセットアップは特に効果的であり、人の直感と機械の効率性を融合できます。

人とAIのペアでは、開発者は、 AIと対話してコードの提案を生成させ、 出力をレビューして改良 します。 この力学によって、 人は、 コード品質と関連性を確保するために監視しながら、 ボイラープ レートコードの作成、テストケースの生成といった繰り返しのタスクに対処する際に、 AIの速度を 活用できます。

例えば、 新しいライブラリを統合する際、 開発者は、 AIに初期統合コードを下書きするようにプ ロンプトで指示するかもしれません。その後、開発者はAIの提案をレビューし、 公式ドキュメント と相互参照して正確さを確認します。 このプロセスは、開発を加速させるだけでなく、 開発者がAI の出力とライブラリの複雑さの両方に深く関わることで、 知識の習得を促進します。

これを、 従来の人と人のペアプログラミングと比較してみましょう。

・「人とAIのペア」 は、 素早いコード生成を提供し、 ありふれたタスクに効率的に対処できる。 1 人で開発する場合や、チームのリソースが限られている場合に、 特に有益である。

・「人と人のペア」 は、 微妙な理解と協働的なブレインストーミングが不可欠な、複雑な問題解決 のシナリオに優れている。 共同所有とコードの共通理解が育まれる。

どちらのアプローチにも利点があり、 あなたがどちらを選択するかは、プロジェクトの複雑さ、リ ソースの有無、 開発プロセスの具体的な目標によって決められます。

3.1.2.3 AI ペアプログラミングのベストプラクティス

AI支援開発の利点を最大化するために、次のプラクティスを検討します。

異なるタスクのために、 新しいAIセッションを開始する

これによって、コンテキストが明確になり、 AIの提案が目の前のタスクに関連するようになり ます。

プロンプトを焦点を絞って簡潔にする

明確で具体的な指示を提供することで、AIの出力の品質が高まります。

頻繁に変更のレビューとコミットを行う

AIが生成したコードを定期的に統合してテストすることで、問題をすぐに見つけ、プロジェク トの勢いを維持できます。

緊密なフィードバックループを維持する

AIの貢献を継続的に評価し、必要に応じてAIに修正や改良を提供して、 AIの学習を導き、 将 来の提案を改善します。

| 3章 70% 問題: 実際に動作する AI 支援ワークフロー

3.1.2.4 検証者としてのAI

AIは、コード生成だけでなく、 コードレビューや品質保証を支援する貴重な検証者としての役割 を果たせます。 AIツールは、潜在的なバグ、セキュリティ脆弱性、 ベストプラクティスの順守につ いて、コードを分析できます。 例えば、 Deep Code や Snyk のAI駆動コードチェッカーといったプ ラットフォームは、入力サニタイズの欠落、安全でない構成といった問題を特定し、 開発環境内で 実用的な知見を直接提供できます。 QodoやTestGPTといったプラットフォームは、テストケー スを自動生成し、より幅広いカバレッジを確保し、手作業を減らせます。 また、多くのAIツールは、

アプリケーションパフォーマンス監視 (APM) を支援し、 根本的な問題を示す異常を検出できます。 AI検証者を開発ワークフローに統合することで、チームはコード品質を向上させ、 不具合の可能 性を減らし、 セキュリティ基準に順守するようにできます。 この検証への能動的なアプローチは、人 の監視を補完し、 より堅牢で信頼性の高いソフトウェアにつながります。 これらのツールは、繰り返 しの時間のかかるタスクに対処することで、品質保証 (QA) プロセスの効率と効果を高め、人のテ スターがQAのより複雑で微妙な側面に集中できるようにします。

ペアプログラマーでも検証者でも、開発プロセスにAIを組み込むことは、 生産性とコード品質を 向上させる機会を提供します。 これらのツールをよく考えて統合することで、開発者は人の知能と 人工知能(AI) の両方の強みを活用できます。

QAでAIと人の能力の利点を最大限に引き出すために、私はいくつかのベストプラクティスを推 奨します。

初期評価と予備スキャンにAIを使い、 明らかな問題を特定する。

●複雑な機能、 ユーザー体験、 AIの限界といった重要な領域については、 人によるレビューを優 先する。

AIのパフォーマンスと人の意思決定の両方を向上させるための継続的なフィードバックループ を備えた、 AIツールと人のテスターが連携する継続的な協働的な環境を醸成する。

3.2 バイブコーディングの黄金律

バイブコーディングは、 ソフトウェア開発にかつてない速度と創造的な自由を提供する一方で、そ の柔軟性のために、一貫した品質とチームの結束を確保するためには、構造化されたアプローチが 求められます。 AI支援開発の迅速で直感的な性質は、創造的な探求とエンジニアリングの規律との バランスを取る明確なガイドラインがなければ、すぐに混乱につながりかねません。

これらの黄金律は、バイブコーディングのワークフローへの統合を成功させたチームの、共同の 経験から生まれました。 これらは、 AIが得意とするところ、 つまずくところ、そしてプロセス全体 を通して人の判断がいかに不可欠であるかについて、 苦労して得た知見を表しています。 これらは、 創造性を制約するのではなく、本番環境対応のソフトウェアに必要な基準を維持しながら、チーム が自信を持って実験できるフレームワークを作成します。

78

3.2 バイブコーディングの黄金律 |

79

黄金律では、 バイブコーディングの3つの重要な側面、 すなわち、 人とAIの対話、 AI が生成した コードの既存システムへの統合、 そして、 持続可能なAI支援開発をサポートするチームプラクティ スの育成を扱っています。 これらのガイドラインに従うことで、チームは技術的負債、セキュリティ 脆弱性、 保守不能なコードベースにつながる一般的な落とし穴を回避しながら、 バイブコーディン グの変革の力を活用できます。

何を望んでいるのかを具体的かつ明確にする

AIとの対話では、 要件、 タスク、 成果を明確に示します。 的確なプロンプトが的確な結果を生 みます。

常にAIの出力を自分の意図に対して検証する

常に、AIが生成したコードを当初の目標に対して確認しなければなりません。 受け入れる前に、 機能、 ロジック、 関連性を検証します。

AIを (監督付きの) ジュニア開発者として扱う

AIの出力を、 あなたの慎重な監視を必要とする下書きと考えます。 フィードバックを提供し、 改良し、 品質と正しさを確保します。

思考を置き換えるのではなく能力を拡張するために、AIを使う

定型タスクや複雑なタスクを自動化するためにAIを活用しますが、 常に問題解決や意思決定に 積極的に関与し続けます。

コードを生成する前に、チーム内で前もって調整する

AI駆動開発を始める前に、 AIの使用基準、 期待されるコード、プラクティスについて、 チーム と連携します。

AI の使用を、 通常の開発の会話の一部として扱う

AIの経験、テクニック、 成功、 落とし穴について、 定期的にチームと議論します。 共同の改善 のためのもう1つのツールとして、AIを標準化します。

別々にコミットすることで、 GitでAIの変更を分離する

レビュー、ロールバック、 追跡を簡素化するために、 バージョン管理内でAIが生成した変更を 明確に識別して分離します。

人が書いたものでも、AIが書いたものでも、 すべてのコードがコードレビューを受けるようにする

すべての貢献を同じ厳格なレビュープロセスにかけることで、一貫した基準を維持し、コード 品質とチームの理解を高めます。

80 | 3章 70% 問題 実際に動作する AI 支援ワークフロー

理解できないコードをマージしない

AIが生成したコードを、 その機能と意味を十分に理解しない限り、決して統合しません。 理解 は、 保守性とセキュリティに不可欠です。

ドキュメント、コメント、 ADR *3を優先する

AIが生成したコードの根拠、機能、 コンテキストを明確に文書化します。 優れたドキュメント は、長期的に明確さを確保し、 将来の技術的負債を減らします。

効果的なプロンプトを共有して再利用する

高品質なAI出力につながるプロンプトを文書化します。 将来の対話を合理化し、 一貫性を高め るために、実績のあるプロンプトのリポジトリを維持します。

定期的に振り返り、 反復する

AI開発ワークフローを定期的にレビューして改良します。 過去の経験からの知見を使って、 チー ムのアプローチを継続的に強化します。

これらの黄金律を守ることで、 チームはAIを効果的に活用し、 生産性を向上させながら、明確さ、 品質、 制御を維持できます。

3.3 まとめと次の一歩

70%の問題は、 AI支援開発の現状を明確にしています。 これらのツールは、ボイラープレートや 定型的な関数を生成することには長けていますが、 エッジケースやアーキテクチャの決定、本番環 境対応を含む、最後の30%で苦戦しています。 私たちは、2つの主な使用パターンを特定しました。 MVPを素早く構築するブートストラッパーと、日々のワークフローにAIを統合するイテレーターで す。 また、 「二歩下がる」 アンチパターンや、印象的なプロトタイプが実世界の圧力で失敗する 「デ 「モ品質の罠」といった、一般的な失敗パターンも特定しました。

3つの実証済みのワークフローパターンが現れました。 最初の下書き作成者としてのAI (生成し てから改良する)、 ペアプログラマーとしてのAI (継続的な協働)、 検証者としてのAI(人が書いた コードとAIの分析) です。 バイブコーディングの黄金律は、明確なコミュニケーション、徹底的な 検証、チームの調整、そしてマージする前にすべてのコードを理解するという譲れない要件を強調 し、不可欠なガードレールを提供します。

個々の開発者は、ワークフローパターンを1つ選び、日々のプラクティスで黄金律を実装しながら、 体系的に実験すべきです。 コード生成でAIと競争するのではなく、 「4章 70%を超えて人の貫 献を最大化する」 で取り上げる持続的なスキル、 すなわち、 システム設計、デバッグ、 アーキテク チャのスキルを養うことに集中します。

*3 訳注: ADR(アーキテクチャ決定レコード)は、ソフトウェア開発における重要なアーキテクチャ上の意思決定を記録する 量な文書です。 背景や選択肢、決定理由を明示することで、チーム内での透明性、知識共有、 履歴管理を可能にします。

3.3 まとめと次の一歩 |

チームは、 AIの使用基準を確立し、 効果的なプロンプトの共有リポジトリを作成し、AIの考慮事 項を既存のアジャイルプラクティスに統合する必要があります。 成功と落とし穴に関する定期的な知 識の共有は、チームがAIの利点を最大化しながら、よくある罠を回避するのに役立ちます。

自律型AIコーディングエージェントが出現するにつれて、 人の役割はアーキテクチャの監視と戦 略的意思決定へと転換していくでしょう。 次章では、このかけがえのない人の貢献を最大化し、 あ らゆるレベルのエンジニアが、競争相手としてではなく、 ますます有能になるAIシステムのパート ナーとして成功するための方法を探ります。

81



| 83

4章

70%を超えて:

人の貢献を最大化する

あなたは、 Cursor, Cline, GitHub Copilot, Windsurf といったAIコーディングアシスタン トが、ソフトウェアの構築方法を変革し、 多く (約70%) の雑務やボイラープレートを引き受けてい るのを見てきました*1。 しかし、 おもちゃの解決策と本番環境対応のシステムとを区別する、 最後 の 「30%」 の仕事はどうでしょうか? このギャップに、 複雑な要件の理解、 保守可能なシステムアー キテクチャ設計、エッジケースへの対処、 コードの正確性の確保といった難しい部分が含まれます。 言い換えれば、AIは 「コード」 を生成できますが、 多くの場合、「エンジニアリング」で苦労するとい うことです。

ティム・オライリーは、数十年にわたるテクノロジーの変遷を振り返り (https://oreil.ly/ BYrNh)、 自動化の飛躍的進歩のたびにプログラミングの 「方法」 は変化してきましたが、熟練プロ グラマーが必要な 「理由」 は変わっていないことを指摘しています。 私たちは、プログラミングの終 焉に直面しているのではなく、 「今日私たちが知っているプログラミングの終焉」 に直面しているの です。 これは、開発者の役割が進化しているのであって、消滅しているわけではないことを意味し ます。

今日のエンジニアの課題は、 AIが最も得意とすること (最初の70%) を受け入れる一方で、残りの 30%に必要な持続的なスキルと知見を倍増させることです。 本章では、専門家の知見から、 人のど のスキルが引き続き重要かを明らかにします。 シニア/ミドルレベルの開発者が引き続き活用すべき ものと、ジュニア開発者がAIとともに成長するために投資すべきものを探ります。

本章の目標は、あらゆるレベルのエンジニアにとっての実用的な指針を提供し、かけがえのない 30%の価値を最大化することです。

4.1 シニアエンジニアと開発者 AIの経験を活かす

もしあなたがシニアエンジニアなら、AIコーディングツールの出現を、 あなたの経験を適切な方

1 本章は、私のSubstackニュースレターに最初に掲載した2つのエッセイを基にしています。 「70%を超えて AI 支援コーディ ングで人の30%を最大化する」 (https://oreil.ly/PMFsp) (アディオスマニ著 Elevate with Addy Osmani, 2025年3月13日)、 「あなたのソフトウェアエンジニアリングのキャリアを時代遅れにならないようにする」 (https://oreilly/1EoW8) (アディ オスマニ著 Elevate with Addy Osmani 2024年12月23日) を参照。

84 | 4章 70%を超えて人の貢献を最大化する

法で活用すれば、あなたの影響を増幅できる機会だと捉えるべきです。 シニア開発者は、通常、深 いドメイン知識、何がうまくいかないかに対する直感、 高度な技術的判断を下す能力を持っていま す。

これらの強みは、 AIだけでは処理できない30%の部分です。 本節では、 経験豊富な開発者が自分 の価値を最大化する方法について見ていきます。

4.1.1 アーキテクトになり、 編集長になる

AIにコードの最初の下書きを任せて、 あなたは、 解決策のアーキテクチャを設計し、 AIの出力を 改良することに集中しましょう。 スティーブイェッゲ (https://oreil.ly/Qt7_ は、 「多くの組 織において、チームに「シニアアソシエイトだけ」が必要とされるような転換が起こるかもしれない」 と書いています。 彼らは、(a) 実行すべきタスクを説明する、つまりプロンプトを作成する、 (b 果の作業の正確さと正しさをレビューする役割を担います。 このモデルを受け入れましょう。 シニア 開発者として、 あなたは、 複雑な要件をAIアシスタントのための効果的なプロンプトや仕様に変換 し、その後、 あなたの批判的な目を使って、 作成されたすべての行を検査できます。 あなたはAIと ペアプログラミングをしているようなものであり、 AIは入力は速いですが、 頭脳はあなたなのです。

レビュー中は、高い基準を維持してください。 コードが、 あなたの組織の品質、セキュリティ、パ フォーマンスの基準を満たしていることを確認してください。 アーキテクト兼編集者として行動する ことで、「高いレビューの負担」に圧倒されるのを防ぎます (注意: もしジュニアスタッフが、AIの 生の出力を単にあなたに渡してくるようなら、 差し戻してください。 彼らが、 AIが生成した作業を 最初に検証しなければならないプロセスを確立して、 あなたが唯一の安全網ではなくなるようにして ください。

4.1.2 大きなイニシアチブの 「力を増強させるもの」として、AIを使う

シニアエンジニアは、多くの場合、大規模なプロジェクトを推進したり、 ジュニアだけではアプ ローチできない厄介なリファクタリングに取り組んだりします。 AIは、あなたの指導の下で、 多く の機械的な変更に対処したり、 代替案を探ったりすることで、こうした取り組みを加速させることが できます。 スティーブイェッゲは、この種の作業のために、チャット指向プログラミング (CHOP) (https://oreil.ly/QU7 ) という用語を導入しました。 これは、AIを協働者とした 「反復的なプロ ンプト改良によるコーディング」です。 CHOPを活用することで、あなたが引き受けていることによ り意欲的に取り組めます。

AIの支援を受けることで、プロジェクトに時間を投資する価値があるかどうかのハードルが下が ります。 数日かかっていたことが、今では数時間でできるようになるからです。 そのため、 シニア開 発者は、いつも手が届かないと思われていた「こうなったらいいな?」 というプロジェクトに挑戦で きます。

重要なのは、指導的な思考を保ち続けることです。 どのツールやアプローチを追求すべきかを決

4.1 85

シニアエンジニアと開発者: AIの経験を活かす |

定し、断片を統合して全体としてのまとまりを持たせます。 あなたの経験によって、 AIの提案を選 別できます。

4.1.3 指導し、基準を設定する

シニアエンジニアのもう1つの重要な役割は、 経験の浅いチームメンバーに、AIの効果的な使い 方や、 時代を超えたベストプラクティスを指導することです。 あなたは、 メモリリーク、 オフバイワ ンエラー、 同時実行性の危険性など、 ジュニアが気付かない落とし穴について、 苦労して得た知識 を持っている可能性が高いでしょう。

ジュニアがAIを使ってコードを生成する可能性がある今、彼らにそのコードを自己レビューして テストする方法を教えることが重要です。AIの貢献を徹底的にテストする方法を示すことで模範を 示し、マシンの出力に疑問を持って検証する文化を奨励してください。 (法律事務所すらも含む) 一 部の組織では、誰かがAIを使ってコードや文章を生成した場合、 「先輩が間違いを見つけてくれる だろう」と思わずに、 「それを開示し、 自分で結果を検証」 しなければならないという規則を設けてい ます。

シニアエンジニアとして、 チーム内でそのような規範を支持してください。 AIは歓迎されますが、 勤勉さが求められます。 このようにジュニアを指導することで、監視の負担を減らし、 彼らがより早 <30%のスキルセットを身につけられるようにするのです。

4.1.4 ドメインへの精通と先見性を養い続ける

あなたの幅広い経験とコンテキストは、これまで以上に重要性を増しています。 シニア開発者は 多くの場合、 社内の物事が特定の方法で構築されている理由や、 業界がどのように活動しているか について、歴史的な知識を持っています。 このようなドメインに精通することで、 新人が気付かない AIの間違いを見つけられます。

問題ドメインを深く理解するために、投資を続けてください。 それは、ビジネスのニーズ、ユー ザーフィードバック、ソフトウェアに影響を与える新たな規制について、常に最新の情報を得ること を意味するでしょう。 あなたが指示しない限り、 AIはこういった考慮事項を自動的に取り入れるこ とはありません。 あなたのドメインに対する知見とAIの速度を組み合わせることで、 最高の成果を 得られます。

また、先見性を使って、 AIを操縦してください。 例えば、素早い修正が将来、 保守の痛みを生 むことがわかっている場合、 より持続可能な解決策を実装するように、AIに指示できます。 あなた が長年磨いてきた直感を信じてください。 コードスニペットが「外れている」ように見えたり、 あま りにも出来が良すぎたりしたら、 掘り下げてください。 十中八九、 あなたの直感は、AIが考慮しな かった何かを見抜いています。 コードの2次的、 3次的効果を予見できることは、シニアエンジニア の特徴です。 AIの便利さによって、その習慣を鈍らせないでください。 むしろ、 AIが生み出すもの には何でも、その習慣を適用してください。

86 | 4章 70%を超えて人の貢献を最大化する

4.1.5 ソフトスキルとリーダーシップを磨く

AIがコーディングの一部を引き受けることで、シニア開発者はエンジニアリングの人的側面によ りエネルギーを使えます。 利害関係者とコミュニケーションし、設計会議を主導し、テクノロジー とビジネス戦略を合わせる判断を下します。 ティム・オライリーなどは (https://oreil.ly/rbIKm)、 暗記コーディングが容易になるにつれて、 「何」 を構築し、 複雑なシステムを「どのようにオーケスト 「レーションする」かを決定することに、価値が移っていくことを示唆しています。

シニアエンジニアは、 多くの場合、 オーケストレーション (調整) して全体像を把握する役割を 担っています。 その役割に踏み出してください。 アーキテクチャのロードマップを書いたり、(AIで も、そうでなくても)どのツールを採用すべきかを評価したり、 社内のAIコーディングガイドライン を定義したりすることを志願してください。 これらはAIができないタスクであり、経験、 人の裁量、 そして多くの場合、 チーム横断的な合意形成が必要となります。 リーダーシップの存在感を高める ことで、あなたが (他のツールで代替可能な) コード生成者であるだけではなく、チームを導く不可 欠な技術リーダーでもあるようにします。

要するに、経験豊富な開発者が最も得意とする 「森を見て木も見る」 (「木を見て森を見ず」 の逆) を続けることです。 AIはより多くの木を切る手助けをしてくれますが、それでも誰かが「どの」 木を 切り、「どのように」 その材木から安定した家を建てるかを決める必要があります。 あなたの判断力、 戦略的思考、そして指導が、 今やさらに重要になっているのです。 AIを効果的に活用するシニア開 発者は、そうでない開発者よりも生産性が劇的に向上します。 しかし、 本当に優れた開発者は、 AI をただ野放しにするのではなく、人の強みを活かしてAIの出力を増幅させる人でしょう。

あるRedditユーザーが観察した (https://oreil.ly/HulC9) ように、 「AIはプログラミングの力 を増強させるもの」であり、「シニアプログラマーの生産性を大幅に向上させます」。 増強効果は本物 ですが、増強されているのはあなたの専門知識です。 その専門知識を常に研ぎ澄まし、 開発プロセ スの中心に置いてください。

4.2 ミドルエンジニア: 適応と特化

ミドルエンジニアは、おそらく最も大きな圧力に直面しています。 機能の実装、テストの記述、単 純な問題のデバッグなど、 従来時間を割いていたタスクの多くが、 自動化されつつあります。 これは、陳腐化ではなく昇格を意味しています。次節では、コードを書くことから、より専門化さ れた知識を構築することにフォーカスが移っていることを探ります。

4.2.1 システム統合と境界の管理を学ぶ

システムが複雑化するにつれて、 コンポーネント間の境界を理解して管理することが重要にな ります。 これには、API設計、 イベントスキーマ、 データモデルが含まれており、 ビジネス要件と将 来の柔軟性を慎重に考慮する必要があります。 次のような分野の高度な理解を得ることを含め、コ ンピューターサイエンスの基礎を深めてください。

4.2 ミドルエンジニア 適応と特化 |

●データ構造とアルゴリズム

• 分散システムの原則

● データベースの内部構造とクエリの最適化

ネットワークプロトコルとセキュリティ

この知識は、AIが生成したコードの意味を理解し、 より良いアーキテクチャの決定を下すのに役 立ちます。

エッジケースや曖昧さの対処方法も学んでください。 実世界のソフトウェアには、奇抜なシナリオ や変化する要件があふれています。 AIは、デフォルトでは一般的な場合を解決する傾向があります。 「もし・・・だったらどうなりますか?」と問いかけ、 弱点を探るのは、 開発者次第です。

ここでの持続的なスキルは、 批判的思考と先見性です。 エッジケースを列挙し、 失敗を予測し、 コードや設計でそれらに対処します。 これは、空の入力、ネットワークの停止、ユーザーの異常な 行動、 他のシステムとの統合を考えることを意味します。

4.2.2 ドメインの専門知識を築き上げる

ビジネスコンテキストやユーザーの環境を理解することで、一般的なAIが知らないエッジケース が明らかになります。 経験豊富なエンジニアは、こういったシナリオを習慣的に検討しています。 体 系的に境界をテストし、 想定に疑問を持つことを実践してください。 人の理解が不可欠な複雑なド メインに特化してください。 一般的なドメインには、次のものがあります。

● 規制要件のある金融システム

●プライバシーに関わる医療システム

パフォーマンス要件が厳しいリアルタイムシステム

・機械学習の基盤

ソフトウェアエンジニアリングに特化したドメインには、フロントエンドやバックエンドのエンジ ニアリング、モバイル開発、 DevOps、セキュリティエンジニアリングなどがあります。 ドメインの 専門知識は、現在のAIツールに欠けているコンテキストを提供し、 AIツールを適用する場所と方法 について、より適切な判断を下すのに役立ちます。

4.2.3 パフォーマンス最適化とDevOpsを習得する

LLMは基本的な最適化を提案できますが、システム全体のパフォーマンス問題を特定して解決す るには、データベースのクエリパターンからフロントエンドのレンダリング戦略まで、 スタック全体 を深く理解する必要があります。 コード生成が自動化されるほど、システムが本番環境でどのように 動作しているかを理解することの価値が高まります。

次のような分野に注力してください。

87

88 | 4 章 70%を超えて: 人の貢献を最大化する

● 監視と可観測性

パフォーマンスのプロファイリングと最適化

セキュリティのプラクティスとコンプライアンス

コストの管理と最適化

4.2.4 コードレビューと品質保証に注力する

AIが多くのコードを書くようになると、そのコードを厳密にレビューしてテストする能力が、 さ らに重要になります。 スティーブイェッゲは、 「誰もが、コードのテストとレビューにもっと真剣 になる必要があります」と強調しています (https://oreil.ly/Qt7_) AIが生成したコードを、 人 のジュニア開発者の出力と同じように扱ってください。 あなたが、 バグやセキュリティの欠陥、 ずさ んな実装を見つける責任を負うコードレビュアーなのです。 これは、単体テスト、 統合テスト、 デ バッグのスキルを強化することを意味します。

良いテストを書くことは、仕様を理解し、 正しさを検証することを強いる、 持続的なスキルです。 そうでないことが証明されるまでは、何も動作しないと想定するのが賢明です。 AIは、 多くの場合、 あなたが反復的な改善を通してコードを導くまで、 機能的だが最適化されていないコードを生み出 します。 これには、コーディングモデルがトレーニングされたトレーニングデータが、 すべてのベス トプラクティスを完全に反映しているわけではないなどの、 さまざまな理由が考えられます。

テストの考え方を養ってください。 すべての重要なロジックパスを検証し、 静的解析やリンターを 使い、 AIから与えられたコードが品質基準を満たさない場合、 コードを書き直すことをためらわな いでください。 前章で説明した 「検証者としてのAI」 パターンに従っているとしても、品質保証は単 にAIにアウトソーシングすべき領域ではありません。 これは、 人の勤勉さが輝く場所です。 ソフト ウェアが期待通りに動作しない場合、 それを診断して修正するためには、真の問題解決の技術が必 要となります。 AIは (例えば、 考えられる原因を提案することで) デバッグを支援できますが、アプ リケーションが実行されている特定のコンテキストに対する真の理解に欠けています。 人のテスター は、現在のAIには欠けている、 ドメイン固有の知識とユーザーの期待に対する理解を持っています。 この知見は、潜在的な問題の関連性と影響を評価する際に不可欠です。 複雑なバグを診断するには、 多くの場合、創造的な問題解決と幅広い要素を考慮する能力が必要です。 これは、本質的に人のス キルです。 また、 公正さやアクセシビリティなど、ソフトウェアの振る舞いの倫理的な意味を評価す るには、 人の感性と判断力が必要となります。

複雑なバグを推論する能力は、時代を超えたエンジニアリングスキルです。 これは、バグを再現 させ、原因を切り分け、 基盤となるシステム (OS、 データベース、 ライブラリ) を理解することです。 そのためには、多くの場合、 (メモリやステートの動作、 同時実行性といった) 基礎をしっかりと理 解する必要があり、 ジュニア開発者は実践を通してそれを学ばなければなりません。 AIをヘルパー として使ってください (AIはエラーメッセージを説明したり、 修正を提案したりするかもしれませ ん)。 しかし、 「軽率にAIを頼らないでください」。 デバッグ時にトラブルシューティングを整然と行

89

4.2 ミドルエンジニア 適応と特化 |

い、 基本原則を適用するスキルは、優れた開発者を際立たせます。 これは、フィードバックループ でもあります。 AIが書いたコードをデバッグすることで、次回により良くAIにプロンプトで指示を したり、 特定のパターンを避けたりすることを学べます。

4.2.5 システム思考を学ぶ

ソフトウェアプロジェクトは単なる単独のコーディングタスクではなく、 ユーザーのニーズ、タイ ムライン、レガシーコード、 チームプロセスといった大きなコンテキストの中に存在します。 (多く の場合、 現実的ではないですが、プロンプトにすべてを明示的に入力しない限り) AIは、プロジェ クトの歴史や、 特定の決定の背後にある論理的根拠など、 全体像について生まれながらの感覚を 持っていません。 人がそのコンテキストを伝える必要があります。

ここでの持続的なスキルは、 システム思考です。 これは、システムのある部分の変更が他の部分 にどのように影響するか、ソフトウェアがどのようにビジネスの目的に役立つか、 そして、 すべての 要素がどのようにつながっているのかを理解することです*2。 この全体的な視点によって、 AIの出力 を適切に使えるようになります。 例えば、 AIが規制要件や社内の慣例に反する巧妙な抜け道を提案 しても、あなたはコンテキストを知っているため、それを見つけられます。 何が合って何が合わない かを判断できるように、必ず、 プロジェクトの背景を学び、 設計ドキュメントを読んでください。

4.2.6 適応力を持ち、 学び続ける

最後は、メタスキルである 「新しいツールを学び、 変化に適応する能力」 です。 AI支援開発の分野 は急速に進化しています。 広い心を保ち、 AIの新機能の効果的な使い方を学ぶエンジニアは、時代 を先取りし続けます。 ティム・オライリーは、 「新しいスキルを学ぶことに熱心な」 開発者が、 AIに よる最大の生産性向上を経験するだろうと示唆しています (https://oreil.ly/BYrNh)。 「基礎」 を 深く学び、 新しいテクニックに好奇心を持ち続けることに投資してください。 この組み合わせによっ て、AIに依存することなく、 ツールとしてAIを活用できるようになります。

バランスが求められます。 AIを使って成長を加速させつつ、 本質的な学習をさぼらないようにす るため、時にはAIなしで実践してください (生のコーディングスキルを鋭く保つために、定期的に 「AI デトックス」 (https://oreil.ly/XFPqu) を行う開発者もいます)。 要するに、 常に学び続けるエ ンジニアになってください。 それが、どんな時代でもキャリアにとって安全なスキルなのです。

4.2.7 機能横断的なコミュニケーションが得意になる

ビジネス要件と技術的な解決策との間を変換する能力は、 実装時間が短くなるほど、 価値が高ま ります。 プロダクトマネージャー、デザイナー、 他の利害関係者と効果的にコミュニケーションでき るエンジニアは、ますます価値が高まるでしょう。 ここで注目すべき分野は、次の通りです。

2 システム思考についてさらに学ぶには、 Donella H. Meadows, 「Thinking in Systems: A Primer」, 2nd edition (Rizzoli, 2008). Peter M. Senge, 「The Fifth Discipline: The Art and Practice of the Learning Organization」 (Crown, 2010)を調べてくだ さい。

90 | 4章 70%を超えて人の貢献を最大化する

・要件の収集と分析

● 技術文書の作成と文書化

プロジェクトの計画と見積もり

・チームのリーダーシップと指導

4.2.8 システム設計とアーキテクチャを学ぶ

ミドルエンジニアは、 新機能の実装に何日も費やす代わりに、 規模や故障モードに正常に対処 する堅牢なシステムの設計に時間を費やすかもしれません。 そのためには、 分散システムの原理、 データベースの内部構造、 クラウド基盤を深く理解する必要があります。 これらは、現在LLMが提 供できる価値が限られている分野です。

大規模な実世界の問題を解決するシステムの設計を実践してください。 こういったスキルは、ビ ジネス要件とエンジニアリングのトレードオフの理解を必要とするため、コードがどのように生成さ れるかにかかわらず、価値が高いものです。

一貫したシステムを設計するには、トレードオフ、 制約、 そしていくつかの関数を書く以上の 「全 「体像」を理解する必要があります。 AIはコードを生成できますが、 複雑な問題に対して最適なアー キテクチャを自動的に選択することはできません。

コンポーネントの対話、データの流れ方、スケーラビリティとセキュリティを確保する方法といっ 全体的な設計は、人の知見を必要とする30%の部分です。 これには、次のものが含まれます。

負荷分散とキャッシュ戦略

データのパーティション分割とレプリケーション

故障モードと復旧手順

コスト最適化とリソース管理

シニア開発者は、長い間このスキルを磨いてきました。 ミドル / ジュニア開発者は、積極的にこの スキルを養うべきです。 (関心事の分離、 モジュール性といった) パターンや原則の観点から考えて ください。 これらは、AIが生成した解決策を保守性に導きます。 「確かなアーキテクチャが、 偶然生 まれることはない」ということを覚えておいてください。 これには、経験豊富な人の手がハンドル を握る必要があります。

4.2.9 AI を使う!

AIはワークフローに統合されるべきものであり、 抵抗するものではないことを覚えておいてく ださい。 日々の仕事にAIを取り入れる実践的な方法には、次のものがあります。

• 初期コード構造のスキャフォールディング (足場作り)

• 素早いプロトタイプと概念実証 (PoC)

4.2 ミドルエンジニア: 適応と特化 |

91

● 素早いデバッグと問題解決のための、 ペアプログラミング

・ 最適化と代替アプローチの提案

● アーキテクチャと設計の決定に集中しながらの、繰り返しのコードパターンへの対処

4.2.10 UI/UXデザインに挑む

ミドルソフトウェアエンジニアは「辞めるべきだ」という説が広まっています。 これは、AIが実 装の詳細に対処するにつれて、純粋なエンジニアリングスキルは時代遅れになるという説です。 こ の結論は大げさですが、 (デザインなどの) エンジニアリング以外のスキルの重要性に関する言説は、 検討に値します。 2024年12月のXでの代表的な交流で、 @fchollet (https://oreil.ly/BokTH) は、 次のように書きました。

近い将来、 テスト時計算 *3 を 「能力」 に変換できる世界が訪れるでしょう。 ソフトウェアの歴史上 初めて、限界コストが重要になります。

それに対して、 @garrytanはこう答えました。

UX、デザイン、技術への実際の献身が、この次の瞬間に主役となります。

人々が欲しがるものを、実際に作ってください。 ソフトウェアやコーディングが決め手になるわけ ではありません。 優れたソフトウェアを作成するのは、博識になり、 多くのドメインで賢く効果的で ある能力なのです。

成功するソフトウェア作成には、常にコーディング能力以上のものが必要とされてきました。 変化 しつつあるのは、エンジニアリングの死ではなく、純粋な実装の障壁が下がっていることです。 この 変化によって、エンジニアリングの判断力やデザイン思考は、重要でなくなるのではなく、 より重要 になるのです。

Figma Notion、 VS Code といったアプリケーションを成功させているものは何か、考えてみて ください。それは、単に技術的に優れていることだけでなく、ユーザーのニーズ、ワークフロー、課 題点を深く理解していることなのです。 この理解は、次のものから生まれます。

・ユーザー体験のデザイン思考

●深いドメイン知識

・人の心理と振る舞いに関する理解

• パフォーマンス、信頼性、スケーラビリティを考慮したシステム設計

ビジネスモデルとの一致

*3訳注: テスト時計算 (Test-Time Compute) とは、 AIモデルが推論 (テスト時)に使う計算リソースを増加させ、その過 程でより複雑で高精度な応答を生成する技術を指します。

4 : 従来はソフトウェアの複製・実行コストがほぼゼロだったが、AI推論では1回ごとの計算コストが無視できなくなると いう意味です。

92 | 4章 70%を超えて人の貢献を最大化する

最高のエンジニアは常に、単なるコーダーではありません。 彼らは、技術的制約と人のニーズの 両方を理解する問題解決者です。 AIツールが実装の摩擦を減らすにつれて、 この総合的な理解の価 値はさらに高まります。

しかし、これは、すべてのエンジニアがUXデザイナーになる必要があるという意味ではありませ ん。 むしろ、 より強力なプロダクト思考能力を開発し、デザイナーやプロダクトマネージャーとのよ り良い協働のスキルを養うことを意味します。 ユーザーについてより深く考え、ユーザーの心理や振 る舞いのパターンを理解し、 ユーザー体験の目標をサポートする技術的な決定を下すことを学ぶと いうことです。 あなたは、技術的な優雅さを達成する段階まで来ています。 ここで、 実用的なユー ザーニーズに細心の注意を払うことで、バランスを取るのです。

将来は、(自分がより優れたデザイン感覚を養うことを通して、 または、 専属のデザイナーとより 効果的な協働をすることを通して) 人のニーズと技術的な解決策との間のギャップを埋められるエン ジニアのものです。

4.3 ジュニア開発者: AI とともに成長する

あなたがジュニア開発者や経験の浅い開発者であれば、 AIに対して興奮と不安が入り混じった 感情を抱くかもしれません。 AIアシスタントは、あなた自身が書き方を知らないようなコードを 書くことができ、 あなたの学習を加速させる可能性があります。 しかし、 「ジュニア開発者の死」 (https://oreil.ly/Q7) を報じる見出しが出ており、エントリーレベルのコーディング職が危機 にさらされていることを示唆しています。 この人気の高い憶測とは裏腹に、 AIは初期キャリアの経 験を大きく変えつつありますが、 ジュニア開発者が 「時代遅れになったわけではありません」。

あなたは、AIが量産できる以上の価値に貢献できるようにするスキルを、積極的に養う必要があ ります。 基本的なCRUDアプリケーションや単純な機能の実装を通して学ぶという従来の道は、こ ういったタスクの自動化が進むにつれて、 進化していくでしょう。

典型的なジュニアのタスクを考えてみましょう。 そのタスクは、既存のパターンに従った、新しい APIエンドポイントの実装です。 これまでは、コーディングとテストに1日かかっていたかもしれま せん。 AIの支援があれば、 実装にかかる時間は1時間に短縮されるかもしれませんが、 重要なスキ ルは次のものになります。

● 要件を正しく定義できる程度に十分に、 既存のシステムアーキテクチャを理解する • 生成されたコードにセキュリティ上の影響やエッジケースがないか、 レビューする

• 実装が既存のパターンとの一貫性を維持していることを確認する

ビジネスロジックを検証する包括的なテストを書く

こういったスキルは、単にチュートリアルやAIのプロンプティングを通して学ぶことはできませ ん。 本番システムでの実務経験とシニアエンジニアからの指導が必要です。

この進化は、初期キャリアの開発者に課題と機会の両方をもたらします。 エントリーレベルの職の

4.3 ジュニア開発者: AI とともに成長する |

93

ハードルは上がり、 AIが生成したコードを効果的にレビューして検証するための、 より強力な基礎 知識が求められるようになるかもしれません。 しかしこの変化は、ジュニアエンジニアがキャリアの 早い段階で、より興味深い問題に取り組める可能性があることも意味しています。

ここでは、この30%のギャップに効果的に対処するための自己投資方法について、説明します。

4.3.1 基礎を学ぶ: 「なぜ」 を省略しない

あらゆる質問 (「PythonでXを行うには、どうすればよいですか?」) に対する回答をAIに求めた くなりますが、根本的な概念を真に吸収することは決してありません。 その衝動に抵抗してください。 単なる回答の自動販売機としてではなく、 家庭教師としてAIを使ってください。 例えば、 AIがあな たにコードの一部を示したら、「なぜ」 そのアプローチを選んだのかを尋ねたり、コードを一行ずつ 説明させたりしてください。

データ構造、 アルゴリズム、メモリ管理、 同時実行性といった概念を、 常にAIに委ねることなく、 理解するようにしてください。 理由は簡単です。 AIの出力が間違っていたり不完全だったりした場 合、それを認識して修正するためには、あなた自身のメンタルモデルが必要だからです。 なぜAIが 特定のコードを生成するのかに積極的に関与しなければ、 実際に学習量が減り、あなたの成長を妨 げることになるかもしれません。 したがって、 ドキュメントを読み、 小さなプログラミングをゼロ から書き 中心的な知識を固めるために、時間を取ってください。 これらの基礎知識は持続的です。 周りのツールが変わっても、 あなたの役に立ちます。

4.3.2 AIの安全網なしで問題解決とデバッグを実践する

真の自信を築くには、時には単独飛行する必要があります。 多くの開発者は、 「AIなしの日」を作 るか、定期的にAIの支援を制限することを勧めています。 こうすることで、 自分のスキルだけで問 題解決ができるようになります。 これは、スキルの萎縮を避けるために重要なことです。 あなたは、 問題のロジックを真に考え抜くことを強いられることに気付くでしょう。 その結果、 (より知的にAI に指示できるようになるので) AIの使い方がうまくなります。

さらに、AIが生成したコードでバグやエラーに遭遇した時は、AIに修正を依頼する前に、「自分」 で飛び込んでデバッグしてください。 デバッガーを通してステップ実行したり、 print文を追加した りして、 何が間違っているのかを確認することで、より多くのことを学べます。

AIの提案は、 最終回答ではなくヒントだと考えてください。 時間をかけて、 タスクの最後の厄介 な部分に取り組むことで、 AIが苦手とする分野のスキルを身につけます。 これは、まさにあなたの 価値を高めます。

4.3.3 テストと検証に集中する

ジュニア開発者として、 あなたが身につけられる最良の習慣の1つは、自分のコードのテストを書 くことです。 AIを使ってコードを生成するのであれば、これはいっそう当てはまります。

| 4章 70%を超えて人の貢献を最大化する

LLMから一連のコードを受け取ったら、それが正しいと想定せず、疑ってください。 単体テスト を書いて(あるいは、手動テストを使って)、 それが本当に要件やエッジケースに対処しているかど うかを確認してください。 これは、2つのことを達成します。 AIの出力の問題点を見つけることと、 実装を信頼する前に期待される振る舞いについて考える訓練をすることです。

あなたはテスト作成にAIを使うかもしれませんが、 何をテストするかを定義するのは「あなた 自身」です。 テストとコードレビューに真剣に取り組むというスティーブイェッゲのアドバイス (https://oreil.ly/QtJ7) は、 あらゆるレベルで当てはまります。 (AI支援だろうと、なかろうと) 自分の作業を注意深く検証しているという評判を育てれば、上級の同僚はあなたをより信頼するよう になりますし、あなたが疑わしいコードをただ「捨てている」 と彼らが感じるようなシナリオも避け られます。

実用的な面では、テストを後付けではなく、 開発の不可欠な部分として扱い始めてください。 テ ストフレームワークの使い方、 探索的手動テストの方法、体系的なバグ再現の方法などを学んで ください。 こういったスキルは、 あなたが30%の作業をよりうまくこなせるようにするだけでなく、 コードが実際にどのように動作するのかについてのあなたの理解を加速させます。

覚えておいてください。 AIが導入したバグをあなたが見つけた場合、 「あなた」はAIができなかっ たことをしたことになります。 それが付加価値です。

4.3.4 保守性の目を養う

ジュニア開発者は多くの場合、「動くようにする」ことに集中します。 しかしAIの時代には、基 本的な動作するバージョンを作るのは簡単です。 難しいのは (そして、 あなたが集中すべきなのは)、 読みやすく、 保守しやすく、クリーンなコードを作ることです。

優れたコードの構造とスタイルを見極める目を養うことから始めてください。 AIの出力をあなた が知っているベストプラクティスと比較し、 AIコードが乱雑だったり複雑すぎたりする場合は、率 先してリファクタリングしてください。 例えば、 LLMが50行の関数を出力し、その関数があまりに も多くのことを行っている場合、それをより小さな関数に分割できます。 変数名が不明瞭なら、 名前 を変えてください。

基本的には、同僚のコードをレビューしているふりをして、 AIコードを同僚が書いたコードのよ う改善してください。 こうすることで、優れた設計原則を内面化できます。 時とともに、 あなたは、 (あなたが望むスタイルをあなたが指定するので) 初めよりクリーンなコードを得られるような方法 で、AIにプロンプトで指示し始めるでしょう。 (多くの場合、数か月後や数年後に作業している) ソ フトウェアメンテナー (保守担当者) はあなたに感謝するでしょう。 そして、 あなたは 「実行させる」 ことだけを超えて考えている、つまり、 あなたはエンジニアのように考えていることを証明すること になります。 保守性を維持することは、まさに人が主導する30%の中にあるので、キャリアの最初 から、それを関心事としてください。

94

4.3 ジュニア開発者: AI とともに成長する | 95

4.3.5 プロンプティングとツールのスキルを賢く) 養う

「プロンプトエンジニアリング」 (AIツールと効果的に対話するスキル) が有益であることは、否 定しません。 ジュニア開発者は、 AIへの質問の表現方法、 適切なコンテキストの与え方、 出力を改 善するためにプロンプトを反復的に改良する方法を、 絶対に学ぶべきです (手始めは、本書の「2章 プロンプトの芸術: AIと効果的にコミュニケーションする」 が良いでしょう)。 これらは、あなた を際立たせる新しいスキルです (経験豊富な開発者の多くも、 まだこのことを理解しつつあります)。 しかし、優れたプロンプティングは、 多くの場合、 問題をよく理解していることのプロキシであるこ とを覚えておいてください。 あなたがAIに思い通りにさせられないと気付いたら、それは「あなた」 がまず、 自身の理解を明確にする必要があるからかもしれません。 それを合図にしてください。

AIに実装を頼む前に、 自分で平易な言葉で解決策を概説してみるのも、 1つの戦略です。 また、 (GitHub Copilot, Claude といった) さまざまなAIツールを試してみて、 それぞれの強みと弱みを 確認してください。 これらのアシスタントを使いこなすほど、 生産性を向上できます。 しかし、決し てその出力を完璧なものとして扱わないでください。 AIを、 超強力なStack Overflowのようなも のだと考えてください。 助けにはなりますが、 権威ではありません。

自分の限界に挑戦するために、 AIを使って小さな個人プロジェクトを立ち上げることもできる でしょう (「AIの助けを借りて、 簡単なウェブアプリを作れないか?」)。 そうすることで、AIを開 発ワークフローに統合する方法を学びます。 これは、チームに持ち込むと非常に有用なスキルです。 ただ、前述したように、 AIなしで作業する期間とバランスを取ってください。

4.3.6 フィードバックと指導を求める

最後に、 あなたの成長を加速させる持続的なスキルは、 フィードバックを求め、他から学ぶ能力 です。AIはそのアドバイスを無視しても気を悪くしませんが、人のチームメイトやメンターは、あ なたの成長にとってかけがえのない存在です。 特に、 ソフトスキル リーダーシップ、コミュニケー ション、 社内政治をうまく立ち回ることに関してはなおさらです。

AIが提案した内容と異なる場合には特に、 なぜ一方の解決策を選ぶのかをシニア開発者に遠慮な く尋ねてみてください。 経験豊富な同僚と設計上の決定やトレードオフについて議論してください。 こういった会話が、 経験豊富なエンジニアの考え方を明らかにし、 それはあなたにとって価値のあ ることです。 コードレビューでは、AIが書いたコードに関するコメントを、 特に受け入れようとし てください。もしレビュアーが「この関数はスレッドセーフではありません」や「このアプローチに はスケーリングの問題があります」と指摘したら、時間をかけて、根本的な問題を理解してください。 これらは、まさにAIが見逃す可能性のあるものであり、 あなたはそれを見つけることを学びたいの です。 時とともに、 あなたは、 考慮事項の脳内のチェックリストを作っていきます。

さらに、(リモートであっても) ペアプログラミングの機会を見つけてください。 ワークフローで AIを使っているシニアと 「ペア」を組めれば、彼らがどのようにAIにプロンプトで指示し、 どのよ うに修正するかを観察できるでしょう。 しかしそれ以上に重要なのは、彼らがどのようにコミュニ

96 | 4章 70%を超えて 人の貢献を最大化する

ケーションし、議論を主導し、 微妙なチームの力学に対処しているかを見ることです。 フィードバッ クを受け入れ、積極的に指導を求めることで、あなたは、AIでもできるタスクを行うことから、 人 にしかできない価値の高いタスクを行うことに成熟できます。 あなたはある意味、 経験とともに得ら れる知恵を、できるだけ効率的に身につけようとしているのです。 そうすることで、 あなたは単なる コーダー以上の存在となり、チームが引き留めて昇進させたがるようなエンジニアになるのです。

4.3.7 コミュニケーションと協働

ソフトウェアの構築はチームスポーツです。 (ありがたいことに) AIは会議には出席しません。 そ れでも人は、要件を明確にし、 トレードオフを議論し、 作業を調整するために、他の人と話さなけ ればなりません。 強力なコミュニケーションスキルは、相変わらず価値があります。 (同僚にもAIに も) 良い質問をして、問題を明確に説明することを実践してください。

興味深いことに、AIにプロンプトで指示すること自体が、コミュニケーションの一形態です。 何 を望んでいるかを正確に表現する必要があります。 これは、 エンジニアリングの中心的なスキルで 「ある 「要件分析」 と重なります*5。 明確なプロンプトや仕様を考案できれば、それはあなたが問題を 考え抜いたことを意味しています。

さらに、知識の共有、 ドキュメントの作成、 他の人のコードレビューは、AIが代替できない協働 的なスキルです。 将来、 開発者がAI と 「ともに」 作業するようになっても、 (正しい問題が解決され ていることを確認する) チーム内の人対人の協働は不可欠です。 新たな傾向として、 開発者は(多く の場合、 AIも参加する) より高レベルの設計の議論やタスクの調整に集中し、 本質的に指揮者のよ うな役割を担うようになるかもしれません。 コミュニケーションとリーダーシップのスキルは、 指揮 者の席で大いに役立つでしょう。

4.3.8 考え方を変える 消費から作成へ

AI時代のジュニアにとって、考え方の転換は注目に値します。 「解決策を消費」 するだけでなく、 「理解を生む」 必要があります。 過去には、最終的に機能を書くためにドキュメントと格闘していた かもしれませんが、 今では、 AIが解決策をお膳立てしてくれます。 単にそれを消費する (コピー& ペーストして進む) だけでは、あなたに大した成長はありません。

代わりに、AIから与えられた解決策を、学習ケースとして使ってください。 それを解剖し、 実験 し、自身がどのようにしてそれにたどり着いた可能性あるかを考えてください。 AIの出力を、 すべ ての質問を終わらせる回答としてではなく、 対話型の学習教材として扱うことで、人であるあなたが 常にレベルアップするようにするのです。こうすることで、 AIはあなたの成長を代替するのではな く、むしろ加速させるのです。

多くの専門家は、AIによって、 大規模チームで大量のジュニア「コーダー作業員」の必要性は減る

*5 このトピックの詳細については、 Mark Richards and Neal Ford, 「Fundamentals of Software Architecture」 2nd edition (O' Reilly, 2025) Mark Richards, Neal Ford, and Raju Gandhi, 「Head First Software Architecture」 (O'Reilly, 2024) を参照 (訳 前者の初版の日本語版 「ソフトウェアアーキテクチャの基礎」 (オライリー、2022年) が出ています)。

4.4 まとめと次の一歩 |

かもしれない一方で、 ジュニア開発者に求められる 「水準は引き上げられる」と考えています。その 役割は、AIと効果的に連携し、 バリューチェーンを素早く上がれる人材に移行しつつあります。 本 節で説明する習慣を身につければ、 あなたは、どの企業もサブスクリプションを通して得られる) AIがもたらすものだけでなく、 知見、 信頼性 継続的改善 (将来シニア開発者となるための資質)を もたらすジュニア開発者として、 頭角を現すでしょう。

4.4 まとめと次の一歩

AI拡張開発の世界で成功するためには、 あらゆるレベルのエンジニアが、 AIが (まだ) 複製でき ない持続的なスキルとプラクティスを強化させるべきです。 こういった能力は、 ツールがどれほど進 歩しても、引き続き極めて重要です。 特に、 次の分野に集中してください。

• システム設計とアーキテクチャの専門知識を強化する

●システム思考を実践し、 全体像のコンテキストの理解を維持する

・ 批判的思考、 問題解決、 先見性のスキルを磨く

● 専門ドメインにおける専門知識を築く

●コードレビュー、 テスト、 デバッグ、 品質保証を行う

●コミュニケーションと協働のスキルを向上させる

• 変化に適応する

継続的に学習し、基礎を固めながら、 新しいスキルを身につけ、 知識を更新する AIを使う

こういったスキルは、ソフトウェアエンジニアリングにおける人の利点を形作ります。 フレーム ワークやツールの変更によって失効しないため、こういったスキルは持続的です。 サイモン・ウィリ ソンは、 AIの支援によって、 強力なプログラミングスキルの価値は下がるどころか、むしろ高まる と主張しています (https://oreil.ly/5F307)。

強力なマシンが未熟な人の手に渡れば、危険で無駄なものになりかねませんが、 有能な人の手に 渡れば変革を起こします。 AI時代には、経験豊富なエンジニアは、 新しい高度な副操縦士 (コバイ ロット) を乗せた経験豊富なパイロットのようなものです。 旅はより速く、より遠くへ進めますが、 パイロットは依然として嵐の中を進み、 安全な着陸を保証しなければなりません。

ソフトウェアエンジニアリングは、アセンブリ言語から高レベルプログラミングへ、オンプレミ スサーバーからクラウドへ、 そして現在、 手動コーディングからAI支援開発へ、 常に変化し続けて います。 飛躍のたびにプログラミングのある側面は自動化されてきましたが、 そのたびに開発者は 適応し、さらにやるべきことを見つけてきました。 ティム・オライリーのメモ (https://oreil.ly/ BYrNh) に対して、 ある Hacker Newsユーザーは、過去の技術革新は開発者にとって「ほとんどの 場合、さらなる仕事、さらなる成長、さらなる機会をもたらした」と述べました (https://oreil.ly/ OewGO)。 AIの台頭も同じです。 開発者を無用の存在にするのではなく、成功に必要なスキルセッ

97

98 | 4章 70%を超えて 人の貢献を最大化する

トを再構築しているのです。 コーディングの平凡な70%はより容易になり、 困難な30%が我々の価 値のさらに大きな部分を占めるようになります。

人の30%を最大限に生かすには、時代を超えたエンジニアリングスキルに集中してください。 そ れは、問題を深く理解すること、クリーンな解決策を設計すること、コード品質を精査すること、 ユーザーとコンテキストを考慮することです。 経験豊富なプログラマーは、AIをどのように導き、 AIがつまずいた時にどうすべきかを知っているため、 AIからより多くのものを得ています。 こう いったスキルをAIツールと組み合わせることで、 どちらか一方しか持っていない人たちを凌駕でき るでしょう。 実際、 AIは熟練者のためのツールであり、「LLMはパワーユーザー向けのパワーツー ルである」というのが、 専門家の間で一致した意見 (https://oreil.ly/5gfvc) になっています。 つ まり、 私たち一人ひとりが、 「パワーユーザー」になること、つまり、この新しいツールを効果的に 使いこなすための専門知識を養うことを求められているのです。

結局のところ、ソフトウェアエンジニアリングの技術とは、動作するコードを書くこと以上のもの です。 実世界の環境で、 時とともに、 進化する要求の下で「うまく動作する」 コードを書くことなの です。 今日のAIモデルは、コードを書くことを支援できますが、それらすべての次元でコードがう まく動作するようにすることは、まだできません。 それは開発者の仕事です。

今説明したスキルを強化することで、 シニア開発者は主導と革新を続け、 ミドル開発者は専門知 識を深め、 ジュニア開発者は習得への道のりを加速できます。 AIはより多くの定型作業に対処する ようになるでしょうが、 あなたの創造性、 直感、そして思慮深いエンジニアリングが、 その生の出力 を真に価値あるものに変えるでしょう。 AIは強力なツールですが、私たちがそれをどう使うかがす べてです。優れたエンジニアリングプラクティス、 人の判断力、そして学ぶ意欲は、今後も不可欠 なものです。

実用的な言い方をすれば、 関数を書いてくれる 「熱心なジュニア」 AIとベアプログラミングをして いる時でも、 AIが生成したコードの差分をレビューしている時でも、人ならではのレンズを当てる ことを決して忘れないでください。 これは 「正しい」 問題を解決していますか? 他の人はこれを理解 して保守できますか?リスクやエッジケースは何ですか? これらの質問はあなたの責任です。 プロ グラミングの未来は、すべてのセミコロンを手動入力することを減らし、 指示とキュレーションを増 やすことです。 しかし、 舵を取る立場にあり、それを正しく行う知恵を備えた開発者が、依然として 必要です。

結局のところ、優れたソフトウェアエンジニアリングは、 常に問題解決に取り組んできたのであり、 単にコードを書き連ねるだけではありません。 AIがそれを変えることはありません。 AIは、問題解 決を次のレベルに引き上げるように、私たちに挑戦しているだけなのです。 その挑戦を受け入れる ことで、私たちの業界のこの新章で成功を収めることができるでしょう。

199

5章

生成されたコードを理解する: レビュー、改良、所有

あなたは、コードを生成させるためにプロンプトでAIに指示する方法を学びました。 これまで、 これらのテクニックを使っていくつかのコードを作成したことでしょう。 ここで、 重要な段階に来ま した。 そのコードが正しく、 安全で、 保守可能であることを確認するのです。

開発者としては、 単にAIの出力を受け取って、 軽率にリリースすることはできません。 それをレ ビューし、テストし、 場合によっては改善し、 コードベースの他の部分と統合する必要があります。 本章では、AIが出力したものを理解し、繰り返し編集とデバッグを行い、プロジェクトの一部とし てコードを完全に所有する方法に焦点を当てます。

本章では、次のことを取り上げます。

●あなたの当初の意図の観点から、 AIコードを解釈する

・ 「多数決の解決策」 現象、 つまり、 多くの場合、 AIが生成したコードが一般的な解決策のように 見える理由

• 明確さと潜在的な問題に関して、コードをレビューするテクニック

AIが書いたコードが期待通りに動かない場合の、コードのデバッグ

●スタイルや効率のために、コードをリファクタリングする

•コードの振る舞いを検証するために、テストを書く

こういったスキルを習得することで、 自信を持ってAIの貢献をあなたのプロジェクトに統合でき ます。

5.1 意図から実装へ AIの解釈を理解する

AIコードを入手したら、 最初の手順として、コードをあなたの意図 (あなたが与えたプロンプト) と比較すべきです。 そのコードは、 あなたが設定した要件を満たしていますか? AIは、 時には、あ なたが頼んだことを少し誤解したり、 部分的にしか実装しなかったりします。

注意深く、 コードを全部読んでください。 あなたの頭の中で、 あるいは紙の上で、 そのコードをス テップ実行してください。

100 | 5章 生成されたコードを理解する レビュー、 改良、 所有

典型的な入力に対して、 何が行われるかを追跡する。

・プロンプトに複数の部分 (「XとYを実行して」) があった場合、 AIがそれらすべてを実行したか どうかを検証する。

・AIが、 あなたが求めていない機能を追加していないことを確認する。 AIは、 時には、 ロギング やパラメーターの追加など、 AIが便利だと 「思う」 余分な機能を追加することがある。 それは間 題ないこともあるし、問題あることもある。

同僚のコードの場合と同じように、 不明な点があれば、それをメモしてください。 それがそこにあ る正当な理由を探せば、見つかることがあります。 理由が見つからない場合、 質問するか、または、 除去を検討してください。

例えば、あなたが素数チェッカーを求めた時に、AIコードが各数に対して「7をチェック中･･･」の ような表示もする場合、 それは、 あなたのプロンプトでの指示の成果物のこともありますし、 AIの トレーニングデータからのパターンのこともあります (進捗を表示する、チュートリアルのコードも あります)。 もしそれが不要なら、それを除去することを計画するか、 それを除去するようにAIにプ ロンプトで指示してください。

また、期待通りにエッジケースに対処していることを確認してください。 空の入力に対処すること を意図していた場合、 そうなっていますか? 入力がNone や負の数の可能性がある場合、 AIはそれ を考慮しましたか?

プロンプトに曖昧な点があり、 AIが解釈を選ばなければならなかった場合、 どこでそれが起こっ たかを特定してください。 おそらく、 あなたが出力形式を指定しなかったので、 AIが結果を返す代 わりに、それを画面出力することを選んだのでしょう。 あなたは、 それを受け入れるか、コードを修 正したいかを決めなければなりません。

この理解する段階は非常に重要です。 この段階を省略しないでください。 たとえコードをテスト するつもりだとしても、読んで理解することは重要です。 なぜなら、 テストがすべてをカバーしてい るとは限らないからです(そして、 簡単に気付くことについては、 読む方が速いからです)。

最後に、AIの想定を考えてみましょう。AIは多くの場合「多数派」、つまり最も一般的な解釈を選 びます(これは、次節につながります)。

5.2

「多数派」 の問題:

「最も一般的」 は 「最も適切」 を意味しない

大量のコードでトレーニングされたAIモデルは、多くの場合、 そのトレーニングデータで最も代 表的な解決策 (あるいは、 適合する最も単純な解決策) を作成します。 私は、これを 「多数派の解決 「策」 効果と呼んでいます。 それは一般的には正しいですが、 あなたの特定の状況には最適ではないこ とがあります。

例えば、あなたが、さらなるコンテキストなしに探索アルゴリズムを求めた場合、 AIは、基本的

5.3 コードの可読性と構造: パターンと潜在的な問題点 | 101

な線形探索がわかりやすく一般的なため、それを出力することがあります。 もしかしたら、あなた は実際には二分探索を必要としていたのかもしれません。 しかし、あなたがそう言わなかったため、 AIは、 効率が重要であることを知りませんでした。 線形探索は中程度の場合には十分ですが、パ フォーマンスが重要な場合には適していません。

同様に、 AIは、多くの単純な例でグローバル変数を使っているので、 そうすることがあります。 しかし、おそらくあなたのプロジェクトでは、 それは受け入れがたいかもしれません。 AIの解決策は、一般的なシナリオに最適化されることがあることに留意してください。 人の開発 者であるあなたには、AIに欠けているコンテキストに対する知見があります。 これに対処するには、次のことを行ってください。

●コード内の想定を特定する。 AIが、 リストがソートされている、あるいは、入力が有効である と想定している場合、 その想定は問題ないか? あなたは、それを指定したか? そうでない場合、 AIはチェックを含めるべきだったかもしれない。

・ 代替案を検討する。 あなたが (異なるアルゴリズムなど) 問題を解決する複数の方法を知ってい る場合、 AIはそのうちの1つを選んだか? それはあなたが望むものか? そうでない場合、 プロ ンプトで代替案を指示するか、あるいは、単にコードを変更できる。

AIコードが 「通常の」 場合には動作しますが、 あなたにとって重要な境界条件で動作しない場合、 それを修正すべきです。 例えば、 AIが、 ある計算で整数のオーバーフローを考慮していないことが ありました。 トレーニングデータの多くの例では、それが考慮されていないことがありましたが、あ なたのコンテキストではそれは重要かもしれません。

AIに一般的な解決策に向かう傾向があることを理解することで、 あなたはAIコードをうまくレ ビューできるようになります。 AIは魔法でもなければ、オーダーメイドでもありません。それは、 解決策に対する非常に根拠のある推測です。 オーダーメイドするのは、あなたの仕事です。

5.3 コードの可読性と構造 パターンと潜在的な問題点

AIが生成したコードには、多くの場合、いくつかの明確なパターンがあります。 AIが生成した コードは、次のようなもののことがあります。

•(AIはチュートリアルのコードから学習しており、チュートリアルのコードはコメントが多い傾 向があるため) 普通より多くのコメントや、 奇妙な言い回しのコメントがある

(ループのijkのように) 一貫して特定の変数名を使う

(一般的な場合に対応するため) やや冗長なスタイルでコードをレイアウトする

これらを確認し、 あなたのプロジェクトのスタイルと合っているかどうかを検討してください。 コードは機能的には問題ありませんが、可読性のための見直しが必要なことがあります。 その見直 しでは、あなたは次のことを行うことがあります。

102 5章 生成されたコードを理解する レビュー、 改良、 所有

●より説明的にする、あるいは、 あなたのコードベースと一貫性を持たせるために、変数名を変 更する。

コメントを削除、または改良する。 AIが、一目瞭然のif文の上に 「#数が素数かどうかをチェッ ク」のようなコメントを追加した場合、 それを削除する。 しかし、複雑なロジックを説明するコ メントがある場合は、良いことなので、それを保持して改善する。

あなたが希望するスペースやかっこのスタイルに合うように、 コードを (Python向けのBlack、 Go向けのgofmt といった)リンターやフォーマッターに通すことで、一貫した書式設定を確保 する。

また、変わった構造になっているものを探してください。 あなたが1つのクラスや関数を期待し ている時に、 AIが複数のクラスや関数を定義しませんでしたか? トレーニングデータの例が問題を 複数の関数に分割していたために、 時には、 AIがそうすることもあります。 それがやり過ぎの場合、 あなたは、複数のクラスや関数のインライン化 (あるいは、 その逆) を行えます。 コードが賢すぎた り、素朴すぎたりしますか? 時には、AIが非常にわかりやすい解決策を作成することもありますし、 手が込んだ1行コードを作成することもあります。 それはあなたのチームの好みに合っていますか? そうでない場合、 適宜調整してください。

気を付けるべき他の潜在的な問題は、次の通りです。

オフバイワンエラー

はい、AIもそのエラーをすることがあります。 例えば、

未処理の例外

ループの境界は厄介です。

そのコードは、ファイルが正常に開くことや、すべての入力が正しい形式であることを想定して いますか? 必要なら、エラー処理を追加してください。

パフォーマンスの落とし穴

もしかしたらAIは、大規模データセットのメンバーシップチェックのために、 集合 (セット) を 使うなどの、 より良いアプローチがあるにもかかわらず、 インナーループを使っていることがあ ります。AIの解決策は、正しいが、最適ではないことがあります。

ライブラリの使用

コードがライブラリを使っている場合、 それがあなたが使いたい (そして利用可能な) ライブラ リであることを確認してください。 時には、AIが (トレーニングデータの例でそれを見たため に) 単純な合計に numpyを使うことがあります。 その依存関係を持ち込む価値がなければ、純粋 な Python か あなたが意図したライブラリに切り替えられます。

非一貫性

時には、関数のdocstringにはあることが書かれているが、 コードは別のことが行っている(例

5.4 デバッグ戦略エラーの発見と修正 |

えば、ロジックが修正されたが、 コメントが修正されていない場合) といった、ちょっとした非 一貫性が、 AI コードにあることがあります。 それらを修正してください。

構文のちょっとした問題

これは、十分にテストされたモデルではまれですが、混乱を招きやすい言語では起こり得ます。

時代遅れのAPI の使用

例えば、 AIは、機能が変更されたライブラリの旧バージョンを使っていることがあります。 見 覚えのない関数呼び出しがあったら、すぐにライブラリのドキュメントを確認して、あなたが 使っているバージョンでそれが正しいことを確認してください。

プレースホルダー

AIの出力に 「ここにコードを記述」 といったプレースホルダーが使われていたら (まれですが、 汎用テンプレートではあり得ます)、 それを埋めてください。

要するに、AIコードを、インターンが書いて残していったものとして扱ってください。あなたは、 コードの品質をレビューして、コードを適切に統合する必要があります。

5.4 デバッグ戦略 エラーの発見と修正

あなたがコードを実行して (あるいは、 そのコード向けのテストを作成して)、 何かがうまく行か なかったとしましょう。 AIが生成したコードのデバッグは、 (あなたがそのコードを書いていないの で、あまり馴染みがないことを除いては) あなた自身や他の誰かのコードのデバッグと変わりません。 しかし、あなたはすでにそのコードを注意深く読んでいるので、問題はありません (図5-1を参照)。

AIコードを実行 エラーが発生 エラーとコードを AIが修正案を提案 Aに渡す 適用してテスト ループ(エラーがまだ残っている場合)

AIコードのデバッグサイクル。 AIが生成したコードを実行し、エラーを記録し、解析のためにAIにエラーコン テキストを返し、 修正案を実装し、解決するまで繰り返す。

図5-1

103

1045章 生成されたコードを理解する レビュー、 改良

、所有

デバッグのための6段階のアプローチを紹介します。

1. 問題を再現する

失敗した入力で、 関数やコードを実行します。 出力やエラーを確認します。

2. 問題の原因を突き止める

print文のような典型的なデバッグテクニックを使うか、 デバッガーを使ってステップスルーし ます。 ロジックエラー (間違った出力) の場合、 ロジックを手動で、 またはprint文を使って追 跡して、どこであなたの期待と乖離しているかを確認します。

3. プロンプトをコードと照合する

時には、単にコードが要件を完全に実装していなかったというバグがあります。 あなたが何か をソートするように頼んだのに、コードが正しくソートしない、といったものです。 これは、AI のロジックに欠陥があるか、 (空のリストなどの) エッジケースに対処していないことを意味す ることがあります。

デバッグにAIを活用する

4. !

実際に問題のあるコードをAIに戻して、「このコードはXに対して間違った結果を出している。 バグを見つけるのを助けてもらえますか?」 と言うことができます。 多くの場合、 AIは(コー ドレビューのように) コードを解析し、問題点を指摘してくれます。 例えば、 AIが、 ループが len (arr)まで回るべきなのに、 len (arr) -1までしか回っていないことに気付くことがありま す。 AIが、素早くそれを見つけることがあります (完全に信頼しないように、注意が必要です。 これは、デバッグを手伝ってくれるように、同僚に頼むようなものです)。 5. コードを修正する

あなたには選択肢があります。 手動で修正するか、または、AIにプロンプトで修正バージョン を指示するかです。 修正点が明らかな場合、そのまま修正します。 そうでない場合、 「上記の関 数は、入力Xで失敗しました (期待値: Y, 実際 Z)。 これを修正して」といったプロンプトを 試せます。 AIは、それに応じてコードを調整することがあります。

6. 再度、 テストする

バグが解決され、新たな問題が持ち込まれていないことを確認します。

私は、テスト駆動デバッグを推奨します。 可能なら、重要な関数のテストをいくつか書いてくださ い (詳しくは、 本章のテストの節で説明します)。 テストに失敗したら、 何が間違っているのかが直 接表示されます。 これは、最も単純な関数以外では、手動で確認するよりも速いことがあります。

最後に、デバッグをする時は、 「何」だけではなく「なぜ」と問うようにしてください。 なぜAIが 間違いを犯したのかを、理解するようにしてください。 その点について、 プロンプトが不明確でし たか? これによって、次回、 どのようにプロンプトで指示するか、あるいは、AIの出力でその点を 常に再確認する必要があるかを知ることができます。 例えば、 多くの場合、AIが指示されない限り、 空の入力に対処しないことに気付いたら、プロンプトで常にその点を明記し、それをレビューするよ

5.5 保守性のためのリファクタリング:AIコードをあなたのコードにする | 105

うにします。

5.5 保守性のためのリファクタリング: AIコードをあなたのコードにする

コードが機能の面で正しくなったら、プロジェクトの基準に合わせて、 将来、 作業しやすくするた めに、リファクタリングを検討してください。 AIの仕事は、 あなたに素早くコードを提供すること でした。 あなたの仕事は、それを洗練させることです。

今回はリファクタリング向けの、もう1つの6段階のプロセスです。

1. スタイルのガイドラインに合わせる

コードをフォーマッターやリンターに通します。 「変数名を小文字にすべき」 や 「行が長すぎる」 といった警告を修正します。 これによって、 コードがすぐに、 あなたの他のコードベースと同様 になります。 多くのAIツールは、スタイルに関して適切な仕事をしてくれますが、 若干の調整 が必要なことがあります。

2. 名前付けと構造を改善する

AIがクラス内の関数を _helper1、 _helper2という名前にし、 あなたが意味のある名前を好む 場合、名前を変更します。 AIが一度しか使われない小さな関数を多数作成した場合、それらの 関数によってより明確になる場合を除いて、 関数をインライン化します。 3. 不要な部分を除去する

例えば、AIが、あなたが求めていないメインブロックやテストコードを、出力に含めているこ とがあったとします。 それが不要なら、除去します。 逆に、AIがすべてを1つの関数にまとめ ましたが、 あなたは、わかりやすくするためにその関数を小さく分割したいことがあります。 そ の場合、 分割します。

4. ドキュメントを追加する

このコードを、 他の人が使うライブラリやモジュールの一部にするつもりなら、 適切な場所に docstringやコメントを追加します。 AIが多少コメントしていることがありますが、それがあ なたの基準に合っていることを確認します。 例えば、 あなたのプロジェクトでは、パラメーター と戻り値が文書化された、 特定のdocstring形式が必要なことがあります。 5. 必要に応じて最適化する

さて、コードは動きましたが、 それは十分に効率的でしょうか? このコードが高頻度なループ や大規模データで呼び出される可能性がある場合、 その複雑さを確認します。 AIは、最適化さ れたアプローチを使っていないことがあります (繰り返しますが、 「多数派の解決策」 は、 より最 適化されたアプローチではなく、単純なループのことがあります)。 パフォーマンスが気になる なら、より良いアルゴリズムにリファクタリングします。 次のように、 再度AIを巻き込むこと もできます。

1065章 生成されたコードを理解する レビュー 改良、 所有

ルックアップにリストの代わりにセットを使うことで、より高速に実行できるようにこのコード を最適化する。

しかし、 開発者であるあなたは、 多くの場合、 自分が望むパターンを知っているので、単にそ の変更を実装するだけでしょう。

6. 必要なら単純化する

AIコードが冗長すぎることがあります。 例えば、 条件付きの1つのreturn で十分なところを、 if-else と複数のreturnを使うことがあります。 明示的なコードが必ずしも悪いわけではあり ませんが、明確さを失わずに可読性を向上させるため、 行数を減らして簡素化する方がいいこ ともあります。

リファクタリングの目標は、後で別の開発者がこのコードを読んだ時に、 「AIがこれを書いた」と 一目でわからないようにすることです。 良いコードに見えるようにすべきです。 多くの場合、それは コードをクリーンにするために、人が小さく手を加えることを意味します。

リファクタリングする時は、 何も壊していないことを確認する必要があります。 それでは、テスト の話に移りましょう。

5.6 テストの重要性:

単体テスト、 統合テスト、エンドツーエンドテスト

テストは常に重要ですが、 2つの理由でAIが生成したコードでは特に重要です。 第一に、 あなた がゼロからコードを書いていないので、そのコードがどのような場合でも動作することを保証した いのです。 第二に、 あなたが後でAIに変更を求めたり、 より多くのAIコードを統合したりする場合、 テストは、 新しい変更が既存の機能を壊さないことを保証するのに役立ちます。 さまざまな種類の テストについて、 簡単に見てみましょう。

単体テスト

特にエッジケースに対応して、AIが生成した関数やモジュールごとにテストを書いてください。 素数の例では、素数、非素数、 1 (エッジケース)、0、負の数 (おそらく、 期待される振る舞い を定義)、 大きな素数などをテストします。 コードがこれらすべてのテストを通過すれば、 コー ドが正しい可能性が高いでしょう。

AIに、こういったテストを生成させることができます。

上記の関数に対して、 エッジケースをカバーする PyTest単体テストを書いて。

多くの場合、 AIは適切な仕事をしてくれます。 それでも、 テストが有効で、 あなたが必要だと 思うものに対応していることを確認するため、テストをレビューしてください。

5.7 まとめと次の一歩 |

統合テスト

AIコードが、 データベースを使う関数のように、コードベースの他の部分と対話する場合、 そ のコンテキストで他の部分を呼び出すテストを書いてください。 そのコードは、データベースに 格納すべきものを実際に格納していますか? そのコードが、 他の関数によって利用される出力 を作成する場合、テストの中でそれらを連鎖させてください。

エンドツーエンドテスト

このコードがより大きなワークフローの一部の場合、最初から最後までシナリオを実行してくだ さい。 例えば、 AIコードがウェブルートの一部だった場合、 テスト環境でそのルートへのテス トリクエストを行い、 形式、 エラー処理、 その他すべてが問題なく動作するかを確認してくださ い。

必要なテストのレベルは、コードの重要度や複雑さによって異なります。 しかし、 手動で素早くテ ストを実行したり、 スクリプトで単純なassert文を実行したりするだけでも、 検証をしないよりは ましです。 テストはバグを見つけるだけではなく、振る舞いを固定化するということを、 覚えておい てください。 後であなたが (あるいは、AIが) 何かを変更した場合、 テストはコードの機能が後退し ていないことを保証するのに役立ちます。

また、テストは所有権を主張する良い方法でもあります。 あなたがテストして問題を修正すれば、 そのコードに自信を持てます。 この時点で、 コードベースの他のコードと同じように、そのコードは 「あなたのもの」だと言ってもいいでしょう。 あなたはそれを理解し、 信頼し、それを守るためのテ ストを持っています。

AI とテストに関するメモ

テストの提案を統合し始めているAIコーディングツールがあります。 例えば、 Amazon CodeWhisperer'は、コードの後にアサートの提案をすることがあります。 こういった提案を出 発点として使いますが、 100% 包括的だとは思わないでください。 創造的なエッジケースを考えて ください。これは、人の直感がまだ非常に貴重である場所の1つです。

5.7 まとめと次の一歩

コードの生成、理解、 デバッグ、そしてリファクタリングを見てきました。 このループは、 短時間 (小さな関数の場合、数分以内) で起こることもありますし、 長時間 (複雑なモジュールの場合、 断 続的なAIの支援を受けながら、 数時間から数日) かかることもあります。

重要なのは、 「最終的なコードの責任は、 開発者であるあなたにある」ことを認識することです。 AIは作成を加速させるツールですが、何か失敗してもAIは責任を取ってくれません。 ライセンスや 著作権のリスクもあります。 一定以上の長さの出力にはコピーされたものが含まれている可能性が 統計的にあると言っている、 AIのプロバイダー (https://oreil.ly/kYyO_) もいます。 これはまれ

*1 注: Amazon CodeWhispererは、Amazon Q Developerに統合されています。

107

108 | 5章 生成されたコードを理解する レビュー 改良、 所有

なことであり、プロバイダーはこの問題をかなり緩和しています。 しかし、 特に出力が大きい場合や クリーンすぎる場合は、 Stack Overflowの回答を精査して明らかにライセンスされたテキストや帰 属表示がないか確認するのと同じように、簡単な確認を行ってください。 例えば、あなたが「クイッ クソートを実装して」 とプロンプトで指示し、 AIが20行の原始的なコードを返したとします。 それ はおそらく、問題ない共通の知識です。 しかし、 あなたが曖昧なものを求め、 大きな一連のコード が返された場合は、その中の固有の文字列をインターネットで検索し、 それがどこかからそのまま 持ち込まれたものかどうか、 調べてください。 AIシステムが雑誌の記事や他の著作権保護された ソースからテキストを複製した事例が文書化された (https://oreil.ly/h_BzA) ことで、 最近、 こ の問題はより明白になってきています。 責任あるコード所有権の一環として、 開発者は、一般的な パターンを超えたり、特定のソースに異常に特化していたりするように見える、 AIが生成したコン テンツの出所を確認すべきです。

最後に、コードをプロジェクトに統合します。 おそらく、コミットメッセージにAIが手助けした ことを明記して、コードをバージョン管理システムに追加してください。 コミットメッセージに明記 する必要はありませんが、これを追跡したがるチームもあります。

時とともに、要件が変わるにつれて、 AIが生成したコードを修正することになるでしょう。 その コードを、他のコードと同じように扱ってください。 「ああ、これはAIコードだから、AIに変更する 「ように頼もう」と考えないでください。 そうしたいならできますが、手動で自由に修正することもで きます。 最も効率的で保守しやすいようにしてください。

AIが生成したコードは、入念なコードレビューとテストを経て、 あなたのプロジェクトにおける 単なるコードになります。 その時点で、 10行目を書いたのがAIかあなたかは、無意味になります。 重要なのは、そのコードがプロジェクトのニーズと基準を満たしているかどうかです。

こういったプラクティスに従うことで、品質を確保しながらAIコーディングの速度を活用できま す。AIの出力を疑わずに信頼するという落とし穴を避け、代わりに、 AIの出力をプロの開発ワーク フローに統合するのです。

次の「6章 AI駆動プロトタイピングツールとテクニック」 では、 AIツールがソフトウェア開発 のプロトタイピング段階をどのように根本的に変革できるかを見ていきます。 AIアシスタントを活 用することで、 初期概念から動作するプロトタイプまでの道のりを加速させて、多くの場合、 開発時 間を数日から数時間に短縮する実践的なテクニックを探ります。 Vercel v0 や screenshot-to-code ユーティリティを含む具体的なAI駆動プロトタイピングツールや、AIの指導の下での反復的な改良 の戦略について議論します。

また、AIが生成したプロトタイプから本番環境対応のコードへの重要な移行プロセスについても 言及し、AIが開発ワークフローの中心になった場合に生じる機会と潜在的な課題の両方を検討しま す。 実世界での事例研究を通して、 開発者がAIをうまく利用してアイデアを素早くテストしながら、 コード品質を維持し、 概念から実装への移行が早すぎる場合に生じうる一般的な落とし穴を回避し ている方法を示します。

| 109

6章

AI駆動プロトタイピング: ツールとテクニック

本章では、 AI駆動のバイブコーディングが、 ソフトウェア開発のプロトタイピングの段階をどの ように加速させるかを探ります。 プロトタイピングとは、アイデアを動作するモデルに素早く変える ことです。 AIアシスタントを使えば、 開発者は通常は数日かかることを数時間で実現し、 素早くコ ンセプトを改善できます。 AIを使ってコンセプトからプロトタイプに移行するテクニックについて 説明し、 (Vercel v0. screenshot-to-code ユーティリティを含む) 人気のあるAIプロトタイピング ツールを比較し、AIの指導の下でプロトタイプを反復的に改良する方法を検討します。 また、AIが 生成した大まかなプロトタイプを本番品質のコードに移行するという、 重要な手順も取り上げます。 本章を通して、 AI駆動のプロトタイピングが成功につながった事例研究も取り上げ、 このアプロー チの可能性と落とし穴の両方を示します。

6.1 AIアシスタントによる素早いプロトタイピング

プロトタイピングは、AIが生成するコードの速度から大きな利点を得ます。 プロトタイピングの 目標は、洗練された本番対応のコードではなく、 評価と改良が可能な 「概念実証」 (PoC) です。 AI コーディングアシスタントは、最小限の入力から動作するコードを素早く生成することで、 真価を発 揮します。 例えば、 開発者は、 UIモックアップを手動でコーディングする代わりに、 自然言語で希 望するインターフェイスを説明し、 AIにHTML/CSS や React コンポーネントを生成させることが できます。 これによって、 アイデアから実装までのサイクルが非常に速くなります。

あるUXエンジニア (https://oreil.ly/dP5U3) は、 生成AIツールを使うことでワークフローが 完全に変わったと語っています。 「生成AIを使って機能するプロトタイプを生成する速度には、驚か されました。 通常は数日かかるプロトタイプを、数時間で構築しました」。 AIは定型ボイラープレー トと繰り返しパターンに自動的に対処するため、 彼はより高度なデザインの決定に集中できます。 プ ロトタイピングにおいて、 これは、同じ時間でより多くのアイデアを試せることを意味します。もう 1つの利点は、AIが、プロトタイプの面倒な部分 (基本UIコンポーネント、フォーム処理、 サンプ ルデータ)をほぼ瞬時に補完してくれるため、人の開発者はテスト対象の中心概念や固有の機能に集 中できることです。

110 | 6章 AI駆動プロトタイピングツールとテクニック

しかし、多くの場合、プロトタイプのコードは使い捨てコードであることを忘れてはなりません。 AIは解決策を素早く生成することがありますが、 そのコードは保守性やスケールのために構造化さ れていないことがあります。 優雅さよりも速度と実験が重要なプロトタイプでは、 本番用に重要な部 分をリファクタリングしたり書き直したりする計画があれば、 これは許容できます (このプロセスに ついては、 本章の後半で説明します)。 「3章 70% 問題: 実際に動作するAI支援ワークフロー」、 「4 章 70%を超えて: 人の貢献を最大化する」 で説明したように、 AIはプロトタイプのコーディング の約70%を自信を持って処理できます。 一方、 あなたは全体的なアーキテクチャを導き、重大な欠 陥を修正できます。

「1章 序論 : バイブコーディングとは何か?」 で紹介した概念である 「意図を持ったプログラミ ング」が、ここでは不可欠です。 あなたは高レベルな指示 (プロトタイプに何をさせたいか、 それを どのように見せたいかという意図) を与え、 AIに実装を補完させます。 説明のために、AIアシスタ ントを使った非常に単純なプロトタイピングの例を、順を追って確認してみましょう。 あなたに、新 サービスの登録ページのアイデアがあるとします。 フロントエンドを素早くプロトタイピングしたい ので、次のような開発者プロンプトから始めます。

名前、電子メール、 パスワードのフィールドと送信ボタンを備えた登録フォーム用の単純な HTMLページを作って。 基本的なスタイル付けで、 外観を良くして。

Cline のような最新のコードアシスタントは、完全なHTML/CSSの例を提供することがあります。

<!DOCTYPE html>

<html lang="en"> <head> <meta charset="UTF-8" /> <meta name="viewport" content="width=device-width, initial-scale=1.0"/> <title>Sign Up</title> <style> body { font-family: Arial, sans-serif; max-width: 400px; margin: 2em auto; } form { display: flex; flex-direction: column; } label { margin-top: 1em; } input, button { padding: 0.5em; font-size: 1em; } button { margin-top: 1em; background: #4CAF50; color: #fff; border: none; } </style> </head> <body> <h2>Sign Up</h2> <form> <label> Name: <input type="text" name="name" required> </label> <label> Email: <input type="email" name="email" required> </label> <label>Password: <input type="password" name="password" required> </label> <button type="submit">Create Account</button> </form>

6.2 AI プロトタイピングツール |

</body> </html>

AIが生成したこのコードは、 登録フォームのプロトタイプとしては適切な出発点です。 このコー ドには、 基本レイアウトと、 スタイル付けのためのインラインCSSが含まれています。 開発者とし て、 あなたはHTML/CSSを手動で書く必要はありません。 あなたは単に成果を説明し、 AIは実装 を提供します。 これは、意図によるプログラミングを示しています。 あなたはUIが「何」 をすべきか に集中し、 AIはその「方法」を見つけます。

もちろん、これは些細な例です。 実際には、プロトタイプはより複雑であり、 複数のファイルやフ レームワーク、データを含むことがあります。 しかし、原則は同じです。 あなたは、AIを使って最 初の下書きを素早く作成します。 そして、 ブラウザーでこのプロトタイプを開き、それがどのように 見えるかを確認し、それをさらに改良することがあります。 それが、平易な言葉のプロンプトを超え る 専門AIプロトタイピングツールの使用という、 次のトピックにつながります。

6.2 AI プロトタイピングツール

Gemini、 ChatGPT、 Claudeのような汎用アシスタントはプロンプトからプロトタイプコードを 生成できますが、 専門AI支援プロトタイピングツールの状況は急速に進化し続けています。 この原 稿を書いている時点で、 利用可能なツールは、AIが生成するプロトタイプにおける忠実度と制御と の間の基本的なトレードオフに対して、さまざまなアプローチを提供しています。

プロトタイピングの明確なニーズに応えるために、エコシステムが成熟してきました。 ビジュアル デザインをコードに変換することに優れたツールもあります。 こういったツールでは、デザイナーが スクリーンショットやスケッチをアップロードすると、 動作するHTML CSS、 またはReact コン ポーネントを数秒で受け取れます。 この 「screenshot-to-code」 機能は、デザインからコードへの プロセスを劇的に加速させます。 これは、手描きのスケッチやFigmaデザインを素早く実装したい 場合、 特に価値があります。 Vercel v0のようなツールはこのアプローチの典型例であり、コード構 造の制御を犠牲にしながら、 元のデザインへの高い忠実度を提供します。

他のプラットフォームは、 会話型インターフェイスを通して完全なアプリケーションを生成するこ とに、重点を置いています。 こういったプラットフォームでは、ユーザーが自然言語で機能を説明 し、フルスタック実装を受け取れます。 例えば、コーディングなしで素早くアプリを作りたいデザイ ナーは、 Lovable, Bolt.new といったツールを使うことがあります。 AIが面倒なコンポーネントや パターンに自動的に対処することで、 従来は数日かかった機能するプロトタイプを数時間で構築した と報告するデザイナーもいます。

第3のカテゴリーは、AIを開発環境に直接統合し、プロトタイピング段階で知的なペアプログラ マーとして機能させるものです。 Cursor, Windsurf、 ClineといったAI拡張IDEでは、開発者 がコード生成プロセスをより制御でき、AIによる加速の利点も享受できます。 多くの場合、違いは

111

112 | 6章 AI駆動プロトタイピングツールとテクニック

ワークフローの哲学にあります。 素早い実験のために、 変更の自動適用を優先するものもありますし、 より慎重な反復のために、変更を明示的に受け入れる必要があるものもあります。

こういったアプローチに共通しているのは、コンセプトから動作するプロトタイプまでの道のりを 圧縮する能力です。 しかし、 異なるユーザーやユースケースに対する有用性を左右する2つの重要な 側面で、 大きく異なっています。

「忠実度 (fidelity)」 とは、生成された出力が、 あなたの入力や意図にどれだけ合っているかを指 します。 「screenshot-to-code」 ツールは通常、 ビジュアルデザインに高い忠実度を提供しますが、 あなたのアーキテクチャの好みに合わないコードを生成することがあります。 会話型ツールは、あな たの要件をより緩やかに解釈し、 改良が必要な機能的ながら一般的な実装を生成することがありま す。

制御には、生成プロセスを導いたり修正したりする能力が含まれます。 完全な出力を生成するプ ラックボックスとして動作するツールもあれば、継続的な対話や直接のコード編集を通して反復的 な改良を可能にするツールもあります。 特定のアーキテクチャパターンやパフォーマンス最適化、既 存のコードベースとの統合が必要な場合、 この側面が重要になります。

こういったトレードオフを理解することは、プロトタイピングのニーズに適したツールを選ぶのに 役立ちます。 新しい対話パターンを検証するデザイナーは、忠実度と速度を優先し、 実装の詳細を あまり制御できないことを受け入れることがあります。 技術的な実現可能性を探っている開発者は、 生成プロセスで手動介入が増えるとしても、制御と透明性を重視することがあります。

こういったツールはどれも、人の監視なしに本番品質のコードを生成するものではありません。 こ ういったツールは通常、 私が 「80%のプロトタイプ」と呼ぶものを提供します。 これはコンセプト をテストし、利害関係者にデモを行うには十分機能的ですが、 本番デプロイには追加作業が必要で す。 残りの20%には、 多くの場合、セキュリティ強化、 パフォーマンス最適化、 エラー処理、アー キテクチャの改良が含まれます。

ラピッドプロトタイピング中でも、素早いコードレビューは不可欠です。 プロトタイピングの細部 まで洗練させることはありませんが、公開されたAPIキーや安全でないデータ処理といった明らか な問題を精査することで、問題が後の開発段階に伝播するのを防げます。 最新のほとんどのツール は、生成されたコードの透明性を提供し、 あなたが生成されたものを検査して理解できるようにしま す。

AIプロトタイピングの状況が進化し続けるにつれて、具体的なツールは間違いなく変化するで しょうが、忠実度と制御、人の監視の必要性といった基本的な考慮事項は変わらないでしょう。 重 要なのは、プロトタイピングの目標を理解し、素早いビジュアル実装、 機能的なデモ、技術的探索 といった特定のニーズに合ったアプローチを選択することです。

6.3 コンセプトからプロトタイプへ 反復的な改良

AI駆動プロトタイピングの強みの1つは、「反復ループ」 です。 あなたは初期バージョンを生成し、

6.3 コンセプトからプロトタイプへ 反復的な改良 | 113

AIとの対話によってそれを改良できます。 あなたはコードを手動編集する代わりに、 何を変更した いかをAIに伝えるだけです (図6-1 を参照)。 私は、 純粋な 「経験と勘による」 バイブコーディングよ りも責任あるアプローチを提唱していますが、 早いフィードバックサイクルは間違いなくプロトタイ プに取り入れるべきものです。

Xを変更 初期プロンプト Yを追加 適用およびテスト [AIプロトタイプ v3 HHO [ AI プロトタイプ v1 AIプロトタイプ V2

図6-1 反復的なプロトタイプ改良プロセス。 初期プロンプトがベースラインのプロトタイプを生成し、 開発者からの フィードバックによって改良が重ねられ、AIとの協働によってますます改良された解決策が生成される。

ほとんどのAIプロトタイピングツールは、要求のコンテキストの履歴を保持しており、これは非 常に便利です。 つまり、AIがあなたのアプリの 「目的」 や以前の指示を覚えているので、 毎回すべて を説明し直す必要がないのです。 この「コンテキストの永続性」は、 バイブコーディング環境の特徴 です。 AIとの会話が開発ログになるのです。

典型的な反復的な改良は、次のように進みます。

手順1: 初期生成

あなたは、プロトタイプを作成するために、 プロンプトや入力を提供します。

経費を追加するフォームと、 それらの経費をリストするテーブルを備えた、基本的な経費追跡ア プリを生成して。

手順2:コードをレビューして実行する

あなたは、生成されたコードを取得し、 それを実行します。 うまく行くかもしれませんが、あな たは改善点に気付きます。 例えば、 「UIは機能的だが地味である」 や 「テーブルが経費をソート しない」などです。

114 | 6章 AI駆動プロトタイピングツールとテクニック

手順3:プロンプトを改良する

あなたはAIに戻り、 追加の指示を出します。 例えば、次のようなものです。

経費リストを金額や日付でソートできるようにして。

AIは、ソートロジックを含むようにコードを修正したり、 ソート可能なテーブルのライブラリを 使ったりするでしょう。

おそらく、モダンなCSSフレームワークを使って、色のスタイル付けを追加して。

AIは、外観を良くするために、 (Tailwind Bootstrap といった) CSSライブラリを統合した り、単にカスタムスタイルを追加したりするでしょう。

名前と金額の入力がなければ支出を追加できないよう

エンド検証を追加するでしょう。 こういったプロンプトはそれぞれ、プロトタイプを修正します。 AIはコンテキストを理解して いるため (Cursorのようなツールやチャットツールはコードのステートを保持する)、 多くの場 合、 適切な場所に変更を適用できます。 例えば、 フォームに検証コードを挿入したり、 ソート可 能な列を含むようにテーブルのレンダリングを書き直したりします。

AIは、単純なフロント

手順4:繰り返す

に、フォームを検証して。

それぞれの改良の後、結果を確認します。 AIが新たな問題を持ち込んだり、 あなたが意図した ことを正確に行わなかったりした場合、 プロンプトを通して明確化や修正を行います。 • ソートが逆方向です。 デフォルトでは昇順でソートするようにして。

●新しい配色は良いですが、 ヘッダーを黒ではなく紺色にして。

各反復サイクルは非常に高速であり、多くの場合、数秒の処理で終わります。 これは、 1時間に多 数の反復を行えることを意味します。 手動でコーディングし、すべての変更を確認するのに比べれ ば、AIのアプローチは格段に高速です。 これは、スタイルの変更や機能の追加といった幅広い変更 に、特に当てはまります。

重要なのは、AIを使った反復作業には明確なコミュニケーションが必要だということです。 ここ で 「プロンプトエンジニアリング」 のスキルが役立ちます。 あなたが望む変更が明示的で明確なほど、 AIがその変更を正しく行う可能性は高くなります。 例えば、 「もっときれいに見えるようにして」 は 漠然としています。 より具体的なプロンプトは、アシスタントに具体的な指示を出します。

青いヘッダーを持つライトテーマを適用し、可読性のためにフォントサイズを大きくして。

Vercel v0. Lovableといったツールを使っているなら、そのインターフェイスを使い、 UIの一部 を指し示して「これをXに変えて」 と言うこともあります。

6.4 本番に向けてプロトタイプを進化させる | 115

開発者とAIコーディングアシスタントとの間の、 短い会話の反復プロセスを見てみましょう。

To-Do リストのReact コンポーネントを生成して。それは、タスクのリストと、新しいタスクを 追加するためのテキスト入力を表示すべきです。

AIはタスクのステートを持つReact コンポーネントを生成し、 リスト、入力、タスクを追加する ボタンをレンダリングします。

素晴らしい。 各タスクを編集可能にし、 完了を示すチェックボックスを追加して。

AIは、各タスクにチェックボックスと編集機能をレンダリングし、 それに応じてステートを変更 するように、コードを更新します。 開発者はアプリを実行し、 編集が動作しますが、 削除ボタンがな いことを見つけます。

各タスクに削除ボタンを追加して

AIは、コードに削除機能を追加します。

レイアウトが少し窮屈です。 基本的なCSSを追加して、 リストアイテムの間隔を空け、フォント をもう少し大きくして。

AIは、おそらくコンポーネントの<style>や別のCSSスニペットとして、 CSSスタイル付けを出 力します。

外観が良くなった!

このような行き来は、プロトタイプが構想を満たすまで続けられます。 開発者は最終的に、 作成、 編集、 完了、 削除機能を備えた、 To-Doリストアプリの動作するプロトタイプを手に入れます。

このプロセスを通して、 開発者は何が起こるかについての監督であり続けることを覚えていて ください。 AIは機能の実装方法を提案することがありますが、「あなた」が、 それがニーズに合って いるかどうかを決めるのです。 AIの実装が正しいものの、 あなたが期待していたものではないこと もあります (おそらく、 あなたが考えていたものとは異なるUIアプローチを採用しています)。 あな たはプロトタイプの目標を損なわないなら) それを受け入れるか、あるいは、 あなたの好みのアプ ローチに変更するようにAIに指示することができます。

6.4 本番に向けてプロトタイプを進化させる

プロトタイプは、概念実証 (PoC) であり、 何が動作するかを学ぶためのツールです。 プロトタイ プがその目的を果たしたら(例えば、ユーザーとともにデザインの妥当性を確認したり、 ある機能が 実現可能であることを証明したりしたら)、 次の段階は多くの場合、 それを本番アプリケーションに することです。この移行は、重要な分岐点です。 AIは引き続き役立ちますが、 人の開発者が、 プロ

116 | 6章 AI 駆動プロトタイピングツールとテクニック

トタイプの荒削りな部分を磨かなければなりません。 本節では、プロトタイプから本番コードに移行 する際の重要な考慮事項をいくつか見ていきます。

まず、アーキテクチャとコード構造を注意深くレビューしてください。 プロトタイプでは、内部が 散らかっていることがあります。 おそらく、すべてのコードを1つのファイルにまとめたり、速度の ために特定のベストプラクティスを回避したりしたのでしょう。 今こそ、 適切な構造を導入する時で す。 例えば、プロトタイプが1ページのスクリプトだったら、 それを複数のモジュールに分けること があります。 ウェブUIでは、適切なコンポーネント構造を導入することがあります。 バックエンド では、体系的なモデルビューコントローラー (MVC) アーキテクチャパターンを設定することがあり ます。

AIがプロトタイプの多くを書いたとはいえ、 開発者であるあなたがアーキテクチャの目標を最も 良く理解しています。 あなたは新しいプロジェクトを立ち上げ、プロトタイプを参照や足場として使 うことすらあります。 おそらくプロトタイプのコードの一部を再利用しますが、一般的にはそれを使 い捨てコードとして扱います。 また、AIがリファクタリングを提案したり、 クリーンアップ中に何も 壊れないことを保証するテストを生成したりしながら、プロトタイプのコードベースを徐々にリファ クタリングして、形を整えることもあります。

次に、エラー処理とエッジケースを追加します。 多くの場合、プロトタイプのコードは正常系のシ ナリオに焦点を当てますが、 API呼び出しが失敗したらどうなりますか? 入力が空だったら、どう なりますか? 各機能を体系的に調べ、 潜在的な故障モードを検討してください。

次のようなプロンプトがあれば、 AIはエッジケースをプレインストーミングする手助けをしてく れます。

この機能で起こりうるエラーケースと、その対処方法は?

アシスタントはおそらく、 あなたが処理を実装できる (あるいは、 AIにその実装を頼む) いくつ かのシナリオ(ネットワークエラー、不正な入力、 同時実行性の問題) をリストしてくれるでしょう。 コードの堅牢性を確保することは、本番環境対応の一環です。

プロトタイプのコードはおそらく最適化されていないので、非効率な部分やセキュリティ上の問題 を引き起こす可能性のある部分がないか確認してください。 例えば、プロトタイプの中のAIは、小 さなテストデータセットでは動作しますが、 実データでは遅くなってしまう素朴なアルゴリズムを 使っていることがあります。 こういった箇所を特定し、最適化してください (AIが生成したコードの 一般的な欠陥については、 「8章 セキュリティ、 保守性、信頼性」で取り上げます)。

パフォーマンステストを実行したり、プロトタイプにプロファイラーを使ったりしてボトルネック を見つけ、その関数の最適化をAIに頼むのも、1つの戦略です。 認証やデータ処理といったセキュ リティ機能も、確実にレビューしてください。 AIのプロトタイプが (SQLインジェクション攻撃の 危険がある) 適切なパラメーター化なしのSQLクエリを使ったり、 機密情報 (https://oreil.ly/ gzUjn) を含んでいたりすることは、珍しくありません。 これらの問題は 「修正されなければなりま

6.4 本番に向けてプロトタイプを進化させる | 117

2021年の調査 (https://oreil.ly/a721b) では、 「AIが生成したコードの約40%に潜在的な 脆弱性がある」ことが発見されました。 そのため、本番環境対応の一環として、警戒を怠らないこと です。 コードの静的解析やセキュリティテストを手動で実行するか、 「このコードにセキュリティ上 の問題がないかスキャンして」 とプロンプトでAIに指示してください。

多くの場合、プロトタイプにはドキュメントが欠けています。 コードを正式なものにする時に、ド キュメントを追加する必要があります。 各モジュールの人にレビューされた明確な説明は、数か月後 にコードを再検討する時に、 あなただけでなく将来のチームメンバーにも役立つでしょう。 一度コー ドをクリーンアップしたら、プロンプトでAIツールに指示して、 コードに基づいて、 システムがど のように動作するかを説明する MarkdownのAPIドキュメントやREADMEを作成させることがあ ります。 「1章 序論 バイブコーディングとは何か?」 では、 AIがコードの説明を生成する方法に ついて説明しました。 これは、その方法を活用する絶好の機会です。

「5章 生成されたコードを理解する レビュー、 改良、 所有」 で学んだように、プロトタイプを 徹底的にテストすることが重要です。 中心的なロジックの単体テスト、 主要なフローの統合テストな どを書くことがあります。 テストケースの生成をAIに頼むことで、これを加速させることができま す。

タスクの追加、編集、 完了、 削除をカバーした、 To-DoリストコンポーネントのJestテストを書いて。

そして、 AIが生成したテストを実行して、調整してください。 優れたテストスイートがあれば、 プロトタイプのコードをリファクタリングする時に、 自信を持てます。

時には、あなたのコードの特定の部分を完全に置き換えることを決断することがあります。 プロト タイプが間に合わせのライブラリや、長期的には適さないハックを使っていた場合などです。AIは、 これも高速化できます。 プロトタイプのコードではデータのローカル配列を使っていましたが、 適切 なデータベース統合が必要になったとしましょう。 あなたのプロンプトは、次のようなものでしょう。

タスクを格納するために、インメモリ配列の代わりにSQLite データベースを統合して。

AIはこの統合の出発点を提供でき、 あなたはそれをあなたが改良すべきです。

このような変更を行う際、 あなたの考え方を「ラピッドプロトタイピングモード」から、より規律 を守るエンジニアリングアプローチに切り替えるのが、賢明です。AIは今や、コード品質を向上さ せるためのあなたのアシスタントであり、もはや素早く機能を生成するだけの存在ではありません。 状況が少し異なります。 安定性と品質があなたの最優先事項である今、あなたはAIからの提案をよ り批判的に評価することがあります。 「4章 70%を超えて: 人の貢献を最大化する」 で述べたよう に、「シニア開発者は、 AIから多大な利点を得られます」。 何を受け入れ、何を修正すべきかを知っ ているからです。 この段階では、 あなたはそのシニアの考え方を大いに発揮します。 あなたは最終 システムの構想を持っているので、具体的な改善や実装のタスクをAIに任せます。

この議論の基盤を固めるために、簡単な例を考えてみましょう。 CSVファイルのデータをチャー

118 | 6章 AI 駆動プロトタイピングツールとテクニック

トに変換する小さなウェブアプリを作りたい、1人の開発者ジェーンを想像してください。 彼女はAI アシスタントを使って、 わずか1週間で素早くプロトタイプを完成させます。 基本的なAPIを備え たNode.js スクリプト、そしてCSVをアップロードし、 JavaScriptのチャートライブラリを使って チャートをレンダリングする単純なフロントエンドです。

ジェーンはこのプロトタイプを何人かの潜在ユーザーにデモし、 前向きなフィードバックを得たの で、これを実際のプロダクト(ウェブサービス) にすることに決めます。 彼女は、次のように移行を 進めていきます。

バックエンドを強化する

プロトタイプのNode.js APIには認証がありませんでした (誰でもデータをアップロードでき ました)。 本番環境では、ユーザーアカウントと認証が必要です。 彼女はAI を使って、 (おそら < JWTベースの) 認証システムを統合します。 AIは足場を提供してくれますが、 パスワードが 適切にハッシュされ、 トークンが安全であることを確認するために、彼女はそれを注意深くレ ビューします。 彼女はまた、AIが提案したコードと彼女自身の微調整を組み合わせて、 アップ ロード用のエンドポイントに入力検証を追加します (AIは、それを行っていませんでした)。

フロントエンドをリファクタリングする

初期のフロントエンドは、スクリプトタグでCDN (コンテンツ配信ネットワーク) 上の依存関 係を参照する、単一のHTMLファイルでした。 ジェーンは保守性を考慮して、 構造化された React アプリにリファクタリングすることにしました。 彼女はまず、スクリプトタグではなくビ ルドシステムとnpmを使うことで、より本番環境対応になるようにプロジェクトをリファクタ リングすることを、AIに依頼します。 次に、それらを React コンポーネントとして統合するよ うに、AIに依頼します。 例えば、それは、プロトタイプのチャートレンダリングのコードを、 <Chart> コンポーネントに変えてくれます。 ジェーンはAIを使って、 これらのコンポーネント の書き方を練習し、(プロトタイプでは深く考慮されていなかった) ステート管理とコンポーネ ント階層がベストプラクティスに従っていることを確認します。

パフォーマンスのテストと確認

ジェーンは、重要な関数 (CSV 解析、 データ変換) の単体テストを書きます。 エッジケースにつ いて確信が持てない時は、 AIに質問します。

CSV 解析について、 どんなエッジケースをテストすべき?

AIは、 空のフィールドや不規則な列といったシナリオを提案し、 彼女はそれをテストに組み込 みます。 彼女はまた、プロトタイプが CSVファイル全体をメモリにロードしていることに気付 きます。巨大なファイルでは、 これはクラッシュする可能性があります。 彼女は、 ストリーム処 理を行うようにコードを修正し、 AIを使ってストリームロジックを再確認しました。 これで、 アプリはより確実に巨大なファイルを処理できるようになりました。

6.5 AIプロトタイピングの課題に取り組む |

UIを洗練させる

プロトタイプのUIは実用的でした。 ジェーンは自分のプロダクトでは、ユーザー体験にもう 少し時間をかけます。 彼女は、 レスポンシブレイアウトの推奨と、 おそらくCSSフレームワー クの統合を、AIに依頼します。 AIはBootstrapを追加し、 ジェーンはそれを使って、 外観 (フォーム、 ボタン、レイアウト) を改善します。 その後、手動でCSSを微調整します。 この洗 練の段階は、重いコーディングよりはデザインの選択に関するものですが、(ナビゲーション バーやローディングスピナーといった) 標準UIパターンのために素早くコードを提供すること で、 AIは引き続き役立っています。

このような努力の結果、 かつての荒削りなプロトタイプは、はるかにクリーンで、より安全で、 よ りスケーラブルなアプリケーションとなり、 実ユーザー向けの準備ができています。 ジェーンはテス トを追加し、 AIが生成したコードをレビューしたので、 自信を持ってそのコードをデプロイします。 プロトタイプから本番環境までのこのプロセスには数週間かかったかもしれませんが、プロダクト全 体をゼロから書いたら、はるかに長い時間がかかったでしょう。 AIは初期プロトタイプを加速させ、 移行を支援し続けましたが、 人としてのジェーンの監督と再構築が、 本番品質に到達するのに不可 欠でした。

6.5 AIプロトタイピングの課題に取り組む

AI駆動のプロトタイピングは強力ですが、 課題がないわけではありません。 開発者としては、課 題を認識して緩和する方法を知っておくべきです。 特に注目すべき2つの領域は、スコープクリープ と統合です。

AIを使えば簡単に機能を追加できるため、 あなたはプロトタイプに「もう1つ」 追加して、どんど ん進めたくなることがあります。 これは「スコープクリープ」として知られる現象です。 これは、最 プロダクトになろうとして、どんどん大きくなっていくプロトタイプにつながります。 プロトタイ プの目的を思い出してください。 それは、あなたが答えたい重要な質問や、実証すべき中心的な体 験に焦点を絞ることです。 ログインシステム、決済処理などを実装していることに気付いたら、プロ トタイプの段階でそれが本当に必要かどうか、尋ねてください。 それらをスタプアウトする方が良い かもしれません (AIは、シミュレーションするために、本物ではない偽のログインフローを生成でき ます)。プロトタイプの焦点を絞っておけば、時間を節約し、後で使い捨てや作り直しが簡単になり ます。

集中し続ける

プロトタイプの目標 (「ユーザーがCSVをアップロードしてチャートを得られることを示し、実現 可能性を検証する」) を書き、 それを北極星のような指針として使ってください。 その目標に素早く 到達するためにAIを使い、プロトタイプを過剰に作り込みたくなる誘惑に抗ってください。

119

120 | 6章 AI駆動プロトタイピングツールとテクニック

第二に、実システムとの統合の問題があります。 多くの場合、プロトタイプでは、モックデータ や簡素化されたサブシステムを使います。 AIのプロトタイプがダミーデータやローカルファイルを 使っている場合、 それを本番環境の実際のデータベースやサービスと統合することは、簡単ではな いことがあります。 プロトタイピングの際には、いくつかの近道が取られていることに留意してく ださい。 例えば、 プロトタイプのメールは実際には送信されず、 コンソールにログを出力しただけ かもしれません。 本番環境では、本当の電子メールサービスが必要になります。 AIは、後の統合 を手助けしてくれますが、追跡しておくのは良いことです。 プロトタイピングしながら、 「前進する 場合に対処すべきこと」のリストを管理してください。 そうすれば、 どの部分が一時的なものだっ たかを忘れることはありません。 チームで作業する場合、 これらを明確に伝えてください。 例えば、 // TODO: ここで、 本当の電子メールサービスと統合する」 と、コードにコメントを残すことがで きます。 多くのAIツールは、 簡素化された解決策を生成する際に、 実際にこのようなTODO コメン トを含めるので便利です。

これらの課題を見込むことで、 罠にはまることなく、 AIプロトタイピングを効果的に利用できま す。 熟慮して使えば、記録的な速度で開発された堅牢なプロトタイプが得られ、それを最終プロダ クトに変えることも、そこから得られた教訓を引き出した後に脇に置いておくこともできます。

6.6 まとめと次の一歩

本章では、 AI支援のバイブコーディングが、 プロトタイピングのプロセスをどのように加速させ るかを見てきました。 コード生成の重労働をAIに任せることで、 開発者はコンセプトから動作する モデルまで、かつてない速度で移行できます。 UI生成のためのVercel v0. フルスタックのプロトタ イプのためのLovable, Cursor, WindsurfのようなAI拡張IDEといったツールを取り上げまし た。 それぞれが、ラピッドプロトタイピングの異なる側面を可能にしています。 私はまたAI プロ トタイピングの反復的な性質を強調しました。 自然言語プロンプトが変更を導きながら、 生成、テス ト、 改良を素早いサイクルで行います。

AI駆動のプロトタイピングでは数時間で機能するデモを作成できますが、 重要な本番環境への移 行についても議論しました。 メッセージは明確です。 プロトタイプは最終プロダクトではありません。 最初の下書きなのです。 人の開発者はコードのリファクタリングと強化を行う必要があり、AIは (改 善点の提案、テストの生成といった) その道のりを引き続き支援します。 こういったテクニックを 使った個人やチームの事例研究は、本当の生産性向上を強調しています。 数週間ではなく数日で構 築されたプロトタイプが、 高速なユーザーフィードバックとビジネス上の決定を可能にします。

ここまでで、 バイブコーディングがプロトタイピングを、ボイラープレートを書き出すのではなく、 アシスタントとブレインストーミングをするような感覚にしてくれることを、理解できたと思います。 それは、根本的に異なるバイブスなのです。 より会話的で、より高レベルで、ずっと高速なのです。 しかし、素早いプロトタイプであっても、コード品質への意識を保つことの重要性を、そして、プロ トタイプ段階を超えて進化させる際にはなおさら重要であることを、あなたはすでに目にしてきまし

た。

6.6 まとめと次の一歩 |

「7章 AIでウェブアプリケーションを構築する」では、ラピッドプロトタイピングからAIの支援 による包括的なウェブアプリケーション開発に、焦点を移します。 プロトタイピングでは可能性を探 りますが、本格的な開発では、 アーキテクチャ、実装、 デプロイに対する体系的なアプローチが求 められます。

121



| 123

7章

AIでウェブアプリケーションを

構築する

本章では、素早いプロトタイピングでのプロンプティングから、 AIの支援を使った完全な ウェブアプリケーションの開発に焦点を移します。 ウェブアプリには通常、 (多くの場合、 React、 Angular Vue といったフレームワークで書かれた) フロントエンド、 (API 、 データベース、サー バーといった) バックエンド、 そしてすべてを接続するグルー(つなぎ) が含まれます。 バイブコー ディングは、これらの各レイヤーを加速させることができます。

AIペアプログラマーとともにウェブアプリケーションを構築するための、エンドツーエンドの ワークフローを順を追って確認しましょう。

. プロジェクトのセットアップとスキャフォールディング (足場作り)

• フロントエンドUIのコーディング

● バックエンドロジックの実装

. データベースとの統合

• スタック全体のテストと妥当性確認

その過程で、 フロントエンド向けのAI開発パターン (例えば、AIに説明から React や Vueのコ ンポーネントを生成させること)、バックエンド向けのAI開発パターン (自然言語プロンプトを通し て、ルート、ビジネスロジック、 データベースクエリを書くこと) を紹介します。 また、フルスタッ クのプロジェクトで人とAIとの協働を最適化し、 それぞれが最も得意とする作業に貢献できるよう にする方法も取り上げます。 本章が終わる頃には、あなたは、AIを単独のコーディングタスクに使 うだけでなく、 ウェブ開発のワークフロー全体を効率的かつ効果的に管理するための、明確なロー ドマップを手にしているはずです。

7.1 プロジェクトをセットアップする : AIによるスキャフォールディング

すべてのウェブアプリケーションは、 「スキャフォールディング」、つまり、 ビルドツール、ファイ ル構造、依存関係などの初期設定から始まります。 AIは、多くのボイラープレートの作成を自動化

124 | 7章 AIでウェブアプリケーションを構築する

できます。 最新のウェブフレームワークには、 多くの場合、 ベースプロジェクトを生成できるコマ ンドラインインターフェイス(CLI) ツールが付属していますが、それでも特定のものを構成したり、 追加のライブラリを統合したりする必要があることがあります。 AIアシスタントは、こういったCLI ツールを使って導いたり、オンデマンドでカスタムのプロジェクト構造をセットアップしたりするこ とで、あなたを助けることができます。

例えば、あなたが、フロントエンド向けのReactとバックエンド向けのExpress を使って、新し いアプリケーションプロジェクトを開始したいとしましょう。 このタスクのAI以前のワークフロー は、おそらく次のようなものでしょう。

1. CLI ツールや Vite を実行し、 React プロジェクトをセットアップする。

2. (おそらく npm init で Express をインストールして) Express アプリを初期化する。 3. 開発向けのプロキシをセットアップするか、 オリジン間リソース共有 (CORS) (https://oreil. ly/bgw1V) を構成して、React フロントエンドがExpress バックエンドと通信できるようにする。 4. MongoDB のようなデータベースを統合するか、単純な使用のために SQLite ファイルをセット アップする。

Cursor や ClineのようなAIコーディング環境を使えば、 あなたは希望するセットアップを一度に 説明できます。

(Vite を使った) React フロントエンドとExpressバックエンドで、新しいプロジェクトをセット アップして。 バックエンドは、 To-DoリストのREST APIを提供して、 まずはインメモリ配列を 使って。 開発中にバックエンドへのAPIリクエストをプロキシするように、フロントエンドを構 成して。

高度なAIDEは、この指示を受けて、 次のようなことが行います。

2つのディレクトリ(フロントエンド、バックエンド) を作成する。

(シェルにアクセスできる場合) npm create vite@latestを実行するか、 基本的な Reactアプ リをテンプレートから作成する。

•バックエンドで、いくつかのサンプルデータを返す) /api/to-dosのようなエンドポイントを備 えた、基本的なExpressサーバーファイルを初期化する。

各ディレクトリに、 (start both といった) 関連スクリプトとともに、 package.json を置きます。 • React開発サーバーでプロキシを構成するか、 CORSヘッダーを実装するための指示を提供す ることで、フロントエンド、バックエンド間の通信をセットアップする。

数分で、フルスタックのウェブアプリの骨格ができ上がります。 AIがすべてを自動でやってくれ るわけではありませんが、(例えば、「このプロキシ設定を React の package.jsonファイルに追加して ください」といった) コードとそれを完成させるために必要な指示を与えることがあります。 これに よって、 多くのセットアップ時間を節約し、すぐに機能に集中できます。

7.1 プロジェクトをセットアップする AI によるスキャフォールディング | 125

AIIDEを使っていなくても、例えば次のように、 ChatGPTや他のアシスタントを段階的に使え ます。

新しいReactアプリを作成したい。 どんなコマンドを実行すればいい?

AIは、あなたを段階的に導いたり、 Vite、 Next.jsのような新しい代替手段を推奨したりすること ができます。

ここで、/api/to-dosルートを持つExpressサーバーをセットアップして。

AIはExpress サーバーのコードを生成し、 あなたはそれをファイルにコピーします。

開発中にReact アプリをこのAPIに接続するには、どうすればいい?

AIは、プロキシ構成を提案したり、(プロキシしない場合の、 完全なURLといった) APIの呼び出 し方法を教えてくれたりします。

こうすることで、 基本的な配管のセットアップでさえ、 ドキュメント内の捜索ではなく、会話にな ります。 以前の章で述べたように、 「意図によるプログラミング」とは、どのような成果が欲しいか をAIに伝え、AIがその手順を見つけ出すことを意味します。 プロジェクトのセットアップは、その 完璧なシナリオです。

この段階では、アーキテクチャの決定を主張することが重要です。 AIはあなたの指導に従います。 アーキテクチャや高レベルの決定には人が不可欠なので、スタックや主なパターンについては、あな た自身が決めてください。 モノリポにしますか? それとも、フロントエンド、バックエンドでリポジ トリを分けますか? REST を使いますか? それとも、 GraphQLを使いますか? どのデータベース を使いますか?

これらが決まれば、それに従って次のようにAIに指示できます。

また、SQLite データベース用に基本的なPrismaスキーマをセットアップして。

あるいは、次のように指示できます。

RESTの代わりに、 GraphQLサーバーを含めて。

AIは複雑なセットアップを完璧には実行しないかもしれませんが、作業の大部分をやってくれる でしょう。 あなたは、 そこから改良できます。

多くの経験豊富な開発者は、これらの手順をプロジェクトテンプレートに統合したり、 ボイラーブ レートジェネレーターを使ったりしますが、 AIはより柔軟なアプローチを提供しています。 あなた は、自然言語を使ってその場でカスタマイズできるのです。 つまり、 通常の2つではなく3つの層 が必要な場合や、 Tailwind CSS といった特定のライブラリを事前構成したい場合など) あなたのプ ロジェクトが少し変わっている場合、 あなたが望むものを含めるように、AIに頼むだけでいいので す。

126 | 7章 AIでウェブアプリケーションを構築する

7.1.1 AIを使ったフロントエンド開発パターン

スキャフォールディングの準備ができたら、ウェブアプリのフロントエンドの開発が主な作業にな ります。 本節では、フロントエンドのコードでAIペアプログラマーを活用する方法を探ります。

7.1.1.1 説明からコンポーネントを実装する

例えば次のように、 機能と外観を説明することで、 コンポーネントの作成をAIに頼めます。

To-Do項目のリストを受け取ってそれらを表示する、 TodoList という React コンポーネントを作 成して。 各項目は、タイトルと完了を示すチェックボックスを表示する必要がある。

AIは、 必要に応じて propsとstateを備えた関数コンポーネントとして、コードを生成します。

ユーザー名、パスワードを入力するログインフォーム用のVue コンポーネントを作成し、 送信時 にフォームデータを含むイベントを送出して。

AIはそれに応じて、 <template> <script> <style> セクションを出力するでしょう。 開発者で あるあなたは、 ボイラープレートを書く手間を省き、 必要な構造を直接得られます。 必要なら、簡単 に手を加えられます。 多くの場合、 あなたのプロンプトがそれらが必要だと示唆しているなら、 AI は基本的な検証やステート処理まで含めます。

この段階で、一貫性を確保することが重要です。 複数のコンポーネントを別々に生成したなら、 それらが一緒に動作するように調整する必要があることがあります。 例えば、 TodoList が特定の 形のpropsとして項目を受け取ることを期待している場合、 TodoList を使うコンポーネントがそれ を提供するようにしてください。 (AIがすべてを認識できるように) 1つのプロンプトで複数のコン ポーネントを生成するか、あるいは、単に自分で配線して、 不一致の修正をAIに頼んでください。

7.1.1.2 スタイル付けとレイアウト

CSSとスタイル付けは面倒なものです。 あなたが望む外観を説明し、AIにCSSの詳細に対処させ ます。

ToDoリストのコンポーネントをスタイル付けして。 リストにはflex column を使い、適度な 余白を入れて、 完了した項目のテキストの色をグレーにして、取り消し線を付けて。 ・ログインフォームのコンポーネントは、ページの中央に配置し、入力フィールドを大きくして、 角を丸めて。

アシスタントは、コンテキストに応じて、 CSS-in-JS、 プレーン CSS、 インラインスタイルを出力 できます。 Tailwind CSSのようなフレームワークを使っているなら、 適切なクラスを出力するよう に、AIに頼めます (ただし、 すべてのモデルがTailwindを熟知しているわけではないことを、覚え ておいてください)。

重要なのは、 CSSの値を手動でいじらなくても、デザインを反復できることです。 これによって、

7.1 プロジェクトをセットアップする AI によるスキャフォールディング 127

あなたはmarginや colorをすべて書くのではなく、より抽象化された 「優れた外観」の指定に集中 できます。

7.1.1.3 APIとステート管理の統合

多くの場合、 ウェブフロントエンドは、バックエンドからデータを取得し、 (Redux、 コンテキス ト、単なるコンポーネントのステートといった) ステートを管理する必要があります。 例えば次のよ うに、AIは、こういった統合部分を書くのを助けてくれます。

Todolist コンポーネントがマウントされた時に、 /api/to-dos からTo-Doリストを取得し、そ れをステートに格納するコードを追加して。

●チェックボックスが切り替えられた時、 /api/to-dos/{id}/complete に POSTリクエストを送 信し、それに応じてステートを更新する、 TodoListの関数を実装して。

AIは、ReactのuseEffect フックを生成して取得したり、 Vueのmounted() フックを生成した りできます。 また、 AIは、 (fetchやAxiosなどを使って) HTTP呼び出しをスタブアウトできます。 (あなたがバックエンドを構築しているか、あるいは、バックエンドの仕様があるなら) APIエンド ポイントとペイロードが、 バックエンドの期待と一致していることを確認したいでしょう。

バックエンドをまだ作成していないなら、 AIを使って同時にバックエンドを作成することがあり ます。 これについては、すぐ後で取り上げます。 あなたは、 AIの支援を受けながら、 フロントエン ド、バックエンドで並行して作業できます。 なぜなら、 あなたが両者間のインターフェイスを把握し ている限り、 それぞれを比較的独立して指定して生成できるからです。

7.1.1.4 AIの指導で複雑さに対処する

フロントエンドに、 動的なフォーム検証規則、 条件付きレンダリング、 複雑なユーザー対話といっ た複雑なロジックがある場合、 AIを使ってこれらを段階的に実装できます。 問題を分解することが、 優れたプラクティスです。

機能を追加して ユーザーがTo-Doの 「完了」ボックスをチェックしたら、そのリスト項目を フェードアウトさせて (CSS移行)、 1秒後にリストから除去して。

AIは、チェック時のCSSクラスを追加し、 フェードアウトに必要なCSSを含め、 項目の除去にタ イムアウトを使うコードを生成するでしょう。

フォームには、「メモ」用のオプションフィールドがある。 「メモを追加」チェックボックスが チェックされている場合にのみ、メモのテキストエリアを表示して。

AIは、メモのフィールドを条件付きでレンダリングするために、コンポーネントのステートとJSX を修正できます。

これらはそれぞれ、 反復的なプロンプトにできます。 基本的には、あなたがUXの振る舞いを説明

128 | 7章 AIでウェブアプリケーションを構築する

し、AIがコードを書きます。 追加した後には毎回、必ずテストして、期待通りに動作することを確 認してください。

フレームワーク固有のヒント

フレームワークが異なれば、 イディオムも異なります。

. Reactでは、 AIは (useState, useEffectといった) フックを使うことがあります。 それが (例 えば、 useEffectの依存配列が正しい、 といった) ベストプラクティスに従っていることを再確 認してください。

• Vueでは、AIは、そのAIが学んだ内容に応じて、 Options APIスタイルか Composition API スタイルを出力することがあります。 あなたがどちらかを優先するなら、そのように (例えば 「Vue 3 Composition API を使って」 のように) 指定してください。

Angular では、AIはコンポーネントを生成できますが、 Angular は学習曲線が急です。 AIは要 求に応じてテンプレート、 TypeScript クラス、 基本的なサービス注入を生成できることがあり ますが、あなたはより多くの手作業を行うか、あるいは、 構造についてはAngular CLI を使い、 (フォーム検証ロジックといった) 特定の部分をAIに埋めてもらう必要があるでしょう。

7.1.2 AI を使ったバックエンド/API開発パターン

それでは、バックエンドに目を向けてみましょう。 AIを使ったウェブアプリケーションのサー バーサイドの構築も、類似のパラダイムに従います。 あなたがエンドポイント、 データモデル、ロ ジックを説明し、 AIがコードを生成します。 一般的なバックエンドのコンポーネントには、ルート ハンドラー、 ビジネスロジック データベースとの対話、 検証などがあります。 AIはこれらすべて を支援できます。

7.1.2.1 APIエンドポイントを実装する

あなたのTo-Doリストアプリ用に、 RESTful API を構築しているとしましょう。 あなたは、 GET /to-dos POST/to-dos、 PUT /to-dos/:id、 DELETE / to-dos/:idといったエンドポイントを持 つでしょう。あなたは、1つずつエンドポイントを作成できます。

(今のところ、メモリに格納された配列を使って) To-Doリストを返すGET /api/to-dos ルート を Express アプリに追加して。

• JSON 本文を受け取り、リストに新しいTo-Doを追加する POST /api/to-dos ルートを追加して。 ID付きで、 新しい To-Doを返して。

AIはそれに応じて、おそらく app.get('/api/to-dos', ...) といったものを使って、 Express ルートハンドラーを書きます。 あなたがJSONとともにExpressを使っていることを示すと、 AIは、 必要なミドルウェアがまだ存在しない場合、 それを含めることがあります。

7.1 プロジェクトをセットアップする AI によるスキャフォールディング | 129

app.use(express.json ())

バックエンドが成長するにつれて、 あなたはAIにリファクタリングを頼めます。

Expressルートを、別のルーターモジュールにリファクタリングして。

AIは、ルートを別のファイルに分割するでしょう。 これは、保守性のための優れたプラクティス です。

7.1.2.2 データベースの統合

プロトタイプではインメモリデータを使うことがありますが、 より完全なアプリケーションでは データベースが必要です。 あなたが MongoDB か PostgreSQLを選んだとしましょう。 次のように、 プロンプトで指示できます。

Mongoose を使って、 MongoDBをExpressアプリに統合して。 title (文字列) completed (ブール) というフィールドを持つ、 To-Doモデルを作成して。 GET/POSTルートを修正して、 インメモリ配列の代わりにデータベースを使うようにして。

AIはMongoose モデル定義を出力し、 (GETでは Todo.find()、POSTではTodo.create() のよう に) データベースをクエリするようにルートハンドラーを調整します。 同様に、SQLでは、 Prisma、 Sequelize といったオブジェクトリレーショナルマッピング (ORM) (https://oreil.ly/AoWDL) をセットアップするように、 AIに頼めます。 あなたは (接続文字列のような) 構成の詳細を提供する 必要があるかもしれないことを覚えておいてください。 AIは、あなたのデータベースURIを知ら ないことがあります。 しかし、 AIは一般的なコードに対処します。

7.1.2.3 ビジネスロジックと検証

バックエンドに (例えば、ユーザーは重要だとマークされたTo-Doを削除できない、リストのタイ トルはユニークでなければならない、といった) 特定の規則がある場合、 あなたはAIを使って、 そ れらをコード化できます。

POST /api/to-dos ルートに検証を追加して。 タイトルが空か、あるいは100文字より長い場合 は拒否し、400ステータスを返して。

AIはチェックを含め、 適切なレスポンスを送るようにします。

次のロジックを追加して。 (例えばPUT /api/to-dos/:idを通して) To-Doが完了とマークされ た時、 すべてのTo-Doが完了していたら、「すべて完了!」というメッセージをログに記録して。

AIは、そのロジックをPUTハンドラーに挿入できます。 あなたはこういった要件をわかりやすく説明し、 AIはそれに従ってコードを修正します。 それで も、コードが期待通りに動くか、テストする必要があります。

130 | 7章 AIでウェブアプリケーションを構築する

7.1.2.4 フレームワークやボイラープレートを使う

多くのウェブバックエンドは、素のExpress ではなく (Node.jsのNestJS、 Python の Django といった) フレームワークを使っています。 あなたは、 より複雑なタスクを分解する必要があるかも しれませんが、AIはこれらのフレームワークとも連携できます。

• Python の Django では、次のようにプロンプトで指示することがあります。

フィールドXを持つTo-Do用の Django モデルと、 それに対応するリスト、 表示のビューを作成 して。 合の

AIは、そのコンテキストを知っていれば、 モデルコードや汎用ビュー、 DRF (Django REST Framework) のシリアライザー/ビューセットを出力することがあります。

• Ruby on Rails では、 あなたはモデル、コントローラーを生成する助けを得られます (その時点 では、 あなたはRailsのスキャフォールディングを使うだけかもしれませんが、 AIが検証の追 加やルートの調整によって補完できます)。

AIモデルは、 異なるプログラミング言語や技術スタックにわたってさまざまな習熟度を示します。 これは主に、 トレーニングデータでの技術の普及率によって決まります。 モデルはトレーニング中に 遭遇したあらゆる言語を使えますが、 その効果は大きく異なります。 JavaScript、 Python、Javaと いった人気の言語は、トレーニングコーパスにオープンソースリポジトリ、 ドキュメント、 教材が豊 富に含まれているため、 通常、 強力なサポートを得られます。

あなたが選択したスタックに対するモデルの習熟度を判断するには、 実践的な評価が必要です。 対象言語の基本タスクでモデルをテストすることから始め、徐々に複雑さを増して、 モデルの能力 を測ってください。 モデルが、 言語固有の慣習に従った慣用コードを生成するかどうか、 一般的な フレームワークやライブラリを多くの説明なしに認識するかどうか、 そのエコシステムに適したデザ インパターンを提案するかどうかに注目してください。 強力な習熟度は、コンテキストに応じた適 切な提案として現れます。 一方、サポートが弱いと、 多くの場合、 一般的な、 あるいは時代遅れの コードパターンになります。

多くのAIプロバイダーはモデルの能力に関する文書を公開していますが、これらに言語固有の詳 細なベンチマークが含まれていることはまれです。 最も確実なアプローチは、 あなたの実際の技術 スタックを使って小規模な実験を行うことです。 例えば、 Ruby on Rails を使っているなら、モデル がActiveRecord パターンといったRailsの規約を理解しているか、 適切な RSpecテストを生成で きるかをテストしてください。 同様に、 新しいフレームワークやあまり一般的でない言語では、結果 のばらつきが大きくなることを想定し、モデルのトレーニングにおける潜在的な不足を補うために、 あなたのプロンプトで追加のコンテキストを提供できるよう準備しておいてください。

7.1.2.5 多段階の操作をオーケストレーションする

あるテーブルでエントリを作成した後に別のテーブルでエントリを作成したり、 外部APIを呼び

7.1 プロジェクトをセットアップする: AIによるスキャフォールディング |131

出したりするような、複数の手順を含むエンドポイントもあります。 あなたは手順の順序の概要を説 明し、AIに下書きを作らせることができます。

(POST /api/usersで) 新規ユーザーが登録する時に、ユーザーレコードを作成し、 SendGrid APIを通してようこそメールを送信して

AIは、(おそらくオブジェクトリレーショナルマッパー (ORM) を使って) ユーザーを保存し、 そ れから、適切なペイロードでSendGrid APIにHTTPリクエストを送信するコードを書けます。 あ なたは実際のAPIキーを入力し、 内容を調整しますが、 ほとんどのボイラープレートは完了してい ます。

トランザクションを実装して。 (POST /api/transferで) 送金する時、アカウントAから引き落 とし、 アカウントBに入金し、 それがアトミック (すべて成功か すべて失敗か) であるようにし て。

あなたが、 トランザクションをサポートするORMやデータベースを使っているなら、 AIは、 (SQLトランザクションブロック、 ORMのトランザクションメソッドといった) それらの機能を使う ことがあります。 そういったコードが正しいか、 慎重にレビューしてください。 トランザクションロ ジックは、 特に扱いにくいものです。 しかし、 AIはよくある落とし穴を知っていて、 チェックを入 れていることがあります。 例えば、AIが送金エンドポイントに対処するようにプロンプトで指示さ れた時、次のようなコード構造を生成しました。

async function transferMoney (fromAccountId, toAccountId, amount) const session= await db.startSession();

try {

await session.startTransaction(); // 送金元口座から引き落とす const sourceAccount await Account.findByIdAndUpdate( ); fromAccountId, { $inc: { balance: -amount }}, { session, new: true }

if (sourceAccount.balance < 0) { } throw new Error('Insufficient funds');

{

// 入金先口座に入金 await Account.findByIdAndUpdate( toAccountId,

132 | 7章 AIでウェブアプリケーションを構築する

); { $inc: { balance: amount }}, { session }

await session.commitTransaction(); return { success: true };

} catch (error){ await session.abortTransaction(); throw error; } finally { ) session.endSession();

AIは、両方のデータベース操作をトランザクション内に正しくラップし、資金不足の検証を含め、 エラー時のロールバックに適切に対処しました。 あなたは、エッジケースをレビューし、 適切なロギ ングを追加する必要がありますが、 基本的なトランザクション構造は、 アトミックな操作を理解して いることを示しています。

7.1.2.6 API のドキュメントとテスト

あなたは、APIを構築する際、AIにドキュメントを作成させることもできます。 例えば、 「/api/ to-dosエンドポイントの簡単なドキュメントを書いて」と指示すると、次のようなものが生成される でしょう。

GET /api/to-dos To-POST /api/to-dos 新しいTo-Doを作成する。 次のJSONを期待する: {title: string}。 作成された To-Doを返す。

Doのリストを返す。

...

これは素早く参照するのに便利ですし、 (チームで作業しているなら) フロントエンド開発者と 共有するのにも便利です。 さらに、 あなたは、 Node.js用のJest や Mocha、 Python API 用の PyTest といったテストフレームワークを使って、 AIを使ってAPIエンドポイントのテストを書けま す。 「To-Do APIのテストを生成して(リスト、作成、 検証エラーのテストを1つずつ)」といったプ ロンプトがあれば、AIはテストコードを出力し、 あなたは、それを実行して検証できます。

7.2 データベースの設計と統合

データベーススキーマの設計には、ビジネスドメインに関する人の知識が欠かせません。 しかし、 AIは、その設計を (マイグレーションスクリプトやORMモデルといった) コードに変換する手助け をできます。 また、 あなたがスキーマに確信を持てないなら、AIとブレインストーミングを行えま

す。

7.2 データベースの設計と統合 |

例えば、あなたのアプリがTo-Doリストだけでなく、 完全なプロジェクト管理ツールに拡張され るとしましょう。 あなたは、 プロジェクト、タスク、ユーザーなど、いくつかのテーブルを設計する 必要があります。 あなたは 「ユーザー、プロジェクト、 タスクを備えた単純なプロジェクト管理アプ リには、どんなデータモデルが必要? 関連も含めて」と尋ねることができます。 AIは、次のように 答えるでしょう。

• User (id, name, email など)

• Project (id, name, User を参照する owner_id)

• Task (id, description, project_id, (Userへの) assigned_to, status など)

これはあなたが望むものと厳密には違うかもしれませんが、あなたに出発点を与えてくれます。 あ なたはこういった設計のアイデアを確認し、 微調整し、実装します。

7.2.1 ORM を使う

あなたが Prisma、 Entity Framework, SQLAlchemyといったORMを使うなら、AIにモデル クラスやスキーマ定義を生成させることができます。

(Node.js用の) Sequelize を使って、 関連も含めて、 User Project、 Taskのモデルを定義して 1人のUserは多くのProjectを持ち、 ProjectはUserに属します。 Projectは多くのTaskを持ち、 TaskはProjectに属します。 TaskはUser に割り当てられることがあります (多対1)。

AIはSequelize モデルと関連を定義する JavaScript/TypeScriptコードを書き、 あなたはそれを コードベースに統合できます。 また、AIが外部キーやカスケード規則に精通していれば、それらを 提案することがあります。

あなたがORMを使っておらず、 素のSQLマイグレーションを書いているなら、AIにマイグレー ションスクリプトを下書きさせることもできます。

適切な外部キーを持つユーザー、プロジェクト、タスクのテーブルを作成するSQL スクリプトを 書いて。

AIはSQL DDLスクリプトを出力し、 あなたはそのスクリプトが正しいかレビューし、実行でき ます。

7.2.2 データベースクエリ

あなたは、コードにデータベースを統合する時、 単純なCRUDより複雑なクエリが必要になるこ とがあります。 例えば、すべてのプロジェクトとそのタスク、 各タスクに割り当てられたユーザーを 取得したいとしましょう。 これは、 Project、 Task, Userにわたる結合です。 あなたは、次のよう にプロンプトで指示できます。

133

134 | 7章 AIでウェブアプリケーションを構築する

プロジェクトとそのタスク、 各タスクに割り当てられたユーザー名を検索するSQLクエリを作成

して。

AIがあなたに代わって、 SQL 結合クエリを生成することがあります。 あるいは、 ORM を使っているなら、次のように指示できます。

Sequelizeを使って、関連するタスクと各タスクのユーザーを持つ、 得して。

すべてのプロジェクトを取

あなたは、次のような、関連するデータをロードするためのコードを期待するでしょう。

include: [Task, { model: User, as: 'assignedUser' }]

7.2.3 AI が生成したクエリを確認する

AIが生成したコードが実際のスキーマと合っており、 データの完全性が保たれるようにするため に、データベース操作には慎重な検証が必要です。 あなたがプロンプトで明示的に情報提供しない 限り、 AIは特定のテーブル名、 フィールド名、 関連を自動的に知ることはできません。 モデルに会 話メモリがある場合でも、正確性を確保するために、あなたは複雑なデータベース関連の各プロン プトにスキーマの詳細を含めるべきです。 この明示的なアプローチは、スキーマが実際にはuserId や customer_ref を使っているのに、 AIが生成したクエリがuser_idといった一般的なフィールド 名を参照してしまうという、よくある問題を防ぎます。

パフォーマンスの考慮事項には、多くの場合、人の監視が必要になります。 AIモデルは主キーや 結合といった基本的なデータベースの概念を理解していますが、頻繁にクエリされるフィールドへ のインデックスの追加、 クエリの実行計画の検討といったパフォーマンス最適化を、 自動的に提案 することはありません。 特に、頻繁に実行される操作や大規模データセットに対して実行される操 作については、生成されたクエリの効率性を確認してください。

データー貫性 (整合性) 規則は、明示的な仕様が求められる、もう1つの重要な領域です。 削除 操作を実装する場合、 あなたが期待するカスケードの振る舞いを明確に定義してください。 例えば、 Project レコードを削除する場合、 データベースが関連するTask レコードを自動的にカスケード前 除すべきか、あるいは、アプリケーションロジックがこのクリーンアップに対処するかを、あなたが 決めなければなりません。 こういったビジネス規則をAIに明確に伝えてください。

プロジェクトが削除されたら、関連するすべてのタスクをカスケード削除するように、データベー スを構成して。

あるいは、 別の方法もあります。

7.3 フルスタックの統合フロントエンドとバックエンドの融合 | 135

プロジェクトを削除する際、 まず既存のタスクを確認し、それが存在する場合は削除しないよう にして。

明確な指示があれば、 AIはどちらのアプローチも効果的に実装できます。 カスケード削除では、 AIは ON DELETE CASCADE付きの外部キー制約を生成するでしょう。 アプリケーションレベルの対処 では、削除を許す前に関連レコードをクエリするコードを生成するでしょう。 重要なのは、 あなたの 特定ドメインでの適切な振る舞いを、 AIが推測するだろうと考えるのではなく、 あなたのデータ完 全性の要件を明示的に示すことです。

7.3 フルスタックの統合: フロントエンドとバックエンドの融合

AIの助けを借りてフロントエンドとバックエンドの両方を構築してきたので、次の課題は、それ らをシームレスなウェブアプリケーションに統合することです。これには、フロントエンドからAPI エンドポイントが正しく呼び出され、データが適切に流れ、システム全体が一貫しているようにする ことが含まれます。

7.3.1 フロントエンドとバックエンドの契約を合わせる

これは重要です。 フロントエンドは特定の形のデータを受け取ることを期待しているため、 バック エンドが送信するデータはその期待に合っていなければなりません。 両者で別々にAIに作業させた ら、小さな不一致が起こる可能性があります(バックエンドは{ success: true, data: [...] }を 返しますが、 フロントエンドは配列を直接受け取ることを期待していることがあります)。これを避 けるには、両者のコーディングの時に使うレスポンスの形式を、 AIに明示的に指示します。 あるい は、両者の作業が完了したら、 エンドツーエンドで呼び出しをテストしてください。 例えば、 ウェブ アプリを開き、リストがロードされるかを確認してください。 ロードされない場合、 ブラウザーコン ソールをサーバーログを照合してください。

多くの場合、私はAIを使って一方を他方に合わせるように調整します。

バックエンドがフロントエンドの期待とはわずかに異なるJSONキー名を返し、あなたがバグ に気付いたら、あなたは(どちらかの側で) 次のようにAIに言えます。

JSON で 'taskList' (単数形) の代わりに 'tasks' (複数形)を使うように、コードを修正して。

• フロントエンドがフォームデータをform-encodedで送信していますが、バックエンドがJSON を期待しているなら、あなたはAIに変換を頼めます。 フロントエンドでJSON.stringify を使 うか、バックエンドでbody-parser を追加します。

136 | 7章 AI でウェブアプリケーションを構築する

7.3.2 AIを使ったリアルタイムの協働

プロジェクト全体のコンテキストを保持する Cline Cursor といったAI拡張IDEは、この統合段 階で特に役立ちます。 あなたは、IDEベースのツールでフロントエンド、バックエンドのファイルを 一緒に開き、次のようにプロンプトで指示できます。

フロントエンドの/api/to-dos からの取得が、 Expressルートが期待するリクエスト/レスポンス と合っていることを確認して。 不一致があれば修正して。

すると、(フロントエンドに await response.json ( がなかったら追加する、 JSON 構造を調整す るなど) AIが内容を調和させることがあります。

7.3.2.1 ステート管理と同期

フルスタックアプリでは、プロの結果を得るために、読み込み状態や、フロントエンドでAPI呼 び出しに失敗した場合のエラー処理などの実装を検討してください。 あなたは、 次のようにプロン プトで指示するでしょう。

ローディングインジケーターを追加して。 Reactコンポーネントがタスクを取得している時、 データがロードされるまで 「読み込み中･･･」 テキストを表示して。

あるいは、次のように指示するでしょう。

エラーを処理して。 (200以外のレスポンスで) API呼び出しに失敗したら、 UIにエラーメッセー ジを表示して。

これは、 isLoadingステートと条件付きレンダリングを追加したり、エラーを捕捉してメッセージ を表示するために、 fetchの周りにtry/catch を実装したりします。 このように洗練されたアプリは、 堅牢性を「感じさせます」。

7.3.2.2 WebSockets と高度な統合

あなたのアプリが (WebSockets や SSEを使うような) リアルタイム更新を必要とするなら、あな たは次のようにプロンプトで指示することがあります。

Socket.ioを使って、 WebSockets をセットアップして。 サーバーで新しいタスクが作成された ら、接続しているすべてのクライアントにそれをブロードキャストして。 新しいタスクをリッス ンし、それをリアルタイムでリストに追加するように、 フロントエンドを修正して。

これは複雑ですが、AIは、 (io.on('connection', ...) を追加する、 新しいタスクの作成時にイ ベントを送出するといった) サーバーサイドのSocket.ioのセットアップ、 そして、接続してそのイ ベントをリッスンするクライアントサイドのコードを生成するでしょう。 あなたはこれを注意深く統 合する必要がありますが、こういった説明によって動作するリアルタイムのコードを作成できること

7.3 フルスタックの統合 フロントエンドとバックエンドの融合 | 137

は、実に驚くべきことです。 コードがいきなり完璧に動かなくても、反復的なプロンプティングとテ ストで、そこにたどり着けます。

7.3.2.3 例 AI を使ったフルスタックフロー

説明のため、あなたが単純な連絡先マネージャーのウェブアプリを構築しているとしましょう。

あなたは、本章で前に行ったように、 React フロントエンド、 Node.js/Express バックエンド をスキャフォールディングします。

まず、 フロントエンドでは、 ContactList ContactFormコンポーネントをプロンプトで指示 してください。 次に、 API呼び出しを追加するようにプロンプトで指示してください。

ContactList では、マウント時に/api/contactsから連絡先を取得して。 ContactFormでは、成功時に/api/contactsにフォームデータとともにPOSTを送信し、連絡先 リストを更新して。

バックエンドでは、 あなたはインメモリ配列を使いたいか、あるいは、先にデータベースを統合 したいでしょう。次に、 (リストを返す) GET /api/contacts と(データベースやメモリにコン タクトを追加する) POST /api/contactsのExpressルートをプロンプトで指示します。

・UIで連絡先を追加してみます。 リストに表示されたら、 上出来です。 表示されないなら、デバッ グしてください。 もしかしたらPOSTルートが新しい連絡先を正しく返さなかったか、 フォーム のコードがリストを再読み込みしなかったのかもしれません。 ギャップを特定し、 修正するよう にAIにプロンプトで指示してください。

連絡先を追加した後、 バックエンドはレスポンスで新しい連絡先オブジェクトを返し、フロント エンドはフルリロードなしで、 それをリストに追加するようにして。

これは、AIがバックエンドのレスポンスや (おそらく、 React ステートの更新を使って) 新しい 連絡先を送るためのフロントエンドのステートロジックを調整することにつながるでしょう。 ・同様に、編集と削除の関数も実装してください。 その都度、AIに定型部分を対処させて、「その 機能が何をすべきか」 についてのあなたの入力に集中してください。

これをすべて手動で行うと、 ジュニア開発者にとって1、2週間の作業になりかねませんが、AI コード開発者なら、テンプレートコードや配線の多くが自動化されているため、1日か2日で終わら せることができるでしょう。

7.3.2.4 フルスタック開発におけるAIと人の協働の最適化

スタック全体を通して作業する際、 AIアシスタントと生産的なリズムを確立することが有益です。 協働を最適化するための戦略をいくつか紹介しましょう。

138 | 7章 AIでウェブアプリケーションを構築する

ボイラープレートにAIを使い、 カスタムロジックを自分で書く

コードのどの部分がありふれたもので、 どの部分が独自の中心的ロジックなのかを特定してくだ さい。 CRUD APIや標準コンポーネントをAIに生成させてください。 しかし、 (プロプライエ タリなアルゴリズム、 直接実装する方が簡単な特定のビジネス規則といった) 特に扱いにくいロ ジックがあるなら、 その部分を手動で行い、 AIにレビューやテストを頼んでください。 AIに繰 り返しのタスクを委ねて、 あなたは新しいタスクに対処すると考えてください。

AIを使って、やることリストに1つずつ取り組む

開発中は、追加すべき機能、 修正すべきバグといった) タスクを把握ください。 そして、各タ スクを1つずつAIに説明し、 解決策を提案させてください。 例えば、 「ユーザー登録時のパス ワードのハッシュ化を実装する」 というメモがあったとします。 次のようなプロンプトを試して ください。

ユーザーを保存する前に、 POST /api/register ルートでbcrypt を使ったパスワードのハッシュ 文化を追加して。

こういった的を絞った体系的なアプローチは、何も見落とさないようにするのに役立ちます。

AIにプロンプトで指示して、 コード品質を向上させる

機能を達成したら、 「読みやすくするために、このコードをリファクタリングして」 や 「この関数 を最適化して」 とプロンプトで指示することがあります。 多くの場合、 AIは、 あなたの監督の下 で2回目の推敲をするアシスタントのように、コードをよりクリーンにしたり、パフォーマンス 改善を提案したりできます。 変更が加えられても、引き続きテストを通過することを必ず確認し てください。

AI を使って、 再確認を行う

設計アプローチに不明点があれば、AIに聞いてください。

連絡先をメモリに保存するために配列を使うことは問題ない? それとも、データベースを使うべ き? 長所と短所は?

あなたは (永続性のためにデータベースを使うという) 回答を知っている可能性が高いですが、 これは同僚にアイデアをぶつけるようなものです。 時には、AIが、 あなたが思いもつかなかっ たような考慮事項を述べることもあります。

複数のサーバーインスタンスがある場合、 インメモリストアはそれらの間で同期されません。

AI を使って、 あなたのチームと調整する

あなたがチームで作業しているなら、全員がAIを直接使っているとは限りません。 その場合、 あなたがやったことを記録するように、AIに頼むようにしてください。 また、 あなたのアプロー

7.4 AI 生成ウェブアプリケーションのテストと妥当性確認 | 139

チをチームに伝えるのもいいでしょう。 「私はAIを使って、これらのコントローラーを素早く生 成しました。 私は確認しましたが、 慣例に従わないパターンがないか目を光らせておいてくださ い。」 コードレビューの文化を奨励してください。 そこでは、全員が、 AIが書いたコードを他の コードと同じようにレビューし、 癖を見つけます。

(Snyk (https://oreil.ly/8Dmn7) のチームのような) 実世界でAIを導入しているチームは、 AI が生産性を高められると報告していますが、 妥当性確認のためにヒューマンインザループを維持す ることも強調しています。 GitHubによる2024年の調査 (https://oreil.ly/oivAx) では、開発者の 97%が何らかの形で職場でAIコーディングツールを使っていると報告しています。

7.4 AI生成ウェブアプリケーションのテストと妥当性確認

AIの助けを借りてウェブアプリを構築したら、 徹底的にテストして、すべてが意図した通りに動 作することを確認し、あなたやAIが導入した可能性のある問題を見つけてください。 ここでは、AI が支援するこの状況で、 どのようにテストに取り組めばよいかを説明します。

単体テスト

バックエンドのロジックでは、(何かの計算や入力の検証を行う関数など) 重要な関数の単体テ ストを書いてください。 AIがその関数を書いたのなら、テストを書くことで隠れたバグを見つ けられます。 前述のように、 AIにテストを生成させることもできます。 ただし慎重にしてくだ さい。 AIが生成するテストは普通のものだったり、 実装を想定したものだったりすることがあ るので、あなたは、エッジケースをテストするように導く必要があるかもしれません。

空のパスワード、非常に長いパスワード、 特殊文字を含むパスワードといったエッジケースを含む、 パスワード強度関数のテストを書いて。

統合テスト

(Node.js用の) Supertestや直接のHTTP呼び出しなどで、 APIエンドポイントをテストして ください。 各エンドポイントが期待通りの結果を返すか、確認してください。 AIは、これらの スキャフォールディングを助けてくれます。

Jest と Supertest を使って、 /api/to-dos エンドポイントの統合テストを書いて。

AIは、アプリを開始し、 エンドポイントにアクセスし、レスポンスに対してアサートするテスト を生成するでしょう。

フロントエンドテスト

(コンポーネントロジック用の) Jest、 (エンドツーエンドUIテスト用の) Cypressや Playwright といったツールを使って、 ウェブUIテストを行えます。 あなたは、 Cypressのテ ストシナリオを生成するように、 AIに頼めます。

140 | 7章 AIでウェブアプリケーションを構築する

アプリをロードし、 フォームで新しいTo-Doを追加し、それがリストに表示されることを確認す Cypressテストを書いて。

あなたは、テストを実行できるテストスクリプトを手に入れるでしょう。 これはかなり強力で す。 あなたは、AIを活用してユーザー対話をスクリプト化することで、エンドツーエンドのテ ストカバレッジを素早く達成しています。

手動テスト

どのような自動テストを実行するにしても、 常に手動の探索的テストも行ってください。 自分 でウェブアプリをクリックして回ってください (あるいは、 チームで作業しているなら、 QAに やってもらってください)。 AIは、 実世界のあらゆるシナリオを想定していないことがありま す。 例えば、ブラウザーの「戻る」ボタンを使うと何らかのステートを壊すかもしれませんし、 特定の順序のアクションが不具合を引き起こすかもしれません。 あなたがバグを見つけたら、 それを修正するか、 AIに修正を頼んでください。 手動テストは、 UI/UXの判断においても重要 です。 アプリは、 使っていて心地よいと感じられますか? 使いづらいフローはないですか? AI はこのような主観的なUXの問題を判断する方法を知らないので、 人のフィードバックが重要に なります。

コードレビュー

もし他の人と一緒に仕事をしているなら、 彼らにAIが生成したコードをレビューしてもらって ください。 新しい視点なら、 あなたが見過ごしていたかもしれないものを見つけられます。 彼ら はセキュリティ上の見落としを見つけたり、 より慣用的な書き方を提案したりすることがありま す。 AIを使用するチームは、 通常のコードレビュープロセスを維持することが多いですが、 AI がうっかり持ち込むかもしれない微妙なバグやセキュリティの問題のレビューに重点を置いて います (https://oreil.ly/05Dbj)。

セキュリティ監査

「8章 セキュリティ、 保守性、信頼性」ではセキュリティについて掘り下げますが、開発時で あっても、既知の脆弱性パターンがないかコードをスキャンする価値はあります。リンターや静 的アプリケーションセキュリティテスト (https://oreil.ly/T531z) (SAST) ツールといった自 動ツールを実行できますし、次のようにAIにプロンプトで指示もできます。

Expressアプリのコードをレビューし、 潜在的なセキュリティ脆弱性やベストプラクティス違反 をリストして。

AIは「ここはユーザー入力をサニタイズしていません」 や 「CORSを適切にセットアップすべき です」といった、驚くべき警告を与えることがあります。 それをアプリを強化するためのチェッ クリストとして使ってください。

7.5 AI が構築したウェブプロジェクトの成功例 | 141

AIを使うことの興味深い効果の1つは、 AIが非常に簡単にテストを作成してくれるため、あなた が他の方法では書かなかったようなテストを書くことです。 これは最終的に、「より」 堅牢なコード につながる可能性があります。 機能を生成した直後にテストを生成するプラクティス (基本的には、 AI支援のテスト駆動開発 (TDD) か、 少なくとも事後テスト) を採用すれば、素早い開発によって品 質が損なわれることがなくなります。 次のように考えてください。 AIがコードを書く時間を節約し てくれたので、その節約した時間の一部をテストを書いて実行することに投資してください。

ユーザーが注意深くなければ、 AIは安全でないコードを提案する可能性があります。 例えば、 旧 バージョンのAIは、それを避けるように特にプロンプトで指示されなければ、 インジェクション 攻撃に対して脆弱なSQLクエリを生成することがあります。 テストとレビューを行うことで、こう いった問題を見つけられます。 ある研究 (https://oreil.ly/U3b8H) では、AIの支援を使っている 開発者は、 AI支援のコードのセキュリティが手動作成した場合よりも悪い場合でも、そのコードを 過信する傾向があることがわかりました。

AIがコードを書いたからといって、決して妥当性確認を省略しないでください。 人が書いたコー ドと同じように、バグがある可能性があることを想定してください。

7.5 AI が構築したウェブプロジェクトの成功例

(さまざまなレポートから抜粋した) 実際のウェブアプリケーションを提供する上でAIの支援が重 要な役割を果たした例を、いくつか取り上げてみましょう。

1人の開発者によるECサイト

ある1人の開発者は、カスタムのTシャツを販売する小さなECウェブアプリを作成したかった のですが、 時間が限られていました。 彼はIDEの拡張機能を通してGPTを使い、スタック全体 を構築しました。 彼は、 商品リスト、 カート、チェックアウトページを持つReact フロントエン ド、商品と注文用のエンドポイントを持つNode.js バックエンドを生成するように、AIにプロ ンプトで指示しました。 彼は決済にStripeを使い、AIにStripeのAPIについて助けてもらうこ とで、それを統合しました。 2週間、 夜間に作業した後、彼は機能するサイトを手に入れました。 この開発者は、特に繰り返しのUI部分やフォーム処理など、コーディングのおそらく70%を Al が行い、 自分は Stripeを正しく構成し、ブランディングのためにUIを微調整することに集中し たと報告しました。 最終的に、 主にバイブコーディングを通して構築されたシステムの中で、 顧 客は商品を閲覧し、カートに入れ、 購入することができるようになりました。 また、 モデルが頼 るドキュメントが利用可能になっているか、あるいはあなたがそれを提供すれば、 (Stripe など の) 外部サービスの統合はAIの指導によって実現可能であることも、浮き彫りになりました。

社内ダッシュボード

多少のコーディングスキルを持つプロダクトマネージャーは、AIペアプログラマーを使って チーム向けの社内分析ダッシュボードを作成しました。 通常ならエンジニアリングリソースを待

142 | 7章 AIでウェブアプリケーションを構築する

つ必要がありましたが、ウェブプロジェクトで ReplitのGhostwriter, GitHub Copilot といっ たツールを使うことで、彼女は基本的なウェブアプリを自分で構築できました。 AIは、 (安全 な読み取り専用の認証情報を使って) データベースのクエリを行う単純なFlaskバックエンド、 (チャートライブラリを使って) グラフを表示する Vue.js フロントエンドのセットアップを支援 しました。 彼女はそれぞれのグラフが表示すべきもの (「時系列の合計登録数」、 「地域別のアク ティブユーザー数｣) を説明し、 AIがSQLクエリとグラフのコードを書きました。 プロセス全体では、微調整とテストに数週間を要しましたが、 彼女は最終的に動作するダッシュ ボードを提供しました。 コード品質は企業向けではありませんでしたが、 社内向けだったので 問題ありませんでした。 さらに重要なのは、彼女がほんのわずかな時間で、 ツールを使ってチー ムを強化したことです。 この例は、 AIツールがどのようにして非専門家のプログラマーによる 有用なウェブアプリの作成を可能にし、そうでなければバックログに滞留していたかもしれない タスクから障害物を取り除したことを示しています。 これは、 「10章 自律型バックグラウンド コーディングエージェント」で説明する 「プログラマーの分離」の一例です。 これは、個人が、

個人やチーム固有のソフトウェアをより簡単に作成できるようになったことを意味します。

スタートアップの実用最小限のプロダクト (MVP)

(共同創業者2名、 ビジネス系1名、 技術系1名の) 小さなスタートアップは、 投資家に見せるた めのMVP ウェブアプリケーションを必要としていました。 技術系の共同創業者は、 バイブコー ディングを多用し、記録的な速さでMVPを構築しました。 彼はAIアシスタントを使い、 SSR React フロントエンド用のNext.js、 単純な Node.js APIを使った最新のウェブアプリのスキャ フォールディングを行いました。 彼はAIを活用して、ソーシャルログイン機能 (AIがOAuth フ ローを書きました)、 画像アップロード機能 (AIがクラウドストレージAPIと統合しました)、 プ ロダクト自体のAIベースの機能などを実装しました。 さらに、 AI を使って、 APIから NLP (自 然言語処理) モデルを統合しました。 通常なら小規模チームが4~6か月かかることを、1人の 開発者が数ヶ月で達成したのです。 その結果、やや場当たり的ですがデモできる機能的なプロ ダクトができ上がり、 ベータユーザーをプラットフォームに迎え入れることもできました。 後に共同設立者がプロダクトを改良するためにさらに開発者を雇った時、新しい開発者たちは、 スケーラビリティのためにかなりの部分をリファクタリングしたものの、 AIが書いたコードが ほぼ理解できることに気付きました。 これは、AIはあなたを最初の段階まで素早く連れていき

ますが、次の段階に進むにつれて、 あなたは品質に投資する必要があることを強調しています。

こういった話は逸話的ですが、 業界の新たなパターンと合っています。 特にウェブ開発では多く の場合、多くのコンポーネントをまとめて配線するため、 生産性向上は非常に明白です。 Microsoft (https://oreil.ly/QLunu) や他のグループ (https://oreil.ly/BNVrB) は、 AIを導入した開発者 は、そうでない開発者より大幅に速くタスクを完了できることを発見した研究結果を報告しています。 しかし、注意すべき話もあります。 例えば、 開発者がコードを完全に理解していないために、セ

7.6 まとめと次の一歩 |

キュリティ上の欠陥があるAIが生成したウェブアプリをデプロイしてしまうことがあります。 この リスクは、テストとレビューがいかに重要であるかを裏付けています。

結論として、 AI支援のウェブアプリケーション構築は、主流になりつつあります。 それは、経 験豊富な開発者の必要性を除去するものではなく、むしろ彼らを強化するものです。 開発者は、引 き続きアーキテクチャを計画し、 正しさを保証し、コードの複雑な部分や斬新な部分に対処します。 一方、 AIは、 すべてをつなぐ繰り返しのボイラープレートコードに対処します。 スキャフォール ディングからフロントエンド、 バックエンド、 テストまで、 我々が順を追って確認したエンドツーエ ンドのワークフローは、あなたが人の判断と専門知識を適用する限り、 ウェブ開発のほとんどすべて の手順をAIで加速できることを示しています。

7.6 まとめと次の一歩

本章では、バイブコーディングが本格的なウェブアプリケーション開発にどのように拡張されるか を見てきました。 AIを常に利用可能なペアプログラマーとして扱うことで、フロントエンド、バッ クエンドのタスクに並行して取り組み、 自然言語の説明からコンポーネントやAPIを生成し、 プロト タイプアプリケーションを本番品質まで反復的に改良できます。 成功の鍵は、 (AIが、各手順であな たが何を望んでいるかを知ることができるように) あなたの意図を明確に伝えること、 (AI の出力の 問題点を見つけるために) 慎重に検証すること、そして、コード生成だけでなく、スキーマ設計のブ レインストーミングやテストの作成などにAIを活用することです。

また、本章では、AIが開発者があまり詳しくない分野のコードを提案して、 開発者の知識の ギャップを埋めることで、開発者を効果的にフルスタックエンジニアにする方法も探りました。 これ によって、 一般的な機能の開発時間が大幅に短縮され、 開発はある種の民主化を遂げ、 大規模チー ムなしでもカスタムのウェブベースの解決策を作成できるようになります(このテーマは、10章で再 び取り上げます)。

AIは、要件の理解や品質の確保に取って代わるものではなく、 実行を加速させるものです。

さて、ウェブアプリケーションが稼働し始めたら、次に気になるのは、セキュリティ、信頼性、保 守性を確保することです。 「8章 セキュリティ、 保守性、信頼性」では、AIによって生成された コードベースでのセキュリティ、 信頼性の課題を掘り下げ、潜り込んでくる可能性のある一般的な脆 弱性の特定、 それを監査して修正する方法、(本章で、テストやレビューで適用し始めたような) AI で素早く開発してもシステムを壊さないようにするためのベストプラクティスを紹介します。 基本的 には、構築から強化へと移行し、 バイブコーディングされたソフトウェアが実世界の条件や脅威に 耐えられるようにします。

143



Ⅲ部 信頼と自律性



| 147

8章

セキュリティ、 保守性、信頼性

本章では、 バイブコーディングとAI支援エンジニアリングの重要な側面、つまり、AIの支援を受 けて作成したコードを安全で、信頼性が高く、 保守可能にすることに立ち向かいます。 出来上がっ たソフトウェアが脆弱性だらけだったり、 クラッシュしやすかったりするなら、速度や生産性にほと んど意味はありません。

まず、インジェクションの脆弱性から機密漏洩まで、 AIが生成したコードに生じる一般的なセ キュリティの落とし穴を検討します。 AIが書いたコードにこういった問題がないか監査、 レビュー するテクニックを学び、 AI ペアプログラマー用のセキュリティの安全網として効果的に機能させま す。

次に、バグや信頼性の問題をすぐに見つけるために、AIが生成したコードに効果的なテストと QAのフレームワークを構築することについて議論します。 パフォーマンスに関する考慮事項も扱い ます。 AIは正しいコードを書くかもしれませんが、それは必ずしも最も効率的なコードとは限りま せん。 パフォーマンスのボトルネックを特定して最適化する方法について、概説します。 また、 AI の提案は一貫していなかったり、過度に冗長だったりすることがあるため、一貫したスタイルの強制 やAIコードのリファクタリングといった、 保守性を確保するための戦略も探ります。

AI支援ワークフローにコードレビューのプラクティスを適応させる方法を紹介し、部分的または 全体的にAIが生成したコードをレビューする際に、人のレビュアーが何を重視すべきかを強調しま す。 最後に、継続的インテグレーション (CI) パイプラインから本番環境での監視まで、 自信を持っ てAI支援プロジェクトをデプロイするためのベストプラクティスをまとめます。 本章が終わる頃に は、 あなたは、AI駆動開発を安全かつ堅牢に保つためのツールキットを手に入れるでしょう。

8.1 AI が生成するコードに共通するセキュリティ脆弱性

AIコーディングアシスタントは強力ですが、 適切に導かれなければ、うっかりセキュリティ問題 を引き起こす可能性があります。 AIは多くの公開コードから学習しますが、その中には優れたプラ クティス、 悪いプラクティスの両方が含まれています。 AIは、 プロンプトやコンテキストによって 導かれないと、 安全でないパターンを再利用することがあります。 こういったよくある落とし穴を知

148 | 8章 セキュリティ、 保守性、信頼性

それを見つけて修正できるようにすることが重要です。 これには、 潜在的なセキュリティ問題を 検出するために、 手動、 自動の両方の手段を使うことが含まれます (図8-1 を参照)。

AIがコードを生成 セキュリティ スキャナー セキュリティ上の欠陥

図8-1 AIが持ち込んだセキュリティ脆弱性。 AIが生成したコードには微妙なセキュリティ上の欠陥が含まれているこ とがあり、それを特定して修正するためには、慎重なレビューと自動化されたセキュリティスキャンが必要とな る。

AIが生成したコードに見られる典型的なセキュリティ問題には、次のようなものがあります。

ハードコードされた秘密や認証情報

AIは、 APIキー、パスワード、トークンをコードに出力することがあります。 特に、 トレーニン グデータに類似した例が含まれていた場合はなおさらです。 例えば、 AWS と統合するようにAI に頼むと、AIはダミーのAWSシークレットキーをコードに直接入れることがあります。 そのま ま残しておくと危険です。 コードが共有された場合、 機密情報が漏れる可能性があります。 常 に、シークレットが環境変数や設定ファイルで適切に管理されているようにしてください。 AI がapi_key = "ABC123SECRET" といったことを提案したら、 それをフラグとして扱ってくださ い。 実際のキーをソースコードに書くべきではありません。

SQLインジェクションの脆弱性

AIモデルにSQLクエリやORMの使用を生成させる場合、ユーザー入力を直接連結してクエリ を構築していないことを確認してください。 例えば、安全でないパターンは次のようなものです。

sql = "SELECT * FROM users WHERE name= + username + "'";

これはインジェクション攻撃を受けやすいものです。 あなたがクエリをパラメーター化するよ うにAIに特に指示しなければ、 AIはこれを生成することがあります。 必ず、プリペアドステー トメントかパラメーターバインディングを使ってください。 多くのAIアシスタントは、(SQLで ユーザーのプレースホルダー入力に? を使うといった) ベストプラクティスを思い出せば、そう しますが、それは保証されているわけではありません。 確認して、必要ならAIに修正を頼むの は、あなた自身です。

IN

8.1 AI が生成するコードに共通するセキュリティ脆弱性 | 149

SQLインジェクションを避けるため、このクエリを修正して、パラメーターを使って

ウェブアプリでのクロスサイトスクリプティング (XSS)

AIツールは、 ウェブのコードを生成する際、 出力でユーザー入力を自動的にエスケープすると は限りません。 例えば、あなたのAIは、 {{comment.text}}をエスケープせずに直接HTMLに 挿入するテンプレート化スニペットを生成することがあります。 これによって、 コメント内に置 かれた悪意のあるスクリプトが動作する可能性があります。 フレームワークを使っているなら、 多くの場合、 AIはデフォルトでエスケープしますが、 生のHTMLを処理している場合、 注意し てください。 出力エンコーディングやサニタイズルーチンを実装してください。 次のように、AI にプロンプトで指示できます。

XSSを避けるため、 ユーザー入力にサニタイズを追加して。

最新のフレームワークの多くには組み込みメカニズムがあるので、 AIがそれらを使うよう にしてください。 例えば、 ドキュメントオブジェクトモデル (DOM) 操作 (https://oreil. ly/5o_2x) においては、 innerHTMLではなくinnerTextを使うようにしてください。

不適切な認証認可

AIは認証フローを書けますが、 微妙な間違いが忍び込むことがあります。 例えば、十分に強力 なシークレットなしでJSON ウェブトークン (JWT) (https://oreil.ly/rf7JL) を生成したり、 パスワードハッシュを正しく確認していなかったりします。

認可についても、 同じことが言えます。 AIは、リソースの削除といった) あるアクションがそ のリソースを所有するユーザーに限定されるように、 自動的に強制しないことがあります。 こう いったロジックの問題を自動的に見つけるのは、難しいものです。 セキュリティモデルを通して

考える必要があります。 こういったコードを書く時は、次のように明確に指定してください。 リソースの所有者だけが、 そのリソースを削除できるようにして。 ユーザーIDの確認を追加して、

そして、こういった条件をテストしてください。 AIは、言われない限りコンテキストを本当に 「理解」することはないので、 AIは簡単に確認を省略します。

安全でないデフォルトや構成

AIは、プロンプトでそうしないように指示されない限り、 セキュリティよりも利便性を選ぶこ とがあります。 例えば、次のようなものがあります。

• (TLSが指定されていない場合) API呼び出しに、 HTTPSではなくHTTPを使う SSL証明書を検証しない (リクエストでverify=falseを使っているインターネット上の コピーすることがある)

コード例があり、 AIがそれを

• すべてのオリジンとメソッドに対して、 CORSを制限なく広く有効にする(これは、あらゆ るクロスオリジンリクエストに、アプリを開放してしまう可能性がある)

150 | 8章 セキュリティ、 保守性、信頼性

時代遅れの暗号を選ぶ (パスワード用のSHA-256、 Berypt, Argon2ではなく、 ハッシュ用の 弱いMD5、SHA1を選ぶ)

多くの場合、 こういった問題は微妙であり、 それが、 構成ファイルや初期化コードを監査する のが良い理由の1つです。 AIがapp.UseCors (allowAll) といったセットアップをしたり、 古い 暗号を選んだりしたら、 あなたはそれを見つけて修正すべきです。

機密情報が漏れるエラー処理

AIが生成したエラー処理は、 スタックトレースを出力したり返したりすることがあります。 例 えば、Node.js APIがエラーを捕捉して、 res.send(err.toString()) を行うことがあり、こ れによって、内部の詳細が漏れる可能性があります。 ユーザーへのエラーメッセージがサニタ イズされ、ログが適切に処理されるようにしてください。 完全なエラーメッセージやファイルバ スといった手がかりを攻撃者に与えないように、必要に応じて調整してください。

依存関係の管理と更新

AIが (ライブラリなどの) 依存関係をプロジェクトに追加する場合、 それらが最新で、 信頼でき るソースからであるようにしてください。 AIは、 トレーニングデータで人気だったライブラリ を選ぶことがありますが、そういったライブラリがもはや保守されていなかったり、 既知の脆弱 性があったりします。 例えば、 AIがパッケージの旧バージョンの使用を提案したら、 あなたが 最新の安定バージョンに更新すべきです。 生成後に、 npm audit やそれに相当するものを実行 するのも賢明です。 あるいは、次のようにAIに尋ねてください。

このライブラリはまだ保守されていて、安全ですか?

AIは完全には知らないかもしれませんが、 既知の非推奨があれば教えてくれる可能性がありま す。

2023年に実世界のプロジェクトでのGitHub Copilot を大規模に分析したところ、 言語によって 異なりますが、生成されたコードの25~33%に、 コマンドインジェクション、コードインジェク ション、クロスサイトスクリプティング (https://arxiv.org/abs/2310.02059) といった深刻度の 高いCWEを含む、潜在的なセキュリティ上の弱点が含まれていることが明らかになりました。 こ れらの発見は、 GitHub Copilot が意図的に欠陥のあるコードを生成するのではなく、トレーニング データに存在する安全でないパターンを反映していることを示しています。 一貫した推奨事項とは 何でしょうか? 開発者は常に警戒を怠ってはなりません。 AIが生成したコードを手動でレビューし、 セキュリティを意識したツールを使い、コードの衛生管理を徹底してください。 特に「バイブコー ディング」 中は、AIが生成する内容の速度と範囲によって、より一層の警戒が求められます。 より短 時間でより多くのコードを作成することは、より多くの監査対象を意味します。

*1 訳注:CWE (Common Weakness Enumeration) は、 脆弱性の原因となる弱点を体系的に整理した一覧です。 個別の 性のためのCVE (Common Vulnerabilities and Exposures) とは異なります。

8.1 AIが生成するコードに共通するセキュリティ脆弱性 |

簡単な例を見てみましょう。

8.1.1 不適切な認証認可

Express アプリでログインルートを作成するように、 AIに頼んだとしましょう。次のようなもの が生成されることがあります。

// 安全でない例 app.post('/login', async (req, res) => { const { username, password } = req.body; const user = await Users.findOne({ username: username }); if (!user) return res.status (401).send("ユーザーが見つかりません"); if (user.password === password) { // 平文のパスワード比較 res.send("ログインに成功しました!"); } else { } }); res.status (401).send("パスワードが正しくありません");

ここで、 何が問題でしょうか?

パスワードを直接比較している。 これは、パスワードがデータベースに平文で格納されている ことを示唆している。

非常に一般的なレスポンスを送信している。これはセキュリティ上適切かもしれませんが、うっ かり機密情報を公開してしまう可能性もある。

重要な例として、 認証エラーメッセージを考えてみましょう。 安全なシステムは、ログインに失敗 した時、ユーザー名、パスワードのどちらが間違っているかに関係なく、 「認証情報が無効です」と いった汎用メッセージを返すべきです。 しかし、 AIが生成したコードは、 「ユーザー名が見つかりま せん」 や 「このユーザーのパスワードが正しくありません」といった、より具体的なエラーを出すこ とがあります。

こういった特定のメッセージは、潜在的な攻撃者が彼らが持つどの情報が正しいかを確認できる ようにすることで、 セキュリティ脆弱性を生みます。 攻撃者がエラーとして「パスワードが正しくあ りません」 を受け取ったら、 彼らはあなたのシステムで有効なユーザー名を見つけたことになります。 これによって、 彼らは、試行錯誤を繰り返しながら正当なユーザー名のリストを作成し、 確認された アカウントのパスワードをクラックすることに全力を注げます。 「ユーザー列挙」 として知られるこ のテクニックは、 推測ゲームをより的を絞った攻撃に変えます。 セキュリティに関わる操作に対して 適切に曖昧なレスポンスを維持するように、あなたが明示的に指示しない限り、AIが親切で具体的 なエラーメッセージを出す傾向は、悪意のある攻撃者をうっかり助けてしまいます。

コードには示されていませんが、ここにはレート制限や他の保護機能は含まれていません。

151

152 | 8章 セキュリティ、 保守性、信頼性

安全な実装には、いくつかの重要なセーフガード (保護策) が組み込まれているはずです。

● 何よりもまず、 パスワードは決して平文で格納すべきではありません。 代わりに、 システムは暗 号学的にハッシュ化されたパスワードを格納し、 ログインの試行を検証するために安全な比較 関数を使用すべきです。

この比較プロセスは、タイミング攻撃を防ぐため、定数時間アルゴリズムを採用しなければなり ません。タイミング攻撃は、攻撃者がパスワードの正しさに関する情報を推測するために、 応 答時間を分析するものです。 多くのセキュリティに特化したライブラリは、この脆弱性に対処 するために、定数時間の比較関数を提供しています。

さらに、認証システムは、 ブルートフォース (総当たり) 攻撃を防ぐために、レート制限やスロッ トリング機構を実装すべきです。 失敗したログイン試行を、 セキュリティ監視のためにログに 記録し、管理者が不審なパターンを検出して対応できるようにすべきです。 こういった対策が 連携して多層防御アプローチを形成することで、1つのセキュリティ層が侵害されても、ユー ザー認証情報を保護します。

次のように、この問題を解決するようにAIに頼めます。

ログインルートを改善して、 bcrypt を使ってパスワードのハッシュ化、 比較を行って。 データ ベース内のパスワードがハッシュ化されるようにして。

AIは、次のように出力するでしょう。

const bcrypt = require('bcrypt');

app.post('/login', async (req, res) => { const { username, password } = req.body; const user = await Users.findOne({ username }); if (!user) { } return res.status (401).send("認証情報が無効です"); const match = await bcrypt.compare(password, user.passwordHash); if (!match) { } return res.status (401) .send("認証情報が無効です"); res.send("ログインに成功しました!"); });

こちらの方が良いでしょう。 これはbcryptを使って (変数user.passwordHash に格納されている と想定している) ハッシュ化されたパスワードと比較します。 ユーザーを作成する際にも、 bcrypt. hashを使ってパスワードをハッシュ化するようにしたいでしょう。

ちょっとした指導があればAIは正しいことをできますが、初期の素朴な出力は安全ではないこと

8.1 AI が生成するコードに共通するセキュリティ脆弱性 | 153

があります。 これは、 「レビューして改良する」パターンを明確に示しています。

8.1.2 パッケージ管理の問題

もう1つの一般的な脆弱性のカテゴリーは、 パッケージ管理です。 AIはライブラリを発明したり、 ライブラリ名を間違って覚えたりすることがあります。これは「パッケージのハルシネーション」 と して知られている問題です。 そういったパッケージは存在しないかもしれませんが、攻撃者は理論 上、悪意のあるコードを含むパッケージを、 よくハルシネーションされる名前で公開できます。 そう いったパッケージが存在しており、 正しいパッケージであることを確認せずにインストールすると、 深刻なリスクをもたらす可能性があります。 特定のパッケージについて確信が持てないなら、 素早く ウェブ検索するか、 npm/PyPIを直接確認してください。

さらに、AIは、トレーニングデータに含まれていたライセンスされたスニペットと同じコードを、 うっかり生成してしまうことがあります。 これはセキュリティの問題というよりは知的財産の問題で すが、 注意する必要があります。 例えば、 GitHub Copilotには重複検出機能があり、生成された コードが公開リポジトリと厳密に一致した場合にフラグを立てられます。 そのため、 開発者は潜在 的なライセンス競合を避けられます。 AIが生成したコードの起源という特定の課題に対処するため に、類似のツールが登場しつつあります。 「9章 バイブコーディングの倫理的課題」では、ライセ ンスと知的財産に関する考慮事項をより詳細に掘り下げ、こういった複雑な問題を切り抜けるための 包括的な指導を提供します。

つまり、 主なメッセージは変わりません。 そうです、 本書を通してこの点を何度も強調してきた ので、 おそらくあなたは眠りながらでも暗唱できるだろうと自覚しています。 「AIの出力には、ジュ ニア開発者のコードに適用するのと同じような、慎重なレビューが必要です」。 繰り返しは意図的な ものであり、この原則が安全で効果的なAI支援開発のほぼすべての側面を支えているからです。 プ ロトタイピング、バックエンド構築、 セキュリティ機能の実装のどれを行っていても、この考え方は、 AIを危険な近道ではなく強力な味方にするための、 信頼と検証との適切なバランスを提供します。 AIは大量のコードを素早く書けますが、 あなたはセキュリティのベストプラクティスをAIに浸透さ せ、脆弱性を再確認する必要があります。 小説家フランク・ハーバートは、 「God Emperor of Dune」 (Putnam, 1981年) *2からよく引用される行で (https://oreil.ly/yr2B_)、 このように表現してい ます。 「それらは、私たちが考えずに行えることの数を増やします。考えずに行うこと、そこにこそ 本当の危険があります。」

AIを使うことで、あなたは、定型コードについて考える量が減ってしまいがちです。 そのため、 あなたは、意識的にセキュリティレビューの考え方をどのように適用するかを考える必要があります。 こういった「考えずに行えること」を見つけるために、 これは極めて重要です。

2訳注: SF 小説のシリーズ 「デューン」の第4作。 日本語訳は 「デューン砂漠の神皇帝」 (早川書房)。

154 | 8章 セキュリティ、 保守性、信頼性

8.2 セキュリティ監査

概説した脆弱性の種類を考えると、 どのようにして、AIが生成したコードを効果的に監査して安 全にできますか? 本節では、あなたが使えるいくつかのテクニックとツールを紹介します。

8.2.1 自動セキュリティスキャナーを活用する

静的解析ツール (SAST) は、 既知の脆弱性パターンについて、 コードをスキャンできます。 例え ば、次のようなものがあります。

• ESLint + セキュリティプラグイン (https://oreil.ly/55ppH) は、 JavaScript、 Node.js コー ドの安全でない関数や、サニタイズされていない入力を検出できます。

• Python 用のBandit (https://bandit.readthedocs.io) は、 本番環境でのアサートの使用、 脆 弱な暗号、 ハードコードされたシークレットなどにフラグを立てられます。

• GitHub CodeQL (https://github.com/github/codeql) は、 コードベース全体にクエリを 実行し、SQLインジェクション、 XSS、他のよくあるパターンを見つけられます。

• Semgrep (https://semgrep.dev) には、JavaScript、 Python、Java、 Goなどのコミュニ ティで保守されている規則を含む、 多くの言語の規則があり、すぐに最大の問題を見つけられ ます。

こういったツールを、CI/CD や開発のパイプラインに統合できます。 こういったツールを、 AIが 生成したコードに対して実行してください。 すべてを見つけるわけではありませんが、おそらく (例 えば、平文のパスワードの確認、 サニタイズされていないSQL、 安全でない暗号といった) 明らか な間違いにフラグを立てるでしょう。 これは確かな安全です。

8.2.2 別のAIをレビュアーとして使う

生成されたコードのセキュリティレビューにAIを活用するには、 2つの異なるアプローチがあり、 それぞれに独自の利点があります。 1つ目は、コードを生成したのと同じAIモデルを使い、 視点を 切り替えて自身の出力を監査するように、そのモデルに頼む方法です。 コードを生成した後、 あな たは、次のようにモデルにプロンプトで指示できます。

セキュリティ脆弱性について、 このコードをレビューし、見つけた問題を説明して。

モデルは、 平文のパスワードの格納、入力検証の欠落、潜在的なSQLインジェクション脆弱性と いった、一般的なセキュリティの問題を特定できるため、多くの場合、このアプローチは驚くほど効 果的な結果をもたらします。

2つ目のアプローチでは、別のAIモデルを独立したレビュアーとして採用します。 例えば、 ChatGPTを使ってコードを生成したなら、セキュリティ分析のためにそのコードを Claudeや Geminiに貼り付けることがあります。 異なるセキュリティツールや人のレビュアーが、さまざまな

8.2 セキュリティ監査 | 155

専門知識や重点分野をもたらすのと同じように、このモデル横断的なレビューによって、異なる視点 を浮かび上がらせ、 元のモデルが見落としていたかもしれない問題を見つけられます。 異なるモデ ルは、異なる重点やデータセットでトレーニングされていることがあり、 異なるカテゴリーの脆弱性 を見つける可能性があります。

どちらのテクニックも、セキュリティレビューの貴重な追加層として機能します。 これらは、適切 なセキュリティテストと人の専門知識を補完するものであり、決してそれらに取って代わるものでは ありません。 AIレビュアーは、時には誤検出したり、 微妙な脆弱性を見逃したりすることがありま すが、 一般的なセキュリティのアンチパターンを素早く見つけることに優れています。 このプロセ スを、セキュリティの考慮事項に特化した自動ペアプログラミングと考えてください。 重要なのは、 AIが生成したセキュリティレビューを、 最終的な安全検査としてではなく、 セキュリティ評価プロ セスへのもう1つの入力として扱うことです。

8.2.3 セキュリティチェックリストを使って 人によるコードレビューを行う

あなたがチームに所属しているなら、 セキュリティを考慮したコードレビューを行うための、 チェックリストを用意してください。 多くの場合、 AIは期待されるケースに対して「動作する」コー ドを生成しますが、悪意のあるケースに対処するように強化されてはいません。 AIが生成したコー ドについては、次のことを必ず検討してください。

認証フロー: それらは堅牢ですか?

□データがシステムに入るあらゆる場所: 入力を検証していますか?

□データがシステムから出るあらゆる場所 出力をサニタイズしていますか? 機密データを保護 していますか?

外部API の使用 失敗に対処していますか? キーを公開していませんか? □データベースへのアクセス: ORMを安全に使っていますか? パラメーター化されたクエリを 使っていますか?

□低レベルコードのメモリ管理 AIがC/C++ や Rustを書いている場合、 オーバーフローはあり ませんか? 誤用はありませんか?

8.2.4 ベネトレーションテストとファジングを行う

動的なアプローチを使います。 ファズテストとして、 関数やエンドポイントにランダムな入力や特 別に作成した入力を送り込み、壊れたり奇妙な動きをしたりしないか確認してください。 AIはファ ズケースを生成するのに役立ちますし、GoogleのOSS Fuzz (https://oreil.ly/FvKSU) といった 既存のファズツール (https://oreil.ly/OoFzT) を使えます。

AIが作成したウェブアプリに対して、 OWASP ZAPのようなベネトレーション (侵入) テストツー

156 | 8章 セキュリティ、 保守性、信頼性

ルを実行すると、 XSSやSQLインジェクションの脆弱性などのスキャンを自動化できます。 例えば、 ZAPはスクリプトの注入を試みてそれを反映させたり、 特定の入力がサニタイズされていないこと を検出したりします。

あなたがAPIを構築しているなら、 Postmanのようなツールやカスタムスクリプトを使って不 正な形式のデータの送信を試みて、 システムがどのように動作するか確認できます。

8.2.5 セキュリティに焦点を当てた単体テストを追加する

コードの重要な部分に対して、 セキュリティ特性をアサートするテストを書いてくださ い。 例えば、ログインのレートリミッターがX回の失敗後に発動されることをテストしたり、 ("<script>alert(1) </script>" のような) 特定の入力がレスポンス内でエスケープされて出力さ れることをテストしたりすることです。 認可されていないユーザーが保護されたリソースにアクセス できないことをテストするには、 認可された呼び出し、 認可されていない呼び出しの両方をシミュ レートし、アプリが正しく動作することを確認してください。

あなたは、こういったテストの生成をAIに頼めます。

認可されていないユーザーが / deleteUser エンドポイントで403を得ることを確認するテストを 書いて。

そして、テストを実行してください。

8.2.6 トレーニングカットオフを補う更新を提供する

AIモデルには、セキュリティに直接影響する基本的な限界があります。 モデルの知識は、ある特 定の時点で固定されてしまいます。 モデルのトレーニングが完了すると、 その後に発見された脆弱 性、 その後にリリースされたセキュリティパッチ、 新たに出現したベストプラクティスについて学習 できなくなります。 このナレッジカットオフは、AIが知っていることと現在のセキュリティ基準との 間に重大なギャップを生み出します。

2023年にトレーニングされたモデルが、2025年にコードを生成するとしましょう。 その間に、数 多くのセキュリティ脆弱性が発見され、 バッチが適用され、 文書化されています。 新しい攻撃ベク トルが出現し、 フレームワークにセキュリティ機能が追加され、 ベストプラクティスが進化してきま した。 しかし、あなたがプロンプトで明示的に更新情報を提供しない限り、 AIはこういった進展に 気付かないままです。

この制限は、急速に進化するセキュリティ基準や脆弱性データベースで、 特に顕著になります。 例えば、 OWASPトップ10 (https://oreil.ly/US-uh) は、 変化する脅威の状況を反映するために、 定期更新されています。 あなたが 「安全なファイルアップロード関数を書いて」 とAIにプロンプトで 指示したら、 AIはトレーニングデータに基づいて、 (おそらく、 ファイルタイプの検証、サイズ制限、 ウェブルート外への保存といった) 合理的な保護を実装することがあります。 しかし、 最近発見され

8.2 セキュリティ監査 |

た攻撃ベクトルを見逃したり、 新たに推奨された緩和策を実装できなかったりする可能性がありま す。

解決策は、 AIの知識を現在のセキュリティ情報で積極的に補完することです。 セキュリティに関 わるコードを求める時は、プロンプトに現在のベストプラクティスへの参照を含めてください。 例え ば、あなたは、単に安全なコードを求めるのではなく、次のようにプロンプトで指示することがあり ます。

特にインジェクション攻撃とサーバーサイドリクエストフォージェリ (SSRF) に焦点を当てて、 2025年のOWASPトップ10のセキュリティの懸念事項に対処するファイルアップロード関数を 書いて。

このアプローチによって、 AIの応答が、 時代遅れの可能性があるトレーニングデータではなく、 現在のセキュリティ基準に基づくものになります。

同様に、 多くの場合、 フレームワーク固有のセキュリティ機能は、AIのトレーニングカットオフ 後に出現します。 例えば、 Expressアプリケーションは、セキュリティヘッダーを設定するための Helmet ミドルウェア (https://oreil.ly/WSPar) から大きな利点を得ています。 Helmet が標準プ ラクティスになる前にトレーニングされたAIは、この重要なセキュリティ層なしでExpress アプリ ケーションを生成することがあります。 あなたは、 プロンプトで現在のセキュリティのツールやプラ クティスに明示的に言及することで、 AIが過去ではなく現在のセキュリティ基準に沿ったコードを 生成するのを助けます。

8.2.7 ロギングの最適化

(AIと人による) コードが、 特に重要な操作や潜在的な障害点のまわりで、 適切なロギングを行う ようにしてください。 これは、本番環境での問題のデバッグに役立ちます。 AIが書いたコードのセ クションに最小限のログしかないなら、さらに追加することを検討してください。 例えば、AIが生 成したcatchブロックがただエラーを飲み込んでいるなら、可視化のためにエラー (そして、おそら くいくらかのコンテキスト) をログに記録するように、それを変更してください。 また、機密情報を 含まないように、ログをサニタイズしてください。

8.2.8 セキュリティに重点を置いた、更新されたモデルやツールを使う

コード生成と組み込みセキュリティスキャンの融合を目指す、 AIコーディングツールもありま す。 Snykはその代表例であり、 LLMが生成する提案とルールベースの汚染分析を組み合わせたハ イブリッドなアプローチ (https://oreil.ly/OZGFv) を採用しています。 Snykによれば、 (OpenAI、 Anthropic, Hugging Face のような LLMライブラリからであっても)あなたがコードを求めると、 Snyk Code は潜在的に安全でないデータフローを追跡し、信頼できない入力が機密シンクに到達す る前に、その入力にフラグを立てます。 実際には、AIがデータベースのクエリを提案したら、あな

157

158 | 8章 セキュリティ、 保守性、信頼性

た自身がそうすることを忘れたとしても、 Snykがそのクエリがパラメーター化されているようにし、 SQLインジェクションを防ぎます。 この種のツールは、 AIが生成する提案を通して安全でないコー ドが持ち込まれるのを回避するように動作するため、 特に有用です。

8.2.9 コンテキストにおける警告に注意を払う

あなたがIDEを使っていると、 多くの場合、 疑わしいコードを強調する警告や波線を目にします。 IntelliSenseを備えた最新のIDEでは、 例えば、 疑わしく見えるSQLの文字列連結を見つけられま す。 AIがコードを書いたからといって、こういった警告やフラグを無視しないでください。 問題に 対処してください。 AIは、 コードを生成する時に、こういったリアルタイムの警告の恩恵を受けら れません。

8.2.10 速度を落とす

AIを使って大量のコードを素早く生成した後、 監査の時間になったら、ギアチェンジして 「速度 を落としてください。 機能を素早く生成できるようになると、次の機能を追いかけたくなります が、徹底的なレビューのための時間をスケジュールしてください。 これを 「AI駆動開発、 人間駆動 「セキュリティ」と考えてください。 Snykのベストプラクティス (https://oreil.ly/uUExW) では、 IDE内でAIコードをスキャンすること、そして、 AIの速度があなたのセキュリティチェックを上回 らないように注意することを推奨しています。 言い換えれば、セキュリティスキャンを開発ループに 統合し、コードが書かれるとすぐに脆弱性を発見できるようにしてください。

まとめると、 AIが生成したコードを監査する際には、従来の開発で使っていたのと同じツール (静的解析、 動的テスト、 コードレビュー) の多くを使うことになります。 しかし、 コードがより素 早く生成されるため、こういったツールをより頻繁に適用することがあります。 「すべてのAI出力を、 検査が必要なものとして扱ってください」。

8.3 AI 生成システムのための 効果的なテストフレームワークの構築

セキュリティは信頼性 (reliability) を支える柱の1つにすぎませんが、 より広い概念としての信 頼性 (reliability) は、ソフトウェアシステムの基本的な信頼性 (dependability) を包含しています。 「信頼性」 (reliability) は、ソフトウェアアーキテクチャの用語で言えば、システム障害とその結果 に関する重要な問題に対処するものです。 あなたのシステムは、フェイルセーフである必要がありま すか? 人命や安全に影響するような、 ミッションクリティカルなものですか? システムに障害が発 生したら、 あなたの組織に大きな財務的損失をもたらしますか? これらを考慮することで、開発や テストのプラクティスに求められる厳密さが決まります。

AIの支援を受けて構築する場合でも、こうした信頼性の利害関係は変わりません。 AIの支援に よって生成された銀行アプリケーションは、トランザクションの正確性とデータの完全性に関して、

8.3 AI生成システムのための効果的なテストフレームワークの構築 | 159

完全に人によって書かれたものと同じ要件が課せられます。 医療システムは、コードの起源にかか わらず、患者の安全性に関する同一の基準を満たさなければなりません。 コード生成にAIが関与し ても、こういった基本的な信頼性の要件が軽減されることはありません。

この現実は、 AI 支援開発で包括的なテストがより重要になる理由を、 明確に示しています。 強力 なテストフレームワークは、コードが意図された機能を正しく実行し、 プロジェクトが進化してもそ の正しさを維持するようにします。 AIが生成したコードのテストは、人が書いたコードのテストと 同じ基本原則に従いますが、 AI開発プロセスに特有の違いや機会が生じるため、 特別な注意が必要 となります。

以下の節では、単にコードを生成するだけでなく、 (信頼性を検証し、 システムの安定性を維持し、 最もリスクが高い時にソフトウェアが正しく動作するという自信を与える) 堅牢なテストスイートを 作成する上で、 AIを活用する方法を探ります。

第一に、 早い段階から頻繁に自動テストを取り入れることです。 開発が遅い時には、機能をブッ シュしたいので、テストを書くのを省略してしまいがちです。 皮肉なことに、 (AIを使って開発が 「速い」 時は、 新機能がどんどん出てくるので、 「ここでも」テストを省略するのが簡単です。 しかし、 コードが素早く量産される時こそ、 後退や統合の問題を見つけるためのテストが最も必要な時なの です。 したがって、 AIの助けを借りて機能を実装したら、すぐにそのテストを書く (あるいは、AI を使ってテストを書く) 習慣を身につけてください。 こうすることで、機能を検証し、後で変更する 際に機能を守ることができます。

2022年の調査 (https://oreil.ly/Vc8Gd) では、 AIアシスタントを使っている開発者は、AIアシ スタントを使っていない開発者が書いたコードより客観的に安全でない場合でさえ、 自分が書いた コードのセキュリティにより自信を持っていることが発見されました。 あなたは、 実際のテストでそ の過信を打ち消す必要があります。

「4章 70%を超えて人の貢献を最大化する」 で述べたように、 AIを使って、 コードを生成す るだけでなく、 テストスイートも作成できます。こうすることで、 AIは自分自身を再確認できます。 これは、実装、 最初の妥当性確認の両方をAIにやらせるようなものです。 例えば、 新しいモジュー ルを書いた後、 あなたは次のように尋ねることができます。

エッジケースをカバーした、 このモジュールの単体テストを書いて。

テストに成功したら、素晴らしいことです。 テストに失敗したら、バグがあるか、あるいは、 テス トが何か別の結果を想定しています。 調査して、必要に応じてコードかテストを修正してください。

AIが、 ある出力や振る舞いを間違って想定している可能性があることに、注意してください。 AI のテストも、AIコードと同様に、グラウンドトゥルース (絶対的な正解) ではなく提案として扱って ください。 意図した振る舞いに合わせるために、テストの期待値を調整する必要があるかもしれま せん。 しかし、あなたは意図した振る舞いを明確に定義することを強いられるので、 このプロセスで さえも価値があります。

160 | 8章 セキュリティ、 保守性、信頼性

テストスイートを、 (コミットごとに実行される) CIパイプラインに組み込んでください。 こうす れば、AIが生成したコードが追加、変更されるたびに、 すべてのテストが自動的に実行されます。 何かが壊れたら、それをすぐに見つけられます。 AIが (関数のシグネチャや出力形式を少し変更す るといった) 微妙な破壊的変更を加えることがありますが、 堅牢なテストスイートはそれを検出し ます。 新たに持ち込まれた危険なパターンにフラグを立てられるように、 (npm audit、 静的解析と いった) セキュリティスキャンもCIに含めてください。 試すべきテストの種類には、次のものがあり ます。

プロパティベーステストとファジング

(Python Hypothesis (https://oreil.ly/JcYBf). JavaScript fast-check (https:// fast-check.dev) といったツールを使った) プロパティベーステスト (PBT) も、価値あるテク ニックです。 特定の入力と期待される出力で個別のテストケースを定義する代わりに、 コードが 常に満たすべき高レベルのプロパティを定義します。 そしてフレームワークが、それらのプロパ ティが維持されているかどうかを確認するために、幅広い入力を生成します。

ソートを例にとってみましょう。 sort([3, 1, 2]) === [1, 2, 3] とアサートするのではなく、 次のプロパティを定義できます。

・出力は、順になっているべきです。

出力は、入力と同じ要素を含むべきです。

ツールは、こういった条件をテストするために数十、 数百の入力配列を生成し、 手動では思い つかないようなエッジケースを見つけます。

これは、AIが生成したコードで特に役立ちます。 AIが、電子メールアドレスのドメインを小 文字にするといった) 正規化を行う関数を書いたら、 プロパティテストが、出力が 「べき等」 で あることを確認することがあります。 べき等とは、関数を2回実行しても、 1回実行したのと同 じ結果になるということです。 エッジケースがその不変条件に違反したら、 テストフレームワー クは反例を生成し、 あなたはそれをバグの診断に役立てます。

負荷テストとパフォーマンステスト

AIは、最適化されていないコードを書くことがあります。 負荷をかけた状態でテストするのは、

良いアイデアです。 これは、パフォーマンス面での信頼性です。 JMeter Locust, k6 といっ たツールを使って、 多くのリクエストや重いデータをシミュレートし、 システムが持ちこたえる かどうかを確認してください。 持ちこたえなかったら、 ボトルネックを特定してください。 例えば、AIが素朴なO (n2) アルゴリズムを書き、 それが100個の項目では問題なく動作します が 10,000個では破綻するとしましょう。 パフォーマンステストがなければ、本番環境になる まで問題に気付かないかもしれません。 そのため、妥当なら、 パフォーマンスシナリオをいくつ か組み込んでください。 入力サイズを大きくして、 重要な操作の時間を計ったり、プロファイリ ングツールを使って、 重いタスクでCPU時間やメモリがどうなるかを確認してください。

エラー処理

8.3 AI 生成システムのための効果的なテストフレームワークの構築 | 161

システムが正常に応答するようにするため、次のように、意図的にエラーを引き起こしてくださ い。

• APIでは、データベースをシャットダウンし、 APIがわかりやすいエラーを返すか、 クラッ シュするかを確認してください。 クラッシュしたら、DB接続エラーを処理するコードを追 加してください (あるいは、 コードを追加するようにAIに頼んでください)。

• フロントエンドでは、 バックエンドが500エラーを返すことをシミュレートし、 UIが空白 ページや無限スピナーではなく、エラーメッセージを表示するようにしてください。

AIはコードを書く時に、こういった故障モードを自分では思いつかないことがあるので、あな たはテストして改良しなければなりません。 こういったシナリオをテストすることで、あなたは 適切なフォールバックロジック、 再試行、ユーザーフィードバックを追加するように促され、 信 頼性が向上します。

監視とロギング

ロギングを組み込み、 おそらくテストでログを使って検証してください。 例えば、 あるアクショ ンが監査ログエントリーをトリガーすべきなら、それをテストしてください。 AIはログ行を生 成できます。 それらが期待通りに出力されることを検証してください。

また、(本番環境でサービスがどのように監視されるかを、 インメモリでシミュレートするよう な形で) 監視のセットアップについても考えてみましょう。 例えば、テストを実行する際に、捕 捉されなかった例外がログに記録されるかどうかを追跡することがあります。 記録されるなら、 テストの失敗として扱ってください。 つまり、適切に処理されていないケースがあるということ です。

保守性

コードのスタイルや基準を保証するような保守性テストは、重要です。 AIはプロンプトによっ て微妙に異なるスタイルを生成する可能性があるため、リンターやフォーマッターを使って、 コードの一貫性を保ってください。 Prettier (https://prettier.io) や (Python用の) Black (https://pypi.org/project/black) といった書式設定ツールは、スタイルを統一できます。 より論理的な一貫性を保ち、 リファクタリングが必要な複雑すぎるAI生成コードを見つけるた めに、関数の複雑さの制限などを強制するリント規則を追加することを検討してください(詳し くは「8.5 AI駆動コードベースにおける保守性の確保」 を参照)。

テストが実施されれば、より自信を持ってAIコードをリファクタリングできます。 おそらくAIは、 動作するが不格好な解決策を生成するでしょう。 あなたはそれを改善し、その振る舞いを壊してい ないことを確認するために、テストを頼ります。 次のように、 AIコードのリファクタリングを、AI 自体に頼むことすらあります。

162 | 8章 セキュリティ、 保守性、 信頼性

現在のテストを通過するように保ちながら、この関数を明確にするためにリファクタリングして。

テストが優れていれば、リファクタリングが何も壊していないことを確認できます。 AIシステムの非決定論を理解するには、 根本的に異なる2つのシナリオを区別する必要がありま す。 顧客の質問に応答するチャットボット、コンテンツをパーソナライズする推薦エンジンなど、本 番システムで実行時にAIが動作する時、 同じ入力でも出力が変わる可能性があります。 この変動性 は、モデルの温度 (temperature) 設定、 乱数のシード、 進化するモデルの段階といった要因から生 じます。 このようなシステムのテストでは、完全一致を期待するのではなく、 許容可能な変動範囲を 考慮した専門のアプローチが必要です。

しかし、 AI 支援のコード生成は、まったく異なるパラダイムを示します。 AIがコードを生成し、 そのコードがリポジトリにコミットされると、 人が書いたコードと同じように決定論的になります。 税率を計算する関数は、 最初に人が書いたかAIが書いたかにかかわらず、 毎回同じ入力に対して同 じ出力を生成します。 この決定論はシステムの信頼性にとって極めて重要であり、 従来のテストア プローチを、 AIが生成したコードに完全に適用可能にします。

各コンポーネントが異なる暗黙の前提で個別に作成される可能性がある、 AIが生成した複数のコ ンポーネントを統合する際に、 より微妙な課題が現れます。 電子商取引 (EC) システムの具体例を 考えてみましょう。 あなたは、 注文処理モジュールを生成するようにAIにプロンプトで指示し、国 際注文を処理するよう指示します。 これとは別に、 あなたは、 同じシステムの配送計算サービスを 作成するように、AIに頼みます。 注文処理モジュールは、アメリカの慣例に従って、12月25日を 「12/25/2024」 と日付を書式設定します。 一方、配送サービスは、おそらく生成の過程でヨーロッパ の例に影響されて、 「25/12/2024」 と書式設定された日付を期待しています。 どちらのコンポーネン トも個別の単体テストを通過しており、単独では完璧に機能します。

不一致が表面化するのは、統合テスト中に注文処理モジュールが配送計算モジュールに日付を 渡すときだけです。 配送サービスは 「12/01/2024」を12月1日ではなく1月12日と解釈し、完全に 誤った月に基づいて出荷予定日を計算する可能性があります。 この種の前提の不一致は、AIによっ て生成されたコンポーネントで特によく見られます。 なぜなら、AIは各コンポーネントを独立して 生成する際に、異なる例や慣例から導き出すことがあるからです。 コンポーネント間の実際のデータ フローを動かす包括的な統合テストは、こういった微妙な非互換性が本番環境で不具合を引き起こ す前に見つけるために、不可欠になります。

AIは通常とは異なるエッジケースを持ち込む可能性があるため、AI支援プロジェクトのQAプロ セスには、もう少し創造性が必要かもしれません。 例えば、AIはあなたが明示的に考慮しなかった 機能を出力することがあります。 その場合、それもテストしてください。 AIが隠れた振る舞いを追 加したら、それを除去するか、あるいは、 適切にテストしてください。

最後に、可能なら本番環境に似た環境で、現実的なデータ負荷でアプリケーションをテストして ください。 データ量が大きくなったり、 同時実行性が高くなったりした場合にのみ、パフォーマンス

8.4 パフォーマンス最適化 |

の問題が現れることがあります。 こういったテスト結果を使って、 非効率な箇所を突き止めてくださ い。

8.4 パフォーマンス最適化

多くの場合、 AIは正しいコードを書きますが、必ずしも「最適な」 コードを書くとは限りません。 LLMは、本質的にパフォーマンス分析を行いません。 LLMは通常、トレーニングデータで一般的 なものを再現します。 そのため、 特にクリティカルパスや大規模利用では、 潜在的なパフォーマンス の問題を警戒してください。

す。 あなたは、次のようにAIとチャットして、パフォーマンス最適化のヒントを得ることすらできま

このコードの複雑さはどの程度? 改善できますか?

この関数が遅い。 速くするアイデアはある?

AIが常に正しいとは限りませんが、有益な提案をしてくれたり、少なくともあなたの考えを確認 してくれたりすることがあります。

とはいえ、最適化しすぎたり、 時期尚早に最適化したり、必要のないところで最適化したりしな いでください。 データサイズが小さかったり、 操作の頻度が少なかったりする場合、 AIの解決策で まったく問題ないこともあります。 プロファイリングデータを使って、 本当のボトルネックに焦点 を当て、 本当に必要な部分を最適化してください。 バイブコーディングの利点は、ゼロから手動で コードを作成するのに多くの時間を費やしていないことです。 そのため、ユーザー体験やコストに影 響しない限り、 重要でない部分を単純にして、最適化しすぎないようにする余裕があります。 この アプローチは、「まずは動くようにし、 それから (必要なら) 速くする」 というアジャイルプラクティ スに沿ったものです。

AI拡張プロジェクトを効率的に運営する際に押さえておくべき領域は、次の通りです。

複雑さの分析

AIがアルゴリズムを生成する時、 その複雑さを考えてみてください。 より効率的なアルゴリズ ムが存在するにもかかわらず、 ブルートフォース (総当たり)の解決策を使うことがあります。 例えば、 AIが1回の手順で済む方法を思い出せなかったために、リストを二重にソートしてし まい、O(n log n) で済むところをO(n logn × 2)にしてしまうかもしれません (大文字の 「O」 はメモリ使用量を表しています) *3。

あるいは、既知の0 (n) アプローチがあるにもかかわらず、 ネストされたループを使って操作を On"にしてしまうかもしれません。そのようなものを見つけたら、次のように改善を求めてく

*3訳注:このビッグオー記法は、アルゴリズムの実行時間や必要なメモリ量が入力サイズに対してどのように変化するかを表し ます。

163

ださい。

164 | 8章 セキュリティ、 保守性、信頼性

ネストされたループを避けて、 最適化できる? おそらく、 ルックアップにセットを使って。

AIは多くの場合、 あなたがそのアプローチをほのめかせば、それに応じて、 より良い解決策を 示すでしょう。 そうでない場合、 その部分を手動で実装しなければならないかもしれません。 遅い関数を特定するには、プロファイラーを実行するか、代表的なデータや最悪のデータを使っ て、主なコードパスの実行時間を測定してください。 あまりにも遅い場合、 手動で、あるいは AIの支援を受けて、 最適化を試みることができます。

現在ボトルネックになっているこの関数を最適化して。 複雑さを減らすよう試みて。

AIは、パフォーマンスのためにコードを再構築することがあります。 テストを使って、引き続 動作することを確認してください。

重要なアルゴリズムに対して、 小さなベンチマークハーネスを書いてください。 AIがあなたに、 (例えば、何かを計算する) コードを与えたら、別のアプローチに対してそのコードをテストす るか、少なくとも、入力サイズに応じてそのコードがどのようにスケールするかを測定します。 必要なら、あなたは、より効率的な方法でそのコードを書き直すことに決めることがあります。

メモリ使用量、 リーク、 保持

AIが生成した解決策は、必要以上にメモリを使うことがあります。 例えば、 ストリーム処理す る代わりにファイル全体をメモリに読み取り、 大きなデータ構造を保持します。 あなたのユース ケースにビッグデータが含まれる場合、システムのメモリ使用量を確認し、必要ならストリーム 処理やチャンク処理で最適化してください。 例えば、数百万レコードを処理する必要がある場 合、 あなたは、 バッチ処理するか、 データベースからストリーム処理するように、AIが生成し た関数loadAllRecords() をリファクタリングしたいでしょう。

また、AIが生成したコードがリソースを解放しているか、確認してください。 Java、 C#といっ た言語では、コードがファイルやDB接続を開いて、 閉じないことがあります。 フロントエン ドのシングルページアプリ (SPA) で、 イベントリスナーが除去されず、 リークにつながってい ることがあります。 (フロントエンド用のChrome開発ツールのメモリインスペクター、C++の リーク用のValgrindといった) ツールが役立つことがありますが、多くの場合、コードを読む だけでも役立ちます。 これらを特定し、 修正してください。 開いているファイルハンドルが閉じ られていないのを見たら、 finallyブロックでcloseを追加してください。

同時実行性 (並行性) と並列性

スレッドや非同期をサポートする言語を使っているなら、 AIコードを並列化できるのに単ース レッドになっている場所を探してください。 AIは、 適切な場所で自動的に async/awaitを使わ ないことがありますし、重いCPU タスクをワーカースレッドにオフロードすることを知らない こともあります。 そういった機会を特定してください。 例えば、 Node.js や PythonのI/Oに制

8.4 パフォーマンス最適化 | 165

約されたタスクでは、システムがブロックされないように非同期で使うようにしてください。 CPUに制約されたタスクでは、 AIはコードであまり役立たないかもしれません。 あなたは、よ り高パフォーマンスの言語で実装するか、バックグラウンドジョブにオフロードすることに決め ることがあります。

キャッシュ

AIが必ずしも自動的に追加しない一般的なパフォーマンス最適化は、コストの高い処理の結果 をキャッシュすることです。 あなたのコードを見てみてください。 繰り返し、 何かを再計算して いませんか? もしそうなら、 (インメモリか、 Redisのような外部キャッシュを使って) キャッ シュを実装してください。 あなたは、次のようにAIにプロンプトで指示できます。

冗長な計算を避けるために、この関数にキャッシュを追加して。

AIは、単純な記憶を実装したり、 キャッシュライブラリの使用を提案したりするでしょう。

データベースクエリの最適化

アプリケーションがデータベースを使っているなら、AIが作成するクエリを調べてください。 クエリは、インデックスを適切に使っていますか? おそらく、 AIはSELECT *と書きますが、必 要な列はほんのわずかでしょう。 あるいは、 AIは、 コードでフィルタリングするために膨大な データを取得し、 N + 1 クエリ問題のようなパフォーマンスのボトルネックを作り出します。 こ ういった非効率性では、より多くの作業をデータベースにプッシュするか、 適切なインデックス を活用することで、 最適化が必要です。

例えば、生成されたコードがループ内で繰り返し findOneを呼び出し、 何度もデータベースと ラウンドトリップしているなら、 WHERE id IN (...) を使って、これを1つのバッチクエリにリ ファクタリングできます。 同様に、頻繁にクエリされるフィールドのマイグレーションでAIが インデックス作成を省略したなら、 インデックスを追加することが、 受け入れ可能なパフォーマ ンスを維持するために不可欠になります。 多くの場合、 AIは機能的には正しいが最適ではない データベース対話を生成し、それを特定して解決するには、 人の専門知識が必要になります。

説明するために、例を挙げてみましょう。 例えば、 (O (n) のマージステップやマージソートのよう に2つのソートされたリストをマージするために使える既知の線形アルゴリズムがあるにもかかわ らず、AIが、単に連結して結果をソートするだけで、(O (n log n) になる) 2つのソートされた配列 をマージする関数を書いたとしましょう。 コードレビューで、あなたは、これが大きな配列でボトル ネックになる可能性があることに気付き、次のように、線形マージを実装するようにAIにプロンプ トで指示します。

組み込みソートを使わず、 線形時間でマージを実行するように、 mergeSortedArrays 関数を最 適化して。

166 | 8章 セキュリティ、 保守性、信頼性

AIはこれを古典的なマージアルゴリズムと認識して、それを書きます。 解決策はテストを通過し ます。 おめでとうございます。 あなたは、 正しさを犠牲にすることなくパフォーマンスを向上させる ことができました。

AI支援開発が、 パフォーマンスチューニングの必要性をなくすことはありません。 チューニング を行う「タイミング」 が変わるだけなのです。 多くの場合、 あなたはまず (非常に価値のある) 正しい 解決策を手に入れて、 それから、 対象部分の測定と最適化に目を向けることになります。 何かを最 適化する必要がある時、 必要なことをAIに教えさえすれば、 AIは助けてくれます。

8.5 AI駆動コードベースにおける保守性の確保

コードベースの 「保守性」 とは、 経時的な修正、 拡張、 理解の容易さを表します。 AI が生成した コードは、特に複数の提案でスタイルやパターンが異なる場合、 乱雑になったり一貫していなかっ たりすることを心配する人もいます。 本節では、こういった懸念に対処し、 バイブコーディングのプ ロジェクトをクリーンで保守しやすい状態に保つために使える、 いくつかのプラクティスを取り上げ ます。

8.5.1 プロンプトの作成中

プロンプトを準備する際に、 いくつか覚えておくべきことがあります。

一貫したコーディング基準を使う

リンターとフォーマッターを使って、一貫したスタイルを強制してください。 前述したよう に、AIは出力によって異なる命名規則や書式設定を使うことがあります。 コード生成後に (JavaScript用のPrettier Python用のBlack Go用のgofmtといった) フォーマッターをす べてのコードに対して実行することで、コードが統一されたスタイルに従うようにしてくださ い。これによって、コードを読むのが非常に楽になります (スタイルが切り替わることによる認 知負荷がなくなります)。 さらに、 プロジェクトの命名規則を定義して、それに従ってください。 AIが、ある場所では get_user_data、別の場所ではfetchUserDataと出力するなら、あなた が (snake_case、camelCaseの) どちらの命名規則を好むかを決め、1つのスタイルにリファク タリングしてください。

アーキテクチャパターンを使って、 モジュール性を促進し、スプロールを避ける

関心事を分離するようにAIにプロンプトで指示することで、 AIにモジュール化されたコードを 書くように促してください。 例えば、 すべてを実装した1つの巨大なファイルを書くようにAIに 求めるのではなく、 作業をタスクに分割してください。

•ユーザーロジック用のUserServiceクラスを作成して。

・メール送信用のモジュールを別途作成して。

これによって、 コードベースが論理的に分割されます。 各モジュールが明確な責任を持つこと

8.5 AI駆動コードベースにおける保守性の確保 | 167

で、 保守が容易になります。 あなたはアーキテクチャを導けます。

データベースアクセスのコードを、 APIルーティングのコードとは別のファイルやクラスに配置 して。

AIを使うと機能を追加するのが非常に簡単になるため、フィーチャークリープ (機能肥大化) や コードのスプロール (無秩序な拡大) を防ぐことが重要です。 規律を守るアーキテクチャ思考が なければ、コードベースが、 ソフトウェアアーキテクトが「大きな泥だんご」 と呼ぶ、 明確な構 造も境界もないアンチパターンに陥る危険があります。 この危険はAIの支援によって強まりま す。 従来は機能追加に伴っていた摩擦がなくなり、 アーキテクチャの崩壊を加速させる可能性 があるからです。

これに対抗するには、 実績のあるアーキテクチャパターンと原則に基づいたAI支援開発を行う ことです。 AIに指示する際に、プロジェクトが従うパターンを明示的に参照してください。 プロジェクトで使用されているリポジトリ/サービスパターンに従って、この新機能を追加 して。

ドメインレイヤーで確立されたヘキサゴナルアーキテクチャを使って、これを実装して。

この具体性は、機能が急速に蓄積されていたとしても、一貫性を維持するのに役立ちます。 より深いアーキテクチャの基礎を求める開発者のために、いくつかの基礎的なテキストが重要な 指導を提供しています。

エーリヒガンマ (エリックガンマ)、リチャード・ヘルム、ラルフ・ジョンソン、ジョン・ブ リシディース (「Gang of Four」) による 「Design Patterns: Elements of Reusable Object-Oriented Software」 (Addison-Wesley、 1994年)は、引き続き、 再利用可能な設計の解決策の決定的 なカタログです。

マーク・リチャーズとニール・フォードによる 「Fundamentals of Software Architecture: An Engineering Approach」 (https://learning.oreilly.com/library/view/fundamentals-ofsoftware/9781098175504) (O'Reilly, 2025年)は、技術スタック全体のアーキテクチャバター ンと原則を包括的に解説しています。

エリック・エヴァンスによる 「Domain-Driven Design: Tackling Complexity in the Heart of Software」 (Addison-Wesley, 2003年)は、ソフトウェア設計をビジネスドメインに沿わせる ための重要なテクニックを提供しています。 特に複雑なビジネスロジックを反映しなければな らないコードをAIが生成する場合に、 有用です。

こういったリソースによって、 あなたはAIツールを効果的に導けるようになり、生成されたコー

*4 訳注:日本語訳は「オブジェクト指向における再利用のためのデザインパターン (改訂版)」(SBクリエイティブ, 1999年)。 *5 訳注: 日本語訳は「ソフトウェアアーキテクチャの基礎第2版」(https://learning.oreilly.com/library/view/sohutouea akitekutiyanoji-chu-di-2ban/9798341634398/) (オライリー、2025年)。

*6訳注:日本語訳は「エリック・エヴァンスのドメイン駆動設計

、2011年)。

168 | 8章 セキュリティ、 保守性、信頼性

ドが技術的負債を助長するのではなく、 健全なアーキテクチャ原則を遵守するようにします。 覚え ておいてください。 AIはパターンの実装に優れていますが、 どのパターンが特定のコンテキストに 適しているかを判断することはできません。 アーキテクチャの判断は、引き続き、基本的に人が行い ます。

8.5.2 コード出力を扱う

AIが生成されたコードで応答したら、 保守性のために次のようなテクニックを使います。

継続的にリファクタリングする

必要に応じて、AIが生成したコードのリファクタリングをためらわないでください。 最初は、 正しいが理想的な構造ではないことがあります。 例えば、 AIは非常に長い関数を書いたり、ロ ジックを2箇所に重複させたりすることがあります。 よくある課題は、意図せずに重複したコー ドです。 AIは、2つの関数が類似したことを実行することに気付かず、 両方を作成してしまうこ とがあります。 類似のブロックに気付いたら、 1つにリファクタリングしてください。 コードリ ンターのようなツールは、重複を検出できます (類似性の高すぎるコード用のリンターもありま す)。 それらを実行すれば、 「DRY out」 (同じことを繰り返さないように) すべき箇所が浮き彫 りになることがあります。

AIにリファクタリングの手助けを頼むには、次のようにプロンプトで指示できます。

このコードをリファクタリングして、 重複を除去し、 明確さを向上させて。

AIはヘルパー関数を作成したり、ロジックを簡素化したりすることがあります。 リファクタリ ング後に、必ずテストを行ってください。

テストする

本章ですでにテストについて取り上げているので、 良いテストスイートが保守を容易にすること だけを書いておきましょう。 将来、 (おそらくまたAIを使って) あなたや他の人がコードを変更 した時に、その変更が何かを壊していないかをテストが見つけてくれるので、安心してリファク タリングして、 実装を変更できます。 テストは、 「何をするか」 と 「どのようにするか」 を切り離 し、「何」 を変えずに 「どのように」 を保守、 改善する柔軟性を与えてくれます。

過剰な複雑化や、 AI特有の構成要素への過度の依存を避ける

AIが、 他の開発者が知らないような巧妙な技やあまり一般的でない機能を使うことがあります。 それは本質的に悪いことではありませんが、 保守性を考慮してください。 平均的な開発者がそ のコードを見て頭をかくようなら、それを簡素化してください。 例えば、 AIがちょっとした正 規表現の魔法やリスト内包表記を使っていて、それが簡潔すぎるなら、それをより明示的なルー プに書き換えてください (あるいは、少なくともコメントしてください)。 同様に、役に立とうとするAIは、必要でない層を追加するなど、 解決策を過剰設計することが

8.5 AI駆動コードベースにおける保守性の確保 |

あります。 例えば、 直接的なアプローチで問題なかったかもしれませんが、AIが役に立たない 抽象化を持ち込んでしまいました。 それを除去して、物事を単純に保ってください。 通常、 よ り単純なコードはより保守しやすいのです。

レジリエンスとフォールバックを組み込む

失敗した場合のフォールバック戦略を考えてください。 例えば、 AIがコーディングしたコンポー ネントが外部APIを呼び出し、 そのAPIが停止していたり、 予期しないデータを返したりした ら、キャッシュデータの使用や、デフォルトのレスポンスといった) フォールバックはあります か? (サーキットブレーカー、バックオフを備えた再試行といった) レジリエンスパターンを実 装することで、システムをより堅牢にできます。 AIは、求められない限り、 自分でこれを行う ことはないでしょう。 システムが、部分障害に正常に対処できるようにしてください。 可能なら、 1つのマイクロサービスが停止しても、アプリ全体が停止すべきではありません。 タイムアウト とフォールバックロジックを使ってください。

8.5.3 フォローアップ

あなたがコードに満足したら、 さらにいくつかのプラクティスがコードを保守可能にするのを助け ます。

徹底したドキュメントとコメントを提供する

コードが適切に文書化されていることを確認してください。 AIは多くの場合、 プロンプトで指 示されない限り、最小限のコメントしか書きません。 プロンプトで、 docstringやコメントを求 められます。

このコードの各セクションの目的を説明するコメントを追加して。

●この関数のdocstringを書いて。

これらは将来の読者の時間を節約できます。 AIは通常、かなり良い説明を生成できますが、微 妙な点を誤って説明することもあるので、正確さをレビューしてください。

また、アーキテクチャや主なコンポーネントなどを説明した (README、 設計ドキュメントと いった) プロジェクトの高レベルのドキュメントの整備を検討してください。 あなたがほとんど 自分でこれを書けますが、必要ならAIがコードベースを要約して助けてくれます。

「AIは、いつもこのパラメーターに変な名前を付ける」 といった癖に遭遇したら、他の人のため に開発メモにそのことを書いておいてください。 これは、新しい協働環境の一環です。 あなた だけがAIが生成したコードを使うなら、 多少の癖があっても構いませんが、他の人がプロジェ クトに参加した場合、 「なんでこんな名前付けなんだろう?」と疑問に思うことがあります。 お そらく、単に名前付けを標準化してください。

また、どのコードがAIが生成したもので、 どれが人が書いたものかを知るという点で、保守

169

170 | 8章 セキュリティ、 保守性、信頼性

性という側面もあります。 厳密にラベル付けする必要はありませんが、 追跡可能性のために 「2025/05/01 に GPT-4の助けを借りて生成した」とコメントするチームもあるでしょう。 理 想的には、 PRの説明の中で不明点にフラグを立ててください。 「この関数を支援するために、 ChatGPTを使いました。 動作しているようですが、エラー処理ロジックを注意深く確認してく ださい。」

これは、あまり普及していないプラクティスです。 コードレビューの際に役立つかもしれません が、人がすでにコードをレビューし、それが単なるコードになっている場合、 これは必要ないか もしれません。 トランスクリプトやプロンプトを残しておくなら、 複雑なコードのコメントでそ れらをリンクできます。 「このアルゴリズムは、プロンプト Xに基づいてGPT-4によって導かれ た。」 レビュアーは精査の観点でそれを特別に扱う必要はありませんが(あなたはすべてのコー ドを精査すべきです)、 コンテキストを理解するのに役立つでしょう。 例えば、コードにスタイ ルの不一致や奇妙なイディオムがあったら、それがAIに由来するものだと知ることが、 それが 作者の意図的な選択ではなく、 AIの成果物であることをレビュアーに伝える手がかりになるこ とがあります。

コードレビューとチーム規範を設ける

チームで作業しているなら、1人の人とAIが共同でそれを書いたとしても、チームメンバー全 員にコードレビューしてもらってください。 彼らは、厄介なパターンやチーム規範に反するもの を見つけることがあります。 時とともに、 あなたは、 あなたのチームのスタイルに合うように(シ ステムプロンプトや初期のガイドラインに具体的な内容を盛り込むといった形で) AIにプロンプ トで指示する方法の感覚を養うでしょう。 複数の開発者がAIを使うなら、全員が望ましいスタ イルパターンを知っていて、それに応じて (「これを関数スタイルで書いて」 や 「コールバックで はなく async/awaitを使って」といった) プロンプトで指示できるようにしてください。 AIコー ドを使ったコードレビューのヒントについては、次節を参照してください。

技術的負債を追跡する

開発中に、理想的でないとわかっているAIの解決策を受け入れたら、コメントやプロジェクト のTODOで、それを技術的負債として追跡してください。 「TODO: 解決策は動作しますが、 On2) です。 データが大きくなったら、これを最適化してください」 や 「TODO これは単純化 のためにグローバル変数を使っています。 後で改良してください」などです。 あなたが次のよう に頼めば、 AI自体がTODO コメントを挿入できます。

将来に改善が必要な領域があったら、 TODOコメントを追加して。

こういったTODOには、いずれ対処すれば十分です。

AIのパターンから学ぶ

AIが、 あなたがなじみのないデザインパターンやライブラリを持ち込んだら、それを無視する

8.6 コードレビュー戦略 | 171

のではなく、時間をかけてそれについて学んでください。 特定のキャッシュのアプローチやライ ブラリを理解することで、 将来、 自信を持ってその部分を保守して修正できるようになります。 あまりに難解なら、 あなたは知っているものを優先して、それを除去することに決めることもあ ります。 しかし、AIが、 あなたが知らなかった便利なライブラリやパターンで、あなたを驚か せることもあります。 それがよく知られた解決策であり、あなたやあなたのチームがそれを学ぶ ことができたら、 それは保守性を向上させます。

実際には、いつもと同じように、 保守性は優れたソフトウェアエンジニアリングの原則を適用する ことに帰着します。 AIが部分的に書いたコードに、原則を適用するだけです。 幸いなことに、AIが 雑務を減らしてくれるため、コードのクリーンアップやドキュメントの作成に集中できる時間が増え、 「保守性が「向上」します。

AIでコードを一気に生成した後、リファクタリングと文書化のための 「強化スプリント」に時間を 割いていると、一部の企業は報告しています (https://oreil.ly/2IrTW)。 生成に重点を置いたスプ リントとクリーンアップスプリントを交互に実施することも、1つの可能な戦略として検討してくだ さい。

8.6 コードレビュー戦略

「4章 70%を超えて: 人の貢献を最大化する」 で説明したように、 コードレビューは従来の開 発での重要なプロセスであり、 AI支援開発でも同様です。 本節では、 コードレビューの一部がマシ ンで提案されたものである時に考慮すべき、いくつかの微妙な差異について議論します。 AIは非常 に早くコードを生成できるため、 コードレビューがボトルネックになると心配するのはもっともです。 しかし、その心配がレビュープロセスの妨げにならないようにしましょう。 レビューに適切な時間を 割くことは、極めて重要です。 「早く書いたから、早くマージしましょう」という思い込みで、手を 抜いてはなりません。 どちらかといえば、レビューを容易にするために、 より小さな変更をより頻繁 にコミットしてください(いずれにせよ、 一般的には良いプラクティスです)。 頻繁で小さなプルリ クエスト (PR) は、1つの巨大なPRよりも徹底的にレビューしやすいものです。 あなたが適宜計画 すれば、 AIはタスクを小さなPRに分割する手助けもしてくれます。

「AIが書いて、 テストを通過した」 という理由だけで、 コードが正しいと想定しないでください。 批判的に考えて、ロジックの推論を試みてください。 可能なら、テストがすべてをカバーしていない ことがあるので、頭の中で、あるいは提供されているテスト以外のケースを追加して、テストしてく ださい。 また、 あなたは、コードを実行し、扱いにくい入力のスニペットを実行してその挙動を確認 することで、実験できます。

コードレビューは、重要な学習の瞬間でもあります。 AIが実際に優れた斬新な解決策を持ち込 んだら、レビュアーはその正しさを検証しながら、 新しい知見を得られるかもしれません。 同様に、 AIと人の組み合わせが最適ではないやり方をしていた場合、 レビュアーはより良いアプローチを説

172 | 8章 セキュリティ、 保守性、 信頼性

明できます。 時とともに、このフィードバックループは、 何を避けるべきか、 どう尋ねればよいか を全員が理解できるように助けることなど) チームのAIの使い方を改善できます。 ある意味、コー ドレビューは人の学習ループを閉じるのに役立ちます。 なぜなら、 人の作者は、 彼らにとってAIが 書いた新しいものは何でも、学んで理解する必要があるからです。

コードをレビューする時に最優先すべきは、そのコードが要件と意図した設計を満たしているよう にすることです。 このコードは、その機能やバグ修正が想定していることを行っていますか? 仕様 に記載されているエッジケースをカバーしていますか? プロンプトが外れていたら、 AIは少し違っ た問題を解決することがあります。 必要でないケースに対処したり、ケースを見逃してたりしている かもしれません。これは普通のことですが、 部分的にしか問題に対処していないAIの出力を、 開発 者がそのまま受け入れないように、注意してください。 例えば、 AIは日付を書式設定するコードを 生成し、特定のタイムゾーンを想定していることがあります。 それは、要件に合っているかもしれま せんし、合っていないかもしれません。

コード内の何かが明白でないなら、 どのように動作するか、 なぜそのようにするかを説明するよ うに、作者に求めてください。 彼らが説明するのに苦労したり、 「AIがやったことだから、正しいと 「思う」と言ったりしたら、それは危険信号です。 チームは、コードベースのすべてを理解すべきです。 AIやドキュメントで再確認し (場合によってはコード内のコメントとして) 適切な説明をするように、 作者に促してください。

本章の前半で議論したセキュリティとパフォーマンスの脆弱性にも注意を払い、 (ウェブ開発で出 力がエスケープされていない、 コードに認証情報を見つけた発見したなど) 既知のベストプラクティ スに違反しているなら、それを指摘してください。

コードが動作するものの、 より単純で、よりチームのスタイルに沿ったものになる可能性があるな ら、変更やリファクタリングを求めてください。

AIは異なるユーザーロールのために3つの別個の関数を作成したが、 そのほとんどは互いに重 複している。 これらを、 ロールのパラメーターを持つ1つの関数にマージできる?

コードの作者は、 (おそらくAIの助けを借りて) それを行えます。 AIの提案がチームの一貫したス タイルや標準ライブラリを使っていないなら、それにも言及してください。

通常、 HTTP呼び出しにrequests ライブラリを使うが、このコードはhttp.clientを使っている。 一貫性のために、 requestsにそろえよう。

作者は、好みのライブラリを使って書き直すように、AIにプロンプトで指示できます。 AIが、扱いにくいアルゴリズムのような、 本当に複雑なものを書いたら、 他のレビュアーやチー ムと議論して、 より深くレビューすることを検討してください。

プルリクエスト用のGitHub Copilot といった、AIを使ってコードレビューを支援する新しいツー ルを試してみるのもいいでしょう。 こういったツールは、まとめを生成し、潜在的なバグやほかの問

8.7 信頼できるデプロイのためのベストプラクティス | 173

題にフラグを立てられます。 (重複の可能性を指摘して)「このコードスニペットは、モジュールXの ものと似ていますが、 若干の違いがあります」 といったことを示すことがあります。 こういったヒン トは、人によるレビューを補完できますが、 それに取って代わるものであってはなりません。

最後に、コードにAIによる欠陥があったとしても、敬意を持って建設的にレビューしてください。 AIの成果物である可能性について、 開発者を責めるのは避けてください。 開発者が自分のコードに 責任を持つことに変わりはありませんが、その状況を認識してください。 AIはツールであり、作者 もレビュアーもそれを扱っています。 目標は、コードを改善して知識を共有することであり、非難す ることではありません。 例えば 「この部分にはセキュリティの問題があるようです。 おそらくAIの提 案の見落としでしょう」 と言いましょう。

最終的に、 バイブコーディングにおけるコードレビューとは、 人とAIの協働において 「人の知性」 の側面を最大限に発揮するための手段です。 AIが見逃すことがあるものを見つけ、品質基準を高く 保つために、監督と専門知識の出番となります。 それはまた、チームにとって知識を共有する機会 でもあります。 レビューでコードについて議論することで、ドメイン、AIの最適な使い方の両方に ついて理解が深まるからです。

コードレビューはまた、グラントグロスが 「CIO」で紹介した (https://oreil.ly/INPFV) 「編集 者としての開発者」 という概念を正式なものにするものです。 レビュアーは編集者であり、 コードが 洗練され、本番に適したものになるようにします。 これは、バイブス (AIの提案) はありますが人の 判断がそれを洗練させるという、概念としてのバイブコーディングと完全に一致しています。

8.7 信頼できるデプロイのためのベストプラクティス

コードが安全で、 テストされ、 保守可能であることがわかったら、 あなたはそれをデプロイし、本 番環境で確実に実行し続ける必要があります。

AI支援開発によってソフトウェアデプロイの中心原則が変わることはありませんが、 デプロイの ベロシティや運用の複雑さに関する考慮が必要になります。 デプロイの基本を包括的にカバーした い人には、ジーン・キム、 ジェズ・ハンブル、 パトリック・ボア、 ジョン・ウィリス、ニコール・フォー スグレンによる 「The DevOps Handbook」 (IT Revolution Press, 2016年) *7が、継続的インテグ レーションやデプロイパイプラインから監視、セキュリティ、 組織変革までをカバーした、決定的な ガイドを提供しています。 AIがデプロイ可能なコードを生成するあなたの能力が加速させると、こ の基礎知識はさらに重要になります。 原則が、 あなたのデプロイプラクティスを、 開発ベロシティの 増加に合わせて拡張できるようにするからです。

8.7.1 デプロイ前とデプロイ中

あなたがデプロイに向けて立ち上がる際には、次のベストプラクティスを検討してください。

7 注:第1版の日本語訳は 「The DevOps ハンドブック 理論実践のすべて」(日経BP、2017年)。

174 | 8章 セキュリティ、 保守性、信頼性

CI/CD パイプラインを自動化する

AI開発のベースが速いことを考えると、 堅牢な継続的インテグレーション / 継続的デプロイ (CI/CD) パイプラインは価値があります。 (AIが生成したコードの有無にかかわらず) すべて のコミットは、自動化されたパイプラインを通してビルドされ、テストされ、デプロイされる可 能性があるべきです。 これによって、 ヒューマンエラーが減り、 すべてのデプロイ手順 (テスト、 リント、セキュリティスキャン) が一貫して実行されることを確認できます。 AIコードがビルド を壊したり、テストに失敗するようなものを持ち込んだら、 CIはすぐにそれを見つけます。 ま また、自動化されたCI/CD パイプラインは素早い反復を可能にするので、 AIが持ち込んだ問題 にパッチを当て、素早く修正をデプロイできます。

コードとしてのインフラ (laC)

(Terraform、 AWS CloudFormation といった) コードとしてのインフラを使って、デプロ イ環境を定義してください。 これはAIコーディングとは直接関係ないですが、 信頼性の高い デプロイの一環です。 AIを使ってTerraform スクリプトを書けますが、 本番環境に適用する 前にサンドボックスでテストするなど、他のAIコードと同じように慎重に扱って、 テストして ください。 貴重な出発点は、 「Terraform: Up and Running」 (https://learning.oreilly.com/ library/view/terraform-up-and/9781098116736/) (O'Reilly, 2022年)*8という本であり、 Terraformを使ったIaCの原則、 プラクティスについて包括的な入門を提供しています。

段階的ロールアウトを使い、ロールバック計画を立てる

完全な本番環境へのロールアウトの前に、ステージング環境やカナリアリリースにデプロイする といった、段階的ロールアウト戦略を使ってください。 こうすることで、 全ユーザーに影響が及 ぶ前に、見落としていたものを見つけられます。 例えば、 AIでコーディングされた新機能をユー ザーの5%にデプロイし、 (メトリクスやログで) エラーやパフォーマンスの問題がないか監視し ます。 問題がなければ、 100%のユーザーにロールアウトしてください。

常にロールバックプランを持ってください。 すべてのテストとレビューにもかかわらず、 物事が すり抜けることもあります。 新リリースがうまくいかなかった場合に備えて、 最後の安定バー ジョンに戻す準備をしてください。 Kubernetesのようなコンテナー化戦略を使っているなら、 以前のデプロイを維持しておき、素早くロールバックできるようにします。 サーバーレス関数な ら、新バージョンに自信が持てるまで、 旧バージョンを残しておきます。

可観測性 (オブザーバビリティ) をセットアップする

本番環境で、システムメトリクスとアプリケーションログの両方について、 包括的な監視をセッ トアップします。

• Sentry のようなツールを使ってエラーを追跡し、 例外を捕捉します。 (おそらくエッジケー

*8 訳注: 日本語訳は「詳解 Terraform 第3版 -Infrastructure as Codeを実現する」 (https://learning.oreilly.com/ library/view/xiang-jie-terraform-di-3ban/9784814400522/) (オライリー、2023年)。

8.7 信頼できるデプロイのためのベストプラクティス |175

スが網羅されていないため) AIコードが本番環境で予期せぬエラーを送出したら、あなた はアラートを受け取り、 それを修正できます。

アプリケーションパフォーマンス監視 (APM) のようなパフォーマンス監視ツールを使って、 応答時間、スループット、 メモリ使用量を追跡します。 これによって、 新しいデプロイに含 まれるコードが、速度低下やメモリリークを持ち込んだかどうかが、わかります。

・可用性を監視します。 例えば、サービスエンドポイントにpingして、 それらが稼働してい ることを確認してください。 (おそらく、テストされていないシナリオが原因で) 何かがク ラッシュしたら、アラートが発報されるはずなので、 あなたは素早く対応できます。

セキュリティを常に警戒する

APIキーのようなシークレットが、 デプロイで適切に対処されるようにしてください。 例え ば、AIが環境変数のシークレットを期待するコードを書いたら、CI/CDやクラウド構成でそ のシークレットをセットアップし、誤ってログに記録されたり公開されたりしないようにして ください。 シークレット管理、 キー管理などを提供し、 多くの統合が可能なHashiCorp Vault (https://oreil.ly/NqQ-T) やデータベース認証情報、 APIキー、 トークンといったシークレッ トを安全に格納してローテーションでき、 GitHubのようなCI/CDツールと統合可能なAWS Secrets Manager (https://oreil.ly/LIYX-) といったシークレット管理ツールを使ってくださ い。 また、 コンテナーイメージを使っているなら、 脆弱性がないかイメージをスキャンしてくだ さい。

ブルーグリーンデプロイ シャドウテストといったテクニックを使ってテストする

大きな変更では、ブルーグリーンデプロイを検討してください。 これには、2つの同じ本番環境 をセットアップします。 「ブルー」 (現在のライブバージョン)と「グリーン」 (新バージョン) で す。 最初は、 トラフィックはブルー環境に向けられます。 グリーン環境の準備が整って、 テスト されたら、 トラフィックはそちらに切り替えられます。 グリーン環境で何らかの問題が発生した ら、トラフィックをブルー環境に素早く再ルーティングでき、 停止時間とリスクを最小限に抑え ます。 この方式は、 新バージョンを唯一のライブバージョンにする前に、 完全な本番環境で新 バージョンをテストします。

あるいは、 AIでコーディングされた特定のアルゴリズムの変更にリスクがある場合や、 ユー ザーに影響を与えずに実世界のデータでその振る舞いを検証したい場合は、シャドウテストを 行えます。 これは、現在のライブバージョンとともに新バージョンをデプロイします。 本番環境 の実際の入力は、両方のバージョンに並行して与えられます。 しかし、ユーザーには現在のバー ジョンの出力だけが表示されます。 新しい (シャドウ) バージョンからの出力は収集され、現在 のバージョンの結果と比較され、そのパフォーマンス、 正確性、安定性が評価されます。 シャ ドウバージョンの結果が満足のいくものであり、パフォーマンスも良好なら、自信を持ってそれ をアクティブなバージョンに切り替えられます。

176 | 8章 セキュリティ、 保守性、信頼性

8.7.2 継続的なベストプラクティス

デプロイ後、次のような戦略は、すべてを確実に実行し続けるのに役立ちます。

運用ランブックを作成する

AIが生成したコード部分の特殊な側面を説明したランブック (運用手順書) を、 運用チームに提 供します。 「このサービスは、機能XにAIモデルを使っています。 モデルの出力に誤りがあるよ うなら、サービスを再起動するか、 モデルのバージョンを確認するかしてください」 や 「機能Y はキャッシュを多用して、うまく動作しています。 パフォーマンスに問題が発生したら、 キャッ シュのヒット率を確認してください」 などです。 基本的に、 明白ではないことがある、 あらゆる 運用の考慮事項を文書化します。 AIが (一時ファイルの使用のような) 依存関係を持ち込んだ ら、運用チームがディスク容量などを監視すべきだとわかるように、 それを記録してください。

本番環境でテストする

開発中に、あるいはロールアウトの一環としてテストを実行することに加えて、継続的に小さ な実験を行うといった安全な方法で 「本番環境でのテスト」 (TiP) を行う企業もあります。 例え ば、あなたはフィーチャーフラグ(フィーチャートグル) を使って、 少数のユーザーに対してAI が生成した機能を有効にし、エラー率が変化するかを確認することがあります。 これはカナリ アリリースと重なりますが、フィーチャーフラグを使えば、 より粒度を細かくできます。

定期的に監査する

コードベースのセキュリティ、パフォーマンスの監査を定期的に行ってください。 特に、AIに よる貢献が増えていくにつれて、 注意を払ってください。 これは、 技術的負債の管理と似てい ます。 最初は問題なかったが、規模や状況が変わるにつれて問題になる可能性があるものを見 つけるのに役立ちます。 「ドリフト」 (逸脱)にも注意してください。 AIコードがSQLクエリを 生成している場合、マイグレーションとコードが同期しており、 新しいコードがトラフィックを 受ける前に、そのデプロイでマイグレーションが適切に実行されているようにしてください。

ヒューマンインザループを維持する

自動化を監視すべきなのは、人です。 AIは、あなたがコードを書くのを助けることがあります が、 午前2時の本番環境のインシデントを解決してくれるわけではありません。 システムを理解 している人を、オンコール体制に置いておいてください。 時とともに、ログ分析のようなトラブ ルシューティングにAIを活用することもあるでしょう(これは、 新しいツールの一部が備える 機能です)。 しかし、最終的に修正に関する判断を下すのは、人であるべきです。

失敗から学ぶ

100%完璧なプロセスは存在しません。 エラーが防御を突破して、 インシデントを引き起こした ら、事後調査を行ってください。 (「私たちはここのAIコードを信頼しましたが、それはシナリ

88 まとめと次の一歩 | 177

オXの下で失敗しました」 のように) 問題がAIの使用に関連しているかどうかを特定し、その種 の問題を防ぐために、プロセスとテストを更新してください。 この種の分析を毎回行うことで、 信頼性が継続的に向上します。

もちろん、 信頼性はコードだけに関するものではありません。 コード 「周辺」の基盤や運用も関わ ります。 AIは主にコードの面で役立ちます。 (AIが部分的に支援できる) 堅牢な運用プラクティスは、 システム全体の信頼性を維持します。

要するに、 デプロイに関しては、AIを多用するプロジェクトを、 他の高品質なソフトウェアプロ ジェクトと同じように扱ってください。 徹底的なテストを採用し、徐々にロールアウトし、厳重に監 視し、素早くロールバックできるようにします。 AIはより速く変更を作成できるため、より頻繁に デプロイを行うことになるかもしれません (CI/CD パイプラインが良好なら、 これは問題ありませ ん)。 小さなデプロイを頻繁に (https://oreil.ly/ATjYo) 行うことは、 大きなデプロイをまれに行 うことに比べて、 実際にはリスクを低減することが知られています (https://oreil.ly/Y5uDn)。 そ の理由は、個々の変更が小さくなるため、発生した問題を特定し修正するのが容易になるからです。 問題が発生したら、 小さな変更をロールバックする方が、より単純で高速です。 このアプローチは、 多数の変更をまとめてデプロイする大規模でまれなリリースとは対照的であり、 問題の原因を特定 するのが難しく、 デプロイに失敗した場合の潜在的な影響も大きくなります。

こういったベストプラクティスに従うことで、 多くのコードがAIで生成されたものであっても、 システム全体としてユーザーにとって信頼性の高い動作をすることを確信できます。 自動テスト、 入 念なデプロイ、監視の組み合わせがループを閉じて、 初期段階をすり抜けたものを見つけます。そ の結果、 あなたは、本番環境でのソフトウェアの信頼性を犠牲にすることなく、 AI開発の速度と生 産性の利点を享受できます。

8.8 まとめと次の一歩

まとめると、 バイブコーディングはエンジニアリングの厳密さの必要性をなくすものではなく、 そ の厳密さを適用するエンジニアの生産性を増幅させるものです。 あなたのモットーは、 古いロシアの ことわざ「信頼せよ、されど確認せよ」 (Trust but verify) であるべきです。 AIが雑務に対処するこ とを信頼し、 あなたのツールと専門知識ですべてを検証 (確認) してください。

セキュリティと信頼性は責任ある開発の一側面であり、倫理は別の側面です。 AI支援コーディン グは、知的財産、 バイアス、 開発者の仕事への影響などに関する重要な問題を提起します。 「9章 バイブコーディングの倫理的課題」 では、そうした幅広い意味を掘り下げていきます。 どのようにし て、AIコーディングツールを責任を持って公正に使えますか? どのようにして、AIが生成したコー ドのライセンスに対処し、 モデルとプロンプトが倫理的に使われるようにしますか?



| 179

9章

バイブコーディングの倫理的課題

AI支援開発がますます一般的になるにつれて、この新しいパラダイムの倫理的、社会的な課題に 対処することは極めて重要です。 本章では、技術的な詳細から一歩引いて、 倫理的なレンズを通し てバイブコーディングを検討します。 このような新しい開発方式は効果的であり得ますが、責任を 持って実装され、 個人や社会全体に利益をもたらす必要があります。

知的財産 (IP) の問題から始めましょう。 AIが生成するコードの所有権は誰にありますか? ま た、オープンソースコードに由来するかもしれないAIの出力を、 帰属表示なしに使うことは許され ますか? そこから、 バイアス (偏見) と公平性について考えます。 透明性がもう1つの焦点です。 開 発者は、コードベースのどの部分がAIによって生成されたかを開示すべきですか? また、チームは、 コード品質やバグについて、 どのように説明責任を果たせますか?

透明性と説明責任の確立からプロンプトでの機密データの回避、 アクセシビリティと包括性の確 保まで、 AI利用における責任ある開発プラクティスについて概説します。 本章の最後には、 AIツー ルを責任を持って使うための一連のガイドラインがあります。

法的免責事項

次節では、複雑な法的問題、 特に著作権と知的財産法について、主に米国の視点から触れています。 法制度や解釈は、 特に人工知能に関して、世界中で進化しつつあります。 この情報は教育的目的の みに提供されるものであり、 法的助言として解釈されるべきものではありません。 特に、あなたや AIツールが生成したコードの所有権やライセンスについて懸念がある場合は、あなたはこの情報に 基づいて何らかの決定を下す前に、資格を有する知的財産専門の弁護士に相談すべきです。

9.1 知的財産に関する考慮事項

AIが生成したコードの所有権は誰にありますか? また、 AIは、AIをトレーニングする際に使われ た資料のライセンスや著作権を尊重して使っていますか? GPT のようなAIモデルは、 (MIT、 GPL、 Apache など) さまざまなライセンスのオープンソースリポジトリを含む、 インターネット上の膨大 な量のコードでトレーニングされてきました。 AIが、 GPLライセンスのプロジェクトのものと非常 に似た (https://oreil.ly/I3HxT) (または同じ) コードスニペットを生成し、プロプライエタリな

180 | 9章 バイブコーディングの倫理的課題

コードベースでそのスニペットを使うと、一般に派生コードの共有 (https://oreil.ly/8inJe) を義 務付けているGPLにうっかり違反してしまう可能性があります。

オープンソースの規範と一般的な著作権の原則によれば、 数行程度の小さなスニペットは、独立 した創作物とみなされるに足る十分な独創性を欠いている場合、 著作権の対象とならない可能性が あります」。 その利用は、デミニミス (些細すぎて法的に問題にならない) とみなされる 「可能性もあ ります」。 しかし、実質的な内容や独自の創造的選択を表現しているものは、 著作権によって保護さ れる可能性が高くなります。 重要なのは「オープンソース」が「パブリックドメイン」を意味するもの ではないという点です。 原則として、 コードを含む創作物には、その著作者に専有的に著作権が付 与されています。 オープンソースライセンスは、 通常であれば著作権法によって制限される利用を、 明示的に許可するものです。

オープンソースの規範についてもっと知りたいなら、 次のものから始めるのが良いでしょう。

オープンソースイニシアティブ (OSI)

OSI (https://oreil.ly/hmJVN) は、 オープンソースソフトウェアを定義して推進し、 オープ ンソースの定義を保守し、 その基準を満たすライセンスを承認します。

フリーソフトウェア財団 (FSF)

FSFは (https://fsf.org)、 (オープンソースの原則と強く重なる) 「フリーソフトウェア」を提 唱しており、 GNU 一般公衆ライセンス (GPL) などのライセンスの管理主体でもあります。

プロジェクト固有のドキュメント

個々のオープンソースプロジェクトには通常、 「LICENSE」 ファイル、 「README」 ファイ ル、 「CONTRIBUTING」 ガイドラインが含まれており、その特定のプロジェクトの利用と貢 献の条件が詳述されています。

コミュニティと法的リソース

GitHubのようなWebサイトでは、 オープンソースのプラクティスに関する幅広いドキュメント や議論を提供しています。 Linux Foundation のような組織や法的情報サイトも、 オープンソー スのコンプライアンスや法的な側面に関する貴重なリソースを提供しています。

小さなコードスニペットの利用が (米国では) フェアユース (公正使用、 公正利用)の理論 (https://oreil.ly/dOZK8) (他の多くの法域では 「フェアディーリング (公正な取引)」) と重なるか どうかという問題は、複雑であり、事実関係に大きく依存します。 フェアユース (https://oreil.ly/ EwrJ2) は、 批評、コメント、 報道、教育、学術、 研究などの目的で、 著作物を許可なく限定的に使 うことを認めています。 米国の裁判所は通常、フェアユースを判断するために4つの要素を考慮しま す。

• 利用の目的 (https://oreil.ly/1TE5B) と性質 (商用か非営利か、変革的か重複的か)。

9.1 知的財産に関する考慮事項 |

・著作物の性質 (高度に創作的か 事実的か)。

・著作物全体に対する利用部分の量と実質性

・ 利用が著作物の潜在的市場や価値に及ぼす影響

相互運用性のため、あるいは著作権保護の対象とならないアイデアにアクセスするためなら、 特 にその利用が変革的なら、ごく小さな機能的コードスニペットの複製が、 フェアユースに該当し得 ると主張する人もいます。 しかし、コードに関しては、この分野の法理は明確に確立されているわ けではなく、 「フェアユース」 や 「デミニミス」 (些細すぎて法的に問題にならない)と断定できる行 数について、普遍的に合意された基準は存在しません。 最も安全な対応は、許諾を得るか、 基礎と なるアイデアを理解した上で自分自身の方法でコードを書き直すことです。 米国連邦最高裁判所の Google LLC 対 Oracle America, Inc. の事件では、 ソフトウェアAPIにおけるフェアユースが争わ れ、 GoogleによるJava API宣言コードの再実装がフェアユースに該当すると判断されました。 た だし、 これはAPI宣言に特化した複雑な判決であり、 すべてのコードに適用されるものではありま せん。 一般的に、 著作権はアイデアそのものや手続き、 操作方法ではなく、 その具体的な表現を保 護するものと理解されています。

通常、AIを利用する開発者が 「著作者」 とみなされます。 これは、AIがコンパイラーやワードプ ロセッサーのようなツールだと理解されるためです。 したがって、業務でコードが生成された場合、 そのツールを使った開発者が生み出したコードは、AIツールの利用規約や知的財産上の問題に従い つつ、開発者の所属企業が所有する可能性が高いと考えられます。 ただし、AIツールのサービス利 用規約 (ToS) は非常に重要です。 多くのToSでは、ユーザーが生成した出力に対する権利をユー ザーに付与しています。 例えば、 OpenAI の ToSでは 「GPT-4で生成した (コードを含む) 出力の所 有権はあなたにあります」 と明記されています。

しかし、この「所有権」については、 慎重な検討が必要です。 一般的には、AIプロバイダー が、 「あなたがそのツールで」 作成したものの所有権を主張しないことを意味します。ただし、そ れはあなたが入力する内容に対して権利を有していることを前提としており、 生成された出力が自 動的に著作権保護の対象となることや、 第三者の知的財産権から完全に自由であることを保証する ものではありません。 あなたが自分自身の独自のコードを入力して修正や拡張を行った場合、 その 出力は基本的にあなた (または、 あなたの雇用主) の所有となる可能性が高いですが、それはAIの 処理方法やトレーニングデータから取り込まれたものに依存します。 一方、 あなたが他者の著作権 で保護されたコードを入力して修正や変換を行った場合、その出力は第三者コードの二次的著作物 (https://oreil.ly/mBPyq) とみなされる可能性があります。

米国や他の多くの法域では、AIが生成した出力がトレーニングデータと実質的に類似している 場合や、著作権で保護された入力に基づく場合に、 その出力が二次的著作物に該当するかどうかは、 現在も法的議論が続いており、明確には定まっていません。

自分のものではない (あるいは、 適切にライセンスされていない) 著作権で保護されたコードを、

181

182 | 9章 バイブコーディングの倫理的課題

大量にAIツールに入力すべきではありません。なぜなら、その出力が二次的著作物 (https://oreil. ly/04ktq) とみなされ、 元の著作権コードのライセンスの下に置かれる可能性があるからです。

こうした不確実性を踏まえると、安全のためには、AIが生成したコードを曖昧なライセンスの下 にあるものとして扱い、 既存の著作権を侵害しておらず、潜在的なオープンソースライセンス上の 義務を遵守できると確信できる場合にのみ使うべきです。 AIの出力そのものの著作権の状況につい て、米国著作権局 (https://oreil.ly/YOPYG) は、 人による十分な創作性を欠いた純粋なAIの生成 物は著作権保護の対象とならないと明言しています。 人がAIの生成物を大幅に修正したり、 創造的 にアレンジした場合、その人の貢献部分は著作権保護の対象 (https://oreil.ly/NV3G1) となり得 ますが、 AIが生成した要素単独では著作権保護を受けません。 したがって、 純粋にAIのみが生成し た出力は誰の著作権にも属さない可能性があるか、 あるいは、著作権は人の創造的な貢献部分にの み及ぶと考えるのが、多くの場合賢明です。

これは仮定上の懸念ではありません。 実際、 現在も法的議論が続いています。 著名な集団訴訟 「Doev. GitHub, Inc.」 (https://githubcopilotlitigation.com) がGitHub、 Microsoft、 OpenAIに 対して提訴されており、 GitHub Copilot が適切な帰属表示やライセンス条項の遵守なしに、ライセ ンスされたオープンソースコードに過度に類似したコードを生成していると主張しています。 この 訴訟の一部の請求は棄却されたものの、控訴中であり (2025年半ば時点では、 DMCA関連の請求や 契約違反に関する訴えについて、第9巡回区控訴裁判所で審理が続いています)、 AIがトレーニング データから著作権で保護されたコードを再現したり、 近似的に言い換えることがあり、 実際そうする こともあるという、重大な懸念を浮き彫りにしています。 訴訟情報は、カリフォルニア北部地区連邦 地方裁判所や第9巡回区控訴裁判所の裁判記録 (https://oreil.ly/BdDiV)、 あるいは法律ニュース や訴訟追跡サービス (https://oreil.ly/ AZrc-) で確認できます。

古い (しかし、引き続き関連性があり、 その後裏付けられた) GitHub 自身による研究 (https:// oreil.ly/fFUUd) では、 GitHub Copilotの出力が一部のケースでトレーニングデータと一致する 提案を含んでおり、まれに長めの逐語的スニペットが出現することが指摘されています。 多くのAI ツールは、プロンプトで具体的に指示されたり、極めて標準的なアルゴリズムを扱ったりする場合を 除き、 特定可能なコードを幅広く直接コピーすることを避けるように設計されていますが、 そのリス クは存在します。 さらに、 懸念されるのはオープンソースコードだけではありません。 著作者、 アー ティスト、メディア企業によって多くの訴訟が提起されており、 彼らの完全に著作権で保護された 私有の知的財産が、 許可や対価なしに大規模言語モデルや他の生成AIシステムのトレーニングに利 用されたと主張しています。プロプライエタリなコードに関する課題は、オープンソースと異なり一 一般に公開されていないことが多いため、エンドユーザーがAIの出力がそのプライベートなコードに 偶然似ているかどうかを確認するのが難しい点にあります。

それでも、倫理的かつ慎重なプラクティスとしては、 「AIツールから受け入れるあらゆるコードは、 自分の責任であると考えて行動」すべきです。 あなたのプロジェクトに組み込む前に、 AIが生成し たコードを入念にレビューし、 テストし、理解してから、その利用が適用されるすべてのライセンス

9.1 知的財産に関する考慮事項 |

と著作権法に準拠していることを確認してください。

9.1.1 疑わしい出力を受け取った場合の対処法

AIの出力が、 既知のコードの逐語的、 あるいはそれに近いコピーのように見える場合 (特に特徴 的なコメントや著者名を含む場合)、慎重に扱ってください。 盗用検出ツールを使って類似性チェッ クを行うか、ユニークな文字列をウェブ検索して一致が見つかるか確認し、 コピーの可能性を調べ てください。

従うべきもう1つの原則は、「疑わしい場合はやめる」 です。 すなわち、 出力を使わないか、互 換性のあるライセンスの下にあることを確認し、必要なら帰属表示を行ってください。 例えば、 GitHub Copilot が、 Stack Overflowやオープンソースプロジェクトから見覚えのある有名なアル ゴリズム実装を生成した場合、 ソースを引用するか、 AIの回答を参考にしながらも逐語的に引用せ ず、 自分なりに書き直してください。

出力が既存のライブラリの実装と一致している可能性があると感じたら、(適切なライセンスの下 で) そのライブラリ自体を導入することを検討してください。 また、次のようにプロンプトでAIに指 示できます。

ライブラリからのコピーではなく、 独自の実装を提供して

そうすることで、 より独自性のある解決策が生成されることがあります(トレーニングデータの影 響を完全に排除できる保証はありませんが、少なくともそのままコピーすることは避けようとしま す)。

ここでの倫理的配慮には、AIを使って意図的に帰属表示を取り除くような行為を避けることも含 まれます。 例えば、 Stack OverflowからのコードをAI経由で帰属表示なしでコピーし、 回答者へ のクレジットを表示すべきだというポリシーを回避するような使い方は、 倫理的に問題があります。 そうした行為は、オープンな知識共有のエコシステムに対する信頼を損ないます。 適切なクレジット を付けて素材を取り入れる方が望ましいでしょう。 状況に応じて、次のような対応が考えられます。

• AIが (「John Doe 2018」 とコメントに記載されたスニペットをコピーした場合など) 著者名を 含むソースからコードコメントを書いた場合、 それを削除せずに保持するか、 適切な帰属表示 セクションに移して完全な引用情報を記載するべきです。 そうすることで、元の著作者へのク レジットを尊重することになります。

• AIが提示した解決策が、 既知のアルゴリズムやコードスニペットに由来することがわかってい る場合、 自分で調べて見つけた場合と同様に、その出典を明示してください。

・AIツールが、独自のアプローチやドキュメント用の文章といった) 創造的とみなされ得る成 果物を生成した場合、その貢献を認めてください。 AI自体に権利があるわけではありませんが、 透明性の観点から (そして技術への敬意として) そうしてください。

183

184 | 9章 バイブコーディングの倫理的課題

(MITのような) 一部のオープンソースライセンスは寛容であり、コピーしたコードであっても帰 属表示を行えばライセンス要件を満たすことができます。

一方、GPL AGPLのようなライセンスでは、そのコードを取り込むことで、あなたのコード ベース全体を 「感染」させてしまう (つまり、同じライセンスの下に置かれてしまう)ため、クローズ ドなプロジェクトにとっては望ましくありません。

要するに、AIが生成した内容にIP (知的財産) の問題があるかもしれないと感じた場合、 その出 力を使わないか、あるいは、 可能性のあるライセンスにすべて準拠するように十分に変換してくださ い。

9.1.2 グレーゾーン

これを書いている今もなお、 AI ツールは知的財産、著作権、そして倫理に関する新たな問題を提 起し続けています。 例えば、 次のものです。

あなたのバイブコーディングで、 AIを使ってドキュメント用の文章、 構成ファイル、 画像など の非コード資産を生成する場合、 知的財産に関する同様の問題が生じます。 例えば、 著作権で 保護された画像でトレーニングされたAIツールを使ってアイコン画像を生成した場合、 その新 しい画像の所有権は誰にありますか?

AIがソフトウェア製品の重要な部分を生成した場合、 そのAIのトレーニング元となったコード の元の著作者にクレジットを与えるべきですか?

AIが生成したコードが他人のコードと似ているという理由で、著作権侵害を主張される可能性 はありますか? ある程度の長さの部分が一致している可能性がある場合、 類似性チェックの出 番です。

AI企業は、ライセンスを尊重するフィルターの導入や、 開発チームが自分たちのコードをAIのト レーニングデータに含めないようオプトアウトできる仕組みを整える必要がある、という考え方が広 まりつつあります。 こうした議論は現在も進行中ですが、 現場の開発者は権利を侵害しないように 慎重に行動すべきです。

裁判所がすべての法的問題に決着をつけるには、時間がかかるでしょう。 だからこそ、 それまで は知的な誠実さと敬意を指針として行動すべきです。 AIが公表された論文に基づく既知のアルゴリ ズムを使っている場合、 コードのコメントでその論文を引用してください。 一般的なオープンソース のヘルバーコードを使っている場合、そのプロジェクトに対してクレジットを記載してください。 こ れは著作者の貢献を尊重する姿勢です。 何かの出所を認識しているなら、クレジットを与える側に 立つべきです。 これは透明性を促進する良いプラクティスです。

忘れてはならないのは、 AIの知識の裏側には、コードを公開してきた何千人もの開発者たちの貢 献があるということです。 倫理的に見ても、ソフトウェア業界はそのコミュニティに対し、 オープン ソースライセンスとその規範を尊重する責任があります。 正当なクレジットをきちんと与え、 「AIが

9.2 透明性と帰属表示

ん。

|

書いたから自分の責任ではない」という言い訳で他者の成果を濫用してはなりませ

9.2 透明性と帰属表示

「透明性」 とは、 開発プロセスや出力でのAIの使用について率直に開示することを指しており、 「帰属表示」とは、AIが生成したコードが特定可能な出典に由来する場合、 適切なクレジットを与え ることを意味します。

説明責任の観点からも、 透明性は重要です。 例えば、 AIが生成したコードにバグやセキュリティ 上の欠陥が含まれていた場合、 「このコードはAIの提案によるもの」と明示して透明性を確保して おくことで、 根本原因分析 (RCA) がしやすくなります。 もしかすると、 曖昧なプロンプトの書き直 しが必要かもしれません。 コードコメントやプロジェクトのREADME. ドキュメントなどに、「こ のプロジェクトはChatGPTなどのAIツールの支援を受けて構築されました」といった一般的な記 述を加えることもできます。 より具体的に 「CSVを解析する関数を追加 (ChatGPTの支援で生成し、 その後に修正)」のように書くことも可能です。 これは、フレームワークやライブラリの使用を明示 するのと同じようなものです。

透明性は、 信頼の構築にも不可欠です。(チームメンバー、クライアント、エンドユーザー、業界 の規制当局などの) ステークホルダーは、あなたのソフトウェアがどのように開発、 妥当性確認され たかを知りたがるかもしれません。 AIがコード生成に関与していた場合、 ステークホルダーによっ てはAIの信頼度を過大評価したり、逆に過小評価したりする可能性があります。 透明性があれば、 信頼性についての対話が可能になります。 例えば 「はい、AIを使いましたが、徹底的にテスト済み です」 や 「この部分は難しかったので、AIに初期コードを生成させた後、私たちで検証しました」と いった説明ができます。

多くの学術分野では、 帰属表示が期待されるか、あるいは義務付けられています。 オープンソー スプロジェクトの中には、 知的財産の懸念から、AIによる貢献を制限したり、完全に禁止したりし ているものもあるため、 AIを使う前に貢献者ガイドラインを確認してください。 バッチがAIによっ て生成されたものである場合、 メンテナーに対してその事実を明示することで、 特にライセンスに関 する懸念がある場合に、 評価の助けになります。

実際、 規制の厳しい業界の中には、監査目的でソフトウェアベンダーに対しAIの使用を開示す ることを義務付けているところもあります。 EUのAI法 (https://oreil.ly/wDNKs) では、(クレ ジットスコアリングのアルゴリズムなど) 個人に影響を与える自動意思決定に対して、 透明性を求め ています。 バイブコーディングによってそのようなシステムが構築される場合、ユーザーに対して 「この推薦は自動的に生成されており、 データの傾向を反映している可能性があります」 と通知する ことが、 法的、倫理的に不可欠となります。

同様に、あなたのプロダクトが、(ユーザーが提供したコード例などの) ユーザーデータや独自 データをAIモデルに入力して、 ファインチューニングを行い、 分析機能の向上に役立てている場合、 プライバシーポリシーに「ユーザーデータは、許可を得た上でAIモデルの改善に使用されることが

185

186 | 9章 バイブコーディングの倫理的課題

「あります」 と明記する必要があるかもしれません(いつものことですが、 法的な判断については、必 ず弁護士に相談してください)。 透明性はプライバシーの問題とも密接に関わっています。

また、使ったツールや参照元を明示することは、一般的な倫理的態度として重要です。 もしコー ドの30% が GitHub Copilot によって生成されたのなら、 ドキュメントや社内コミュニケーションで それを記載するのは公平なことです。 自分の役割を矮小化するためではなく、 プロセスについて誠 実であるためです。

一部の開発者は、 AIの助けを借りたことを認めると、 自分の貢献やスキルが過小評価されたり、 「不正行為」 とみなされたりするのではないかと恐れるかもしれません。 しかし、 バイブコーディン グが一般化するにつれて、このような汚名は次第に薄れていくでしょう。 やがて、 利用可能なAIを 使わない」ことの方が、 時代遅れと見られるようになるかもしれません。 私たちは、AIをツールと して正しく位置づける必要があります。 それはStack OverflowやIDEを使うのと同じであり、「不 「正行為」ではありません。

その一方で、 過剰に免責事項を提示すると、 不要な不安を招く可能性があります。 クライアント に「この製品はAIを使ってコーディングしました」と伝えると、 (たとえそれが誤解によるもので あっても) 安全性に疑念を抱かれるかもしれません。重要なのは表現の仕方です。 続けて、品質対策 を強調してください。 「高度なコーディングアシスタントを活用して開発を加速しましたが、 AIが生 成したコードはすべて厳格にレビューとテストを行い、 当社の品質基準を満たしています」と説明す るのです。

要するに、透明性と帰属表示は信頼とコミュニティの価値を育みます。 これによって、 人の作成 者に正しくクレジットが渡り、 私たちは、ソフトウェアがどのように構築されたかについて誠実であ り続けることができます。 これは、 芸術家が自らの道具やインスピレーションを列挙するのに似てい ます。 作品の価値を損なうのではなく、その文脈を与えるのです。 私と同じように、 あなたもバイブ コーディングを広く受け入れられるものにしたいなら、 AIを使っていること、そしてそのリスクを どのように軽減しているかを率直に示すことが重要です。

9.3 バイアスと公平性

本書のこの時点までにあなたは十分理解されていると思いますが、 AIモデルの出力は、トレーニ ングデータを反映しています。 そのデータにバイアスや排除的なパターンが含まれている場合、モ デルは偏ったり不公平な出力を生成する可能性があります。

「コードが偏るなんてあり得る? LLMが採用判断をしているわけでもないのに」と思うかもしれま せん。 しかし、 バイアスは微妙な形であなたのコーディングに入り込む可能性があります。

●多くの場合、コードはその作成者の想定を反映しています。 AIが生成するユーザー向けのテキ ストやコンテンツには、トレーニングデータに含まれる文化的バイアスや不適切な言葉が反映 されることがあります。 例えば、 2016年に公開された初期のチャットボットである Microsoft

9.3 バイアスと公平性 | 187

のTay (https://oreil.ly/d8wxO) は、 公開から数時間以内にTwitter上の対話から人種差別 的、女性蔑視的なスラングを模倣するようになったことで悪名を馳せました。

● また、 想定が、 (自動車所有、 特定技術への普遍的アクセスを想定するなどの) 中産階級の北 米的ライフスタイルといった、 特定の文化的規範に依拠することがあります。 未検討の想定が 排他的な製品につながった顕著な例として、 初期のAppleのHealthアプリの2014年リリース (https://oreil.ly/67sZG) には月経トラッカーが欠落しており、 設計チームの多様性や視点の 不足が原因と考えられます。 さらに、サンプルコードやコメント、 合成データにおいても、 モデ ルが常に 「he/him」 (彼) の代名詞を使う可能性があり、ジェンダーバイアスを強化することに なります。

●コードリポジトリや幅広いソフトウェア開発の世界が、 主に西洋的視点と英語話者を反映して ことはよく知られています。 そのため、 これらのリポジトリでトレーニングされたAIは、国際 化の重要な側面を見落とす可能性があります。 (中国語、日本語、韓国語、アラビア語、ヒン ディー語など、 非ラテン文字や音節文字を使う言語に不可欠な) Unicodeやマルチバイト文字 への適切な対応を欠いたり、 型名などの例を英語中心に提示したりすることがあります。 開発 者は、AIが自発的に対応しなくても、 国際化を意識して設計、実装する必要があります。

アルゴリズムを書く場合、人種、性別、年齢など、 特定の変数を扱う際には注意が必要です。 AIは、指示されない限り、 自発的にこれらを含めない場合もあります。 しかし、AIが誤って基 準をハルシネーションしたり、データセットにコードアシスタントのようなAIを使ったりする なら、公平性の制約を適用してください。 AIは道徳的、 法的なコンテキストを本質的に理解し ているわけではありません。

単なるコーディングにとどまらず、モデルはそのコンテンツ領域での「データバイアス」、つまり、 トレーニングデータに存在する歴史的なバイアスを反映することがあります。 例えば、ローン承認の ためのクレジットスコアリングアルゴリズムのコードを作成するように、AIに指示した場合を考え てみましょう。 米国のクレジットスコアリングシステムには、人種的バイアスを反映し、さらにそれ を固定化してきた歴史が記録されています。 こういったバイアスは、赤線引きや他の制度的差別と いった歴史的慣行に起因し、 特に黒人コミュニティや他の周縁化されたグループに長期的に経済的 影響を及ぼしてきました (政府の政策がいかに米国社会を分断してきたかについての包括的な歴史に ついては、リチャード・ロススタインの 「The Color of Law」 (Economic Policy Institute、2017年) を参照)。

トレーニングデータがこうした歴史的バイアスを反映している場合、 AIは差別的な変数を取り込 んでしまう可能性があります。 たとえば、 郵便番号を利用することは、住宅の分断的なパターンに より人種的な人口構成の代理指標となり得ますし、他の一見中立的なデータポイントも、保護され るべき属性と相関してしまうことがあります。 適切に導かれなければ、AIは銀行に不公平な融資判 断をさせるコードを生成し、 歴史的な不平等を固定化し、現実の人々の生活に影響を及ぼす可能性

188 | 9章 バイブコーディングの倫理的課題

があります。 同様の問題は、予測的警察活動アルゴリズムの分野でも生じます。 そこでは、 (バイア スを含む可能性のある) 過去の逮捕データが、 特定のコミュニティを偏って対象にする (https:// oreil.ly/H4rmr) AIシステムにつながる可能性があります。

同様に、(医療ソフトウェア用にファインチューニングされたAIコードアシスタントのような) 専 門モデルを使う場合、 その分野のデータに内在するバイアスに縛られていないことを確認してくださ い。歴史的に一部の医療ガイドラインは主に男性被験者を対象とした研究に偏っており、 その結果、 他の性別に対して誤診や効果の低い治療につながった例があります。 AIが医療診断用のコードや解 決策を推奨するなら、 あなたは、AIがうっかりこういったバイアスを組み込んでいないかを再確認 する必要があります。

AIの出力に含まれるバイアスを検出するためのツールが登場しつつありますが、こういったツー ルはコンテンツ生成に用いられるGPTモデルでより一般的です。 AIプロバイダー自身も、露骨に 偏ったり有害な出力をフィルタリングしようとしています。 コード指向のAIが自発的にヘイトス ピーチを生成することはまれですが、そのためのコンテンツフィルターが備わっているのは望ましい ことです。 倫理的な制約を組み込むということは、多くのAIツールにおいて、 ユーザーがAIにマル ウェアや差別的なアルゴリズムを生成させようとした場合に、 AIが拒否することを意味します。 こ ういったフィルターを破って非倫理的なな出力を得ようとしないでください。

開発プロセスのさまざまな段階でバイアスを認識、 緩和する方法は、 他にも数多く存在します。 次のようなものがあります。

多様な例によるテスト

AIがユーザー向けのコンポーネントや人に関連するデータを扱うロジックを生成する場合、多 様な入力でテストしてください。 例えば、 AI が生成したフォーム検証が 「First Name」 (名)、 「Last Name」 (姓) を期待している場合、 一部の文化では一般的な単一の名前を許容しています か? もしそうでないなら、それは想定にバイアスがあるということです。 サンプルのユーザー 名を生成する際に、それらはすべて 「JohnDoe」 のような形式ですか? もしそうなら、例にもっ と多様性を取り入れることを検討してください。

包括性のためのプロンプティング

中立的または包括的であるように、 AIに明示的に指示できます。 「さまざまな文化圏の名前を 使って、例を生成して」といった具合です。 AIが常にユーザーを 「he」 (彼) と呼ぶなら、 あな たは次のようにプロンプトで指示します。

このコードのコメントでは性別を限定する言葉を避け、 中立的な表現や they/them の代名詞を使 用して。

また、AIが生成するジョークや例が文化的に不適切になる可能性があるため、注意してくださ い。 そのような場合、プロの口調を使うように、 プロンプトでAIに指示して、回避できます。

9.4 責任ある AI利用のための黄金律 |

通常、AIはそれに従います。 AIには意図や目的があるわけではありません。 指示されない限 り、普通だとみなすものを出力するだけです。 私たちがその 「普通」を形作るのです。

多様なチームを雇う

多様なチームで出力をレビューすることで、問題を見つけられる場合があります。 例えば、 「ね え、私たちのAIがいつも foo/ barのような変数名を選ぶのはいいとしても、 ドキュメントで登 場人物がすべて男性になっている」と指摘されるかもしれません。 その場合、 それを体系的に修 正してください。 すべての開発者が似たような背景を持っていると、 微妙なバイアスに気付か ないことがあります。 可能なら、 AI利用ガイドラインをレビューする際に、 代表的ではないグ ループの人々を参加させるか、 少なくとも彼らの視点を考慮してください。

まとめると、 バイアスと公平性とは、バイブコーディングツールを用いて、 あらゆる背景を持つ ユーザーに対して公平であり、歴史的な差別を反映したり(さらに悪いこととして) 永続させたりし ないコードを生成することです。 チームでこういったツールを使う方法も、異なるレベルや背景を持 つ開発者や同僚に対して公平であるべきです。 特にジュニア開発者にとって、 AIツールが職場をど のように変えつつあるかの倫理的影響については、 「4章 70% を超えて人の貢献を最大化する」 を参照してください。

9.4 責任あるAI利用のための黄金律

これまでに扱ってきた多くのことをまとめて、 バイブコーディングにおける一連の責任あるプラク ティスを明確にする価値があります。

1. 常にヒューマンインザループを維持する

繰り返しますが、決してAIを監督なしに動作させないでください。 責任あるAI支援開発とは、 開発者であるあなたがすべての行をレビューし、 意思決定を行うことであり、人の妥当性確認 なしに素のAIの出力をそのままデプロイすることではありません。 2. 自分のコードに責任を持つ

何か問題が起きても、 それはAIの責任ではなく、 開発チームの責任です。 この心構えを持つこ とで、惰性に陥るのを防げます。 自分でゼロから書いても、AIが生成したものを受け入れても、 あなたのコードを正当化できる準備をしてください。 誰かに「なぜこのコードはこうしているの か?」と聞かれた時に、「わからない、 GitHub Copilotがそうした」 と答えないでください。 だ からこそ「3章 70% 問題: 実際に動作するAI支援ワークフロー」の黄金律の1つは、「完全に 理解していないコードを決してコミットしない」 なのです。 これこそが責任あるエンジニアリン グです。

3. ユーザーのプライバシーを守り、同意を求める

倫理的観点から、 あなたには、ユーザーや自社の秘密データを秘密のまま保持する義務があり

189

190 | 9章 バイブコーディングの倫理的課題

ます。 AIツール、特にクラウドベースのものを使う際、プロンプトや会話の中で機密データを 公開しないように注意してください。 例えば、 ユーザーデータベースの問題をデバッグしている 場合、実際のユーザーレコードをChatGPTに入力しないでください。 代わりに、サニタイズ済 みデータや合成データを使ってください。

現在、 多くのツールではユーザー (少なくともビジネスユーザー) が、 自分の入力データをトレー ニングに利用されないようにオプトアウトできるようになっています。 あなたが企業ユーザーな ら、その設定を利用するか、 機密性の高いコードにはオンプレミスのソリューションを使ってく ださい。 ユーザーデータをモデルに入力する場合や、 (LLMを使うアプリ内のチャットボットな ど) AI機能がユーザーに直接触れる場合、ユーザーの同意を得て、 適切ならユーザーがオプト アウトできるようにしてください。 「この機能はAIサービスを利用しています。 入力内容は処理 のためにAIサービスに送信されます」 といった警告は透明性があり、 プライバシーを重視する ユーザーが自ら判断できるようにします。

4. 法律や規制を遵守する

AIに関する法的要件は常に進化しているため、 注意を払ってください。 例えば、EUの一般デー タ保護規則 (GDPR) やAI法といったデータ保護法では、 AIの出力に個人データが含まれてい る場合、それを個人データとして扱います。 ユーザーデータでモデルをトレーニングさせる場合、 そのユーザーの同意が必要となる可能性があります。 規制当局はコード生成を 「汎用AI」に分類 し、透明性やリスク管理の義務を課す場合もあります。 最新情報を常に把握し、法務、 コンプ ライアンスの専門家と緊密に連携して、規制違反を避けてください

言うまでもありませんが、 AIを使ってマルウェアを生成したり、 倫理的に正当な理由なくコー ドを悪用したり、 非倫理的または違法な行為を自動化しないでください。 AIは非常に効果的な フィッシングメールやコードインジェクション攻撃を書くことも可能でしょうが、 そのような目 的で利用することは倫理に反し、 多くの国の法律に違反し、さらにAIの利用規約にも抵触する 可能性があります。 建設的な利用に集中してください。

5. 組織内に責任ある AI 文化を醸成する

チームがバイブコーディングを採用する場合、 倫理についての議論を促し、 関連する倫理研修 を提供してください。 開発者やコードレビュー担当者に、 図9-1のような簡潔なチェックリスト を活用させることを検討してください。

*1 倫理的に正当化される例外も存在します。 ペネトレーションテスト担当者やセキュリティ研究者は、責任ある情報公開プロト コルの下で活動する限り、修正すべき脆弱性を見つけるためにAIを利用することが倫理的に認められます。

9.4 責任ある AI利用のための黄金律 |

Al 責任ある AIチェックリスト VIPチェック ✓バイアスの レビュー ●セキュリティ 監查

AI生成コードをマージする前に行う

図9-1 責任あるAI開発のチェックリスト。 AI が生成したコードを本番システムに統合する前の、 知的財産のレ ビュー、 バイアスの評価、セキュリティ監査といった必須の妥当性確認手順。

倫理的なAI利用については、誰もが責任を感じるべきです。 これは特定の瞬間にツールを使っ ている個人だけの負担ではなく、集団的な取り組みです。 これを制度化するために、 チームや 組織内に 「倫理チャンピオン」 を任命したり、小規模な倫理委員会を設置することを検討してく ださい。 (その責任は共有されたままなので) この個人やグループが倫理の唯一の責任者になる わけではなく、次のことについて主導的な役割を担うことになります。

• AI倫理の最新動向、 新たなベストプラクティス、 新たな規制の状況を常に把握する

具体的なプロジェクトにおける倫理的配慮についての議論を促進する

● 開発ライフサイクルへの倫理原則の統合を推進する

関連リソースや研修資料を収集し、チーム全体に広める

・倫理的な質問や懸念を持つチームメンバーの窓口となる

この分野は非常に速いペースで進化しているため、チームとして協力し、AIツールの新バー ジョンやその機能、 制約、 そして責任ある利用に向けて進化するベストプラクティスについて、 常に最新情報を把握することが重要です。

この分野は急速に進化しているため、チームで協力し、 AIツールの新バージョンやベストプラ クティスについて常に最新情報を把握することが重要です。 ワークフローに統合すべき重要な 概念の1つが、モデルカードの利用です。 「モデルカード」とは、 機械学習モデルに関する透明 性を提供する標準化されたドキュメントです。 AIモデルの栄養成分表示ラベルのようなものだ と考えてください。 通常、 それには次のような詳細が含まれています。

• モデルの内容、 バージョン、開発時期

•モデルが設計、テストされた具体的な使用例

限界や危害の可能性のために、 モデルを使うべきでないシナリオ

異なる人口統計グループ間での公平性やバイアスの評価を含む、 さまざまなベンチマーク でのモデルのパフォーマンス

●データの既知の制限やバイアスを含む、モデルのトレーニングに使われたデータセットに

191

192 | 9章 バイブコーディングの倫理的課題

関する情報

潜在的なリスクと社会的影響、 および採用された緩和戦略

事前学習済みモデルを利用する場合や、 使うモデルを評価する場合にはいつでも、そのモデル カードを確認してください。 モデルをファインチューニングしたり新たに開発する場合には、自 分自身のモデルカードを作成することがベストプラクティスです。

6. ガードレールと安全網を作成する

責任ある設計を実践するということは、AIが生成するシステムに安全網を備えるべきであるこ とを意味します。 例えば、 AIが範囲外のインデックスの修正を提案したとしても、それが根本 的な問題を覆い隠す可能性があるなら、静かに誤動作するよりも安全に失敗する方が望ましい のです。 AIが生成した推薦システムが誤っている可能性がある場合、 ユーザーが修正や上書き できる仕組みを提供することは、 人の主体性を尊重することにつながります。 AIコンポーネン トが不具合を起こしたとしても、システムが優雅に劣化 (段階的に品質低下) するように構築す ることを目指してください。

7. チーム内で AI の使用に関する決定を文書化する

特定のAI提案を採用した (あるいは採用しなかった) 理由を、 内部ログとして記録してください。 「モジュールXにAIを試したが、 重複コードが多く生成される傾向があったため、 その部分は手 「作業で書いた」 などです。 このような記録はプロセスの改善に役立ち、 コードベースの履歴にお けるAIの役割について新しいチームメンバーに状況を伝え、チームの集合的記憶を補強します。 また、監査の際にも有用です。

8. バイアス、 差別、 不公平を避けるために積極的に取り組む

AIの利用が差別につながる可能性がある兆候に注意を払い、 そのような事態を未然に防ぐよう 努めてください。 例えば、 あなたのアプリがグローバル展開されている場合、 AIは多言語対応 していますか、それとも英語話者を優遇していますか? チームメンバー全員が、AIのツールや 研修に平等にアクセスできますか?

責任あるAIチェックリスト

1.プロンプトとコード生成 (開発者)

□プロンプトに、顧客情報、 PII、 シークレットなどの秘密データ、 機密データが含まれて いないことを確認する。

□ すべての出力のライセンスを確認し、許可されている場合を除き、プロプライエタリな コード、 GPLコードが含まれていないことを確認する。 スキャナーチェックにFOSSA のようなツールを使う。

□コードやコメントが固定観念や差別を助長しないように、出力にバイアスがないかテスト する。

9.4 責任ある AI利用のための黄金律 | 193

□ デフォルトで安全になるようにプロンプトで指示することによって、セキュリティ衛生を 確認する。 コードが安全でないパターン (eval、 サニタイズされていない入力)を避けて いることを確認する。

□スタイル、フレームワーク、パフォーマンスのニーズ、 互換性ガイドラインなど、あらゆ る制約をプロンプトで指定する。

2. コードレビューのチェック (開発者とコードレビュアー)

□ ライセンスがない限り、 コードに埋め込まれた著作物が使われていないことを確認する。 □ 必要な場合には、 帰属表示とクレジットが与えられていることを確認する。

□特にユーザー / UIレイヤーで、 バイアスや公平性について、 ロジック、言語、名前付け を監査する。

□コードが危害、 誤用、 操作、 差別を助長しないことを確認する。

□入力サニタイズ、データ処理、 ロギングを検証し、 秘密の漏洩がないかを確認する。 □単体テスト、エッジケース、エラー処理、テストカバレッジによって、 コードの機能と正 確性を確認する。

□非効率なパターンや電力を消費するパターンがないか確認する。

依存関係を確認し、 未審査のライブラリや隠れたライセンスリスクが含まれていないこ とを確認する。

☐ ☐ 可読性と保守性を確認する。 コードはスタイルガイドに従い、 明確な名前付け規則を使う。 使われていないコードが除去されているか確認する。

☐ 特にAIが生成したロジックについて、 コードのコメントがコードの意図を説明している ことを確認する。

□コードレビューのフィードバックが、敬意を払い、具体的で、 共感的であることを確認 する。

3. ガバナンスとプロセス (組織)

□ 統合ライセンススキャナー、 監査ログ、プロベナンス (出自) 遺跡が実施されていること を確認する。

□ 倫理とAI支援コーディングに関する研修を提供し、更新を定期的に共有する。

□AIツールの吟味されたリストを維持し、 未承認のものやリスクの高いものを禁止する。

□インシデントプロセスを導入し、倫理に反するコードを見つけた場合のエスカレーション チャネルや内部告発のオプションを設ける。

□バイアスのインシデント、セキュリティ上の発見、ライセンス違反など、責任あるAIの メトリクスを監視する。 こういったメトリクスのチェックリストを維持し、 定期的に改訂 する。

□コミュニティからのフィードバックを求め、 耳を傾ける。 振り返りミーティングや外部監 査を通じて、 多様な視点を取り入れる。

194 | 9章 バイブコーディングの倫理的課題

このチェックリストの使い方

このリストをカスタマイズして、組織やビジネスドメイン、チームの技術、 リスク許容度、 価値観に特化した質問を含める。

・ 小さく始める。 「機密データを避けたか?」 や 「ライセンスをスキャンしたか?」といった重 要な質問から始める。

PRテンプレート、CIパイプライン、 コードレビューツールを使って、確認とチェックリス トをワークフローに統合する。

四半期ごと、 あるいは大きなインシデントが発生した後に、このチェックリストのレビュー を予定に入れる。 このレビューを使って、 新しい項目を追加したり、 不要な項目を削除し たりして、リストを反復する。

このチェックリストを、堅苦しいルールブックとしてではなく、 パイロットや外科医が チェックリストを使うように、会話のきっかけとして扱う。

AIの状況が変化し成長し続けるにつれて、ソフトウェア業界はAIに関する標準や認定を導入する 可能性が高いでしょう。 まだ時期尚早ではありますが、 企業が、 AIソフトウェアエンジニアリング に関するIEEEやISOのワーキンググループなどの標準化活動に参加することで、そのガイドライ ンの策定に貢献することもできます。 倫理的な観点からも、規制当局や裁判所だけに任せるのでは なく、開発者コミュニティが規則の策定に協力する方が望ましいのです。

9.5 まとめと次の一歩

責任あるバイブコーディングとは、AIをソフトウェア開発ライフサイクルに統合する際に、 すべ てのステークホルダーを尊重することを意味します。 すなわち、 (知的財産の尊重によって) 元の作 成者を、(透明性と公平性を通して) 同僚を、(プライバシー、セキュリティ、 結果の公平性を通し て) ユーザーを、 そして (悪用による害を防ぐことによって) 社会を尊重します。 AIの強みを活かし つつ、その弱みに注意深く対処することが求められます。

私はよく、バイブコーディングは低品質な作業の言い訳にはならないと述べてきました。 それは、 倫理的な抜け道の言い訳にもなりません。 責任を担う人として、開発者は速度が価値を損なわない ようにしなければなりません。

次の 「10章 自律型バックグラウンドコーディングエージェント」 では、AIモデルの扱い方を変 えつつある新しい技術、 つまり自律型コーディングエージェントを取り上げます。

| 195

10章

自律型バックグラウンド コーディングエージェント

「自律型バックグラウンドコーディングエージェント」は、AIコーディングツールの次なる進化と して急速に台頭しつつあります。 従来の「コパイロット」 アシスタントが、あなたが入力中にコード を提案するのとは異なり、 こういったエージェントは、非同期でタスク全体を任せられるバックグラ ウンドのジュニア開発者のように機能します。 コードはエージェント専用の隔離された環境で生成さ テストも実行可能であり、 多くの場合、その結果は、 あなたがレビューできる完成済みのプルリ クエストとして返ってきます。

本節では、バックグラウンドコーディングエージェントとは何か、 その仕組み、 (OpenAl Codex、 Google Jules、 Cursor Devin といった) 現在利用可能なツール群、 そして従来のIDEアシスタン トとの比較について掘り下げます。 さらに、こういったエージェントが持つ能力と限界、そしてソフ トウェアエンジニアリングの未来に向けた実践的な変化の兆しについても考察します。

10.1 コパイロット型から自律型エージェントへ: バックグラウンドコーディングエージェントとは何か?

(Cursor, GitHub Copilot, ClineなどのVS Code拡張機能といった) 従来のAIコーディング アシスタントは、 「監督型コーディングエージェント」 と呼ばれる存在です。 これは、開発者のプロ ンプトやインラインのコンテキストに反応する、 対話型ヘルパーです。 本質的には 「超高性能な自動 補完」 であり、 チャットやコード入力中に提案を生成しますが、すべての手順を導くのは、あくまで 「運転席」に座っている人の開発者です。

対照的に、 自律型バックグラウンドコーディングエージェントは、はるかに高い独立性を持って動 作します。 あなたがエージェントに高レベルのタスクや目標を与えてから、 「エージェントを送り出 すと」、エージェントが継続的な監督なしに自律的に問題解決に取り組みます。 こういったエージェ ントは、コードベースを読み取って修正し、 計画を立て、コードを実行し (テストやコマンドすらも 実行し)、 結果 (多くの場合、 コミットやプルリクエスト)を生成します。 すべてが、 非同期のワーク フローで行われます。

196 | 10章 自律型バックグラウンドコーディングエージェント

コパイロット (副操縦士) とオートパイロット (自動操縦) の違いを思い浮かべてください。 (GitHub Copilot のような) コパイロットは常にコックピットであなたの隣にいて、 あなたの入力を 待っています。 一方、オートパイロット(バックグラウンドエージェント) は、 しばらくの間、自律 的に飛行機を操縦できます。 この自律性によって、 バックグラウンドエージェントは複数の手順にわ たるコーディングタスクに取り組むことができ、 あなたは別の作業に集中できます。 Codex や Jules のような非同期エージェントを使うことは、 認知の帯域幅を拡張するようなものです。 あなたはAI にタスクを送り、それが完了するまで忘れておけるのです。 AIとのシングルスレッドの行き来では なく、突然マルチスレッドのワークフローが実現します。 エージェントはあなたと並行して作業し、 まるで有能なジュニア開発者が裏方で動いているかのようです。

重要なのは、バックグラウンドエージェントが、 あなたのエディター内で直接動作するのではなく、 隔離された開発環境 (多くの場合、 クラウド上のVMやコンテナー) で動作する点です。 こういった エージェントは、リポジトリをサンドボックス環境にクローンし、 依存関係をインストールし、プロ ジェクトのビルドやテストに必要なツールを備えています。 セキュリティの観点から、こういったサ ンドボックスは「明示的に許可されない限り、 インターネットアクセス不可」 といった規則がある) 制限された一時的な環境です。 エージェントは、ローカルマシンにリスクを与えることなく、コンパ イラー、テスト、リンターなどを実行できます。 タスクが完了すると、エージェントはコードの変更 (差分) と実行内容の要約を出力します。 通常、 これは (コードの差分、コミットメッセージ、 場合に よっては説明を備えた) プルリクエストの形式で提出され、 あなたはそれをレビューしてマージでき ます。

まとめると、 バックグラウンドコーディングエージェントとは、 AI駆動の自律型コーダーです。 エージェントはあなたの意図を理解し、サンドボックス環境内でコードの読み書きやテストを行って タスク全体に取り組み、 あなたがレビューできるようにその結果を届けます。 単に数行のコードを提 案するだけではなく、次のようなより幅広いタスクを処理できる能力を備えています。

•コードベース全体にわたって、 新機能Xを書く。

効率化のために、モジュールYをリファクタリングする。

このプロジェクトの依存関係をアップグレードする。

これは、AIを開発ワークフローに取り入れる方法における本質的な転換を意味します。 補助的な 提案から 「実際の実装作業」の委任へと移行しつつあるのです。

10.2 自律型コーディングエージェントは どのように動作するか?

内部では、ほとんどのバックグラウンドエージェントは、 「計画、 実行、 検証、 報告」 という類似 した動作パターンに従っています。 それぞれの手順とその機能について、順を追って確認していき

ましょう。

10.2 自律型コーディングエージェントはどのように動作するか? | 197

10.2.1 計画

(通常、 あなたが望む内容を説明したプロンプトやコマンドを通して) エージェントにタスクを与 えると、エージェントはまず要求を解析し、攻撃計画を立てます。 進む前にこの計画を明示的に示 すエージェントもあります。 例えば、 Google のJulesは実行計画を示し、コーディングの開始前に、 あなたは実行計画をレビュー、調整できます。 これによって、 「エージェントがあなたの要求を正し く理解したかどうか不安になること」を防げます。 優れたエージェントは、次のようにタスクを複数 の手順に分解します。

手順1: コードベースで関連セクションを検索する

手順2:ファイルA、B、Cに変更を加える

手順3:テストを実行する

手順4: 変更をコミットする

この計画段階は、効果的な自律性にとって重要です。 それは、AIが作業に取りかかる前に「どの 「ように」 あなたの目標を達成するかを推論する方法なのです。

エージェントは、タスク専用の開発環境を立ち上げます。 例えば、 Julesは 「あなたのコードベー スを安全なGoogle Cloud VM にクローンし」、 そこで非同期で作業を進めます。 OpenAIのCodex も同様に、 あなたのリポジトリが事前ロードされた独自のクラウドサンドボックスで、各タスクを 実行します。 Cursorのバックグラウンドエージェントのようなツールは、 Ubuntu ベースのリモー トマシンを使います。 このマシンは、インターネットアクセス可能でパッケージをインストールでき、 Dockerやスナップショットによるカスタマイズも可能です。 環境に必要な依存関係 (適切な言語ラ ンタイムやビルドツールなど) を揃えることは、 非常に重要である一方で容易ではありません。 以前 の分析でも述べたように、 「エージェントに最適な環境をスムーズに立ち上げる体験を設計すること が重要であり、 その設定体験はCIパイプライン以上に苛立たしい場合もある」 と言えます。 それで も、エージェントは設定ファイルでセットアップ手順を指定できるようにすることで、この課題に取 り組んでいます。 最終的な目標は、クラウド上の開発環境を構築し、 人間の開発者がプロジェクト のコードやテストを正常に実行するために必要な環境を再現することです。

注目すべきは、 多くのエージェントがセットアップ後にコードからのインターネットアクセスを無 効化し、 無許可のデータ流出や無制限のインターネット呼び出しを防ぎながらサンドボックス内で実 行できるようにしている点です。 一方、 特定の用途に限って制御されたインターネット利用を許可し ているエージェントもあります。 例えば、 OpenAIは最近、パッケージの更新やドキュメント取得と いったCodexのタスクに対応するため、オプションでインターネットアクセスを有効化できるよう にしました。

198 | 10章 自律型バックグラウンドコーディングエージェント

10.2.2 実行

次はいよいよ本番です。 エージェントは計画に従ってコードの記述や修正を開始します。 コー ディングに特化してファインチューニングされた大規模言語モデル (あるいは、いくつかのモデルの 組み合わせ) を備えているため、複数のファイルを読み取り、 新しいコードを生成し、必要なら新し いファイルを作成できます。 ここでは、エージェントはまさにプログラマーのように振る舞います。 変更すべき箇所を特定し、 コードを編集し、 新しいロジックを挿入するのです。

初期の実行から得られた興味深い観察として、 多くのエージェントはコードベースの関連部分を 見つけるために、多くの場合 (Unixのgrepコマンドのような) ブルートフォース (総当たり) のテキ スト検索を使います。 例えば、 関数名やキーワードを検索して、 リポジトリのどこを変更すべきかを 判断するのです。これは驚くほど単純に見えます。 「高度なセマンティックコード検索や、 AST (抽 象構文木) ベースの解析を使うべきではないか?」と思うかもしれません。 しかし実際には、この方 法は効果的で信頼性があります。 ビルギッタ・ベッケラーが指摘しているように (https://oreil.ly/ wDSkr)、 多くのコーディングエージェントはより高度なテクニックが存在するにもかかわらず、 あ えて単純な全文検索をデフォルトとして採用しており、 それが最も幅広く有効な手法だと考えている のかもしれません。

エージェントがコードを編集している間、 リアルタイムのログやステータス更新を提供し、 必要 ならあなたが進行状況を追えるようにしているシステムもあります。 OpenAI Codex は、 エージェ ントがタスクを進める際の 「思考」 やコマンドを要約したログを公開します。 Cursorでは、 「ステー タスを確認し、エージェントが動作しているマシンに入る」ことで、 途中経過を観察したり、場合に よっては介入することも可能です。 もっとも、 実際の狙いは常に付きっきりで監督することではなく、 エージェントをオートパイロットで走らせておける点にあります。

10.2.3 検証する

こういったエージェントの大きな特徴は、コードを書くだけで終わらないことです。 多くの場合、 コードをコンパイルし、 「テストを実行して変更を検証」 します。 例えば、 OpenAI のCodexは、テ ストを通過する結果を得るまで反復的にテストを実行するように設計されています。 エージェン トがプロジェクトのテストスイート (あるいは、少なくとも関連する一部のテスト) を実行できれば、 間違いを検出し、その後の反復で自動的に修正することが可能です。 これは非常に大きな進歩です。 AIが単にコードを 「生成」するだけでなく、「デバッグ」 し 「検証」する段階にまで踏み込むのです。

理論的には、堅牢なテストハーネスを備えたエージェントは、 「ヒューマンインザループなしで」 修正を試み、テストが失敗したらコードを調整し、テストを通過するまでこれを繰り返すことができ ます。 しかし実際には、環境の問題がこれを妨げることがあります。 私が調査したあるケースでは、 Codex が (特定のツールが欠けていたという) 環境の不一致によって完全なテストスイートを実行で きず、結果として2件のテストが失敗したままでプルリクエストを提出してしまいました。 環境が完 全に整っていたら、 エージェントはその些細な問題をPR作成前に修正できていたはずです。

10.2 自律型コーディングエージェントはどのように動作するか? | 199

これは、自律型エージェントにとって環境のセットアップがいかに重要かを強調しています。 開 発者が行うすべての処理 (リンター、テスト、ビルド) を実行できれば、 多くのエラーを自動的に自 己修正できるからです。 Devinのようなエージェントは、このループを重視しています。 Devinは、 「コードを書き、バグを見つけ、コードを修正し、 独自のエンドツーエンドテストを実行し、動作を 検証する」ことを、 通常の動作の一部として行います。 さらにDevin は、 ライブプレビューとして自 分が構築したフロントエンドアプリをデプロイするので、あなたはブラウザー上で機能を手動で確認 できます。 これは、 検証手順を巧みに拡張したものです。

10.2.4 レポート

エージェントが、 (すべてのテストを通過し、 コードが完成したと判断して) 候補となる解決策を 得ると、その結果をあなたに示します。 プラットフォームによって、 GitHub上のプルリクエストと して届く場合や、チャット内で差分と説明が示される場合、 マージ可能なファイルとして示される場 合があります。

この段階で、 「人である」 あなたがレビューを行います。 ここで再び、 「信頼せよ、されど確認せ よ」 (Trust but verify) という考え方に立ち返ります。 つまり、 あなたは、 エージェントが有用な結 果を出すことを信頼しつつも、 コードレビューや追加のテストを通して変更内容を検証するのです。 多くのエージェントシステムは、 開発者にとってなじみのあるワークフローであるPRレビューのプ ロセスに、明示的に統合されています。 例えば、 JulesはGitHubに接続し、変更を含むブランチと PRを自動的に作成します。 OpenAIのCodex は ChatGPT内に差分を示し、 あなたが承認したり 追加の質問をしたりできるようにします。 問題を見つけたり変更要求があったりしたら、それをエー ジェントにフィードバックし、次の反復に反映させることも可能です。

チャット経由でこれに対処するエージェントもあります。 (例えばDevin は、リンクされたSlack スレッドからフィードバックを受け取れます。 あなたが問題を指摘したり調整を頼んだりすると、 Devin はそれに対処するために 「返信の作業を開始」 します)。調整したプロンプトで新しい実行を 必要としたり、 レビューコメント用のインターフェイスを使ったりするエージェントもあります。 印 象的なのは、 Devin が GitHubのPRコメントで「なぜ」 その変更を行ったのかという質問に答えた ことです。 Devin はまず「目」の絵文字でコメントを確認したことを示し、その後、自らの推論を詳 しく説明しました (その説明が完全に正確ではないことが判明しましたが、 PRについて議論できる という事実は、こういったエージェントがどれほど対話型になり得るかを示しています)。

すべて問題がなければ、 あなたは、エージェントのPRをマージするか変更を統合します。 そうし ないなら、 PRを破棄するか、エージェントに再試行させます。 チームが直面する現実的な疑問の1 つは、エージェントの出力が 「ほぼ」 良いが完全ではない場合にどうするかです。 AIに任せた低優 先度のタスクであっても、 あなたが時間を費やして、エージェントが生成したパッチの最後の10~ 20%を修正すべきでしょうか? 私は、これをAI貢献における「サンクコスト」 (埋没費用) のジレン マと呼んでいます。ビルギッタ・ベッケラー (https://oreil.ly/ldJ9d) は、 エージェントのPRが部

200 | 10章 自律型バックグラウンドコーディングエージェント

分的にしか成功しなかった場合、 チームは、もともと多くの開発時間を割く価値がなかったタスクに 対して「どの状況でプルリクエストを破棄し、 どの状況で残りの20%を完成させるために時間を投資 するのか」を判断しなければならないと考察しています。 唯一の答えは存在せず、状況や変更の価値 に依存します。 しかし、これは自律型エージェントによってもたらされた新種のトレードオフなので す。

まとめると、バックグラウンドコーディングエージェントは、 「理解計画コーディングテ スト提供」というコーディングタスクのエンドツーエンドのサイクルに対処します。 つまり、現 在のAIの制約の範囲内ではありますが、 勤勉で体系的な開発者がタスクを割り当てられたときに行 う作業をシミュレートしているのです。 (図10-1 を参照)。

タスクを計画 エージェント サンドボックスで エージェント コードを実行 検証 エージェント (テスト実行) 報告 (プルリクエスト) 反映およびテスト Xを変更 開発者

図10-1 自律型AIエージェントのワークフロー。 自律型エージェントは、人の介入を最小限に抑えながら、タスク画し、解決策を実行し、結果を検証し、 成果を報告する。

を計

10.3 バックグラウンドエージェントは

IDE AIアシスタントと比較してどうなのか?

ここ数年使われてきた (GitHub Copilot ChatGPTのコーディングモードなどの)コーディング AIツールと、 新世代の自律型エージェントとの間には、明確な線を引く価値があります。 どちらも 有用ですが、 果たす役割は異なり、 それぞれに強みと弱みがあります。

最も明らかな違いは「自律性のレベル」です。 GitHub Copilot や VS Code の AI 拡張機能といっ たIDEアシスタントは、あなたと 「同期的」に動作します。 呼び出された時に提案を生成したり質問 に答えたりしますが、 その範囲は通常、 (現在編集中のファイルや関数、 あるいは、あなたが与えた 特定のプロンプトといった) 直近のコンテキストに限られます。 提案を受け入れるか、別の提案を求

10.3 バックグラウンドエージェントはIDE AIアシスタントと比較してどうなのか? 201

めるか、 変更を適用するかを決めるのは「あなた自身」です。

あなたが一度タスクに対して 「Go」 をクリックすると、バックグラウンドエージェントは、それ以 上の確認なしに (ファイル編集、 実行、 検索など) 数百ものアクションを自律的に実行する可能性が あります。 これは非同期で動作します。 この仕組みは、(エージェントに自由に変更させるため) よ り高度な信頼を必要としますが、あなたをマイクロマネジメントから解放することにもつながります。 私はよく、 これをチームにAI 「ペアプログラマー」がいるのか、 AI 「アシスタント開発者」がいるの か」 の違いと表現しています。 ペアプログラマー (GitHub Copilot) はキー入力ごとにあなたととも に動作しますが、 アシスタント開発者 (Codex, Jules など) は並行して別の問題に取り組みます。

コパイロット型のAIツールは、 関数を書く、 1行を補完する、 小さなコードスニペットを生成する、 APIの使い方の質問に答えるといったマイクロタスクに優れています。 ただし、エディターで開いて いるファイルや限られたウィンドウの範囲を超えて、長いストーリーやプロジェクト全体の理解を維 持することはありません。

自律型エージェントは「プロジェクトレベル」 で動作します。 リポジトリ全体をロードする (ある いは、少なくともインデックス化する)ことで、複数のモジュールにわたる変更を調整して行えます。 さらに、複数の手順からなる計画を追跡します。 例えば、あなたがプロンプトを与えれば、 GitHub Copilot は単体テストを書くのを助けてくれます。 一方、バックグラウンドエージェントは自律的に 判断して、 あるファイルでの対応する実装の追加、 別のファイルでのテスト作成、 また別のファイル での構成の修正といった手順を、1つの統合されたタスクとして実行します。 このため、エージェン トは (ロギングやエラー処理といった) 横断的な関心事のリファクタリング、 多数のファイルにわた るアップグレード、バックエンド、フロントエンドの両方に関わる機能の実装といった作業に、はる かに適しています。 IDE アシスタントは、長期タスクメモリやリポジトリ全体の可視性を欠いている ため、こういった作業を容易には扱えません。

コパイロット型のアシスタントは受動的です。 あなたのコードや質問に応答しますが、自ら行動を 開始することはありません。 一方、バックグラウンドエージェントは能動的であり、 一度起動される と目標に到達するために主体的に行動します。 例えば、 Jules や Devin のようなエージェントは、各 手順で明示的に指示されなくても「ここに新しいファイルを作成する必要がある」 や 「今、テストを 実行しよう」と判断することがあります。 さらに、こういったエージェントは、次のように「能動的 にあなたに通知」できます。

この変更を適用できる別の箇所を見つけたので、それも含めておきます。

こういったエージェントの振る舞いは、まるで社員のようです。 社員なら 「コードを見ていたらX に気付いたので、それも修正しておきました」 と言うことがあります。 とはいえ、自律性があるとい うことは、あなたが期待していなかったことや、必ずしも望んでいないことを行うこともあるという ことです。 この種のツールへの「監督」は、(おそらく、 あなたが気付かない微妙に間違った提案を 除いて) ツールがあなたが受け入れることだけを実行することを意味します。つまり、大きな力 能

202 | 10章 自律型バックグラウンドコーディングエージェント

動性)には、大きな監督が必要になるのです。

大きな違いは、バックグラウンドエージェントが「コードやコマンドを実行」できるのに対し、従 来のIDE アシスタントは通常それができないという点です (ChatGPT の Code Interpreter モード のようなものを含めるなら別ですが、それは主にデータ分析用であり、プロジェクトのビルドに統合 されているわけではありません)。

エージェントはテストスイートを実行し、 開発サーバーを起動し、 アプリをコンパイルし、場合に よってはデプロイまで行います。 エージェントはサンドボックス内で動作しますが、実質的にはター ミナルを使える自動化された開発者のような存在です。 これは画期的な転換点であり、 検証 / 修正の ループを閉じるものです。IDE ヘルバーは一見もっともらしいコードを生成することがありますが、 そのコードを実際に実行していなかったので、 ランタイムエラーやテスト失敗が発生する可能性が あります。

コードを実行できるエージェントを使えば、生成された出力が実際に機能する可能性がより高くな ります。 さらに、デバッグの手順を肩代わりしてくれるため、 失敗があったら、 エージェントがすぐ に修正を試みることもできます。 一方、 これは (前述の通り) エージェントの環境が正しく構成され ていることを前提としています。 また、副作用が生じる可能性もあります。 例えば、 エージェントが データベースのマイグレーションを実行したり、データを変更したりすることを想像してみてくださ い。 通常はサンドボックスモードで動作するため、 本番環境には影響しませんが、注意してくださ い。

GitHub Copilot のようなツールはエディター内で動作し、フローの中でコーディングするのには 非常に便利です。 一方、多くの場合、エージェントはプロジェクト管理ツールやDevOpsツールと も統合されます。 例えば、 あなたが GitHub イシューを作成すると、 エージェントがそれを拾って PRを生成したり、 CIパイプラインから(PR上のリントエラーの自動修正など) 特定のタスクをトリ ガーしたりできます。 実際、 CodeGenはエージェントが課題管理システムに接続できることを宣伝 しており、 イシューが 「進行中」になると、 AIエージェントがそのイシューで作業を開始します。 こ ういった統合は、IDEツールの範疇を超えています。 AIエージェントがCI/CDループの一部とな る可能性を示唆しているのです。 例えば、 ビルド失敗を自動的に修正しようとしたり、 軽微な問題 に対してフォローアップのPRを自動生成したりすることです。 これは、 従来とは異なる協働の形で す。 単に開発者がコードを書くのを助けるだけでなく、チームのツールチェーンにおけるボットユー ザーとして動作するのです。

コパイロット型のアシスタントを使うと、 多くの場合、 まだ「プログラミングしている」感覚があ ります。 より速くなるだけです。 あなたが入力し、アシスタントが提案し、 あなたが受け入れ、テ ストします。 一方、バックグラウンドエージェントを使うと、 「委ねててレビューする」感覚になり ます。 人の労力は、コードを書くことから、良いタスクの説明を書くこと、 生成されたコードをレ ビューすることに移ります。 私はこれを「ジェネレーター対レビュアーの非対称性」 と呼んでいます。 解決策 (あるいはコード)をゼロから生成するのは難しいことですが、 それをレビューして改良する

10.4 複数の AI モデルを組み合わせて強みを最大化する | 203

のはより簡単です。 非同期エージェントはこれを活かします。 エージェントが一括生成に対処し、あ なたは (通常はより速く) 検証と微調整の作業に集中できます。 これは生産性の向上につながります が、エンジニアとしてはコードレビューや検証のスキルを磨く必要があるということでもあります。

コードレビューは常に重要でしたが、 今では、 人の同僚が書いたコードだけでなく、 AIが生成し たコードに対しても重要です。 AIのコードには、 人のコードとは異なるパターンの間違いが含まれ る可能性があります。 私のモットーは、エージェントが生成したコードを、 少し熱心すぎるジュニア 開発者が書いたものとして扱うべきだということです。 善意と一定の能力はあると想定しつつも、す べてを検証し、基準に達していないなら、遠慮なく修正を求めたり却下したりすべきです。

実際には、 私はコパイロット型のツールとバックグラウンドエージェントを 「併用」しているこ とに気付きました。 例えば、 複雑なロジックを積極的にコーディングしている時には、 GitHub Copilot や Cursorのインライン提案を使うことがあります。 なぜなら、 そのロジックに対して厳密 な制御を保ちたいからです。 一方、 (新しいエンドポイント用に、 すべてのAPIクライアントライブ ラリを更新といった) 重要ではないが時間のかかるタスクは、バックグラウンドエージェントに委ね て、 並行して対処させることがあります。 これらはそれぞれ異なるニッチを埋めるものです。 必ずし も、一方が他方を置き換えるわけではありません。 実のところ、 私はIDEが統一エクスペリエンス を提供する未来を予見しています。 「この行を完成させて」から「関数を生成して」、さらには「ねえ AI、 私に代わってこのチケット全体を実装して」 まで、幅広いオプションのパレットが用意されるで しょう。 あなたは、スコープに応じてツールを選択することになるのです。

10.4 複数の AI モデルを組み合わせて強みを最大化する

ここまで、 私は 「AI」 をひとつの巨大なアシスタントのように語ってきました。 しかし実際に は、多くのAIモデルがあり、それぞれ異なる強みを持っています。 自然言語理解に優れたモデルも、 コード生成に特化したモデルも、 (数学問題の解決やUI生成といった) 特定の領域に特化したモデル も存在します。 高度なバイブコーディングの実践者は、複数のAIをオーケストレーション (調整) し て、それぞれの得意分野を活かすことができます。 これは、1人の万能型ではなく、 専門家のチーム を持つようなものです。

次のものを持つ、 将来のワークフローを考えてみましょう。

効率的にコードを生成、 修正できる、 プログラミングで高度にトレーニングされた 「コード生成 AIJ

テストケースの生成とエッジケースの発見に特化した 「テスト生成AI

わかりやすいドキュメントや説明を書く 「ドキュメントAI」

•UIレイアウトやグラフィックスの生成に長けた 「デザインAI」

パフォーマンスチューニングに特化し、 おそらく低レベルの詳細まで認識する 「最適化AI」

タスクを複数のAIにパイプで接続できます。 例えば、 あなたは、コード生成AIに実装を書くよ

204 | 10章 自律型バックグラウンドコーディングエージェント

うに頼みます。 すぐに、 その出力をテスト生成AIに渡して、その出力用のテストを生成 (あるいは、 その出力を批評)させます。 次に、コードとテストをドキュメントAIに渡して、 ドキュメントや使 用ガイドを作成させます。 コードがユーザーインターフェイスを含むなら、 先にデザインAIを使っ てレイアウト構造を提案させ、それをコード生成AIが実装することもあるでしょう。 このように チェーンさせることで、 各モデルの専門知識を活用できます。 これはソフトウェアのパイプラインや 組立ラインに似ていますが、 人の役割ではなく、 AIの役割が分担されているのです。

類似のモデルでも、 組み合わせることで信頼性を高められます。 異なるプロバイダーや異なる アーキテクチャのコード生成モデルを2つ用意し、 両方のモデルに解決策を生成させ、両方の出力を 比較、テストできます。 一方のモデルの出力がすべてのテストを通過し、 もう一方が通過しなけれ ば、通過した方を選びます。 両方が通過したもののアプローチが異なるなら、より読みやすい方を 手動で選ぶこともあります。 一方が失敗したなら、失敗したモデルに、 学習のヒントとして成功した コードを示せます。 こういったAI間のクロストークには、エラーを減らす効果があります。 2つの異 なるモデルがまったく同じ間違いをする可能性は低いからです。 これは、セカンドオピニオンを得る ようなものです。 すでに、一方のAIを使ってもう一方のAIの推論を確認する研究やツールも存在し ています。 例えば一方のAIが回答を生成し、 もう一方のAIがその回答を評価するようなものです。

10.4.1 タスクの種類によってモデルを差別化する

仕事に適したツールを使ってください。 大規模言語モデル (LLM) は優れた万能型ですが、時に は小規模の専門モデルやツールの方がうまく機能することもあります。 例えば、 計算や特定のアル ゴリズムでは、決定論的なツール (あるいは、制約の強いAI) の方が適していることがあります。 特 定のサブタスクに記号ソルバーや古いルールベースAIを使い、他の部分にはLLMを使うような、 高度な開発セットアップもあります。 高度なバイブコーダーは、ツールボックスを維持しているかも しれません。 正規表現が必要なら正規表現専用ジェネレーターを呼び出し、 コミットメッセージが必 要なら要約にファインチューニングされたモデルを使う、といったものです。 その強みは、単純なス クリプトやプロンプトラッパーを通して、これらを統合できることです。 例えば、 プロンプトでAI に指示する ai_regex_generatorのようなローカルスクリプトを用意します。 さらに、 前処理、後 処理で出力が有効な正規表現になるようにし、 おそらく、 与えられた例でその正規表現をテストし ます。

10.4.2 オーケストレーションシステムを使う

頻繁に複数のモデルを組み合わせているなら、オーケストレーション (調整) システムを利用した り構築したりすることになるでしょう。 これは新しく登場したフレームワークのカテゴリであり、 多 くの場合「AIオーケストレーション」や「エージェント」 と呼ばれています。 こういったシステムを 使うと、例えば次のように、フローを定義できます。

手順1: モデルAを使って、ユーザーの要求を解釈します。

10.4 複数の AI モデルを組み合わせて強みを最大化する | 205

手順2: その要求がデータ分析に関するものなら、モデルBを使ってSQLを生成します。 テキス トに関するものなら、 モデルCを使います···

手順3: 結果をモデルDに与えて、その結果を説明します。

複数のAIの手順によって駆動されるアプリやサービスを構築しているなら、これはより関連性が 高いでしょう。 しかし、 個人開発においても、複数の手順のアプローチをスクリプト化できます。 例 えば、カスタム CLIツールのai_dev_assistはプロンプトを受け取り、裏側でAIを使って、そのプ ロンプトを code, design、 test、 optimize といったカテゴリに分類します。 このツールは、カテ ゴリに基づいて、そのプロンプトを適切な専門Ⅰに転送します。 結果を受け取ったら、 レビューや改 善のために別のAIにその結果を渡せます。

こういった他のAIを調整するメタAIは複雑に聞こえますが、 高度なユーザーなら現在の技術でも 構築できます。 そして、 IDEやクラウドプラットフォームに専用のサポートが登場し始めているので、 さらに容易になっていくでしょう。

10.4.3 人とAIのハイブリッドチーム

多重知能の話題に触れていますが、 「人」 の協働者を忘れてはなりません。 高度なバイブコーダー は、いつ人の開発者仲間を参加させるべきかを理解しています。 例えば、ある機能のためにAIに2 ~3種類のデザインプロトタイプを生成させ、それをチームのUXデザイナーに持ち込みフィード バックをもらえます。 「どれが私たちのブランドに合っているか?」 や 「どれが直感的に感じられる か?」といった問いを投げかけるのです。 また、 AIが複雑なコードを書いたら、「このコードはAI が書いたので、もう1人の目でも確認したい」と認めて、その部分に焦点を当てて同僚とコードレ ビューを行うこともあります。 ある意味で、 「複数モデル」 アプローチには、高度なモデルとして人 も含めることができます。 それぞれの存在 (人とAI) は固有の強みを持っています。 開発の未来は、 人とAIのペアプログラミング、あるいは、チームプログラミングで「チームメンバー」の一部がAI になる、という形が多くなるかもしれません。

バイブコーディングで小さなウェブアプリケーションを構築することを想像してみてください。 あ なたのワークフローは、次のようになるかもしれません。

1. (フロントエンドに特化した) UIレイアウト AIを使って、説明が与えられたページのHTML/ CSSを生成します。

2. コンテンツ AI を使って、 必要なプレースホルダーのテキストや画像を生成します (コピーライ ティング用のモデルを使って、 マーケティングテキストを生成するといったもの)

3.次に、メインのコードAIを使って、JavaScript で対話機能を生成し、どの要素 ID にフックす るかわかるようにHTMLを送り込みます。

4. 次に、 インターフェイスの対話に対して、 Selenium や Playwright のテストを生成するように、 テストAIに頼みます。

206 | 10章 自律型バックグラウンドコーディングエージェント

5. 最後に、 セキュリティ AIを使って、一般的な脆弱性についてコードをスキャンします。 これは モデルかもしれないし、単にAIで拡張された静的解析ツールかもしれません。

この複数モデルのアプローチは、 フロントエンド (存在するなら) バックエンド、コンテンツ、 テスト、セキュリティを、 1つの統合されたプロセスの中でカバーします。 各AIが自分の担当部分 に対処し、あなたはオーケストレーターとして、 それらがすべて調整されているようにしました。

今日のところは、あるツールから別のツールへ手動で出力をコピーしたり、 ちょっとしたグルー (つなぎ) スクリプトを使ったりしなければならないことがあります。 しかし明日のIDEでは、この パイプラインを構成できるようになり、シームレスに感じられるようになるでしょう。 重要なのは、 「複数のAIモデルを使えるなら、1つのAIモデルだけに頼らないようにする」ことです。 それぞれの 作業に最適なモデルを使って、 それらを協調させてください。 それによってより良い成果が得られ、 単一障害点を減らせます。 あるモデルが不得意な分野でも、別のモデルがその弱点を補ってくれる かもしれません。

AIモデルを組み合わせることは高度な取り組みですが、 これは専門化の論理的な拡張であり、ソ フトウェアエンジニアリングでよく知られている原則です (各サービスが1つのことをうまく行う、 マイクロサービスを思い浮かべてください)。 ここでは、 各AIサービスが1つのことをうまく行いま す。 バイブコーダーとしてのあなたの役割は、単なる AI プロンプト担当ではなく、 AIの指揮者へと 広がります。 多少のセットアップや思考が必要ですが、その成果は、それぞれが高品質な最終成果 物に貢献する、 AI協働者の 「交響曲」 となるのです。

それらの仕組みがわかったところで、代表的な例をいくつか見て、それぞれを比較してみましょ う。

10.5 自律型コーディングエージェントの主要プレイヤー

2025年にこれを書いている時点で、 自律型コーディングエージェントの状況はこの1年で急速に 進化し、さまざまなプラットフォームで明確に異なるアプローチが現れています。 こういったツール は、受動的にコードを補完する存在から、 独立して複雑なタスクを実行できる能動的な開発パート ナーへと移行しているのです。

クラウドベースのコマンドラインエージェント: OpenAl Codex

OpenAI の Codex (https://oreil.ly/MI-NU) はクラウドベースのエージェントアプローチ の代表例であり、 ChatGPTインターフェイスやオープンソースのCLIを通して動作します。 Codex は隔離されたサンドボックスを立ち上げ、 並行してコーディングタスクを実行し、 React のアップグレードから単体テストの作成までのすべてに対処します。 Codexを際立たせている のは、 実際のコーディングタスクについての強化学習によるトレーニングです。 これによって、 テストを通過するまで反復的に実行するといった、 ベストプラクティスに従うことが可能になり ます。 実行ごとに結果が変わることがありますが、 Codexは通常、 境界が明確なタスクに対し

10.5 自律型コーディングエージェントの主要プレイヤー | 207

て動作する解決策に収束します。 その強みは、 CIに近い環境で実際にコードを実行できる点に あり、開発パイプラインと真に 「ペア」になる第一世代のエージェントを代表しています。

ワークフロー統合型エージェント: Google Jules

Google Jules (https://jules.google) は、 GitHub ワークフローとの深い統合によって、異な るアプローチを取っています。 Jules は Google Cloud VM上でリポジトリ全体をクローンし、 視覚化、 構造化された計画を重視します。 実行前に推論を示し、 計画の修正を可能にするので す。 この「まず計画し、 その後に実行する」 という哲学は、リアルタイムのフィードバック機能 と組み合わされて、 Jules をブラックボックス的な自動化ではなく、監督付きアシスタントとし て位置付けます。 GitHub ネイティブな設計によって、チームが作業する場で直接動作し、 コン テキストを切り替えることなくブランチやPRを作成できます。 さらにこのエージェントは、音 声の変更ログといった新機能の実験も行っており、 よりアクセスしやすいコードレビューのプロ セスに向かっています。

IDE 統合型エージェント: Cursor

Cursorのバックグラウンドエージェント (https://oreil.ly/V-Pci) は、 IDE中心のアプロー チを体現しており、 エディターから直接起動されますが、 実際の処理はリモートマシン上で実 行されます。 このハイブリッドモデルによって、 開発者はローカルでの制御を維持しつつ、 コマ ンドセンターから複数のAIワーカーをオーケストレーションできます。 CursorはUbuntu イン スタンスをプロビジョニングし、 「environment.json」 やDockerfileを通して環境をカスタマ イズ可能にします。 これによって、 エージェントは完全なインターネットアクセスとパッケージ のインストール機能を持ちます。 最大の革新は、IDEとのシームレスな統合です。 開発者はエー ジェントの進捗を監視し、必要なら介入し、完了後すぐにローカルで変更内容にアクセスでき ます。 このアプローチは、ローカルのAI支援とクラウドの実行能力との境界を曖昧にしています。

チーム統合型エージェント: Devin

Devin (https://devin.ai) は単なるツールではなく「AIチームメイト」として位置付けられ、 Slack、 GitHub、 Jira といった課題管理システムと統合されています。 Cognition Labs によっ て開発され、 長期的な推論や複数手順の実行に最適化されたカスタムAIモデルを使っていま す。 Devin は、 バグ修正、 テスト追加、リンターによるクリーンアップといった、 多くの場合優 先度が下げられがちな小規模な保守作業を並行して実行することに優れています。 その協働的 な設計には、ステータス更新、確認の要求、プレビューの自動デプロイまで含まれています。 単純なタスクに強い一方で、 複雑な問題には引き続き人による大きな介入が必要となる場合が あり、 自律型コーディングの現時点での限界を浮き彫りにしています。

この分野は急速に拡大しており、既存の大手とスタートアップの両方が、 このカテゴリーを定義 しようと競い合っています。 Microsoftは 「GitHub Copilot++」 を示唆しており、 インライン補

208 | 10章 自律型バックグラウンドコーディングエージェント

完を超えてエージェント機能へと進化しようとしています*1。 AnthropicのClaudeを使っている CodeGenのようなスタートアップは、「眠らないSWE (ソフトウェアエンジニア)」 を約束し、 企業 にアプローチしています。 一方、 オープンソースプロジェクトや学術研究も境界を押し広げ続けて おり、コード生成をより信頼性が高く、 コンテキストに即したものにする方法を探求しています。

この急速な広がりは、 私たちが新しい開発パラダイムの誕生を目撃していることを示しています。 そこでは、個々の開発者が、 ソフトウェアライフサイクルのさまざまな側面に特化した複数のAI エージェントをオーケストレーションしています。 現在浮かび上がっている主要な差別化要因は、次 の通りです。

• 実行環境 (ローカル、 クラウド)

● 統合の深さ (IDE、 ワークフローツール)

• 自律性レベル (監視、 独立)

● 対象ユースケース (保守、 機能開発)

10.6 課題と限界

自律型コーディングエージェントは、本書全体で議論してきたAI支援開発に伴う基本的な課題、 特に「3章 70% 問題: 実際に動作するAI支援ワークフロー」で取り上げた 「70%問題」 を受け継い でいます。 一方、次のような、 自律性ゆえの固有の複雑さを伴っており、 別途検討する価値があり ます。

連続的な意思決定の複合効果

人が各手順で介入する対話型のAI支援とは異なり、 自律型エージェントは意思決定を連鎖的に 行い、誤りを独特な形で複合させてしまう可能性があります。 エージェントが初期要件を誤解 すると、単に不完全な関数を1つ生成するだけではなく、 その誤解に基づいて「実装アーキテク 「チャ全体」 を構築してしまいます。 後続のそれぞれの意思決定はその最初の誤りを強化し、私が 「一貫した誤り」 (coherent incorrectness) と呼ぶ状態、つまり、 内部的には一貫しているが、 実際のニーズとは根本的に一致していないコードを作成するのです。

この連続的な意思決定は、 特に複数ファイルにまたがる変更へ取り組むエージェントに大きな 課題をもたらします。 新機能を実装するエージェントは、バックエンド APIを正しく修正してか ら、誤った前提をフロントエンド、 データベーススキーマ、テストスイートへと伝播させてしま うことがあります。 あなたが完全なプルリクエストをレビューする段階では、こういった相互に 絡み合った誤りを解きほぐす作業は、 従来のAI支援で可能な対話型かつ段階的な修正よりも多

*1 2025年2月に発表された VS Code内のGitHub Copilotチャットの 「エージェントモード」や、2025年5月に発表 されたVS Codeとは独立して動作する 「GitHub Copilot コーディングエージェント」を指していると思われます。 GitHub ブログのポスト 「GitHub Copilot エージェントの覚醒」(https://github.blog/jp/2025-02-07-github-copilot-the-agent. awakens/)、 「GitHub Copilot: 新しいコーディングエージェント」(https://github.blog/jp/2025-05-20-github-copilot-meetthe-new-coding-agent/) を参照。

10.6 課題と限界 | 209

くの労力を要する傾向があります。

大規模環境における脆弱性

「8章 セキュリティ、 保守性、信頼性」では一般的な環境構成の課題について論じていますが、 自律型エージェントは、そのサンドボックス実行モデルに特有の複雑さに直面します。 各エー ジェントの実行には、 開発環境を 「正確に」 ミラーリングした隔離環境を立ち上げる必要があ り、これは大規模になるほど困難になります。 複数のエージェントを同時に実行すると、環境の わずかな差異で結果が大きく異なる可能性があります。

5つのエージェントが同時に異なる機能に取り組むシナリオを考えてみましょう。 エージェント Aはコンテナー内でNode.jsのやや古いバージョンを使っており、エージェントBは特定のシス テムライブラリを欠いています。 さらに、エージェントCは異なるタイムゾーン設定を持ってい ます。 これらの差異は実行中には見えませんが、 作業を統合し始めた時に初めて、 微妙なバグ として表面化します。 こういったエージェント間サンドボックスの「環境ドリフト」は、単一の 開発者ワークフローには存在しない新種の統合の課題を示しています。

非同期調整のパラドックス

自律型エージェントは並行開発を可能にすると期待されていますが、それは人のチームの力学 とはまったく異なる調整上の課題をもたらします。 複数のエージェントが重複するコード部分を 修正する場合、 人が用いる暗黙のコミュニケーション手段を持ち合わせていません。 つまり、 「認証モジュールを触っている?」 といった素早いSlackメッセージもなければ、同僚が何に取 り組んでいるかという非公式な認識も存在しないのです。

これが、私の言う「非同期調整のパラドックス」 を生み出します。 つまり、生産性を高めるため に並行して多くのエージェントを走らせるほど、 統合はより複雑になるのです。 人の開発者はス タンドアップや非公式なコミュニケーションを通して自然に調整しますが、 エージェントは単独 で動作します。 例えば、 エージェントAがユーティリティ関数をリファクタリングしている一方 で、エージェントBは旧バージョンへの新しい呼び出しを追加している、 といった衝突が起こり 得ます。 こういった衝突は、人の開発者同士が互いの作業を自然に把握していれば発生しない ものです。

増幅するレビューのボトルネック

(前章で議論した通り) AIが生成したコードすべてに対してコードレビューが不可欠であること は変わりませんが、 自律型エージェントはその課題を量とタイミングの両面で増幅させます。 対 話型のAI支援では、 作業に合わせてコードが段階的に届きますが、 エージェントが生成するPR は完成した実装として現れます。 しかも、 一晩の実行後に複数のPRが同時に到着することも珍 しくありません。

これは、人間のPRをレビューする時に生じるものとは異なる種類の認知過負荷を引き起こしま

210 | 10章 自律型バックグラウンドコーディングエージェント

す。 人の貢献であれば、 コミットメッセージやPRの説明から、コーダーの実際の思考過程を ある程度読み取れます。 ところが、 エージェントによるPRは、コードそのものからエージェン 「トの 「推論」を逆算して理解し直す必要があります。 月曜の朝に5つのエージェントがそれぞれ 500行以上のPRを提出してきたら、レビューの負担は協働的な品質確認から、むしろ考古学的 発掘作業のようなものへと変わってしまうのです。

エージェントへの委任には信頼が必要

おそらく最も重要なのは、 自律型エージェントが対話型のAIツールとは異なる形で、私たちの 信頼モデルに挑戦するという点です。 タスクをエージェントに委ねてその場を離れる時、私た ちは「許容できるリスク」に関して暗黙の賭けをしていることになります。 これは、逐一の制御 を維持できる監督型AI支援とは根本的に異なるのです。

エージェント技術のセキュリティ上の影響を考えてみましょう。 リポジトリへの書き込み権 限と実行機能を持つ自律型エージェントは、 固有の攻撃対象領域を示します。 侵害された、 あ るいは誤った方向に導かれたエージェントは、単に不正なコードを 「提案」 するだけではなく、 それを積極的に「コミット」 し、 場合によっては 「デプロイ」することさえあります。 したがっ て、それに応じて、エージェントに対するサンドボックス化やアクセス制御は、 (「8章 セキュ リティ、保守性、信頼性」 で扱った) 提案ベースのツールよりも高度でなければなりません。

新たに現れる組織的課題

チームがエージェントの利用を拡大するにつれて、 従来のAI支援には存在しなかった新しい組 パターンが現れています。 依頼した開発者が病欠の場合、 エージェントが生成したコードの 「所有者」は誰になりますか? チーム間でエージェントのリソース使用をどのように追跡すべき ですか? さらに、エージェントによる1か月にわたるリファクタリングプロジェクトが、緊急の 機能開発と衝突した場合にはどうなりますか?

これらは技術的な制約ではなく組織的な課題であり、 自律型システムに固有のものです。 必要 となるのは、新しい役割 (エージェント調整担当者?)、 新しいプロセス (エージェント影響評 価?)、 新しいツール (エージェントフリート管理?) であり、 それらは本書のこれまでの章で 扱った個々の開発者レベルの考慮事項を超えるものです。

こういったエージェントの自律的な性質、 つまり、独立して作業し、 連続的に意思決定を行い、 大規模に動作できる能力は、エージェントを単なる生産性向上ツールから、チームメンバーに近い 存在へと変貌させます。 この変化は、 本書全体で議論してきた技術的プラクティスだけでなく、調 整、信頼、 統合のためのまったく新しい枠組みを必要とします。 そして私たちはまだ、 その理解を 始めたばかりなのです。

10.7 AI コーディングエージェントを効果的に使うためのベストプラクティス | 211

10.7 AI コーディングエージェントを効果的に使うための ベストプラクティス

多くの一般的なAI開発プラクティスは自律型コーディングエージェントにも適用できます が、エージェントベースの開発には固有の考慮が必要な側面があります。 Codex, Jules, Devin、 Cursorのバックグラウンドエージェントといったツールに関する共同経験に基づいて、 こういった プラクティスは、独立して動作するAIシステムに開発タスク全体を委ねる際に生じる固有の課題に 対処するものです。

10.7.1 自律型エージェントが実装するタスクを戦略的に選択する

AIアシスタントと自律型エージェントの根本的な違いは、 その適用範囲と自律性にあります。 エージェントは、 成功基準が明確に定義されたカプセル化されたタスクに優れており、 特に多数の 小さなタスクを並列実行する場面で力を発揮します。 理想的なエージェントの割り当てには、包括 的なテストカバレッジの改善、 体系的な依存関係の更新、 大規模なリファクタリング作業、複数コ ンポーネントにわたる標準化された機能実装が含まれます。

AIアシスタントに1つのテスト作成を頼む場合と、 エージェントにモジュール全体で80%のテスト カバレッジを達成させる場合の違いを考えてみましょう。 エージェントは、未テストの関数をそれぞ れ体系的に処理し、 適切なテストケースを生成し、それを実行して正しさを検証し、 カバレッジ目 標が満たされるまで反復できます。 こういった体系的で測定可能な作業こそが、 自律型エージェン トの得意分野なのです。

一方で、 重要なアーキテクチャ上の意思決定、 複雑なステークホルダー要件の解釈、 新規アルゴ リズムの設計を必要とするタスクは、AIの支援を受けながらも、引き続き人が主導する開発に適し ています。 重要なのは、大きなタスクのどの部分をエージェントに効果的に委ねられ、 どの部分が 人の判断と創造性を必要とするかを見極めることです。

10.7.2 エージェントに特化した計画と監視の機能を活用する

現代の自律型エージェントは、高度な計画機能と実行の透明性によって他と一線を画し、積極的 な関与を要求します。 例えば、 Jules が作業開始前に実行計画を示す場合や、 Cursor がエージェン トの活動をリアルタイムでログ表示する場合、これらはエージェントベースの開発に固有の重要な介 入ポイントを示しています。

「計画フェーズ」は主要な品質ゲートとして機能します。 正しさだけでなく効率性やコードベース の規約との整合性についても、 提案された計画をレビューしてください。 JulesがNext.jsアプリ ケーションを更新しようとして、 重要なwebpackの構成変更を省略していた場合、計画段階でそ れを見つければ後の大規模な手戻りを防げます。 こういった能動的なレビューは、従来の受動的な コードレビューとは根本的に異なり、 開発者ツールキットにおける新しいスキルを意味します。

212 | 10章 自律型バックグラウンドコーディングエージェント

「実行時監視」 は、エージェント固有の監督にもう1つの層を加えます。 すべての操作を逐一監視 する必要はありませんが、 定期確認によって、 エージェントが非効率な解決策を追求したり、不必 要に幅広い変更を加えたりするのを防ぐことができます。 Cursor がタスクの途中でエージェントの 「環境に「入り込める」機能は、最新のツールが自律的なワークフローを完全に放棄することなく介入 を支援する方法の一例です。 効率を最大化するためには、いつ介入すべきか、いつエージェントに 自己修正を任せるべきかを見極めるスキルが求められます。

10.7.3 エージェントの同時操作を管理する

従来の開発では、1人の開発者が一度に1つのタスクに取り組みますが、 エージェントは真の並行 開発を可能にします。 この能力には新しい調整戦略が必要です。 複数のエージェントを同時に実行 する場合、例えば、一方が依存関係を更新し、もう一方がロギング基盤を追加している時、それぞ れの作業の間に生じる潜在的な競合や依存関係を考慮しなければなりません。

各エージェントのスコープに明確な境界を設定し、 マージ競合を最小化してください。 可能なら、 アプリケーションの異なるモジュールやレイヤーにエージェントを割り当ててください。 統合の順序 も考慮してください。 新機能を追加するエージェントは、別のエージェントによる基盤改善が完了す るまで待つ必要があるかもしれません。 こういったオーケストレーションは、 従来の単独開発という よりも分散チームを管理することに近いものです。

10.7.4 エージェントを統合するためにチームのプラクティスを進化させる

自律型エージェントの導入は、チームの力学やレビュープロセスを根本的に変化させます。 同僚 が丁寧に作成したPRをレビューする場合とは異なり、 エージェントが生成したPRには技術的には 正しいものの、スタイル的に一貫性のないコードが含まれることがあります。 チームは、この違いを 考慮した新しいレビューのプラクティスを確立しなければなりません。

エージェント固有のレビューチェックリストを整備することを検討してください。 そこでは、正し さだけでなく、チームの規約やアーキテクチャパターンとの整合性も重視します。 エージェントと作 業する中で見つけたよくある癖を記録しておいてください。 例えば、選んだエージェントが一貫して 特定のアンチパターンを使ってしまう、あるいは特定の最適化の機会を見逃す、 といったことです。 こうした組織的な知識は、レビュー担当者が繰り返し発生する問題を素早く特定し、 対処するのに 役立ちます。

10.7.5 自律システムでフィードバックループを構築する

おそらく最も重要なのは、 自律型エージェントが新しい形の反復開発を可能にする点です。 その フィードバックループは、単なるコードレビューを超えて広がります。 エージェントのプルリクエス トに改良が必要なら、多くの場合、具体的な指示を添えて差し戻し、もう一度反復させることが可 能です。 これは、作業を人の同僚に差し戻すと社会的、時間的コストが伴う従来の開発とは異なり

ます。

10.8 まとめと次の一歩

213

あなたが選んだエージェントに適したプロンプトパターンを開発するように、努めてください。 高 品質な結果を一貫して生み出す成功したプロンプトの定式化を見つけたら、それを記録してくださ い。 共通のタスクの種類に対しては、必要なコンテキストや制約をすべて含むテンプレートを作成し てください。 これは、エージェントの計画、実行、 修正サイクルを考慮した、エージェントに特化し たプロンプトエンジニアリングであり、 一般的なAIとの対話とは異なる独自のスキルです。

目標は変わりません。 高品質なソフトウェアを効率的に提供することです。 自律型エージェントは、 この目標を達成するための新しいツールにすぎず、 既存のプラクティスを全面的に置き換えるので はなく、慎重に統合すべきものです。 エージェントを理解し、 その固有の能力を活用しつつ、厳格 な品質基準を維持することで、チームはコード品質やアーキテクチャの整合性を犠牲にすることなく、 大幅な生産性向上を実現できます。

10.8 まとめと次の一歩

まとめとして、「4章 70%を超えて: 人の貢献を最大化する」 の言葉を繰り返します。 AIが開発 者を置き換えることはありません。 しかし、 AIを効果的に使える開発者は、使えない開発者を置き 換える可能性があります。 自律型コーディングエージェントの登場は、 その方向への大きな飛躍で す。 こういった「主体を持たない同僚」 を使いこなせる人は、より短時間でより多くのことを成し遂 げられるでしょう。 私たちが適応し、 仕事を高い基準で維持し続ける限り、ソフトウェアエンジニア にとって今は非常に刺激的な時代です。 ツールは変わりつつありますが、目標は変わりません。 信 頼性が高く、効率的で、 革新的なソフトウェアを構築することです。 AIエージェントが私たちの そばに (あるいは裏方で) いることで、その目標に到達する新しい方法が生まれています。 そして、 ボットが夜通し働いている間に、 私たちはゆっくり眠れるかもしれません。

次に、 本書の最終章では、(エージェント型AIの未来を含む) コーディングにおけるAIの未来を、 より幅広い視点から考察します。



1215

11章

コード生成を超えて:

AI拡張開発の未来

バイブコーディングは、AIが私たちのプロンプトからコードを生成するところから始まりました が、その意味するところは単なるコード作成をはるかに超えています。 AI技術が進歩するにつれ、 ソフトウェア開発ライフサイクルの「あらゆる」 側面を変革する可能性を秘めています。 本章では、 AIの役割が将来どのように拡張していくかについて、 推測的ながらも根拠に基づいた視点を示しま す。 具体的には、AI駆動のテスト、 デバッグ、 保守、ソフトウェア設計やユーザー体験のパーソナ ライズへの影響、 AI支援によるプロジェクト管理の進化、プログラミング言語そのものの未来につ いて探っていきます。 目的は、 AIを単なるコードジェネレーターではなく、ソフトウェアエンジニア リングにおける包括的な参加者として捉える未来像を描くことです。 そして、 特定の技術が移り変 わっても議論が有効であり続けるように、 基本原則に根ざした形で展開していきます。

11.1 テスト、 デバッグ、 保守におけるAI

将来の開発環境を想像してみてください。 あなたが (手書きかバイブコーディングで) 関数を1つ 書いた瞬間、 AIツールがすぐその関数用に一連の単体テストを生成し、潜在的なバグを見つけ、 場 合によってはそれを修正してしまいます。 これらすべてが数秒のうちに行われるのです。 こうしたシ ナリオは、急速に現実味を帯びてきています。 ここでは、品質保証 (QA) と保守におけるAIの潜在 的な (そしてすでに現れ始めている) 貢献を整理していきましょう。

11.1.1 テストの自動生成

徹底的なテストを書くことは時間がかかり、締め切りのために軽視されがちです。 「7章 AIで ウェブアプリケーションを構築する」 で見たように、現在のAIアシスタントはテストを自動生成す ることで、この負担を軽減できます。 例えば、 あるコードを与えれば、 AIは典型的なケース、エッ ジケース、エラー条件をカバーする一連の単体テストを提案できます。

将来的には、これがさらに進む可能性があります。 AIがコードベース全体を調べ、テストカバ レッジが不十分な関数やモジュールを特定し、 追加のテストを生成できるようになる可能性があり ます。 さらに、(ファズテストのように) 人のテスターが思いつかないような入力をシミュレートし、

216 | 11章 コード生成を超えて AI 拡張開発の未来

隅々のケースに潜むバグを検出することさえ可能でしょう。 その利点は、テストの手動作成を最小限 に抑えつつ、より堅牢なコードベースを得られることです。

注意すべき点は、テストの品質はAIが仕様をどれだけ理解しているかに依存するということです。 したがって、人がAIが生成したテストをレビューし、ソフトウェアの意図された挙動と一致してい るか確認する必要があります。 たとえば、AIがある出力をアサートする場合、 それは 「技術的には」 コードが行っていることですが、 要件は異なっていた可能性があります。 しかし、 人が関与してい たら、コードかテストのどちらかに存在する誤解を見つける助けとなり得るのです。

11.1.2 知的なデバッグ

デバッグは多くの場合、エラーの原因を突き止めるためにログを延々と調べたり、コードを一行ず つ追いかけたりする退屈な作業を伴います。 「5章 生成されたコードを理解する レビュー、 改良、 所有」では、AIが賢いデバッグの相棒として機能できることを見てきました。 現在、 エラーメッセー ジと問題のあるコードを入力として受け取り、その説明と修正のためのコード変更を返すことができ AIツールもあります。

AI支援のデバッグワークフローがどのように進化していくかを垣間見るために、 次のようなAI システムを考えてみましょう。 このAIシステムは、プログラムの実行を監視し、 クラッシュや例外 が発生した時にスタックトレースや変数の状態を解析して、 原因の可能性が高い箇所を特定します。 単にエラーメッセージを返すのではなく、 次のように言うことがあります。

getEmail() を呼び出した際に userProfiles が null だったため、 アプリケーションがクラッシュし ました。 これは、ユーザープロファイルを読み込む際にnull チェックが欠けていることを示唆し ています。

さらに、AIは修正方法を提案できます。

考えられる解決策は、 userProfilesがnullの場合に初期化するか、 getEmail() を呼び出す前に条 件を追加することです。この修正を適用しましょうか?

将来のデバッグAIは、ランタイム環境に直接統合され、 リアルタイムで問題を見つけられるよう になるかもしれません。さらに、コードパスを解析することで、問題が発生する 「前に」予測するこ とさえ可能になるでしょう。

この関数は、y=0で呼び出された場合、 DivisionByZero 例外を投げる可能性があります。その ケースに対処することを検討してください。

これは静的解析に似ていますが、AIが無数のコードベースやエラーパターンから学習した知識に よって駆動されているため、より示唆に富み柔軟になる可能性があります。

11.1 テスト、 デバッグ、 保守における AI | 217

11.1.3 予知保全 (予測的な保守) とリファクタリング

時とともに要件が変化すると、 コードは古くなったり、 最適でなくなったりします。 保守には、 (挙動を変えずにコード構造を改善する) リファクタリング、 依存関係の更新、 パフォーマンスの最 適化といった活動が含まれます。 AIは、こういった各領域で支援できます。

リファクタリング

将来のAIは、重複コード、 長い関数などの) コードスメルを特定し、自動的にリファクタリ ングする可能性があります。 例えば、3か所に似たコードがあることを検出し、 それらを1つの ヘルパー関数に抽象化するように推奨するかもしれません。 あるいは、深く入れ子になった一 連のループを、より読みやすい形に変換する可能性もあります。 AIは「良い」 コードの数多く の事例を見てきているため、コードベースをクリーンで保守しやすくするためのスタイル改善 (https://oreil.ly/XWXC を提案できます。 将来、 AIが常時バックグラウンドでコードをリ ファクタリングし、 開発者がその変更をレビューして承認するモードが、 エディターに備わる日 が来るかもしれません。

依存関係の更新

将来のAIサービスは、(ライブラリやフレームワークといった) プロジェクトの依存関係を監視 し、それらを新バージョンに更新するためのプルリクエストを自動生成するかもしれません。 そ の際、 破壊的変更に対応するために必要なコード修正も含めます。 例えば、 ウェブフレームワー クの新バージョンでAPIが変更されたら、 AIはコードを新しいAPIに適応させることができる でしょう。これによって、 開発者は移行ガイドを読んだり、バージョン関連の問題を修正したり する繰り返し作業から解放されます。

パフォーマンスチューニング

多くの場合、保守には、データがスケールしたり利用パターンが変化したりする中でのパフォー マンス改善が含まれます。 AIはパフォーマンスプロファイルを解析し、 非効率な部分を指摘す ることで、 役割を果たせます。 例えば、 AIがコード内の特定のデータベースクエリに時間がか かっていることに気付き、インデックスの追加やクエリの書き換えを提案するかもしれません。 また、ループ内で冗長な計算が行われていることを特定し、キャッシュの導入を提案することも 考えられます。 これはまるで、常にアプリケーションを監視し、冗長なループや最適でないデー タ構造といった非効率を積極的に検出してくれるパフォーマンスの専門家がそばにいるようなも のです。

AIはステージング環境で実行され、高負荷をシミュレートして、次のようなレポートを示すか もしれません。 「高負荷下では、モジュールXがYによってボトルネックになります。 アプロー チZを使ったリファクタリングを検討してください。」 要するに、 AIは問題を見つけるだけでな く、より良いパターンでチームを教育する役割も果たすのです。

218 | 11章 コード生成を超えて AI 拡張開発の未来

11.2 AI駆動デザインとユーザー体験 (UX) の パーソナライゼーション

AIは、コードやロジックを超えて 「ソフトウェアの設計方法やユーザー体験 (UX) のあり方」に影 響を与えるようになります。 優れたソフトウェアは、 内部的に正しいだけでなく、 直感的で、 アクセ スしやすく、ユーザーにとって満足のいくものである必要があります。 AIは今後も、 より良いユー ザーインターフェイスを生み出し、 個々のユーザーのニーズに合わせて体験を調整する新しい方法 を開発し続けるでしょう。

11.2.1 生成デザインツール

今日のAIデザインツールは、 敵対的生成ネットワーク (GAN) やトランスフォーマーのテクニッ クを使って、 説明からUIモックアップを生成します。 プロダクトマネージャーは、次のように自然 言語で機能を説明できます。

ようこそメッセージ、 遊び心のあるイラスト、 名前、メールアドレス、パスワードの入力フォー ムを備えた、モバイル用の登録画面が必要です。 その画面は、私たちのブランドカラーを使い、 親しみやすい見た目にすべきです。

AIデザインアシスタントはこの説明を受け取り、レイアウト、プレースホルダーテキスト、スタ イル付きコンポーネントを備えた、UIデザインの複数の候補を数秒で生成できます。 デザイナーや 開発者は、その中から最も近いものを選び、さらに改良していきます。

将来、こういったツールがデザインソフトウェアやコーディング環境に直接統合され、「デザイン」 と「UIのコーディング」 の境界が曖昧になる可能性があります。 AIは、 生成したデザインをそのま まHTML/CSSやFlutterコードとして出力し、 すぐにテスト可能にするかもしれません。 これに よって、デザインの反復サイクルが飛躍的に高速化します。 手動やソフトウェアでスケッチする代わ りに、ユーザーが使いやすく魅力的だと感じるデザインのベストプラクティスや膨大なトレーニング データを基にしてデザインを提案するAIと、 協働することになるでしょう。

デザインの創造的なプロセスにおいても、 AIはインスピレーションの源となり得ます。 デザイ ナーがアプリの配色やイラストスタイルをブレインストーミングしている時、 AIツールは色のムー ドボードを生成したり、 その場でカスタムアイコンを作成したりすることができます。 例えば、 デザ イナーはAIに次のように伝えるかもしれません。

コードと音楽のアイデアを組み合わせたロゴが必要です。

AIは、 (波括弧のような) コーディングの記号と音符を組み合わせた、いくつかのサンプルロゴを 生成します。 プロのデザイナーが手動で最終成果物を仕上げるかもしれませんが、 AIの提案はアイ デアを刺激し、探索フェーズを加速させることができます。 要するに、 AIは素早いプロトタイピン グツールであり、デザイナーの選択肢を広げる創造的なパートナーの役割を果たせるのです。

11.2 AI駆動デザインとユーザー体験 (UX)のパーソナライゼーション

デザインやUXにおいては、 人の判断が最も重要であることに留意すべきです。 美的センス、人の 感情の理解、ブランドアイデンティティといったものは、AIが近づくことはできても、AIが本質的 に備えているものではありません。 したがって、 デザインにおけるAIは人の創造性を高めるための ツールであり、置き換えるものではありません。 AIはバリエーションの生成やユーザーデータの処 理といった雑務を担い、デザイナーが共感や創造的な判断に集中できるようにします。

開発者にとって、AI駆動デザインは、従来の 「デザインから開発への引き継ぎ」 がより流動的にな ることを意味します。 開発者はデザイナーと協働して、 AIを使ってUIコードを生成でき、その逆も 可能です。 これはまた、フロントエンド開発者がレイアウトをピクセル単位で微調整する時間を減 らし、デザインが機能性と整合し、アクセシビリティを備えて実装されていることを確認することに、 より多くの時間を割けるようになることも意味します。 また、 彼らは、 パーソナライゼーションのた めのフックを作成する作業に取り組むかもしれません。 つまり、 AIがユーザーデータに基づいてレ イアウト A、Bのどちらかを選択できるようにするコードを書き、 両方のレイアウトが高いパフォー マンスと堅牢性を備えているようにするのです。

将来のバイブコーディングでは、 「バイブデザイン」 も可能になるかもしれません。 つまり、あな たがアプリケーションの外観や使い心地に求めるパイプス (しゃれのつもりです) をただ説明するだ けで、AIがそれを具体化する手助けをしてくれるのです。 結果として生まれるのは、包括的なAI開 発プロセスです。 バックエンドロジックやデータベースクエリをAIの支援で書くだけでなく、AIと 協働して製品全体の体験を作り上げるのです。

11.2.2 UXリサーチのためのAI

デザインのもう1つの側面は、ユーザー行動の理解です。 AIは (プライバシーへの配慮を念頭に置 きながら) アプリケーションの利用データを分析し、ユーザーがつまずいている箇所を明らかにでき ます。 例えば、 AIは、 多くのユーザーが特定のアイコンにカーソルを合わせ、それがクリック可能 であると期待しているのに実際にはそうではないことを検出し、 UX改善の機会を示すかもしれませ ん。 また、 特定の属性を持つユーザーが、 あるワークフローの手順で一貫して離脱していることを 検出し、その手順が彼らにとって直感的ではない可能性を示唆することもあります。

将来、AIが、ユーザー行動モデルを用いてユーザーとの対話をシミュレートし、実際のユーザー が遭遇する 「前に」 UXの問題を予測できるようになる可能性があります。 この「仮想UXテスト」に よって、 修正が容易な開発段階で、 複雑すぎるナビゲーションや不明瞭なラベルといった問題を見 つけられます。

11.2.3 パーソナライズされたユーザー体験 (UX)

「パーソナライゼーション」は、しばらくの間バズワードとして使われてきました。 これは、ユー ザーの嗜好や履歴に基づいて、 異なるコンテンツを異なるユーザーに提供するという意味です。 AI はこのパーソナライゼーションをさらに進化させ、各ユーザーに合わせてソフトウェアの挙動やイン

219

220 | 11章 コード生成を超えて: AI 拡張開発の未来

ターフェイスをリアルタイムで微調整できます。 例えば、アプリのAIが、 あるユーザーがメニュー ではなく検索を通してアプリを操作する傾向があると学習します。 すると、 AIは、 (人のアシスタン トが上司のニーズを先回りして把握するように) そのユーザーに対して検索バーをより目立たせたり、 状況に応じてユーザーが求めそうな検索結果を事前に読み込んだりします。

もう1つのシナリオはアクセシビリティの改善です。 AIが、 ユーザーがスクリーンリーダー技術を 使っていることを検知したら (つまり、ユーザーに視覚障害がある可能性があったら)、アプリケー ションを自動的に高コントラスト、 大フォントのモードに切り替え、 スクリーンリーダー用ラベルを 最適化できます。 これは、従来の静的なアクセシビリティ設定を超える対応です。 要するに、ソフト ウェアは「適応的」 になり得るのです。

あるECサイトが、 その場でレイアウトを動的に並べ替えることを想像してみてください。 どちら がより関心を引くかに応じて、 あるユーザーには商品がグリッド表示され、別のユーザーには詳細付 きのリスト表示が示されます。 こういった変更は微妙で継続的であり、 AIは試行錯誤しながら学習 していきます。 まるでA/Bテストのようですが、 個々のユーザー単位で自律的に行われるのです。

11.3 AIによるプロジェクト管理の進化

ソフトウェア開発は、単にコードを書いたりデザインを作ったりすることだけではありません。 計 画調整、 意思決定といった、 プロジェクト管理やチームリーダーシップの領域も含まれます。 AI の分析、予測の能力は、タスクの割り当てからリスク管理、 意思決定の支援に至るまで、プロジェ クト管理を大いに助けられます。 ここでは、AIがソフトウェアプロジェクトの計画と実行のあり方 をどのように変革し得るかを示します。

タスク配分

チームを管理するということは、 各開発者の強みや弱み、 現在の作業負荷を把握し、それに応 じてタスクを割り当てることを意味します。 AIのプロジェクト管理アシスタントは、 さまざまな データポイント、 つまり、コードのコミット履歴 (例えば、開発者が取り組んできたコードベー スの部分から推測される) 専門分野、 個々の生産性パターン (より効果的にコーディングできる のが、朝の人も夜の人もいます) を分析し、 新しいタスクを誰に任せるべきかを推奨できます。 例えば、 新機能がデータベース作業を伴う場合、 アリスがこれまで多くのデータベース関連タス クをうまくこなし、 過負荷になっていないことをAIが把握していれば、 AIはそのタスクをアリ スに割り当てるように提案するかもしれません。 さらに、 AIは過去の類似タスクとの比較や個々 のベロシティを考慮することで、そのタスクにどれくらいの時間がかかるかを予測できます。 こ れによって、プロジェクトマネージャーはより現実的なスケジュールを設定し、 特定のメンバー が過負荷になるのを防げます。 時とともに、このようなAIは熟練したマネージャーのように作 業負荷を分散させ、誰も手持ち無沙汰にならず、誰も過度に疲弊しないようにできるでしょう。

11.3 AIによるプロジェクト管理の進化 | 221

スケジューリングとスプリント計画

AIは、高レベルの目標を実行可能な項目に分解する支援を行えます。 例えば、AIに機能要件や ユーザーストーリーを入力すると、それを実装するために必要なサブタスクの一覧を提案してく れるかもしれません。 要するに、 AIは計画や作業分解構造 (WBS) の下書きを生成できるので す。 アジャイル手法におけるスプリント計画の際、AIがバックログを分析し、チームの過去の ベロシティを考慮して、 次のスプリントに収まる一連のタスクを提案できます。 AIはタスク間の依存関係を強調し、 計画が論理的な順序で並んでいるようにすることさえでき

ます。

タスクBはタスクAの後に実施すべきです。 なぜなら、タスクBはタスクAの機能を基盤として いるからです。

長期的なロードマップ作成では、 AIツールがさまざまなシナリオをシミュレートすることがあ ります。

今、機能Xを優先すると、 モデルはリソースの重複によって、 機能Yが2週間遅れるリスクがある と予測しています。

こういったシミュレーションやデータ駆動の知見を活用することで、 人のマネージャーは、優先 順位に関して十分な情報に基づいた意思決定を行えます。

リスク分析と管理

リスク管理には、 多くの場合、 何が問題になり得るか (遅延、技術的な障害、 統合上の課題) を 予測し、 その緩和策を計画することが含まれます。 AIはパターン認識に適しているため、 (社内 の、利用可能なら業界全体の) 過去のプロジェクトデータを分析し、リスク要因を特定できます。 例えば、 AIは次のような点に警告を出します。

技術スタックの切り替えを伴うプロジェクトは、過去のデータに基づくと、スケジュール超 過の可能性が30%高くなります。

直近の3つのプロジェクトでは、統合テスト段階で遅れが生じました。 このプロジェクトで も、同様のリスクがある可能性が高いです。

これによって、マネージャーは、あらかじめその段階により多くの時間やリソースを割り当てら れます。 もう1つの観点は、現在の進捗の監視です。 AIシステムはタスク完了率やバグ発見率 などを監視し、問題の兆候を察知したらアラートを送信できます。

チームは今のスプリントで、 期待されるベロシティの半分のペースでタスクを完了しています。 潜在的なブロッカーへの対応が必要です。

本質的に、AIは常に警戒を怠らないプロジェクト監査役となり、深刻化する前に問題を見つけ られます。

222 | 11章 コード生成を超えて AI 拡張開発の未来

意思決定の支援

プロジェクト管理には多くの意思決定が伴います。 例えば、 締め切りに間に合わせるために機 能を削るべきか、新機能を追加する代わりにリファクタリングに投資すべきか、といった決定で す。 こういった決定にはビジネスや人の要因が関わるため、 AIが直接判断を下せません。 しか し、 AIはそれを支援するためのデータを提供できます。 例えば、 リファクタリングを検討して いるなら、 AIは次のように報告します。

モジュールZをリファクタリングすれば、 複雑さのメトリクスとチームからの入力に基づいて、 関連する機能の将来の開発時間を20%削減できる可能性があります。 今、 2週間の遅延を招くか もしれませんが、6か月後にはその効果が現れるでしょう。

こういった数値はあくまで推定値にすぎませんが、 客観的な分析があることで、 ステークホル ダーはトレードオフをより具体的に評価できます。

もう1つの例としては、 新しいライブラリを採用するか、 社内で構築するかを判断する場面が考 えられます。 AIは、そのライブラリに関するドキュメント、 コミュニティのサポート、 既知の問 題を調査し、長所と短所を要約することで、チームの調査時間を何時間も節約できるでしょう。

自然言語によるステータスクエリ

いつの日か、ステークホルダーやマネージャーが、AIに自然言語でプロジェクトの状況を問い 合わせられるようになるかもしれません。

支払い統合機能の進捗はどうなっていますか? ブロッカーは何ですか?

AIは、チケット更新、 コミットメッセージ、テスト結果を解析して、次のように答えます。

支払い統合は70%完了しています。 1つのブロッカーは通貨変換に関連するテスト失敗であり、 現在2人の開発者がデバッグしています。 明日までに解決すれば、この機能は金曜日までに完了 する見込みです。

このようなアクセスしやすいステータス報告は、 特に大規模なチームや非技術系のステークホ ルダーを含むチームにおいて、 コミュニケーションを改善できます。 AIは基本的に、細部まで 把握し、必要に応じて要約できる全知のプロジェクトアシスタントとなります。

感情やチームの健康状態の把握

これはやや推測的ですが、AIはまた、コミュニケーションのパターンを分析することで、(もち ろん、プライバシーや境界を尊重しながら) チームの士気やストレスを測れるかもしれません。 例えば、 コードレビューのコメントが簡潔すぎる傾向になっていたり、 Jira チケットで「再オー プン」アクションが多発していたりしたら、混乱や不満を示している可能性があります。 その 際、AIはプロジェクトリードに対して、チームの健全性を確認するように穏やかに通知できま す。 リモートや分散型のチームでは、このようなシグナルを読み取るのが難しいため、 「デジタ ルなムード」を監視するAIは価値があるでしょう。もちろん、侵入的に感じられないよう、慎

11.4 自律型エージェントはソフトウェアエンジニアリングをどう変えるか |223

重かつ透明性をもって扱う必要があります。

これらすべての点において、 AIはプロジェクトマネージャーにとっての「力を増強させるもの」と して機能します。 AIは重い分析や定型的な提案に対処し、 人のマネージャーが最も得意とする判断、 チームの動機付け、 協働の人の側面に集中できるようにします。 優れたプロジェクト管理は、 科学 であると同時に芸術でもあります。 AIは科学的側面(データ、 予測、 分析) を強化することで、芸 術的側面 (リーダーシップ、 構想、 適応力) が輝けるようにします。 開発者もこうした強化を歓迎す べきです。 計画が行き届き、 監視が適切に行われるプロジェクトは、より明確な目標と予期せぬ不 快な驚きの少なさにつながります。 また、 (AIが詳細を処理するため) ステータス会議やスプレッド シートの更新に費やす時間が減り、 創造的な開発作業により多くの時間を割けるようになります。

11.4 自律型エージェントはソフトウェアエンジニアリン グをどう変えるか

この技術はまだ序盤にありますが、 急速に進展しています。 長期的な影響や、 今後数年間でどの ように進化するかを考える価値があります。 ここでは、自律型コーディングエージェントの時代にお けるソフトウェアエンジニアリングの未来像を、 現在の動向といくつかの根拠ある推測から描いてみ ます。

AIエージェントは開発チームの標準となる

今日ではソース管理やCI/CDを使うのが標準であるように、AIエージェントが開発に参加する ことも日常的になるかもしれません。 毎朝、 エージェントが夜間に完了したタスクを示す「AIア シスタントボード」 を確認するのが当たり前になり、ログインすればコードレビューが待ってい る、といった状況です。 すでに今日でも、「あなたが眠っている間に」 エージェントが動作する 兆しが見えています。 エンジニアは一日の終わりにまとまったタスクをAIに委ねて、 翌朝まで に試みてもらうことが一般的になるかもしれません。 「開発者の仕事」 とは何かという考え方も 変わっていきます。 定型コードを打ち込んだり機械的な更新をすることよりも、問題を定義し、 解決策を統合し、AIを導くことが中心になるでしょう。 少し想像を膨らませれば、開発者はAI 開発者に対するプロダクトマネージャーのような存在になり、 必要な作業を指定し、それが要 件を満たしているかを確認する役割を担うようになる、と言えるかもしれません。

複数エージェントの協働がより一般的になる

現在、 各エージェントは、あなたが与えたタスクをほぼ単独で処理しています。 しかし将来に は、異なる専門性を持つ複数のエージェントが協働するシナリオが考えられます。 あるエージェ ントはフロントエンドのタスクに優れ、別のエージェントはバックエンドのタスクに強く、 あな たがそれらに調整されたタスクを与える(あるいは、エージェント自身が分担方法を見つけ出 す) ことになるかもしれません。 別の可能性として、 (コジョオセイが「複数ブランチ探索」 と

224 | 11章 コード生成を超えて AI 拡張開発の未来

呼ぶ*1) エージェントが複数の解決経路を並行して探索するという形もあり得ます。

複雑な問題をAIに与えると、AIが異なるアプローチやアーキテクチャを用いた3つのサブタス クを立ち上げ、 最適なものを選択する、 あるいは、 どの方向を好むかを 「あなた」 に尋ねると想 像してみてください。 これによって、異なる実装を評価するのにかかる時間を劇的に短縮できる かもしれません(現在、複数のエンジニアが数日かけてプロトタイピングすることもある作業で す)。もちろん、それをオーケストレーションするのは容易ではありませんが、 エージェントフ レームワークが進化すれば不可能ではありません。

インテリジェントなチェックポイント機能により、 AIは人間に助けを求めるようになる

将来のエージェントは、 意思決定の場面で積極的に指示を求めるほど賢くなるかもしれません。 これは単なる推測ではなく、 LLMにおける不確実性推定や内省に関する研究が進行中であり、 モデルが自分が確信を持てないときにそれを認識し、 先へ進むのではなく助けを求めるように トレーニングやプロンプティングが可能であるという、 初期の兆候も見られます。 例えば、ある エージェントが何かを実装する際に2つのライブラリのどちらを使うかという場面に直面し、推 測する代わりに (ジュニア開発者のように) 一度立ち止まり、 あなたに尋ねる、 といったことが 起こり得ます。

これには、ライブラリAかBを使えます。 どちらを希望しますか?

業界では、この種の「知的チェックポイント」を導入することで、エージェントがブラックボッ クスではなく協働者のように感じられ、より信頼できるという考えが広がりつつあります。 これ は、人がチームで働く際のやり方 (はったりをかますのではなく、必要な時に質問する) ともよ く一致します。 まだ初期段階ではありますが、 ツール利用の内省、 不確実性のしきい値を考慮 した計画、実行途中でユーザーフィードバックを明示的に受け入れる仕組みなどを通して、 この種の振る舞いをサポートするモデルが増え始めています。 知的チェックポイントには、エー ジェントが自らの不確実性を認識する必要があり、これは難題ですが、 研究者たちは信頼度を 含むAIの自己認識に取り組んでいます。

エージェントのUXが向上する

より多くの作業をエージェントに委ねるようになるにつれて、彼らが何をしているのかを把握す るためのより良い方法が必要になります。 コジョオセイは「エージェントインボックス」を提 案しています*2。 これは、エージェントが取り組んでいるタスク、 完了したタスク、そしてあな たの注意を必要とするタスクを一元的に表示する仕組みです。 これは、すべての実行中のエー ジェントタスクを進捗 (「3/5ステップ完了」 や 「レビュー待ち」) や結果とともに示すダッシュ ボードになる可能性があります。

現在のログやPRが入り混じった状態の代わりに、 エージェントを管理するための明確なイン

*1 訳注: https://kojo.blog/codex-jules-async-agents/ *2 訳注: https://kojo.blog/codex-jules-async-agents/

11.4 自律型エージェントはソフトウェアエンジニアリングをどう変えるか 225

ターフェイスが登場するでしょう。 おそらくIDEには「エージェント」 サイドバーが設けられ、 アクティブなタスクの一覧や更新フィードが表示されるようになるかもしれません。 さらに、 通 知を受け取ることもできるでしょう。

●エージェントXがタスクYを完了し、 PR #123 を作成しました。

●エージェントZは、処理を続けるために入力を必要としています。

この基盤は、 全体像を見失うことなく利用をスケールアップするために重要になります。 結局の ところ、 中央管理がなく、 10個のサイレントボットが何をしているのかわからない状況を、誰 も望んではいません。

エージェントは、課題管理システムやCIシステムと統合される

私は、課題管理システム (Jira, GitHub Issues, Linear) にあるイシューが、エージェントに よって最初から最後まで処理されるような、より密接なループが実現すると予想しています。 実 際 CodeGen の Linear との統合は、すでにその兆しを示しています。

ワークフローは次のようになるでしょう。

1.PMがチケットに仕様を添付する。

2. 開発者 (またはテックリード)がそれをAI向けに承認する。

3. AIエージェントがそれを受け取り、実行し、 チケットにPRを添付する。

4. 人が修正内容をレビューし、 テストし、チケットをクローズする。 これによって、 開発プロセスはより継続的なものになる可能性があります。 同様に、CIシステ ムは、特定のチェックが失敗した際に自動的にエージェントを呼び出すかもしれません。たとえ ば、セキュリティスキャンで脆弱性が見つかったら、 エージェントは脆弱なライブラリをアップ グレードしたり、リスクのあるコードをリファクタリングして修正のPRを作成できます。 ある いは、 PR後にコードカバレッジがしきい値を下回ったら、エージェントが追加のテストを生成 して、カバレッジを引き上げることも可能です。 これを「自動化された保守」 だと考えてください。 具体例として現在、 GitHub の Dependabotは、 依存関係を更新するためのPRを作成します。 AI エージェントはPRを作成するだけでなく、更新によって壊れたコードを修正し、テストを実 行してすべてが正常であることを確認することもできます。 つまり、 強化版 Dependabotと言 えるでしょう。

モデルの改善により、 30% のギャップが縮小する

(GPT-4、 Gemini、 Claude などの) 主要なAIモデルは、コードの理解と生成能力を今後も向 上させていくでしょう。 モデルがより高性能になるにつれて、 「最後の30%」 のギャップは縮小 するかもしれません。 さらに、 より多くのシナリオでトレーニングされ、 推論力が改善された結 果、明らかな再利用やエッジケースをほとんど見逃さないエージェントが登場する可能性があ ります。

より優れたモデルによって、エージェントは間違いを減らし、監督の必要性も少なくなり、より

226 | 11章 コード生成を超えて AI 拡張開発の未来

複雑なタスクを扱えるようになるかもしれません。 とはいえ、ソフトウェアは本質的に複雑なの で、 人の判断が必要となるギャップは「常に」 残るだろうと私は考えています。 そのギャップは 「最後の30%」 ではなく、 「最後の5~10%」 になるのかもしれません。

私はまた、モデルがより効率的になると予想しています。 これによって、データプライバシー (あ るいはコスト) を懸念する人々が、ローカルやセルフホスト型のエージェントを実行することが 現実的になるでしょう。 オープンソースのコーディングモデルも追いついてきて、 オンプレミス のエージェントが、 大規模クラウドエージェントに匹敵するほど多くのタスクで十分に優れた性 能を発揮できるようになるかもしれません。

エージェントとツールはより特殊化する

異なるドメインや役割に特化したコーディングエージェントが登場するかもしれません。 例え ば、失敗したテストやエラーログを指定するとバグに的を絞る 「Bug Fixer」 エージェント、プ ロファイリングやホットスポットの最適化に集中する 「PerformanceGuru」 エージェント、 既 存のコードベースからドキュメントやコードコメントを作成する専門エージェントなどが考えら れます。

専門化することで、エージェントはよりドメイン固有の知識やツールを取り込むことができるよ うになります。 例えば、ゲーム開発タスクを支援するためにゲームエンジンと統合するエージェ ントや、データエンジニアリングのパイプラインに特化したエージェントが登場するかもしれま せん。狭いドメインに特化したAI専門家のチームは、人のチームにおける専門知識の分布と似 た形になるでしょう。 ある開発者はフロントエンドで知られ、別の開発者はインフラで知られて いるように、 AIチームメイトとしてDocsBot, TestBot, RefactorBot, Security Bot など、 それぞれの目的に合わせて調整されたエージェントを持てるのです。 実際、 Cursorにはすでに 自動PRレビュー用のBugBotがあり、 この方向性の一歩となっています。 BugBotはコードを 書くのではなく、バグのリスクに焦点を当ててPRにコメントを残します。 まるで超高性能な静 的解析のような存在です。

開発者は文化的、 スキル的な転換を迫られる

エージェントがより日常的なコーディングを担うようになったら、 開発者のスキルセットは 「4 章 70%を超えて人の貢献を最大化する」 で説明したように、 設計、 アーキテクチャ、監督 へと変わっていくでしょう。 (人にもAIにも) 要件を明確に伝えるといったソフトスキルは、さ らに重要になります。 コードの読解やレビューのスキルは、コードを書くスキルと同じくらい不 可欠になるかもしれません。 また、 テストへの重点も高まるでしょう。 テストはAIの出力を検 証するための重要な手段であるため、テストケースをうまく書く (あるいは、 AIに書かせるよう 導く) 能力は引き続き価値があります。

本質的に、 「人間の30%」 は、 ソフトウェア開発における高次の批判的思考や品質管理の側面に 集中することになるでしょう。 ジュニア開発者の成長の仕方にも変化が見られると思います。 彼

11.4 自律型エージェントはソフトウェアエンジニアリングをどう変えるか | 227

らは大量のコードを書く前に、まずAIエージェントを使って簡単なタスクを管理するところか ら始めるかもしれません。 これは、価値をすぐに提供できるという点で良いことですが、基礎 を学び、 AIを杖のように扱わないことが求められるため、挑戦でもあります。 適応する意欲の ある人にとっては刺激的な時代ですが、 従来のやり方を好む人にとっては居心地が悪いかもし れません。 「4章 70%を超えて: 人の貢献を最大化する」 で述べたように、このAI時代にあな たのキャリアを 「将来にわたって有効に保つ」ための大きな要素は、こういったツールを受け入 れ、自分にしかない人としての強みを強調することです。

新しい役割とプロセスが出現する

「AI ラングラー」 (AI世話係) や 「自動化リーダー」といった役割が、 エンジニアリングチームに 登場するかもしれません。 それは、AIエージェントを活用し、 ワークフローを設計し、 それら の構成を維持することに特に長けた人々です。 これは、 ビルドシステムが複雑化したときに「ビ ルド/リリースエンジニア」が登場したり、インフラ自動化が進んだときに 「DevOpsエンジニ ア」が現れたのと似ています。 同様に、AIが不安全なパターンを導入していないかを確認する 監査が、 コードレビューにおいて標準化される可能性もあります。

追加の安心感を提供するために、 テスト文化への強調がより強まるかもしれません。 おそらく、 すべてのエージェントによるPRは、 マージ対象とみなされるために(エージェントまたは人に よって書かれた) テストを含める必要があるでしょう。 AIエージェントが多くのコードを書いて いるなら、 人のエンジニアがより多くのテストを書く (あるいはその逆にする)ことで、独立し た検証を確保すべきかもしれません。

要するに、 バックグラウンドコーディングエージェントが存在する未来とは、開発者がオーケス トレーションと検証を担い、 AIエージェントが実行と実装を行う世界のように見えます (図11-1を 参照)。 ソフトウェアエンジニアリングは、すべての手順を手動で行うよりも、自動化された一連の コーダーを監督することに重点を置くようになるかもしれません。 これによって、大幅な生産性向上 が可能となり、 退屈な雑務を減らし、チームがこれまで時間がなくて取り組めなかった技術的負債 や保守タスクに着手できるようになるでしょう。 (例えば、これまで放置されていた小さなバグや非 一貫性を、 AIに対処させて一掃できると想像してみてください!) さらに、新しいアイデアのプロト タイピングの障壁も低くなるかもしれません。 AIにアプリのプロトタイプ全体を下書きさせて、自 分で微調整できるのです。 また、 AIが素早く代替案を生成できるため、意思決定に至る前により多 くの解決策を検討できるようになるでしょう。

しかし、私たちの業界は、こういった変化を慎重に統合しなければなりません。創造性、 直感、 倫理的判断といった人の要素は、引き続き代替不可能です。 AIは私たちの能力を増幅できますが、 制御されなければ誤りも増幅させてしまいます。

私の展望は楽観的です。 自律型コーディングエージェントは、賢く活用すれば開発者を「より」生 的にし、ソフトウェア構築における本当に挑戦的で興味深い部分に集中できるようにしてくれるで

228 | 11章 コード生成を超えて: AI拡張開発の未来

しょう。 最終的には、より優れたソフトウェアをより速く構築することにつながります。 そのために は、良いプラクティスを育み、 開発者やエンジニアとしての役割が進化していることを認識する必 要があります。

Xを変更 未来 DesignBot CodeBot SecurityBot 適用およびテスト

図11-1 複数エージェントのAI協働のアーキテクチャ。 開発者は、テスト、設計、コーディング、セキュリティに特化 したAIエージェントをオーケストレーションし、包括的なソフトウェア解決策を協働開発する

11.5 プログラミング言語の未来 自然言語駆動開発?

バイブコーディングの未来に関して最も興味深い問いの1つは、それがプログラミング言語をどの ように形作るかという点です。 私たちが 「AIに欲しいものをただ伝えるだけ」で済むなら、 従来の構 文や言語は本当に必要なくなるのでしょうか? 英語 (あるいは他の言語) が新しいプログラミング言 語になるのでしょうか? 本節では、その可能性を探っていきます。

私たちはすでに、 タスクを平易な言葉で説明するとAIがコードを書くというツールで、 自然言語 がコードとして機能する兆候を目にしています。 この傾向が続けば、プログラミングの労力は実装よ りも 「意図」 や 「要件」 の指定に移っていくかもしれません。 将来の開発環境では、開発者が(さらに は非開発者でさえも) 次のように書けるようになる可能性があります。

毎時間、 データベースで非アクティブユーザーを確認し、 90日間ログインしていないユーザーに、 テンプレートXを使ってリマインダーメールを送信して。 メールがバウンスしたら、 データベー スでそのユーザーを 「無効メール」 とマークして。

AIはこの仕様を受け取り、 (cron ジョブやスケジュールされた関数のセットアップ, SQLクエリ の作成やORMの利用、 メール APIの呼び出しといった) 適切なコードに変換できます。 本質的に、 プログラマーの役割は、ポリシーや振る舞いの説明により重点が置かれるようになります。

11.5 プログラミング言語の未来 自然言語駆動開発? | 229

だからといって、プログラミング言語が一夜にして消えるわけではありません。 むしろ起こり得る のは 「階層化」 です。 高レベルのオーケストレーションに自然言語を使い、裏では細かな制御のた めに既存のプログラミング言語が使われる、 という形です。

プログラミング言語が存在する理由の1つは、自然言語が曖昧になり得るからです。 形式言語を完 全に取り除いてしまうと マシンとの間で誤解が生じる危険があります。 AIは、コンテキストに基 づいて曖昧さを解消したり、確認のための質問を投げかけたりすることでこのギャップを埋めるかも しれませんが、限界はあるでしょう。 特定の複雑なアルゴリズムや最適化は、散文よりもコードで伝 える方がはるかに容易な場合があります。 したがって、 将来のプログラマーはある意味でバイリン ガルである必要があると考えられます。 AIと対話するために人の言語に堪能であり、 AIが生成した ものを検証、調整するために基盤となる技術的概念にも堪能である、ということです。

「ドメイン固有自然言語」の台頭も見られるかもしれません。 AIが確実に理解できるよう制約され た英語 (あるいは他の言語) の形式で、 ソフトウェア領域に特化したものです。 例えば、 ユースケー スを説明するための 「要件言語」があり、 AIがそれをテストやコードに変換できます。

たとえ完全な自然言語にまで至らなくても、 AIの影響によって、 プログラミング言語はより高い 抽象化レベルへと進む可能性があります。 過去には、 アセンブリから高水準言語へ、 手動のメモリ 管理からガベージコレクション環境へと移行し、 そのたびに抽象化レベルが引き上げられてきまし た。 AIは、すぐに抽象化を定義できるようにしてくれるかもしれません。 本書全体で論じてきた 「意図によるプログラミング」の観点で考えてみてください。 目標を指定すれば、AIがそれを達成す る方法を見つけ出し、必要に応じて低レベルのコードを書くことも可能になるのです。

もう1つの可能性は、 自然言語とコードを融合させた「ハイブリッド」 言語です。 例えば、 将来の 言語では、次のようなコードが可能になるかもしれません。

// 注文から顧客名のリストを作成し、 重複を除外して

// アルファベット順に並べ替え、 それから出力する

list<Customer> customers orders -> map(order -> order.customerName)

-> unique() -> sort() -> print();

この疑似的な例では、日本語で書かれたコメントは、AIによってほぼ実行可能です。 実際の環 境では、ラムダ構文すら必要ないかもしれません。 AIがコメントからあなたの意図を推測し、それ を補完できるからです。 あるいは、その言語には日本語のように見えますが、 AIが確実に解析でき るほど形式化された構文が備わっているかもしれません。 これは、コメントや疑似コードが実際の

230 | 11章 コード生成を超えて AI 拡張開発の未来

コードへと進化し、 AIがその背後にある意図を解釈するようになる姿だと考えられます。 コーディングは、すでにより会話的になりつつあります。 完全なプログラムを書く代わりに、 AI との対話を始めるのです。

プロンプト: 「顧客の購入履歴に基づいて、ポイントを計算する関数が必要です。」

AI 「もちろんです。 すべての商品が、 同じようにポイント対象になるのでしょうか? それとも、 一部の商品により多くのポイントを付与するのでしょうか? また、時間の要素 (例えば、 最近の 購入と過去の購入)をどのように考慮すべきでしょうか?」

プロンプト 電化製品には、 他のカテゴリと比べて2倍のポイントが付与されます。 また、直 近1か月の購入には、 10%のボーナスが付きます。」

A1: 「了解しました。 こちらが、 その機能を実装した関数です... [AIがコードを提示] 。 異なる シナリオに対するテストも生成しましょうか?」

プロンプト: 「はい。 そして、購入履歴が存在しない場合に適切に対処するようにしてください (0ポイントを返すべきです)。」

このシナリオでは、 自然言語によるAIとの対話の中で、プログラミングが進みます。 AIがコード を書き、確認の質問を投げかけるのです。 これはペアプログラミングに似ていますが、 相手が人で はなくAIである点が異なります。 すでに ChatGPTのプラグインや GitHub Copilotチャットなど で、 初期の形が見られます。 将来、 これがソフトウェア開発の支配的な形態になる可能性がありま す。会話を通じてソフトウェアを段階的に改良していく方法であり、ゼロから厳密な静的テキスト ファイルを書くよりもはるかに流動的です。

コーディングの多くが自然言語駆動になったとしても、コードやコンピューターの仕組みを理解 することは引き続き重要です。 電卓やスプレッドシートが登場しても、数学者や会計士が計算を理 解する必要がなくなったわけではありません。 同様に、AIの出力がどこかで「ずれている」ことを見 抜く力が必要です。 AIが日本語の指示を誤解したら、熟練した開発者は疑似コードや実際のコード に切り替えて、意図を明確にするでしょう。 したがって、 構文の細かい知識はそれほど重要ではな くなるかもしれません (AIがAPIのパラメーター順序を補完できるなら、 覚える必要はありません)。 しかし、アルゴリズム的思考やデバッグ能力は、引き続き不可欠です。 言語は変わるかもしれませ んが、基礎となる論理や問題解決のスキルは持続するのです。

しかし、プログラミングへの参入障壁はすでに低くなっています。 非開発者やドメイン専門家でも、 バイブコーディングを通してAIと対話しながら、簡単なアプリケーションを直接作成できます。 こ の民主化は非常に刺激的です。 深いプログラミング知識がなくても、より多くの人々がソフトウェア の解決策を生み出せるようになるのです。 そしてプロ開発者は、より難しい問題に取り組んだり、 市 民開発者が作成したスクリプトを安全に統合したり、 そうした対話を可能にするプラットフォームを 構築したりする役割を担うことになります。

AIが自然言語でのコーディングを助ける一方で、 AI自体がその中間に位置する新しい「言語」を

11.6 バイブコーディングはどのように業界を再構築しているのか | 231

進化させる可能性もあります。 おそらく、AIにとって使いやすい新しいプログラミングパラダイム が登場するでしょう。 つまり、AIが空白を埋められる余地を残すような言語です。 例えば、 (「【ここ で速度を最適化]」 のような) AIが解決できるプレースホルダーを含む、部分的なプログラムを許容 する言語や、 ファジー理論を使ってAIが決定論的なロジックに改良できる言語などです。

結局のところ、 自然言語によるプログラミング言語の完全な置き換えではなく、両者の融合が起 こる可能性が高いでしょう。 それは、 開発者にとってより表現力を高め、 コンピューターに対して より直感的に指示を与える方法となります。 アンドレイ・カルパシーが的確に述べている (https:// www.youtube.com/watch?v=LCEmiRjPEtQ) ように、 「プログラミングの未来は、もはや完璧な コードを書くことではないのかもしれません。 むしろ、 自分の望みを完璧に説明することなのかもし れません」。 プログラミングの本質、つまり、問題を明確に考え、解決策を指定することは変わりま せん。 しかし、その指定の形式はより自然なものに進化し、翻訳者としてのAIが高レベルの意図を 低レベルの実行に変換していくでしょう。

このような未来は大きな可能性を秘めています。 より高速な開発、 より高いアクセシビリティ、 「どのように入力するか」という細かい作業ではなく、 「何を達成したいか」に集中することで、ます ます複雑なシステムを構築できるようになるのです。 いつものように、 抽象化が飛躍するたびに創造 性は爆発的に高まりました (高級言語は、アセンブリでは決して到達できなかった規模のソフトウェ アを可能にしました)。 自然言語駆動開発は、 バイブコーダーが最前線に立ち、文字通りソフトウェ アを通して新しい世界を 「語り」 ながら創り出し、さらなるイノベーションの波を解き放つかもしれ ません。

訳者補

本書執筆後の2025年後半に登場した新たな概念として、SDD (Spec Driven Development. 仕 様駆動開発) があります。 SDDは、 ソフトウェア開発においてコードを書く前に仕様を明確に定義 し、その仕様を基盤として設計、実装、テスト、 ドキュメントまで一貫して進める手法です。 仕様 を唯一の情報源とすることで、認識のずれを減らし、品質と効率を高めることができます。 代表的なSDDツールとして、 GitHub Spec Kit とKiro を紹介します。

GitHub Spec Kitは、 SDDを支援する軽量ツールです。 仕様をYAMLやMarkdownで記述し、 GitHub イシューやブルリクエスト(PR) に統合できます。 これによって、 チーム全員が同じ仕様 を参照しながらタスク分割やコード生成を進めることができます。 OSS コミュニティや小規模チー ムでも導入しやすいのが特徴です。

Kiroは AWS が提供するAI統合型IDEであり、より大規模な開発向けに設計されています。 仕様 を基盤に設計、実装、 テストまで自動化し、 AIエージェントが協働してプロパティベーステスト (PBT) やクラウド連携を行うため、 エンタープライズ環境での品質保証や効率化に強みを持ってい ます。

11.6 バイブコーディングはどのように業界を再構築 しているのか

本書を通して、 いくつかの基本的な原則やアイデアが浮かび上がってきました。

232 | 11章コード生成を超えて AI 拡張開発の未来

実装よりも意図を重視する

バイブコーディングは、逐次的なコード記述から、 意図や望む成果を表現し、 実装の詳細をAI に任せるという方向に焦点を移します。 これによって、 問題への取り組み方が変わり、私たちは 「何を達成したいか」をより重視し、 「どのように入力するか」 にあまりこだわらなくなります。 これは、ソフトウェア開発をより高レベルで捉える方法です。

協働パートナーとしてのAI

バイブコーディングにおけるAIは、 単独のツールとして使われるのではなく、 ペアプログラ マーやアシスタントのような存在です。 それは対話的で反復的なプロセスです。 私たちは、(プ ロンプトエンジニアリングを通して) AIを適切に導くこと、 その出力をレビューすること、私た ちの強みをAIの強みと組み合わせることがいかに重要かを見てきました。 未来は 「AIがプログ ラマーに取って代わる」のではなく、 プログラマーがAIとともに働き、 生産性を高めるのです (https://oreil.ly/OuP00)。

倫理と責任

私たちは、 (AI) 大いなる力には大いなる責任が伴うことを強調しました。 バイアスの軽 減、 公平性の確保、 プロセスの透明性の維持、 説明責任の保持はすべて重要です。 業界は、 ガー ドレールなしでAIに依存すると問題を引き起こす可能性があることを認識しており、 そのた め、AIの出力をテストすること、AIの関与を文書化すること、 (AIが生成したコードの知的財 産権のような) 法的問題に対処することに関するベストプラクティスが、 標準的な手続きの一部 になりつつあります。

AIはコード生成を超える

AIの役割は、テスト、デバッグ、設計、プロジェクト管理などにまで広がっています。 この包 括的な統合によって、ソフトウェアライフサイクル全体がAIによって加速、 強化されるのです。 こういった段階を支援するツールは、 今後ますます増えていくでしょう。 すでに、IDEでのAI テスト生成や、AIベースのプロジェクトスケジューリングツールといったものが存在していま す。

スキルは進化し続けているが、基礎は不変である

前述のプラクティスを受け入れるプログラマーは、自らのスキルセットが進化していることに気 付くでしょう。 従来のコーディングやアルゴリズムのスキルに加えて、プロンプトエンジニアリ ング、AIの監督、データ分析、 高水準の設計が含まれるように変わっていきます。 問題解決の 根本的な思考姿勢は引き続き重要ですが、日々のタスクは異なって見えるのです。 それでも、 基礎は揺るぎません。 問題領域を深く理解すること、明確な仕様を書くこと(ブロン

*3訳注:「大いなる力には、大いなる責任が伴う」 (With great power comes great responsibility) は、古くからの格言であり、 スパイダーマンの物語で有名になったフレーズです。

117 まとめ次の一歩 |

プトは基本的に仕様です)、 厳密なテストと妥当性確認を維持すること、ユーザーのニーズに焦 点を当てることです。 AIはこれらを変えるものではなく、むしろその重要性を増幅します。な ぜなら、曖昧さや不明確さは、AIの超高速な実行によって拡大され得るからです。

この新しいバイブコーディングというパラダイムは、実践的な形で業界を再構築しています。 AI ツールを導入したチームは、 生産性が大幅に向上したと報告しています。 開発者はより短時間で機 能を完成させたり、 同じリソースでより複雑なプロジェクトを扱えるようになっています。 また。 参 入障壁も低くなり、 経験の浅い開発者でもAIの指導によって多くを達成でき、より早くレベルアッ プできる可能性があります。 一方、経験豊富な開発者にとっては、視野を広げ、古いワークフロー に安住しないよう促す力にもなっています。

企業は、プログラミングの知識だけでなく、 「AIリテラシー」、 つまり、 AIツールを効果的に活用 する能力を持つ人材を採用し始めています。 近いうちに、求人票にはバージョン管理やクラウドプ ラットフォームの知識と同様に、AIコーディングアシスタントへの習熟が求められるようになるか もしれません。 したがって、 バイブコーディングの先駆者となることは、キャリア上の優位性をもた らすのです。

重要なのは、 バイブコーディングが、 ある程度プログラミングを民主化するという点です。 従来 のソフトウェアエンジニアではない人々も、自分の望むものを説明することでソフトウェアの作成に 参加できるようになります。 これによって、 ニッチなニーズに合わせたソフトウェアが、AIの助け を借りたドメイン専門家によって生み出される可能性があります (プロ開発者は、そのためのガード レールやプラットフォーム、 洗練された中心的なコンポーネントの提供に注力することになります)。

今は刺激的な時代です。 私たち開発者は、自ら形作ることのできる変革の瀬戸際に立っています。 コンピューティングの黎明期を思い返してください。 パーソナルコンピューター革命を受け入れた 人々が、 今日の世界を創り上げました。 現在、 プログラミングにおけるAIは同様の転換点にありま す。 それを受け入れることは、 今後数十年にわたってソフトウェアがどのように構築されるかを定義 する一端を担うことを意味します。

11.7 まとめと次の一歩

プログラミングの未来は、ただ私たちに訪れるものではなく、私たち自身が創り出すものです。開 発者コミュニティの一人ひとりが、 バイブコーディングやAIツールの採用、規制、 発展において果 たすべき役割を持っています。 これは、読者であり実践者であるあなたへの行動の呼びかけです。

実験する

すべての答えが与えられるのを待ってはなりません。 外に出て、さまざまなコンテキストでバイ ブコーディングを試してみましょう。 AIを使って、 風変わりで新しいものを作ってみてくださ い。こういったツールができることの限界を押し広げてみましょう。 もしかすると、まだ誰も文 書化していない新しいユースケースや制約を発見するかもしれません。 成功でも失敗でも、実

233

234 | 11章 コード生成を超えて AI 拡張開発の未来

験はコミュニティに知識をもたらすのです。

発見を共有する

自分の経験について書くか、 少なくとも仲間と議論しましょう。素晴らしくうまくいく技術を見 つけたら、公開してください。 落とし穴に遭遇したら、他の人に警告しましょう。 この急速な進 化の中で、 コミュニティの知識共有こそが私たち全員がついていく方法です。 AIの癖に対する 解決策を投稿することで、誰かのデバッグ作業を数日分教えるかもしれません。 クールなAI支 援プロジェクトを共有することで、 誰かの創造性を刺激できるかもしれません。

ツールに貢献する

意欲があるなら、 AIツールそのものの開発に貢献してください。 これは、オープンソースのAI フレームワークにコードを提供することを意味するかもしれませんし、あるいは、 ツールの開 発者に詳細なフィードバックを送るだけでも構いません (多くの開発者は、 改善点についてユー ザーからの声を非常に熱心に求めています)。 ツールの方針に関わることで、 未来がどのような 姿になるかに直接影響を与えられます。 今日の多くのAIコーディングアシスタントが大きく進 歩してきたのは、あなたのような開発者がベータ版をテストし、 知見を提供してきたからなので す。

前向きな変化を提唱する

あなたの組織やコミュニティの中で、 生産性向上のためにAIを活用すること、人々がそれを正 しく使えるように研修を行うことを提唱してください。 マネージャーには、AIツールを学ぶた めの時間を認めるよう促したり、誤解から使用を禁じているポリシーを更新するよう働きかけま しょう。 AIを安全かつ有益に活用できる方法を示してください。 AIがチームを前向きに拡張す る成功事例が増えるほど、業界全体がそれを受け入れるようになります。

生涯にわたって学ぶ姿勢を持ち続ける

この新時代において、 私たちは皆、 学生であるという心構えを持ちましょう。 謙虚さと柔軟な心 を保ち続けてください。 (今日の新卒が、年長者よりもコーディングに多く触れて育ってきたよ うに) 未来のジュニア開発者は、 AIツールを生まれながらに扱えるかもしれません。 経験の有 無にかかわらず、誰からでも学ぶ準備をしておきましょう。なぜなら、これは誰にとっても何ら かの意味で新しいものだからです。 学生のような心構えを持ち続ければ、 常に成長を見いだし、 「すべてを理解した」 と思い込む罠を避けられるでしょう。

熱意と慎重さのバランスを取る

可能性に対して熱意を持ちましょう。 その興奮は他の人を鼓舞します。 しかし、必要な時には 慎重さを代弁する存在にもなり、興奮が不注意な利用につながらないようにしましょう。 例え ば、AI駆動開発を推進すると同時に、AIの出力に対して単体テストやコードレビューを行うこ

11.7 まとめと次の一歩

とを強調してください。 このバランスの取れたアプローチこそが、 バイブコーディングを持続可 能で尊敬されるものにします。

次世代を指導する

熟達するにつれて、 新参者を助けましょう。 バイブコーディングは参入障壁を下げるため、より 多くの初心者がプログラミングに飛び込むかもしれません。 彼らは、AIが抽象化してしまうか もしれない確かな基礎を学ぶための指導を必要とします。 彼らを指導することで、次世代の開 発者が理解なしにAIに過度に依存することを防げます。 あなたは、 AI拡張ソフトウェアエンジ ニアリングの良いプラクティスという伝統を、 次世代に継承することになるのです。

私たちが目の当たりにしている指数関数的な変化は、 稀有な機会です。 産業革命からインター ネットの隆盛に至るまでの、 過去の技術的飛躍を思い返してください。 それらに関わった人々が産 業全体を形作りました。 現在、 ソフトウェア開発におけるAIは、 まさにそのような岐路にあります。 これは単に仕事を維持したり楽にすることではなく、 技術がどのように進化し、 社会にどのような影 響を与えるかに発言権を持つことなのです。

あなたは、本書を読むことで、あなたが先見の明のある人であることを示しました。 今、その先 見性を行動に移すことをお勧めします。 AIとともに書く一行一行のコード、設計するすべてのプロ ンプト、教える同僚一人ひとり、影響を与えるすべてのポリシーのすべてが、 バイブコーディングの 未来に寄与するのです。

最後に、 忘れないでください。 根本にあるのは、コーディングは常に創造と問題解決のための営 みだということです。 AI駆動のバイブコーディングは、創造のための非常に強力な新しい媒体です。 楽観と好奇心を持って受け入れましょう。 そして、それを使って意味のあるものを構築してください。 その際には、常に人の要素、 つまり、私たちの創造性、 判断力、 価値観を中心に据えてください。

プログラミングの未来は、 今まさに描かれつつあります。 それはコードの中だけでなく、私たちが こういったAIパートナーを作業にどう統合するかという選択の中にもあります。 これは刺激的で未 知の道であり、 私たち一人ひとりが開拓者になれるのです。 だからこそ、 一歩踏み出し、 大胆に実 験し、自由に共有し、 人間の知性と精神の最良の部分で導いてください。 そうすることで、単に未 来に適応するだけでなく、積極的にその未来を形作ることになるのです。

楽しいバイブコーディングを! そして、 あなたが創り出す未来でお会いしましょう!

235



1237

索引

70%問題

数字

人の貢献を最大化-

A

AI(人工知能)

アシスタント開発者

安全網なしでの問題解決とデバッグ-

~拡張開発-

215-235

自然言語驅動開発-

ソフトウェアエンジニアリングへの影響-223-228

知的なデバッグ

228-231

テストの自動生成・

バイブコーディングの影響

バイブコーディングの未来を形作る

-216

233-235

プロジェクト管理

〜生成コード 99-108 開発者の役割 107 コードの可読性と構造 101 多数派の問題 100 テストの重要性 - 106 デバッグ戦略 103 保守性のためのリファクタリング 105 パターン 170-171 複数のAIモデルを組み合わせて強みを最大化 203-206 フルスタック開発におけるリアルタイムの 136-139 ペアプログラマーとしてのAI- 74.77,201 ~ベースのコーディングツール 新しい抽象化や戦略- 70 苦労している点 70 説得力はあるが正しくない出力 70 テストの提案を統合 107 優れている特定のタスク 69 ベストプラクティス・ 77 ミドルエンジニア 90 232 Angular 123 ヒント 128 Anthropic 22 API AIを使ったバックエンド/API開発パターン 128-132 ウェブアプリ バックエンド フロントエンド 123 127

220-223

予知保全とリファクタリング

苦労している点

検証者:

コーディング支援

コーディングの範囲

コード生成を超える

最初の下書き作成者としてのAI

~支援エンジニアリング

217

75,78

自律型AI コーディングエージェント

74-75

AIパートナーとの構造化されたアプローチ 10-7 バイブコーディングとの違い 10

優先すべき場合

232

215

35

信頼性

33

73

69-71

70

-83

-93

-201

4

3

3

238 索引

エラー処理 136, 160 Clineによる作成 110 時代遅れ 103 ウェブアプリのフロントエンド 126 ベネトレーションテストとファジング 155 CSVファイル 117 async/await- 165 Cursor 37 Cursor IDE 23, 111, 195, 198 B Bandit- bcrypt Bolt.new- Geminiの統合 28 154 既存のコードを編集 22 150, 152 コード生成 22 -111 バックグラウンドコーディングエージェント 197,207 プロのワークフローで効果的に使う･ 23 C ChatGPT- 5 D Cursorで使う 22 DeepSeek OpenAIの利用規約・ 181 Devin 多用途 29 AIチームメイト CI/CD (継続的インテグレーション / 継続的デプロイ) DevOps パイプライン 自動化 174 バックグラウンドエージェント Django 自律型コーディングエージェント 202 Doev. GitHub, Inc. 集団訴訟- 27 199, 201 -207, AIも参照 -74,87 -202 130 182 セキュリティ 175 デプロイ回数への影響 177 E Claude 5,22,26 EC (ecommerce site). 141 推論の名人 29 ESLint -154 ニーズに合ったモデルを選択 30 EU AI 185 複数のAIモデルのサポート 27 Express ルート 128 Cline 21-22, 110-111, 195 VS Code 22 F Code Assist 28 Few-Shot プロンプティング (few-shot prompting) 52 Codex 5, 196-198,206 Copilot 200 G GitHub GitHub Copilotを参照 Gemini 19,22 コバイロット型アシスタントの受動的性質 201 ニーズに合ったモデルを選択 -30 訴訟 182 複数のAIモデルのサポート 27 CRUD (作成、 読み取り、更新、削除) 操作 31 マルチモーダルコーディング機能 28 アプリケーション 32 GitHub CodeQL -154 機能のプロトタイピング 32 GitHub Copilot 195 CSS エディター内 202 AIによるスタイル付けの出力 115 訴訟 182 AIによる生成 109 プルリクエスト 172 AIによるライブラリの統合 114 Google Gemini -Gemini を参照

索引 239

Google Jules- Google LLC 対 Oracle America, Inc. 事件 GPT-4 -207, Jules も参照 複数のAIモデルのサポート 27 181 モデル 26,30 181 ORM (オブジェクトリレーショナルマッピング) 129-130, 133 H OWASP Helmet ミドルウェア 157 ZAP- HTML/CSS AIアシスタントを使って作成 トップ10 155 156 110 AI デザインツールによる生成 -218 AIによる生成 -109 PoC (概念実証) 109 Clineによる作成 110 PostgreSQL 129 UIレイアウト AIによる生成 205 PR(プルリクエスト) 171 エージェントによる PR- 210 | レビュープロセス -199 IaC (コードとしてのインフラ) 174 IDE (統合開発環境) R AI拡張 AI駆動 警告やフラグ 111 RAG (検索強化生成) 24 5 React- 123 -158 ヒント 128 コーディングエージェント -200 ReAct (Reason+ Act) プロンプト -60 従来のコーディングに溶け込むAI機能 12 RESTful API- 128 統合型エージェント・ 207 Ruby on Rails 130 フルスタック開発 136 S SAST (静的解析ツール) 154 Jules -195-197,201, 207 screenshot-to-code 111 Semgrep- 154 L LLM (大規模言語モデル) Lovable Sequelize 133 3,204 Snyk- 157 111 ベストプラクティス・ 158 Sonnet モデル 29 M SQL MongoDB 129 インジェクションの脆弱性 -148 MVP (実用最小限のプロダクト) ウェブアプリ 9, 142 データベースクエリ 133 142 マイグレーションスクリプト 133 OpenAI TODO コメント Codex 5, 196-198, 206 ToS (サービス利用規約) ToS (サービス利用規約) 181 T 120 181

240|索引 U 曖昧なプロンプト (vague prompt) +63 UIとUX デザイン 36 アクションと推論 (actions and reasoning) 60 AIアシスタントによる素早いプロトタイピング 109 アクセシビリティ (accessibility) 219 AI駆動プロトタイプ 118 足場 (scaffolding) 7 UXリサーチのためのAI 219 アルゴリズム (algorithm) 生成デザインツール 218 ジュニア開発者 93 パーソナライズされたユーザー体験 ミドルソフトウェアエンジニア 219 パフォーマンス最適化 163 91 安全システム (safety system)- 56 V 安全ではないデフォルト (insecure defaults) アンチパターン (antipattern) -149 Vercel v0. -111 大きな泥だんご -167 VS Code (Visual Studio Code)- 195 二歩下がる。 -72 AI 拡張機能 200 ブロンプト 63-66 Cline 22 移行点 (transition point) -34 Vue Geminiの統合 ヒント 28 意思決定サポート (decision support)- 222 123 依存 (dependence) -73 128 依存関係 (dependency) 123 Cline -21 W React DuseEffect 777 -127 WebSockets Windsurf IDE Geminiの統合 136 インストール 196 24, 111 カスケードビュー 強さ ཌ ༀ མཾ སོ 管理と更新 -150 28 更新 217 25 責任あるAIチェックリスト 193 26 一貫性 (consistency) 意図 (intent) 38 AIによる解釈 36 XSS (クロスサイトスクリプティング)- 149 実装よりも重視 232 プログラミング 3, 13-17, 99, 110 Z ZAP (OWASP) 155 インストラクターの役割 (instructor role) ウェブアプリケーション (webapplication) 55 123-143 AIによるスキャフォールディング 123-125 あ行 AIを使ったバックエンド / API開発パターン128-132 アーキテクチャ (architecture) エンドツーエンドのワークフロー 123 基礎的テキスト 167 成功例 -141-143 人の監督 ミドルエンジニア 90 データベースの設計と統合 132-135 90 テストと検証 139-141 モジュール性 166 複数モデルアプローチ 205 アーキテクト (architect) 84 フルスタックの統合 135-139

アーティファクト機能 (Artifacts feature)

曖昧な参照 (ambiguous references)

運用ランブック (operational runbook)

126-128

-176

29

44

フロントエンド開発パターン

エッジケース (edge case)

索引 241

100

162

5

AIの対処

品質保證

ブレインストーミング

116

エ (error) ラー

103-104

エラー処理 (error handling)

AI生成システムのためのテスト

機密情報が漏れる。

160

エンジニア (engineer)

150

強化すべきスキル

97

83-86

シニアエンジニアと開発者

ミドルエンジニア

エンジニアリング (engineering)

会話 (conversation)

86-92 過剰なプロンプト (overloaded prompt)

規律を守る。

ラピッドプロトタイピングモード

エンドツーエンドテスト (end-to-end test)-

より高速なサイクル

開発者 (developer)

エンドポイント (endpoint)

37

AI生成コードの著作者

文化的、スキル的な転換

181

-226

63

-117

会話型インターフェイス (conversational interface)

117

106

APIエンドポイントの実装

多段階の操作のオーケストレーション。

大きな泥だんご (big ball of mud)

-130

オーケストレーションシステム (orchestration system)

オープンソース (open source)

AIモデル

規範

集団訴訟

パブリックドメインを意味しない。 オブザーバビリティ (observability)オブジェクトリレーショナルマッピング (object-relational mapper, ORM) オフバイワンエラー (off-by-one error)

129-130

182

174

解決策 (solution)

か行

消費から作成へ考え方を変える。 多数派の問題

概念実証 (proof of concept, PoC)

開発 (development)

劇的に開発時間を加速

ライフサイクル

111

会話によるコーディング (code by conversation)-07-4 可観測性 (observability) 174

64

カスケード削除 (cascading delete)-

可読性 (readability)

134

-128

128

過度の依存 (overreliance)

-101

-38

ガバナンスとプロセス (governance and process 193

-167

環境 (environment).

監査 (audit)

43

セキュリティ

パフォーマンス監視 監視 (monitoring)

204

27

140,175, セキュリティも参照

感情やチームの健康状態の把握

161

-222

(emotional and team health insight)

関数 (function)

180

潜在的な問題

パフォーマンス最適化

180 リファクタリング

175

102

163-166

監督型コーディングエージェント

-105

(supervised coding agent) キー管理 (key management)

102

96

100

195

技術的負債 (technical debt)

175

109

基礎 (fundamentals)

不変-

170

学不重要性。

232

帰属表示 (attribution)

185

93

期待 (expectation)

AI 支援

機能横断的 (cross-functional)

キャッシュ (caching)

計画先行

4

10

境界 (boundary)

8

89

パフォーマンス最適化

90

165

242 索引

管理

コンポーネント

協働 (collaboration)

86

機能

協働パートナーとしてのAI

76

232

ジュニア開発者とチームメンバー

96

フルスタック開発

具体性 (specificity)

137

組合せ論 (combinatorial math)

64

クラウドベースのコマンドラインエージェント

54

86

(cloud-based command-line agent)

206

繰り返しのコード生成 (repetitive code generation)-33 グルーコード (glue code) 32

グレーゾーン (gray area)

コードとしてのインフラ (infrastructure as code, laC)

(cross-site scripting、 XSS)

計画段階 (planning stage)

継続的インテグレーション / 継続的デプロイ (CI/CD) パイプライン -CI/CD を参照

検索強化生成

(retrieval-augmented generation. RAG) 検証 (verification)

AI生成ウェブアプリケーション AI生成コード

AIを使ったバックエンドAPI開発パターン

自律型コーディングエージェント

198

検証者 (validator)

174

24

140

74,78

構成 (configurations)

公正使用 (fairuse)

公平性 (fairness)

声に出しながら考える (thinking out loud)

コーディング基準 (coding standard)

コーディングの範囲 (coding spectrum)

コードエディター (code editor)

コード生成 (code generation)

コードベース (codebase)

Windsurf

平易な言葉で質問

コードレビュー (code review)

AI生成ウェブアプリケーション

エージェント生成コード

-202

ジェネレータ対レビュアーの非対称性・ 責任ある AI-

構文の問題 (syntax issue)

セキュリティチェックリスト 戰略

25

202

クロスサイトスクリプティング

184

-149

計画と監視の機能 (planning and oversight features)

-155

193

増幅するボトルネック

-171-173

197

チーム規範

209

別のAIをレビュアーとして使う

-170

ミドルエンジニア

-154

-88

211

互換性の制約 (compatibility constraints) 国際化 (internationalization)-

-57

故障モード (failure mode)-

コスト最適化 (cost optimization)

24

コミュニケーション (communication) AIを使った反復作業

114

-89

139-141 コメント (comment)

93 コンテキスト (context)

129

101, 169

149

180

187

-90

機能橫断的

ジュニア開発者とチームメンバー

186-189

96

AI支援コーディングにおける活用-

Claudeの幅広い理解

Cursorのプロジェクト全体のコンテキスト

54

15

-29

ウィンドウ

-103

19,53

166

24

グローバルコンテキストの提案

~に応じたプロンプティング

コンポーザーモード (Composer mode)

12 サーバー (server)

繰り返し

反復サイクルとコード生成におけるAIの役割 14-17

-56

25

22

さ行

22

サービス利用規約 (ToS)最初の下書き (first drafter)

33

90

123

削除 (delete)

CRUD

-74-75

181

32

カスケード

索引 243

175

差分 (diff

差別 (discrimination)

参照 (reference)

199 社内ダッシュボード (company dashboard) 出力 (output)

暧昧

192

ブロンプト

134 シャドゥテスト (shadow testing)

-65

シークレット管理ツール (secret management tool)-175

ジェネレータ (generator)

ジェンダーバイアス (gender bias)

44

203 ジュニア開発者の死 (death of the junior developer)

自己一貫性 (self-consistency)

187

58

思考の連鎖 (chain-of-thought. CoT) プロンプティング

ReAct プロンプト

53-55

-60

形式

システム (system)

強化すべきスキル

指示

44

複数の出力と多数決

57

58

65

92

101, 106

97

システム思考を学ぶ

設計とアーキテクチャを学ぶ

システム統合 (systems integration)

89

自然言語駆動開発

(natural-language-driven development)- 228-231 自然言語コーディング環境

(natural-language coding environment) 自然言語によるステータスクエリ -12

(natural-language project status query) 実験 (experimentation) 222

AI支援コーディングによる強化

実行 (execution)

失敗 (failure)

失敗パターン (failure pattern)

AI支援コーディング

デモ品質の

質問 (question)

実用最小限のプロダクト

(minimum viable product. MVP)- ウェブアプリ

指導 (mentorship)

-141

無視

長さ (verbosity)-

所有権 (ownership)-

107, 181, 210

自律型バックグラウンドコーディングエージェント

(autonomous background coding agent) IDE AIアシスタントとの違い

195

概要

課題と限界

-200

195

86

仕組み

主要プレイヤー

208-210

考え方を促進

実行段階 (execution stage)

196-200

206-208

ソフトウェアエンジニアリングへの影響 223-228

ベストプラクティス

211-213

自律的型AIコーディングエージェント

37

17

73

187

22

201

198

176

9,142

(autonomous Al coding agent) VS Code と Clineを使う 人種的バイアス (racial bias) 信頼性 (reliability)

158

コード周辺のインフラや運用

推論 (reasoning)

177

-26

スキャフォールディング (scaffolding)

123-125

スキル (skill)

72

74

-64

進化-

基準を設定

232

ソフトウェアエンジニアリング

退化

97

スケジューリング (scheduling)

ジュニア開発者

85

38

142

スコープクリープ (scope creep)

スタイル付け (styling)-

221

119

126

スタイルのガイドライン (style guideline) ステート (state)

管理-

105

63

フルスタックアプリにおける管理

95 ステートフルな会話 (stateful conversation)

127, 136

136

63

244 索引

221

スプリント計画 (sprint planning)

スプロール (sprawl)-

166

64

成功基準 (success criteria)

生産性 (productivity)-

静的解析ツール (static analysis tool、 SAST)

制約 (constraint)

37

た行

154

コンテキストに応じたプロンプト

プロンプトに含める

57

44

責任あるAI (responsible Al)

3,204

黄金律

チェックリスト

-43

189-192 タイミング攻撃 (timing attack)

192

責任と倫理 (responsibility and ethical concerns)-232 セキュリティ (security) 147-158

アナリスト

一般的な脆弱性

147-153

55

監查

懸念

スキャナー

140, 154-158

脆弱性

常に警戒

154

117 単体テスト (unit test)

パッケージ管理の問題-

ソフトスキル (soft skill)

大規模言語モデル (large language model、 LLM)

曖昧なプロンプト

体験 (experimentation)-

設計

-119

-197

-163, 215

ユーザー

多数派の解決策効果 (majority solution effect) タスク (task)

-100

自律型コーディングエージェント

適したモデルを選択-

211

-141

153

不適切な認証認可

ゼロからのプロダクト開発

(zero-to-one product development)

ゼロショットプロンプティング (zero-shot prompt) 先見性 (foresight)

175

151

85,87

戦略 (strategy)

AIベースのコーディングツール コードレビュー戦略

ダッシュボード (dashboard)

妥当性確認 (validation)

多様なチーム (diverse team)-

段階的ロールアウト (staged rollout)

AI 生成ウェブアプリケーション

AI生成コード

セキュリティ

31

51

171-173

デバッグ

70

ブロンプト

双方向の変換 (bidirectional translation)

ソース (source)

速度に最適化されたモデル (speed-optimized model)

185

組織的課題 (organizational challenge)

ソフトウェアエンジニアリング (software engineering)

27

強化すべきスキル

自律型エージェントはどう変えるか

-152

27

-139

188

174

139

39

チーム統合型エージェント (team-integrated agent)

-106, 159

-156

操作モード (modes of operation)

-207

チームプラクティス (team practice) -

212

知識のパラドックス (knowledge paradox) 知的財産 (intellectual property)-

疑わしい出力

-153, 179-184

30

-73

183

25

グレーゾーン

103

184

179-182

コードの著作権、ライセンス、 所有権

43 チャット指向プログラミング

(chat-oriented programming, CHOP)

チャットベースのインターフェイス (chat-based

210

interface)

忠実度 (fidelity)-

-84

著作権 (copyrights)

223-228

AI生成コード

保護の対象

111

97

著作者 (author)

12

179-181

-182

ツール (tool)

181

85

索引 245

AIプロトタイピングツール

111-112

103-104

開発エコシステム

19-26

コーディングの範囲

12

ジュニア開発者のAIツール構築スキル。

95

使用の明示

セキュリティに重点を置く

185

157

データ一貫性規則 (data consistency rule)-

データ構造 (data structure)

134

93

データバイアス (data bias)

187

データベース (database)

ウェブアバックエンド

クエリの最適化

123

設計と統合

165

統合

132-135

トランザクション

データ保護規則 (data protection laws)-

129

適応力 (adaptability)-

131

190

テキスト検索 (text search)-

-89

デザイン (design)

198

AI駆動デザインとUXパーソナライゼーション

Cursorを使う

93

-24

46

時代を超えたエンジニアリングスキル 自律型コーディングエージェント

-88

73

知的

173

-218-220

202

216

UI/UX-

デザインからコードへのプロセス

テスト (testing)

AI駆動プロトタイプ

単体テスト

AI 生成ウェブアプリケーション

AIツールを支援

AIによるテストの自動生成

APIのドキュメント

シャドウテスト

重要性

ジュニア開発者

保守性。

AI生成コード

本番環境

AIの安全網なし

効果的なプロンプト

コーディング

「何」だけではなく 「なぜ」と問う デプロイ (deployment)

テスト駆動デバッグ

-104

継続的なベストプラクティス

176

デプロイ前とデプロイ中

ベストプラクティス

173-177

デミニミス (de minimis)

デモ品質の罠 (demo-quality trap)-

同期 (synchronization)-

-180

74

統合 (integration)-

111

136

実システム

32

統合テスト (integration test)

120

AI 生成ウェブアプリケーション

-91

AI生成コード

139

107

効果的なフレームワークの構築

同時実行性 (concurrency)-

同時操作 (concurrent operations)-

117

-118

93, 164

-78

-212

透明性 (transparency)-

185

139-141

提案を統合するツール

登録ページ (sign-up page) -

ドメイン (domain)

デバッグ (debugging)

AI 支援コード-

110

215

132

-158-163

ソフトウェアエンジニアリングに特化 ドメイン固有自然言語

175

88, 106

精通

專門知識

85

87

(domain-specific natural language)- トランザクション (transaction)-

229

93

131

107

104

87

な行

二歩下がる (two steps back)・

認可 (authorization)

168

175

72

認証 (authentication)

149

AIにログインシステムの作成を依頼

Cline で REST APIを作成

149

11

不適切

21

6

246索引

認証情報 (credential)

ハードコードされた

AIが生成したデータベースクエリ

175

148

は行

バージョン管理 (version control) パーソナライズされたユーザー体験 (personalized user experience)パーティション分割 (partitioning) バイアス (bias)

AI駆動プロトタイプ

落とし穴

最適化-

管理-

76

219

39, 186-189, 192

87, 105, 163-166

セキュリティ監視

133

チューニング

反復的改良 (iterative refinement)・ 反復的なプロトタイプの改良

90

バイブコーディング (vibe coding)

AI 支援エンジニアリングとの違い

黄金律

78-80

10

業界の再構築

実験の考え方を促進

重要なこと

典型的なサイクル

制約

118

175

テスト

-217

-160

概要

(iterative prototype refinement)反復ループ (iterative loop)非一貫性 (inconsistency)-

112-115

会話によるコーディング

-45

07-4

-65, 102

3

232

112

非決定論 (nondeterminism)

ビジネスロジック (business logic)

17

未来を形作る

233-235

利点と限界

パスワード (password)

bcrypt

31-39

152

暗号学的にハッシュ

セキュリティ脆弱性

パターン (pattern)

152

151

101

16

AI

バックエンド (backend)

170-171

API開発パターン

CRUD操作

ウェブバックエンドー

日付の書式設定 (date formatting)

128-132

ウェブアプリケーション

エラー処理

非同期エージェント (async agent)

16

人とAIのハイブリッドチーム

人とAIのペアプログラミング

123

160

人と人のペアプログラミングとの違い 人の知性

フルスタックの統合

人と人のペアプログラミング

例

135-139

バックグラウンドコーディングエージェント

117

(background coding agent)

-195, 自律型バックグラウンドエージェントも参照

パッケージ (package)

管理の問題

102

-57

-162

32

-128-129

-75, 162

非同期調整のパラドックス

-196

(human-Al hybrid team)

ハルシネーション

153

パフォーマンス (performance)

153

176

83-86

-209

205

(human-Al pair programming) コードレビュー

77,84

(human-human pair programming)

172

77

173

ジュニア開発者とシニアの指導者

人とAIのペアプログラミングとの違い。 人に関連するデータ (human-related data) 人の監視 (human oversight)

95

77

15,73

188

AI駆動プロトタイピングツール。

コードレビュー

セキュリティ

112

155

本番に向けプロトタイプを進化させる。 人の貢献 (human contribution)

155

自動化を監視

シニアエンジニアと開発者

115

-83-98

索引 247

ジュニア開発者 フルスタック開発

189

92-97

ミドルエンジニア

137 ブルーグリーンデプロイ (blue-green deployment)-175

-86-92

批判的思考 (critical thinking)-

秘密 (secret)

87

148

秘密データ (secret data)

標準化 (standardization)

品質 (quality)

変わりやすい出力品質

AI 支援プロジェクト

AIと人の能力の利点を最大限に引き出す。

効率と効果

ユーザー

ブルートフォース (brute-force)

解決策

163

攻擊

テキスト検索

152

198

189

-38

デモ品質の

品質保証 (quality assurance)

フルスタックフロー (full stack flow)

プレースホルダー (placeholder)

-88

162

137

-78

ファズテスト (fuzz test)

103

-38 フレームワーク (framework) ウェブバックエンド-

74

最新のフレームワークの活用-

プログラミング (programming)

-78

-155, 215

フィードバック (feedback)

AIとのフィードバックループ

ジュニア開発者

自律システム

-45

フェアユース (fair use)

95

フォーマッター (formatter)

-212

161, 166

フォールバック (fallback)

130

新しい開発スタイルの課題

13-17, 110

19

17-19

プログラミング言語 (programming language)

7

180

深い推論モデル (deep reasoning model)

負荷テスト (load testing)-

負荷分散 (load balancing)

複雑さ (complexity)

コード出力

对処

分析

意図を持った

生産性、近づきやすさ、 本質の変化-

民主化

プロンプトで指定

複数モデルアプローチ (multimodel approach)

変わりやすい出力品質

セキュリティに重点を置く

どのモデルでも使える実践的なヒント

トレーニングカットオフを補う更新

不公平 (unfairness)

復旧手順 (recovery procedure)

フック (hook)

-32

未來

43

-228-231

プロジェクト管理 (project management) プロジェクトレベル (project level)-

-169

-26

高度なプロンプティング

-220-223

201

プロトタイピング (prototyping)

160

AI駆動ツールとテクニック

109-121

AI支援コーディングによる強化

90

-127

機能とプロトタイピング

37

-32

プロパティベーステスト (property-based testing)160

61

168

フロントエンド (frontend)

-30

ウェブアプリケーション

エラー処理

163

開発パターン

38

157

123

160

126-128

-27

156

テスト

バックエンドの統合

139

リファクタリング

192

135-139

プロンプティングテクニック (prompting techniques)

-90

プライバシー (privacy)

118

ReAct-

128

50-61

-60

高度なプロンプティング

コンテキストに応じたプロンプティング

懸念

自己一貫性

39

61-66

-56

思考の連鎖 (CoT) プロンプティング

58

53-55

89

248 索引

ゼロショットプロンプティング

メタプログラミング

役割プロンプティング

-57

55

ワンショットプロンプティング

プロンプト (prompt)

51-52

AIとの効果的なコミュニケーション

技術革新-

実際のAI活用方法

92-97

51

41

AIの解釈を理解する

曖昧さ

アンチパターン

-99

AIの明確化や出力を無視する

曖昧な参照

38

曖昧な成功基準

173

65

曖昧なプロンプト

過剰なプロンプト

97

-71-78

115-119

非一貫性。

エンジニアリング

コミュニケーション

作成中のコード

本番に向けてプロトタイプを進化させる。 役割の進化

63-66 変数 (variable)

64

-63

-83

107

65

質問を見落とす

64

64

65

41-42

-190

-166-171

-168

96

ジュニア開発者の開発スキル

責任ある AI

反復的な改良

保守 (maintenance)-

保守性 (maintainability)

217

AI駆動コードベースにおける確保 コード出力

166

ジュニア開発者

95

192

プロンプトアーティストとAIオーケストラ指揮者との

違い

理解

変更 (change)

編集者としての開発者 (developers as editors)

AIとともに成長する

187

テスト

フォローアップ

-94

プロンプト作成中の考慮事項 リファクタリング

113

-105

ま行

12

文化的バイアス (cultural bias)

15

186

文書化 (documentation)

AI駆動コードベース

マルチモーダル処理 (multimodal processing) 未処理の例外 (unhandled exception)-

ウェブバックエンドAPI

169

本番に向けてプロトタイプを進化

132

117

ペアプログラマー (pair programmer)

ベストプラクティス

74,77

ペアプログラミング (pair programming)

AI ペアプログラマーとAIアシスタント開発者の違い

ジュニア開発者とシニアの指導者

レビュー、 改良、 所有

人と人vs人とAI

人種、性別、年齢-

101

包括性 (inclusivity)-

並列性 (parallelism)

法的要件 (legal requirements) -

-188

-161

-102

ミドルエンジニア (midlevel engineer)

エンジニアを参照

201

ベネトレーションテスト (penetration testing)

26

メタプログラミング (metaprogramming). メモリ (memory)

-57

95

管理

93

77

パフォーマンス最適化

目標 (goal)

164

モジュール性 (modularity)

11-10

モデル (model)

166

べき等 (idempotence)

主なモデル。

26-28

28-30

改善による30% ギャップの縮小

77

-169

166

165

カテゴリー

160

限界を知る

-225

155

26

コンテキストウィンドウのサイズ

スタイルについての注意

-62

-50

19

索引 249

221

タスクに適したモデルを選択

27

ニーズに合ったモデルを選択

-30

複数のAIモデルを組み合わせて強みを最大化

-203-206

モデルカード (model card)

191

問題解決 (problem solving)

93

や行

テスト

役割 (role)

インストラクター

エンジニアリングチーム

リソース管理 (resource management) リファクタリング (refactoring)

雜萩的。

コード出力

168

-168

-161

保守性

リンター (linter)

105

倫理的課題 (ethical implication)

55

227

開発者:

コード生成

-107

~プロンプティング

ユーザー列挙 (user enumeration)

-90

ユースケース (use case)

12, 161, 166

要件 (requirement)

-179-194,232

AIによる解釈

-179-184

プロンプトに含める 分析-

知的財產。

ライブラリ (library)

ラバーダックデバッグ (rubber duck debug)

ランブック (runbook)-

透明性と帰属表示-

リーダーシップ (leadership)

リスク分析と管理 (risk analysis and management)

-185-186

14-17

編集者としての開発者

伝わるプロンプト

ライセンス (licensing)

バイアスと公平性

レイアウト (layout)-

126

-55

-186-189

レート制限 (rate limiting)-

-151

-83 レジリエンス (resilience)

151 レプリケーション (replication) レポート (reporting)-

169

90

-31

ロールバック計画 (rollback plan)-

36 ロギング (logging)

44

-102 30,46

199

174

最適化:

テスト

-96

157

わ行

161

-153, 179

ら行

ワークフロー統合型エージェント (workflow-integrated agent) 悪いプロンプト (poor prompt) ワンショットプロンプティング

207

-176

49

(one-shot prompting)-

51,63

-85

ステートフルな会話との比較

63

43

著者紹介

Addy Osmani (アディオスマニ)

Googleのシニアエンジニアリングリーダーで、 開発者体験、パフォーマンス、AI駆動のソフト ウェア開発ツールの開発に携わる。ウェブテクノロジーの構築において25年の経験を持ち、ソ フトウェアエンジニアリングのベストプラクティスに関する複数の書籍を執筆している。

AI駆動開発者ツールに幅広く携わり、 Cursor Cline, GitHub Copilot, Bolt, v0、 Lovable, Claude Codeのような新しいプラットフォームのテストと評価を行ってきた。 AI 支援ソフトウェア開発に関する彼の著作は何千人もの開発者に影響を与えている。 Google Chromeにおける彼のリーダーシップは、ウェブパフォーマンスとAI拡張開発者ワークフロー の未来を形作るのに寄与している。

本書にはソフトウェアエンジニアリングにおける彼の深い専門知識と、AI駆動コーディングア シスタントの開発者体験が凝縮されており、 開発者が日々のワークフローにAIを統合し、急速 に変化するソフトウェア開発の状況に適応するための実践的な戦略を提供する。

訳者紹介

佐藤直生 (さとう なおき)

日本オラクル株式会社における、 Java EE アプリケーションサーバやミドルウェアのソフト ウェアエンジニア/テクノロジーエバンジェリストとしての経験を経て、現在は Microsoft Corporation で、 パブリッククラウドプラットフォーム 「Microsoft Azure」のプリンシパルソ フトウェアエンジニアリングマネージャーとして活動。 訳書、 監訳書に「グラフデータベース」、 「プロダクションレディマイクロサービス」、 「Head First デザインパターン 第2版」、「マイク ロサービスアーキテクチャ第2版｣、 ｢LLMのプロンプトエンジニアリング」(以上オライリー・ ジャパン)、共著書に「RDB技術者のためのNoSQLガイド」 (秀和システム)、 「Azureテクノロ ジ入門 2019」 (日経BP) などがある。

查読協力

大橋真也 (おおはし しんや)

表紙の説明

表紙の動物はカベバシリ (英語名wallcreeper、 学名 Tichodroma muraria) で、 ヨーロッパ、 中東アジアの内陸の崖や山頂に生息しています。 飛翔中のカベバシリは大きな蝶のように見えると 言われますが、岩肌を背にして静止している姿を見つけるのは難しいです。 羽の色は鮮やかな赤色 で、羽の先端は黒と白です。 繁殖期のオスは首が黒くなります。

成鳥は体長約15センチ、体重は約24~32グラムです。 通常は年に1回、 岩の隙間にコケと草で 作ったお椀型の巣に3~5個の卵を産みます。 主食は昆虫です。

国際自然保護連合(IUCN) のレッドリストでは、 カベバシリの保全状況は「軽度懸念 (Least Concern)」 とされています。 オライリーの表紙を飾る動物の多くは絶滅の危機に瀕していますが、 それらはいずれも世界にとって重要です。

表紙のイラストは 「Lydekker's Royal Natural History』 に掲載された古い銅版画をもとにJose Marzan Jr.が描いています。 シリーズデザインはEdie Freedman, Ellie Volckhausen, Karen Montgomery が担当しました。



バイブコーディングを超えて -AI時代を生き抜く開発者の未来

2025年12月25日 初版第1刷発行

著

者

Addy Osmani (アディオスマニ)

訳

者

佐藤 直生 (さとう なおき)

発行人 制 作

ティム・オライリー

印刷 製本

スタヂオ ポップ .

発行所

株式会社平河工業社

株式会社オライリージャパン

〒105-0003 東京都港区西新橋一丁目18番6号

TEL (03)6257-2177

発売元

FAX (03)6257-3380

電子メール japan@oreilly.co.jp

株式会社オーム社

〒101-8460 東京都千代田区神田錦町3-1

TEL (03)3233-0641 (代表)

FAX (03)3233-3440

Printed in Japan (ISBN978-4-8144-0142-0) 落丁 乱丁の際はお取り替えいたします。

本書は著作権上の保護を受けています。 本書の一部あるいは全部について、 株式会社オライリー・ジャパ ンの承諾を得ずに、著作権法の範囲を超えて無断で複写、複製することは禁じられています。