# Claude Code Skills 完全理解ガイド

> 投稿・note記事の内容を公式ドキュメントと照らし合わせながら整理

---

## 1. 核心的な理解ポイント

### 1.1 Skillsとスラッシュコマンドの本質的な違い

| 観点 | スラッシュコマンド | Skills |
|------|-------------------|--------|
| **コンテキスト** | メインに「追加」する | 段階的ロードで「必要な時だけ」読み込む |
| **分離** | なし（全部同じコンテキスト） | Task単位でコンテキストを分離可能 |
| **環境** | 特定のエディタ内 | Claude Code/Cursor/API横断 |
| **設計思想** | 「プロンプトの保存」 | 「Context Engineeringのフレームワーク」 |

### 1.2 Context Engineeringとは

> LLMがタスクをちゃんと完走できるように、「どの情報」「どのツール」を「どのタイミング」で渡すかを設計すること

**記事の核心メッセージ:**
- モデルの賢さより「コンテキストの設計」がボトルネック
- 失敗の多くは「モデルの性能」ではなく「文脈の設計ミス」

---

## 2. Skillsのディレクトリ構造と役割

```
.claude/skills/{skill-name}/
├── SKILL.md                    # ワークフロー全体の定義（指揮者）
├── agents/                     # Task仕様書（記事独自の構造）
│   ├── article-research.md
│   ├── article-writer.md
│   └── article-reviewer.md
├── references/                 # 外部化された知識（教科書置き場）
│   ├── writing-guide.md
│   ├── structure-templates.md
│   └── examples/
│       ├── good-article.md
│       └── bad-article.md
└── scripts/                    # 機械的処理の外出し
    └── format_article.py
```

### 2.1 SKILL.md（必須）

- **役割**: ワークフロー全体の流れを定義する「司令塔」
- **内容**: メタデータ（name, description）+ ステップバイステップの指示
- **サイズ目安**: 500行以下（詳細は別ファイルへ）

### 2.2 agents/*.md（記事の独自設計）

- **役割**: 各Taskの「仕様書」
- **重要**: これは公式の `.claude/agents/` とは異なる
  - 公式の `.claude/agents/`: サブエージェント定義（独立したcontext）
  - 記事の `skills/agents/`: Task実行時の仕様書（Skill内部で使用）
- **設計原則**:
  - 役割・入力・出力・制約だけを書く
  - 知識は `references/` に逃がす
  - できるだけ軽く設計する

### 2.3 references/（知識の外部化）

- **役割**: 「必要なときにだけ取りに行く」教科書置き場
- **設計原則**:
  - 1ファイル1トピック
  - 「いつ読むか」をTask仕様書に明記
  - 具体例は別フォルダ（examples/）に分離
- **効果**: コンテキスト消費を抑制

### 2.4 scripts/（自動化）

- **役割**: LLMにやらせるとコスパが悪い処理を外出し
- **例**: ファイル整形、CSV集計、ログ処理
- **効果**: トークン消費ゼロ + 100%再現性

---

## 3. 段階的ロード（Progressive Disclosure）

```
┌─────────────────────────────────────────┐
│ Discovery: メタデータのみ              │
│ (~100 tokens/Skill)                     │
│ - name と description                   │
└─────────────────────────────────────────┘
                    ↓
       [ユーザー要求とdescriptionのマッチング]
                    ↓
┌─────────────────────────────────────────┐
│ Loading: SKILL.md本体                   │
│ (~5k tokens未満)                        │
│ - ワークフロー定義                      │
└─────────────────────────────────────────┘
                    ↓
       [Taskを実行する直前]
                    ↓
┌─────────────────────────────────────────┐
│ Execution: リソース・スクリプト         │
│ - agents/*.md（Task仕様書）             │
│ - references/（必要な知識）             │
│ - scripts/（出力のみ消費）              │
└─────────────────────────────────────────┘
```

**重要な気づき（記事から）:**
- `skills/agents/*.md` は段階的ロードの"候補探索"には使われない
- Task実行直前に、そのTask用の仕様書として一気に読まれる
- だから「仕様だけを書く」「知識はreferencesに逃がす」が効く

---

## 4. Taskによるコンテキスト分離

### 4.1 Taskとは

> Claudeがその場で立ち上げて、仕事が終わったら即解散する「一時労働者」

- 各Taskは独立したコンテキストウィンドウ（~200kトークン）
- 最大10個程度まで並列起動可能
- Taskが終わると中身ごと消えて、結果だけがメインに返る

### 4.2 なぜコンテキスト分離が重要か

**全部1コンテキストに詰め込むと:**
1. 判断が濁る（不要な情報が多すぎる）
2. コンテキスト不足による劣化（古い情報が圧縮・削除される）
3. 長いワークフローで破綻する

**Task分離すると:**
- メインエージェントは「司令塔」に専念
- 重たい作業はTask側で消費
- メインのコンテキストはスカスカに保てる

### 4.3 技術記事ライティングの例

```
ユーザー依頼
    ↓
[SKILL.md がワークフロー指揮]
    ↓
┌──────────────────┐
│ リサーチTask     │ → Web検索100ページ → 要約だけ返す → Task消滅
└──────────────────┘
    ↓
┌──────────────────┐
│ 執筆Task         │ → 何度も書き直し → 最終ドラフトだけ返す → Task消滅
└──────────────────┘
    ↓
┌──────────────────┐
│ レビューTask     │ → チェック結果だけ返す → Task消滅
└──────────────────┘
    ↓
メインエージェントには「結果」だけが残る
```

---

## 5. Agentic Workflowの核心

### 5.1 静的ワークフロー vs Agentic

```
静的なワークフロー: A → B → C の固定パイプライン

Agentic: A → B → （Bの結果で分岐） → C1 or C2 → D
```

### 5.2 業種別分岐の例（tomoyukiさんの投稿より）

```
[ fetch、業種分解、レポート]

業種によって次の処理を変える場合に、LLMの実行結果で分岐してQueueに追加：

1. 製造業の場合
[ fetch、業種分解、製造業向け観点、レポート]

2. IT系の場合
[ fetch、業種分解、IT向け観点、レポート]
```

**Skillsでこれを実現するには:**
1. SKILL.md で分岐ロジックを定義
2. 業種判定後、適切な `agents/manufacturing.md` or `agents/it-industry.md` を呼び出す
3. 各TaskはそのドメインのKnowledge（`references/`）を参照

---

## 6.「売れる営業マン」のロジックをコピーする

### 6.1 記事の最後にある「令和の新人教育」

> 売れる営業マンの思考ロジックをスキルでコピして、売れない営業マンもできるになる

**これはつまり:**
- ベテランが「ここを調べる」というポイントをTask仕様書に言語化
- 業種ごとの観点の違いを条件分岐で設計
- 新人はSkillを実行するだけで、ベテランと同じ思考フローを辿れる

### 6.2 思考プロセスのインフラ化

```
[ベテラン営業の頭の中]
    ↓ 言語化
[SKILL.md: ワークフロー定義]
    ↓
[agents/*.md: 各フェーズの判断基準]
    ↓
[references/: 業界知識・事例集]
    ↓
[新人がSkillを実行]
    ↓
[ベテランと同じ思考フローを辿る]
```

---

## 7. 公式ドキュメントとの照らし合わせ

### 一致している点

1. Skills = instructions + scripts + references の束
2. 段階的ロードの3段階（Discovery → Loading → Execution）
3. コンテキスト効率のための設計
4. Model-invoked（自動起動）の仕組み

### 記事独自の解釈・拡張

1. `skills/agents/*.md` というディレクトリ構造
   - 公式ドキュメントでは明示されていない
   - 記事著者が実践的に編み出した構造

2. Taskの「Queue」的な使い方
   - 業種によって次の処理を動的に差し込む
   - LLM実行結果で分岐してQueueに追加

3. 「売れる営業マンの思考ロジックをSkillでコピー」
   - ビジネス応用の視点

---

## 8. 実践的な設計指針

### 8.1 agents/*.md（Task仕様書）の書き方

```markdown
# 執筆 Task 仕様書

## あなたの役割
リサーチ結果をもとに、技術記事の本文を書く。

## 入力
- リサーチTaskから渡された要約
- 想定読者
- 記事の目的

## 作業の前に読むもの
- references/writing-guide.md（文体のルール確認）

## 必要に応じて読むもの
- references/examples/good-article.md

## 出力
- 完成した記事本文
- 使用した構成パターンのメモ
```

**ポイント:**
- 知識の「中身」は書かない（パスだけ）
- 「何を返さないか」も明記する
- ファイル自体をできるだけ軽くする

### 8.2 references/の設計

- 1ファイル1トピック（writing-guide.md / structure-templates.md / seo-guidelines.md）
- 「いつ読むべきか」をTask側で指定
- 具体例は examples/ フォルダに分離

### 8.3 scripts/の活用

LLMにやらせると微妙な処理:
- 大量のファイルを機械的にいじる
- ログやCSVの集計・変換
- Markdown整形

→ Pythonスクリプトに落として `scripts/` に配置

---

## 9. まとめ：Skillsの本当の価値

> Skills = Task設計 × コンテキスト設計 × 自動化設計 を束ねるフレームワーク

### スラッシュコマンドとの決定的な違い

- **スラッシュコマンド**: 「保存されたプロンプトを貼る」
- **Skills**: 「処理そのものを別コンテキストに分離して、結果だけ戻す」

### Skillsをちゃんと使うための最低限のステップ

1. タスクを分解して「どこでTaskを区切るか」を決める
2. SKILL.mdにワークフロー全体の流れを書く
3. 各フェーズをTaskとして切り出し、agents/*.mdを用意
4. 知識・ルール・テンプレをreferences/へ逃がす
5. 機械的処理はscripts/でコード化

### 最終的なメッセージ

> Skillsは「LLMを便利にする機能」というより、
> **自分の思考プロセスを"インフラ化していくための器"**

---

## 10. 次のステップ（実装時）

1. 既存のワークフローを1つ選んで分解
2. ディレクトリ構造を作成
3. SKILL.md → agents/*.md → references/ → scripts/ の順で作成
4. 実際に動かしてコンテキスト消費を確認
5. 必要に応じて調整

---

## 参考リンク

- 原文記事（note）: そらさんの記事
- tomoyukiさんの投稿: Agentic Workflowの解説
- 公式ドキュメント: Claude Code Skills

---

*作成日: 2026-01-02*
*このファイルは `C:\Users\user\.claude\plans\cosmic-tumbling-gray.md` の内容を整理したものです*
